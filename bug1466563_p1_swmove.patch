# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7897da649dd8fb8231fd3f4df67594a36050df5c
Bug 1466563 P1 Fix std::move warnings in dom/serviceworkers. r=asuth

diff --git a/dom/serviceworkers/ServiceWorkerDescriptor.cpp b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
@@ -98,17 +98,17 @@ ServiceWorkerDescriptor::PrincipalInfo()
   return mData->principalInfo();
 }
 
 nsCOMPtr<nsIPrincipal>
 ServiceWorkerDescriptor::GetPrincipal() const
 {
   AssertIsOnMainThread();
   nsCOMPtr<nsIPrincipal> ref =  PrincipalInfoToPrincipal(mData->principalInfo());
-  return std::move(ref);
+  return ref.forget();
 }
 
 const nsCString&
 ServiceWorkerDescriptor::Scope() const
 {
   return mData->scope();
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -319,51 +319,51 @@ ServiceWorkerManager::StartControllingCl
   const ServiceWorkerDescriptor& active =
     aRegistrationInfo->GetActive()->Descriptor();
 
   auto entry = mControlledClients.LookupForAdd(aClientInfo.Id());
   if (entry) {
     RefPtr<ServiceWorkerRegistrationInfo> old =
       entry.Data()->mRegistrationInfo.forget();
 
-    ref = std::move(entry.Data()->mClientHandle->Control(active));
+    ref = entry.Data()->mClientHandle->Control(active);
     entry.Data()->mRegistrationInfo = aRegistrationInfo;
 
     if (old != aRegistrationInfo) {
       StopControllingRegistration(old);
       aRegistrationInfo->StartControllingClient();
     }
 
     Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
 
-    return std::move(ref);
+    return ref.forget();
   }
 
   RefPtr<ClientHandle> clientHandle =
     ClientManager::CreateHandle(aClientInfo,
                                 SystemGroup::EventTargetFor(TaskCategory::Other));
 
-  ref = std::move(clientHandle->Control(active));
+  ref = clientHandle->Control(active);
 
   aRegistrationInfo->StartControllingClient();
 
   entry.OrInsert([&] {
     return new ControlledClientData(clientHandle, aRegistrationInfo);
   });
 
   RefPtr<ServiceWorkerManager> self(this);
   clientHandle->OnDetach()->Then(
     SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
     [self = std::move(self), aClientInfo] {
       self->StopControllingClient(aClientInfo);
     });
 
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
 
-  return std::move(ref);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::StopControllingClient(const ClientInfo& aClientInfo)
 {
   auto entry = mControlledClients.Lookup(aClientInfo.Id());
   if (!entry) {
     return;
diff --git a/dom/serviceworkers/ServiceWorkerRegistrar.cpp b/dom/serviceworkers/ServiceWorkerRegistrar.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrar.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrar.cpp
@@ -1276,17 +1276,17 @@ ServiceWorkerRegistrar::GetShutdownPhase
   // memory), and there's no point in continuing startup. Include as much
   // information as possible in the crash report.
   RELEASE_ASSERT_SUCCEEDED(rv, "async shutdown service");
 
 
   nsCOMPtr<nsIAsyncShutdownClient> client;
   rv = svc->GetProfileBeforeChange(getter_AddRefs(client));
   RELEASE_ASSERT_SUCCEEDED(rv, "profileBeforeChange shutdown blocker");
-  return std::move(client);
+  return client.forget();
 }
 
 #undef RELEASE_ASSERT_SUCCEEDED
 
 void
 ServiceWorkerRegistrar::Shutdown()
 {
   AssertIsOnBackgroundThread();
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
@@ -22,17 +22,17 @@ ServiceWorkerRegistrationDescriptor::New
   Maybe<IPCServiceWorkerDescriptor> result;
   if (mData->installing().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(mData->installing().get_IPCServiceWorkerDescriptor());
   } else if (mData->waiting().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(mData->waiting().get_IPCServiceWorkerDescriptor());
   } else if (mData->active().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(mData->active().get_IPCServiceWorkerDescriptor());
   }
-  return std::move(result);
+  return result;
 }
 
 ServiceWorkerRegistrationDescriptor::ServiceWorkerRegistrationDescriptor(
                                     uint64_t aId,
                                     nsIPrincipal* aPrincipal,
                                     const nsACString& aScope,
                                     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : mData(MakeUnique<IPCServiceWorkerRegistrationDescriptor>())
@@ -133,17 +133,17 @@ ServiceWorkerRegistrationDescriptor::Pri
   return mData->principalInfo();
 }
 
 nsCOMPtr<nsIPrincipal>
 ServiceWorkerRegistrationDescriptor::GetPrincipal() const
 {
   AssertIsOnMainThread();
   nsCOMPtr<nsIPrincipal> ref =  PrincipalInfoToPrincipal(mData->principalInfo());
-  return std::move(ref);
+  return ref;
 }
 
 const nsCString&
 ServiceWorkerRegistrationDescriptor::Scope() const
 {
   return mData->scope();
 }
 
@@ -152,54 +152,54 @@ ServiceWorkerRegistrationDescriptor::Get
 {
   Maybe<ServiceWorkerDescriptor> result;
 
   if (mData->installing().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(ServiceWorkerDescriptor(
       mData->installing().get_IPCServiceWorkerDescriptor()));
   }
 
-  return std::move(result);
+  return result;
 }
 
 Maybe<ServiceWorkerDescriptor>
 ServiceWorkerRegistrationDescriptor::GetWaiting() const
 {
   Maybe<ServiceWorkerDescriptor> result;
 
   if (mData->waiting().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(ServiceWorkerDescriptor(
       mData->waiting().get_IPCServiceWorkerDescriptor()));
   }
 
-  return std::move(result);
+  return result;
 }
 
 Maybe<ServiceWorkerDescriptor>
 ServiceWorkerRegistrationDescriptor::GetActive() const
 {
   Maybe<ServiceWorkerDescriptor> result;
 
   if (mData->active().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(ServiceWorkerDescriptor(
       mData->active().get_IPCServiceWorkerDescriptor()));
   }
 
-  return std::move(result);
+  return result;
 }
 
 Maybe<ServiceWorkerDescriptor>
 ServiceWorkerRegistrationDescriptor::Newest() const
 {
   Maybe<ServiceWorkerDescriptor> result;
   Maybe<IPCServiceWorkerDescriptor> newest(NewestInternal());
   if (newest.isSome()) {
     result.emplace(ServiceWorkerDescriptor(newest.ref()));
   }
-  return std::move(result);
+  return result;
 }
 
 namespace {
 
 bool
 IsValidWorker(const OptionalIPCServiceWorkerDescriptor& aWorker,
               const nsACString& aScope,
               const mozilla::ipc::ContentPrincipalInfo& aContentPrincipal)
