# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  29f08616599d68c7168d1a1c5df2db34b2ffa94f
Bug 1329693 Gracefully handle immediate ActorDestroy() in CacheStorage::ActorCreated(). r=asuth

diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -496,49 +496,54 @@ CacheStorage::WrapObject(JSContext* aCon
 {
   return mozilla::dom::CacheStorageBinding::Wrap(aContext, this, aGivenProto);
 }
 
 void
 CacheStorage::ActorCreated(PBackgroundChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(mStatus));
+  MOZ_DIAGNOSTIC_ASSERT(!mActor);
   MOZ_DIAGNOSTIC_ASSERT(aActor);
 
   if (NS_WARN_IF(mWorkerHolder && mWorkerHolder->Notified())) {
     ActorFailed();
     return;
   }
 
   // WorkerHolder ownership is passed to the CacheStorageChild actor and any
   // actors it may create.  The WorkerHolder will keep the worker thread alive
   // until the actors can gracefully shutdown.
-  CacheStorageChild* newActor = new CacheStorageChild(this, mWorkerHolder);
+  mActor = new CacheStorageChild(this, mWorkerHolder);
+  mWorkerHolder = nullptr;
+
+  // Pass the actor construction message to the parent.  Note, if this fails
+  // we can get DestroyInternal() and ActorFailed() called synchronously.  This
+  // will null out mActor and set an error mStatus.
   PCacheStorageChild* constructedActor =
-    aActor->SendPCacheStorageConstructor(newActor, mNamespace, *mPrincipalInfo);
+    aActor->SendPCacheStorageConstructor(mActor, mNamespace, *mPrincipalInfo);
 
-  if (NS_WARN_IF(!constructedActor)) {
-    ActorFailed();
+  if (NS_WARN_IF(NS_FAILED(mStatus))) {
+    MOZ_DIAGNOSTIC_ASSERT(!mActor);
     return;
   }
 
-  mWorkerHolder = nullptr;
-
-  MOZ_DIAGNOSTIC_ASSERT(constructedActor == newActor);
-  mActor = newActor;
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(constructedActor == mActor);
 
   MaybeRunPendingRequests();
   MOZ_DIAGNOSTIC_ASSERT(mPendingRequests.IsEmpty());
 }
 
 void
 CacheStorage::ActorFailed()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
-  MOZ_DIAGNOSTIC_ASSERT(!NS_FAILED(mStatus));
+  MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(mStatus));
 
   mStatus = NS_ERROR_UNEXPECTED;
   mWorkerHolder = nullptr;
 
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     nsAutoPtr<Entry> entry(mPendingRequests[i].forget());
     entry->mPromise->MaybeReject(NS_ERROR_UNEXPECTED);
   }
