# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  566b4fbdb429a5b5e157c6109f57732621b820f0
Bug 1093357 P2 Add an RAII type to safely handle serialized stream actors. r=jld

diff --git a/ipc/glue/InputStreamParamsOrSendStream.ipdlh b/ipc/glue/InputStreamParamsOrSendStream.ipdlh
new file mode 100644
--- /dev/null
+++ b/ipc/glue/InputStreamParamsOrSendStream.ipdlh
@@ -0,0 +1,25 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PSendStream;
+include InputStreamParams;
+
+namespace mozilla {
+namespace ipc {
+
+struct InputStreamParamsOrSendStream
+{
+  OptionalInputStreamParams optionalStream;
+  OptionalFileDescriptorSet optionalFds;
+  nullable PSendStream optionalSendStream;
+};
+
+union OptionalInputStreamParamsOrSendStream
+{
+  InputStreamParamsOrSendStream;
+  void_t;
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -2,19 +2,24 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InputStreamUtils.h"
 
 #include "nsIIPCSerializableInputStream.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/PContentChild.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/ipc/BlobParent.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/SendStream.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
 #include "nsID.h"
 #include "nsIXULRuntime.h"
 #include "nsMIMEInputStream.h"
 #include "nsMultiplexInputStream.h"
 #include "nsNetCID.h"
 #include "nsStringStream.h"
@@ -177,10 +182,294 @@ DeserializeInputStream(const OptionalInp
 
     default:
       MOZ_ASSERT(false, "Unknown params!");
   }
 
   return stream.forget();
 }
 
+namespace {
+
+// The SerializeOrSendInputStream() and CleanupSendInputStreamParamsOrSendStream
+// functions could be externally exposed.  For now, though, keep them private
+// to encourage use of the safer RAII AutoIPCStreamChild class.
+
+template<typename M>
+void
+SerializeOrSendInputStream(nsIInputStream* aStream,
+                           InputStreamParamsOrSendStream& aValue,
+                           M* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+
+  // First attempt simple stream serialization
+  nsCOMPtr<nsIIPCSerializableInputStream> serializable =
+    do_QueryInterface(aStream);
+  if (serializable) {
+    InputStreamParams params;
+    AutoTArray<FileDescriptor, 4> fds;
+
+    serializable->Serialize(params, fds);
+
+    if (params.type() == InputStreamParams::T__None) {
+      MOZ_CRASH("Serialize failed!");
+    }
+
+    aValue.optionalStream() = params;
+
+    if (!fds.IsEmpty()) {
+      PFileDescriptorSetChild* fdSet =
+        aManager->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        Unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+
+      aValue.optionalFds() = fdSet;
+    }
+
+    return;
+  }
+
+  // As a fallback, attempt to stream the data across using a SendStream
+  // actor.  This will fail for blocking streams.
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(aStream);
+  aValue.optionalSendStreamChild() =
+    SendStreamChild::Create(asyncStream, aManager);
+
+  if (!aValue.optionalSendStreamChild()) {
+    MOZ_CRASH("SendStream creation failed!");
+  }
+}
+
+template<typename M>
+void
+SerializeOrSendInputStream(nsIInputStream* aStream,
+                           OptionalInputStreamParamsOrSendStream& aValue,
+                           M* aManager)
+{
+  if (!aStream) {
+    aValue = void_t();
+    return;
+  }
+
+  aValue = InputStreamParamsOrSendStream(void_t(), void_t(), nullptr, nullptr);
+  SerializeOrSendInputStream(aStream, aValue.get_InputStreamParamsOrSendStream(),
+                             aManager);
+}
+
+void
+CleanupInputStreamParamsOrSendStream(InputStreamParamsOrSendStream& aValue,
+                                     bool aConsumedByIPC)
+{
+  // Cleanup file descriptors if necessary
+  if (aValue.optionalFds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    AutoTArray<FileDescriptor, 4> fds;
+
+    FileDescriptorSetChild* fdSetActor = static_cast<FileDescriptorSetChild*>(
+      aValue.optionalFds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    if (!aConsumedByIPC) {
+      Unused << fdSetActor->Send__delete__(fdSetActor);
+    }
+
+    // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
+    // unconditionally forget them here.  The fds themselves are auto-closed in
+    // ~FileDescriptor since they originated in this process.
+    fdSetActor->ForgetFileDescriptors(fds);
+  }
+
+  if (aValue.optionalSendStreamChild()) {
+    auto sendStream =
+      static_cast<SendStreamChild*>(aValue.optionalSendStreamChild());
+
+    if (!aConsumedByIPC) {
+      sendStream->StartDestroy();
+      return;
+    }
+
+    // If we the SendStream was taken to be sent to the parent, then we need to
+    // start it before forgetting about it.
+    sendStream->Start();
+  }
+}
+
+void
+CleanupInputStreamParamsOrSendStream(OptionalInputStreamParamsOrSendStream& aValue,
+                                     bool aConsumedByIPC)
+{
+  if (aValue.type() == OptionalInputStreamParamsOrSendStream::Tvoid_t) {
+    return;
+  }
+
+  CleanupInputStreamParamsOrSendStream(aValue.get_InputStreamParamsOrSendStream(),
+                                       aConsumedByIPC);
+}
+
+} // anonymous namespace
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const InputStreamParamsOrSendStream& aValue)
+{
+  auto sendStream =
+    static_cast<SendStreamParent*>(aValue.optionalSendStreamParent());
+  if (sendStream) {
+    return sendStream->TakeReader();
+  }
+
+  AutoTArray<FileDescriptor, 4> fds;
+  if (aValue.optionalFds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+    FileDescriptorSetParent* fdSetActor = static_cast<FileDescriptorSetParent*>(
+      aValue.optionalFds().get_PFileDescriptorSetParent());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    if (!fdSetActor->Send__delete__(fdSetActor)) {
+      // child process is gone, warn and allow actor to clean up normally
+      NS_WARNING("Failed to delete fd set actor.");
+    }
+  }
+
+  return DeserializeInputStream(aValue.optionalStream(), fds);
+}
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const OptionalInputStreamParamsOrSendStream& aValue)
+{
+  if (aValue.type() == OptionalInputStreamParamsOrSendStream::Tvoid_t) {
+    return nullptr;
+  }
+
+  return DeserializeInputStream(aValue.get_InputStreamParamsOrSendStream());
+}
+
+AutoIPCStreamChild::AutoIPCStreamChild()
+  : mInlineValue(void_t())
+  , mValue(nullptr)
+  , mOptionalValue(&mInlineValue)
+  , mTaken(false)
+{
+}
+
+AutoIPCStreamChild::AutoIPCStreamChild(InputStreamParamsOrSendStream& aTarget)
+  : mInlineValue(void_t())
+  , mValue(&aTarget)
+  , mOptionalValue(nullptr)
+  , mTaken(false)
+{
+  *mValue = InputStreamParamsOrSendStream(void_t(), void_t(), nullptr, nullptr);
+}
+
+AutoIPCStreamChild::AutoIPCStreamChild(OptionalInputStreamParamsOrSendStream& aTarget)
+  : mInlineValue(void_t())
+  , mValue(nullptr)
+  , mOptionalValue(&aTarget)
+  , mTaken(false)
+{
+  *mOptionalValue = void_t();
+}
+
+AutoIPCStreamChild::~AutoIPCStreamChild()
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  if (mValue) {
+    CleanupInputStreamParamsOrSendStream(*mValue, mTaken);
+  } else {
+    CleanupInputStreamParamsOrSendStream(*mOptionalValue, mTaken);
+  }
+}
+
+void
+AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
+                                    PContentChild* aManager)
+{
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeOrSendInputStream(aStream, *mValue, aManager);
+  } else {
+    SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
+  }
+}
+
+void
+AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
+                                    PBackgroundChild* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeOrSendInputStream(aStream, *mValue, aManager);
+  } else {
+    SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
+  }
+}
+
+bool
+AutoIPCStreamChild::IsSet() const
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  if (mValue) {
+    return mValue->optionalSendStreamChild() != nullptr ||
+           mValue->optionalStream().type() != OptionalInputStreamParams::Tvoid_t;
+  } else {
+    return mOptionalValue->type() !=
+           OptionalInputStreamParamsOrSendStream::Tvoid_t;
+  }
+}
+
+InputStreamParamsOrSendStream&
+AutoIPCStreamChild::TakeValue()
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(IsSet());
+
+  mTaken = true;
+
+  if (mValue) {
+    return *mValue;
+  }
+
+  InputStreamParamsOrSendStream& value =
+    mOptionalValue->get_InputStreamParamsOrSendStream();
+
+  // We should never have the parent SendStream actor set on the child side.
+  MOZ_ASSERT(value.optionalSendStreamParent() == nullptr);
+
+  // We must have a send stream actor or a serialized stream
+  MOZ_ASSERT(value.optionalSendStreamChild() != nullptr ||
+             value.optionalStream().type() != OptionalInputStreamParams::Tvoid_t);
+
+  // If the file descriptors are set, then we must have a serialized stream.
+  MOZ_ASSERT_IF(value.optionalFds().type() != OptionalFileDescriptorSet::Tvoid_t,
+                value.optionalStream().type() != OptionalInputStreamParams::Tvoid_t);
+
+  return value;
+}
+
+OptionalInputStreamParamsOrSendStream&
+AutoIPCStreamChild::TakeOptionalValue()
+{
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!mValue);
+  MOZ_ASSERT(mOptionalValue);
+  mTaken = true;
+  return *mOptionalValue;
+}
+
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/glue/InputStreamUtils.h b/ipc/glue/InputStreamUtils.h
--- a/ipc/glue/InputStreamUtils.h
+++ b/ipc/glue/InputStreamUtils.h
@@ -1,24 +1,31 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_ipc_InputStreamUtils_h
 #define mozilla_ipc_InputStreamUtils_h
 
 #include "mozilla/ipc/InputStreamParams.h"
+#include "mozilla/ipc/InputStreamParamsOrSendStream.h"
 #include "nsCOMPtr.h"
 #include "nsIInputStream.h"
 #include "nsTArray.h"
 
 namespace mozilla {
+
+namespace dom {
+class PContentChild;
+}
+
 namespace ipc {
 
 class FileDescriptor;
+class PBackgroundChild;
 
 void
 SerializeInputStream(nsIInputStream* aInputStream,
                      InputStreamParams& aParams,
                      nsTArray<FileDescriptor>& aFileDescriptors);
 
 void
 SerializeInputStream(nsIInputStream* aInputStream,
@@ -28,12 +35,101 @@ SerializeInputStream(nsIInputStream* aIn
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const InputStreamParams& aParams,
                        const nsTArray<FileDescriptor>& aFileDescriptors);
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const OptionalInputStreamParams& aParams,
                        const nsTArray<FileDescriptor>& aFileDescriptors);
 
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const InputStreamParamsOrSendStream& aValue);
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const OptionalInputStreamParamsOrSendStream& aValue);
+
+// RAII helper class that serializes an nsIInputStream into an
+// InputStreamParamsOrSendStream IPC struct.  Any SendStreamChild actors
+// are automatically managed correctly.
+//
+// Use the TakeValue() method when passing the value (or just after passing the
+// value) to the IPC Send*() method.
+//
+// For example:
+//
+//  AutoIPCStreamChild streamChild();
+//  streamChild.SerializeOrSend(inputStream, actor->Manager());
+//  actor->SendData(streamChild.TakeValue());
+//
+// If you need to manage an InputStreamParamsOrSendStream struct embedded in
+// another type, you can create the AutoIPCStreamChild around the existing
+// struct like this:
+//
+//  MyIPCStruct data;
+//  AutoIpcStreamChild streamChild(data.myStream());
+//  streamChild.SerializeOrSend(inputStream, actor->Manager());
+//  actor->SendData(data);
+//  streamChild.TakeValue();
+//
+// The AutoIPCStreamChild class also supports OptionalInputStreamParamsOrSendStream
+// values.  As long as you did not initialize the object with a non-optional
+// InputStreamParamsOrSendStream, you can call TakeOptionalValue() instead.
+//
+// Like SerializeInputStream(), the AutoIPCStreamChild will crash if
+// serialization cannot be completed.  Currently, this should only
+// occur if the nsIInputStream cannot be serialized and is also blocking.
+//
+class MOZ_STACK_CLASS AutoIPCStreamChild final
+{
+  OptionalInputStreamParamsOrSendStream mInlineValue;
+  InputStreamParamsOrSendStream* mValue;
+  OptionalInputStreamParamsOrSendStream* mOptionalValue;
+  bool mTaken;
+
+  bool
+  IsSet() const;
+
+public:
+  // Implicitly create an OptionalInputStreamParamsOrSendStream value.  Either
+  // TakeValue() or TakeOptionalValue() can be used.
+  AutoIPCStreamChild();
+
+  // Wrap an existing InputStreamParamsOrSendStream.  Only TakeValue() may be
+  // used.  If a nullptr nsIInputStream is passed to SerializeOrSend() then
+  // a crash will be forced.
+  explicit AutoIPCStreamChild(InputStreamParamsOrSendStream& aTarget);
+
+  // Wrap an existing OptionalInputStreamParamsOrSendStream.  Either TakeValue()
+  // or TakeOptionalValue can be used.
+  explicit AutoIPCStreamChild(OptionalInputStreamParamsOrSendStream& aTarget);
+
+  ~AutoIPCStreamChild();
+
+  // Serialize the input stream or create a SendStream actor using the PContent
+  // manager.  If neither of these succeed, then crash.  This should only be
+  // used on the main thread.
+  void
+  SerializeOrSend(nsIInputStream* aStream, dom::PContentChild* aManager);
+
+  // Serialize the input stream or create a SendStream actor using the
+  // PBackground manager.  If neither of these succeed, then crash.  This can
+  // be called on the main thread or Worker threads.
+  void
+  SerializeOrSend(nsIInputStream* aStream, PBackgroundChild* aManager);
+
+  // Get the InputStreamParamsOrSendStream as a non-optional value.  This will
+  // assert if a stream has not been serialized or if it has already been taken.
+  // This should only be called if the value is being, or has already been, sent
+  // to the parent
+  InputStreamParamsOrSendStream&
+  TakeValue();
+
+  // Get the OptionalInputStreamParamsOrSendStream value.  This will assert if
+  // the value has already been taken.  This should only be called if the value
+  // is being, or has already been, sent to the parent
+  OptionalInputStreamParamsOrSendStream&
+  TakeOptionalValue();
+};
+
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_InputStreamUtils_h
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -152,16 +152,17 @@ LOCAL_INCLUDES += [
     '/dom/indexedDB',
     '/dom/workers',
     '/media/webrtc/trunk',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
+    'InputStreamParamsOrSendStream.ipdlh',
     'PBackground.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
     'PSendStream.ipdl',
     'URIParams.ipdlh',
