# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d6e51041df0d4cf2beea2c5aeef0ca7c1689b0dd

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -842,47 +842,53 @@ FetchDriver::AsyncOnChannelRedirect(nsIC
     Unused << oldHttpChannel->GetResponseHeader(NS_LITERAL_CSTRING("referrer-policy"),
                                                 tRPHeaderCValue);
   }
 
   // "HTTP-redirect fetch": step 14 "Append locationURL to request's URL list."
   nsCOMPtr<nsIURI> uri;
   MOZ_ALWAYS_SUCCEEDS(aNewChannel->GetURI(getter_AddRefs(uri)));
 
-  nsCOMPtr<nsIURI> uriClone;
-  nsresult rv = uri->CloneIgnoringRef(getter_AddRefs(uriClone));
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
-  }
-  nsCString spec;
-  rv = uriClone->GetSpec(spec);
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
-  }
-  nsCString fragment;
-  rv = uri->GetRef(fragment);
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
+  // However, ignore internal redirects here.  We don't want to flip
+  // Response.redirected to true if an internal redirect occurs.  These
+  // should be transparent to script.
+  if (!(aFlags & nsIChannelEventSink::REDIRECT_INTERNAL)) {
+    nsCOMPtr<nsIURI> uriClone;
+    nsresult rv = uri->CloneIgnoringRef(getter_AddRefs(uriClone));
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+    nsCString spec;
+    rv = uriClone->GetSpec(spec);
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+    nsCString fragment;
+    rv = uri->GetRef(fragment);
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+
+    mRequest->AddURL(spec, fragment);
   }
 
-  mRequest->AddURL(spec, fragment);
   NS_ConvertUTF8toUTF16 tRPHeaderValue(tRPHeaderCValue);
   // updates requestâ€™s associated referrer policy according to the
   // Referrer-Policy header (if any).
   if (!tRPHeaderValue.IsEmpty()) {
     net::ReferrerPolicy net_referrerPolicy =
       nsContentUtils::GetReferrerPolicyFromHeader(tRPHeaderValue);
     if (net_referrerPolicy != net::RP_Unset) {
       mRequest->SetReferrerPolicy(net_referrerPolicy);
       // Should update channel's referrer policy
       if (httpChannel) {
-        rv = FetchUtil::SetRequestReferrer(mPrincipal,
-                                           mDocument,
-                                           httpChannel,
-                                           mRequest);
+        nsresult rv = FetchUtil::SetRequestReferrer(mPrincipal,
+                                                    mDocument,
+                                                    httpChannel,
+                                                    mRequest);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
   }
 
   aCallback->OnRedirectVerifyCallback(NS_OK);
   return NS_OK;
 }
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -2051,18 +2051,20 @@ HttpBaseChannel::SetRedirectionLimit(uin
 
 nsresult
 HttpBaseChannel::OverrideSecurityInfo(nsISupports* aSecurityInfo)
 {
   MOZ_ASSERT(!mSecurityInfo,
              "This can only be called when we don't have a security info object already");
   MOZ_RELEASE_ASSERT(aSecurityInfo,
                      "This can only be called with a valid security info object");
+  /*
   MOZ_ASSERT(!BypassServiceWorker(),
              "This can only be called on channels that are not bypassing interception");
+  */
   MOZ_ASSERT(mResponseCouldBeSynthesized,
              "This can only be called on channels that can be intercepted");
   if (mSecurityInfo) {
     LOG(("HttpBaseChannel::OverrideSecurityInfo mSecurityInfo is null! "
          "[this=%p]\n", this));
     return NS_ERROR_UNEXPECTED;
   }
   if (!mResponseCouldBeSynthesized) {
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -0,0 +1,761 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "InterceptedHttpChannel.h"
+#include "nsContentSecurityManager.h"
+#include "nsEscape.h"
+
+namespace mozilla {
+namespace net {
+
+namespace {
+
+class ListenerAdapter final : public nsIStreamListener
+                            , public nsIProgressEventSink
+{
+  nsCOMPtr<nsIChannel> mChannel;
+  nsCOMPtr<nsILoadGroup> mLoadGroup;
+  nsCOMPtr<nsIStreamListener> mListener;
+  nsCOMPtr<nsIProgressEventSink> mProgressSink;
+
+  ~ListenerAdapter()
+  {
+  }
+
+public:
+  NS_DECL_ISUPPORTS
+
+  ListenerAdapter(nsIChannel* aChannel, nsILoadGroup* aLoadGroup,
+                  nsIStreamListener* aListener,
+                  nsIProgressEventSink* aProgressSink)
+    : mChannel(aChannel)
+    , mLoadGroup(aLoadGroup)
+    , mListener(aListener)
+    , mProgressSink(aProgressSink)
+  {
+  }
+
+  NS_IMETHOD
+  OnStartRequest(nsIRequest* aRequest, nsISupports* aContext) override
+  {
+    printf_stderr("### ### [%p] ListenerAdapter::%s\n", this, __func__);
+
+    nsLoadFlags flags = 0;
+    mChannel->GetLoadFlags(&flags);
+
+    printf_stderr("### ### [%p] ListenerAdapter::%s mLoadFlags is document load %s\n",
+                  this, __func__,
+                  (flags & nsIChannel::LOAD_DOCUMENT_URI ? "true" : "false"));
+
+    return mListener->OnStartRequest(mChannel, aContext);
+  }
+
+  NS_IMETHOD
+  OnStopRequest(nsIRequest* aRequest, nsISupports* aContext,
+                nsresult aStatus) override
+  {
+    printf_stderr("### ### [%p] ListenerAdapter::%s\n", this, __func__);
+    mListener->OnStopRequest(mChannel, aContext, aStatus);
+    mLoadGroup->RemoveRequest(mChannel, aContext, aStatus);
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
+                  nsIInputStream* aInputStream, uint64_t aOffset,
+                  uint32_t aCount) override
+  {
+    printf_stderr("### ### [%p] ListenerAdapter::%s\n", this, __func__);
+    uint32_t loadFlags;
+    mChannel->GetLoadFlags(&loadFlags);
+
+    if (!(loadFlags & HttpBaseChannel::LOAD_BACKGROUND)) {
+      nsCOMPtr<nsIURI> uri;
+      mChannel->GetURI(getter_AddRefs(uri));
+
+      nsAutoCString host;
+      uri->GetHost(host);
+
+      OnStatus(mChannel, aContext, NS_NET_STATUS_READING, NS_ConvertUTF8toUTF16(host).get());
+
+      // TODO: fix max length
+      int64_t progress = aOffset + aCount;
+      OnProgress(mChannel, aContext, progress, -1);
+    }
+
+    return mListener->OnDataAvailable(mChannel, aContext, aInputStream,
+                                      aOffset, aCount);
+  }
+
+  NS_IMETHODIMP
+  OnStatus(nsIRequest* aRequest, nsISupports* aContext, nsresult aStatus,
+           const char16_t* aStatusArg) override
+  {
+    printf_stderr("### ### ListenerAdapter %s\n", __func__);
+    if (!mProgressSink) {
+      return NS_OK;
+    }
+    return mProgressSink->OnStatus(mChannel, aContext, aStatus, aStatusArg);
+  }
+
+  NS_IMETHODIMP
+  OnProgress(nsIRequest* aRequest, nsISupports* aContext, int64_t aProgress,
+             int64_t aProgressMax) override
+  {
+    printf_stderr("### ### ListenerAdapter %s\n", __func__);
+    if (!mProgressSink) {
+      return NS_OK;
+    }
+    return mProgressSink->OnProgress(mChannel, aContext, aProgress,
+                                     aProgressMax);
+  }
+};
+
+NS_IMPL_ISUPPORTS(ListenerAdapter, nsIRequestObserver,
+                                   nsIStreamListener,
+                                   nsIProgressEventSink)
+
+} // anonymous namespace
+
+NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
+                            HttpBaseChannel,
+                            nsIInterceptedChannel,
+                            nsIAsyncVerifyRedirectCallback)
+
+InterceptedHttpChannel::~InterceptedHttpChannel()
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+}
+
+InterceptedHttpChannel::InterceptedHttpChannel()
+  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Cancel(nsresult aStatus)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return CancelInterception(aStatus);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Suspend(void)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  if (mPump) {
+    return mPump->Suspend();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Resume(void)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  if (mPump) {
+    return mPump->Resume();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecurityInfo(nsISupports** aSecurityInfo)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  nsCOMPtr<nsISupports> ref(mSecurityInfo);
+  ref.forget(aSecurityInfo);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen(nsIStreamListener* aListener, nsISupports* aContext)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  printf_stderr("### ### [%p] saving mListener %p\n", this, aListener);
+  mListener = aListener;
+
+  nsCOMPtr<nsINetworkInterceptController> controller;
+  GetCallback(controller);
+
+  if (NS_WARN_IF(!controller)) {
+    ReleaseListeners();
+    return NS_ERROR_FAILURE;
+  }
+
+  mResponseCouldBeSynthesized = true;
+
+  mLoadGroup->AddRequest(this, nullptr);
+
+  // If we already have a synthesized body then this is a "fake redirect"
+  // from a channel synthesized with an opaque response.
+  if (mBodyReader) {
+    nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mPump),
+                                            mBodyReader,
+                                            int64_t(-1), int64_t(-1), 0, 0, true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIProgressEventSink> progressSink;
+    GetCallback(progressSink);
+
+    nsCOMPtr<nsIStreamListener> listener;
+    if (mListener) {
+      listener = new ListenerAdapter(this, mLoadGroup, mListener, progressSink);
+    }
+
+    rv = mPump->AsyncRead(listener, mListenerContext);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return rv;
+  }
+
+  // Otherwise start the service worker interception.
+  nsresult rv = controller->ChannelIntercepted(this);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen2(nsIStreamListener* aListener)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  nsCOMPtr<nsIStreamListener> listener(aListener);
+  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+  return AsyncOpen(listener, nullptr);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::LogBlockedCORSRequest(const nsAString& aMessage)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetupFallbackChannel(const char*  aFallbackKey)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ForceIntercepted(uint64_t aInterceptionID)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseSynthesized(bool* aResponseSynthesized)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  *aResponseSynthesized = mResponseHead || mBodyReader;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetPriority(int32_t aPriority)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetClassFlags(uint32_t aClassFlags)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ClearClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AddClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResumeAt(uint64_t startPos, const nsACString & entityID)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void
+InterceptedHttpChannel::DoNotifyListenerCleanup()
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResetInterception(void)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  printf_stderr("### ### [%p] mListener is %p\n", this, mListener.get());
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIIOService> ioService;
+  rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
+
+  nsCOMPtr<nsIChannel> newChannel;
+  nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+    CloneLoadInfoForRedirect(mURI, flags);
+  rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                             mURI,
+                             redirectLoadInfo,
+                             nullptr, // aLoadGroup
+                             nullptr, // aCallbacks
+                             mLoadFlags,
+                             ioService);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = SetupReplacementChannel(mURI, newChannel, true, flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+    nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
+    rv = newChannel->GetLoadFlags(&loadFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+    loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+    rv = newChannel->SetLoadFlags(loadFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  mRedirectChannel = newChannel.forget();
+
+  rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
+
+  if (NS_FAILED(rv)) {
+    OnRedirectVerifyCallback(rv);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeStatus(uint16_t aStatus,
+                                         const nsACString& aReason)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  nsAutoCString statusLine;
+  statusLine.AppendLiteral("HTTP/1.1 ");
+  statusLine.AppendInt(aStatus);
+  statusLine.AppendLiteral(" ");
+  statusLine.Append(aReason);
+
+  mSynthesizedResponseHead->ParseStatusLine(statusLine);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeHeader(const nsACString& aName,
+                                         const nsACString& aValue)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  nsAutoCString header = aName + NS_LITERAL_CSTRING(": ") + aValue;
+  // Overwrite any existing header.
+  nsresult rv = mSynthesizedResponseHead->ParseHeaderLine(header);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  if (mBodyWriter) {
+    mBodyWriter->Close();
+  }
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  mResponseHead = mSynthesizedResponseHead.release();
+
+  if (nsHttpChannel::WillRedirect(mResponseHead) &&
+      !mLoadInfo->GetDontFollowRedirects()) {
+    printf_stderr("### ### will redirect\n");
+    nsCOMPtr<nsIIOService> ioService;
+    nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsAutoCString location;
+    rv = mResponseHead->GetHeader(nsHttp::Location, location);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+    // make sure non-ASCII characters in the location header are escaped.
+    nsAutoCString locationBuf;
+    if (NS_EscapeURL(location.get(), -1, esc_OnlyNonASCII, locationBuf)) {
+      location = locationBuf;
+    }
+
+    if (NS_WARN_IF(mRedirectionLimit == 0)) {
+      return NS_ERROR_REDIRECT_LOOP;
+    }
+
+    nsCOMPtr<nsIURI> redirectURI;
+    rv = ioService->NewURI(nsDependentCString(location.get()),
+                           nullptr,
+                           mURI,
+                           getter_AddRefs(redirectURI));
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_CORRUPTED_CONTENT);
+
+    uint32_t redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
+    if (nsHttp::IsPermanentRedirect(mResponseHead->Status())) {
+      redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
+    }
+
+    bool rewriteToGET = ShouldRewriteRedirectToGET(mResponseHead->Status(),
+                                                   mRequestHead.ParsedMethod());
+
+    nsCOMPtr<nsIChannel> newChannel;
+    nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+      CloneLoadInfoForRedirect(redirectURI, redirectFlags);
+    rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                               redirectURI,
+                               redirectLoadInfo,
+                               nullptr, // aLoadGroup
+                               nullptr, // aCallbacks
+                               mLoadFlags,
+                               ioService);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = SetupReplacementChannel(redirectURI, newChannel, !rewriteToGET,
+                                 redirectFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+      nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
+      rv = newChannel->GetLoadFlags(&loadFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+      loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+      rv = newChannel->SetLoadFlags(loadFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    mRedirectChannel = newChannel.forget();
+
+    rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, redirectFlags);
+
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      OnRedirectVerifyCallback(rv);
+    }
+
+    printf_stderr("### ### will redirect complete - %s\n", (NS_SUCCEEDED(rv) ? "succeeded" : "failed"));
+    return rv;
+  }
+
+  SetApplyConversion(false);
+
+  if (!mBodyReader) {
+    nsresult rv = NS_NewCStringInputStream(getter_AddRefs(mBodyReader),
+                                           EmptyCString());
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  nsCOMPtr<nsIURI> responseURI;
+  if (!aFinalURLSpec.IsEmpty()) {
+    nsresult rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
+    NS_ENSURE_SUCCESS(rv, rv);
+  } else {
+    responseURI = mURI;
+  }
+
+  bool equal = false;
+  Unused << mURI->Equals(responseURI, &equal);
+  if (!equal) {
+    nsresult rv = NS_OK;
+
+    RefPtr<InterceptedHttpChannel> newChannel = new InterceptedHttpChannel();
+
+    rv = newChannel->Init(responseURI, mCaps,
+                          static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                          mProxyResolveFlags, mProxyURI, mChannelId);
+
+    uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
+
+    nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+      CloneLoadInfoForRedirect(responseURI, flags);
+    newChannel->SetLoadInfo(redirectLoadInfo);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = SetupReplacementChannel(responseURI, newChannel, true, flags);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+      nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
+      rv = newChannel->GetLoadFlags(&loadFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+      loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+      rv = newChannel->SetLoadFlags(loadFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    newChannel->mBodyReader = mBodyReader.forget();
+    newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
+
+    mRedirectChannel = newChannel;
+
+    rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
+
+    if (NS_FAILED(rv)) {
+      OnRedirectVerifyCallback(rv);
+    }
+
+    return rv;
+  }
+
+  nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mPump),
+                                          mBodyReader,
+                                          int64_t(-1), int64_t(-1), 0, 0, true);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIProgressEventSink> progressSink;
+  GetCallback(progressSink);
+
+  nsCOMPtr<nsIStreamListener> listener;
+  if (mListener) {
+    listener = new ListenerAdapter(this, mLoadGroup, mListener, progressSink);
+  }
+
+  rv = mPump->AsyncRead(listener, mListenerContext);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return rv;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::CancelInterception(nsresult aStatus)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  if (mPump) {
+    return mPump->Cancel(aStatus);
+  }
+
+  return AsyncAbort(aStatus);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseBody(nsIOutputStream** aResponseBody)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  if (!mBodyWriter) {
+    nsresult rv = NS_NewPipe(getter_AddRefs(mBodyReader),
+                             getter_AddRefs(mBodyWriter),
+                             0,          // default segment size
+                             UINT32_MAX, // infinite pipe length
+                             true,       // non-blocking reader
+                             true);      // non-blocking writer
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  nsCOMPtr<nsIOutputStream> ref(mBodyWriter);
+  ref.forget(aResponseBody);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetChannel(nsIChannel** aChannel)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  nsCOMPtr<nsIChannel> ref(this);
+  ref.forget(aChannel);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecureUpgradedChannelURI(nsIURI** aSecureUpgradedChannelURI)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  // TODO: Is this correct for e10s?
+  nsCOMPtr<nsIURI> ref(mURI);
+  ref.forget(aSecureUpgradedChannelURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return aChannelInfo->ResurrectInfoOnChannel(this);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetInternalContentPolicyType(nsContentPolicyType* aPolicyType)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  if (mLoadInfo) {
+    *aPolicyType = mLoadInfo->InternalContentPolicyType();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector** aConsoleReportCollector)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishResponseStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishSynthesizedResponseEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelResetEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SaveTimeStamps(void)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetReleaseHandle(nsISupports* aHandle)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  mReleaseHandle = aHandle;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnRedirectVerifyCallback(nsresult rv)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+
+  printf_stderr("### ### [%p] mListener is %p\n", this, mListener.get());
+  printf_stderr("### ### [%p] result is %s\n", this, (NS_FAILED(rv) ? "failed" : "success"));
+
+  if (NS_SUCCEEDED(rv)) {
+    // TODO: move this into a separate method like OpenRedirectChannel()?
+
+    // Make sure to do this after we received redirect veto answer,
+    // i.e. after all sinks had been notified
+    mRedirectChannel->SetOriginalURI(mOriginalURI);
+
+    // open new channel
+    if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
+      printf_stderr("### ### calling AsyncOpen2()\n");
+      MOZ_ASSERT(!mListenerContext, "mListenerContext should be null!");
+      rv = mRedirectChannel->AsyncOpen2(mListener);
+    }
+    else {
+      printf_stderr("### ### calling AsyncOpen()\n");
+      rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
+    }
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mStatus = NS_BINDING_REDIRECTED;
+
+    ReleaseListeners();
+  }
+
+  if (NS_FAILED(rv)) {
+    // Cancel the channel here, the update to https had been vetoed
+    // but from the security reasons we have to discard the whole channel
+    // load.
+    Cancel(rv);
+  }
+
+  mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+
+  return NS_OK;
+}
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_InterceptedHttpChannel_h
+#define mozilla_net_InterceptedHttpChannel_h
+
+#include "HttpBaseChannel.h"
+#include "nsINetworkInterceptController.h"
+#include "nsIInputStream.h"
+
+namespace mozilla {
+namespace net {
+
+class InterceptedHttpChannel final : public HttpBaseChannel
+                                   , public HttpAsyncAborter<InterceptedHttpChannel>
+                                   , public nsIInterceptedChannel
+                                   , public nsIAsyncVerifyRedirectCallback
+{
+  friend class HttpAsyncAborter<InterceptedHttpChannel>;
+
+  UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
+  nsCOMPtr<nsIChannel> mRedirectChannel;
+  nsCOMPtr<nsIInputStream> mBodyReader;
+  nsCOMPtr<nsIOutputStream> mBodyWriter;
+  nsCOMPtr<nsISupports> mReleaseHandle;
+  RefPtr<nsInputStreamPump> mPump;
+
+  ~InterceptedHttpChannel();
+
+public:
+  InterceptedHttpChannel();
+
+  NS_IMETHOD
+  Cancel(nsresult aStatus) override;
+
+  NS_IMETHOD
+  Suspend(void) override;
+
+  NS_IMETHOD
+  Resume(void) override;
+
+  NS_IMETHOD
+  GetSecurityInfo(nsISupports * *aSecurityInfo) override;
+
+  NS_IMETHOD
+  AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) override;
+
+  NS_IMETHOD
+  AsyncOpen2(nsIStreamListener *aListener) override;
+
+  NS_IMETHOD
+  LogBlockedCORSRequest(const nsAString & aMessage) override;
+
+  NS_IMETHOD
+  SetupFallbackChannel(const char * aFallbackKey) override;
+
+  NS_IMETHOD
+  ForceIntercepted(uint64_t aInterceptionID) override;
+
+  NS_IMETHOD
+  GetResponseSynthesized(bool *aResponseSynthesized) override;
+
+  NS_IMETHOD
+  SetPriority(int32_t aPriority) override;
+
+  NS_IMETHOD
+  SetClassFlags(uint32_t aClassFlags) override;
+
+  NS_IMETHOD
+  ClearClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  AddClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  ResumeAt(uint64_t startPos, const nsACString & entityID) override;
+
+  void
+  DoNotifyListenerCleanup() override;
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIINTERCEPTEDCHANNEL
+  NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_InterceptedHttpChannel_h
diff --git a/netwerk/protocol/http/moz.build b/netwerk/protocol/http/moz.build
--- a/netwerk/protocol/http/moz.build
+++ b/netwerk/protocol/http/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'HttpBackgroundChannelChild.cpp',
     'HttpBackgroundChannelParent.cpp',
     'HttpBaseChannel.cpp',
     'HttpChannelChild.cpp',
     'HttpChannelParent.cpp',
     'HttpChannelParentListener.cpp',
     'HttpInfo.cpp',
     'InterceptedChannel.cpp',
+    'InterceptedHttpChannel.cpp',
     'nsCORSListenerProxy.cpp',
     'nsHttp.cpp',
     'nsHttpActivityDistributor.cpp',
     'nsHttpAuthCache.cpp',
     'nsHttpAuthManager.cpp',
     'nsHttpBasicAuth.cpp',
     'nsHttpChannel.cpp',
     'nsHttpChunkedDecoder.cpp',
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -106,16 +106,17 @@
 #include "HSTSPrimerListener.h"
 #include "CacheStorageService.h"
 #include "HttpChannelParent.h"
 #include "nsIBufferedStreams.h"
 #include "nsIFileStreams.h"
 #include "nsIMIMEInputStream.h"
 #include "nsIMultiplexInputStream.h"
 #include "../../cache2/CacheFileUtils.h"
+#include "InterceptedHttpChannel.h"
 
 #ifdef MOZ_TASK_TRACER
 #include "GeckoTaskTracer.h"
 #endif
 
 namespace mozilla { namespace net {
 
 namespace {
@@ -545,18 +546,71 @@ nsHttpChannel::Connect()
     SpeculativeConnect();
 
     // Don't allow resuming when cache must be used
     if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
         LOG(("Resuming from cache is not supported yet"));
         return NS_ERROR_DOCUMENT_NOT_CACHED;
     }
 
+    nsresult rv = NS_OK;
+    if (mInterceptCache == MAYBE_INTERCEPT) {
+      mInterceptCache = INTERCEPTED;
+
+      nsCOMPtr<nsINetworkInterceptController> controller;
+      GetCallback(controller);
+
+      printf_stderr("### ### nsHttpChannel mListener is %p when creating InterceptedHttpChannel\n", mListener.get());
+      RefPtr<InterceptedHttpChannel> intercepted =
+        new InterceptedHttpChannel();
+
+      rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                             mProxyResolveFlags, mProxyURI, mChannelId);
+
+      nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+        CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
+      intercepted->SetLoadInfo(redirectLoadInfo);
+
+      rv = SetupReplacementChannel(mURI, intercepted, true,
+                                   nsIChannelEventSink::REDIRECT_INTERNAL);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      // Inform consumers about this fake redirect
+      mRedirectChannel = intercepted;
+
+      // We need to propagate the listener to the redirect channel so save it
+      // early here.
+      /*
+      mListener = listener;
+      mListenerContext = context;
+      */
+
+      PushRedirectAsyncFunc(
+          &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      rv = gHttpHandler->AsyncOnChannelRedirect(this, intercepted,
+                                                nsIChannelEventSink::REDIRECT_INTERNAL);
+
+      if (NS_SUCCEEDED(rv)) {
+        rv = WaitForRedirectCallback();
+      }
+
+      if (NS_FAILED(rv)) {
+        AutoRedirectVetoNotifier notifier(this);
+
+        /* Remove the async call to ContinueAsyncRedirectChannelToURI().
+         * It is called directly by our callers upon return (to clean up
+         * the failed redirect). */
+        PopRedirectAsyncFunc(
+            &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      }
+
+      return rv;
+    }
+
     // open a cache entry for this channel...
-    nsresult rv;
     bool isHttps = false;
     rv = mURI->SchemeIs("https", &isHttps);
     NS_ENSURE_SUCCESS(rv,rv);
     rv = OpenCacheEntry(isHttps);
 
     // do not continue if asyncOpenCacheEntry is in progress
     if (AwaitingCacheCallbacks()) {
         LOG(("nsHttpChannel::Connect %p AwaitingCacheCallbacks forces async\n", this));
@@ -3933,16 +3987,17 @@ nsHttpChannel::OpenCacheEntry(bool isHtt
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsINetworkInterceptController> controller;
         GetCallback(controller);
 
         RefPtr<InterceptedChannelChrome> intercepted =
                 new InterceptedChannelChrome(this, controller, entry);
         intercepted->NotifyController();
+
     } else {
         if (mInterceptCache == INTERCEPTED) {
             cacheEntryOpenFlags |= nsICacheStorage::OPEN_INTERCEPTED;
             // Clear OPEN_TRUNCATE for the fake cache entry, since otherwise
             // cache storage will close the current entry which breaks the
             // response synthesis.
             cacheEntryOpenFlags &= ~nsICacheStorage::OPEN_TRUNCATE;
             DebugOnly<bool> exists;
diff --git a/uriloader/base/nsDocLoader.cpp b/uriloader/base/nsDocLoader.cpp
--- a/uriloader/base/nsDocLoader.cpp
+++ b/uriloader/base/nsDocLoader.cpp
@@ -1445,18 +1445,22 @@ NS_IMETHODIMP nsDocLoader::AsyncOnChanne
     aOldChannel->GetLoadFlags(&loadFlags);
     // If the document channel is being redirected, then indicate that the
     // document is being redirected in the notification...
     if (loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
     {
       stateFlags |= nsIWebProgressListener::STATE_IS_DOCUMENT;
 
 #if defined(DEBUG)
-      nsCOMPtr<nsIRequest> request(do_QueryInterface(aOldChannel));
-      NS_ASSERTION(request == mDocumentRequest, "Wrong Document Channel");
+      // We only set mDocumentRequest in OnStartRequest(), but its possible
+      // to get a redirect before that for service worker interception.
+      if (mDocumentRequest) {
+        nsCOMPtr<nsIRequest> request(do_QueryInterface(aOldChannel));
+        NS_ASSERTION(request == mDocumentRequest, "Wrong Document Channel");
+      }
 #endif /* DEBUG */
     }
 
     OnRedirectStateChange(aOldChannel, aNewChannel, aFlags, stateFlags);
     FireOnStateChange(this, aOldChannel, stateFlags, NS_OK);
   }
 
   cb->OnRedirectVerifyCallback(NS_OK);
