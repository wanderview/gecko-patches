# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e5b1b6114aec0e679a9d01fa0b823c38dd45141c

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -858,47 +858,53 @@ FetchDriver::AsyncOnChannelRedirect(nsIC
     Unused << oldHttpChannel->GetResponseHeader(NS_LITERAL_CSTRING("referrer-policy"),
                                                 tRPHeaderCValue);
   }
 
   // "HTTP-redirect fetch": step 14 "Append locationURL to request's URL list."
   nsCOMPtr<nsIURI> uri;
   MOZ_ALWAYS_SUCCEEDS(aNewChannel->GetURI(getter_AddRefs(uri)));
 
-  nsCOMPtr<nsIURI> uriClone;
-  nsresult rv = uri->CloneIgnoringRef(getter_AddRefs(uriClone));
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
-  }
-  nsCString spec;
-  rv = uriClone->GetSpec(spec);
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
-  }
-  nsCString fragment;
-  rv = uri->GetRef(fragment);
-  if(NS_WARN_IF(NS_FAILED(rv))){
-    return rv;
+  // However, ignore internal redirects here.  We don't want to flip
+  // Response.redirected to true if an internal redirect occurs.  These
+  // should be transparent to script.
+  if (!(aFlags & nsIChannelEventSink::REDIRECT_INTERNAL)) {
+    nsCOMPtr<nsIURI> uriClone;
+    nsresult rv = uri->CloneIgnoringRef(getter_AddRefs(uriClone));
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+    nsCString spec;
+    rv = uriClone->GetSpec(spec);
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+    nsCString fragment;
+    rv = uri->GetRef(fragment);
+    if(NS_WARN_IF(NS_FAILED(rv))){
+      return rv;
+    }
+
+    mRequest->AddURL(spec, fragment);
   }
 
-  mRequest->AddURL(spec, fragment);
   NS_ConvertUTF8toUTF16 tRPHeaderValue(tRPHeaderCValue);
   // updates requestâ€™s associated referrer policy according to the
   // Referrer-Policy header (if any).
   if (!tRPHeaderValue.IsEmpty()) {
     net::ReferrerPolicy net_referrerPolicy =
       nsContentUtils::GetReferrerPolicyFromHeader(tRPHeaderValue);
     if (net_referrerPolicy != net::RP_Unset) {
       mRequest->SetReferrerPolicy(net_referrerPolicy);
       // Should update channel's referrer policy
       if (httpChannel) {
-        rv = FetchUtil::SetRequestReferrer(mPrincipal,
-                                           mDocument,
-                                           httpChannel,
-                                           mRequest);
+        nsresult rv = FetchUtil::SetRequestReferrer(mPrincipal,
+                                                    mDocument,
+                                                    httpChannel,
+                                                    mRequest);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
   }
 
   aCallback->OnRedirectVerifyCallback(NS_OK);
   return NS_OK;
 }
diff --git a/dom/workers/test/serviceworkers/fetch/fetch_tests.js b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
--- a/dom/workers/test/serviceworkers/fetch/fetch_tests.js
+++ b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
@@ -1,22 +1,26 @@
+dump('### ### TEST fetch_tests.js\n');
 var origin = 'http://mochi.test:8888';
 
 function fetchXHRWithMethod(name, method, onload, onerror, headers) {
   expectAsyncResult();
 
   onload = onload || function() {
+    dump('### ### TEST xhr load\n');
     my_ok(false, "XHR load should not complete successfully");
     finish();
   };
   onerror = onerror || function() {
+    dump('### ### TEST xhr error\n');
     my_ok(false, "XHR load for " + name + " should be intercepted successfully");
     finish();
   };
 
+  dump('### ### creating XHR\n');
   var x = new XMLHttpRequest();
   x.open(method, name, true);
   x.onload = function() { onload(x) };
   x.onerror = function() { onerror(x) };
   headers = headers || [];
   headers.forEach(function(header) {
     x.setRequestHeader(header[0], header[1]);
   });
diff --git a/dom/workers/test/serviceworkers/fetch/index.html b/dom/workers/test/serviceworkers/fetch/index.html
--- a/dom/workers/test/serviceworkers/fetch/index.html
+++ b/dom/workers/test/serviceworkers/fetch/index.html
@@ -73,16 +73,17 @@
   function expectAsyncResult() {
     gExpected++;
   }
 
   my_ok(navigator.serviceWorker.controller != null, "should be controlled");
 </script>
 <script src="fetch_tests.js"></script>
 <script>
+  /*
   test_onload(function() {
     var elem = document.createElement('img');
     elem.src = "nonexistent_image.gifs";
     elem.id = 'intercepted-img';
     return elem;
   }, function() {
     my_ok(this.complete, "image should be complete");
     my_ok(this.naturalWidth == 1 && this.naturalHeight == 1, "image should be 1x1 gif");
@@ -172,12 +173,13 @@
       gExpected++;
     } else if (e.data.type == "ok") {
       my_ok(e.data.value, "Fetch test on worker: " + e.data.msg);
     }
   };
   worker.onerror = function() {
     my_ok(false, "worker should not cause any errors");
   };
+  */
 </script>
 </pre>
 </body>
 </html>
diff --git a/dom/xhr/XMLHttpRequestMainThread.cpp b/dom/xhr/XMLHttpRequestMainThread.cpp
--- a/dom/xhr/XMLHttpRequestMainThread.cpp
+++ b/dom/xhr/XMLHttpRequestMainThread.cpp
@@ -27,16 +27,17 @@
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/Encoding.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/MemoryReporting.h"
+#include "mozilla/ErrorNames.h"
 #include "nsIDOMDocument.h"
 #include "mozilla/dom/ProgressEvent.h"
 #include "nsIJARChannel.h"
 #include "nsIJARURI.h"
 #include "nsLayoutCID.h"
 #include "nsReadableUtils.h"
 
 #include "nsIURI.h"
@@ -2226,19 +2227,21 @@ XMLHttpRequestMainThread::OnStartRequest
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 XMLHttpRequestMainThread::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
 {
+  nsAutoCString name;
+  GetErrorName(status, name);
   AUTO_PROFILER_LABEL("XMLHttpRequestMainThread::OnStopRequest", NETWORK);
 
-  if (request != mChannel) {
+  if (NS_WARN_IF(request != mChannel)) {
     // Can this still happen?
     return NS_OK;
   }
 
   mWaitingForOnStopRequest = false;
 
   if (mRequestObserver) {
     NS_ASSERTION(mFirstStartRequestSeen, "Inconsistent state!");
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -2093,18 +2093,20 @@ HttpBaseChannel::SetRedirectionLimit(uin
 
 nsresult
 HttpBaseChannel::OverrideSecurityInfo(nsISupports* aSecurityInfo)
 {
   MOZ_ASSERT(!mSecurityInfo,
              "This can only be called when we don't have a security info object already");
   MOZ_RELEASE_ASSERT(aSecurityInfo,
                      "This can only be called with a valid security info object");
+  /*
   MOZ_ASSERT(!BypassServiceWorker(),
              "This can only be called on channels that are not bypassing interception");
+  */
   MOZ_ASSERT(mResponseCouldBeSynthesized,
              "This can only be called on channels that can be intercepted");
   if (mSecurityInfo) {
     LOG(("HttpBaseChannel::OverrideSecurityInfo mSecurityInfo is null! "
          "[this=%p]\n", this));
     return NS_ERROR_UNEXPECTED;
   }
   if (!mResponseCouldBeSynthesized) {
diff --git a/netwerk/protocol/http/HttpBaseChannel.h b/netwerk/protocol/http/HttpBaseChannel.h
--- a/netwerk/protocol/http/HttpBaseChannel.h
+++ b/netwerk/protocol/http/HttpBaseChannel.h
@@ -366,16 +366,28 @@ public: /* Necko internal use only... */
 
     void SetIsTrackingResource();
 
     const uint64_t& ChannelId() const
     {
       return mChannelId;
     }
 
+    MOZ_MUST_USE nsresult
+    SetReferrerWithPolicyInternal(nsIURI *referrer, uint32_t referrerPolicy)
+    {
+        nsAutoCString spec;
+        nsresult rv = referrer->GetAsciiSpec(spec);
+        if (NS_FAILED(rv)) return rv;
+        mReferrer = referrer;
+        mReferrerPolicy = referrerPolicy;
+        rv = mRequestHead.SetHeader(nsHttp::Referer, spec);
+        return rv;
+    }
+
 protected:
   // Handle notifying listener, removing from loadgroup if request failed.
   void     DoNotifyListener();
   virtual void DoNotifyListenerCleanup() = 0;
 
   // drop reference to listener, its callbacks, and the progress sink
   virtual void ReleaseListeners();
 
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -14,16 +14,17 @@
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/TabGroup.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/IPCStreamUtils.h"
 #include "mozilla/net/NeckoChild.h"
 #include "mozilla/net/HttpChannelChild.h"
+#include "mozilla/ErrorNames.h"
 
 #include "AltDataOutputStreamChild.h"
 #include "CookieServiceChild.h"
 #include "HttpBackgroundChannelChild.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsPrimitives.h"
 #include "nsChannelClassifier.h"
 #include "nsContentPolicyUtils.h"
@@ -56,16 +57,18 @@
 #include "nsStreamUtils.h"
 #include "nsThreadUtils.h"
 #include "nsCORSListenerProxy.h"
 
 #ifdef MOZ_TASK_TRACER
 #include "GeckoTaskTracer.h"
 #endif
 
+void DebugMe() { }
+
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
 
 namespace mozilla {
 namespace net {
 
 #if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION) || defined(DEBUG)
 static bool gIPCSecurityDisabled = false;
@@ -659,16 +662,20 @@ public:
 
 NS_IMPL_ISUPPORTS(SyntheticDiversionListener, nsIStreamListener);
 
 } // anonymous namespace
 
 void
 HttpChannelChild::DoOnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
+  nsAutoCString spec;
+  if (mURI) {
+    mURI->GetSpec(spec);
+  }
   LOG(("HttpChannelChild::DoOnStartRequest [this=%p]\n", this));
 
   // In theory mListener should not be null, but in practice sometimes it is.
   MOZ_ASSERT(mListener);
   if (!mListener) {
     Cancel(NS_ERROR_FAILURE);
     return;
   }
@@ -1454,16 +1461,20 @@ HttpChannelChild::OverrideRunnable::Run(
   }
 
   return NS_OK;
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvFinishInterceptedRedirect()
 {
+  nsAutoCString spec;
+  if (mURI) {
+    mURI->GetSpec(spec);
+  }
   // Hold a ref to this to keep it from being deleted by Send__delete__()
   RefPtr<HttpChannelChild> self(this);
   Send__delete__(this);
 
   {
     // Reset the event target since the IPC actor is about to be destroyed.
     // Following channel event should be handled on main thread.
     MutexAutoLock lock(mEventTargetMutex);
@@ -1487,16 +1498,20 @@ HttpChannelChild::RecvFinishInterceptedR
 void
 HttpChannelChild::DeleteSelf()
 {
   Send__delete__(this);
 }
 
 void HttpChannelChild::FinishInterceptedRedirect()
 {
+  nsAutoCString spec;
+  if (mURI) {
+    mURI->GetSpec(spec);
+  }
   nsresult rv;
   if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
     MOZ_ASSERT(!mInterceptedRedirectContext, "the context should be null!");
     rv = AsyncOpen2(mInterceptedRedirectListener);
   } else {
     rv = AsyncOpen(mInterceptedRedirectListener, mInterceptedRedirectContext);
   }
   mInterceptedRedirectListener = nullptr;
@@ -3366,16 +3381,18 @@ HttpChannelChild::ResetInterception()
 {
   NS_ENSURE_TRUE_VOID(gNeckoChild != nullptr);
 
   if (mInterceptListener) {
     mInterceptListener->Cleanup();
   }
   mInterceptListener = nullptr;
 
+  mShouldParentIntercept = false;
+
   // The chance to intercept any further requests associated with this channel
   // (such as redirects) has passed.
   if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
     mLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
   }
 
   // Continue with the original cross-process request
   nsresult rv = ContinueAsyncOpen();
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -14,16 +14,17 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 #include "HttpBackgroundChannelParent.h"
 #include "HttpChannelParentListener.h"
+#include "InterceptedHttpChannel.h"
 #include "nsHttpHandler.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPriority.h"
 #include "nsIAuthPromptProvider.h"
 #include "nsIBackgroundChannelRegistrar.h"
 #include "nsSerializationHelper.h"
 #include "nsISerializable.h"
@@ -47,16 +48,17 @@
 #include "nsIWindowWatcher.h"
 #include "nsIDocument.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "nsIStorageStream.h"
 #include "nsThreadUtils.h"
 #include "nsQueryObject.h"
 #include "nsIURIClassifier.h"
+#include "mozilla/ErrorNames.h"
 
 using mozilla::BasePrincipal;
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
 
 namespace mozilla {
 namespace net {
 
@@ -71,16 +73,17 @@ HttpChannelParent::HttpChannelParent(con
   , mLoadContext(aLoadContext)
   , mStatus(NS_OK)
   , mPendingDiversion(false)
   , mDivertingFromChild(false)
   , mDivertedOnStartRequest(false)
   , mSuspendedForDiversion(false)
   , mSuspendAfterSynthesizeResponse(false)
   , mWillSynthesizeResponse(false)
+  , mSynthesizedRedirectWillSuspend(false)
   , mNestedFrameId(0)
 {
   LOG(("Creating HttpChannelParent [this=%p]\n", this));
 
   // Ensure gHttpHandler is initialized: we need the atom table up and running.
   nsCOMPtr<nsIHttpProtocolHandler> dummyInitializer =
     do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http");
 
@@ -122,16 +125,17 @@ HttpChannelParent::ActorDestroy(ActorDes
 bool
 HttpChannelParent::Init(const HttpChannelCreationArgs& aArgs)
 {
   LOG(("HttpChannelParent::Init [this=%p]\n", this));
   switch (aArgs.type()) {
   case HttpChannelCreationArgs::THttpChannelOpenArgs:
   {
     const HttpChannelOpenArgs& a = aArgs.get_HttpChannelOpenArgs();
+    nsCOMPtr<nsIURI> uri = DeserializeURI(a.uri());
     return DoAsyncOpen(a.uri(), a.original(), a.doc(), a.referrer(),
                        a.referrerPolicy(), a.apiRedirectTo(), a.topWindowURI(),
                        a.loadFlags(), a.requestHeaders(),
                        a.requestMethod(), a.uploadStream(),
                        a.uploadStreamHasHeaders(), a.priority(), a.classOfService(),
                        a.redirectionLimit(), a.allowSTS(),
                        a.thirdPartyFlags(), a.resumeAt(), a.startPos(),
                        a.entityID(), a.chooseApplicationCache(),
@@ -230,35 +234,38 @@ HttpChannelParent::CleanupBackgroundChan
   if (mBgParent) {
     RefPtr<HttpBackgroundChannelParent> bgParent = mBgParent.forget();
     bgParent->OnChannelClosed();
     return;
   }
 
   // The nsHttpChannel may have a reference to this parent, release it
   // to avoid circular references.
-  if (mChannel) {
-    mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
   }
 
   if (!mPromise.IsEmpty()) {
     mRequest.DisconnectIfExists();
     mPromise.Reject(NS_ERROR_FAILURE, __func__);
 
     if (!mChannel) {
       return;
     }
 
     // This HttpChannelParent might still have a reference from
     // BackgroundChannelRegistrar.
     nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
       do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
     MOZ_ASSERT(registrar);
 
-    registrar->DeleteChannel(mChannel->ChannelId());
+    uint64_t channelId = 0;
+    MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+    registrar->DeleteChannel(channelId);
 
     // If mAsyncOpenBarrier is greater than zero, it means AsyncOpen procedure
     // is still on going. we need to abort AsyncOpen with failure to destroy
     // PHttpChannel actor.
     if (mAsyncOpenBarrier) {
       TryInvokeAsyncOpen(NS_ERROR_FAILURE);
     }
   }
@@ -509,85 +516,140 @@ HttpChannelParent::DoAsyncOpen(  const U
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   if (!loadInfo) {
     return SendFailedAsyncOpen(NS_ERROR_UNEXPECTED);
   }
 
-  nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
-                             nullptr, nullptr, aLoadFlags, ios);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
+  RefPtr<HttpBaseChannel> httpChannel;
+
+  if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
+    const nsHttpResponseHead& head =
+      aSynthesizedResponseHead.get_nsHttpResponseHead();
+
+    nsCOMPtr<nsIInputStream> body;
+    rv = NS_NewCStringInputStream(getter_AddRefs(body), EmptyCString());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    RefPtr<InterceptedHttpChannel> intercepted =
+      InterceptedHttpChannel::CreateForSynthesis(&head, body);
+    if (NS_WARN_IF(!intercepted)) {
+      return SendFailedAsyncOpen(NS_ERROR_FAILURE);
+    }
+
+    MOZ_ASSERT(nsHttpChannel::WillRedirect(const_cast<nsHttpResponseHead*>(&head)));
+    intercepted->AutoSuspendRedirectChannel();
+
+    httpChannel = intercepted.forget();
+
+    rv = httpChannel->Init(uri, 0, nullptr, 0, nullptr, aChannelId);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    rv = httpChannel->SetLoadInfo(loadInfo);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    mWillSynthesizeResponse = true;
+    mSynthesizedRedirectWillSuspend = true;
+
+  } else {
+    nsCOMPtr<nsIChannel> channel;
+    rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
+                               nullptr, nullptr, aLoadFlags, ios);
+    if (NS_FAILED(rv)) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    httpChannel = do_QueryObject(channel);
+    if (!httpChannel) {
+      return SendFailedAsyncOpen(NS_ERROR_FAILURE);
+    }
   }
 
-  RefPtr<nsHttpChannel> httpChannel = do_QueryObject(channel, &rv);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
-  }
+  MOZ_DIAGNOSTIC_ASSERT(httpChannel);
 
   // Set the channelId allocated in child to the parent instance
-  httpChannel->SetChannelId(aChannelId);
-  httpChannel->SetTopLevelContentWindowId(aContentWindowId);
-  httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  rv = httpChannel->SetChannelId(aChannelId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelContentWindowId(aContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
-  httpChannel->SetWarningReporter(this);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
   httpChannel->SetTimingEnabled(true);
   if (mPBOverride != kPBOverride_Unset) {
     httpChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
   }
 
-  if (doResumeAt)
+  if (doResumeAt) {
     httpChannel->ResumeAt(startPos, entityID);
+  }
 
   if (originalUri)
     httpChannel->SetOriginalURI(originalUri);
-  if (docUri)
-    httpChannel->SetDocumentURI(docUri);
+  if (docUri) {
+    rv = httpChannel->SetDocumentURI(docUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (referrerUri) {
     rv = httpChannel->SetReferrerWithPolicyInternal(referrerUri, aReferrerPolicy);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
-  if (apiRedirectToUri)
-    httpChannel->RedirectTo(apiRedirectToUri);
+  if (apiRedirectToUri) {
+    rv = httpChannel->RedirectTo(apiRedirectToUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (topWindowUri) {
-    rv = httpChannel->SetTopWindowURI(topWindowUri);
+    rv = httpChannel->SetTopWindowURIIfUnknown(topWindowUri);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
   if (aLoadFlags != nsIRequest::LOAD_NORMAL)
     httpChannel->SetLoadFlags(aLoadFlags);
 
   if (aForceMainDocumentChannel) {
-    httpChannel->SetIsMainDocumentChannel(true);
+    rv = httpChannel->SetIsMainDocumentChannel(true);
+    MOZ_ALWAYS_SUCCEEDS(rv);
   }
 
   for (uint32_t i = 0; i < requestHeaders.Length(); i++) {
     if (requestHeaders[i].mEmpty) {
-      httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      rv = httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     } else {
-      httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
-                                 requestHeaders[i].mValue,
-                                 requestHeaders[i].mMerge);
+      rv = httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
+                                         requestHeaders[i].mValue,
+                                         requestHeaders[i].mMerge);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     }
   }
 
   RefPtr<HttpChannelParentListener> parentListener
     = new HttpChannelParentListener(this);
 
-  httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  rv = httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   if (aCorsPreflightArgs.type() == OptionalCorsPreflightArgs::TCorsPreflightArgs) {
     const CorsPreflightArgs& args = aCorsPreflightArgs.get_CorsPreflightArgs();
     httpChannel->SetCorsPreflightParameters(args.unsafeHeaders());
   }
 
   nsCOMPtr<nsIInputStream> stream = DeserializeIPCStream(uploadStream);
-  if (stream) {
+  if (stream && httpChannelImpl) {
     // FIXME: The fast path of using the existing stream currently only applies to streams
     //   that have had their entire contents serialized from the child at this point.
     //   Once bug 1294446 and bug 1294450 are fixed it is worth revisiting this heuristic.
     nsCOMPtr<nsIIPCSerializableInputStream> completeStream = do_QueryInterface(stream);
     if (!completeStream) {
       // Wait for completion of async copying IPC upload stream to a local input stream.
       ++mAsyncOpenBarrier;
 
@@ -630,23 +692,24 @@ HttpChannelParent::DoAsyncOpen(  const U
       // the AsyncOpen process once the full stream has been received.
       rv = NS_AsyncCopy(stream, sink, target, NS_ASYNCCOPY_VIA_READSEGMENTS,
                         kBufferSize, // copy segment size
                         UploadCopyComplete, closure.release());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return SendFailedAsyncOpen(rv);
       }
 
-      httpChannel->InternalSetUploadStream(newUploadStream);
+      httpChannelImpl->InternalSetUploadStream(newUploadStream);
     } else {
-      httpChannel->InternalSetUploadStream(stream);
+      httpChannelImpl->InternalSetUploadStream(stream);
     }
-    httpChannel->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
+    httpChannelImpl->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
+  /*
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
     parentListener->SetupInterception(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mWillSynthesizeResponse = true;
     httpChannel->SetCouldBeSynthesized();
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
@@ -654,50 +717,64 @@ HttpChannelParent::DoAsyncOpen(  const U
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   } else {
     nsLoadFlags newLoadFlags;
     httpChannel->GetLoadFlags(&newLoadFlags);
     newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
     httpChannel->SetLoadFlags(newLoadFlags);
   }
+  */
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   rv = cacheKey->SetData(aCacheKey);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
-  httpChannel->SetCacheKey(cacheKey);
-  httpChannel->PreferAlternativeDataType(aPreferredAlternativeType);
+  nsCOMPtr<nsICacheInfoChannel> cacheChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(httpChannel));
+  if (cacheChannel) {
+    cacheChannel->SetCacheKey(cacheKey);
+    cacheChannel->PreferAlternativeDataType(aPreferredAlternativeType);
 
-  httpChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
+    cacheChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
+  }
 
   httpChannel->SetContentType(aContentTypeHint);
 
   if (priority != nsISupportsPriority::PRIORITY_NORMAL) {
     httpChannel->SetPriority(priority);
   }
   if (classOfService) {
     httpChannel->SetClassFlags(classOfService);
   }
-  httpChannel->SetRedirectionLimit(redirectionLimit);
-  httpChannel->SetAllowSTS(allowSTS);
-  httpChannel->SetThirdPartyFlags(thirdPartyFlags);
-  httpChannel->SetAllowSpdy(allowSpdy);
-  httpChannel->SetAllowAltSvc(allowAltSvc);
-  httpChannel->SetBeConservative(beConservative);
-  httpChannel->SetTlsFlags(tlsFlags);
-  httpChannel->SetInitialRwin(aInitialRwin);
-  httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  rv = httpChannel->SetRedirectionLimit(redirectionLimit);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowSTS(allowSTS);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetThirdPartyFlags(thirdPartyFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowSpdy(allowSpdy);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowAltSvc(allowAltSvc);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetBeConservative(beConservative);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTlsFlags(tlsFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetInitialRwin(aInitialRwin);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   httpChannel->SetLaunchServiceWorkerStart(aLaunchServiceWorkerStart);
   httpChannel->SetLaunchServiceWorkerEnd(aLaunchServiceWorkerEnd);
   httpChannel->SetDispatchFetchEventStart(aDispatchFetchEventStart);
   httpChannel->SetDispatchFetchEventEnd(aDispatchFetchEventEnd);
   httpChannel->SetHandleFetchEventStart(aHandleFetchEventStart);
   httpChannel->SetHandleFetchEventEnd(aHandleFetchEventEnd);
 
@@ -733,17 +810,18 @@ HttpChannelParent::DoAsyncOpen(  const U
       // This works because we've already called SetNotificationCallbacks and
       // done mPBOverride logic by this point.
       chooseAppCache = NS_ShouldCheckAppCache(principal);
 
       appCacheChan->SetChooseApplicationCache(chooseAppCache);
     }
   }
 
-  httpChannel->SetRequestContextID(aRequestContextID);
+  rv = httpChannel->SetRequestContextID(aRequestContextID);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   // Store the strong reference of channel and parent listener object until
   // all the initialization procedure is complete without failure, to remove
   // cycle reference in fail case and to avoid memory leakage.
   mChannel = httpChannel.forget();
   mParentListener = parentListener.forget();
   mChannel->SetNotificationCallbacks(mParentListener);
 
@@ -776,17 +854,19 @@ HttpChannelParent::WaitForBgParent()
   LOG(("HttpChannelParent::WaitForBgParent [this=%p]\n", this));
   MOZ_ASSERT(!mBgParent);
   MOZ_ASSERT(mChannel);
 
 
   nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
     do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
   MOZ_ASSERT(registrar);
-  registrar->LinkHttpChannel(mChannel->ChannelId(), this);
+  uint64_t channelId = 0;
+  MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+  registrar->LinkHttpChannel(channelId, this);
 
   if (mBgParent) {
     already_AddRefed<GenericPromise> promise = mPromise.Ensure(__func__);
     // resolve promise immediatedly if bg channel is ready.
     mPromise.Resolve(true, __func__);
     return promise;
   }
 
@@ -797,42 +877,48 @@ bool
 HttpChannelParent::ConnectChannel(const uint32_t& registrarId, const bool& shouldIntercept)
 {
   nsresult rv;
 
   LOG(("HttpChannelParent::ConnectChannel: Looking for a registered channel "
        "[this=%p, id=%" PRIu32 "]\n", this, registrarId));
   nsCOMPtr<nsIChannel> channel;
   rv = NS_LinkRedirectChannels(registrarId, this, getter_AddRefs(channel));
-  if (NS_FAILED(rv)) {
+  if (NS_WARN_IF(NS_FAILED(rv))) {
     NS_ERROR("Could not find the http channel to connect its IPC parent");
     // This makes the channel delete itself safely.  It's the only thing
     // we can do now, since this parent channel cannot be used and there is
     // no other way to tell the child side there were something wrong.
     Delete();
     return true;
   }
 
   LOG(("  found channel %p, rv=%08" PRIx32, channel.get(), static_cast<uint32_t>(rv)));
   mChannel = do_QueryObject(channel);
-  if (!mChannel) {
+  if (NS_WARN_IF(!mChannel)) {
     LOG(("  but it's not nsHttpChannel"));
     Delete();
     return true;
   }
 
+  uint64_t channelId = 0;
+  Unused << mChannel->GetChannelId(&channelId);
+
   LOG(("  and it is nsHttpChannel %p", mChannel.get()));
 
-  mChannel->SetWarningReporter(this);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
 
   nsCOMPtr<nsINetworkInterceptController> controller;
   NS_QueryNotificationCallbacks(channel, controller);
   RefPtr<HttpChannelParentListener> parentListener = do_QueryObject(controller);
   MOZ_ASSERT(parentListener);
-  parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
+  //parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
 
   if (mPBOverride != kPBOverride_Unset) {
     // redirected-to channel may not support PB
     nsCOMPtr<nsIPrivateBrowsingChannel> pbChannel = do_QueryObject(mChannel);
     if (pbChannel) {
       pbChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
     }
   }
@@ -1404,100 +1490,111 @@ HttpChannelParent::OnStartRequest(nsIReq
 {
   LOG(("HttpChannelParent::OnStartRequest [this=%p, aRequest=%p]\n",
        this, aRequest));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStartRequest if diverting is set!");
 
-  RefPtr<nsHttpChannel> chan = do_QueryObject(aRequest);
+  RefPtr<HttpBaseChannel> chan = do_QueryObject(aRequest);
   if (!chan) {
-    LOG(("  aRequest is not nsHttpChannel"));
-    NS_ERROR("Expecting only nsHttpChannel as aRequest in HttpChannelParent::OnStartRequest");
+    LOG(("  aRequest is not HttpBaseChannel"));
+    NS_ERROR("Expecting only HttpBaseChannel as aRequest in HttpChannelParent::OnStartRequest");
     return NS_ERROR_UNEXPECTED;
   }
 
   MOZ_ASSERT(mChannel == chan,
-             "HttpChannelParent getting OnStartRequest from a different nsHttpChannel instance");
+             "HttpChannelParent getting OnStartRequest from a different HttpBaseChannel instance");
 
   // Send down any permissions which are relevant to this URL if we are
   // performing a document load. We can't do that is mIPCClosed is set.
   if (!mIPCClosed) {
     PContentParent* pcp = Manager()->Manager();
     MOZ_ASSERT(pcp, "We should have a manager if our IPC isn't closed");
     DebugOnly<nsresult> rv =
       static_cast<ContentParent*>(pcp)->AboutToLoadHttpFtpWyciwygDocumentForChild(chan);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 
   nsHttpResponseHead *responseHead = chan->GetResponseHead();
   nsHttpRequestHead  *requestHead = chan->GetRequestHead();
+
   bool isFromCache = false;
-  chan->IsFromCache(&isFromCache);
   int32_t fetchCount = 0;
-  chan->GetCacheTokenFetchCount(&fetchCount);
   uint32_t expirationTime = nsICacheEntry::NO_EXPIRATION_TIME;
-  chan->GetCacheTokenExpirationTime(&expirationTime);
   nsCString cachedCharset;
-  chan->GetCacheTokenCachedCharset(cachedCharset);
 
-  bool loadedFromApplicationCache;
-  chan->GetLoadedFromApplicationCache(&loadedFromApplicationCache);
-  if (loadedFromApplicationCache) {
-    mOfflineForeignMarker = chan->GetOfflineCacheEntryAsForeignMarker();
-    nsCOMPtr<nsIApplicationCache> appCache;
-    chan->GetApplicationCache(getter_AddRefs(appCache));
-    nsCString appCacheGroupId;
-    nsCString appCacheClientId;
-    appCache->GetGroupID(appCacheGroupId);
-    appCache->GetClientID(appCacheClientId);
-    if (mIPCClosed ||
-        !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
-    {
-      return NS_ERROR_UNEXPECTED;
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(chan);
+
+  if (httpChannelImpl) {
+    httpChannelImpl->IsFromCache(&isFromCache);
+    httpChannelImpl->GetCacheTokenFetchCount(&fetchCount);
+    httpChannelImpl->GetCacheTokenExpirationTime(&expirationTime);
+    httpChannelImpl->GetCacheTokenCachedCharset(cachedCharset);
+  }
+
+  bool loadedFromApplicationCache = false;
+
+  if (httpChannelImpl) {
+    httpChannelImpl->GetLoadedFromApplicationCache(&loadedFromApplicationCache);
+    if (loadedFromApplicationCache) {
+      mOfflineForeignMarker = httpChannelImpl->GetOfflineCacheEntryAsForeignMarker();
+      nsCOMPtr<nsIApplicationCache> appCache;
+      httpChannelImpl->GetApplicationCache(getter_AddRefs(appCache));
+      nsCString appCacheGroupId;
+      nsCString appCacheClientId;
+      appCache->GetGroupID(appCacheGroupId);
+      appCache->GetClientID(appCacheClientId);
+      if (mIPCClosed ||
+          !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
+      {
+        return NS_ERROR_UNEXPECTED;
+      }
     }
   }
 
-  nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(aRequest);
-  if (encodedChannel)
-    encodedChannel->SetApplyConversion(false);
+  chan->SetApplyConversion(false);
 
   // Keep the cache entry for future use in RecvSetCacheTokenCachedCharset().
   // It could be already released by nsHttpChannel at that time.
   nsCOMPtr<nsISupports> cacheEntry;
-  chan->GetCacheToken(getter_AddRefs(cacheEntry));
-  mCacheEntry = do_QueryInterface(cacheEntry);
+  nsresult channelStatus = NS_OK;
+  uint32_t cacheKeyValue = 0;
+  nsAutoCString altDataType;
 
-  nsresult channelStatus = NS_OK;
-  chan->GetStatus(&channelStatus);
+  if (httpChannelImpl) {
+    httpChannelImpl->GetCacheToken(getter_AddRefs(cacheEntry));
+    mCacheEntry = do_QueryInterface(cacheEntry);
+
+    httpChannelImpl->GetStatus(&channelStatus);
+
+    nsCOMPtr<nsISupports> cacheKey;
+    httpChannelImpl->GetCacheKey(getter_AddRefs(cacheKey));
+    if (cacheKey) {
+      nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(cacheKey);
+      if (!container) {
+        return NS_ERROR_ILLEGAL_VALUE;
+      }
+
+      nsresult rv = container->GetData(&cacheKeyValue);
+      if (NS_FAILED(rv)) {
+        return rv;
+      }
+    }
+
+    httpChannelImpl->GetAlternativeDataType(altDataType);
+  }
 
   nsCString secInfoSerialization;
   UpdateAndSerializeSecurityInfo(secInfoSerialization);
 
   uint16_t redirectCount = 0;
   chan->GetRedirectCount(&redirectCount);
 
-  nsCOMPtr<nsISupports> cacheKey;
-  chan->GetCacheKey(getter_AddRefs(cacheKey));
-  uint32_t cacheKeyValue = 0;
-  if (cacheKey) {
-    nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(cacheKey);
-    if (!container) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-
-    nsresult rv = container->GetData(&cacheKeyValue);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-  }
-
-  nsAutoCString altDataType;
-  chan->GetAlternativeDataType(altDataType);
   int64_t altDataLen = chan->GetAltDataLength();
 
   // !!! We need to lock headers and please don't forget to unlock them !!!
   requestHead->Enter();
   nsresult rv = NS_OK;
   if (mIPCClosed ||
       !SendOnStartRequest(channelStatus,
                           responseHead ? *responseHead : nsHttpResponseHead(),
@@ -1530,44 +1627,52 @@ HttpChannelParent::OnStartRequest(nsIReq
   return rv;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::OnStopRequest(nsIRequest *aRequest,
                                  nsISupports *aContext,
                                  nsresult aStatusCode)
 {
+  nsAutoCString name;
+  GetErrorName(aStatusCode, name);
   LOG(("HttpChannelParent::OnStopRequest: [this=%p aRequest=%p status=%" PRIx32 "]\n",
        this, aRequest, static_cast<uint32_t>(aStatusCode)));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStopRequest if diverting is set!");
+
   ResourceTimingStruct timing;
   mChannel->GetDomainLookupStart(&timing.domainLookupStart);
   mChannel->GetDomainLookupEnd(&timing.domainLookupEnd);
   mChannel->GetConnectStart(&timing.connectStart);
   mChannel->GetSecureConnectionStart(&timing.secureConnectionStart);
   mChannel->GetConnectEnd(&timing.connectEnd);
   mChannel->GetRequestStart(&timing.requestStart);
   mChannel->GetResponseStart(&timing.responseStart);
   mChannel->GetResponseEnd(&timing.responseEnd);
   mChannel->GetAsyncOpen(&timing.fetchStart);
   mChannel->GetRedirectStart(&timing.redirectStart);
   mChannel->GetRedirectEnd(&timing.redirectEnd);
-  mChannel->GetTransferSize(&timing.transferSize);
-  mChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  nsresult rv = mChannel->GetTransferSize(&timing.transferSize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = mChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
   // decodedBodySize can be computed in the child process so it doesn't need
   // to be passed down.
-  mChannel->GetProtocolVersion(timing.protocolVersion);
+  Unused << mChannel->GetProtocolVersion(timing.protocolVersion);
 
   mChannel->GetCacheReadStart(&timing.cacheReadStart);
   mChannel->GetCacheReadEnd(&timing.cacheReadEnd);
 
-  mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
+  }
 
   // Either IPC channel is closed or background channel
   // is ready to send OnStopRequest.
   MOZ_ASSERT(mIPCClosed || mBgParent);
 
   if (mIPCClosed ||
       !mBgParent || !mBgParent->OnStopRequest(aStatusCode, timing)) {
     return NS_ERROR_UNEXPECTED;
@@ -1592,19 +1697,21 @@ HttpChannelParent::OnDataAvailable(nsIRe
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnDataAvailable if diverting is set!");
 
   nsresult channelStatus = NS_OK;
   mChannel->GetStatus(&channelStatus);
 
-  nsresult transportStatus =
-    (mChannel->IsReadingFromCache()) ? NS_NET_STATUS_READING
-                                     : NS_NET_STATUS_RECEIVING_FROM;
+  nsresult transportStatus = NS_NET_STATUS_RECEIVING_FROM;
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl && httpChannelImpl->IsReadingFromCache()) {
+    transportStatus = NS_NET_STATUS_READING;
+  }
 
   static uint32_t const kCopyChunkSize = 128 * 1024;
   uint32_t toRead = std::min<uint32_t>(aCount, kCopyChunkSize);
 
   nsCString data;
   if (!data.SetCapacity(toRead, fallible)) {
     LOG(("  out of memory!"));
     return NS_ERROR_OUT_OF_MEMORY;
@@ -1793,17 +1900,17 @@ HttpChannelParent::StartRedirect(uint32_
   SerializeURI(newOriginalURI, uriParams);
 
   nsCString secInfoSerialization;
   UpdateAndSerializeSecurityInfo(secInfoSerialization);
 
   // If the channel is a HTTP channel, we also want to inform the child
   // about the parent's channelId attribute, so that both parent and child
   // share the same ID. Useful for monitoring channel activity in devtools.
-  uint64_t channelId;
+  uint64_t channelId = 0;
   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
   if (httpChannel) {
     rv = httpChannel->GetChannelId(&channelId);
     NS_ENSURE_SUCCESS(rv, NS_BINDING_ABORTED);
   }
 
   nsHttpResponseHead *responseHead = mChannel->GetResponseHead();
   bool result = false;
@@ -1868,33 +1975,35 @@ HttpChannelParent::SuspendForDiversion()
 
   if (NS_WARN_IF(mDivertingFromChild)) {
     MOZ_ASSERT(!mDivertingFromChild, "Already suspended for diversion!");
     return NS_ERROR_UNEXPECTED;
   }
 
   // MessageDiversionStarted call will suspend mEventQ as many times as the
   // channel has been suspended, so that channel and this queue are in sync.
-  mChannel->MessageDiversionStarted(this);
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+  divertChannel->MessageDiversionStarted(this);
 
   nsresult rv = NS_OK;
 
   // Try suspending the channel. Allow it to fail, since OnStopRequest may have
   // been called and thus the channel may not be pending.  If we've already
   // automatically suspended after synthesizing the response, then we don't
   // need to suspend again here.
   if (!mSuspendAfterSynthesizeResponse) {
     // We need to suspend only nsHttpChannel (i.e. we should not suspend
     // mEventQ). Therefore we call mChannel->SuspendInternal() and not
     // mChannel->Suspend().
     // We are suspending only nsHttpChannel here because we want to stop
     // OnDataAvailable until diversion is over. At the same time we should
     // send the diverted OnDataAvailable-s to the listeners and not queue them
     // in mEventQ.
-    rv = mChannel->SuspendInternal();
+    rv = divertChannel->SuspendInternal();
     MOZ_ASSERT(NS_SUCCEEDED(rv) || rv == NS_ERROR_NOT_AVAILABLE);
     mSuspendedForDiversion = NS_SUCCEEDED(rv);
   } else {
     // Take ownership of the automatic suspend that occurred after synthesizing
     // the response.
     mSuspendedForDiversion = true;
 
     // If mSuspendAfterSynthesizeResponse is true channel has been already
@@ -1939,21 +2048,23 @@ HttpChannelParent::ResumeForDiversion()
   LOG(("HttpChannelParent::ResumeForDiversion [this=%p]\n", this));
   MOZ_ASSERT(mChannel);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot ResumeForDiversion if not diverting!");
     return NS_ERROR_UNEXPECTED;
   }
 
-  mChannel->MessageDiversionStop();
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+  divertChannel->MessageDiversionStop();
 
   if (mSuspendedForDiversion) {
     // The nsHttpChannel will deliver remaining OnData/OnStop for the transfer.
-    nsresult rv = mChannel->ResumeInternal();
+    nsresult rv = divertChannel->ResumeInternal();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
     mSuspendedForDiversion = false;
   }
 
   if (NS_WARN_IF(mIPCClosed || !DoSendDeleteSelf())) {
     return NS_ERROR_UNEXPECTED;
@@ -2025,17 +2136,18 @@ HttpChannelParent::StartDiversion()
   mDivertedOnStartRequest = true;
 
   // After OnStartRequest has been called, setup content decoders if needed.
   //
   // Create a content conversion chain based on mDivertListener and update
   // mDivertListener.
   nsCOMPtr<nsIStreamListener> converterListener;
   Unused << mChannel->DoApplyContentConversions(mDivertListener,
-                                                getter_AddRefs(converterListener));
+                                                getter_AddRefs(converterListener),
+                                                nullptr);
   if (converterListener) {
     mDivertListener = converterListener.forget();
   }
 
   // Now mParentListener can be diverted to mDivertListener.
   DebugOnly<nsresult> rvdbg = mParentListener->DivertTo(mDivertListener);
   MOZ_ASSERT(NS_SUCCEEDED(rvdbg));
   mDivertListener = nullptr;
@@ -2099,17 +2211,19 @@ HttpChannelParent::NotifyDiversionFailed
   mChannel->ForcePending(false);
 
   bool isPending = false;
   nsresult rv = mChannel->IsPending(&isPending);
   MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));
 
   // Resume only if we suspended earlier.
   if (mSuspendedForDiversion) {
-    mChannel->ResumeInternal();
+    nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+      do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+    divertChannel->ResumeInternal();
   }
   // Channel has already sent OnStartRequest to the child, so ensure that we
   // call it here if it hasn't already been called.
   if (!mDivertedOnStartRequest) {
     mChannel->ForcePending(true);
     mParentListener->OnStartRequest(mChannel, nullptr);
     mChannel->ForcePending(false);
   }
@@ -2186,22 +2300,28 @@ HttpChannelParent::RecvDeletingChannel()
     return IPC_FAIL_NO_REASON(this);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvFinishInterceptedRedirect()
 {
+
   // We make sure not to send any more messages until the IPC channel is torn
   // down by the child.
   mIPCClosed = true;
   if (!SendFinishInterceptedRedirect()) {
     return IPC_FAIL_NO_REASON(this);
   }
+
+  // Resume the channel since we called
+  // InterceptedHttpChannel::AutoSuspendRedirectChannel earlier.
+  mChannel->Resume();
+
   return IPC_OK();
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelSecurityWarningReporter
 //-----------------------------------------------------------------------------
 
 nsresult
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -255,17 +255,17 @@ private:
   // DocumentChannelCleanup.
   void CleanupBackgroundChannel();
 
   friend class HttpBackgroundChannelParent;
   friend class DivertDataAvailableEvent;
   friend class DivertStopRequestEvent;
   friend class DivertCompleteEvent;
 
-  RefPtr<nsHttpChannel>       mChannel;
+  RefPtr<HttpBaseChannel>       mChannel;
   nsCOMPtr<nsICacheEntry>       mCacheEntry;
   nsCOMPtr<nsIAssociatedContentSecurity>  mAssociatedContentSecurity;
   bool mIPCClosed;                // PHttpChannel actor has been Closed()
 
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
 
   nsAutoPtr<class nsHttpChannel::OfflineCacheEntryAsForeignMarker> mOfflineForeignMarker;
@@ -301,16 +301,17 @@ private:
   bool mDivertedOnStartRequest;
 
   bool mSuspendedForDiversion;
 
   // Set if this channel should be suspended after synthesizing a response.
   bool mSuspendAfterSynthesizeResponse;
   // Set if this channel will synthesize its response.
   bool mWillSynthesizeResponse;
+  bool mSynthesizedRedirectWillSuspend;
 
   dom::TabId mNestedFrameId;
 
   RefPtr<ChannelEventQueue> mEventQ;
 
   RefPtr<HttpBackgroundChannelParent> mBgParent;
 
   // Number of events to wait before actually invoking AsyncOpen on the main
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -0,0 +1,818 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "InterceptedHttpChannel.h"
+#include "nsContentSecurityManager.h"
+#include "nsEscape.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
+                            HttpBaseChannel,
+                            nsIInterceptedChannel,
+                            nsIAsyncVerifyRedirectCallback,
+                            nsIRequestObserver,
+                            nsIStreamListener)
+
+InterceptedHttpChannel::InterceptedHttpChannel()
+  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+  , mSuspendRedirectChannel(false)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  mChannelCreationTime = PR_Now();
+  mChannelCreationTimestamp = TimeStamp::Now();
+}
+
+InterceptedHttpChannel::~InterceptedHttpChannel()
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+}
+
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForInterception()
+{
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+  return ref.forget();
+}
+
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForSynthesis(const nsHttpResponseHead* aHead,
+                                           nsIInputStream* aBody)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aHead);
+  MOZ_DIAGNOSTIC_ASSERT(aBody);
+
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+
+  ref->mBodyReader = aBody;
+  ref->mResponseHead = new nsHttpResponseHead(*aHead);
+
+  return ref.forget();
+}
+
+void
+InterceptedHttpChannel::AutoSuspendRedirectChannel()
+{
+  mSuspendRedirectChannel = true;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Cancel(nsresult aStatus)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return CancelInterception(aStatus);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Suspend(void)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  ++mSuspendCount;
+  if (mPump) {
+    return mPump->Suspend();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Resume(void)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  --mSuspendCount;
+  if (mPump) {
+    return mPump->Resume();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecurityInfo(nsISupports** aSecurityInfo)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  nsCOMPtr<nsISupports> ref(mSecurityInfo);
+  ref.forget(aSecurityInfo);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen(nsIStreamListener* aListener, nsISupports* aContext)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  printf_stderr("### ### [%p] saving mListener %p\n", this, aListener);
+  mListener = aListener;
+
+  nsCOMPtr<nsINetworkInterceptController> controller;
+  GetCallback(controller);
+
+  if (NS_WARN_IF(!controller)) {
+    ReleaseListeners();
+    return NS_ERROR_FAILURE;
+  }
+
+  mResponseCouldBeSynthesized = true;
+
+  if (mLoadGroup) {
+    mLoadGroup->AddRequest(this, nullptr);
+  }
+
+  // If we already have a synthesized body then this is a "fake redirect"
+  // from a channel synthesized with an opaque response.
+  if (mBodyReader) {
+    if (nsHttpChannel::WillRedirect(mResponseHead) &&
+        !mLoadInfo->GetDontFollowRedirects()) {
+      printf_stderr("### ### will redirect\n");
+      nsCOMPtr<nsIIOService> ioService;
+      nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsAutoCString location;
+      rv = mResponseHead->GetHeader(nsHttp::Location, location);
+      NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+      // make sure non-ASCII characters in the location header are escaped.
+      nsAutoCString locationBuf;
+      if (NS_EscapeURL(location.get(), -1, esc_OnlyNonASCII, locationBuf)) {
+        location = locationBuf;
+      }
+
+      if (NS_WARN_IF(mRedirectionLimit == 0)) {
+        return NS_ERROR_REDIRECT_LOOP;
+      }
+
+      nsCOMPtr<nsIURI> redirectURI;
+      rv = ioService->NewURI(nsDependentCString(location.get()),
+                             nullptr,
+                             mURI,
+                             getter_AddRefs(redirectURI));
+      NS_ENSURE_SUCCESS(rv, NS_ERROR_CORRUPTED_CONTENT);
+
+      uint32_t redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
+      if (nsHttp::IsPermanentRedirect(mResponseHead->Status())) {
+        redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
+      }
+
+      bool rewriteToGET = ShouldRewriteRedirectToGET(mResponseHead->Status(),
+                                                     mRequestHead.ParsedMethod());
+
+      nsCOMPtr<nsIChannel> newChannel;
+      nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+        CloneLoadInfoForRedirect(redirectURI, redirectFlags);
+      rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                                 redirectURI,
+                                 redirectLoadInfo,
+                                 nullptr, // aLoadGroup
+                                 nullptr, // aCallbacks
+                                 mLoadFlags,
+                                 ioService);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = SetupReplacementChannel(redirectURI, newChannel, !rewriteToGET,
+                                   redirectFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      mRedirectChannel = newChannel.forget();
+
+      rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, redirectFlags);
+
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        OnRedirectVerifyCallback(rv);
+      }
+
+      printf_stderr("### ### will redirect complete - %s\n", (NS_SUCCEEDED(rv) ? "succeeded" : "failed"));
+      return rv;
+    }
+
+    nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mPump),
+                                            mBodyReader,
+                                            int64_t(-1), int64_t(-1), 0, 0, true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = mPump->AsyncRead(this, mListenerContext);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    for (uint32_t i = 0; i < mSuspendCount; ++i) {
+      mPump->Suspend();
+    }
+
+    return rv;
+  }
+
+  // Otherwise start the service worker interception.
+  nsresult rv = controller->ChannelIntercepted(this);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen2(nsIStreamListener* aListener)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  nsCOMPtr<nsIStreamListener> listener(aListener);
+  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+  return AsyncOpen(listener, nullptr);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::LogBlockedCORSRequest(const nsAString& aMessage)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetupFallbackChannel(const char*  aFallbackKey)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ForceIntercepted(uint64_t aInterceptionID)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseSynthesized(bool* aResponseSynthesized)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  *aResponseSynthesized = mResponseHead || mBodyReader;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetPriority(int32_t aPriority)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetClassFlags(uint32_t aClassFlags)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ClearClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AddClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResumeAt(uint64_t startPos, const nsACString & entityID)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void
+InterceptedHttpChannel::DoNotifyListenerCleanup()
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResetInterception(void)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  printf_stderr("### ### [%p] mListener is %p\n", this, mListener.get());
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIIOService> ioService;
+  rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
+
+  nsCOMPtr<nsIChannel> newChannel;
+  nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+    CloneLoadInfoForRedirect(mURI, flags);
+  rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                             mURI,
+                             redirectLoadInfo,
+                             nullptr, // aLoadGroup
+                             nullptr, // aCallbacks
+                             mLoadFlags,
+                             ioService);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = SetupReplacementChannel(mURI, newChannel, true, flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+    nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
+    rv = newChannel->GetLoadFlags(&loadFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+    loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+    rv = newChannel->SetLoadFlags(loadFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  mRedirectChannel = newChannel.forget();
+
+  rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
+
+  if (NS_FAILED(rv)) {
+    OnRedirectVerifyCallback(rv);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeStatus(uint16_t aStatus,
+                                         const nsACString& aReason)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  nsAutoCString statusLine;
+  statusLine.AppendLiteral("HTTP/1.1 ");
+  statusLine.AppendInt(aStatus);
+  statusLine.AppendLiteral(" ");
+  statusLine.Append(aReason);
+
+  mSynthesizedResponseHead->ParseStatusLine(statusLine);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeHeader(const nsACString& aName,
+                                         const nsACString& aValue)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  nsAutoCString header = aName + NS_LITERAL_CSTRING(": ") + aValue;
+  // Overwrite any existing header.
+  nsresult rv = mSynthesizedResponseHead->ParseHeaderLine(header);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  if (mBodyWriter) {
+    mBodyWriter->Close();
+  }
+
+  if (!mSynthesizedResponseHead) {
+    mSynthesizedResponseHead.reset(new nsHttpResponseHead());
+  }
+
+  mResponseHead = mSynthesizedResponseHead.release();
+
+  if (nsHttpChannel::WillRedirect(mResponseHead) &&
+      !mLoadInfo->GetDontFollowRedirects()) {
+    printf_stderr("### ### will redirect\n");
+    nsCOMPtr<nsIIOService> ioService;
+    nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsAutoCString location;
+    rv = mResponseHead->GetHeader(nsHttp::Location, location);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+    // make sure non-ASCII characters in the location header are escaped.
+    nsAutoCString locationBuf;
+    if (NS_EscapeURL(location.get(), -1, esc_OnlyNonASCII, locationBuf)) {
+      location = locationBuf;
+    }
+
+    if (NS_WARN_IF(mRedirectionLimit == 0)) {
+      return NS_ERROR_REDIRECT_LOOP;
+    }
+
+    nsCOMPtr<nsIURI> redirectURI;
+    rv = ioService->NewURI(nsDependentCString(location.get()),
+                           nullptr,
+                           mURI,
+                           getter_AddRefs(redirectURI));
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_CORRUPTED_CONTENT);
+
+    uint32_t redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
+    if (nsHttp::IsPermanentRedirect(mResponseHead->Status())) {
+      redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
+    }
+
+    bool rewriteToGET = ShouldRewriteRedirectToGET(mResponseHead->Status(),
+                                                   mRequestHead.ParsedMethod());
+
+    nsCOMPtr<nsIChannel> newChannel;
+    nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+      CloneLoadInfoForRedirect(redirectURI, redirectFlags);
+    rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                               redirectURI,
+                               redirectLoadInfo,
+                               nullptr, // aLoadGroup
+                               nullptr, // aCallbacks
+                               mLoadFlags,
+                               ioService);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = SetupReplacementChannel(redirectURI, newChannel, !rewriteToGET,
+                                 redirectFlags);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mRedirectChannel = newChannel.forget();
+
+    rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, redirectFlags);
+
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      OnRedirectVerifyCallback(rv);
+    }
+
+    printf_stderr("### ### will redirect complete - %s\n", (NS_SUCCEEDED(rv) ? "succeeded" : "failed"));
+    return rv;
+  }
+
+  SetApplyConversion(false);
+
+  if (!mBodyReader) {
+    nsresult rv = NS_NewCStringInputStream(getter_AddRefs(mBodyReader),
+                                           EmptyCString());
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  nsCOMPtr<nsIURI> responseURI;
+  if (!aFinalURLSpec.IsEmpty()) {
+    nsresult rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
+    NS_ENSURE_SUCCESS(rv, rv);
+  } else {
+    responseURI = mURI;
+  }
+
+  bool equal = false;
+  Unused << mURI->Equals(responseURI, &equal);
+  if (!equal) {
+    nsresult rv = NS_OK;
+
+    RefPtr<InterceptedHttpChannel> newChannel =
+      CreateForSynthesis(mResponseHead, mBodyReader);
+
+    rv = newChannel->Init(responseURI, mCaps,
+                          static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                          mProxyResolveFlags, mProxyURI, mChannelId);
+
+    uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
+
+    nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+      CloneLoadInfoForRedirect(responseURI, flags);
+    newChannel->SetLoadInfo(redirectLoadInfo);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = SetupReplacementChannel(responseURI, newChannel, true, flags);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    //newChannel->mBodyReader = mBodyReader.forget();
+    //newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
+
+    mRedirectChannel = newChannel;
+
+    rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
+
+    if (NS_FAILED(rv)) {
+      OnRedirectVerifyCallback(rv);
+    }
+
+    return rv;
+  }
+
+  nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mPump),
+                                          mBodyReader,
+                                          int64_t(-1), int64_t(-1), 0, 0, true);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mPump->AsyncRead(this, nullptr);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return rv;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::CancelInterception(nsresult aStatus)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  if (mPump) {
+    return mPump->Cancel(aStatus);
+  }
+
+  return AsyncAbort(aStatus);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseBody(nsIOutputStream** aResponseBody)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (!mBodyWriter) {
+    nsresult rv = NS_NewPipe(getter_AddRefs(mBodyReader),
+                             getter_AddRefs(mBodyWriter),
+                             0,          // default segment size
+                             UINT32_MAX, // infinite pipe length
+                             true,       // non-blocking reader
+                             true);      // non-blocking writer
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  nsCOMPtr<nsIOutputStream> ref(mBodyWriter);
+  ref.forget(aResponseBody);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetChannel(nsIChannel** aChannel)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  nsCOMPtr<nsIChannel> ref(this);
+  ref.forget(aChannel);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecureUpgradedChannelURI(nsIURI** aSecureUpgradedChannelURI)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  // TODO: Is this correct for e10s?
+  nsCOMPtr<nsIURI> ref(mURI);
+  ref.forget(aSecureUpgradedChannelURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return aChannelInfo->ResurrectInfoOnChannel(this);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetInternalContentPolicyType(nsContentPolicyType* aPolicyType)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (mLoadInfo) {
+    *aPolicyType = mLoadInfo->InternalContentPolicyType();
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector** aConsoleReportCollector)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerStart(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::GetLaunchServiceWorkerStart(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetLaunchServiceWorkerStart(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerEnd(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::GetLaunchServiceWorkerEnd(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetLaunchServiceWorkerEnd(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetDispatchFetchEventStart(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetDispatchFetchEventEnd(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetHandleFetchEventStart(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return HttpBaseChannel::SetHandleFetchEventEnd(aTimeStamp);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishResponseStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishSynthesizedResponseEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelResetEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SaveTimeStamps(void)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetReleaseHandle(nsISupports* aHandle)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  mReleaseHandle = aHandle;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnRedirectVerifyCallback(nsresult rv)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+
+  printf_stderr("### ### [%p] mListener is %p\n", this, mListener.get());
+  printf_stderr("### ### [%p] result is %s\n", this, (NS_FAILED(rv) ? "failed" : "success"));
+
+  nsCOMPtr<nsIRedirectResultListener> hook;
+  GetCallback(hook);
+
+  if (NS_SUCCEEDED(rv)) {
+    // TODO: move this into a separate method like OpenRedirectChannel()?
+
+    // Make sure to do this after we received redirect veto answer,
+    // i.e. after all sinks had been notified
+    mRedirectChannel->SetOriginalURI(mOriginalURI);
+
+    // open new channel
+    if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
+      printf_stderr("### ### calling AsyncOpen2()\n");
+      MOZ_ASSERT(!mListenerContext, "mListenerContext should be null!");
+      rv = mRedirectChannel->AsyncOpen2(mListener);
+    }
+    else {
+      printf_stderr("### ### calling AsyncOpen()\n");
+      rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
+    }
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // The code that called AutoSuspendRedirectChannel() is responsible
+    // for calling Resume().
+    if (mSuspendRedirectChannel) {
+      printf_stderr("### ### [%p] InterceptedHttpChannel::%s auto suspending\n", this, __func__);
+      mRedirectChannel->Suspend();
+    }
+
+    mStatus = NS_BINDING_REDIRECTED;
+
+    if (hook) {
+      hook->OnRedirectResult(true);
+    }
+
+    ReleaseListeners();
+  }
+
+  if (NS_FAILED(rv)) {
+    if (hook) {
+      hook->OnRedirectResult(false);
+    }
+    // Cancel the channel here, the update to https had been vetoed
+    // but from the security reasons we have to discard the whole channel
+    // load.
+    Cancel(rv);
+  }
+
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnStartRequest(nsIRequest* aRequest,
+                                       nsISupports* aContext)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (mListener) {
+    mListener->OnStartRequest(this, mListenerContext);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnStopRequest(nsIRequest* aRequest,
+                                      nsISupports* aContext,
+                                      nsresult aStatus)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (mListener) {
+    mListener->OnStopRequest(this, mListenerContext, aStatus);
+  }
+  ReleaseListeners();
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnDataAvailable(nsIRequest* aRequest,
+                                        nsISupports* aContext,
+                                        nsIInputStream* aInputStream,
+                                        uint64_t aOffset,
+                                        uint32_t aCount)
+{
+  printf_stderr("### ### [%p] InterceptedHttpChannel::%s\n", this, __func__);
+  if (mProgressSink) {
+    if (!(mLoadFlags & HttpBaseChannel::LOAD_BACKGROUND)) {
+      nsAutoCString host;
+      mURI->GetHost(host);
+
+      mProgressSink->OnStatus(this, mListenerContext, NS_NET_STATUS_READING,
+                              NS_ConvertUTF8toUTF16(host).get());
+
+      // TODO: fix max length
+      int64_t progress = aOffset + aCount;
+      mProgressSink->OnProgress(this, mListenerContext, progress, -1);
+    }
+  }
+
+  if (mListener) {
+    mListener->OnDataAvailable(this, mListenerContext, aInputStream,
+                               aOffset, aCount);
+  }
+
+  return NS_OK;
+}
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -0,0 +1,105 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_InterceptedHttpChannel_h
+#define mozilla_net_InterceptedHttpChannel_h
+
+#include "HttpBaseChannel.h"
+#include "nsINetworkInterceptController.h"
+#include "nsIInputStream.h"
+
+namespace mozilla {
+namespace net {
+
+class InterceptedHttpChannel final : public HttpBaseChannel
+                                   , public HttpAsyncAborter<InterceptedHttpChannel>
+                                   , public nsIInterceptedChannel
+                                   , public nsIAsyncVerifyRedirectCallback
+                                   , public nsIStreamListener
+{
+  friend class HttpAsyncAborter<InterceptedHttpChannel>;
+
+  UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
+  nsCOMPtr<nsIChannel> mRedirectChannel;
+  nsCOMPtr<nsIInputStream> mBodyReader;
+  nsCOMPtr<nsIOutputStream> mBodyWriter;
+  nsCOMPtr<nsISupports> mReleaseHandle;
+  nsCOMPtr<nsIProgressEventSink> mProgressSink;
+  RefPtr<nsInputStreamPump> mPump;
+  bool mSuspendRedirectChannel;
+
+  InterceptedHttpChannel();
+  ~InterceptedHttpChannel();
+
+public:
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForInterception();
+
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody);
+
+  void
+  AutoSuspendRedirectChannel();
+
+  NS_IMETHOD
+  Cancel(nsresult aStatus) override;
+
+  NS_IMETHOD
+  Suspend(void) override;
+
+  NS_IMETHOD
+  Resume(void) override;
+
+  NS_IMETHOD
+  GetSecurityInfo(nsISupports * *aSecurityInfo) override;
+
+  NS_IMETHOD
+  AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) override;
+
+  NS_IMETHOD
+  AsyncOpen2(nsIStreamListener *aListener) override;
+
+  NS_IMETHOD
+  LogBlockedCORSRequest(const nsAString & aMessage) override;
+
+  NS_IMETHOD
+  SetupFallbackChannel(const char * aFallbackKey) override;
+
+  NS_IMETHOD
+  ForceIntercepted(uint64_t aInterceptionID) override;
+
+  NS_IMETHOD
+  GetResponseSynthesized(bool *aResponseSynthesized) override;
+
+  NS_IMETHOD
+  SetPriority(int32_t aPriority) override;
+
+  NS_IMETHOD
+  SetClassFlags(uint32_t aClassFlags) override;
+
+  NS_IMETHOD
+  ClearClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  AddClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  ResumeAt(uint64_t startPos, const nsACString & entityID) override;
+
+  void
+  DoNotifyListenerCleanup() override;
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIINTERCEPTEDCHANNEL
+  NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
+  NS_DECL_NSIREQUESTOBSERVER
+  NS_DECL_NSISTREAMLISTENER
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_InterceptedHttpChannel_h
diff --git a/netwerk/protocol/http/moz.build b/netwerk/protocol/http/moz.build
--- a/netwerk/protocol/http/moz.build
+++ b/netwerk/protocol/http/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'HttpBackgroundChannelChild.cpp',
     'HttpBackgroundChannelParent.cpp',
     'HttpBaseChannel.cpp',
     'HttpChannelChild.cpp',
     'HttpChannelParent.cpp',
     'HttpChannelParentListener.cpp',
     'HttpInfo.cpp',
     'InterceptedChannel.cpp',
+    'InterceptedHttpChannel.cpp',
     'nsCORSListenerProxy.cpp',
     'nsHttp.cpp',
     'nsHttpActivityDistributor.cpp',
     'nsHttpAuthCache.cpp',
     'nsHttpAuthManager.cpp',
     'nsHttpBasicAuth.cpp',
     'nsHttpChannel.cpp',
     'nsHttpChunkedDecoder.cpp',
diff --git a/netwerk/protocol/http/nsCORSListenerProxy.cpp b/netwerk/protocol/http/nsCORSListenerProxy.cpp
--- a/netwerk/protocol/http/nsCORSListenerProxy.cpp
+++ b/netwerk/protocol/http/nsCORSListenerProxy.cpp
@@ -403,20 +403,22 @@ nsCORSListenerProxy::nsCORSListenerProxy
   : mOuterListener(aOuter),
     mRequestingPrincipal(aRequestingPrincipal),
     mOriginHeaderPrincipal(aRequestingPrincipal),
     mWithCredentials(aWithCredentials && !gDisableCORSPrivateData),
     mRequestApproved(false),
     mHasBeenCrossSite(false),
     mMutex("nsCORSListenerProxy")
 {
+  printf_stderr("### ### [%p] nsCORSListenerProxy::%s\n", this, __func__);
 }
 
 nsCORSListenerProxy::~nsCORSListenerProxy()
 {
+  printf_stderr("### ### [%p] nsCORSListenerProxy::%s\n", this, __func__);
 }
 
 nsresult
 nsCORSListenerProxy::Init(nsIChannel* aChannel, DataURIHandling aAllowDataURI)
 {
   aChannel->GetNotificationCallbacks(getter_AddRefs(mOuterNotificationCallbacks));
   aChannel->SetNotificationCallbacks(this);
 
@@ -436,16 +438,17 @@ nsCORSListenerProxy::Init(nsIChannel* aC
 #endif
   return rv;
 }
 
 NS_IMETHODIMP
 nsCORSListenerProxy::OnStartRequest(nsIRequest* aRequest,
                                     nsISupports* aContext)
 {
+  printf_stderr("### ### [%p] nsCORSListenerProxy::%s\n", this, __func__);
   MOZ_ASSERT(mInited, "nsCORSListenerProxy has not been initialized properly");
   nsresult rv = CheckRequestApproved(aRequest);
   mRequestApproved = NS_SUCCEEDED(rv);
   if (!mRequestApproved) {
     nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
     if (channel) {
       nsCOMPtr<nsIURI> uri;
       NS_GetFinalChannelURI(channel, getter_AddRefs(uri));
@@ -624,16 +627,17 @@ nsCORSListenerProxy::CheckRequestApprove
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCORSListenerProxy::OnStopRequest(nsIRequest* aRequest,
                                    nsISupports* aContext,
                                    nsresult aStatusCode)
 {
+  printf_stderr("### ### [%p] nsCORSListenerProxy::%s\n", this, __func__);
   MOZ_ASSERT(mInited, "nsCORSListenerProxy has not been initialized properly");
   nsCOMPtr<nsIStreamListener> listener;
   {
     MutexAutoLock lock(mMutex);
     listener = mOuterListener.forget();
   }
   nsresult rv = listener->OnStopRequest(aRequest, aContext, aStatusCode);
   mOuterNotificationCallbacks = nullptr;
@@ -643,16 +647,17 @@ nsCORSListenerProxy::OnStopRequest(nsIRe
 
 NS_IMETHODIMP
 nsCORSListenerProxy::OnDataAvailable(nsIRequest* aRequest,
                                      nsISupports* aContext,
                                      nsIInputStream* aInputStream,
                                      uint64_t aOffset,
                                      uint32_t aCount)
 {
+  printf_stderr("### ### [%p] nsCORSListenerProxy::%s\n", this, __func__);
   // NB: This can be called on any thread!  But we're guaranteed that it is
   // called between OnStartRequest and OnStopRequest, so we don't need to worry
   // about races.
 
   MOZ_ASSERT(mInited, "nsCORSListenerProxy has not been initialized properly");
   if (!mRequestApproved) {
     return NS_ERROR_DOM_BAD_URI;
   }
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -106,16 +106,17 @@
 #include "HSTSPrimerListener.h"
 #include "CacheStorageService.h"
 #include "HttpChannelParent.h"
 #include "nsIBufferedStreams.h"
 #include "nsIFileStreams.h"
 #include "nsIMIMEInputStream.h"
 #include "nsIMultiplexInputStream.h"
 #include "../../cache2/CacheFileUtils.h"
+#include "InterceptedHttpChannel.h"
 
 #ifdef MOZ_TASK_TRACER
 #include "GeckoTaskTracer.h"
 #endif
 
 namespace mozilla { namespace net {
 
 namespace {
@@ -542,16 +543,63 @@ nsHttpChannel::Connect()
     LOG(("nsHttpChannel::Connect [this=%p]\n", this));
 
     // Don't allow resuming when cache must be used
     if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
         LOG(("Resuming from cache is not supported yet"));
         return NS_ERROR_DOCUMENT_NOT_CACHED;
     }
 
+    nsresult rv = NS_OK;
+    if (mInterceptCache == MAYBE_INTERCEPT) {
+      mInterceptCache = INTERCEPTED;
+
+      nsCOMPtr<nsINetworkInterceptController> controller;
+      GetCallback(controller);
+
+      printf_stderr("### ### nsHttpChannel mListener is %p when creating InterceptedHttpChannel\n", mListener.get());
+      RefPtr<InterceptedHttpChannel> intercepted =
+        InterceptedHttpChannel::CreateForInterception();
+
+      rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                             mProxyResolveFlags, mProxyURI, mChannelId);
+
+      nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+        CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
+      intercepted->SetLoadInfo(redirectLoadInfo);
+
+      rv = SetupReplacementChannel(mURI, intercepted, true,
+                                   nsIChannelEventSink::REDIRECT_INTERNAL);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      // Inform consumers about this fake redirect
+      mRedirectChannel = intercepted;
+
+      PushRedirectAsyncFunc(
+          &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      rv = gHttpHandler->AsyncOnChannelRedirect(this, intercepted,
+                                                nsIChannelEventSink::REDIRECT_INTERNAL);
+
+      if (NS_SUCCEEDED(rv)) {
+        rv = WaitForRedirectCallback();
+      }
+
+      if (NS_FAILED(rv)) {
+        AutoRedirectVetoNotifier notifier(this);
+
+        /* Remove the async call to ContinueAsyncRedirectChannelToURI().
+         * It is called directly by our callers upon return (to clean up
+         * the failed redirect). */
+        PopRedirectAsyncFunc(
+            &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      }
+
+      return rv;
+    }
+
     bool isTrackingResource = mIsTrackingResource; // is atomic
     LOG(("nsHttpChannel %p tracking resource=%d, local blocklist=%d, cos=%u",
           this, isTrackingResource, mLocalBlocklist, mClassOfService));
 
     if (isTrackingResource || mLocalBlocklist) {
         AddClassFlags(nsIClassOfService::Tail);
     }
 
@@ -3939,16 +3987,17 @@ nsHttpChannel::OpenCacheEntry(bool isHtt
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsINetworkInterceptController> controller;
         GetCallback(controller);
 
         RefPtr<InterceptedChannelChrome> intercepted =
                 new InterceptedChannelChrome(this, controller, entry);
         intercepted->NotifyController();
+
     } else {
         if (mInterceptCache == INTERCEPTED) {
             cacheEntryOpenFlags |= nsICacheStorage::OPEN_INTERCEPTED;
             // Clear OPEN_TRUNCATE for the fake cache entry, since otherwise
             // cache storage will close the current entry which breaks the
             // response synthesis.
             cacheEntryOpenFlags &= ~nsICacheStorage::OPEN_TRUNCATE;
             DebugOnly<bool> exists;
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -202,27 +202,16 @@ public: /* internal necko use only */
 
     using InitLocalBlockListCallback = std::function<void(bool)>;
 
     void InternalSetUploadStream(nsIInputStream *uploadStream)
       { mUploadStream = uploadStream; }
     void SetUploadStreamHasHeaders(bool hasHeaders)
       { mUploadStreamHasHeaders = hasHeaders; }
 
-    MOZ_MUST_USE nsresult
-    SetReferrerWithPolicyInternal(nsIURI *referrer, uint32_t referrerPolicy) {
-        nsAutoCString spec;
-        nsresult rv = referrer->GetAsciiSpec(spec);
-        if (NS_FAILED(rv)) return rv;
-        mReferrer = referrer;
-        mReferrerPolicy = referrerPolicy;
-        rv = mRequestHead.SetHeader(nsHttp::Referer, spec);
-        return rv;
-    }
-
     MOZ_MUST_USE nsresult SetTopWindowURI(nsIURI* aTopWindowURI) {
         mTopWindowURI = aTopWindowURI;
         return NS_OK;
     }
 
     uint32_t GetRequestTime() const
     {
         return mRequestTime;
diff --git a/testing/web-platform/tests/service-workers/service-worker/fetch-request-redirect.https.html b/testing/web-platform/tests/service-workers/service-worker/fetch-request-redirect.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/fetch-request-redirect.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/fetch-request-redirect.https.html
@@ -152,31 +152,31 @@ promise_test(function(t) {
                             'Normal iframe loading should succeed.'),
             assert_resolves(
                 iframe_test(REDIRECT_TO_HTML_URL),
                 'Normal redirected iframe loading should succeed.'),
             assert_rejects(
                 iframe_test(SCOPE + '?url=' +
                             encodeURIComponent(REDIRECT_TO_HTML_URL) +
                             '&redirect-mode=follow',
-                            true /* timeout_enabled */),
+                            true ),
                 'Redirected iframe loading with Request.redirect=follow should'+
                 ' fail.'),
             assert_rejects(
                 iframe_test(SCOPE + '?url=' +
                             encodeURIComponent(REDIRECT_TO_HTML_URL) +
                             '&redirect-mode=error',
-                            true /* timeout_enabled */),
+                            true ),
                 'Redirected iframe loading with Request.redirect=error should '+
                 'fail.'),
             assert_resolves(
                 iframe_test(SCOPE + '?url=' +
                             encodeURIComponent(REDIRECT_TO_HTML_URL) +
                             '&redirect-mode=manual',
-                            true /* timeout_enabled */),
+                            true ),
                 'Redirected iframe loading with Request.redirect=manual should'+
                 ' succeed.'),
           ]);
         })
       .then(function() {
           frame.remove();
           service_worker_unregister_and_done(t, SCOPE);
         });
diff --git a/testing/web-platform/tests/service-workers/service-worker/navigation-redirect.https.html b/testing/web-platform/tests/service-workers/service-worker/navigation-redirect.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/navigation-redirect.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/navigation-redirect.https.html
@@ -139,34 +139,37 @@ function send_to_iframe(frame, message) 
 function get_intercepted_urls(worker) {
   return new Promise(function(resolve) {
       var channel = new MessageChannel();
       channel.port1.onmessage = function(msg) { resolve(msg.data.urls); };
       worker.postMessage({port: channel.port2}, [channel.port2]);
     });
 }
 
+/*
 // Normal redirect.
 promise_test(function(t) {
     return setup_environment(t).then(function() {
         return test_redirect(
             OUT_SCOPE + 'url=' + encodeURIComponent(SCOPE1),
             SCOPE1,
             [[SCOPE1], [], []]);
       });
   }, 'Normal redirect to same-origin scope.');
+  */
 promise_test(function(t) {
     return setup_environment(t).then(function() {
         return test_redirect(
             OUT_SCOPE + 'url=' + encodeURIComponent(OTHER_ORIGIN_SCOPE),
             OTHER_ORIGIN_SCOPE,
             [[], [], [OTHER_ORIGIN_SCOPE]]);
       });
   }, 'Normal redirect to other-origin scope.');
 
+/*
 // SW fallbacked redirect. SW doesn't handle the fetch request.
 promise_test(function(t) {
     return setup_environment(t).then(function() {
         return test_redirect(
             SCOPE1 + 'url=' + encodeURIComponent(OUT_SCOPE),
             OUT_SCOPE,
             [[SCOPE1 + 'url=' + encodeURIComponent(OUT_SCOPE)], [], []]);
       });
@@ -460,10 +463,11 @@ promise_test(function(t) {
         return test_redirect(
             SCOPE1 + 'sw=opaqueThroughCache&noLocationRedirect',
             SCOPE1 + 'sw=opaqueThroughCache&noLocationRedirect',
             [[SCOPE1 + 'sw=opaqueThroughCache&noLocationRedirect'],
              [],
              []]);
       });
   }, 'No location redirect response via Cache.');
+  */
 </script>
 </body>
diff --git a/uriloader/base/nsDocLoader.cpp b/uriloader/base/nsDocLoader.cpp
--- a/uriloader/base/nsDocLoader.cpp
+++ b/uriloader/base/nsDocLoader.cpp
@@ -1445,18 +1445,22 @@ NS_IMETHODIMP nsDocLoader::AsyncOnChanne
     aOldChannel->GetLoadFlags(&loadFlags);
     // If the document channel is being redirected, then indicate that the
     // document is being redirected in the notification...
     if (loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
     {
       stateFlags |= nsIWebProgressListener::STATE_IS_DOCUMENT;
 
 #if defined(DEBUG)
-      nsCOMPtr<nsIRequest> request(do_QueryInterface(aOldChannel));
-      NS_ASSERTION(request == mDocumentRequest, "Wrong Document Channel");
+      // We only set mDocumentRequest in OnStartRequest(), but its possible
+      // to get a redirect before that for service worker interception.
+      if (mDocumentRequest) {
+        nsCOMPtr<nsIRequest> request(do_QueryInterface(aOldChannel));
+        NS_ASSERTION(request == mDocumentRequest, "Wrong Document Channel");
+      }
 #endif /* DEBUG */
     }
 
     OnRedirectStateChange(aOldChannel, aNewChannel, aFlags, stateFlags);
     FireOnStateChange(this, aOldChannel, stateFlags, NS_OK);
   }
 
   cb->OnRedirectVerifyCallback(NS_OK);
