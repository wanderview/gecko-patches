# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d6e51041df0d4cf2beea2c5aeef0ca7c1689b0dd

diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -18,16 +18,17 @@
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/IPCStreamUtils.h"
 #include "mozilla/net/NeckoChild.h"
 #include "mozilla/net/HttpChannelChild.h"
 
 #include "AltDataOutputStreamChild.h"
 #include "CookieServiceChild.h"
 #include "HttpBackgroundChannelChild.h"
+#include "InterceptedHttpChannel.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsPrimitives.h"
 #include "nsChannelClassifier.h"
 #include "nsContentPolicyUtils.h"
 #include "nsGlobalWindow.h"
 #include "nsStringStream.h"
 #include "nsHttpChannel.h"
 #include "nsHttpHandler.h"
@@ -1557,16 +1558,17 @@ mozilla::ipc::IPCResult
 HttpChannelChild::RecvRedirect1Begin(const uint32_t& registrarId,
                                      const URIParams& newUri,
                                      const uint32_t& redirectFlags,
                                      const nsHttpResponseHead& responseHead,
                                      const nsCString& securityInfoSerialization,
                                      const uint64_t& channelId,
                                      const NetAddr& oldPeerAddr)
 {
+  printf_stderr("### ### HttpChannelChild::RecvRedirect1Begin()\n");
   // TODO: handle security info
   LOG(("HttpChannelChild::RecvRedirect1Begin [this=%p]\n", this));
   // We set peer address of child to the old peer,
   // Then it will be updated to new peer in OnStartRequest
   mPeerAddr = oldPeerAddr;
 
   mEventQ->RunOrEnqueue(new Redirect1Event(this, registrarId, newUri,
                                            redirectFlags, responseHead,
@@ -1594,26 +1596,39 @@ HttpChannelChild::SetupRedirect(nsIURI* 
                              uri,
                              redirectLoadInfo,
                              nullptr, // aLoadGroup
                              nullptr, // aCallbacks
                              nsIRequest::LOAD_NORMAL,
                              ioService);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  rv = SetupRedirectInternal(uri, responseHead, redirectFlags, newChannel);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  newChannel.forget(outChannel);
+  return NS_OK;
+}
+
+nsresult
+HttpChannelChild::SetupRedirectInternal(nsIURI* uri,
+                                        const nsHttpResponseHead* responseHead,
+                                        const uint32_t& redirectFlags,
+                                        nsIChannel* aChannel) {
+
   // We won't get OnStartRequest, set cookies here.
   mResponseHead = new nsHttpResponseHead(*responseHead);
 
   bool rewriteToGET = HttpBaseChannel::ShouldRewriteRedirectToGET(mResponseHead->Status(),
                                                                   mRequestHead.ParsedMethod());
 
-  rv = SetupReplacementChannel(uri, newChannel, !rewriteToGET, redirectFlags);
+  nsresult rv = SetupReplacementChannel(uri, aChannel, !rewriteToGET, redirectFlags);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCOMPtr<nsIHttpChannelChild> httpChannelChild = do_QueryInterface(newChannel);
+  nsCOMPtr<nsIHttpChannelChild> httpChannelChild = do_QueryInterface(aChannel);
   if (httpChannelChild) {
     bool shouldUpgrade = false;
     auto channelChild = static_cast<HttpChannelChild*>(httpChannelChild.get());
     if (mShouldInterceptSubsequentRedirect) {
       // In the case where there was a synthesized response that caused a redirection,
       // we must force the new channel to intercept the request in the parent before a
       // network transaction is initiated.
       rv = httpChannelChild->ForceIntercepted(false, false);
@@ -1626,18 +1641,17 @@ HttpChannelChild::SetupRedirect(nsIURI* 
       // case, force the new channel to intercept the request in the parent
       // similar to the case above, but also remember that ShouldInterceptURI()
       // returned true to avoid calling it a second time.
       rv = httpChannelChild->ForceIntercepted(true, shouldUpgrade);
     }
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 
-  mRedirectChannelChild = do_QueryInterface(newChannel);
-  newChannel.forget(outChannel);
+  mRedirectChannelChild = do_QueryInterface(aChannel);
 
   return NS_OK;
 }
 
 void
 HttpChannelChild::Redirect1Begin(const uint32_t& registrarId,
                                  const URIParams& newOriginalURI,
                                  const uint32_t& redirectFlags,
@@ -1852,16 +1866,17 @@ HttpChannelChild::ProcessDivertMessages(
 // Returns true if has actually completed the redirect and cleaned up the
 // channel, or false the interception logic kicked in and we need to asyncly
 // call FinishInterceptedRedirect and CleanupRedirectingChannel.
 // The argument is an optional OverrideRunnable that we pass to the redirected
 // channel.
 bool
 HttpChannelChild::Redirect3Complete(OverrideRunnable* aRunnable)
 {
+  printf_stderr("### ### HttpChannelChild::Redirect3Complete()\n");
   LOG(("HttpChannelChild::Redirect3Complete [this=%p]\n", this));
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIHttpChannelChild> chan = do_QueryInterface(mRedirectChannelChild);
   RefPtr<HttpChannelChild> httpChannelChild = static_cast<HttpChannelChild*>(chan.get());
   // Chrome channel has been AsyncOpen'd.  Reflect this in child.
   if (mRedirectChannelChild) {
     if (httpChannelChild) {
@@ -2061,35 +2076,37 @@ HttpChannelChild::CompleteRedirectSetup(
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIAsyncVerifyRedirectCallback
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::OnRedirectVerifyCallback(nsresult result)
 {
+  printf_stderr("### ### OnRedirectVerifyCallback()\n");
   LOG(("HttpChannelChild::OnRedirectVerifyCallback [this=%p]\n", this));
   nsresult rv;
   OptionalURIParams redirectURI;
 
   uint32_t referrerPolicy = REFERRER_POLICY_UNSET;
   OptionalURIParams referrerURI;
   SerializeURI(nullptr, referrerURI);
 
   nsCOMPtr<nsIHttpChannel> newHttpChannel =
       do_QueryInterface(mRedirectChannelChild);
 
-  if (NS_SUCCEEDED(result) && !mRedirectChannelChild) {
+  if (NS_SUCCEEDED(result) && !mRedirectChannelChild && !mSimpleRedirectChannel) {
     // mRedirectChannelChild doesn't exist means we're redirecting to a protocol
     // that doesn't implement nsIChildChannel. The redirect result should be set
     // as failed by veto listeners and shouldn't enter this condition. As the
     // last resort, we synthesize the error result as NS_ERROR_DOM_BAD_URI here
     // to let nsHttpChannel::ContinueProcessResponse2 know it's redirecting to
     // another protocol and throw an error.
     LOG(("  redirecting to a protocol that doesn't implement nsIChildChannel"));
+    printf_stderr("### ### no an nsIChildChannel!\n");
     result = NS_ERROR_DOM_BAD_URI;
   }
 
   bool forceHSTSPriming = false;
   bool mixedContentWouldBlock = false;
   if (newHttpChannel) {
     // Must not be called until after redirect observers called.
     newHttpChannel->SetOriginalURI(mOriginalURI);
@@ -2105,16 +2122,38 @@ HttpChannelChild::OnRedirectVerifyCallba
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     nsCOMPtr<nsIURI> newChannelReferrerURI;
     rv = newHttpChannel->GetReferrer(getter_AddRefs(newChannelReferrerURI));
     MOZ_ASSERT(NS_SUCCEEDED(rv));
 
     SerializeURI(newChannelReferrerURI, referrerURI);
   }
 
+  if (mSimpleRedirectChannel) {
+    // Make sure to do this after we received redirect veto answer,
+    // i.e. after all sinks had been notified
+    mSimpleRedirectChannel->SetOriginalURI(mOriginalURI);
+
+    // open new channel
+    if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
+        MOZ_ASSERT(!mListenerContext, "mListenerContext should be null!");
+        rv = mSimpleRedirectChannel->AsyncOpen2(mListener);
+    }
+    else {
+        rv = mSimpleRedirectChannel->AsyncOpen(mListener, mListenerContext);
+    }
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mStatus = NS_BINDING_REDIRECTED;
+
+    ReleaseListeners();
+
+    return NS_OK;
+  }
+
   if (mRedirectingForSubsequentSynthesizedResponse) {
     nsCOMPtr<nsIHttpChannelChild> httpChannelChild = do_QueryInterface(mRedirectChannelChild);
     RefPtr<HttpChannelChild> redirectedChannel =
         static_cast<HttpChannelChild*>(httpChannelChild.get());
     // redirectChannel will be NULL if mRedirectChannelChild isn't a
     // nsIHttpChannelChild (it could be a DataChannelChild).
 
     RefPtr<InterceptStreamListener> streamListener =
@@ -2373,26 +2412,53 @@ HttpChannelChild::AsyncOpen(nsIStreamLis
 
   MOZ_ASSERT_IF(mPostRedirectChannelShouldUpgrade,
                 mPostRedirectChannelShouldIntercept);
   bool shouldUpgrade = mPostRedirectChannelShouldUpgrade;
   if (mPostRedirectChannelShouldIntercept ||
       ShouldInterceptURI(mURI, shouldUpgrade)) {
     mResponseCouldBeSynthesized = true;
 
-    nsCOMPtr<nsINetworkInterceptController> controller;
-    GetCallback(controller);
-
+    RefPtr<InterceptedHttpChannel> intercepted = new InterceptedHttpChannel();
+    rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                           mProxyResolveFlags, mProxyURI, mChannelId);
+
+    nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+      CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
+    intercepted->SetLoadInfo(redirectLoadInfo);
+
+    nsHttpResponseHead head;
+    rv = SetupRedirectInternal(mURI, &head,
+                               nsIChannelEventSink::REDIRECT_INTERNAL,
+                               intercepted);
+    if (NS_SUCCEEDED(rv)) {
+      nsCOMPtr<nsIEventTarget> target = GetNeckoTarget();
+      MOZ_ASSERT(target);
+
+      mSimpleRedirectChannel = intercepted;
+
+      rv = gHttpHandler->AsyncOnChannelRedirect(this,
+                                                intercepted,
+                                                nsIChannelEventSink::REDIRECT_INTERNAL,
+                                                target);
+      if (NS_FAILED(rv)) {
+        OnRedirectVerifyCallback(rv);
+      }
+    }
+
+    /*
     mInterceptListener = new InterceptStreamListener(this, mListenerContext);
 
     RefPtr<InterceptedChannelContent> intercepted =
         new InterceptedChannelContent(this, controller,
                                       mInterceptListener, shouldUpgrade);
     intercepted->NotifyController();
-    return NS_OK;
+    */
+
+    return rv;
   }
 
   return ContinueAsyncOpen();
 }
 
 NS_IMETHODIMP
 HttpChannelChild::AsyncOpen2(nsIStreamListener *aListener)
 {
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -182,16 +182,17 @@ protected:
   virtual mozilla::ipc::IPCResult RecvLogBlockedCORSRequest(const nsString& aMessage) override;
   NS_IMETHOD LogBlockedCORSRequest(const nsAString & aMessage) override;
 
 private:
   // this section is for main-thread-only object
   // all the references need to be proxy released on main thread.
   nsCOMPtr<nsISupports> mCacheKey;
   nsCOMPtr<nsIChildChannel> mRedirectChannelChild;
+  nsCOMPtr<nsIChannel> mSimpleRedirectChannel;
   RefPtr<InterceptStreamListener> mInterceptListener;
   // Needed to call AsyncOpen in FinishInterceptedRedirect
   nsCOMPtr<nsIStreamListener> mInterceptedRedirectListener;
   nsCOMPtr<nsISupports> mInterceptedRedirectContext;
 
   // Proxy release all members above on main thread.
   void ReleaseMainThreadOnlyReferences();
 
@@ -412,16 +413,21 @@ private:
 
   // Create a a new channel to be used in a redirection, based on the provided
   // response headers.
   MOZ_MUST_USE nsresult SetupRedirect(nsIURI* uri,
                                       const nsHttpResponseHead* responseHead,
                                       const uint32_t& redirectFlags,
                                       nsIChannel** outChannel);
 
+  MOZ_MUST_USE nsresult SetupRedirectInternal(nsIURI* uri,
+                                              const nsHttpResponseHead* responseHead,
+                                              const uint32_t& redirectFlags,
+                                              nsIChannel* aChannel);
+
   // Perform a redirection without communicating with the parent process at all.
   void BeginNonIPCRedirect(nsIURI* responseURI,
                            const nsHttpResponseHead* responseHead);
 
   // Override the default security info pointer during a non-IPC redirection.
   void OverrideSecurityInfoForNonIPCRedirect(nsISupports* securityInfo);
 
   // Collect telemetry for the successful rate of OMT.
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -0,0 +1,1399 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ *  License, v. 2.0. If a copy of the MPL was not distributed with this
+ *  file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "InterceptedHttpChannel.h"
+#include "nsContentSecurityManager.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
+                            HttpBaseChannel,
+                            nsIInterceptedChannel,
+                            nsIAsyncVerifyRedirectCallback)
+
+InterceptedHttpChannel::~InterceptedHttpChannel()
+{
+}
+
+InterceptedHttpChannel::InterceptedHttpChannel()
+  /*
+  : mURI(aURI)
+  , mTopLevelContentWindowID(0)
+  , mTopLevelOuterContentWindowID(0)
+  , mRequestContextID(0)
+  , mRedirectionLimit(0)
+  , mThirdPartyFlags(0)
+  , mTlsFlags(0)
+  , mCorsMode(0)
+  , mRedirectMode(0)
+  , mFetchCacheMode(0)
+  , mReferrerPolicy(NS_GetDefaultReferrerPolicy())
+  , mLoadFlags(0)
+  , mStatus(NS_OK)
+  , mAllowSTS(false)
+  , mAllowSpdy(false)
+  , mAllowAltSvc(false)
+  , mBeConservative(false)
+  */
+{
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetName(nsACString& aName)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::IsPending(bool* _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetStatus(nsresult* aStatus)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aStatus = mStatus;
+  return NS_OK;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Cancel(nsresult aStatus)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Suspend(void)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Resume(void)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLoadGroup(nsILoadGroup** aLoadGroup)
+{
+  nsCOMPtr<nsILoadGroup> ref(mLoadGroup);
+  ref.forget(aLoadGroup);
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLoadGroup(nsILoadGroup* aLoadGroup)
+{
+  mLoadGroup = aLoadGroup;
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLoadFlags(nsLoadFlags* aLoadFlags)
+{
+  *aLoadFlags = mLoadFlags;
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
+{
+  mLoadFlags = aLoadFlags;
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetOriginalURI(nsIURI** aOriginalURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetOriginalURI(nsIURI* aOriginalURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetURI(nsIURI** aURI)
+{
+  nsCOMPtr<nsIURI> ref(mURI);
+  ref.forget(aURI);
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetOwner(nsISupports** aOwner)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetOwner(nsISupports* aOwner)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor** aNotificationCallbacks)
+{
+  nsCOMPtr<nsIInterfaceRequestor> ref(mCallbacks);
+  ref.forget(aNotificationCallbacks);
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetNotificationCallbacks(nsIInterfaceRequestor* aNotificationCallbacks)
+{
+  mCallbacks = aNotificationCallbacks;
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecurityInfo(nsISupports** aSecurityInfo)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentType(nsACString& aContentType)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetContentType(const nsACString& aContentType)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentCharset(nsACString& aContentCharset)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetContentCharset(const nsACString& aContentCharset)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentLength(int64_t* aContentLength)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetContentLength(int64_t aContentLength)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Open(nsIInputStream** _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::Open2(nsIInputStream** _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen(nsIStreamListener* aListener, nsISupports* aContext)
+{
+  printf_stderr("### ### %s\n", __func__);
+
+  nsCOMPtr<nsINetworkInterceptController> controller;
+  GetCallback(controller);
+
+  if (NS_WARN_IF(!controller)) {
+    ReleaseListeners();
+    return NS_ERROR_FAILURE;
+  }
+
+  nsresult rv = controller->ChannelIntercepted(this);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AsyncOpen2(nsIStreamListener* aListener)
+{
+  printf_stderr("### ### %s\n", __func__);
+  nsCOMPtr<nsIStreamListener> listener(aListener);
+  nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ReleaseListeners();
+    return rv;
+  }
+  return AsyncOpen(listener, nullptr);
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentDisposition(uint32_t* aContentDisposition)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetContentDisposition(uint32_t aContentDisposition)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentDispositionFilename(nsAString& aContentDispositionFilename)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetContentDispositionFilename(const nsAString& aContentDispositionFilename)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetContentDispositionHeader(nsACString& aContentDispositionHeader)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLoadInfo(nsILoadInfo** aLoadInfo)
+{
+  nsCOMPtr<nsILoadInfo> ref(mLoadInfo);
+  ref.forget(aLoadInfo);
+  printf_stderr("### ### %s\n", __func__);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLoadInfo(nsILoadInfo* aLoadInfo)
+{
+  mLoadInfo = aLoadInfo;
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetIsDocument(bool* aIsDocument)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRequestMethod(nsACString& aRequestMethod)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mRequestHead.Method(aRequestMethod);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetRequestMethod(const nsACString& aRequestMethod)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mRequestHead.SetMethod(aRequestMethod);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetReferrer(nsIURI** aReferrer)
+{
+  printf_stderr("### ### %s\n", __func__);
+  nsCOMPtr<nsIURI> ref(mReferrer);
+  ref.forget(aReferrer);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetReferrer(nsIURI* aReferrer)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mReferrer = aReferrer;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetReferrerPolicy(uint32_t* aReferrerPolicy)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aReferrerPolicy = mReferrerPolicy;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetReferrerWithPolicy(nsIURI* referrer, uint32_t referrerPolicy)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetProtocolVersion(nsACString& aProtocolVersion)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetTransferSize(uint64_t* aTransferSize)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetDecodedBodySize(uint64_t* aDecodedBodySize)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetEncodedBodySize(uint64_t* aEncodedBodySize)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRequestHeader(const nsACString& aHeader,
+                                         nsACString& aValue)
+{
+  printf_stderr("### ### %s\n", __func__);
+  nsHttpAtom atom = nsHttp::ResolveAtom(aHeader);
+  if (!atom) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  return mRequestHead.GetHeader(atom, aValue);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetRequestHeader(const nsACString& aHeader,
+                                         const nsACString& aValue,
+                                         bool aMerge)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return mRequestHead.SetHeader(aHeader, aValue, aMerge);
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetEmptyRequestHeader(const nsACString& aHeader)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::VisitRequestHeaders(nsIHttpHeaderVisitor* aVisitor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::VisitNonDefaultRequestHeaders(nsIHttpHeaderVisitor* aVisitor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetAllowPipelining(bool* aAllowPipelining)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetAllowPipelining(bool aAllowPipelining)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetAllowSTS(bool* aAllowSTS)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aAllowSTS = mAllowSTS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetAllowSTS(bool aAllowSTS)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mAllowSTS = aAllowSTS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRedirectionLimit(uint32_t* aRedirectionLimit)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aRedirectionLimit = mRedirectionLimit;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetRedirectionLimit(uint32_t aRedirectionLimit)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mRedirectionLimit = aRedirectionLimit;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseStatus(uint32_t* aResponseStatus)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseStatusText(nsACString& aResponseStatusText)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRequestSucceeded(bool* aRequestSucceeded)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetIsMainDocumentChannel(bool* aIsMainDocumentChannel)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetIsMainDocumentChannel(bool aIsMainDocumentChannel)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseHeader(const nsACString& header, nsACString& _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetResponseHeader(const nsACString& header, const nsACString& value, bool merge)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::VisitResponseHeaders(nsIHttpHeaderVisitor* aVisitor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetOriginalResponseHeader(const nsACString& aHeader, nsIHttpHeaderVisitor* aVisitor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::VisitOriginalResponseHeaders(nsIHttpHeaderVisitor* aVisitor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::IsNoStoreResponse(bool* _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::IsNoCacheResponse(bool* _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::IsPrivateResponse(bool* _retval)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::RedirectTo(nsIURI* aTargetURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRequestContextID(uint64_t* aRequestContextID)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aRequestContextID = mRequestContextID;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetRequestContextID(uint64_t aRequestContextID)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mRequestContextID = aRequestContextID;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetChannelId(uint64_t* aChannelId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelId(uint64_t aChannelId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetTopLevelContentWindowId(uint64_t* aTopLevelContentWindowId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aTopLevelContentWindowId = mTopLevelContentWindowID;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetTopLevelContentWindowId(uint64_t aTopLevelContentWindowId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mTopLevelContentWindowID = aTopLevelContentWindowId;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetIsTrackingResource(bool* aIsTrackingResource)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetTopLevelOuterContentWindowId(uint64_t* aTopLevelOuterContentWindowId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aTopLevelOuterContentWindowId = mTopLevelOuterContentWindowID;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetTopLevelOuterContentWindowId(uint64_t aTopLevelOuterContentWindowId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mTopLevelOuterContentWindowID = aTopLevelOuterContentWindowId;
+  return NS_OK;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::LogBlockedCORSRequest(const nsAString& aMessage)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetDocumentURI(nsIURI** aDocumentURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  nsCOMPtr<nsIURI> ref(mDocumentURI);
+  ref.forget(aDocumentURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDocumentURI(nsIURI* aDocumentURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mDocumentURI = aDocumentURI;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRequestVersion(uint32_t* major, uint32_t* minor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseVersion(uint32_t* major, uint32_t* minor)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::TakeAllSecurityMessages(nsCOMArray<nsISecurityConsoleMessage>& aMessages)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetCookie(const char*  aCookieHeader)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetupFallbackChannel(const char*  aFallbackKey)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetThirdPartyFlags(uint32_t* aThirdPartyFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aThirdPartyFlags = mThirdPartyFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetThirdPartyFlags(uint32_t aThirdPartyFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mThirdPartyFlags = aThirdPartyFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetForceAllowThirdPartyCookie(bool* aForceAllowThirdPartyCookie)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetForceAllowThirdPartyCookie(bool aForceAllowThirdPartyCookie)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetCanceled(bool* aCanceled)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetChannelIsForDownload(bool* aChannelIsForDownload)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelIsForDownload(bool aChannelIsForDownload)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLocalAddress(nsACString& aLocalAddress)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLocalPort(int32_t* aLocalPort)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRemoteAddress(nsACString& aRemoteAddress)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRemotePort(int32_t* aRemotePort)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetCacheKeysRedirectChain(nsTArray<nsCString>* cacheKeys)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::HTTPUpgrade(const nsACString& aProtocolName, nsIHttpUpgradeListener* aListener)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetAllowSpdy(bool* aAllowSpdy)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aAllowSpdy = mAllowSpdy;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetAllowSpdy(bool aAllowSpdy)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mAllowSpdy = aAllowSpdy;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseTimeoutEnabled(bool* aResponseTimeoutEnabled)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetResponseTimeoutEnabled(bool aResponseTimeoutEnabled)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetInitialRwin(uint32_t* aInitialRwin)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetInitialRwin(uint32_t aInitialRwin)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetApiRedirectToURI(nsIURI** aApiRedirectToURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetAllowAltSvc(bool* aAllowAltSvc)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aAllowAltSvc = mAllowAltSvc;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetAllowAltSvc(bool aAllowAltSvc)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mAllowAltSvc = aAllowAltSvc;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetBeConservative(bool* aBeConservative)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aBeConservative = mBeConservative;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetBeConservative(bool aBeConservative)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mBeConservative = aBeConservative;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetTlsFlags(uint32_t* aTlsFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aTlsFlags = mTlsFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetTlsFlags(uint32_t aTlsFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mTlsFlags = aTlsFlags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLastModifiedTime(PRTime* aLastModifiedTime)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ForceIntercepted(uint64_t aInterceptionID)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseSynthesized(bool* aResponseSynthesized)
+{
+  printf_stderr("### ### %s\n", __func__);
+  // TODO
+  *aResponseSynthesized = false;
+  return NS_OK;
+}
+
+/*
+NS_IMETHODIMP
+InterceptedHttpChannel::GetCorsIncludeCredentials(bool* aCorsIncludeCredentials)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetCorsIncludeCredentials(bool aCorsIncludeCredentials)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetCorsMode(uint32_t* aCorsMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aCorsMode = mCorsMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetCorsMode(uint32_t aCorsMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mCorsMode = aCorsMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetRedirectMode(uint32_t* aRedirectMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aRedirectMode = mRedirectMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetRedirectMode(uint32_t aRedirectMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mRedirectMode = aRedirectMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetFetchCacheMode(uint32_t* aFetchCacheMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  *aFetchCacheMode = mFetchCacheMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFetchCacheMode(uint32_t aFetchCacheMode)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mFetchCacheMode = aFetchCacheMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetTopWindowURI(nsIURI** aTopWindowURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetTopWindowURIIfUnknown(nsIURI* topWindowURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetNetworkInterfaceId(nsACString& aNetworkInterfaceId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetNetworkInterfaceId(const nsACString& aNetworkInterfaceId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetProxyURI(nsIURI** aProxyURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+void
+InterceptedHttpChannel::SetCorsPreflightParameters(const nsTArray<nsCString>& unsafeHeaders)
+{
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetBlockAuthPrompt(bool* aBlockAuthPrompt)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetBlockAuthPrompt(bool aBlockAuthPrompt)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetIntegrityMetadata(nsAString& aIntegrityMetadata)
+{
+  printf_stderr("### ### %s\n", __func__);
+  aIntegrityMetadata = mIntegrityMetadata;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetIntegrityMetadata(const nsAString& aIntegrityMetadata)
+{
+  printf_stderr("### ### %s\n", __func__);
+  mIntegrityMetadata = aIntegrityMetadata;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetConnectionInfoHashKey(nsACString& aConnectionInfoHashKey)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetLastRedirectFlags(uint32_t* aLastRedirectFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLastRedirectFlags(uint32_t aLastRedirectFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ConnectParent(uint32_t aRegistrarId)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::CompleteRedirectSetup(nsIStreamListener* aListener,
+                                              nsISupports* aContext)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+*/
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetPriority(int32_t aPriority)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetClassFlags(uint32_t aClassFlags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ClearClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::AddClassFlags(uint32_t flags)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResumeAt(uint64_t startPos, const nsACString & entityID)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void
+InterceptedHttpChannel::DoNotifyListenerCleanup()
+{
+  printf_stderr("### ### %s\n", __func__);
+}
+
+
+NS_IMETHODIMP
+InterceptedHttpChannel::ResetInterception(void)
+{
+  printf_stderr("### ### %s\n", __func__);
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIIOService> ioService;
+  rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
+
+  nsCOMPtr<nsIChannel> newChannel;
+  nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+    CloneLoadInfoForRedirect(mURI, flags);
+  rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                             mURI,
+                             redirectLoadInfo,
+                             nullptr, // aLoadGroup
+                             nullptr, // aCallbacks
+                             nsIRequest::LOAD_NORMAL,
+                             ioService);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = SetupReplacementChannel(mURI, newChannel, true, flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mRedirectChannel = newChannel.forget();
+
+  rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
+
+  if (NS_FAILED(rv)) {
+    OnRedirectVerifyCallback(rv);
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeStatus(uint16_t status, const nsACString& reason)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SynthesizeHeader(const nsACString& name, const nsACString& value)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& finalURLSpec)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::CancelInterception(nsresult status)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetResponseBody(nsIOutputStream** aResponseBody)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetChannel(nsIChannel** aChannel)
+{
+  printf_stderr("### ### %s\n", __func__);
+  nsCOMPtr<nsIChannel> ref(this);
+  ref.forget(aChannel);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetSecureUpgradedChannelURI(nsIURI** aSecureUpgradedChannelURI)
+{
+  printf_stderr("### ### %s\n", __func__);
+  // TODO: Is this correct for e10s?
+  nsCOMPtr<nsIURI> ref(mURI);
+  ref.forget(aSecureUpgradedChannelURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelInfo(mozilla::dom::ChannelInfo* channelInfo)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetInternalContentPolicyType(nsContentPolicyType* aInternalContentPolicyType)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector** aConsoleReportCollector)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetDispatchFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetHandleFetchEventEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishResponseStart(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetFinishSynthesizedResponseEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetChannelResetEnd(mozilla::TimeStamp aTimeStamp)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SaveTimeStamps(void)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::SetReleaseHandle(nsISupports* aHandle)
+{
+  printf_stderr("### ### %s\n", __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+InterceptedHttpChannel::OnRedirectVerifyCallback(nsresult rv)
+{
+  printf_stderr("### ### %s\n", __func__);
+
+  if (NS_SUCCEEDED(rv)) {
+    // TODO: move this into a separate method like OpenRedirectChannel()?
+
+    // Make sure to do this after we received redirect veto answer,
+    // i.e. after all sinks had been notified
+    mRedirectChannel->SetOriginalURI(mOriginalURI);
+
+    // open new channel
+    if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
+      printf_stderr("### ### calling AsyncOpen2()\n");
+      MOZ_ASSERT(!mListenerContext, "mListenerContext should be null!");
+      rv = mRedirectChannel->AsyncOpen2(mListener);
+    }
+    else {
+      printf_stderr("### ### calling AsyncOpen()\n");
+      rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
+    }
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mStatus = NS_BINDING_REDIRECTED;
+
+    ReleaseListeners();
+  }
+
+  if (NS_FAILED(rv)) {
+    // Cancel the channel here, the update to https had been vetoed
+    // but from the security reasons we have to discard the whole channel
+    // load.
+    Cancel(rv);
+  }
+
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
+
+  return NS_OK;
+}
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_InterceptedHttpChannel_h
+#define mozilla_net_InterceptedHttpChannel_h
+
+#include "HttpBaseChannel.h"
+#include "nsINetworkInterceptController.h"
+
+namespace mozilla {
+namespace net {
+
+class InterceptedHttpChannel final : public HttpBaseChannel
+                                   , public nsIInterceptedChannel
+                                   , public nsIAsyncVerifyRedirectCallback
+{
+  nsCOMPtr<nsIChannel> mRedirectChannel;
+/*
+  nsHttpRequestHead mRequestHead;
+  nsCOMPtr<nsIURI> mURI;
+  nsCOMPtr<nsIURI> mDocumentURI;
+  nsCOMPtr<nsIURI> mReferrer;
+  nsCOMPtr<nsILoadInfo> mLoadInfo;
+  nsCOMPtr<nsILoadGroup> mLoadGroup;
+  nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
+  nsString mIntegrityMetadata;
+  uint64_t mTopLevelContentWindowID;
+  uint64_t mTopLevelOuterContentWindowID;
+  uint64_t mRequestContextID;
+  uint32_t mRedirectionLimit;
+  uint32_t mThirdPartyFlags;
+  uint32_t mTlsFlags;
+  uint32_t mCorsMode;
+  uint32_t mRedirectMode;
+  uint32_t mFetchCacheMode;
+  uint32_t mReferrerPolicy;
+  nsLoadFlags mLoadFlags;
+  nsresult mStatus;
+  bool mAllowSTS;
+  bool mAllowSpdy;
+  bool mAllowAltSvc;
+  bool mBeConservative;
+*/
+
+  ~InterceptedHttpChannel();
+
+public:
+  InterceptedHttpChannel();
+
+  NS_IMETHOD
+  Cancel(nsresult aStatus) override;
+
+  NS_IMETHOD
+  Suspend(void) override;
+
+  NS_IMETHOD
+  Resume(void) override;
+
+  NS_IMETHOD
+  GetSecurityInfo(nsISupports * *aSecurityInfo) override;
+
+  NS_IMETHOD
+  AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) override;
+
+  NS_IMETHOD
+  AsyncOpen2(nsIStreamListener *aListener) override;
+
+  NS_IMETHOD
+  LogBlockedCORSRequest(const nsAString & aMessage) override;
+
+  NS_IMETHOD
+  SetupFallbackChannel(const char * aFallbackKey) override;
+
+  NS_IMETHOD
+  ForceIntercepted(uint64_t aInterceptionID) override;
+
+  NS_IMETHOD
+  GetResponseSynthesized(bool *aResponseSynthesized) override;
+
+  NS_IMETHOD
+  SetPriority(int32_t aPriority) override;
+
+  NS_IMETHOD
+  SetClassFlags(uint32_t aClassFlags) override;
+
+  NS_IMETHOD
+  ClearClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  AddClassFlags(uint32_t flags) override;
+
+  NS_IMETHOD
+  ResumeAt(uint64_t startPos, const nsACString & entityID) override;
+
+  void
+  DoNotifyListenerCleanup() override;
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIINTERCEPTEDCHANNEL
+  NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_InterceptedHttpChannel_h
diff --git a/netwerk/protocol/http/SyntheticHttpChannel.cpp b/netwerk/protocol/http/SyntheticHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/SyntheticHttpChannel.cpp
@@ -0,0 +1,155 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SyntheticHttpChannel.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMETHODIMP SyntheticHttpChannel::GetName(nsACString & aName) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsPending(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetStatus(nsresult *aStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Cancel(nsresult aStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Suspend(void) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Resume(void) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadGroup(nsILoadGroup * *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadGroup(nsILoadGroup *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadFlags(nsLoadFlags aLoadFlags) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetOriginalURI(nsIURI * *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetOriginalURI(nsIURI *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetURI(nsIURI * *aURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetOwner(nsISupports * *aOwner) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetOwner(nsISupports *aOwner) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor * *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetNotificationCallbacks(nsIInterfaceRequestor *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetSecurityInfo(nsISupports * *aSecurityInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentType(nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentType(const nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentCharset(nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentCharset(const nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentLength(int64_t *aContentLength) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentLength(int64_t aContentLength) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Open(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Open2(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::AsyncOpen2(nsIStreamListener *aListener) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDisposition(uint32_t *aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentDisposition(uint32_t aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDispositionFilename(nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentDispositionFilename(const nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDispositionHeader(nsACString & aContentDispositionHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadInfo(nsILoadInfo * *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadInfo(nsILoadInfo *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsDocument(bool *aIsDocument) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestMethod(nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestMethod(const nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetReferrer(nsIURI * *aReferrer) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetReferrer(nsIURI *aReferrer) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetReferrerPolicy(uint32_t *aReferrerPolicy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetReferrerWithPolicy(nsIURI *referrer, uint32_t referrerPolicy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetProtocolVersion(nsACString & aProtocolVersion) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTransferSize(uint64_t *aTransferSize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetDecodedBodySize(uint64_t *aDecodedBodySize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetEncodedBodySize(uint64_t *aEncodedBodySize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestHeader(const nsACString & aHeader, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestHeader(const nsACString & aHeader, const nsACString & aValue, bool aMerge) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetEmptyRequestHeader(const nsACString & aHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitNonDefaultRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowPipelining(bool *aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowPipelining(bool aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowSTS(bool *aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowSTS(bool aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRedirectionLimit(uint32_t *aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRedirectionLimit(uint32_t aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseStatus(uint32_t *aResponseStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseStatusText(nsACString & aResponseStatusText) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestSucceeded(bool *aRequestSucceeded) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsMainDocumentChannel(bool *aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetIsMainDocumentChannel(bool aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseHeader(const nsACString & header, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetResponseHeader(const nsACString & header, const nsACString & value, bool merge) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetOriginalResponseHeader(const nsACString & aHeader, nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitOriginalResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsNoStoreResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsNoCacheResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsPrivateResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::RedirectTo(nsIURI *aTargetURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestContextID(uint64_t *aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestContextID(uint64_t aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetChannelId(uint64_t *aChannelId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetChannelId(uint64_t aChannelId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopLevelContentWindowId(uint64_t *aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopLevelContentWindowId(uint64_t aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsTrackingResource(bool *aIsTrackingResource) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopLevelOuterContentWindowId(uint64_t *aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopLevelOuterContentWindowId(uint64_t aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::LogBlockedCORSRequest(const nsAString & aMessage) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetDocumentURI(nsIURI * *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetDocumentURI(nsIURI *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::TakeAllSecurityMessages(nsCOMArray<nsISecurityConsoleMessage> & aMessages) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCookie(const char * aCookieHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetupFallbackChannel(const char * aFallbackKey) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetThirdPartyFlags(uint32_t *aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetThirdPartyFlags(uint32_t aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetForceAllowThirdPartyCookie(bool *aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetForceAllowThirdPartyCookie(bool aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCanceled(bool *aCanceled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetChannelIsForDownload(bool *aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetChannelIsForDownload(bool aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLocalAddress(nsACString & aLocalAddress) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLocalPort(int32_t *aLocalPort) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRemoteAddress(nsACString & aRemoteAddress) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRemotePort(int32_t *aRemotePort) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCacheKeysRedirectChain(nsTArray<nsCString> *cacheKeys) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::HTTPUpgrade(const nsACString & aProtocolName, nsIHttpUpgradeListener *aListener) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowSpdy(bool *aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowSpdy(bool aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseTimeoutEnabled(bool *aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetResponseTimeoutEnabled(bool aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetInitialRwin(uint32_t *aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetInitialRwin(uint32_t aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetApiRedirectToURI(nsIURI * *aApiRedirectToURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowAltSvc(bool *aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowAltSvc(bool aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetBeConservative(bool *aBeConservative) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetBeConservative(bool aBeConservative) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTlsFlags(uint32_t *aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTlsFlags(uint32_t aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLastModifiedTime(PRTime *aLastModifiedTime) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::ForceIntercepted(uint64_t aInterceptionID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseSynthesized(bool *aResponseSynthesized) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCorsIncludeCredentials(bool *aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCorsIncludeCredentials(bool aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCorsMode(uint32_t *aCorsMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCorsMode(uint32_t aCorsMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRedirectMode(uint32_t *aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRedirectMode(uint32_t aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetFetchCacheMode(uint32_t *aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetFetchCacheMode(uint32_t aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopWindowURI(nsIURI * *aTopWindowURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopWindowURIIfUnknown(nsIURI *topWindowURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetNetworkInterfaceId(nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetNetworkInterfaceId(const nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetProxyURI(nsIURI * *aProxyURI) { return NS_OK; }
+void SyntheticHttpChannel::SetCorsPreflightParameters(const nsTArray<nsCString> & unsafeHeaders) { }
+NS_IMETHODIMP SyntheticHttpChannel::GetBlockAuthPrompt(bool *aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetBlockAuthPrompt(bool aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIntegrityMetadata(nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetIntegrityMetadata(const nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetConnectionInfoHashKey(nsACString & aConnectionInfoHashKey) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLastRedirectFlags(uint32_t *aLastRedirectFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLastRedirectFlags(uint32_t aLastRedirectFlags) { return NS_OK; }
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/SyntheticHttpChannel.h b/netwerk/protocol/http/SyntheticHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/SyntheticHttpChannel.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_SyntheticHttpChannel_h
+#define mozilla_net_SyntheticHttpChannel_h
+
+#include "nsIHttpChannel.h"
+#include "nsIHttpChannelInternal.h"
+
+namespace mozilla {
+namespace net {
+
+class SyntheticHttpChannel final : public nsIHttpChannel
+                                 , public nsIHttpChannelInternal
+{
+  virtual ~SyntheticHttpChannel();
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIREQUEST
+  NS_DECL_NSICHANNEL
+  NS_DECL_NSIHTTPCHANNEL
+  NS_DECL_NSIHTTPCHANNELINTERNAL
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_SyntheticHttpChannel_h
diff --git a/netwerk/protocol/http/moz.build b/netwerk/protocol/http/moz.build
--- a/netwerk/protocol/http/moz.build
+++ b/netwerk/protocol/http/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'HttpBackgroundChannelChild.cpp',
     'HttpBackgroundChannelParent.cpp',
     'HttpBaseChannel.cpp',
     'HttpChannelChild.cpp',
     'HttpChannelParent.cpp',
     'HttpChannelParentListener.cpp',
     'HttpInfo.cpp',
     'InterceptedChannel.cpp',
+    'InterceptedHttpChannel.cpp',
     'nsCORSListenerProxy.cpp',
     'nsHttp.cpp',
     'nsHttpActivityDistributor.cpp',
     'nsHttpAuthCache.cpp',
     'nsHttpAuthManager.cpp',
     'nsHttpBasicAuth.cpp',
     'nsHttpChannel.cpp',
     'nsHttpChunkedDecoder.cpp',
@@ -91,16 +92,17 @@ UNIFIED_SOURCES += [
     'nsHttpDigestAuth.cpp',
     'nsHttpHeaderArray.cpp',
     'nsHttpNTLMAuth.cpp',
     'nsHttpRequestHead.cpp',
     'nsHttpResponseHead.cpp',
     'nsHttpTransaction.cpp',
     'NullHttpChannel.cpp',
     'NullHttpTransaction.cpp',
+    'SyntheticHttpChannel.cpp',
     'TunnelUtils.cpp',
 ]
 
 # These files cannot be built in unified mode because of OS X headers.
 SOURCES += [
     'nsHttpHandler.cpp',
 ]
 
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -106,16 +106,17 @@
 #include "HSTSPrimerListener.h"
 #include "CacheStorageService.h"
 #include "HttpChannelParent.h"
 #include "nsIBufferedStreams.h"
 #include "nsIFileStreams.h"
 #include "nsIMIMEInputStream.h"
 #include "nsIMultiplexInputStream.h"
 #include "../../cache2/CacheFileUtils.h"
+#include "InterceptedHttpChannel.h"
 
 #ifdef MOZ_TASK_TRACER
 #include "GeckoTaskTracer.h"
 #endif
 
 namespace mozilla { namespace net {
 
 namespace {
@@ -6145,18 +6146,62 @@ nsHttpChannel::AsyncOpen(nsIStreamListen
 
     rv = NS_CheckPortSafety(mURI);
     if (NS_FAILED(rv)) {
         ReleaseListeners();
         return rv;
     }
 
     if (mInterceptCache != INTERCEPTED && ShouldIntercept()) {
+
+      nsCOMPtr<nsINetworkInterceptController> controller;
+      GetCallback(controller);
+
+      RefPtr<InterceptedHttpChannel> intercepted =
+        new InterceptedHttpChannel();
+
+      rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                             mProxyResolveFlags, mProxyURI, mChannelId);
+
+      nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+        CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
+      intercepted->SetLoadInfo(redirectLoadInfo);
+
+      rv = SetupReplacementChannel(mURI, intercepted, true,
+                                   nsIChannelEventSink::REDIRECT_INTERNAL);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      // Inform consumers about this fake redirect
+      mRedirectChannel = intercepted;
+
+      PushRedirectAsyncFunc(
+          &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      rv = gHttpHandler->AsyncOnChannelRedirect(this, intercepted,
+                                                nsIChannelEventSink::REDIRECT_INTERNAL);
+
+      if (NS_SUCCEEDED(rv)) {
+        rv = WaitForRedirectCallback();
+      }
+
+      if (NS_FAILED(rv)) {
+        AutoRedirectVetoNotifier notifier(this);
+
+        /* Remove the async call to ContinueAsyncRedirectChannelToURI().
+         * It is called directly by our callers upon return (to clean up
+         * the failed redirect). */
+        PopRedirectAsyncFunc(
+            &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+      }
+
+      return rv;
+
+        /*
         mInterceptCache = MAYBE_INTERCEPT;
         SetCouldBeSynthesized();
+        */
     }
 
     // Remember the cookie header that was set, if any
     nsAutoCString cookieHeader;
     if (NS_SUCCEEDED(mRequestHead.GetHeader(nsHttp::Cookie, cookieHeader))) {
         mUserSetCookieHeader = cookieHeader;
     }
 
