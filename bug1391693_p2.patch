# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  164c6b0ffd7f0e492a7e100b95ef1854e25d8b0c

diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -0,0 +1,177 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "InterceptedHttpChannel.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMETHODIMP InterceptedHttpChannel::GetName(nsACString & aName) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::IsPending(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetStatus(nsresult *aStatus) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::Cancel(nsresult aStatus) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::Suspend(void) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::Resume(void) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLoadGroup(nsILoadGroup * *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLoadGroup(nsILoadGroup *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLoadFlags(nsLoadFlags aLoadFlags) { return NS_OK; }
+
+NS_IMETHODIMP InterceptedHttpChannel::GetOriginalURI(nsIURI * *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetOriginalURI(nsIURI *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetURI(nsIURI * *aURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetOwner(nsISupports * *aOwner) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetOwner(nsISupports *aOwner) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor * *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetNotificationCallbacks(nsIInterfaceRequestor *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetSecurityInfo(nsISupports * *aSecurityInfo) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentType(nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetContentType(const nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentCharset(nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetContentCharset(const nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentLength(int64_t *aContentLength) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetContentLength(int64_t aContentLength) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::Open(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::Open2(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::AsyncOpen2(nsIStreamListener *aListener) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentDisposition(uint32_t *aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetContentDisposition(uint32_t aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentDispositionFilename(nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetContentDispositionFilename(const nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetContentDispositionHeader(nsACString & aContentDispositionHeader) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLoadInfo(nsILoadInfo * *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLoadInfo(nsILoadInfo *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetIsDocument(bool *aIsDocument) { return NS_OK; }
+
+NS_IMETHODIMP InterceptedHttpChannel::GetRequestMethod(nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetRequestMethod(const nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetReferrer(nsIURI * *aReferrer) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetReferrer(nsIURI *aReferrer) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetReferrerPolicy(uint32_t *aReferrerPolicy) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetReferrerWithPolicy(nsIURI *referrer, uint32_t referrerPolicy) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetProtocolVersion(nsACString & aProtocolVersion) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetTransferSize(uint64_t *aTransferSize) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetDecodedBodySize(uint64_t *aDecodedBodySize) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetEncodedBodySize(uint64_t *aEncodedBodySize) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRequestHeader(const nsACString & aHeader, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetRequestHeader(const nsACString & aHeader, const nsACString & aValue, bool aMerge) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetEmptyRequestHeader(const nsACString & aHeader) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::VisitRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::VisitNonDefaultRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetAllowPipelining(bool *aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetAllowPipelining(bool aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetAllowSTS(bool *aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetAllowSTS(bool aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRedirectionLimit(uint32_t *aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetRedirectionLimit(uint32_t aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseStatus(uint32_t *aResponseStatus) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseStatusText(nsACString & aResponseStatusText) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRequestSucceeded(bool *aRequestSucceeded) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetIsMainDocumentChannel(bool *aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetIsMainDocumentChannel(bool aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseHeader(const nsACString & header, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetResponseHeader(const nsACString & header, const nsACString & value, bool merge) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::VisitResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetOriginalResponseHeader(const nsACString & aHeader, nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::VisitOriginalResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::IsNoStoreResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::IsNoCacheResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::IsPrivateResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::RedirectTo(nsIURI *aTargetURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRequestContextID(uint64_t *aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetRequestContextID(uint64_t aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetChannelId(uint64_t *aChannelId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetChannelId(uint64_t aChannelId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetTopLevelContentWindowId(uint64_t *aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetTopLevelContentWindowId(uint64_t aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetIsTrackingResource(bool *aIsTrackingResource) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetTopLevelOuterContentWindowId(uint64_t *aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetTopLevelOuterContentWindowId(uint64_t aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::LogBlockedCORSRequest(const nsAString & aMessage) { return NS_OK; }
+
+NS_IMETHODIMP InterceptedHttpChannel::GetDocumentURI(nsIURI * *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetDocumentURI(nsIURI *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRequestVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::TakeAllSecurityMessages(nsCOMArray<nsISecurityConsoleMessage> & aMessages) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetCookie(const char * aCookieHeader) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetupFallbackChannel(const char * aFallbackKey) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetThirdPartyFlags(uint32_t *aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetThirdPartyFlags(uint32_t aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetForceAllowThirdPartyCookie(bool *aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetForceAllowThirdPartyCookie(bool aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetCanceled(bool *aCanceled) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetChannelIsForDownload(bool *aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetChannelIsForDownload(bool aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLocalAddress(nsACString & aLocalAddress) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLocalPort(int32_t *aLocalPort) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRemoteAddress(nsACString & aRemoteAddress) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRemotePort(int32_t *aRemotePort) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetCacheKeysRedirectChain(nsTArray<nsCString> *cacheKeys) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::HTTPUpgrade(const nsACString & aProtocolName, nsIHttpUpgradeListener *aListener) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetAllowSpdy(bool *aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetAllowSpdy(bool aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseTimeoutEnabled(bool *aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetResponseTimeoutEnabled(bool aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetInitialRwin(uint32_t *aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetInitialRwin(uint32_t aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetApiRedirectToURI(nsIURI * *aApiRedirectToURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetAllowAltSvc(bool *aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetAllowAltSvc(bool aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetBeConservative(bool *aBeConservative) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetBeConservative(bool aBeConservative) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetTlsFlags(uint32_t *aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetTlsFlags(uint32_t aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLastModifiedTime(PRTime *aLastModifiedTime) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::ForceIntercepted(uint64_t aInterceptionID) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseSynthesized(bool *aResponseSynthesized) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetCorsIncludeCredentials(bool *aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetCorsIncludeCredentials(bool aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetCorsMode(uint32_t *aCorsMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetCorsMode(uint32_t aCorsMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetRedirectMode(uint32_t *aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetRedirectMode(uint32_t aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetFetchCacheMode(uint32_t *aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetFetchCacheMode(uint32_t aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetTopWindowURI(nsIURI * *aTopWindowURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetTopWindowURIIfUnknown(nsIURI *topWindowURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetNetworkInterfaceId(nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetNetworkInterfaceId(const nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetProxyURI(nsIURI * *aProxyURI) { return NS_OK; }
+void InterceptedHttpChannel::SetCorsPreflightParameters(const nsTArray<nsCString> & unsafeHeaders) { }
+NS_IMETHODIMP InterceptedHttpChannel::GetBlockAuthPrompt(bool *aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetBlockAuthPrompt(bool aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetIntegrityMetadata(nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetIntegrityMetadata(const nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetConnectionInfoHashKey(nsACString & aConnectionInfoHashKey) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetLastRedirectFlags(uint32_t *aLastRedirectFlags) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLastRedirectFlags(uint32_t aLastRedirectFlags) { return NS_OK; }
+
+NS_IMETHODIMP InterceptedHttpChannel::ResetInterception(void) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SynthesizeStatus(uint16_t status, const nsACString & reason) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SynthesizeHeader(const nsACString & name, const nsACString & value) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString & finalURLSpec) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::CancelInterception(nsresult status) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetResponseBody(nsIOutputStream * *aResponseBody) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetChannel(nsIChannel * *aChannel) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetSecureUpgradedChannelURI(nsIURI * *aSecureUpgradedChannelURI) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetChannelInfo(mozilla::dom::ChannelInfo *channelInfo) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetInternalContentPolicyType(nsContentPolicyType *aInternalContentPolicyType) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector * *aConsoleReportCollector) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetDispatchFetchEventEnd(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetHandleFetchEventStart(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetHandleFetchEventEnd(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetFinishResponseStart(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetFinishSynthesizedResponseEnd(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetChannelResetEnd(mozilla::TimeStamp aTimeStamp) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SaveTimeStamps(void) { return NS_OK; }
+NS_IMETHODIMP InterceptedHttpChannel::SetReleaseHandle(nsISupports *aHandle) { return NS_OK; }
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_InterceptedHttpChannel_h
+#define mozilla_net_InterceptedHttpChannel_h
+
+#include "nsIHttpChannel.h"
+#include "nsIHttpChannelInternal.h"
+#include "nsINetworkInterceptController.h"
+
+namespace mozilla {
+namespace net {
+
+class InterceptedHttpChannel final : public nsIHttpChannel
+                                   , public nsIHttpChannelInternal
+                                   , public nsIInterceptedChannel
+{
+  virtual ~InterceptedHttpChannel();
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIREQUEST
+  NS_DECL_NSICHANNEL
+  NS_DECL_NSIHTTPCHANNEL
+  NS_DECL_NSIHTTPCHANNELINTERNAL
+  NS_DECL_NSIINTERCEPTEDCHANNEL
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_InterceptedHttpChannel_h
diff --git a/netwerk/protocol/http/SyntheticHttpChannel.cpp b/netwerk/protocol/http/SyntheticHttpChannel.cpp
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/SyntheticHttpChannel.cpp
@@ -0,0 +1,155 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SyntheticHttpChannel.h"
+
+namespace mozilla {
+namespace net {
+
+NS_IMETHODIMP SyntheticHttpChannel::GetName(nsACString & aName) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsPending(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetStatus(nsresult *aStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Cancel(nsresult aStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Suspend(void) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Resume(void) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadGroup(nsILoadGroup * *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadGroup(nsILoadGroup *aLoadGroup) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadFlags(nsLoadFlags aLoadFlags) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetOriginalURI(nsIURI * *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetOriginalURI(nsIURI *aOriginalURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetURI(nsIURI * *aURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetOwner(nsISupports * *aOwner) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetOwner(nsISupports *aOwner) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor * *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetNotificationCallbacks(nsIInterfaceRequestor *aNotificationCallbacks) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetSecurityInfo(nsISupports * *aSecurityInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentType(nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentType(const nsACString & aContentType) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentCharset(nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentCharset(const nsACString & aContentCharset) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentLength(int64_t *aContentLength) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentLength(int64_t aContentLength) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Open(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::Open2(nsIInputStream * *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::AsyncOpen(nsIStreamListener *aListener, nsISupports *aContext) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::AsyncOpen2(nsIStreamListener *aListener) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDisposition(uint32_t *aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentDisposition(uint32_t aContentDisposition) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDispositionFilename(nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetContentDispositionFilename(const nsAString & aContentDispositionFilename) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetContentDispositionHeader(nsACString & aContentDispositionHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLoadInfo(nsILoadInfo * *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLoadInfo(nsILoadInfo *aLoadInfo) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsDocument(bool *aIsDocument) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestMethod(nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestMethod(const nsACString & aRequestMethod) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetReferrer(nsIURI * *aReferrer) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetReferrer(nsIURI *aReferrer) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetReferrerPolicy(uint32_t *aReferrerPolicy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetReferrerWithPolicy(nsIURI *referrer, uint32_t referrerPolicy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetProtocolVersion(nsACString & aProtocolVersion) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTransferSize(uint64_t *aTransferSize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetDecodedBodySize(uint64_t *aDecodedBodySize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetEncodedBodySize(uint64_t *aEncodedBodySize) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestHeader(const nsACString & aHeader, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestHeader(const nsACString & aHeader, const nsACString & aValue, bool aMerge) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetEmptyRequestHeader(const nsACString & aHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitNonDefaultRequestHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowPipelining(bool *aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowPipelining(bool aAllowPipelining) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowSTS(bool *aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowSTS(bool aAllowSTS) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRedirectionLimit(uint32_t *aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRedirectionLimit(uint32_t aRedirectionLimit) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseStatus(uint32_t *aResponseStatus) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseStatusText(nsACString & aResponseStatusText) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestSucceeded(bool *aRequestSucceeded) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsMainDocumentChannel(bool *aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetIsMainDocumentChannel(bool aIsMainDocumentChannel) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseHeader(const nsACString & header, nsACString & _retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetResponseHeader(const nsACString & header, const nsACString & value, bool merge) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetOriginalResponseHeader(const nsACString & aHeader, nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::VisitOriginalResponseHeaders(nsIHttpHeaderVisitor *aVisitor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsNoStoreResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsNoCacheResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::IsPrivateResponse(bool *_retval) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::RedirectTo(nsIURI *aTargetURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestContextID(uint64_t *aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRequestContextID(uint64_t aRequestContextID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetChannelId(uint64_t *aChannelId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetChannelId(uint64_t aChannelId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopLevelContentWindowId(uint64_t *aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopLevelContentWindowId(uint64_t aTopLevelContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIsTrackingResource(bool *aIsTrackingResource) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopLevelOuterContentWindowId(uint64_t *aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopLevelOuterContentWindowId(uint64_t aTopLevelOuterContentWindowId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::LogBlockedCORSRequest(const nsAString & aMessage) { return NS_OK; }
+
+NS_IMETHODIMP SyntheticHttpChannel::GetDocumentURI(nsIURI * *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetDocumentURI(nsIURI *aDocumentURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRequestVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseVersion(uint32_t *major, uint32_t *minor) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::TakeAllSecurityMessages(nsCOMArray<nsISecurityConsoleMessage> & aMessages) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCookie(const char * aCookieHeader) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetupFallbackChannel(const char * aFallbackKey) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetThirdPartyFlags(uint32_t *aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetThirdPartyFlags(uint32_t aThirdPartyFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetForceAllowThirdPartyCookie(bool *aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetForceAllowThirdPartyCookie(bool aForceAllowThirdPartyCookie) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCanceled(bool *aCanceled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetChannelIsForDownload(bool *aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetChannelIsForDownload(bool aChannelIsForDownload) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLocalAddress(nsACString & aLocalAddress) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLocalPort(int32_t *aLocalPort) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRemoteAddress(nsACString & aRemoteAddress) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRemotePort(int32_t *aRemotePort) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCacheKeysRedirectChain(nsTArray<nsCString> *cacheKeys) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::HTTPUpgrade(const nsACString & aProtocolName, nsIHttpUpgradeListener *aListener) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowSpdy(bool *aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowSpdy(bool aAllowSpdy) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseTimeoutEnabled(bool *aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetResponseTimeoutEnabled(bool aResponseTimeoutEnabled) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetInitialRwin(uint32_t *aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetInitialRwin(uint32_t aInitialRwin) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetApiRedirectToURI(nsIURI * *aApiRedirectToURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetAllowAltSvc(bool *aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetAllowAltSvc(bool aAllowAltSvc) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetBeConservative(bool *aBeConservative) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetBeConservative(bool aBeConservative) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTlsFlags(uint32_t *aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTlsFlags(uint32_t aTlsFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLastModifiedTime(PRTime *aLastModifiedTime) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::ForceIntercepted(uint64_t aInterceptionID) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetResponseSynthesized(bool *aResponseSynthesized) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCorsIncludeCredentials(bool *aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCorsIncludeCredentials(bool aCorsIncludeCredentials) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetCorsMode(uint32_t *aCorsMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetCorsMode(uint32_t aCorsMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetRedirectMode(uint32_t *aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetRedirectMode(uint32_t aRedirectMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetFetchCacheMode(uint32_t *aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetFetchCacheMode(uint32_t aFetchCacheMode) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetTopWindowURI(nsIURI * *aTopWindowURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetTopWindowURIIfUnknown(nsIURI *topWindowURI) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetNetworkInterfaceId(nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetNetworkInterfaceId(const nsACString & aNetworkInterfaceId) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetProxyURI(nsIURI * *aProxyURI) { return NS_OK; }
+void SyntheticHttpChannel::SetCorsPreflightParameters(const nsTArray<nsCString> & unsafeHeaders) { }
+NS_IMETHODIMP SyntheticHttpChannel::GetBlockAuthPrompt(bool *aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetBlockAuthPrompt(bool aBlockAuthPrompt) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetIntegrityMetadata(nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetIntegrityMetadata(const nsAString & aIntegrityMetadata) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetConnectionInfoHashKey(nsACString & aConnectionInfoHashKey) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::GetLastRedirectFlags(uint32_t *aLastRedirectFlags) { return NS_OK; }
+NS_IMETHODIMP SyntheticHttpChannel::SetLastRedirectFlags(uint32_t aLastRedirectFlags) { return NS_OK; }
+
+} // namespace net
+} // namespace mozilla
diff --git a/netwerk/protocol/http/SyntheticHttpChannel.h b/netwerk/protocol/http/SyntheticHttpChannel.h
new file mode 100644
--- /dev/null
+++ b/netwerk/protocol/http/SyntheticHttpChannel.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=8 et tw=80 : */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_net_SyntheticHttpChannel_h
+#define mozilla_net_SyntheticHttpChannel_h
+
+#include "nsIHttpChannel.h"
+#include "nsIHttpChannelInternal.h"
+
+namespace mozilla {
+namespace net {
+
+class SyntheticHttpChannel final : public nsIHttpChannel
+                                 , public nsIHttpChannelInternal
+{
+  virtual ~SyntheticHttpChannel();
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIREQUEST
+  NS_DECL_NSICHANNEL
+  NS_DECL_NSIHTTPCHANNEL
+  NS_DECL_NSIHTTPCHANNELINTERNAL
+};
+
+} // namespace net
+} // namespace mozilla
+
+#endif // mozilla_net_SyntheticHttpChannel_h
diff --git a/netwerk/protocol/http/moz.build b/netwerk/protocol/http/moz.build
--- a/netwerk/protocol/http/moz.build
+++ b/netwerk/protocol/http/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'HttpBackgroundChannelChild.cpp',
     'HttpBackgroundChannelParent.cpp',
     'HttpBaseChannel.cpp',
     'HttpChannelChild.cpp',
     'HttpChannelParent.cpp',
     'HttpChannelParentListener.cpp',
     'HttpInfo.cpp',
     'InterceptedChannel.cpp',
+    'InterceptedHttpChannel.cpp',
     'nsCORSListenerProxy.cpp',
     'nsHttp.cpp',
     'nsHttpActivityDistributor.cpp',
     'nsHttpAuthCache.cpp',
     'nsHttpAuthManager.cpp',
     'nsHttpBasicAuth.cpp',
     'nsHttpChannel.cpp',
     'nsHttpChunkedDecoder.cpp',
@@ -91,16 +92,17 @@ UNIFIED_SOURCES += [
     'nsHttpDigestAuth.cpp',
     'nsHttpHeaderArray.cpp',
     'nsHttpNTLMAuth.cpp',
     'nsHttpRequestHead.cpp',
     'nsHttpResponseHead.cpp',
     'nsHttpTransaction.cpp',
     'NullHttpChannel.cpp',
     'NullHttpTransaction.cpp',
+    'SyntheticHttpChannel.cpp',
     'TunnelUtils.cpp',
 ]
 
 # These files cannot be built in unified mode because of OS X headers.
 SOURCES += [
     'nsHttpHandler.cpp',
 ]
 
