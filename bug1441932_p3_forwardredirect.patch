# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  932715d00bfea6bbfd0045319c7077db85efc728
Bug 1441932 P3 Forward reserved client, initial client, and controller on Redirect2Verify message back to parent. r=mayhemer

diff --git a/ipc/glue/BackgroundUtils.cpp b/ipc/glue/BackgroundUtils.cpp
--- a/ipc/glue/BackgroundUtils.cpp
+++ b/ipc/glue/BackgroundUtils.cpp
@@ -624,10 +624,96 @@ MergeParentLoadInfoForwarder(ParentLoadI
   if (controller.type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     aLoadInfo->SetController(
       ServiceWorkerDescriptor(controller.get_IPCServiceWorkerDescriptor()));
   }
 
   return NS_OK;
 }
 
+void
+LoadInfoToChildLoadInfoForwarder(nsILoadInfo* aLoadInfo,
+                                 ChildLoadInfoForwarderArgs* aForwarderArgsOut)
+{
+  if (!aLoadInfo) {
+    *aForwarderArgsOut = ChildLoadInfoForwarderArgs(void_t(), void_t(),
+                                                    void_t());
+    return;
+  }
+
+  OptionalIPCClientInfo ipcReserved = void_t();
+  Maybe<ClientInfo> reserved(aLoadInfo->GetReservedClientInfo());
+  if (reserved.isSome()) {
+    ipcReserved = reserved.ref().ToIPC();
+  }
+
+  OptionalIPCClientInfo ipcInitial = void_t();
+  Maybe<ClientInfo> initial(aLoadInfo->GetInitialClientInfo());
+  if (initial.isSome()) {
+    ipcInitial = initial.ref().ToIPC();
+  }
+
+  OptionalIPCServiceWorkerDescriptor ipcController = void_t();
+  Maybe<ServiceWorkerDescriptor> controller(aLoadInfo->GetController());
+  if (controller.isSome()) {
+    ipcController = controller.ref().ToIPC();
+  }
+
+  *aForwarderArgsOut = ChildLoadInfoForwarderArgs(
+    ipcReserved,
+    ipcInitial,
+    ipcController
+  );
+}
+
+nsresult
+MergeChildLoadInfoForwarder(const ChildLoadInfoForwarderArgs& aForwarderArgs,
+                            nsILoadInfo* aLoadInfo)
+{
+  if (!aLoadInfo) {
+    return NS_OK;
+  }
+
+  Maybe<ClientInfo> reservedClientInfo;
+  auto& ipcReserved = aForwarderArgs.reservedClientInfo();
+  if (ipcReserved.type() != OptionalIPCClientInfo::Tvoid_t) {
+    reservedClientInfo.emplace(ClientInfo(ipcReserved.get_IPCClientInfo()));
+  }
+
+  Maybe<ClientInfo> initialClientInfo;
+  auto& ipcInitial = aForwarderArgs.initialClientInfo();
+  if (ipcInitial.type() != OptionalIPCClientInfo::Tvoid_t) {
+    initialClientInfo.emplace(ClientInfo(ipcInitial.get_IPCClientInfo()));
+  }
+
+  // There should only be at most one reserved or initial ClientInfo.
+  if (NS_WARN_IF(reservedClientInfo.isSome() && initialClientInfo.isSome())) {
+    return NS_ERROR_FAILURE;
+  }
+
+  // If we received no reserved or initial ClientInfo, then we must not
+  // already have one set.  There are no use cases where this should
+  // happen and we don't have a way to clear the current value.
+  if (NS_WARN_IF(reservedClientInfo.isNothing() &&
+                 initialClientInfo.isNothing() &&
+                 (aLoadInfo->GetReservedClientInfo().isSome() ||
+                  aLoadInfo->GetInitialClientInfo().isSome()))) {
+    return NS_ERROR_FAILURE;
+  }
+
+  if (reservedClientInfo.isSome()) {
+    aLoadInfo->SetReservedClientInfo(reservedClientInfo.ref());
+  } else if (initialClientInfo.isSome()) {
+    aLoadInfo->SetInitialClientInfo(initialClientInfo.ref());
+  }
+
+  aLoadInfo->ClearController();
+  auto& controller = aForwarderArgs.controller();
+  if (controller.type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
+    aLoadInfo->SetController(
+      ServiceWorkerDescriptor(controller.get_IPCServiceWorkerDescriptor()));
+  }
+
+  return NS_OK;
+}
+
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/glue/BackgroundUtils.h b/ipc/glue/BackgroundUtils.h
--- a/ipc/glue/BackgroundUtils.h
+++ b/ipc/glue/BackgroundUtils.h
@@ -44,16 +44,17 @@ struct OriginAttributesParamTraits
 template<>
 struct ParamTraits<mozilla::OriginAttributes>
   : public detail::OriginAttributesParamTraits<mozilla::OriginAttributes> {};
 
 } // namespace IPC
 
 namespace mozilla {
 namespace net {
+class ChildLoadInfoForwarderArgs;
 class OptionalLoadInfoArgs;
 class ParentLoadInfoForwarderArgs;
 class RedirectHistoryEntryInfo;
 } // namespace net
 
 using namespace mozilla::net;
 
 namespace ipc {
@@ -124,12 +125,29 @@ LoadInfoToParentLoadInfoForwarder(nsILoa
 /**
  * Merges (replaces) properties of an existing LoadInfo on a child process
  * with properties carried down through ParentLoadInfoForwarderArgs.
  */
 nsresult
 MergeParentLoadInfoForwarder(ParentLoadInfoForwarderArgs const& aForwarderArgs,
                              nsILoadInfo *aLoadInfo);
 
+
+/**
+ * Fills ChildLoadInfoForwarderArgs with properties we want to carry to the
+ * parent process after the initial channel creation.
+ */
+void
+LoadInfoToChildLoadInfoForwarder(nsILoadInfo* aLoadInfo,
+                                 ChildLoadInfoForwarderArgs* aForwarderArgsOut);
+
+/**
+ * Merges (replaces) properties of an existing LoadInfo on the parent process
+ * with properties contained in a ChildLoadInfoForwarderArgs.
+ */
+nsresult
+MergeChildLoadInfoForwarder(const ChildLoadInfoForwarderArgs& aForwardArgs,
+                            nsILoadInfo* aLoadInfo);
+
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundutils_h__
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -132,16 +132,35 @@ struct ParentLoadInfoForwarderArgs
   // interception occurs.
   OptionalIPCServiceWorkerDescriptor controller;
 
   // IMPORTANT: when you add new properites here you must also update
   // LoadInfoToParentLoadInfoForwarder and MergeParentLoadInfoForwarder
   // in BackgroundUtils.cpp/.h!
 };
 
+/**
+ * This structure is used to carry selected properties of a LoadInfo
+ * object to the parent process that might have changed in the child
+ * during a redirect.  We don't want to use LoadInfoArgs for that since
+ * it's too huge and we only care about small subpart of properties
+ * anyway.
+ */
+struct ChildLoadInfoForwarderArgs
+{
+  // The reserved and initial ClientInfo values may change during a
+  // redirect if the new channel is cross-origin to the old channel.
+  OptionalIPCClientInfo reservedClientInfo;
+  OptionalIPCClientInfo initialClientInfo;
+
+  // The ServiceWorker controller may be cleared in the child during
+  // a redirect.
+  OptionalIPCServiceWorkerDescriptor controller;
+};
+
 //-----------------------------------------------------------------------------
 // HTTP IPDL structs
 //-----------------------------------------------------------------------------
 
 union OptionalHttpResponseHead
 {
   void_t;
   nsHttpResponseHead;
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -2307,20 +2307,29 @@ HttpChannelChild::OnRedirectVerifyCallba
 
   bool chooseAppcache = false;
   nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
     do_QueryInterface(newHttpChannel);
   if (appCacheChannel) {
     appCacheChannel->GetChooseApplicationCache(&chooseAppcache);
   }
 
+  nsCOMPtr<nsILoadInfo> newLoadInfo;
+  nsCOMPtr<nsIChannel> newChannel = do_QueryInterface(mRedirectChannelChild);
+  if (newChannel) {
+    Unused << newHttpChannel->GetLoadInfo(getter_AddRefs(newLoadInfo));
+  }
+
+  ChildLoadInfoForwarderArgs loadInfoForwarder;
+  LoadInfoToChildLoadInfoForwarder(newLoadInfo, &loadInfoForwarder);
+
   if (mIPCOpen)
-    SendRedirect2Verify(result, *headerTuples, loadFlags, referrerPolicy,
-                        referrerURI, redirectURI, corsPreflightArgs,
-                        chooseAppcache);
+    SendRedirect2Verify(result, *headerTuples, loadInfoForwarder, loadFlags,
+                        referrerPolicy, referrerURI, redirectURI,
+                        corsPreflightArgs, chooseAppcache);
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIRequest
 //-----------------------------------------------------------------------------
 
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -874,28 +874,36 @@ HttpChannelParent::RecvUpdateAssociatedC
   if (mAssociatedContentSecurity) {
     mAssociatedContentSecurity->SetCountSubRequestsBrokenSecurity(broken);
     mAssociatedContentSecurity->SetCountSubRequestsNoSecurity(no);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
-HttpChannelParent::RecvRedirect2Verify(const nsresult& result,
+HttpChannelParent::RecvRedirect2Verify(const nsresult& aResult,
                                        const RequestHeaderTuples& changedHeaders,
+                                       const ChildLoadInfoForwarderArgs& aLoadInfoForwarder,
                                        const uint32_t& loadFlags,
                                        const uint32_t& referrerPolicy,
                                        const OptionalURIParams& aReferrerURI,
                                        const OptionalURIParams& aAPIRedirectURI,
                                        const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                        const bool& aChooseAppcache)
 {
   LOG(("HttpChannelParent::RecvRedirect2Verify [this=%p result=%" PRIx32 "]\n",
-       this, static_cast<uint32_t>(result)));
+       this, static_cast<uint32_t>(aResult)));
+
+  // Result from the child.  If something fails here, we might overwrite a
+  // success with a further failure.
+  nsresult result = aResult;
+
+  // Local results.
   nsresult rv;
+
   if (NS_SUCCEEDED(result)) {
     nsCOMPtr<nsIHttpChannel> newHttpChannel =
         do_QueryInterface(mRedirectChannel);
 
     if (newHttpChannel) {
       nsCOMPtr<nsIURI> apiRedirectUri = DeserializeURI(aAPIRedirectURI);
 
       if (apiRedirectUri) {
@@ -932,16 +940,23 @@ HttpChannelParent::RecvRedirect2Verify(c
       rv = newHttpChannel->SetReferrerWithPolicy(referrerUri, referrerPolicy);
       MOZ_ASSERT(NS_SUCCEEDED(rv));
 
       nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
         do_QueryInterface(newHttpChannel);
       if (appCacheChannel) {
         appCacheChannel->SetChooseApplicationCache(aChooseAppcache);
       }
+
+      nsCOMPtr<nsILoadInfo> newLoadInfo;
+      Unused << newHttpChannel->GetLoadInfo(getter_AddRefs(newLoadInfo));
+      rv = MergeChildLoadInfoForwarder(aLoadInfoForwarder, newLoadInfo);
+      if (NS_FAILED(rv) && NS_SUCCEEDED(result)) {
+        result = rv;
+      }
     }
   }
 
   // Continue the verification procedure if child has veto the redirection.
   if (NS_FAILED(result)) {
     ContinueRedirect2Verify(result);
     return IPC_OK();
   }
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -184,16 +184,17 @@ protected:
   virtual mozilla::ipc::IPCResult RecvSetPriority(const int16_t& priority) override;
   virtual mozilla::ipc::IPCResult RecvSetClassOfService(const uint32_t& cos) override;
   virtual mozilla::ipc::IPCResult RecvSetCacheTokenCachedCharset(const nsCString& charset) override;
   virtual mozilla::ipc::IPCResult RecvSuspend() override;
   virtual mozilla::ipc::IPCResult RecvResume() override;
   virtual mozilla::ipc::IPCResult RecvCancel(const nsresult& status) override;
   virtual mozilla::ipc::IPCResult RecvRedirect2Verify(const nsresult& result,
                                                       const RequestHeaderTuples& changedHeaders,
+                                                      const ChildLoadInfoForwarderArgs& aLoadInfoForwarder,
                                                       const uint32_t& loadFlags,
                                                       const uint32_t& referrerPolicy,
                                                       const OptionalURIParams& aReferrerURI,
                                                       const OptionalURIParams& apiRedirectUri,
                                                       const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                                       const bool& aChooseAppcache) override;
   virtual mozilla::ipc::IPCResult RecvUpdateAssociatedContentSecurity(const int32_t& broken,
                                                    const int32_t& no) override;
diff --git a/netwerk/protocol/http/PHttpChannel.ipdl b/netwerk/protocol/http/PHttpChannel.ipdl
--- a/netwerk/protocol/http/PHttpChannel.ipdl
+++ b/netwerk/protocol/http/PHttpChannel.ipdl
@@ -39,16 +39,17 @@ parent:
                                         int32_t no);
   async Suspend();
   async Resume();
 
   async Cancel(nsresult status);
 
   // Reports approval/veto of redirect by child process redirect observers
   async Redirect2Verify(nsresult result, RequestHeaderTuples changedHeaders,
+                        ChildLoadInfoForwarderArgs loadInfoForwarder,
                         uint32_t loadFlags, uint32_t referrerPolicy,
                         OptionalURIParams referrerUri,
                         OptionalURIParams apiRedirectTo,
                         OptionalCorsPreflightArgs corsPreflightArgs,
                         bool chooseAppcache);
 
   // For document loads we keep this protocol open after child's
   // OnStopRequest, and send this msg (instead of __delete__) to allow
