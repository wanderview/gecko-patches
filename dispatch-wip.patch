# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d98cd9cb05a71748c767b6fb46f81498a45c830b

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1512,16 +1512,43 @@ ServiceWorkerManager::GetActiveWorkerInf
 
   if (!registration) {
     return nullptr;
   }
 
   return registration->GetActive();
 }
 
+ServiceWorkerInfo*
+ServiceWorkerManager::GetActiveWorkerInfoForDescriptor(const ServiceWorkerDescriptor* aDesc)
+{
+  AssertIsOnMainThread();
+  MOZ_DIAGNOSTIC_ASSERT(aDesc);
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aDesc->PrincipalInfo());
+
+  nsCOMPtr<nsIURI> scope;
+  nsresult rv = NS_NewURI(getter_AddRefs(scope), aDesc->Scope());
+  NS_ENSURE_SUCCESS(rv, nullptr);
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetServiceWorkerRegistrationInfo(principal, scope);
+  if (!registration) {
+    return nullptr;
+  }
+
+  ServiceWorkerInfo* info = registration->GetActive();
+  if (info->ID() != aDesc->Id()) {
+    return nullptr;
+  }
+
+  return info;
+}
+
 namespace {
 
 class UnregisterJobCallback final : public ServiceWorkerJob::Callback
 {
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
 
   ~UnregisterJobCallback()
   {
@@ -2439,16 +2466,79 @@ public:
 
     return NS_OK;
   }
 };
 
 } // anonymous namespace
 
 void
+ServiceWorkerManager::DispatchSubresourceFetchEvent(const ServiceWorkerDescriptor& aServiceWorker,
+                                                    nsILoadGroup* aLoadGroup,
+                                                    nsIInterceptedChannel* aChannel,
+                                                    ErrorResult& aRv)
+{
+  RefPtr<ServiceWorkerInfo> serviceWorker =
+    GetActiveWorkerInfoForDescriptor(aServiceWorker);
+
+  DispatchFetchEventInternal(serviceWorker, aLoadGroup, aChannel,
+                             false /* aIsReload */, aRv);
+}
+
+void
+ServiceWorkerManager::DispatchNonSubresourceFetchEvent(const OriginAttributes& aOriginAttributes,
+                                                       nsILoadGroup* aLoadGroup,
+                                                       nsIInterceptedChannel* aChannel,
+                                                       bool aIsReload,
+                                                       ErrorResult& aRv)
+{
+}
+
+void
+ServiceWorkerManager::DispatchFetchEventInternal(ServiceWorkerInfo* aServiceWorker,
+                                                 nsILoadGroup* aLoadGroup,
+                                                 nsIInterceptedChannel* aChannel,
+                                                 bool aIsReload,
+                                                 ErrorResult& aRv)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aServiceWorker);
+
+  nsCOMPtr<nsIRunnable> continueRunnable =
+    new ContinueDispatchFetchEventRunnable(aServiceWorker->WorkerPrivate(),
+                                           aChannel, aLoadGroup, aIsReload);
+
+  // When this service worker was registered, we also sent down the permissions
+  // for the runnable. They should have arrived by now, but we still need to
+  // wait for them if they have not.
+  nsCOMPtr<nsIRunnable> permissionsRunnable = NS_NewRunnableFunction(
+    "dom::workers::ServiceWorkerManager::DispatchFetchEvent", [=]() {
+      nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
+      MOZ_ALWAYS_SUCCEEDS(permMgr->WhenPermissionsAvailable(aServiceWorker->Principal(),
+                                                            continueRunnable));
+    });
+
+  nsCOMPtr<nsIChannel> innerChannel;
+  aRv = aChannel->GetChannel(getter_AddRefs(innerChannel));
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+
+  nsCOMPtr<nsIUploadChannel2> uploadChannel = do_QueryInterface(innerChannel);
+
+  // If there is no upload stream, then continue immediately
+  if (!uploadChannel) {
+    MOZ_ALWAYS_SUCCEEDS(permissionsRunnable->Run());
+    return;
+  }
+  // Otherwise, ensure the upload stream can be cloned directly.  This may
+  // require some async copying, so provide a callback.
+  aRv = uploadChannel->EnsureUploadStreamIsCloneable(permissionsRunnable);
+}
+
+void
 ServiceWorkerManager::DispatchFetchEvent(const OriginAttributes& aOriginAttributes,
                                          nsIDocument* aDoc,
                                          nsIInterceptedChannel* aChannel,
                                          bool aIsReload,
                                          bool aIsSubresourceLoad,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
@@ -2541,48 +2631,17 @@ ServiceWorkerManager::DispatchFetchEvent
       loadInfo->SetController(serviceWorker->Descriptor());
     }
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
-  MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
-
-  nsCOMPtr<nsIRunnable> continueRunnable =
-    new ContinueDispatchFetchEventRunnable(serviceWorker->WorkerPrivate(),
-                                           aChannel, loadGroup, aIsReload);
-
-  // When this service worker was registered, we also sent down the permissions
-  // for the runnable. They should have arrived by now, but we still need to
-  // wait for them if they have not.
-  nsCOMPtr<nsIRunnable> permissionsRunnable = NS_NewRunnableFunction(
-    "dom::workers::ServiceWorkerManager::DispatchFetchEvent", [=]() {
-      nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
-      MOZ_ALWAYS_SUCCEEDS(permMgr->WhenPermissionsAvailable(serviceWorker->Principal(),
-                                                            continueRunnable));
-    });
-
-  nsCOMPtr<nsIChannel> innerChannel;
-  aRv = aChannel->GetChannel(getter_AddRefs(innerChannel));
-  if (NS_WARN_IF(aRv.Failed())) {
-    return;
-  }
-
-  nsCOMPtr<nsIUploadChannel2> uploadChannel = do_QueryInterface(innerChannel);
-
-  // If there is no upload stream, then continue immediately
-  if (!uploadChannel) {
-    MOZ_ALWAYS_SUCCEEDS(permissionsRunnable->Run());
-    return;
-  }
-  // Otherwise, ensure the upload stream can be cloned directly.  This may
-  // require some async copying, so provide a callback.
-  aRv = uploadChannel->EnsureUploadStreamIsCloneable(permissionsRunnable);
+  DispatchFetchEventInternal(serviceWorker, loadGroup, aChannel, aIsReload, aRv);
 }
 
 bool
 ServiceWorkerManager::IsAvailable(nsIPrincipal* aPrincipal,
                                   nsIURI* aURI)
 {
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(aURI);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -137,16 +137,36 @@ public:
   // semantics that ensure this method returns true until the worker is known to
   // have shut down in order to allow the caller to induce a crash for security
   // reasons without having to worry about shutdown races with the worker.
   bool
   MayHaveActiveServiceWorkerInstance(ContentParent* aContent,
                                      nsIPrincipal* aPrincipal);
 
   void
+  DispatchSubresourceFetchEvent(const ServiceWorkerDescriptor& aServiceWorker,
+                                nsILoadGroup* aLoadGroup,
+                                nsIInterceptedChannel* aChannel,
+                                ErrorResult& aRv);
+
+  void
+  DispatchNonSubresourceFetchEvent(const OriginAttributes& aOriginAttributes,
+                                   nsILoadGroup* aLoadGroup,
+                                   nsIInterceptedChannel* aChannel,
+                                   bool aIsReload,
+                                   ErrorResult& aRv);
+
+  void
+  DispatchFetchEventInternal(ServiceWorkerInfo* aServiceWorker,
+                             nsILoadGroup* aLoadGroup,
+                             nsIInterceptedChannel* aChannel,
+                             bool aIsReload,
+                             ErrorResult& aRv);
+
+  void
   DispatchFetchEvent(const OriginAttributes& aOriginAttributes,
                      nsIDocument* aDoc,
                      nsIInterceptedChannel* aChannel,
                      bool aIsReload,
                      bool aIsSubresourceLoad,
                      ErrorResult& aRv);
 
   void
@@ -364,16 +384,19 @@ private:
 
   ServiceWorkerInfo*
   GetActiveWorkerInfoForScope(const OriginAttributes& aOriginAttributes,
                               const nsACString& aScope);
 
   ServiceWorkerInfo*
   GetActiveWorkerInfoForDocument(nsIDocument* aDocument);
 
+  ServiceWorkerInfo*
+  GetActiveWorkerInfoForDescriptor(const ServiceWorkerDescriptor* aDesc);
+
   void
   TransitionServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOne);
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
