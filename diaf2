# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7e8d052b0fbc032642137e6b5b03dadf960cbbcd

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -34,40 +34,40 @@ Client::~Client()
 {
 }
 
 void
 Client::EnsureHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Client);
   if (!mHandle) {
-    mHandle = ClientManager::CreateHandle(mData.info());
+    mHandle = ClientManager::CreateHandle(ClientInfo(mData.info()));
   }
 }
 
 // TODO: unify this with code in Clients
 nsresult
 Client::GetEndPoint(ClientEndPoint& aEndPointOut)
 {
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
   if (window) {
     const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
     if (clientInfo.isSome()) {
-      aEndPointOut = clientInfo.ref();
+      aEndPointOut = clientInfo.ref().ToIPC();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
         aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
-        aEndPointOut = workerPrivate->GetClientInfo();
+        aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
         return NS_OK;
       }
     }
   }
 
   return NS_ERROR_DOM_INVALID_STATE_ERR;
 }
 
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -37,28 +37,28 @@ Clients::~Clients()
 
 nsresult
 Clients::GetEndPoint(ClientEndPoint& aEndPointOut)
 {
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
   if (window) {
     const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
     if (clientInfo.isSome()) {
-      aEndPointOut = clientInfo.ref();
+      aEndPointOut = clientInfo.ref().ToIPC();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
         aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
-        aEndPointOut = workerPrivate->GetClientInfo();
+        aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
         return NS_OK;
       }
     }
   }
 
   return NS_ERROR_DOM_INVALID_STATE_ERR;
 }
 
@@ -104,17 +104,17 @@ Clients::Get(const nsAString& aClientID,
     // undefined indicating "not found".
     outerPromise->MaybeResolveWithUndefined();
     return outerPromise.forget();
   }
 
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor
       ? endpoint.get_IPCServiceWorkerDescriptor().principalInfo()
-      : endpoint.get_ClientInfo().principalInfo();
+      : endpoint.get_IPCClientInfo().principalInfo();
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo));
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolve(
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -76,17 +76,18 @@ void
 ClientHandle::Activate(PClientManagerChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(ClientHandle);
 
   if (IsShutdown()) {
     return;
   }
 
-  PClientHandleChild* actor = aActor->SendPClientHandleConstructor(mClientInfo);
+  PClientHandleChild* actor =
+    aActor->SendPClientHandleConstructor(mClientInfo.ToIPC());
   if (!actor) {
     Shutdown();
     return;
   }
 
   ActivateThing(static_cast<ClientHandleChild*>(actor));
 
   MaybeExecuteTaskList();
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -1,28 +1,30 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientHandle_h
 #define _mozilla_dom_ClientHandle_h
 
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/MozPromise.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 
 namespace dom {
 
+class ClientEndPoint;
 class ClientManager;
 class ClientHandleChild;
+class ClientOpConstructorArgs;
 class PClientManagerChild;
 class ServiceWorkerDescriptor;
 
 namespace ipc {
 class StructuredCloneData;
 }
 
 class ClientHandle final : public ClientThing<ClientHandleChild>
diff --git a/dom/clients/manager/ClientHandleChild.cpp b/dom/clients/manager/ClientHandleChild.cpp
--- a/dom/clients/manager/ClientHandleChild.cpp
+++ b/dom/clients/manager/ClientHandleChild.cpp
@@ -10,20 +10,20 @@
 #include "mozilla/dom/ClientIPCTypes.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 IPCResult
-ClientHandleChild::RecvExecutionReady(const ClientInfo& aClientInfo)
+ClientHandleChild::RecvExecutionReady(const IPCClientInfo& aClientInfo)
 {
   if (mHandle) {
-    mHandle->ExecutionReady(aClientInfo);
+    mHandle->ExecutionReady(ClientInfo(aClientInfo));
   }
   return IPC_OK();
 }
 
 void
 ClientHandleChild::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mHandle) {
@@ -41,17 +41,17 @@ ClientHandleChild::AllocPClientHandleOpC
 
 bool
 ClientHandleChild::DeallocPClientHandleOpChild(PClientHandleOpChild* aActor)
 {
   delete aActor;
   return true;
 }
 
-ClientHandleChild::ClientHandleChild(const ClientInfo& aClientInfo)
+ClientHandleChild::ClientHandleChild()
   : mHandle(nullptr)
   , mTeardownStarted(false)
 {
 }
 
 void
 ClientHandleChild::SetOwner(ClientThing<ClientHandleChild>* aThing)
 {
diff --git a/dom/clients/manager/ClientHandleChild.h b/dom/clients/manager/ClientHandleChild.h
--- a/dom/clients/manager/ClientHandleChild.h
+++ b/dom/clients/manager/ClientHandleChild.h
@@ -8,38 +8,39 @@
 
 #include "mozilla/dom/PClientHandleChild.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientHandle;
 class ClientInfo;
+
 template <typename ActorType> class ClientThing;
 
 class ClientHandleChild final : public PClientHandleChild
 {
   ClientHandle* mHandle;
   bool mTeardownStarted;
 
   // PClientHandleChild interface
   mozilla::ipc::IPCResult
-  RecvExecutionReady(const ClientInfo& aClientInfo) override;
+  RecvExecutionReady(const IPCClientInfo& aClientInfo) override;
 
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   PClientHandleOpChild*
   AllocPClientHandleOpChild(const ClientOpConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientHandleOpChild(PClientHandleOpChild* aActor) override;
 
 public:
-  explicit ClientHandleChild(const ClientInfo& aClientInfo);
+  ClientHandleChild();
 
   void
   SetOwner(ClientThing<ClientHandleChild>* aThing);
 
   void
   RevokeOwner(ClientThing<ClientHandleChild>* aThing);
 
   void
diff --git a/dom/clients/manager/ClientHandleParent.cpp b/dom/clients/manager/ClientHandleParent.cpp
--- a/dom/clients/manager/ClientHandleParent.cpp
+++ b/dom/clients/manager/ClientHandleParent.cpp
@@ -62,17 +62,17 @@ ClientHandleParent::ClientHandleParent()
 }
 
 ClientHandleParent::~ClientHandleParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mSource);
 }
 
 void
-ClientHandleParent::Init(const ClientInfo& aClientInfo)
+ClientHandleParent::Init(const IPCClientInfo& aClientInfo)
 {
   mSource = mService->FindSource(aClientInfo.id(), aClientInfo.principalInfo());
   if (!mSource) {
     Unused << Send__delete__(this);
     return;
   }
 
   mSource->AttachHandle(this);
diff --git a/dom/clients/manager/ClientHandleParent.h b/dom/clients/manager/ClientHandleParent.h
--- a/dom/clients/manager/ClientHandleParent.h
+++ b/dom/clients/manager/ClientHandleParent.h
@@ -38,17 +38,17 @@ class ClientHandleParent final : public 
   RecvPClientHandleOpConstructor(PClientHandleOpParent* aActor,
                                  const ClientOpConstructorArgs& aArgs) override;
 
 public:
   ClientHandleParent();
   ~ClientHandleParent();
 
   void
-  Init(const ClientInfo& aClientInfo);
+  Init(const IPCClientInfo& aClientInfo);
 
   ClientSourceParent*
   GetSource() const;
 
   AbstractThread*
   BackgroundThread() const;
 };
 
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -18,17 +18,17 @@ namespace dom {
 struct ClientSourceConstructorArgs
 {
   nsID id;
   ClientType type;
   PrincipalInfo principalInfo;
   TimeStamp creationTime;
 };
 
-struct ClientInfo
+struct IPCClientInfo
 {
   nsID id;
   ClientType type;
   PrincipalInfo principalInfo;
   TimeStamp creationTime;
   nsCString url;
   FrameType frameType;
 };
@@ -47,17 +47,17 @@ struct ClientWorkerState
 union ClientState
 {
   ClientWindowState;
   ClientWorkerState;
 };
 
 struct ClientInfoAndState
 {
-  ClientInfo info;
+  IPCClientInfo info;
   ClientState state;
 };
 
 struct ClientSourceExecutionReadyArgs
 {
   nsCString url;
   FrameType frameType;
 };
@@ -68,24 +68,24 @@ struct ClientControlledArgs
 };
 
 struct ClientFocusArgs
 {
 };
 
 struct ClientNavigateArgs
 {
-  ClientInfo target;
+  IPCClientInfo target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientEndPoint
 {
-  ClientInfo;
+  IPCClientInfo;
   IPCServiceWorkerDescriptor;
 };
 
 struct ClientPostMessageArgs
 {
   ClonedMessageData clonedData;
   ClientEndPoint endpoint;
 };
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
--- a/dom/clients/manager/ClientManagerChild.cpp
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -29,19 +29,19 @@ ClientManagerChild::ActorDestroy(ActorDe
 
   if (mManager) {
     mManager->RevokeActor(this);
     MOZ_ASSERT(!mManager);
   }
 }
 
 PClientHandleChild*
-ClientManagerChild::AllocPClientHandleChild(const ClientInfo& aClientInfo)
+ClientManagerChild::AllocPClientHandleChild(const IPCClientInfo& aClientInfo)
 {
-  return new ClientHandleChild(aClientInfo);
+  return new ClientHandleChild();
 }
 
 bool
 ClientManagerChild::DeallocPClientHandleChild(PClientHandleChild* aActor)
 {
   delete aActor;
   return true;
 }
diff --git a/dom/clients/manager/ClientManagerChild.h b/dom/clients/manager/ClientManagerChild.h
--- a/dom/clients/manager/ClientManagerChild.h
+++ b/dom/clients/manager/ClientManagerChild.h
@@ -26,17 +26,17 @@ class ClientManagerChild final : public 
   RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
   bool mTeardownStarted;
 
   // PClientManagerChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   PClientHandleChild*
-  AllocPClientHandleChild(const ClientInfo& aClientInfo) override;
+  AllocPClientHandleChild(const IPCClientInfo& aClientInfo) override;
 
   bool
   DeallocPClientHandleChild(PClientHandleChild* aActor) override;
 
   PClientManagerOpChild*
   AllocPClientManagerOpChild(const ClientOpConstructorArgs& aArgs) override;
 
   bool
diff --git a/dom/clients/manager/ClientManagerParent.cpp b/dom/clients/manager/ClientManagerParent.cpp
--- a/dom/clients/manager/ClientManagerParent.cpp
+++ b/dom/clients/manager/ClientManagerParent.cpp
@@ -26,31 +26,31 @@ ClientManagerParent::RecvTeardown()
 }
 
 void
 ClientManagerParent::ActorDestroy(ActorDestroyReason aReason)
 {
 }
 
 PClientHandleParent*
-ClientManagerParent::AllocPClientHandleParent(const ClientInfo& aClientInfo)
+ClientManagerParent::AllocPClientHandleParent(const IPCClientInfo& aClientInfo)
 {
   return new ClientHandleParent();
 }
 
 bool
 ClientManagerParent::DeallocPClientHandleParent(PClientHandleParent* aActor)
 {
   delete aActor;
   return true;
 }
 
 IPCResult
 ClientManagerParent::RecvPClientHandleConstructor(PClientHandleParent* aActor,
-                                                  const ClientInfo& aClientInfo)
+                                                  const IPCClientInfo& aClientInfo)
 {
   ClientHandleParent* actor = static_cast<ClientHandleParent*>(aActor);
   actor->Init(aClientInfo);
   return IPC_OK();
 }
 
 PClientManagerOpParent*
 ClientManagerParent::AllocPClientManagerOpParent(const ClientOpConstructorArgs& aArgs)
diff --git a/dom/clients/manager/ClientManagerParent.h b/dom/clients/manager/ClientManagerParent.h
--- a/dom/clients/manager/ClientManagerParent.h
+++ b/dom/clients/manager/ClientManagerParent.h
@@ -20,24 +20,24 @@ class ClientManagerParent final : public
   // PClientManagerParent interface
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   PClientHandleParent*
-  AllocPClientHandleParent(const ClientInfo& aClientInfo) override;
+  AllocPClientHandleParent(const IPCClientInfo& aClientInfo) override;
 
   bool
   DeallocPClientHandleParent(PClientHandleParent* aActor) override;
 
   mozilla::ipc::IPCResult
   RecvPClientHandleConstructor(PClientHandleParent* aActor,
-                               const ClientInfo& aClientInfo) override;
+                               const IPCClientInfo& aClientInfo) override;
 
   PClientManagerOpParent*
   AllocPClientManagerOpParent(const ClientOpConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientManagerOpParent(PClientManagerOpParent* aActor) override;
 
   mozilla::ipc::IPCResult
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -147,18 +147,18 @@ ClientManagerService::RemoveSource(Clien
 
 ClientSourceParent*
 ClientManagerService::FindSource(const nsID& aID, const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
     if (!source->IsFrozen() &&
-        source->Info().id() == aID &&
-        MatchPrincipalInfo(source->Info().principalInfo(), aPrincipalInfo)) {
+        source->Info().Id() == aID &&
+        MatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
       return source;
     }
   }
   return nullptr;
 }
 
 already_AddRefed<ClientOpPromise>
 ClientManagerService::Navigate(const ClientNavigateArgs& aArgs)
@@ -288,36 +288,36 @@ public:
 already_AddRefed<ClientOpPromise>
 ClientManagerService::MatchAll(const ClientMatchAllArgs& aArgs)
 {
   AssertIsOnBackgroundThread();
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
 
   const PrincipalInfo& principalInfo =
-    endpoint.type() == ClientEndPoint::TClientInfo
-      ? endpoint.get_ClientInfo().principalInfo()
+    endpoint.type() == ClientEndPoint::TIPCClientInfo
+      ? endpoint.get_IPCClientInfo().principalInfo()
       : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   RefPtr<PromiseListHolder> promiseList =
     new PromiseListHolder(mBackgroundThread);
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
       continue;
     }
 
-    if (!MatchPrincipalInfo(source->Info().principalInfo(), principalInfo)) {
+    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
       continue;
     }
 
     if (aArgs.type() != ClientType::All &&
-        source->Info().type() != aArgs.type()) {
+        source->Info().Type() != aArgs.type()) {
       continue;
     }
 
     if (!aArgs.includeUncontrolled()) {
       if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
         continue;
       }
 
@@ -337,18 +337,18 @@ ClientManagerService::MatchAll(const Cli
       }
     }
 
     if (!aArgs.includeReserved() && !source->ExecutionReady()) {
       continue;
     }
 
     promiseList->AddPromise(
-      source->StartOp(ClientGetInfoAndStateArgs(source->Info().id(),
-                                                source->Info().principalInfo())));
+      source->StartOp(ClientGetInfoAndStateArgs(source->Info().Id(),
+                                                source->Info().PrincipalInfo())));
   }
 
   // Maybe finish the promise now in case we didn't find any matching clients.
   promiseList->MaybeFinish();
 
   return promiseList->GetResultPromise();
 }
 
@@ -365,34 +365,34 @@ ClientManagerService::Claim(const Client
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
       continue;
     }
 
-    if (!MatchPrincipalInfo(source->Info().principalInfo(), principalInfo)) {
+    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
       continue;
     }
 
     const Maybe<ServiceWorkerDescriptor>& controller = source->GetController();
     if (controller.isSome() &&
         controller.ref().Scope() == serviceWorker.scope() &&
         controller.ref().Id() == serviceWorker.id()) {
       continue;
     }
 
     // TODO: This logic to determine if a service worker should control
     //       a particular client should be moved to the ServiceWorkerManager.
     //       This can't happen until the SWM is moved to the parent process,
     //       though.
     if (!source->ExecutionReady() ||
-        source->Info().type() == ClientType::Serviceworker ||
-        source->Info().url().Find(serviceWorker.scope()) != 0) {
+        source->Info().Type() == ClientType::Serviceworker ||
+        source->Info().URL().Find(serviceWorker.scope()) != 0) {
       continue;
     }
 
     promiseList->AddPromise(source->StartOp(aArgs));
   }
 
   // Maybe finish the promise now in case we didn't find any matching clients.
   promiseList->MaybeFinish();
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -83,18 +83,18 @@ public:
     MOZ_DIAGNOSTIC_ASSERT(innerWindow);
 
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
 
     Maybe<ClientState> clientState = innerWindow->GetClientState();
     MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
 
-    mPromise->Resolve(ClientInfoAndState(clientInfo.ref(), clientState.ref()),
-                      __func__);
+    mPromise->Resolve(ClientInfoAndState(clientInfo.ref().ToIPC(),
+                                         clientState.ref()), __func__);
 
     return NS_OK;
   }
 
   NS_IMETHOD
   OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
                    int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
                    int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
diff --git a/dom/clients/manager/ClientOpPromise.h b/dom/clients/manager/ClientOpPromise.h
--- a/dom/clients/manager/ClientOpPromise.h
+++ b/dom/clients/manager/ClientOpPromise.h
@@ -2,21 +2,23 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientOpPromise_h
 #define _mozilla_dom_ClientOpPromise_h
 
 #include "mozilla/MozPromise.h"
-#include "mozilla/dom/ClientIPCTypes.h"
 
 namespace mozilla {
 namespace dom {
 
+class ClientOpResult;
+class ClientState;
+
 typedef MozPromise<ClientOpResult, nsresult, false> ClientOpPromise;
 
 typedef MozPromise<ClientState, nsresult, false> ClientStatePromise;
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientOpPromise_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -39,18 +39,18 @@ ClientSource::Shutdown()
   mManager->ForgetSource(this);
   mManager = nullptr;
 }
 
 void
 ClientSource::ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
 {
   // TODO: delivered queued messages
-  mClientInfo.url() = aArgs.url();
-  mClientInfo.frameType() = aArgs.frameType();
+  mClientInfo.SetURL(aArgs.url());
+  mClientInfo.SetFrameType(aArgs.frameType());
   MaybeExecute([aArgs](PClientSourceChild* aActor) {
     aActor->SendExecutionReady(aArgs);
   });
 }
 
 nsresult
 ClientSource::SnapshotWindowState(ClientWindowState* aStateOut)
 {
@@ -82,34 +82,35 @@ ClientSource::SnapshotWindowState(Client
 
   return NS_OK;
 }
 
 ClientSource::ClientSource(ClientManager* aManager,
                            const ClientSourceConstructorArgs& aArgs)
   : mManager(aManager)
   , mOwner(void_t())
-  , mArgs(aArgs)
-  , mClientInfo(mArgs.id(), mArgs.type(), mArgs.principalInfo(), mArgs.creationTime(),
-                EmptyCString(), FrameType::None)
+  , mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
 {
   MOZ_ASSERT(mManager);
 }
 
 void
 ClientSource::Activate(PClientManagerChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   MOZ_ASSERT(!GetActor());
 
   if (IsShutdown()) {
     return;
   }
 
-  PClientSourceChild* actor = aActor->SendPClientSourceConstructor(mArgs);
+  ClientSourceConstructorArgs args(mClientInfo.Id(), mClientInfo.Type(),
+                                   mClientInfo.PrincipalInfo(),
+                                   mClientInfo.CreationTime());
+  PClientSourceChild* actor = aActor->SendPClientSourceConstructor(args);
   if (!actor) {
     Shutdown();
     return;
   }
 
   ActivateThing(static_cast<ClientSourceChild*>(actor));
   MaybeExecuteTaskList();
 }
@@ -291,17 +292,17 @@ ClientSource::GetController() const
 
 already_AddRefed<ClientOpPromise>
 ClientSource::Focus(const ClientFocusArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   RefPtr<ClientOpPromise> ref;
 
-  if (mArgs.type() != ClientType::Window) {
+  if (mClientInfo.Type() != ClientType::Window) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
                                            __func__);
     return ref.forget();
   }
 
   nsPIDOMWindowInner* window = GetInnerWindow();
   if (!window) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
@@ -332,32 +333,32 @@ ClientSource::Focus(const ClientFocusArg
 already_AddRefed<ClientOpPromise>
 ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
-    endpoint.type() == ClientEndPoint::TClientInfo
-      ? endpoint.get_ClientInfo().principalInfo()
+    endpoint.type() == ClientEndPoint::TIPCClientInfo
+      ? endpoint.get_IPCClientInfo().principalInfo()
       : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   // TODO: this should probably not require strict spec matching
-  if (false && !(mClientInfo.principalInfo() == principalInfo)) {
+  if (false && !(mClientInfo.PrincipalInfo() == principalInfo)) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
   StructuredCloneData clonedData;
   clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
 
   RefPtr<ServiceWorkerContainer> target;
   nsCOMPtr<nsIGlobalObject> globalObject;
-  if (mClientInfo.type() == ClientType::Window) {
+  if (mClientInfo.Type() == ClientType::Window) {
     MOZ_ASSERT(NS_IsMainThread());
     nsPIDOMWindowInner* window = GetInnerWindow();
     if (window) {
       globalObject = nsGlobalWindow::Cast(window);
       RefPtr<Navigator> navigator =
         static_cast<Navigator*>(window->GetNavigator());
       if (navigator) {
         target = navigator->ServiceWorker();
@@ -537,30 +538,30 @@ ClientSource::GetInfoAndState(const Clie
 
   ClientState state;
   nsresult rv = SnapshotState(&state);
   if (NS_FAILED(rv)) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
-  ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo, state),
-                                          __func__);
+  ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo.ToIPC(),
+                                                             state), __func__);
   return ref.forget();
 }
 
 nsresult
 ClientSource::SnapshotState(ClientState* aStateOut)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   MOZ_DIAGNOSTIC_ASSERT(aStateOut);
 
   // TODO: Handle state on reserved client where no window/workerprivate yet.
 
-  if (mArgs.type() == ClientType::Window) {
+  if (mClientInfo.Type() == ClientType::Window) {
     *aStateOut = ClientWindowState();
     return SnapshotWindowState(&aStateOut->get_ClientWindowState());
   }
 
   *aStateOut = ClientWorkerState();
   return NS_OK;
 }
 
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -1,30 +1,39 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientSource_h
 #define _mozilla_dom_ClientSource_h
 
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/Variant.h"
 #include "ClientOpPromise.h"
 
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
+class ClientClaimArgs;
+class ClientControlledArgs;
+class ClientFocusArgs;
+class ClientGetInfoAndStateArgs;
+class ClientGetStateArgs;
 class ClientManager;
+class ClientPostMessageArgs;
 class ClientSourceChild;
+class ClientSourceConstructorArgs;
 class ClientSourceExecutionReadyArgs;
+class ClientState;
+class ClientWindowState;
 class PClientManagerChild;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
 class ClientSource final : public ClientThing<ClientSourceChild>
 {
@@ -34,17 +43,16 @@ class ClientSource final : public Client
   NS_DECL_OWNINGTHREAD
 
   RefPtr<ClientManager> mManager;
 
   Variant<void_t,
           RefPtr<nsPIDOMWindowInner>,
           mozilla::dom::workers::WorkerPrivate*> mOwner;
 
-  const ClientSourceConstructorArgs mArgs;
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
   void
   Shutdown();
 
   void
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
diff --git a/dom/clients/manager/ClientSourceChild.cpp b/dom/clients/manager/ClientSourceChild.cpp
--- a/dom/clients/manager/ClientSourceChild.cpp
+++ b/dom/clients/manager/ClientSourceChild.cpp
@@ -1,22 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceChild.h"
 
+#include "ClientSource.h"
 #include "ClientSourceOpChild.h"
 #include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::IPCResult;
+
 void
 ClientSourceChild::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mSource) {
     mSource->RevokeActor(this);
     MOZ_ASSERT(!mSource);
   }
 }
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
--- a/dom/clients/manager/ClientSourceParent.cpp
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -32,34 +32,33 @@ ClientSourceParent::RecvTeardown()
   Unused << Send__delete__(this);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ClientSourceParent::RecvRedirect(const ClientSourceConstructorArgs& aArgs)
 {
   mService->RemoveSource(this);
-  mClientInfo.id() = aArgs.id();
-  mClientInfo.type() = aArgs.type();
-  mClientInfo.principalInfo() = aArgs.principalInfo();
+  mClientInfo = ClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(),
+                           mClientInfo.CreationTime());
   mService->AddSource(this);
   return IPC_OK();
 }
 
 IPCResult
 ClientSourceParent::RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
 {
   // TODO: Validate this against nsIURI and nsIPrincipal
   // TODO: mark execution ready
-  mClientInfo.url() = aArgs.url();
-  mClientInfo.frameType() = aArgs.frameType();
+  mClientInfo.SetURL(aArgs.url());
+  mClientInfo.SetFrameType(aArgs.frameType());
   mExecutionReady = true;
 
   for (ClientHandleParent* handle : mHandleList) {
-    Unused << handle->SendExecutionReady(mClientInfo);
+    Unused << handle->SendExecutionReady(mClientInfo.ToIPC());
   }
 
   return IPC_OK();
 };
 
 IPCResult
 ClientSourceParent::RecvFreeze()
 {
@@ -105,18 +104,17 @@ ClientSourceParent::AllocPClientSourceOp
 bool
 ClientSourceParent::DeallocPClientSourceOpParent(PClientSourceOpParent* aActor)
 {
   delete aActor;
   return true;
 }
 
 ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
-  : mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime(),
-                EmptyCString(), FrameType::None)
+  : mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
   , mService(ClientManagerService::GetOrCreateInstance())
   , mExecutionReady(false)
   , mFrozen(false)
 {
   mService->AddSource(this);
 }
 
 ClientSourceParent::~ClientSourceParent()
diff --git a/dom/clients/manager/PClientHandle.ipdl b/dom/clients/manager/PClientHandle.ipdl
--- a/dom/clients/manager/PClientHandle.ipdl
+++ b/dom/clients/manager/PClientHandle.ipdl
@@ -21,15 +21,15 @@ protocol PClientHandle
   manages PClientHandleOp;
 
 parent:
   async Teardown();
 
   async PClientHandleOp(ClientOpConstructorArgs aArgs);
 
 child:
-  async ExecutionReady(ClientInfo aClientInfo);
+  async ExecutionReady(IPCClientInfo aClientInfo);
 
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/PClientManager.ipdl b/dom/clients/manager/PClientManager.ipdl
--- a/dom/clients/manager/PClientManager.ipdl
+++ b/dom/clients/manager/PClientManager.ipdl
@@ -23,17 +23,17 @@ sync protocol PClientManager
   manages PClientHandle;
   manages PClientManagerOp;
   manages PClientNavigateOp;
   manages PClientSource;
 
 parent:
   async Teardown();
 
-  async PClientHandle(ClientInfo aClientInfo);
+  async PClientHandle(IPCClientInfo aClientInfo);
   async PClientManagerOp(ClientOpConstructorArgs aArgs);
   async PClientSource(ClientSourceConstructorArgs aArgs);
 
 child:
   async PClientNavigateOp(ClientNavigateOpConstructorArgs aArgs);
 
   async __delete__();
 };
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -1,31 +1,33 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
   'ClientHandle.h',
+  'ClientInfo.h',
   'ClientIPCUtils.h',
   'ClientManager.h',
   'ClientManagerActors.h',
   'ClientOpPromise.h',
   'ClientSource.h',
   'ClientThing.h',
   'ReservedClientHelper.h',
 ]
 
 UNIFIED_SOURCES += [
   'ClientHandle.cpp',
   'ClientHandleChild.cpp',
   'ClientHandleOpChild.cpp',
   'ClientHandleOpParent.cpp',
   'ClientHandleParent.cpp',
+  'ClientInfo.cpp',
   'ClientManager.cpp',
   'ClientManagerActors.cpp',
   'ClientManagerChild.cpp',
   'ClientManagerOpChild.cpp',
   'ClientManagerOpParent.cpp',
   'ClientManagerParent.cpp',
   'ClientManagerService.cpp',
   'ClientNavigateOpChild.cpp',
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -46,17 +46,17 @@
 #include "mozilla/LoadContext.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Cache.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/dom/ChannelInfo.h"
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/InternalResponse.h"
 #include "mozilla/dom/nsCSPService.h"
 #include "mozilla/dom/nsCSPUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
diff --git a/dom/workers/ServiceWorker.cpp b/dom/workers/ServiceWorker.cpp
--- a/dom/workers/ServiceWorker.cpp
+++ b/dom/workers/ServiceWorker.cpp
@@ -8,16 +8,17 @@
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "WorkerPrivate.h"
 
 #include "mozilla/Preferences.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
@@ -98,15 +99,15 @@ ServiceWorker::PostMessage(JSContext* aC
   Maybe<ClientState> clientState = window->GetClientState();
   if (clientInfo.isNothing() || clientState.isNothing()) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
   ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
   aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
-                                        ClientInfoAndState(clientInfo.ref(),
+                                        ClientInfoAndState(clientInfo.ref().ToIPC(),
                                                            clientState.ref()));
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2688,17 +2688,17 @@ public:
     }
 
     nsString clientId;
     nsCOMPtr<nsILoadInfo> loadInfo = channel->GetLoadInfo();
     if (loadInfo) {
       Maybe<ClientInfo> clientInfo = loadInfo->GetClientInfo();
       if (clientInfo.isSome()) {
         char buf[NSID_LENGTH];
-        clientInfo.ref().id().ToProvidedString(buf);
+        clientInfo.ref().Id().ToProvidedString(buf);
         CopyUTF8toUTF16(nsDependentCString(buf), clientId);
       }
     }
 
     rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup, clientId,
                                                mIsReload);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       HandleError();
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/LoadInfo.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozIThirdPartyUtil.h"
 #include "nsFrameLoader.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIDocShell.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -10,17 +10,17 @@
 #include "nsIContentPolicy.h"
 #include "nsILoadInfo.h"
 #include "nsIPrincipal.h"
 #include "nsIWeakReferenceUtils.h" // for nsWeakPtr
 #include "nsIURI.h"
 #include "nsTArray.h"
 
 #include "mozilla/BasePrincipal.h"
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 
 class nsINode;
 class nsPIDOMWindowOuter;
 
 namespace mozilla {
 
 namespace dom {
