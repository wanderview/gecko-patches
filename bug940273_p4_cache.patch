# HG changeset patch
# Parent 670f4b7e669ac340d415fb7e99c6a92ea0aef7f5
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 Initial implementation of Service Worker Cache.

diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -164,16 +164,24 @@ DOMInterfaces = {
     'nativeType':
       'mozilla::dom::bluetooth::BluetoothPairingListener',
 },
 
 'BoxObject': {
     'resultNotAddRefed': ['element'],
 },
 
+'Cache': {
+    'nativeType': 'mozilla::dom::cache::Cache',
+},
+
+'CacheStorage': {
+    'nativeType': 'mozilla::dom::cache::CacheStorage',
+},
+
 'CameraCapabilities': {
     'nativeType': 'mozilla::dom::CameraCapabilities',
     'headerFile': 'DOMCameraCapabilities.h'
 },
 
 'CameraControl': {
     'nativeType': 'mozilla::nsDOMCameraControl',
     'headerFile': 'DOMCameraControl.h',
diff --git a/dom/bindings/Errors.msg b/dom/bindings/Errors.msg
--- a/dom/bindings/Errors.msg
+++ b/dom/bindings/Errors.msg
@@ -66,8 +66,9 @@ MSG_DEF(MSG_REQUEST_BODY_CONSUMED_ERROR,
 MSG_DEF(MSG_RESPONSE_INVALID_STATUSTEXT_ERROR, 0, JSEXN_TYPEERR, "Response statusText may not contain newline or carriage return.")
 MSG_DEF(MSG_FETCH_FAILED, 0, JSEXN_TYPEERR, "NetworkError when attempting to fetch resource.")
 MSG_DEF(MSG_NO_BODY_ALLOWED_FOR_GET_AND_HEAD, 0, JSEXN_TYPEERR, "HEAD or GET Request cannot have a body.")
 MSG_DEF(MSG_DEFINE_NON_CONFIGURABLE_PROP_ON_WINDOW, 0, JSEXN_TYPEERR, "Not allowed to define a non-configurable property on the WindowProxy object")
 MSG_DEF(MSG_INVALID_ZOOMANDPAN_VALUE_ERROR, 0, JSEXN_RANGEERR, "Invalid zoom and pan value.")
 MSG_DEF(MSG_INVALID_TRANSFORM_ANGLE_ERROR, 0, JSEXN_RANGEERR, "Invalid transform angle.")
 MSG_DEF(MSG_INVALID_RESPONSE_STATUSCODE_ERROR, 0, JSEXN_RANGEERR, "Invalid response status code.")
 MSG_DEF(MSG_INVALID_REDIRECT_STATUSCODE_ERROR, 0, JSEXN_RANGEERR, "Invalid redirect status code.")
+MSG_DEF(MSG_INVALID_URL_SCHEME, 2, "{0} URL {1} must be either http:// or https://.")
diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.cpp
@@ -0,0 +1,18 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Action.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action);
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action::Resolver);
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Action_h
+#define mozilla_dom_cache_Action_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsISupportsImpl.h"
+
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action : public nsISupports
+{
+protected:
+  virtual ~Action() { }
+
+public:
+  class Resolver : public nsISupports
+  {
+  protected:
+    virtual ~Resolver() { }
+
+  public:
+
+    // Note: Action must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on Action's target thread.
+    virtual void Resolve(nsresult aRv)=0;
+
+    NS_DECL_THREADSAFE_ISUPPORTS
+  };
+
+  // Execute operations on target thread. Once complete call
+  // Resolver::Resolve().  This can be done sync or async.
+  // Note: Action should hold Resolver ref until its ready to call Resolve().
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)=0;
+
+  // Called on target thread if the Action is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: Action must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread.  If this Action will operate on the
+  // given cache ID then override this to return true.
+  virtual bool MatchesCacheId(CacheId aCacheId) { return false; }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Cache.cpp
@@ -0,0 +1,550 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Cache.h"
+
+#include "mozilla/dom/Headers.h"
+#include "mozilla/dom/InternalResponse.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/cache/CacheChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "mozilla/ErrorResult.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/unused.h"
+#include "nsIGlobalObject.h"
+#include "nsNetUtil.h"
+
+namespace {
+
+using mozilla::ErrorResult;
+using mozilla::dom::MSG_INVALID_REQUEST_METHOD;
+using mozilla::dom::OwningRequestOrUSVString;
+using mozilla::dom::Request;
+using mozilla::dom::RequestOrUSVString;
+
+static bool
+IsValidPutRequestMethod(const Request& aRequest, ErrorResult& aRv)
+{
+  nsAutoCString method;
+  aRequest.GetMethod(method);
+  bool valid = method.LowerCaseEqualsLiteral("get");
+  if (!valid) {
+    NS_ConvertUTF8toUTF16 label(method);
+    aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
+  }
+  return valid;
+}
+
+static bool
+IsValidPutRequestMethod(const RequestOrUSVString& aRequest,
+                        ErrorResult& aRv)
+{
+  if (!aRequest.IsRequest()) {
+    return true;
+  }
+  return IsValidPutRequestMethod(aRequest.GetAsRequest(), aRv);
+}
+
+static bool
+IsValidPutRequestMethod(const OwningRequestOrUSVString& aRequest,
+                        ErrorResult& aRv)
+{
+  if (!aRequest.IsRequest()) {
+    return true;
+  }
+  return IsValidPutRequestMethod(*aRequest.GetAsRequest().get(), aRv);
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ErrorResult;
+using mozilla::unused;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::Cache);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::Cache);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mGlobal)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Cache)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Cache::Cache(nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+             PCacheChild* aActor)
+  : mGlobal(aGlobal)
+  , mOrigin(aOrigin)
+  , mActor(static_cast<CacheChild*>(aActor))
+{
+  MOZ_ASSERT(mActor);
+  mActor->SetListener(*this);
+}
+
+already_AddRefed<Promise>
+Cache::Match(const RequestOrUSVString& aRequest,
+             const QueryParams& aParams, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  PCacheRequest request;
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  PCacheQueryParams params;
+  ToPCacheQueryParams(params, aParams);
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  unused << mActor->SendMatch(requestId, request, params);
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::MatchAll(const Optional<RequestOrUSVString>& aRequest,
+                const QueryParams& aParams, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  PCacheRequestOrVoid request;
+  ToPCacheRequestOrVoid(request, aRequest, IgnoreBody, PassThroughReferrer,
+                        aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  PCacheQueryParams params;
+  ToPCacheQueryParams(params, aParams);
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  unused << mActor->SendMatchAll(requestId, request, params);
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::Add(const RequestOrUSVString& aRequest, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  if (!IsValidPutRequestMethod(aRequest, aRv)) {
+    return nullptr;
+  }
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+
+  nsTArray<PCacheRequest> requests(1);
+  PCacheRequest* request = requests.AppendElement();
+  ToPCacheRequest(*request, aRequest, ReadBody, ExpandReferrer, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  unused << mActor->SendAddAll(requestId, requests);
+
+  CleanupChildFds(request->body());
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::AddAll(const Sequence<OwningRequestOrUSVString>& aRequests,
+              ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  // Be careful not to early exist after this point to avoid leaking
+  // file descriptor resources from stream serialization.
+
+  nsTArray<PCacheRequest> requests;
+  for(uint32_t i = 0; i < aRequests.Length(); ++i) {
+    if (!IsValidPutRequestMethod(aRequests[i], aRv)) {
+      break;
+    }
+
+    PCacheRequest* request = requests.AppendElement();
+    ToPCacheRequest(*request, aRequests[i], ReadBody, ExpandReferrer, aRv);
+    if (aRv.Failed()) {
+      break;
+    }
+  }
+
+  if (!aRv.Failed()) {
+    RequestId requestId = AddRequestPromise(promise, aRv);
+    unused << mActor->SendAddAll(requestId, requests);
+  }
+
+  for (uint32_t i = 0; i < requests.Length(); ++i) {
+    CleanupChildFds(requests[i].body());
+  }
+
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::Put(const RequestOrUSVString& aRequest, Response& aResponse,
+           ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  if (!IsValidPutRequestMethod(aRequest, aRv)) {
+    return nullptr;
+  }
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  CacheRequestResponse put;
+
+  // Be careful not to early exist after this point to avoid leaking
+  // file descriptor resources from stream serialization.
+
+  ToPCacheRequest(put.request(), aRequest, ReadBody, PassThroughReferrer, aRv);
+
+  put.response().body() = void_t();
+  if (!aRv.Failed()) {
+    ToPCacheResponse(put.response(), aResponse, aRv);
+  }
+
+  if (!aRv.Failed()) {
+    RequestId requestId = AddRequestPromise(promise, aRv);
+
+    unused << mActor->SendPut(requestId, put);
+  }
+
+  CleanupChildFds(put.request().body());
+  CleanupChildFds(put.response().body());
+
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::Delete(const RequestOrUSVString& aRequest,
+              const QueryParams& aParams, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  PCacheRequest request;
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  PCacheQueryParams params;
+  ToPCacheQueryParams(params, aParams);
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  unused << mActor->SendDelete(requestId, request, params);
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+Cache::Keys(const Optional<RequestOrUSVString>& aRequest,
+            const QueryParams& aParams, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mActor);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  PCacheRequestOrVoid request;
+  ToPCacheRequestOrVoid(request, aRequest, IgnoreBody, PassThroughReferrer,
+                        aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  PCacheQueryParams params;
+  ToPCacheQueryParams(params, aParams);
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  unused << mActor->SendKeys(requestId, request, params);
+
+  return promise.forget();
+}
+
+// static
+bool
+Cache::PrefEnabled(JSContext* aCx, JSObject* aObj)
+{
+  using mozilla::dom::workers::WorkerPrivate;
+  using mozilla::dom::workers::GetWorkerPrivateFromContext;
+
+  // TODO: return false if principal is invalid or private browsing (bug 1112134)
+
+  // If we're on the main thread, then check the pref directly.
+  if (NS_IsMainThread()) {
+    bool enabled;
+    nsresult rv = Preferences::GetBool("dom.caches.enabled", &enabled);
+    if (NS_FAILED(rv)) {
+      return false;
+    }
+    return enabled;
+  }
+
+  // Otherwise check the pref via the work private helper
+  WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
+  if (!workerPrivate) {
+    return false;
+  }
+
+  return workerPrivate->DOMCachesEnabled();
+}
+
+nsISupports*
+Cache::GetParentObject() const
+{
+  return mGlobal;
+}
+
+JSObject*
+Cache::WrapObject(JSContext* aContext)
+{
+  return CacheBinding::Wrap(aContext, this);
+}
+
+void
+Cache::ActorDestroy(mozilla::ipc::IProtocol& aActor)
+{
+  MOZ_ASSERT(mActor);
+  MOZ_ASSERT(mActor == &aActor);
+  mActor->ClearListener();
+  mActor = nullptr;
+}
+
+void
+Cache::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                         const PCacheResponseOrVoid& aResponse)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
+    promise->MaybeResolve(JS::UndefinedHandleValue);
+    return;
+  }
+
+  nsRefPtr<Response> response = ToResponse(aResponse);
+  promise->MaybeResolve(response);
+}
+
+void
+Cache::RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
+                            const nsTArray<PCacheResponse>& aResponses)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  nsTArray<nsRefPtr<Response>> responses;
+  for (uint32_t i = 0; i < aResponses.Length(); ++i) {
+    nsRefPtr<Response> response = ToResponse(aResponses[i]);
+    responses.AppendElement(response.forget());
+  }
+  promise->MaybeResolve(responses);
+}
+
+void
+Cache::RecvAddAllResponse(RequestId aRequestId, nsresult aRv)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  promise->MaybeResolve(JS::UndefinedHandleValue);
+}
+
+void
+Cache::RecvPutResponse(RequestId aRequestId, nsresult aRv)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  promise->MaybeResolve(JS::UndefinedHandleValue);
+}
+
+void
+Cache::RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  promise->MaybeResolve(aSuccess);
+}
+
+void
+Cache::RecvKeysResponse(RequestId aRequestId, nsresult aRv,
+                        const nsTArray<PCacheRequest>& aRequests)
+{
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  nsTArray<nsRefPtr<Request>> requests;
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    nsRefPtr<Request> request = ToRequest(aRequests[i]);
+    requests.AppendElement(request.forget());
+  }
+  promise->MaybeResolve(requests);
+}
+
+nsIGlobalObject*
+Cache::GetGlobalObject() const
+{
+  return mGlobal;
+}
+
+const nsACString&
+Cache::Origin() const
+{
+  return mOrigin;
+}
+
+#ifdef DEBUG
+void
+Cache::AssertOwningThread() const
+{
+  NS_ASSERT_OWNINGTHREAD(Cache);
+}
+#endif
+
+Cache::~Cache()
+{
+  if (mActor) {
+    mActor->ClearListener();
+    PCacheChild::Send__delete__(mActor);
+    // The actor will be deleted by the IPC manager
+    mActor = nullptr;
+  }
+}
+
+RequestId
+Cache::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
+{
+  MOZ_ASSERT(aPromise);
+
+  nsRefPtr<Promise>* ref = mRequestPromises.AppendElement();
+  *ref = aPromise;
+
+  // (Ab)use the promise pointer as our request ID.  This is a fast, thread-safe
+  // way to get a unique ID for the promise to be resolved later.
+  return reinterpret_cast<RequestId>(aPromise);
+}
+
+already_AddRefed<Promise>
+Cache::RemoveRequestPromise(RequestId aRequestId)
+{
+  MOZ_ASSERT(aRequestId != INVALID_REQUEST_ID);
+
+  for (uint32_t i = 0; i < mRequestPromises.Length(); ++i) {
+    nsRefPtr<Promise>& promise = mRequestPromises.ElementAt(i);
+    // To be safe, only cast promise pointers to our integer RequestId
+    // type and never cast an integer to a pointer.
+    if (aRequestId == reinterpret_cast<RequestId>(promise.get())) {
+      nsRefPtr<Promise> ref;
+      ref.swap(promise);
+      mRequestPromises.RemoveElementAt(i);
+      return ref.forget();
+    }
+  }
+  return nullptr;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Cache.h
@@ -0,0 +1,127 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Cache_h
+#define mozilla_dom_cache_Cache_h
+
+#include "mozilla/dom/cache/CacheChildListener.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class OwningRequestOrUSVString;
+class Promise;
+struct QueryParams;
+class RequestOrUSVString;
+class Response;
+template<typename T> class Optional;
+template<typename T> class Sequence;
+
+namespace cache {
+
+class CacheChild;
+class PCacheChild;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+
+class Cache MOZ_FINAL : public nsISupports
+                      , public nsWrapperCache
+                      , public CacheChildListener
+                      , public TypeUtils
+{
+public:
+  Cache(nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+        PCacheChild* aActor);
+
+  // webidl interface methods
+  already_AddRefed<Promise>
+  Match(const RequestOrUSVString& aRequest, const QueryParams& aParams,
+        ErrorResult& aRv);
+  already_AddRefed<Promise>
+  MatchAll(const Optional<RequestOrUSVString>& aRequest,
+           const QueryParams& aParams, ErrorResult& aRv);
+  already_AddRefed<Promise>
+  Add(const RequestOrUSVString& aRequest, ErrorResult& aRv);
+  already_AddRefed<Promise>
+  AddAll(const Sequence<OwningRequestOrUSVString>& aRequests,
+         ErrorResult& aRv);
+  already_AddRefed<Promise>
+  Put(const RequestOrUSVString& aRequest, Response& aResponse,
+      ErrorResult& aRv);
+  already_AddRefed<Promise>
+  Delete(const RequestOrUSVString& aRequest, const QueryParams& aParams,
+         ErrorResult& aRv);
+  already_AddRefed<Promise>
+  Keys(const Optional<RequestOrUSVString>& aRequest,
+       const QueryParams& aParams, ErrorResult& aRv);
+
+  // binding methods
+  static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
+
+  virtual nsISupports* GetParentObject() const;
+  virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
+
+  // CacheChildListener methods
+  virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
+  virtual void
+  RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+  virtual void
+  RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
+                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+  virtual void
+  RecvAddAllResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+  virtual void
+  RecvPutResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+
+  virtual void
+  RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
+                     bool aSuccess) MOZ_OVERRIDE;
+  virtual void
+  RecvKeysResponse(RequestId aRequestId, nsresult aRv,
+                   const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
+
+  // TypeUtils methods
+  virtual nsIGlobalObject*
+  GetGlobalObject() const MOZ_OVERRIDE;
+  const nsACString& Origin() const MOZ_OVERRIDE;
+
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
+private:
+  virtual ~Cache();
+
+  RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
+  already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
+
+private:
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+  const nsCString mOrigin;
+  CacheChild* mActor;
+  nsTArray<nsRefPtr<Promise>> mRequestPromises;
+
+public:
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Cache)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_Cache_h
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheChild.cpp
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheChild.h"
+
+#include "mozilla/dom/cache/CacheChildListener.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+CacheChild::CacheChild()
+  : mListener(nullptr)
+{
+}
+
+CacheChild::~CacheChild()
+{
+  MOZ_ASSERT(!mListener);
+}
+
+void
+CacheChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  // If the listener is destroyed before we are, then they will clear
+  // their registration.
+  if (mListener) {
+    mListener->ActorDestroy(*this);
+  }
+}
+
+void
+CacheChild::SetListener(CacheChildListener& aListener)
+{
+  MOZ_ASSERT(!mListener);
+  mListener = &aListener;
+}
+
+void
+CacheChild::ClearListener()
+{
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+bool
+CacheChild::RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
+                              const PCacheResponseOrVoid& aResponse)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvMatchResponse(requestId, aRv, aResponse);
+  return true;
+}
+
+bool
+CacheChild::RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
+                                 const nsTArray<PCacheResponse>& responses)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvMatchAllResponse(requestId, aRv, responses);
+  return true;
+}
+
+bool
+CacheChild::RecvAddAllResponse(const RequestId& requestId, const nsresult& aRv)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvAddAllResponse(requestId, aRv);
+  return true;
+}
+
+bool
+CacheChild::RecvPutResponse(const RequestId& aRequestId, const nsresult& aRv)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvPutResponse(aRequestId, aRv);
+  return true;
+}
+
+bool
+CacheChild::RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
+                               const bool& result)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvDeleteResponse(requestId, aRv, result);
+  return true;
+}
+
+bool
+CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
+                             const nsTArray<PCacheRequest>& requests)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvKeysResponse(requestId, aRv, requests);
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namesapce mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheChild.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheChild_h
+#define mozilla_dom_cache_CacheChild_h
+
+#include "mozilla/dom/cache/PCacheChild.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheChildListener;
+
+class CacheChild MOZ_FINAL : public PCacheChild
+{
+  CacheChildListener* mListener;
+
+public:
+  CacheChild();
+  virtual ~CacheChild();
+
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+
+  void SetListener(CacheChildListener& aListener);
+  void ClearListener();
+
+  // PCacheChild methods
+  virtual bool
+  RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
+                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+  virtual bool
+  RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
+                       const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
+  virtual bool
+  RecvAddAllResponse(const RequestId& requestId,
+                     const nsresult& aRv) MOZ_OVERRIDE;
+  virtual bool
+  RecvPutResponse(const RequestId& aRequestId,
+                  const nsresult& aRv) MOZ_OVERRIDE;
+  virtual bool
+  RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
+                     const bool& result) MOZ_OVERRIDE;
+  virtual bool
+  RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
+                   const nsTArray<PCacheRequest>& requests) MOZ_OVERRIDE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheChild_h
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheChildListener.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheChildListener_h
+#define mozilla_dom_cache_CacheChildListener_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+
+namespace ipc {
+  class IProtocol;
+}
+
+namespace dom {
+namespace cache {
+
+class PCacheRequest;
+class PCacheResponse;
+class PCacheResponseOrVoid;
+class PCacheStreamControlChild;
+
+class CacheChildListener
+{
+public:
+  virtual ~CacheChildListener() { }
+  virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
+
+  virtual void
+  RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                    const PCacheResponseOrVoid& aResponse)=0;
+  virtual void
+  RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
+                       const nsTArray<PCacheResponse>& aResponses)=0;
+  virtual void
+  RecvAddAllResponse(RequestId aRequestId, nsresult aRv)=0;
+
+  virtual void
+  RecvPutResponse(RequestId aRequestId, nsresult aRv)=0;
+
+  virtual void
+  RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
+                     bool aSuccess)=0;
+  virtual void
+  RecvKeysResponse(RequestId aRequestId, nsresult aRv,
+                   const nsTArray<PCacheRequest>& aRequests)=0;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_CacheChildListener_h
diff --git a/dom/cache/CacheInitData.ipdlh b/dom/cache/CacheInitData.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheInitData.ipdlh
@@ -0,0 +1,24 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+
+using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// Data needed to initialize a CacheStorage or Cache backend.  Don't put
+// this with the other types in PCacheTypes.ipdlh since we want to import
+// it into PBackground.ipdl.
+struct CacheInitData
+{
+  Namespace namespaceEnum;
+  PrincipalInfo principalInfo;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheParent.cpp
@@ -0,0 +1,310 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheParent.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "nsCOMPtr.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::void_t;
+using mozilla::ipc::FileDescriptorSetParent;
+using mozilla::ipc::PFileDescriptorSetParent;
+
+CacheParent::CacheParent(cache::Manager* aManager, CacheId aCacheId)
+  : mManager(aManager)
+  , mCacheId(aCacheId)
+{
+  MOZ_ASSERT(mManager);
+  mManager->AddRefCacheId(mCacheId);
+}
+
+CacheParent::~CacheParent()
+{
+  MOZ_ASSERT(!mManager);
+  MOZ_ASSERT(mFetchPutList.IsEmpty());
+}
+
+void
+CacheParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  MOZ_ASSERT(mManager);
+  for (uint32_t i = 0; i < mFetchPutList.Length(); ++i) {
+    mFetchPutList[i]->ClearListener();
+  }
+  mFetchPutList.Clear();
+  mManager->RemoveListener(this);
+  mManager->ReleaseCacheId(mCacheId);
+  mManager = nullptr;
+}
+
+bool
+CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
+                       const PCacheQueryParams& aParams)
+{
+  MOZ_ASSERT(mManager);
+  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest,
+                       aParams);
+  return true;
+}
+
+bool
+CacheParent::RecvMatchAll(const RequestId& aRequestId,
+                          const PCacheRequestOrVoid& aRequest,
+                          const PCacheQueryParams& aParams)
+{
+  MOZ_ASSERT(mManager);
+  mManager->CacheMatchAll(this, aRequestId, mCacheId, aRequest, aParams);
+  return true;
+}
+
+bool
+CacheParent::RecvAddAll(const RequestId& aRequestId,
+                        const nsTArray<PCacheRequest>& aRequests)
+{
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreams;
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    requestStreams.AppendElement(DeserializeCacheStream(aRequests[i].body()));
+  }
+
+  nsRefPtr<FetchPut> fetchPut;
+  nsresult rv = FetchPut::Create(this, mManager, aRequestId, mCacheId,
+                                 aRequests, requestStreams,
+                                 getter_AddRefs(fetchPut));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendAddAllResponse(aRequestId, rv);
+    return true;
+  }
+
+  mFetchPutList.AppendElement(fetchPut.forget());
+
+  return true;
+}
+
+bool
+CacheParent::RecvPut(const RequestId& aRequestId,
+                     const CacheRequestResponse& aPut)
+{
+  MOZ_ASSERT(mManager);
+
+  nsTArray<CacheRequestResponse> putList(1);
+  putList.AppendElement(aPut);
+
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreamList(1);
+  nsTArray<nsCOMPtr<nsIInputStream>> responseStreamList(1);
+
+  requestStreamList.AppendElement(
+    DeserializeCacheStream(aPut.request().body()));
+  responseStreamList.AppendElement(
+    DeserializeCacheStream(aPut.response().body()));
+
+
+  mManager->CachePutAll(this, aRequestId, mCacheId, putList, requestStreamList,
+                        responseStreamList);
+
+  return true;
+}
+
+bool
+CacheParent::RecvDelete(const RequestId& aRequestId,
+                        const PCacheRequest& aRequest,
+                        const PCacheQueryParams& aParams)
+{
+  MOZ_ASSERT(mManager);
+  mManager->CacheDelete(this, aRequestId, mCacheId, aRequest, aParams);
+  return true;
+}
+
+bool
+CacheParent::RecvKeys(const RequestId& aRequestId,
+                      const PCacheRequestOrVoid& aRequest,
+                      const PCacheQueryParams& aParams)
+{
+  MOZ_ASSERT(mManager);
+  mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
+  return true;
+}
+
+void
+CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                          const SavedResponse* aSavedResponse,
+                          Manager::StreamList* aStreamList)
+{
+  PCacheResponseOrVoid responseOrVoid;
+
+  // no match
+  if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
+    responseOrVoid = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // match without body data to stream
+  if (!aSavedResponse->mHasBodyId) {
+    responseOrVoid = aSavedResponse->mValue;
+    responseOrVoid.get_PCacheResponse().body() = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  PCacheReadStream readStream;
+  SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                      &readStream);
+
+  responseOrVoid = aSavedResponse->mValue;
+  responseOrVoid.get_PCacheResponse().body() = readStream;
+
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+}
+
+void
+CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<SavedResponse>& aSavedResponses,
+                             Manager::StreamList* aStreamList)
+{
+  Manager::StreamControl* streamControl = nullptr;
+  nsTArray<PCacheResponse> responses;
+
+  for (uint32_t i = 0; i < aSavedResponses.Length(); ++i) {
+    PCacheResponse* res = responses.AppendElement();
+    *res = aSavedResponses[i].mValue;
+
+    if (!aSavedResponses[i].mHasBodyId) {
+      res->body() = void_t();
+      continue;
+    }
+
+    PCacheReadStream readStream;
+    streamControl =
+      SerializeReadStream(streamControl, aSavedResponses[i].mBodyId,
+                          aStreamList, &readStream);
+    res->body() = readStream;
+  }
+
+  unused << SendMatchAllResponse(aRequestId, aRv, responses);
+}
+
+void
+CacheParent::OnCachePutAll(RequestId aRequestId, nsresult aRv)
+{
+  unused << SendPutResponse(aRequestId, aRv);
+}
+
+void
+CacheParent::OnCacheDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
+{
+  unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
+}
+
+void
+CacheParent::OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                         const nsTArray<SavedRequest>& aSavedRequests,
+                         Manager::StreamList* aStreamList)
+{
+  Manager::StreamControl* streamControl = nullptr;
+  nsTArray<PCacheRequest> requests;
+
+  for (uint32_t i = 0; i < aSavedRequests.Length(); ++i) {
+    PCacheRequest* req = requests.AppendElement();
+    *req = aSavedRequests[i].mValue;
+
+    if (!aSavedRequests[i].mHasBodyId) {
+      req->body() = void_t();
+      continue;
+    }
+
+    PCacheReadStream readStream;
+    streamControl =
+      SerializeReadStream(streamControl, aSavedRequests[i].mBodyId,
+                          aStreamList, &readStream);
+    req->body() = readStream;
+  }
+
+  unused << SendKeysResponse(aRequestId, aRv, requests);
+}
+
+void
+CacheParent::OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId, nsresult aRv)
+{
+  aFetchPut->ClearListener();
+  mFetchPutList.RemoveElement(aFetchPut);
+  unused << SendAddAllResponse(aRequestId, aRv);
+}
+
+Manager::StreamControl*
+CacheParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
+                                 const nsID& aId,
+                                 Manager::StreamList* aStreamList,
+                                 PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aStreamList);
+  MOZ_ASSERT(aReadStreamOut);
+
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
+  MOZ_ASSERT(stream);
+
+  if (!aStreamControl) {
+    aStreamControl = new CacheStreamControlParent();
+    DebugOnly<PCacheStreamControlParent*> actor =
+      Manager()->SendPCacheStreamControlConstructor(aStreamControl);
+    MOZ_ASSERT(aStreamControl == actor);
+  }
+
+  aStreamList->SetStreamControl(aStreamControl);
+
+  nsRefPtr<ReadStream> readStream = ReadStream::Create(aStreamControl,
+                                                       aId, stream);
+  readStream->Serialize(aReadStreamOut);
+
+  return aStreamControl;
+}
+
+already_AddRefed<nsIInputStream>
+CacheParent::DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid)
+{
+  if (aStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  const PCacheReadStream& readStream = aStreamOrVoid.get_PCacheReadStream();
+
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(readStream);
+  if (stream) {
+    return stream.forget();
+  }
+
+  nsTArray<FileDescriptor> fds;
+  if (readStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetParent* fdSetActor =
+      static_cast<FileDescriptorSetParent*>(readStream.fds().get_PFileDescriptorSetParent());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  return DeserializeInputStream(readStream.params(), fds);
+}
+
+} // namespace cache
+} // namespace dom
+} // namesapce mozilla
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheParent.h
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheParent_h
+#define mozilla_dom_cache_CacheParent_h
+
+#include "mozilla/dom/cache/FetchPut.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/Types.h"
+
+struct nsID;
+template <class T> class nsRefPtr;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheDBConnection;
+struct SavedResponse;
+struct StreamHolder;
+
+class CacheParent MOZ_FINAL : public PCacheParent
+                            , public Manager::Listener
+                            , public FetchPut::Listener
+{
+public:
+  CacheParent(cache::Manager* aManager, CacheId aCacheId);
+  virtual ~CacheParent();
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+
+  // PCacheParent method
+  virtual bool
+  RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
+            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
+  virtual bool
+  RecvMatchAll(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
+               const PCacheQueryParams& aParams) MOZ_OVERRIDE;
+  virtual bool
+  RecvAddAll(const RequestId& aRequestId,
+             const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
+  virtual bool
+  RecvPut(const RequestId& aRequestId, const CacheRequestResponse& aPut);
+  virtual bool
+  RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
+             const PCacheQueryParams& aParams) MOZ_OVERRIDE;
+  virtual bool
+  RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
+           const PCacheQueryParams& aParams) MOZ_OVERRIDE;
+
+  // Manager::Listener methods
+  virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                            const SavedResponse* aSavedResponse,
+                            Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                               const nsTArray<SavedResponse>& aSavedResponses,
+                               Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+  virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
+                             bool aSuccess) MOZ_OVERRIDE;
+  virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                           const nsTArray<SavedRequest>& aSavedRequests,
+                           Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+
+  // FetchPut::Listener methods
+  virtual void OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId,
+                          nsresult aRv) MOZ_OVERRIDE;
+
+private:
+  Manager::StreamControl*
+  SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
+                      Manager::StreamList* aStreamList,
+                      PCacheReadStream* aReadStreamOut);
+
+  already_AddRefed<nsIInputStream>
+  DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
+
+  nsRefPtr<cache::Manager> mManager;
+  const CacheId mCacheId;
+  nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheParent_h
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorage.cpp
@@ -0,0 +1,629 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStorage.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/CacheStorageBinding.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/cache/Cache.h"
+#include "mozilla/dom/cache/CacheStorageChild.h"
+#include "mozilla/dom/cache/PCacheChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/BackgroundUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundSharedTypes.h"
+#include "nsIGlobalObject.h"
+#include "nsIScriptSecurityManager.h"
+#include "WorkerPrivate.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::ErrorResult;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::IProtocol;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalToPrincipalInfo;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::CacheStorage);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::CacheStorage);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CacheStorage, mGlobal,
+                                                    mRequestPromises)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(CacheStorage)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
+NS_INTERFACE_MAP_END
+
+// static
+already_AddRefed<CacheStorage>
+CacheStorage::CreateOnMainThread(Namespace aNamespace,
+                                 nsIGlobalObject* aGlobal,
+                                 nsIPrincipal* aPrincipal,
+                                 ErrorResult& aRv)
+{
+  MOZ_ASSERT(aGlobal);
+  MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(NS_IsMainThread());
+
+  bool nullPrincipal;
+  nsresult rv = aPrincipal->GetIsNullPrincipal(&nullPrincipal);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  if (nullPrincipal) {
+    NS_WARNING("CacheStorage not supported on null principal.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  bool unknownAppId;
+  rv = aPrincipal->GetUnknownAppId(&unknownAppId);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  if (unknownAppId) {
+    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  nsAutoCString origin;
+  rv = aPrincipal->GetOrigin(getter_Copies(origin));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  PrincipalInfo principalInfo;
+  rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal, origin,
+                                                principalInfo);
+  return ref.forget();
+}
+
+// static
+already_AddRefed<CacheStorage>
+CacheStorage::CreateOnWorker(Namespace aNamespace,
+                             nsIGlobalObject* aGlobal,
+                             WorkerPrivate* aWorkerPrivate,
+                             ErrorResult& aRv)
+{
+  MOZ_ASSERT(aGlobal);
+  MOZ_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
+  if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
+    NS_WARNING("CacheStorage not supported on null principal.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  if (principalInfo.type() == PrincipalInfo::TContentPrincipalInfo &&
+      principalInfo.get_ContentPrincipalInfo().appId() ==
+      nsIScriptSecurityManager::UNKNOWN_APP_ID) {
+    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  NS_ConvertUTF16toUTF8 origin(aWorkerPrivate->GetLocationInfo().mOrigin);
+
+  nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal, origin,
+                                                principalInfo);
+  return ref.forget();
+}
+
+CacheStorage::CacheStorage(Namespace aNamespace,
+                           nsIGlobalObject* aGlobal,
+                           const nsACString& aOrigin,
+                           const PrincipalInfo& aPrincipalInfo)
+  : mNamespace(aNamespace)
+  , mGlobal(aGlobal)
+  , mOrigin(aOrigin)
+  , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
+  , mActor(nullptr)
+  , mFailedActor(false)
+{
+  MOZ_ASSERT(mGlobal);
+
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    ActorCreated(actor);
+  } else {
+    bool ok = BackgroundChild::GetOrCreateForCurrentThread(this);
+    if (!ok) {
+      ActorFailed();
+    }
+  }
+}
+
+already_AddRefed<Promise>
+CacheStorage::Match(const RequestOrUSVString& aRequest,
+                    const QueryParams& aParams, ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_MATCH;
+    entry->mParams = aParams;
+
+    if (aRequest.IsUSVString()) {
+      *entry->mRequest.SetAsUSVString().ToAStringPtr() =
+        aRequest.GetAsUSVString();
+    } else {
+      entry->mRequest.SetAsRequest() =
+        &aRequest.GetAsRequest();
+    }
+
+    return promise.forget();
+  }
+
+  PCacheRequest request;
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    nsRefPtr<Promise> unused = RemoveRequestPromise(requestId);
+    return nullptr;
+  }
+
+  PCacheQueryParams params;
+  ToPCacheQueryParams(params, aParams);
+
+  unused << mActor->SendMatch(requestId, request, params);
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+CacheStorage::Has(const nsAString& aKey, ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_HAS;
+    entry->mKey = aKey;
+
+    return promise.forget();
+  }
+
+  unused << mActor->SendHas(requestId, nsString(aKey));
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+CacheStorage::Open(const nsAString& aKey, ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_OPEN;
+    entry->mKey = aKey;
+
+    return promise.forget();
+  }
+
+  unused << mActor->SendOpen(requestId, nsString(aKey));
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+CacheStorage::Delete(const nsAString& aKey, ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_DELETE;
+    entry->mKey = aKey;
+
+    return promise.forget();
+  }
+
+  unused << mActor->SendDelete(requestId, nsString(aKey));
+
+  return promise.forget();
+}
+
+already_AddRefed<Promise>
+CacheStorage::Keys(ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
+  if (!promise) {
+    return nullptr;
+  }
+
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
+  RequestId requestId = AddRequestPromise(promise, aRv);
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_KEYS;
+
+    return promise.forget();
+  }
+
+  unused << mActor->SendKeys(requestId);
+
+  return promise.forget();
+}
+
+// static
+bool
+CacheStorage::PrefEnabled(JSContext* aCx, JSObject* aObj)
+{
+  return Cache::PrefEnabled(aCx, aObj);
+}
+
+nsISupports*
+CacheStorage::GetParentObject() const
+{
+  return mGlobal;
+}
+
+JSObject*
+CacheStorage::WrapObject(JSContext* aContext)
+{
+  return mozilla::dom::CacheStorageBinding::Wrap(aContext, this);
+}
+
+void
+CacheStorage::ActorCreated(PBackgroundChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(aActor);
+
+  CacheStorageChild* newActor = new CacheStorageChild(*this);
+  if (NS_WARN_IF(!newActor)) {
+    ActorFailed();
+    return;
+  }
+
+  PCacheStorageChild* constructedActor =
+    aActor->SendPCacheStorageConstructor(newActor, mNamespace, *mPrincipalInfo);
+
+  if (NS_WARN_IF(!constructedActor)) {
+    ActorFailed();
+    return;
+  }
+
+  MOZ_ASSERT(constructedActor == newActor);
+  mActor = newActor;
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    RequestId requestId = entry.mRequestId;
+    switch(entry.mOp) {
+      case OP_MATCH:
+      {
+        PCacheRequest request;
+        ErrorResult rv;
+        ToPCacheRequest(request, entry.mRequest, IgnoreBody,
+                        PassThroughReferrer, rv);
+        if (NS_WARN_IF(rv.Failed())) {
+          nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
+          if (promise) {
+            promise->MaybeReject(rv);
+          }
+          return;
+        }
+
+        PCacheQueryParams params;
+        ToPCacheQueryParams(params, entry.mParams);
+
+        unused << mActor->SendMatch(requestId, request, params);
+        break;
+      }
+      case OP_HAS:
+        unused << mActor->SendHas(requestId, entry.mKey);
+        break;
+      case OP_OPEN:
+        unused << mActor->SendOpen(requestId, entry.mKey);
+        break;
+      case OP_DELETE:
+        unused << mActor->SendDelete(requestId, entry.mKey);
+        break;
+      case OP_KEYS:
+        unused << mActor->SendKeys(requestId);
+        break;
+    }
+  }
+  mPendingRequests.Clear();
+}
+
+void
+CacheStorage::ActorFailed()
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(!mFailedActor);
+
+  mFailedActor = true;
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    RequestId requestId = mPendingRequests[i].mRequestId;
+    nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
+    if (!promise) {
+      continue;
+    }
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+  }
+  mPendingRequests.Clear();
+}
+
+void
+CacheStorage::ActorDestroy(IProtocol& aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(mActor);
+  MOZ_ASSERT(mActor == &aActor);
+  mActor->ClearListener();
+  mActor = nullptr;
+
+  // Note that we will never get an actor again in case another request is
+  // made before this object is destructed.
+  ActorFailed();
+}
+
+void
+CacheStorage::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                                const PCacheResponseOrVoid& aResponse)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
+    promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
+    return;
+  }
+
+  nsRefPtr<Response> response = ToResponse(aResponse);
+  promise->MaybeResolve(response);
+}
+
+void
+CacheStorage::RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+
+  }
+
+  promise->MaybeResolve(aSuccess);
+}
+
+void
+CacheStorage::RecvOpenResponse(RequestId aRequestId, nsresult aRv,
+                               PCacheChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    if (aActor) {
+      PCacheChild::Send__delete__(aActor);
+    }
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  if (!aActor) {
+    promise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+    return;
+  }
+
+  nsRefPtr<Cache> cache = new Cache(mGlobal, mOrigin, aActor);
+  promise->MaybeResolve(cache);
+}
+
+void
+CacheStorage::RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
+                                 bool aSuccess)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  promise->MaybeResolve(aSuccess);
+}
+
+void
+CacheStorage::RecvKeysResponse(RequestId aRequestId, nsresult aRv,
+                               const nsTArray<nsString>& aKeys)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
+  if (NS_WARN_IF(!promise)) {
+    return;
+  }
+
+  if (NS_FAILED(aRv)) {
+    promise->MaybeReject(aRv);
+    return;
+  }
+
+  promise->MaybeResolve(aKeys);
+}
+
+nsIGlobalObject*
+CacheStorage::GetGlobalObject() const
+{
+  return mGlobal;
+}
+
+const nsACString&
+CacheStorage::Origin() const
+{
+  return mOrigin;
+}
+
+#ifdef DEBUG
+void
+CacheStorage::AssertOwningThread() const
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+}
+#endif
+
+CacheStorage::~CacheStorage()
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
+  if (mActor) {
+    mActor->ClearListener();
+    PCacheStorageChild::Send__delete__(mActor);
+    // The actor will be deleted by the IPC manager
+    mActor = nullptr;
+  }
+}
+
+RequestId
+CacheStorage::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(aPromise);
+
+  mRequestPromises.AppendElement(aPromise);
+
+  // (Ab)use the promise pointer as our request ID.  This is a fast, thread-safe
+  // way to get a unique ID for the promise to be resolved later.
+  return reinterpret_cast<RequestId>(aPromise);
+}
+
+already_AddRefed<Promise>
+CacheStorage::RemoveRequestPromise(RequestId aRequestId)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(aRequestId != INVALID_REQUEST_ID);
+
+  for (uint32_t i = 0; i < mRequestPromises.Length(); ++i) {
+    nsRefPtr<Promise>& promise = mRequestPromises.ElementAt(i);
+    // To be safe, only cast promise pointers to our integer RequestId
+    // type and never cast an integer to a pointer.
+    if (aRequestId == reinterpret_cast<RequestId>(promise.get())) {
+      nsRefPtr<Promise> ref;
+      ref.swap(promise);
+      mRequestPromises.RemoveElementAt(i);
+      return ref.forget();
+    }
+  }
+  return nullptr;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorage.h
@@ -0,0 +1,155 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStorage_h
+#define mozilla_dom_cache_CacheStorage_h
+
+#include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/cache/CacheStorageChildListener.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsTArray.h"
+#include "nsWrapperCache.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace ipc {
+  class IProtocol;
+  class PrincipalInfo;
+}
+
+namespace dom {
+
+class Promise;
+
+namespace workers {
+  class WorkerPrivate;
+}
+
+namespace cache {
+
+class CacheStorageChild;
+class PCacheRequest;
+
+class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
+                             , public nsWrapperCache
+                             , public CacheStorageChildListener
+                             , public TypeUtils
+{
+  typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
+
+public:
+  static already_AddRefed<CacheStorage>
+  CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
+                     nsIPrincipal* aPrincipal, ErrorResult& aRv);
+
+  static already_AddRefed<CacheStorage>
+  CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
+                 workers::WorkerPrivate* aWorkerPrivate, ErrorResult& aRv);
+
+  // webidl interface methods
+  already_AddRefed<Promise> Match(const RequestOrUSVString& aRequest,
+                                  const QueryParams& aParams, ErrorResult& aRv);
+  already_AddRefed<Promise> Has(const nsAString& aKey, ErrorResult& aRv);
+  already_AddRefed<Promise> Open(const nsAString& aKey, ErrorResult& aRv);
+  already_AddRefed<Promise> Delete(const nsAString& aKey, ErrorResult& aRv);
+  already_AddRefed<Promise> Keys(ErrorResult& aRv);
+
+  // binding methods
+  static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
+
+  virtual nsISupports* GetParentObject() const;
+  virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
+
+  // nsIIPCbackgroundChildCreateCallback methods
+  virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
+  virtual void ActorFailed() MOZ_OVERRIDE;
+
+  // CacheStorageChildListener methods
+  virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
+  virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                           const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+  virtual void RecvHasResponse(RequestId aRequestId, nsresult aRv,
+                               bool aSuccess) MOZ_OVERRIDE;
+  virtual void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
+                                PCacheChild* aActor) MOZ_OVERRIDE;
+  virtual void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
+                                  bool aSuccess) MOZ_OVERRIDE;
+  virtual void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
+                                const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
+
+  // TypeUtils method
+  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+  virtual const nsACString& Origin() const MOZ_OVERRIDE;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
+private:
+  CacheStorage(Namespace aNamespace,
+               nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+               const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
+  virtual ~CacheStorage();
+
+  RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
+  already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
+
+  // Would like to use CacheInitData here, but we cannot because
+  // its an IPC struct which breaks webidl by including windows.h.
+  const Namespace mNamespace;
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+  const nsCString mOrigin;
+  UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+  CacheStorageChild* mActor;
+  nsTArray<nsRefPtr<Promise>> mRequestPromises;
+
+  enum Op
+  {
+    OP_MATCH,
+    OP_HAS,
+    OP_OPEN,
+    OP_DELETE,
+    OP_KEYS
+  };
+
+  struct Entry
+  {
+    Entry() { }
+    ~Entry() { }
+    RequestId mRequestId;
+    Op mOp;
+    // Would prefer to use PCacheRequest/PCacheQueryParams, but can't
+    // because they introduce a header dependency on windows.h which
+    // breaks the bindings build.
+    RequestOrUSVString mRequest;
+    QueryParams mParams;
+    // It would also be nice to union the key with the match args above,
+    // but VS2013 doesn't like these types in unions because of copy
+    // constructors.
+    nsString mKey;
+  };
+
+  nsTArray<Entry> mPendingRequests;
+  bool mFailedActor;
+
+public:
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CacheStorage)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStorage_h
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorageChild.cpp
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStorageChild.h"
+
+#include "mozilla/dom/cache/CacheStorageChildListener.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+CacheStorageChild::CacheStorageChild(CacheStorageChildListener& aListener)
+  : mListener(&aListener)
+{
+}
+
+CacheStorageChild::~CacheStorageChild()
+{
+  MOZ_ASSERT(!mListener);
+}
+
+void
+CacheStorageChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  // If the listener is destroyed before we are, then they will clear
+  // their registration.
+  if (mListener) {
+    mListener->ActorDestroy(*this);
+  }
+}
+
+bool
+CacheStorageChild::RecvMatchResponse(const RequestId& aRequestId,
+                                     const nsresult& aRv,
+                                     const PCacheResponseOrVoid& aResponseOrVoid)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid);
+  return true;
+}
+
+bool
+CacheStorageChild::RecvHasResponse(const RequestId& aRequestId,
+                                   const nsresult& aRv,
+                                   const bool& aSuccess)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvHasResponse(aRequestId, aRv, aSuccess);
+  return true;
+}
+
+bool
+CacheStorageChild::RecvOpenResponse(const RequestId& aRequestId,
+                                    const nsresult& aRv,
+                                    PCacheChild* aActor)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvOpenResponse(aRequestId, aRv, aActor);
+  return true;
+}
+
+bool
+CacheStorageChild::RecvDeleteResponse(const RequestId& aRequestId,
+                                      const nsresult& aRv,
+                                      const bool& aResult)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvDeleteResponse(aRequestId, aRv, aResult);
+  return true;
+}
+
+bool
+CacheStorageChild::RecvKeysResponse(const RequestId& aRequestId,
+                                    const nsresult& aRv,
+                                    const nsTArray<nsString>& aKeys)
+{
+  MOZ_ASSERT(mListener);
+  mListener->RecvKeysResponse(aRequestId, aRv, aKeys);
+  return true;
+}
+
+void
+CacheStorageChild::ClearListener()
+{
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorageChild.h
@@ -0,0 +1,51 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStorageChild_h
+#define mozilla_dom_cache_CacheStorageChild_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/PCacheStorageChild.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStorageChildListener;
+class PCacheChild;
+
+class CacheStorageChild MOZ_FINAL : public PCacheStorageChild
+{
+public:
+  CacheStorageChild(CacheStorageChildListener& aListener);
+  virtual ~CacheStorageChild();
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvMatchResponse(const RequestId& requestId,
+                             const nsresult& aRv,
+                             const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
+  virtual bool RecvHasResponse(const cache::RequestId& aRequestId,
+                               const nsresult& aRv,
+                               const bool& aSuccess) MOZ_OVERRIDE;
+  virtual bool RecvOpenResponse(const cache::RequestId& aRequestId,
+                                const nsresult& aRv,
+                                PCacheChild* aActor) MOZ_OVERRIDE;
+  virtual bool RecvDeleteResponse(const cache::RequestId& aRequestId,
+                                  const nsresult& aRv,
+                                  const bool& aResult) MOZ_OVERRIDE;
+  virtual bool RecvKeysResponse(const cache::RequestId& aRequestId,
+                                const nsresult& aRv,
+                                const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
+
+  void ClearListener();
+private:
+  CacheStorageChildListener* mListener;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStorageChild_h
diff --git a/dom/cache/CacheStorageChildListener.h b/dom/cache/CacheStorageChildListener.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorageChildListener.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStorageChildListener_h
+#define mozilla_dom_cache_CacheStorageChildListener_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsError.h"
+#include "nsString.h"
+
+template<class T> class nsTArray;
+
+namespace mozilla {
+
+namespace ipc {
+  class IProtocol;
+}
+
+namespace dom {
+namespace cache {
+
+class PCacheChild;
+class PCacheResponseOrVoid;
+
+class CacheStorageChildListener
+{
+public:
+  virtual ~CacheStorageChildListener() { }
+  virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
+  virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
+                                 const PCacheResponseOrVoid& aResponse)=0;
+  virtual void RecvHasResponse(cache::RequestId aRequestId, nsresult aRv,
+                               bool aSuccess)=0;
+  virtual void RecvOpenResponse(cache::RequestId aRequestId, nsresult aRv,
+                                PCacheChild* aActor)=0;
+  virtual void RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
+                                  bool aSuccess)=0;
+  virtual void RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
+                                const nsTArray<nsString>& aKeys)=0;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStorageChildListener_h
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorageParent.cpp
@@ -0,0 +1,374 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStorageParent.h"
+
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/cache/CacheParent.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/unused.h"
+#include "nsCOMPtr.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ipc::PBackgroundParent;
+using mozilla::ipc::PFileDescriptorSetParent;
+using mozilla::ipc::PrincipalInfo;
+
+CacheStorageParent::CacheStorageParent(PBackgroundParent* aManagingActor,
+                                       Namespace aNamespace,
+                                       const PrincipalInfo& aPrincipalInfo)
+  : mNamespace(aNamespace)
+{
+  MOZ_ASSERT(aManagingActor);
+
+  nsresult rv = PrincipalVerifier::Create(this, aManagingActor, aPrincipalInfo,
+                                          getter_AddRefs(mVerifier));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << Send__delete__(this);
+  }
+}
+
+CacheStorageParent::~CacheStorageParent()
+{
+  MOZ_ASSERT(!mManager);
+}
+
+void
+CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mManager) {
+    MOZ_ASSERT(mActiveRequests.Length() > 0);
+    mManager->RemoveListener(this);
+    mManager = nullptr;
+  }
+}
+
+bool
+CacheStorageParent::RecvMatch(const RequestId& aRequestId,
+                              const PCacheRequest& aRequest,
+                              const PCacheQueryParams& aParams)
+{
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_MATCH;
+    entry->mRequestId = aRequestId;
+    entry->mRequest = aRequest;
+    entry->mParams = aParams;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageMatch(this, aRequestId, mNamespace, aRequest,
+                        aParams);
+
+  return true;
+}
+
+bool
+CacheStorageParent::RecvHas(const RequestId& aRequestId, const nsString& aKey)
+{
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_HAS;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageHas(this, aRequestId, mNamespace, aKey);
+
+  return true;
+}
+
+bool
+CacheStorageParent::RecvOpen(const RequestId& aRequestId, const nsString& aKey)
+{
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_OPEN;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageOpen(this, aRequestId, mNamespace, aKey);
+
+  return true;
+}
+
+bool
+CacheStorageParent::RecvDelete(const RequestId& aRequestId,
+                               const nsString& aKey)
+{
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_DELETE;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageDelete(this, aRequestId, mNamespace, aKey);
+
+  return true;
+}
+
+bool
+CacheStorageParent::RecvKeys(const RequestId& aRequestId)
+{
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_DELETE;
+    entry->mRequestId = aRequestId;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageKeys(this, aRequestId, mNamespace);
+
+  return true;
+}
+
+void
+CacheStorageParent::OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)
+{
+  if (NS_WARN_IF(NS_FAILED(aRv))) {
+    FailPendingRequests(aRv);
+    unused << Send__delete__(this);
+    return;
+  }
+
+  MOZ_ASSERT(mVerifier);
+  MOZ_ASSERT(!mManagerId);
+  MOZ_ASSERT(!mManager);
+
+  mManagerId = aManagerId;
+  mVerifier->ClearListener();
+  mVerifier = nullptr;
+
+  RetryPendingRequests();
+}
+
+void
+CacheStorageParent::OnStorageMatch(RequestId aRequestId, nsresult aRv,
+                                   const SavedResponse* aSavedResponse,
+                                   Manager::StreamList* aStreamList)
+{
+  PCacheResponseOrVoid responseOrVoid;
+
+  ReleaseManager(aRequestId);
+
+  // no match
+  if (NS_FAILED(aRv) || !aSavedResponse) {
+    responseOrVoid = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // match without body data to stream
+  if (!aSavedResponse->mHasBodyId) {
+    responseOrVoid = aSavedResponse->mValue;
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  PCacheReadStream readStream;
+  SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                      &readStream);
+
+  responseOrVoid = aSavedResponse->mValue;
+  responseOrVoid.get_PCacheResponse().body() = readStream;
+
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+}
+
+void
+CacheStorageParent::OnStorageHas(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheFound)
+{
+  ReleaseManager(aRequestId);
+  unused << SendHasResponse(aRequestId, aRv, aCacheFound);
+}
+
+void
+CacheStorageParent::OnStorageOpen(RequestId aRequestId, nsresult aRv,
+                                  CacheId aCacheId)
+{
+  if (NS_FAILED(aRv)) {
+    ReleaseManager(aRequestId);
+    unused << SendOpenResponse(aRequestId, aRv, nullptr);
+    return;
+  }
+
+  MOZ_ASSERT(mManager);
+  CacheParent* actor = new CacheParent(mManager, aCacheId);
+
+  ReleaseManager(aRequestId);
+
+  PCacheParent* base = Manager()->SendPCacheConstructor(actor);
+  actor = static_cast<CacheParent*>(base);
+  unused << SendOpenResponse(aRequestId, aRv, actor);
+}
+
+void
+CacheStorageParent::OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                    bool aCacheDeleted)
+{
+  ReleaseManager(aRequestId);
+  unused << SendDeleteResponse(aRequestId, aRv, aCacheDeleted);
+}
+
+void
+CacheStorageParent::OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                                  const nsTArray<nsString>& aKeys)
+{
+  ReleaseManager(aRequestId);
+  unused << SendKeysResponse(aRequestId, aRv, aKeys);
+}
+
+Manager::StreamControl*
+CacheStorageParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
+                                        const nsID& aId,
+                                        Manager::StreamList* aStreamList,
+                                        PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aStreamList);
+  MOZ_ASSERT(aReadStreamOut);
+
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
+  MOZ_ASSERT(stream);
+
+  if (!aStreamControl) {
+    aStreamControl = new CacheStreamControlParent();
+    DebugOnly<PCacheStreamControlParent*> actor =
+      Manager()->SendPCacheStreamControlConstructor(aStreamControl);
+    MOZ_ASSERT(aStreamControl == actor);
+  }
+
+  aStreamList->SetStreamControl(aStreamControl);
+
+  nsRefPtr<ReadStream> readStream = ReadStream::Create(aStreamControl,
+                                                       aId, stream);
+  readStream->Serialize(aReadStreamOut);
+
+  return aStreamControl;
+}
+
+void
+CacheStorageParent::RetryPendingRequests()
+{
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    switch(entry.mOp) {
+      case OP_MATCH:
+        RecvMatch(entry.mRequestId, entry.mRequest, entry.mParams);
+        break;
+      case OP_HAS:
+        RecvHas(entry.mRequestId, entry.mKey);
+        break;
+      case OP_OPEN:
+        RecvOpen(entry.mRequestId, entry.mKey);
+        break;
+      case OP_DELETE:
+        RecvDelete(entry.mRequestId, entry.mKey);
+        break;
+      case OP_KEYS:
+        RecvKeys(entry.mRequestId);
+        break;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Pending request within unknown op");
+    }
+  }
+  mPendingRequests.Clear();
+}
+
+void
+CacheStorageParent::FailPendingRequests(nsresult aRv)
+{
+  MOZ_ASSERT(NS_FAILED(aRv));
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    switch(entry.mOp) {
+      case OP_MATCH:
+      {
+        PCacheResponseOrVoid responseOrVoid;
+        responseOrVoid = void_t();
+        unused << SendMatchResponse(entry.mRequestId, aRv, responseOrVoid);
+        break;
+      }
+      case OP_HAS:
+        unused << SendHasResponse(entry.mRequestId, aRv, false);
+        break;
+      case OP_OPEN:
+        unused << SendOpenResponse(entry.mRequestId, aRv, nullptr);
+        break;
+      case OP_DELETE:
+        unused << SendDeleteResponse(entry.mRequestId, aRv, false);
+        break;
+      case OP_KEYS:
+      {
+        const nsTArray<nsString> emptyKeys;
+        unused << SendKeysResponse(entry.mRequestId, aRv, emptyKeys);
+        break;
+      }
+      default:
+        MOZ_ASSERT_UNREACHABLE("Pending request within unknown op");
+    }
+  }
+  mPendingRequests.Clear();
+}
+
+cache::Manager*
+CacheStorageParent::RequestManager(RequestId aRequestId)
+{
+  MOZ_ASSERT(!mActiveRequests.Contains(aRequestId));
+  if (!mManager) {
+    MOZ_ASSERT(mActiveRequests.Length() < 1);
+    mManager = Manager::GetOrCreate(mManagerId);
+    MOZ_ASSERT(mManager);
+  }
+  mActiveRequests.AppendElement(aRequestId);
+  return mManager;
+}
+
+void
+CacheStorageParent::ReleaseManager(RequestId aRequestId)
+{
+  // Note that if the child process dies we also clean up the mManager in
+  // ActorDestroy().  There is no race with this method, however, because
+  // ActorDestroy removes this object from the Manager's listener list.
+  // Therefore ReleaseManager() should never be called after ActorDestroy()
+  // runs.
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mActiveRequests.Length() > 0);
+
+  DebugOnly<bool> removed = mActiveRequests.RemoveElement(aRequestId);
+  MOZ_ASSERT(removed);
+
+  if (mActiveRequests.Length() < 1) {
+    mManager->RemoveListener(this);
+    mManager = nullptr;
+  }
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorageParent.h
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStorageParent_h
+#define mozilla_dom_cache_CacheStorageParent_h
+
+#include "mozilla/dom/cache/CacheInitData.h"
+#include "mozilla/dom/cache/PCacheStorageParent.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PrincipalVerifier.h"
+#include "mozilla/dom/cache/Types.h"
+
+template <class T> class nsRefPtr;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class ManagerId;
+
+class CacheStorageParent MOZ_FINAL : public PCacheStorageParent
+                                   , public PrincipalVerifier::Listener
+                                   , public Manager::Listener
+{
+public:
+  CacheStorageParent(PBackgroundParent* aManagingActor, Namespace aNamespace,
+                     const ipc::PrincipalInfo& aPrincipalInfo);
+  virtual ~CacheStorageParent();
+
+  // PCacheStorageParent methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvMatch(const RequestId& aRequestId,
+                         const PCacheRequest& aRequest,
+                         const PCacheQueryParams& aParams) MOZ_OVERRIDE;
+  virtual bool RecvHas(const RequestId& aRequestId,
+                       const nsString& aKey) MOZ_OVERRIDE;
+  virtual bool RecvOpen(const RequestId& aRequestId,
+                        const nsString& aKey) MOZ_OVERRIDE;
+  virtual bool RecvDelete(const RequestId& aRequestId,
+                          const nsString& aKey) MOZ_OVERRIDE;
+  virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
+
+  // PrincipalVerifier::Listener methods
+  virtual void OnPrincipalVerified(nsresult aRv,
+                                   ManagerId* aManagerId) MOZ_OVERRIDE;
+
+  // Manager::Listener methods
+  virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
+                              const SavedResponse* aResponse,
+                              Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
+                            bool aCacheFound) MOZ_OVERRIDE;
+  virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
+                             CacheId aCacheId) MOZ_OVERRIDE;
+  virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                               bool aCacheDeleted) MOZ_OVERRIDE;
+  virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
+
+private:
+  Manager::StreamControl*
+  SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
+                      Manager::StreamList* aStreamList,
+                      PCacheReadStream* aReadStreamOut);
+
+  void RetryPendingRequests();
+  void FailPendingRequests(nsresult aRv);
+
+  cache::Manager* RequestManager(RequestId aRequestId);
+  void ReleaseManager(RequestId aRequestId);
+
+  const Namespace mNamespace;
+  nsRefPtr<PrincipalVerifier> mVerifier;
+  nsRefPtr<ManagerId> mManagerId;
+  nsRefPtr<cache::Manager> mManager;
+
+  enum Op
+  {
+    OP_MATCH,
+    OP_HAS,
+    OP_OPEN,
+    OP_DELETE,
+    OP_KEYS
+  };
+
+  struct Entry
+  {
+    Op mOp;
+    RequestId mRequestId;
+    nsString mKey;
+    PCacheRequest mRequest;
+    PCacheQueryParams mParams;
+  };
+
+  nsTArray<Entry> mPendingRequests;
+  nsTArray<RequestId> mActiveRequests;
+};
+
+} // namesapce cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStorageParent_h
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+CacheStreamControlChild::CacheStreamControlChild()
+{
+}
+
+CacheStreamControlChild::~CacheStreamControlChild()
+{
+}
+
+void
+CacheStreamControlChild::AddListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlChild::RemoveListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlChild::NoteClosed(const nsID& aId)
+{
+  unused << SendNoteClosed(aId);
+}
+
+void
+CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    mListeners[i]->CloseStreamWithoutReporting();
+  }
+}
+
+bool
+CacheStreamControlChild::RecvClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+  return true;
+}
+
+bool
+CacheStreamControlChild::RecvCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.h
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlChild_h
+#define mozilla_dom_cache_CacheStreamControlChild_h
+
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlListener;
+
+class CacheStreamControlChild : public PCacheStreamControlChild
+{
+public:
+  CacheStreamControlChild();
+  virtual ~CacheStreamControlChild();
+
+  void AddListener(CacheStreamControlListener* aListener);
+  void RemoveListener(CacheStreamControlListener* aListener);
+
+  void NoteClosed(const nsID& aId);
+
+  // PCacheStreamControlChild methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
+  virtual bool RecvCloseAll() MOZ_OVERRIDE;
+
+private:
+  nsTArray<CacheStreamControlListener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/CacheStreamControlListener.h b/dom/cache/CacheStreamControlListener.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlListener.h
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlListener_h
+#define mozilla_dom_cache_CacheStreamControlListener_h
+
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlListener
+{
+public:
+  virtual ~CacheStreamControlListener() { }
+  virtual void CloseStream()=0;
+  virtual void CloseStreamWithoutReporting()=0;
+  virtual bool MatchId(const nsID& aId)=0;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlListener_h
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -0,0 +1,113 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+CacheStreamControlParent::CacheStreamControlParent()
+{
+}
+
+CacheStreamControlParent::~CacheStreamControlParent()
+{
+  MOZ_ASSERT(!mStreamList);
+}
+
+void
+CacheStreamControlParent::AddListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlParent::RemoveListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  MOZ_ASSERT(mStreamList);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    mListeners[i]->CloseStreamWithoutReporting();
+  }
+  mStreamList->RemoveStreamControl(this);
+  mStreamList->NoteClosedAll();
+  mStreamList = nullptr;
+}
+
+bool
+CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
+{
+  MOZ_ASSERT(mStreamList);
+  mStreamList->NoteClosed(aId);
+  return true;
+}
+
+void
+CacheStreamControlParent::SetStreamList(Manager::StreamList* aStreamList)
+{
+  MOZ_ASSERT(!mStreamList);
+  mStreamList = aStreamList;
+}
+
+void
+CacheStreamControlParent::Close(const nsID& aId)
+{
+  NotifyClose(aId);
+  unused << SendClose(aId);
+}
+
+void
+CacheStreamControlParent::CloseAll()
+{
+  NotifyCloseAll();
+  unused << SendCloseAll();
+}
+
+void
+CacheStreamControlParent::Shutdown()
+{
+  unused << Send__delete__(this);
+}
+
+void
+CacheStreamControlParent::NotifyClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+}
+
+void
+CacheStreamControlParent::NotifyCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.h
@@ -0,0 +1,49 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlParent_h
+#define mozilla_dom_cache_CacheStreamControlParent_h
+
+#include "mozilla/dom/cache/Manager.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlListener;
+
+class CacheStreamControlParent : public Manager::StreamControl
+{
+public:
+  CacheStreamControlParent();
+  ~CacheStreamControlParent();
+
+  void AddListener(CacheStreamControlListener* aListener);
+  void RemoveListener(CacheStreamControlListener* aListener);
+
+  // PCacheStreamControlParent methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
+
+  // Manager::StreamControl methods
+  virtual void SetStreamList(Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void Close(const nsID& aId) MOZ_OVERRIDE;
+  virtual void CloseAll() MOZ_OVERRIDE;
+  virtual void Shutdown() MOZ_OVERRIDE;
+
+private:
+  void NotifyClose(const nsID& aId);
+  void NotifyCloseAll();
+
+  nsRefPtr<Manager::StreamList> mStreamList;
+  nsTArray<CacheStreamControlListener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlParent_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.cpp
@@ -0,0 +1,577 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Context.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/dom/quota/OriginOrPatternString.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "nsIFile.h"
+#include "nsIPrincipal.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::Nullable;
+using mozilla::dom::cache::QuotaInfo;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
+{
+public:
+  QuotaReleaseRunnable(const QuotaInfo& aQuotaInfo, const nsACString& aQuotaId)
+    : mQuotaInfo(aQuotaInfo)
+    , mQuotaId(aQuotaId)
+  { }
+
+private:
+  ~QuotaReleaseRunnable() { }
+
+  const QuotaInfo mQuotaInfo;
+  const nsCString mQuotaId;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
+
+NS_IMETHODIMP
+QuotaReleaseRunnable::Run()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
+                              mQuotaId);
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
+                                           , public Action::Resolver
+{
+public:
+  QuotaInitRunnable(Context* aContext,
+                    ManagerId* aManagerId,
+                    const nsACString& aQuotaId,
+                    Action* aQuotaIOThreadAction)
+    : mContext(aContext)
+    , mManagerId(aManagerId)
+    , mQuotaId(aQuotaId)
+    , mQuotaIOThreadAction(aQuotaIOThreadAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mManagerId);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_CALL_WAIT_FOR_OPEN_ALLOWED;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aRv));
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
+    }
+  }
+
+protected:
+  virtual ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mQuotaIOThreadAction);
+  }
+
+private:
+  enum State
+  {
+    STATE_INIT,
+    STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
+    STATE_WAIT_FOR_OPEN_ALLOWED,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mQuotaIOThreadAction = nullptr;
+  }
+
+  nsRefPtr<Context> mContext;
+  nsRefPtr<ManagerId> mManagerId;
+  const nsCString mQuotaId;
+  nsRefPtr<Action> mQuotaIOThreadAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  QuotaInfo mQuotaInfo;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::QuotaInitRunnable::Run()
+{
+  switch(mState) {
+    case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+      QuotaManager* qm = QuotaManager::GetOrCreate();
+      if (!qm) {
+        Resolve(NS_ERROR_FAILURE);
+        return NS_OK;
+      }
+
+      nsCOMPtr<nsIPrincipal> principal = mManagerId->Principal();
+      nsresult rv = qm->GetInfoFromPrincipal(principal,
+                                             &mQuotaInfo.mGroup,
+                                             &mQuotaInfo.mOrigin,
+                                             &mQuotaInfo.mIsApp,
+                                             &mQuotaInfo.mHasUnlimStoragePerm);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+
+      mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
+                                  mQuotaId, this);
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    }
+    case STATE_WAIT_FOR_OPEN_ALLOWED:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+      nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    }
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+    {
+      // Can't assert quota IO thread because its an idle thread that can get
+      // recreated.
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
+                                                  mQuotaInfo.mGroup,
+                                                  mQuotaInfo.mOrigin,
+                                                  mQuotaInfo.mIsApp,
+                                                  mQuotaInfo.mHasUnlimStoragePerm,
+                                                  getter_AddRefs(mQuotaInfo.mDir));
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+
+      mState = STATE_RUNNING;
+
+      if (!mQuotaIOThreadAction) {
+        Resolve(NS_OK);
+        return NS_OK;
+      }
+
+      mQuotaIOThreadAction->RunOnTarget(this, mQuotaInfo);
+
+      break;
+    }
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
+      }
+      mContext->OnQuotaInit(mResult, mQuotaInfo);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+      break;
+    }
+  }
+
+  return NS_OK;
+}
+
+class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
+                                        , public Action::Resolver
+{
+public:
+  ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
+                 const QuotaInfo& aQuotaInfo)
+    : mContext(aContext)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaInfo(aQuotaInfo)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mCanceled(false)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    MOZ_ASSERT(mQuotaInfo.mDir);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    if (mCanceled) {
+      mState = STATE_COMPLETE;
+      Clear();
+      return NS_OK;
+    }
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  bool MatchesCacheId(CacheId aCacheId) {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    return mAction->MatchesCacheId(aCacheId);
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    mCanceled = true;
+    mResult = NS_ERROR_FAILURE;
+    nsresult rv;
+    switch(mState) {
+      case STATE_RUNNING:
+        // Re-dispatch if we are currently running
+        rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+        }
+        break;
+      case STATE_INIT:
+      case STATE_RUN_ON_TARGET:
+      case STATE_COMPLETING:
+      case STATE_COMPLETE:
+        break;
+      default:
+        MOZ_CRASH("unexpected state");
+        break;
+    }
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+    }
+  }
+
+private:
+  virtual ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->OnActionRunnableComplete(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  nsRefPtr<Context> mContext;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  nsRefPtr<Action> mAction;
+  const QuotaInfo mQuotaInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  bool mCanceled;
+  nsresult mResult;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::ActionRunnable::Run()
+{
+  nsresult rv;
+  switch(mState) {
+    case STATE_RUN_ON_TARGET:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      if (mCanceled) {
+        mState = STATE_COMPLETING;
+        rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+        if (NS_FAILED(rv)) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+        }
+        break;
+      }
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaInfo);
+      break;
+    case STATE_RUNNING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // We only re-enter the RUNNING state if we are canceling.  Normally we
+      // should transition out of RUNNING via Resolve() instead.
+      MOZ_ASSERT(mCanceled);
+      mState = STATE_COMPLETING;
+      mAction->CancelOnTarget();
+      mResult = NS_FAILED(mResult) ? mResult : NS_ERROR_FAILURE;
+      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    case STATE_COMPLETE:
+      // We can end up running in the complete state if we cancel on the origin
+      // thread while simultaneously starting to run the action on the target
+      // thread.
+      MOZ_ASSERT(mCanceled);
+      break;
+    default:
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+  }
+  return NS_OK;
+}
+
+Context::Context(Listener* aListener, ManagerId* aManagerId,
+                 Action* aQuotaIOThreadAction)
+  : mListener(aListener)
+  , mManagerId(aManagerId)
+  , mState(STATE_CONTEXT_INIT)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mManagerId);
+
+  nsRefPtr<QuotaInitRunnable> runnable =
+    new QuotaInitRunnable(this, mManagerId, NS_LITERAL_CSTRING("Cache"),
+                          aQuotaIOThreadAction);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+Context::Dispatch(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aTarget);
+  MOZ_ASSERT(aAction);
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mTarget = aTarget;
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aTarget, aAction);
+}
+
+void
+Context::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    mActionRunnables[i]->Cancel();
+  }
+}
+
+void
+Context::CancelForCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
+      mPendingActions.RemoveElementAt(i);
+    }
+  }
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (mActionRunnables[i]->MatchesCacheId(aCacheId)) {
+      mActionRunnables[i]->Cancel();
+    }
+  }
+}
+
+Context::~Context()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mListener);
+
+  // Unlock the quota dir as we go out of scope.
+  nsCOMPtr<nsIRunnable> runnable =
+    new QuotaReleaseRunnable(mQuotaInfo, NS_LITERAL_CSTRING("Cache"));
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  }
+
+  mListener->RemoveContext(this);
+}
+
+void
+Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  nsRefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, aTarget, aAction, mQuotaInfo);
+  mActionRunnables.AppendElement(runnable);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+}
+
+void
+Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+
+  mQuotaInfo = aQuotaInfo;
+
+  if (NS_FAILED(aRv)) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aActionRunnable);
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (aActionRunnable == mActionRunnables[i]) {
+      mActionRunnables.RemoveElementAt(i);
+      return;
+    }
+  }
+  MOZ_ASSERT(false);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.h
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Context_h
+#define mozilla_dom_cache_Context_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIEventTarget;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action;
+class ManagerId;
+
+class Context MOZ_FINAL
+{
+public:
+  class Listener
+  {
+  protected:
+    virtual ~Listener() { }
+  public:
+    // Called from the Context destructor on the thread that originally
+    // created the Context.
+    virtual void RemoveContext(Context* aContext)=0;
+
+    NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context::Listener)
+  };
+
+  Context(Listener* aListener, ManagerId* aManagerId,
+          Action* aQuotaIOThreadAction);
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(nsIEventTarget* aTarget, Action* aAction);
+
+  // Cancel any Actions running or waiting to run.  This should allow the
+  // Context to be released and Listener::RemoveContext() will be called
+  // when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+  // Cancel any Actions running or waiting to run that operate on the given
+  // cache ID.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelForCacheId(CacheId aCacheId);
+
+private:
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    nsRefPtr<Action> mAction;
+  };
+
+  ~Context();
+  void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo);
+  void OnActionRunnableComplete(ActionRunnable* const aAction);
+
+  nsRefPtr<Listener> mListener;
+  nsRefPtr<ManagerId> mManagerId;
+  State mState;
+  QuotaInfo mQuotaInfo;
+  nsTArray<PendingAction> mPendingActions;
+
+  // weak refs since ~ActionRunnable() removes itself from this list
+  nsTArray<ActionRunnable*> mActionRunnables;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.cpp
@@ -0,0 +1,150 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBAction.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode)
+  : mMode(aMode)
+{
+}
+
+DBAction::~DBAction()
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaInfo.mDir);
+
+  nsCOMPtr<nsIFile> dbDir;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  rv = dbDir->Append(NS_LITERAL_STRING("cache"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+  MOZ_ASSERT(conn);
+
+  RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
+}
+
+nsresult
+DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                         mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
+  //      but this is what IDB does to access mozIStorageConnection so
+  //      it seems at least this corner case mostly works.
+  // TODO: move this to main thread where GetInfoFromPrincipal() is executed (bug 1110485)
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
+
+  rv = dbFileUrl->SetQuery(
+    NS_LITERAL_CSTRING("persistenceType=") + type +
+    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
+    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    dbFile->Remove(false);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  MOZ_ASSERT(*aConnOut);
+  return rv;
+}
+
+SyncDBAction::SyncDBAction(Mode aMode)
+  : DBAction(aMode)
+{
+}
+
+SyncDBAction::~SyncDBAction()
+{
+}
+
+void
+SyncDBAction::RunWithDBOnTarget(Resolver* aResolver,
+                                const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                                mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = RunSyncWithDBOnTarget(aQuotaInfo, aDBDir, aConn);
+  aResolver->Resolve(rv);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBAction_h
+#define mozilla_dom_cache_DBAction_h
+
+#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/cache/CacheInitData.h"
+#include "nsRefPtr.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBAction : public Action
+{
+protected:
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  DBAction(Mode aMode);
+  virtual ~DBAction();
+
+  // Just as the resolver must be ref'd until cancel or resolve, you may also
+  // ref the DB connection.  The connection can only be referenced from the
+  // target thread and must be released upon cancel or resolve.
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn)=0;
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE;
+
+private:
+  nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
+                          mozIStorageConnection** aConnOut);
+
+  const Mode mMode;
+};
+
+class SyncDBAction : public DBAction
+{
+protected:
+  SyncDBAction(Mode aMode);
+  virtual ~SyncDBAction();
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn)=0;
+
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.cpp
@@ -0,0 +1,1256 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBSchema.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/InternalHeaders.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/SavedTypes.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+
+const int32_t DBSchema::kLatestSchemaVersion = 1;
+const int32_t DBSchema::kMaxEntriesPerStatement = 255;
+
+using mozilla::void_t;
+
+// static
+nsresult
+DBSchema::CreateSchema(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aConn);
+
+  nsAutoCString pragmas(
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
+    // Switch the journaling mode to TRUNCATE to avoid changing the directory
+    // structure at the conclusion of every transaction for devices with slower
+    // file systems.
+    "PRAGMA journal_mode = TRUNCATE; "
+#endif
+    "PRAGMA foreign_keys = ON; "
+  );
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t schemaVersion;
+  rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (schemaVersion == kLatestSchemaVersion) {
+    return rv;
+  }
+
+  if (!schemaVersion) {
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE caches ("
+        "id INTEGER NOT NULL PRIMARY KEY "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE entries ("
+        "id INTEGER NOT NULL PRIMARY KEY, "
+        "request_method TEXT NOT NULL, "
+        "request_url TEXT NOT NULL, "
+        "request_url_no_query TEXT NOT NULL, "
+        "request_referrer TEXT NOT NULL, "
+        "request_headers_guard INTEGER NOT NULL, "
+        "request_mode INTEGER NOT NULL, "
+        "request_credentials INTEGER NOT NULL, "
+        "request_body_id TEXT NULL, "
+        "response_type INTEGER NOT NULL, "
+        "response_url TEXT NOT NULL, "
+        "response_status INTEGER NOT NULL, "
+        "response_status_text TEXT NOT NULL, "
+        "response_headers_guard INTEGER NOT NULL, "
+        "response_body_id TEXT NULL, "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_index "
+                "ON entries (request_url);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_no_query_index "
+                "ON entries (request_url_no_query);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE request_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE response_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // We need an index on response_headers, but not on request_headers,
+    // because we quickly need to determine if a VARY header is present.
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX response_headers_name_index "
+                "ON response_headers (name);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE storage ("
+        "namespace INTEGER NOT NULL, "
+        "key TEXT NOT NULL, "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id), "
+        "PRIMARY KEY(namespace, key) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->GetSchemaVersion(&schemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  if (schemaVersion != kLatestSchemaVersion) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CreateCache(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aCacheIdOut);
+
+  nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "INSERT INTO caches DEFAULT VALUES;"
+  ));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT last_insert_rowid()"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!hasMoreData)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                      nsTArray<nsID>& aDeletedBodyIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  // Delete the bodies explicitly as we need to read out the body IDs
+  // anyway.  These body IDs must be deleted one-by-one as content may
+  // still be referencing them invidivually.
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryAll(aConn, aCacheId, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Delete the remainder of the cache using cascade semantics.
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM caches WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::IsCacheOrphaned(mozIStorageConnection* aConn,
+                          CacheId aCacheId, bool* aOrphanedOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aOrphanedOut);
+
+  // err on the side of not deleting user data
+  *aOrphanedOut = false;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT COUNT(*) FROM storage WHERE cache_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  MOZ_ASSERT(hasMoreData);
+
+  int32_t refCount;
+  rv = state->GetInt32(0, &refCount);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aOrphanedOut = refCount < 1;
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
+                     const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams,
+                     bool* aFoundResponseOut,
+                     SavedResponse* aSavedResponseOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aFoundResponseOut);
+  MOZ_ASSERT(aSavedResponseOut);
+
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (matches.Length() < 1) {
+    *aFoundResponseOut = false;
+    return rv;
+  }
+
+  rv = ReadResponse(aConn, matches[0], aSavedResponseOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  aSavedResponseOut->mCacheId = aCacheId;
+  *aFoundResponseOut = true;
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                        const PCacheRequestOrVoid& aRequestOrVoid,
+                        const PCacheQueryParams& aParams,
+                        nsTArray<SavedResponse>& aSavedResponsesOut)
+{
+  MOZ_ASSERT(aConn);
+  nsresult rv;
+
+  nsTArray<EntryId> matches;
+  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+    rv = QueryAll(aConn, aCacheId, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
+  for (uint32_t i = 0; i < matches.Length(); ++i) {
+    SavedResponse *savedResponse = aSavedResponsesOut.AppendElement();
+    rv = ReadResponse(aConn, matches[i], savedResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    savedResponse->mCacheId = aCacheId;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
+                   const PCacheRequest& aRequest,
+                   const nsID* aRequestBodyId,
+                   const PCacheResponse& aResponse,
+                   const nsID* aResponseBodyId,
+                   nsTArray<nsID>& aDeletedBodyIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  PCacheQueryParams params(false, false, false, false, false,
+                           NS_LITERAL_STRING(""));
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryCache(aConn, aCacheId, aRequest, params, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = InsertEntry(aConn, aCacheId, aRequest, aRequestBodyId, aResponse,
+                   aResponseBodyId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
+                      const PCacheRequest& aRequest,
+                      const PCacheQueryParams& aParams,
+                      nsTArray<nsID>& aDeletedBodyIdListOut, bool* aSuccessOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSuccessOut);
+
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (matches.Length() < 1) {
+    *aSuccessOut = false;
+    return rv;
+  }
+
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aSuccessOut = true;
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
+                    const PCacheRequestOrVoid& aRequestOrVoid,
+                    const PCacheQueryParams& aParams,
+                    nsTArray<SavedRequest>& aSavedRequestsOut)
+{
+  MOZ_ASSERT(aConn);
+  nsresult rv;
+
+  nsTArray<EntryId> matches;
+  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+    rv = QueryAll(aConn, aCacheId, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
+  for (uint32_t i = 0; i < matches.Length(); ++i) {
+    SavedRequest *savedRequest = aSavedRequestsOut.AppendElement();
+    rv = ReadRequest(aConn, matches[i], savedRequest);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    savedRequest->mCacheId = aCacheId;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageMatch(mozIStorageConnection* aConn,
+                       Namespace aNamespace,
+                       const PCacheRequest& aRequest,
+                       const PCacheQueryParams& aParams,
+                       bool* aFoundResponseOut,
+                       SavedResponse* aSavedResponseOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aFoundResponseOut);
+  MOZ_ASSERT(aSavedResponseOut);
+
+  nsresult rv;
+
+  // If we are given a cache to check, then simply find its cache ID
+  // and perform the match.
+  if (!aParams.cacheName().EqualsLiteral("")) {
+    bool foundCache;
+    CacheId cacheId;
+    rv = StorageGetCacheId(aConn, aNamespace, aParams.cacheName(), &foundCache,
+                           &cacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (!foundCache) { return NS_ERROR_DOM_NOT_FOUND_ERR; }
+
+    rv = CacheMatch(aConn, cacheId, aRequest, aParams, aFoundResponseOut,
+                    aSavedResponseOut);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  // Otherwise we need to get a list of all the cache IDs in this namespace.
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT cache_id FROM storage WHERE namespace=?1 ORDER BY rowid;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsTArray<CacheId> cacheIdList;
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    CacheId* cacheId = cacheIdList.AppendElement();
+    rv = state->GetInt32(0, cacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // Now try to find a match in each cache in order
+  for (uint32_t i = 0; i < cacheIdList.Length(); ++i) {
+    rv = CacheMatch(aConn, cacheIdList[i], aRequest, aParams, aFoundResponseOut,
+                    aSavedResponseOut);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (*aFoundResponseOut) {
+      aSavedResponseOut->mCacheId = cacheIdList[i];
+      return rv;
+    }
+  }
+
+  return NS_ERROR_DOM_NOT_FOUND_ERR;
+}
+
+// static
+nsresult
+DBSchema::StorageGetCacheId(mozIStorageConnection* aConn, Namespace aNamespace,
+                            const nsAString& aKey, bool* aFoundCacheOut,
+                            CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aFoundCacheOut);
+  MOZ_ASSERT(aCacheIdOut);
+
+  *aFoundCacheOut = false;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT cache_id FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!hasMoreData) {
+    return rv;
+  }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aFoundCacheOut = true;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StoragePutCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                          const nsAString& aKey, CacheId aCacheId)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO storage (namespace, key, cache_id) VALUES(?1, ?2, ?3);"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(2, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageForgetCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                             const nsAString& aKey)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageGetKeys(mozIStorageConnection* aConn, Namespace aNamespace,
+                         nsTArray<nsString>& aKeysOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT key FROM storage WHERE namespace=?1 ORDER BY rowid;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString* key = aKeysOut.AppendElement();
+    rv = state->GetString(0, *key);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                   nsTArray<EntryId>& aEntryIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id FROM entries WHERE cache_id=?1 ORDER BY id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    EntryId* entryId = aEntryIdListOut.AppendElement();
+    rv = state->GetInt32(0, entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                     const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams,
+                     nsTArray<EntryId>& aEntryIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsTArray<PCacheRequest> requestArray;
+  nsTArray<PCacheResponse> responseArray;
+
+  if (!aParams.ignoreMethod() && !aRequest.method().LowerCaseEqualsLiteral("get")
+                              && !aRequest.method().LowerCaseEqualsLiteral("head"))
+  {
+    return NS_OK;
+  }
+
+  nsAutoCString query(
+    "SELECT id, COUNT(response_headers.name) AS vary_count "
+    "FROM entries "
+    "LEFT OUTER JOIN response_headers ON entries.id=response_headers.entry_id "
+                                    "AND response_headers.name='vary' "
+    "WHERE entries.cache_id=?1 "
+      "AND entries."
+  );
+
+  nsAutoString urlToMatch;
+  if (aParams.ignoreSearch()) {
+    urlToMatch = aRequest.urlWithoutQuery();
+    query.Append(NS_LITERAL_CSTRING("request_url_no_query"));
+  } else {
+    urlToMatch = aRequest.url();
+    query.Append(NS_LITERAL_CSTRING("request_url"));
+  }
+
+  if (aParams.prefixMatch()) {
+    query.Append(NS_LITERAL_CSTRING(" LIKE ?2 ESCAPE '\\'"));
+  } else {
+    query.Append(NS_LITERAL_CSTRING("=?2"));
+  }
+
+  query.Append(NS_LITERAL_CSTRING(" GROUP BY entries.id ORDER BY entries.id;"));
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (aParams.prefixMatch()) {
+    nsAutoString escapedUrlToMatch;
+    rv = state->EscapeStringForLIKE(urlToMatch, '\\', escapedUrlToMatch);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    urlToMatch = escapedUrlToMatch;
+    urlToMatch.AppendLiteral("%");
+  }
+
+  rv = state->BindStringParameter(1, urlToMatch);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    EntryId entryId;
+    rv = state->GetInt32(0, &entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t varyCount;
+    rv = state->GetInt32(1, &varyCount);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!aParams.ignoreVary() && varyCount > 0) {
+      bool matchedByVary;
+      rv = MatchByVaryHeader(aConn, aRequest, entryId, &matchedByVary);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (!matchedByVary) {
+        continue;
+      }
+    }
+
+    aEntryIdListOut.AppendElement(entryId);
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::MatchByVaryHeader(mozIStorageConnection* aConn,
+                            const PCacheRequest& aRequest,
+                            EntryId entryId, bool* aSuccessOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT value FROM response_headers "
+    "WHERE name='vary' AND entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, entryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsTArray<nsCString> varyValues;
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsCString* value = varyValues.AppendElement();
+    rv = state->GetUTF8String(0, *value);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Should not have called this function if this was not the case
+  MOZ_ASSERT(varyValues.Length() > 0);
+
+  state->Reset();
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT name, value FROM request_headers "
+    "WHERE entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, entryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<InternalHeaders> cachedHeaders = new InternalHeaders(HeadersGuardEnum::MozNone);
+
+  ErrorResult errorResult;
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsAutoCString name;
+    nsAutoCString value;
+    rv = state->GetUTF8String(0, name);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    rv = state->GetUTF8String(1, value);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    cachedHeaders->Append(name, value, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<InternalHeaders> queryHeaders = new InternalHeaders(aRequest.headers());
+
+  // Assume the vary headers match until we find a conflict
+  bool varyHeadersMatch = true;
+
+  for (uint32_t i = 0; i < varyValues.Length(); ++i) {
+    if (varyValues[i].EqualsLiteral("*")) {
+      continue;
+    }
+
+    nsAutoCString queryValue;
+    queryHeaders->Get(varyValues[i], queryValue, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+
+    nsAutoCString cachedValue;
+    cachedHeaders->Get(varyValues[i], cachedValue, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+
+    if (queryValue != cachedValue) {
+      varyHeadersMatch = false;
+      break;
+    }
+  }
+
+  *aSuccessOut = varyHeadersMatch;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::DeleteEntries(mozIStorageConnection* aConn,
+                        const nsTArray<EntryId>& aEntryIdList,
+                        nsTArray<nsID>& aDeletedBodyIdListOut,
+                        uint32_t aPos, int32_t aLen)
+{
+  MOZ_ASSERT(aConn);
+
+  if (aEntryIdList.Length() < 1) {
+    return NS_OK;
+  }
+
+  MOZ_ASSERT(aPos < aEntryIdList.Length());
+
+  if (aLen < 0) {
+    aLen = aEntryIdList.Length() - aPos;
+  }
+
+  // Sqlite limits the number of entries allowed for an IN clause,
+  // so split up larger operations.
+  if (aLen > kMaxEntriesPerStatement) {
+    uint32_t curPos = aPos;
+    int32_t remaining = aLen;
+    while (remaining > 0) {
+      int32_t max = kMaxEntriesPerStatement;
+      int32_t curLen = std::min(max, remaining);
+      nsresult rv = DeleteEntries(aConn, aEntryIdList, aDeletedBodyIdListOut,
+                                  curPos, curLen);
+      if (NS_FAILED(rv)) { return rv; }
+
+      curPos += curLen;
+      remaining -= curLen;
+    }
+    return NS_OK;
+  }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsAutoCString query(
+    "SELECT request_body_id, response_body_id FROM entries WHERE id IN ("
+  );
+  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  query.Append(NS_LITERAL_CSTRING(")"));
+
+  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    // extract 0 to 2 nsID structs per row
+    for (uint32_t i = 0; i < 2; ++i) {
+      bool isNull;
+
+      rv = state->GetIsNull(i, &isNull);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      if (!isNull) {
+        nsID* id = aDeletedBodyIdListOut.AppendElement();
+        rv = ExtractId(state, i, id);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      }
+    }
+  }
+
+  // Dependent records removed via ON DELETE CASCADE
+
+  query = NS_LITERAL_CSTRING(
+    "DELETE FROM entries WHERE id IN ("
+  );
+  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  query.Append(NS_LITERAL_CSTRING(")"));
+
+  rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
+                      const PCacheRequest& aRequest,
+                      const nsID* aRequestBodyId,
+                      const PCacheResponse& aResponse,
+                      const nsID* aResponseBodyId)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO entries ("
+      "request_method, "
+      "request_url, "
+      "request_url_no_query, "
+      "request_referrer, "
+      "request_headers_guard, "
+      "request_mode, "
+      "request_credentials, "
+      "request_body_id, "
+      "response_type, "
+      "response_url, "
+      "response_status, "
+      "response_status_text, "
+      "response_headers_guard, "
+      "response_body_id, "
+      "cache_id "
+    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindUTF8StringParameter(0, aRequest.method());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aRequest.url());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(2, aRequest.urlWithoutQuery());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(3, aRequest.referrer());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(4,
+    static_cast<int32_t>(aRequest.headersGuard()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(5, static_cast<int32_t>(aRequest.mode()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(6,
+    static_cast<int32_t>(aRequest.credentials()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindId(state, 7, aRequestBodyId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(8, static_cast<int32_t>(aResponse.type()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(9, aResponse.url());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(10, aResponse.status());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindUTF8StringParameter(11, aResponse.statusText());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(12,
+    static_cast<int32_t>(aResponse.headersGuard()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindId(state, 13, aResponseBodyId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(14, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT last_insert_rowid()"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t entryId;
+  rv = state->GetInt32(0, &entryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO request_headers ("
+      "name, "
+      "value, "
+      "entry_id "
+    ") VALUES (?1, ?2, ?3)"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers();
+  for (uint32_t i = 0; i < requestHeaders.Length(); ++i) {
+    rv = state->BindUTF8StringParameter(0, requestHeaders[i].name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindUTF8StringParameter(1, requestHeaders[i].value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindInt32Parameter(2, entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->Execute();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO response_headers ("
+      "name, "
+      "value, "
+      "entry_id "
+    ") VALUES (?1, ?2, ?3)"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers();
+  for (uint32_t i = 0; i < responseHeaders.Length(); ++i) {
+    rv = state->BindUTF8StringParameter(0, responseHeaders[i].name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindUTF8StringParameter(1, responseHeaders[i].value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindInt32Parameter(2, entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->Execute();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
+                       SavedResponse* aSavedResponseOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedResponseOut);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "response_type, "
+      "response_url, "
+      "response_status, "
+      "response_status_text, "
+      "response_headers_guard, "
+      "response_body_id "
+    "FROM entries "
+    "WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t type;
+  rv = state->GetInt32(0, &type);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mValue.type() = static_cast<ResponseType>(type);
+
+  rv = state->GetString(1, aSavedResponseOut->mValue.url());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t status;
+  rv = state->GetInt32(2, &status);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mValue.status() = status;
+
+  rv = state->GetUTF8String(3, aSavedResponseOut->mValue.statusText());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t guard;
+  rv = state->GetInt32(4, &guard);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mValue.headersGuard() =
+    static_cast<HeadersGuardEnum>(guard);
+
+  bool nullBody;
+  rv = state->GetIsNull(5, &nullBody);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mHasBodyId = !nullBody;
+
+  if (aSavedResponseOut->mHasBodyId) {
+    rv = ExtractId(state, 5, &aSavedResponseOut->mBodyId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "name, "
+      "value "
+    "FROM response_headers "
+    "WHERE entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    PHeadersEntry* header = aSavedResponseOut->mValue.headers().AppendElement();
+
+    rv = state->GetUTF8String(0, header->name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetUTF8String(1, header->value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
+                      SavedRequest* aSavedRequestOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedRequestOut);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "request_method, "
+      "request_url, "
+      "request_url_no_query, "
+      "request_referrer, "
+      "request_headers_guard, "
+      "request_mode, "
+      "request_credentials, "
+      "request_body_id "
+    "FROM entries "
+    "WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetUTF8String(0, aSavedRequestOut->mValue.method());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(1, aSavedRequestOut->mValue.url());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(2, aSavedRequestOut->mValue.urlWithoutQuery());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(3, aSavedRequestOut->mValue.referrer());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t guard;
+  rv = state->GetInt32(4, &guard);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.headersGuard() =
+    static_cast<HeadersGuardEnum>(guard);
+
+  int32_t mode;
+  rv = state->GetInt32(5, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.mode() = static_cast<RequestMode>(mode);
+
+  int32_t credentials;
+  rv = state->GetInt32(6, &credentials);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.credentials() =
+    static_cast<RequestCredentials>(credentials);
+
+  bool nullBody;
+  rv = state->GetIsNull(7, &nullBody);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mHasBodyId = !nullBody;
+
+  if (aSavedRequestOut->mHasBodyId) {
+    rv = ExtractId(state, 7, &aSavedRequestOut->mBodyId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "name, "
+      "value "
+    "FROM request_headers "
+    "WHERE entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    PHeadersEntry* header = aSavedRequestOut->mValue.headers().AppendElement();
+
+    rv = state->GetUTF8String(0, header->name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetUTF8String(1, header->value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+void
+DBSchema::AppendListParamsToQuery(nsACString& aQuery,
+                                  const nsTArray<EntryId>& aEntryIdList,
+                                  uint32_t aPos, int32_t aLen)
+{
+  MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
+  for (int32_t i = aPos; i < aLen; ++i) {
+    if (i == 0) {
+      aQuery.Append(NS_LITERAL_CSTRING("?"));
+    } else {
+      aQuery.Append(NS_LITERAL_CSTRING(",?"));
+    }
+  }
+}
+
+// static
+nsresult
+DBSchema::BindListParamsToQuery(mozIStorageStatement* aState,
+                                const nsTArray<EntryId>& aEntryIdList,
+                                uint32_t aPos, int32_t aLen)
+{
+  MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
+  for (int32_t i = aPos; i < aLen; ++i) {
+    nsresult rv = aState->BindInt32Parameter(i, aEntryIdList[i]);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  return NS_OK;
+}
+
+// static
+nsresult
+DBSchema::BindId(mozIStorageStatement* aState, uint32_t aPos, const nsID* aId)
+{
+  MOZ_ASSERT(aState);
+  nsresult rv;
+
+  if (!aId) {
+    rv = aState->BindNullParameter(aPos);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    return rv;
+  }
+
+  char idBuf[NSID_LENGTH];
+  aId->ToProvidedString(idBuf);
+  rv = aState->BindUTF8StringParameter(aPos, nsAutoCString(idBuf));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::ExtractId(mozIStorageStatement* aState, uint32_t aPos, nsID* aIdOut)
+{
+  MOZ_ASSERT(aState);
+  MOZ_ASSERT(aIdOut);
+
+  nsAutoCString idString;
+  nsresult rv = aState->GetUTF8String(aPos, idString);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool success = aIdOut->Parse(idString.get());
+  if (NS_WARN_IF(!success)) { return NS_ERROR_UNEXPECTED; }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.h
@@ -0,0 +1,139 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBSchema_h
+#define mozilla_dom_cache_DBSchema_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsError.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class mozIStorageStatement;
+struct nsID;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheQueryParams;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+class PCacheResponseOrVoid;
+struct SavedRequest;
+struct SavedResponse;
+
+class DBSchema MOZ_FINAL
+{
+public:
+  static nsresult CreateSchema(mozIStorageConnection* aConn);
+
+  static nsresult CreateCache(mozIStorageConnection* aConn,
+                              CacheId* aCacheIdOut);
+  // TODO: improve naming (confusing with CacheDelete) (bug 1110485)
+  static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                              nsTArray<nsID>& aDeletedBodyIdListOut);
+
+  // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code. (bug 1110446)
+  static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
+                                  CacheId aCacheId, bool* aOrphanedOut);
+
+  static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
+                             const PCacheRequest& aRequest,
+                             const PCacheQueryParams& aParams,
+                             bool* aFoundResponseOut,
+                             SavedResponse* aSavedResponseOut);
+  static nsresult CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                                const PCacheRequestOrVoid& aRequestOrVoid,
+                                const PCacheQueryParams& aParams,
+                                nsTArray<SavedResponse>& aSavedResponsesOut);
+  static nsresult CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
+                           const PCacheRequest& aRequest,
+                           const nsID* aRequestBodyId,
+                           const PCacheResponse& aResponse,
+                           const nsID* aResponseBodyId,
+                           nsTArray<nsID>& aDeletedBodyIdListOut);
+  static nsresult CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
+                              const PCacheRequest& aRequest,
+                              const PCacheQueryParams& aParams,
+                              nsTArray<nsID>& aDeletedBodyIdListOut,
+                              bool* aSuccessOut);
+  static nsresult CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
+                            const PCacheRequestOrVoid& aRequestOrVoid,
+                            const PCacheQueryParams& aParams,
+                            nsTArray<SavedRequest>& aSavedRequestsOut);
+
+  static nsresult StorageMatch(mozIStorageConnection* aConn,
+                               Namespace aNamespace,
+                               const PCacheRequest& aRequest,
+                               const PCacheQueryParams& aParams,
+                               bool* aFoundResponseOut,
+                               SavedResponse* aSavedResponseOut);
+  static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
+                                    Namespace aNamespace, const nsAString& aKey,
+                                    bool* aFoundCacheOut, CacheId* aCacheIdOut);
+  static nsresult StoragePutCache(mozIStorageConnection* aConn,
+                                  Namespace aNamespace, const nsAString& aKey,
+                                  CacheId aCacheId);
+  static nsresult StorageForgetCache(mozIStorageConnection* aConn,
+                                     Namespace aNamespace,
+                                     const nsAString& aKey);
+  static nsresult StorageGetKeys(mozIStorageConnection* aConn,
+                                 Namespace aNamespace,
+                                 nsTArray<nsString>& aKeysOut);
+
+private:
+  typedef int32_t EntryId;
+
+  static nsresult QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                           nsTArray<EntryId>& aEntryIdListOut);
+  static nsresult QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                             const PCacheRequest& aRequest,
+                             const PCacheQueryParams& aParams,
+                             nsTArray<EntryId>& aEntryIdListOut);
+  static nsresult MatchByVaryHeader(mozIStorageConnection* aConn,
+                                    const PCacheRequest& aRequest,
+                                    EntryId entryId, bool* aSuccessOut);
+  static nsresult DeleteEntries(mozIStorageConnection* aConn,
+                                const nsTArray<EntryId>& aEntryIdList,
+                                nsTArray<nsID>& aDeletedBodyIdListOut,
+                                uint32_t aPos=0, int32_t aLen=-1);
+  static nsresult InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
+                              const PCacheRequest& aRequest,
+                              const nsID* aRequestBodyId,
+                              const PCacheResponse& aResponse,
+                              const nsID* aResponseBodyId);
+  static nsresult ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
+                               SavedResponse* aSavedResponseOut);
+  static nsresult ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
+                              SavedRequest* aSavedRequestOut);
+
+  static void AppendListParamsToQuery(nsACString& aQuery,
+                                      const nsTArray<EntryId>& aEntryIdList,
+                                      uint32_t aPos, int32_t aLen);
+  static nsresult BindListParamsToQuery(mozIStorageStatement* aState,
+                                        const nsTArray<EntryId>& aEntryIdList,
+                                        uint32_t aPos, int32_t aLen);
+  static nsresult BindId(mozIStorageStatement* aState, uint32_t aPos,
+                         const nsID* aId);
+  static nsresult ExtractId(mozIStorageStatement* aState, uint32_t aPos,
+                            nsID* aIdOut);
+
+  DBSchema() MOZ_DELETE;
+  ~DBSchema() MOZ_DELETE;
+
+  static const int32_t kLatestSchemaVersion;
+  static const int32_t kMaxEntriesPerStatement;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBSchema_h
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.cpp
@@ -0,0 +1,443 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FetchPut.h"
+
+#include "mozilla/dom/Fetch.h"
+#include "mozilla/dom/FetchDriver.h"
+#include "mozilla/dom/Headers.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/PromiseNativeHandler.h"
+#include "mozilla/dom/Request.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/ResponseBinding.h"
+#include "mozilla/dom/UnionTypes.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "nsContentUtils.h"
+#include "nsNetUtil.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FetchPut::Runnable MOZ_FINAL : public nsRunnable
+{
+public:
+  Runnable(FetchPut* aFetchPut)
+    : mFetchPut(aFetchPut)
+  {
+    MOZ_ASSERT(mFetchPut);
+  }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    if (NS_IsMainThread())
+    {
+      mFetchPut->DoFetchOnMainThread();
+      return NS_OK;
+    }
+
+    MOZ_ASSERT(mFetchPut->mInitiatingThread == NS_GetCurrentThread());
+
+    mFetchPut->DoPutOnWorkerThread();
+
+    // The FetchPut object must ultimately be freed on the worker thread,
+    // so make sure we release our reference here.  The runnable may end
+    // up getting deleted on the main thread.
+    mFetchPut = nullptr;
+
+    return NS_OK;
+  }
+
+private:
+  nsRefPtr<FetchPut> mFetchPut;
+};
+
+class FetchPut::FetchObserver MOZ_FINAL : public FetchDriverObserver
+{
+public:
+  FetchObserver(FetchPut* aFetchPut)
+    : mFetchPut(aFetchPut)
+  {
+  }
+
+  virtual void OnResponseAvailable(InternalResponse* aResponse) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(!mInternalResponse);
+    mInternalResponse = aResponse;
+  }
+
+  virtual void OnResponseEnd() MOZ_OVERRIDE
+  {
+    mFetchPut->FetchComplete(this, mInternalResponse);
+    mFetchPut = nullptr;
+  }
+
+protected:
+  virtual ~FetchObserver() { }
+
+private:
+  nsRefPtr<FetchPut> mFetchPut;
+  nsRefPtr<InternalResponse> mInternalResponse;
+};
+
+// static
+nsresult
+FetchPut::Create(Listener* aListener, Manager* aManager,
+                 RequestId aRequestId, CacheId aCacheId,
+                 const nsTArray<PCacheRequest>& aRequests,
+                 const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
+                 FetchPut** aFetchPutOut)
+{
+  MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
+
+  // The FetchDriver requires that all requests have a referrer already set.
+#ifdef DEBUG
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    if (aRequests[i].referrer() == EmptyString()) {
+      return NS_ERROR_UNEXPECTED;
+    }
+  }
+#endif
+
+  nsRefPtr<FetchPut> ref = new FetchPut(aListener, aManager, aRequestId, aCacheId,
+                                        aRequests, aRequestStreams);
+
+  nsresult rv = ref->DispatchToMainThread();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  ref.forget(aFetchPutOut);
+
+  return NS_OK;
+}
+
+void
+FetchPut::ClearListener()
+{
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+FetchPut::FetchPut(Listener* aListener, Manager* aManager,
+                   RequestId aRequestId, CacheId aCacheId,
+                   const nsTArray<PCacheRequest>& aRequests,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams)
+  : mListener(aListener)
+  , mManager(aManager)
+  , mRequestId(aRequestId)
+  , mCacheId(aCacheId)
+  , mInitiatingThread(NS_GetCurrentThread())
+  , mStateList(aRequests.Length())
+  , mPendingCount(0)
+  , mResult(NS_OK)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
+
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    State* s = mStateList.AppendElement();
+    s->mPCacheRequest = aRequests[i];
+    s->mRequestStream = aRequestStreams[i];
+  }
+
+  mManager->AddRefCacheId(mCacheId);
+}
+
+FetchPut::~FetchPut()
+{
+  MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
+  MOZ_ASSERT(!mListener);
+  mManager->RemoveListener(this);
+  mManager->ReleaseCacheId(mCacheId);
+}
+
+nsresult
+FetchPut::DispatchToMainThread()
+{
+  MOZ_ASSERT(!mRunnable);
+
+  nsRefPtr<nsIRunnable> runnable = new Runnable(this);
+
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  MOZ_ASSERT(!mRunnable);
+  mRunnable = runnable.forget();
+
+  return NS_OK;
+}
+
+void
+FetchPut::DispatchToInitiatingThread()
+{
+  MOZ_ASSERT(mRunnable);
+
+  nsresult rv = mInitiatingThread->Dispatch(mRunnable,
+                                            nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch to worker thread after fetch completion.");
+  }
+
+  mRunnable = nullptr;
+}
+
+void
+FetchPut::DoFetchOnMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsRefPtr<ManagerId> managerId = mManager->GetManagerId();
+  nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
+  mPendingCount = mStateList.Length();
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    nsRefPtr<InternalRequest> internalRequest =
+      ToInternalRequest(mStateList[i].mPCacheRequest);
+
+    // If there is a stream we must clone it so that its still available
+    // to store in the cache later;
+    if (mStateList[i].mRequestStream) {
+      internalRequest->SetBody(mStateList[i].mRequestStream);
+      nsRefPtr<InternalRequest> clone = new InternalRequest(*internalRequest);
+
+      // The copy construction clone above can change the source stream,
+      // so get it back out to use when we put this in the cache.
+      internalRequest->GetBody(getter_AddRefs(mStateList[i].mRequestStream));
+
+      internalRequest = clone;
+    }
+
+    nsRefPtr<FetchDriver> fetchDriver = new FetchDriver(internalRequest,
+                                                        principal);
+
+    mStateList[i].mFetchObserver = new FetchObserver(this);
+    nsresult rv = fetchDriver->Fetch(mStateList[i].mFetchObserver);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      MaybeSetError(rv);
+      mStateList[i].mFetchObserver = nullptr;
+      mPendingCount -= 1;
+      continue;
+    }
+  }
+
+  // If they all failed, then we might need to complete main thread immediately
+  MaybeCompleteOnMainThread();
+}
+
+void
+FetchPut::FetchComplete(FetchObserver* aObserver,
+                        InternalResponse* aInternalResponse)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (aInternalResponse->IsError() && NS_SUCCEEDED(mResult)) {
+    MaybeSetError(NS_ERROR_FAILURE);
+  }
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    if (mStateList[i].mFetchObserver == aObserver) {
+      ErrorResult rv;
+      ToPCacheResponseWithoutBody(mStateList[i].mPCacheResponse,
+                                  *aInternalResponse, rv);
+      if (rv.Failed()) {
+        MaybeSetError(rv.ErrorCode());
+        return;
+      }
+      aInternalResponse->GetBody(getter_AddRefs(mStateList[i].mResponseStream));
+      mStateList[i].mFetchObserver = nullptr;
+      MOZ_ASSERT(mPendingCount > 0);
+      mPendingCount -= 1;
+      MaybeCompleteOnMainThread();
+      return;
+    }
+  }
+
+  MOZ_ASSERT_UNREACHABLE("Should never get called by unknown fetch observer.");
+}
+
+void
+FetchPut::MaybeCompleteOnMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (mPendingCount > 0) {
+    return;
+  }
+
+  DispatchToInitiatingThread();
+}
+
+void
+FetchPut::DoPutOnWorkerThread()
+{
+  MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
+
+  if (NS_FAILED(mResult)) {
+    MaybeNotifyListener();
+    return;
+  }
+
+  nsTArray<CacheRequestResponse> putList(mStateList.Length());
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreamList(mStateList.Length());
+  nsTArray<nsCOMPtr<nsIInputStream>> responseStreamList(mStateList.Length());
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    // The spec requires us to catch if content tries to insert a set of
+    // requests that would overwrite each other.
+    if (MatchInPutList(mStateList[i].mPCacheRequest, putList)) {
+      MaybeSetError(NS_ERROR_DOM_INVALID_STATE_ERR);
+      MaybeNotifyListener();
+      return;
+    }
+
+    CacheRequestResponse* entry = putList.AppendElement();
+    entry->request() = mStateList[i].mPCacheRequest;
+    entry->response() = mStateList[i].mPCacheResponse;
+    requestStreamList.AppendElement(mStateList[i].mRequestStream.forget());
+    responseStreamList.AppendElement(mStateList[i].mResponseStream.forget());
+  }
+  mStateList.Clear();
+
+  mManager->CachePutAll(this, mRequestId, mCacheId, putList, requestStreamList,
+                        responseStreamList);
+}
+
+// static
+bool
+FetchPut::MatchInPutList(const PCacheRequest& aRequest,
+                         const nsTArray<CacheRequestResponse>& aPutList)
+{
+  // This method implements the SW spec QueryCache algorithm against an
+  // in memory array of Request/Response objects.  This essentially the
+  // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
+  // we cannot unify them because when operating against the real database
+  // we don't want to load all request/response objects into memory.
+
+  if (!aRequest.method().LowerCaseEqualsLiteral("get") &&
+      !aRequest.method().LowerCaseEqualsLiteral("head")) {
+    return false;
+  }
+
+  nsRefPtr<InternalHeaders> requestHeaders =
+    new InternalHeaders(aRequest.headers());
+
+  for (uint32_t i = 0; i < aPutList.Length(); ++i) {
+    const PCacheRequest& cachedRequest = aPutList[i].request();
+    const PCacheResponse& cachedResponse = aPutList[i].response();
+
+    // If the URLs don't match, then just skip to the next entry.
+    if (aRequest.url() != cachedRequest.url()) {
+      continue;
+    }
+
+    nsRefPtr<InternalHeaders> cachedRequestHeaders =
+      new InternalHeaders(cachedRequest.headers());
+
+    nsRefPtr<InternalHeaders> cachedResponseHeaders =
+      new InternalHeaders(cachedResponse.headers());
+
+    nsTArray<nsCString> varyHeaders;
+    ErrorResult rv;
+    cachedResponseHeaders->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders, rv);
+    MOZ_ALWAYS_TRUE(!rv.Failed());
+
+    // Assume the vary headers match until we find a conflict
+    bool varyHeadersMatch = true;
+
+    for (uint32_t j = 0; j < varyHeaders.Length(); ++j) {
+      if (varyHeaders[i].EqualsLiteral("*")) {
+        continue;
+      }
+
+      // The VARY header could in theory contain an illegal header name.  So
+      // we need to detect the error in the Get() calls below.  Treat these
+      // as not matching.
+      ErrorResult headerRv;
+
+      nsAutoCString value;
+      requestHeaders->Get(varyHeaders[j], value, rv);
+      if (NS_WARN_IF(rv.Failed())) {
+        varyHeadersMatch = false;
+        break;
+      }
+
+      nsAutoCString cachedValue;
+      cachedRequestHeaders->Get(varyHeaders[j], value, rv);
+      if (NS_WARN_IF(rv.Failed())) {
+        varyHeadersMatch = false;
+        break;
+      }
+
+      if (value != cachedValue) {
+        varyHeadersMatch = false;
+        break;
+      }
+    }
+
+    // URL was equal and all vary headers match!
+    if (varyHeadersMatch) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void
+FetchPut::OnCachePutAll(RequestId aRequestId, nsresult aRv)
+{
+  MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
+  MaybeSetError(aRv);
+  MaybeNotifyListener();
+}
+
+void
+FetchPut::MaybeSetError(nsresult aRv)
+{
+  if (NS_FAILED(mResult) || NS_SUCCEEDED(aRv)) {
+    return;
+  }
+  mResult = aRv;
+}
+
+void
+FetchPut::MaybeNotifyListener()
+{
+  MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
+  if (!mListener) {
+    return;
+  }
+  mListener->OnFetchPut(this, mRequestId, mResult);
+}
+
+nsIGlobalObject*
+FetchPut::GetGlobalObject() const
+{
+  MOZ_CRASH("No global object in parent-size FetchPut operation!");
+}
+
+const nsACString&
+FetchPut::Origin() const
+{
+  nsRefPtr<ManagerId> managerId = mManager->GetManagerId();
+  return managerId->Origin();
+}
+
+#ifdef DEBUG
+void
+FetchPut::AssertOwningThread() const
+{
+  MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
+}
+#endif
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.h
@@ -0,0 +1,123 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FetchPut_h
+#define mozilla_dom_cache_FetchPut_h
+
+#include "AlreadyAddRefed.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "nsRefPtr.h"
+#include "nsTArray.h"
+#include <utility>
+
+class nsIInputStream;
+class nsIRunnable;
+class nsIThread;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class OwningRequestOrScalarValueString;
+class Promise;
+class Request;
+class RequestOrScalarValueString;
+class Response;
+template<typename T> class Sequence;
+
+namespace cache {
+
+class FetchPut MOZ_FINAL : public Manager::Listener
+                         , public TypeUtils
+{
+public:
+  typedef std::pair<nsRefPtr<Request>, nsRefPtr<Response>> PutPair;
+
+  class Listener
+  {
+  public:
+    virtual void
+    OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId, nsresult aRv)=0;
+  };
+
+  static nsresult
+  Create(Listener* aListener, Manager* aManager,
+         RequestId aRequestId, CacheId aCacheId,
+         const nsTArray<PCacheRequest>& aRequests,
+         const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
+         FetchPut** aFetchPutOut);
+
+  void ClearListener();
+
+private:
+  class Runnable;
+  class FetchObserver;
+  struct State
+  {
+    PCacheRequest mPCacheRequest;
+    nsCOMPtr<nsIInputStream> mRequestStream;
+    nsRefPtr<FetchObserver> mFetchObserver;
+    PCacheResponse mPCacheResponse;
+    nsCOMPtr<nsIInputStream> mResponseStream;
+
+    nsRefPtr<Request> mRequest;
+    nsRefPtr<Response> mResponse;
+  };
+
+  FetchPut(Listener* aListener, Manager* aManager,
+           RequestId aRequestId, CacheId aCacheId,
+           const nsTArray<PCacheRequest>& aRequests,
+           const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams);
+  ~FetchPut();
+
+  nsresult DispatchToMainThread();
+  void DispatchToInitiatingThread();
+
+  void DoFetchOnMainThread();
+  void FetchComplete(FetchObserver* aObserver,
+                     InternalResponse* aInternalResponse);
+  void MaybeCompleteOnMainThread();
+
+  void DoPutOnWorkerThread();
+  static bool MatchInPutList(const PCacheRequest& aRequest,
+                             const nsTArray<CacheRequestResponse>& aPutList);
+  virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+
+  void MaybeSetError(nsresult aRv);
+  void MaybeNotifyListener();
+
+  // TypeUtils methods
+  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+  virtual const nsACString& Origin() const MOZ_OVERRIDE;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
+  Listener* mListener;
+  nsRefPtr<Manager> mManager;
+  const RequestId mRequestId;
+  const CacheId mCacheId;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsTArray<State> mStateList;
+  uint32_t mPendingCount;
+  nsresult mResult;
+  nsCOMPtr<nsIRunnable> mRunnable;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(mozilla::dom::cache::FetchPut)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FetchPut_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.cpp
@@ -0,0 +1,313 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FileUtils.h"
+
+#include "mozilla/dom/quota/FileStreams.h"
+#include "mozilla/SnappyCompressOutputStream.h"
+#include "mozilla/unused.h"
+#include "nsIFile.h"
+#include "nsIUUIDGenerator.h"
+#include "nsNetUtil.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::FileInputStream;
+using mozilla::dom::quota::FileOutputStream;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::unused;
+
+// static
+nsresult
+FileUtils::BodyCreateDir(nsIFile* aBaseDir)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> aBodyDir;
+  nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = aBodyDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = aBodyDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    bool isDir;
+    rv = aBodyDir->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
+                           nsIFile** aCacheDirOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aCacheDirOut);
+
+  nsresult rv = aBaseDir->Clone(aCacheDirOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = (*aCacheDirOut)->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = (*aCacheDirOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  bool isDir;
+  rv = (*aCacheDirOut)->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  nsAutoString subDirName;
+  subDirName.AppendInt(aId.m3[7]);
+  rv = (*aCacheDirOut)->Append(subDirName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = (*aCacheDirOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = (*aCacheDirOut)->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = (*aCacheDirOut)->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyIdToFile(nsIFile* aBaseDir, const nsID& aId,
+                        BodyFileType aType, nsIFile** aBodyFileOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aBodyFileOut);
+
+  nsresult rv = BodyGetCacheDir(aBaseDir, aId, aBodyFileOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = (*aBodyFileOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  bool isDir;
+  rv = (*aBodyFileOut)->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  char idString[NSID_LENGTH];
+  aId.ToProvidedString(idString);
+
+  NS_ConvertUTF8toUTF16 fileName(idString);
+
+  if (aType == BODY_FILE_FINAL) {
+    fileName.Append(NS_LITERAL_STRING(".final"));
+  } else {
+    fileName.Append(NS_LITERAL_STRING(".tmp"));
+  }
+
+  rv = (*aBodyFileOut)->Append(fileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyStartWriteStream(const QuotaInfo& aQuotaInfo,
+                                nsIFile* aBaseDir, nsIInputStream* aSource,
+                                void* aClosure,
+                                nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                                nsISupports** aCopyContextOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aSource);
+  MOZ_ASSERT(aClosure);
+  MOZ_ASSERT(aCallback);
+  MOZ_ASSERT(aIdOut);
+  MOZ_ASSERT(aCopyContextOut);
+
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> idGen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = idGen->GenerateUUIDInPlace(aIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_TMP, getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIOutputStream> fileStream =
+    FileOutputStream::Create(PERSISTENCE_TYPE_DEFAULT, aQuotaInfo.mGroup,
+                             aQuotaInfo.mOrigin, tmpFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  nsRefPtr<SnappyCompressOutputStream> compressed =
+    new SnappyCompressOutputStream(fileStream);
+
+  rv = NS_AsyncCopy(aSource, compressed, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS,
+                    compressed->BlockSize(),
+                    aCallback, aClosure,
+                    true, true, // close streams
+                    aCopyContextOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+void
+FileUtils::BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
+                           nsISupports* aCopyContext)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aCopyContext);
+
+  nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
+  unused << NS_WARN_IF(NS_FAILED(rv));
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = tmpFile->Remove(false /* recursive */);
+  unused << NS_WARN_IF(NS_FAILED(rv));
+}
+
+// static
+nsresult
+FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> tmpFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL, getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> finalDir;
+  rv = finalFile->GetParent(getter_AddRefs(finalDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsAutoString finalFileName;
+  rv = finalFile->GetLeafName(finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->RenameTo(finalDir, finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
+                    const nsID& aId, nsIInputStream** aStreamOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aStreamOut);
+
+  nsCOMPtr<nsIFile> finalFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
+                             getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIInputStream> fileStream =
+    FileInputStream::Create(PERSISTENCE_TYPE_DEFAULT, aQuotaInfo.mGroup,
+                            aQuotaInfo.mOrigin, finalFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  fileStream.forget(aStreamOut);
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList)
+{
+  nsresult rv = NS_OK;
+
+  for (uint32_t i = 0; i < aIdList.Length(); ++i) {
+    nsCOMPtr<nsIFile> finalFile;
+    rv = BodyIdToFile(aBaseDir, aIdList[i], BODY_FILE_FINAL,
+                      getter_AddRefs(finalFile));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool exists;
+    rv = finalFile->Exists(&exists);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (NS_WARN_IF(!exists)) {
+      continue;
+    }
+
+    rv = finalFile->Remove(false /* recursive */);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FileUtils_h
+#define mozilla_dom_cache_FileUtils_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsStreamUtils.h"
+
+struct nsID;
+class nsIFile;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FileUtils MOZ_FINAL
+{
+public:
+  enum BodyFileType
+  {
+    BODY_FILE_FINAL,
+    BODY_FILE_TMP
+  };
+
+  static nsresult BodyCreateDir(nsIFile* aBaseDir);
+  static nsresult BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
+                                  nsIFile** aCacheDirOut);
+
+  static nsresult
+  BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+               nsIFile** aBodyFileOut);
+
+  static nsresult
+  BodyStartWriteStream(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
+                       nsIInputStream* aSource, void* aClosure,
+                       nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                       nsISupports** aCopyContextOut);
+
+  static void
+  BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
+                  nsISupports* aCopyContext);
+
+  static nsresult
+  BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
+
+  static nsresult
+  BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
+           nsIInputStream** aStreamOut);
+
+  static nsresult
+  BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
+
+private:
+  FileUtils() MOZ_DELETE;
+  ~FileUtils() MOZ_DELETE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FileUtils_h
diff --git a/dom/cache/IPCUtils.h b/dom/cache/IPCUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/IPCUtils.h
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_IPCUtils_h
+#define mozilla_dom_cache_IPCUtils_h
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/cache/Types.h"
+
+namespace IPC {
+  template<>
+  struct ParamTraits<mozilla::dom::cache::Namespace> :
+    public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
+                                    mozilla::dom::cache::DEFAULT_NAMESPACE,
+                                    mozilla::dom::cache::NUMBER_OF_NAMESPACES>
+  {};
+}
+
+#endif // mozilla_dom_cache_IPCUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.cpp
@@ -0,0 +1,1629 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Manager.h"
+
+#include "mozilla/dom/cache/DBAction.h"
+#include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/FileUtils.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/dom/cache/ShutdownObserver.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozStorageHelper.h"
+#include "nsAutoPtr.h"
+#include "nsIInputStream.h"
+#include "nsID.h"
+#include "nsIFile.h"
+#include "nsIThread.h"
+
+namespace {
+
+using mozilla::dom::cache::DBSchema;
+using mozilla::dom::cache::FileUtils;
+using mozilla::dom::cache::QuotaInfo;
+using mozilla::dom::cache::SyncDBAction;
+
+class SetupAction MOZ_FINAL : public SyncDBAction
+{
+public:
+  SetupAction()
+    : SyncDBAction(DBAction::Create)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    // TODO: init maintainance marker (bug 1110446)
+    // TODO: perform maintainance if necessary (bug 1110446)
+    // TODO: find orphaned caches in database (bug 1110446)
+    // TODO: have Context create/delete marker files in constructor/destructor
+    //       and only do expensive maintenance if that marker is present (bug 1110446)
+
+    nsresult rv = FileUtils::BodyCreateDir(aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    rv = DBSchema::CreateSchema(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+private:
+  virtual ~SetupAction() { }
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager::Factory
+{
+private:
+  static Factory* sFactory;
+  nsTArray<Manager*> mManagerList;
+
+public:
+  static Factory& Instance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      sFactory = new Factory();
+    }
+    return *sFactory;
+  }
+
+  already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    nsRefPtr<Manager> ref = Get(aManagerId);
+    if (!ref) {
+      ref = new Manager(aManagerId);
+      mManagerList.AppendElement(ref);
+    }
+
+    return ref.forget();
+  }
+
+  already_AddRefed<Manager> Get(ManagerId* aManagerId)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (*mManagerList[i]->mManagerId == *aManagerId) {
+        nsRefPtr<Manager> ref = mManagerList[i];
+        return ref.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i] == aManager) {
+        mManagerList.RemoveElementAt(i);
+
+        if (mManagerList.Length() < 1) {
+          delete sFactory;
+          sFactory = nullptr;
+        }
+        return;
+      }
+    }
+  }
+};
+
+// static
+Manager::Factory* Manager::Factory::sFactory = nullptr;
+
+class Manager::BaseAction : public SyncDBAction
+{
+protected:
+  BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
+    : SyncDBAction(DBAction::Existing)
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId (aRequestId)
+  { }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv)=0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    Listener* listener = mManager->GetListener(mListenerId);
+    if (!listener) {
+      return;
+    }
+    Complete(listener, aRv);
+    mManager = nullptr;
+  }
+
+  virtual ~BaseAction() { }
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
+};
+
+class Manager::DeleteOrphanedBodyAction MOZ_FINAL : public Action
+{
+public:
+  DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
+    : mDeletedBodyIdList(aDeletedBodyIdList)
+  { }
+
+  DeleteOrphanedBodyAction(const nsID& aBodyId)
+  {
+    mDeletedBodyIdList.AppendElement(aBodyId);
+  }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aResolver);
+    MOZ_ASSERT(aQuotaInfo.mDir);
+
+    nsCOMPtr<nsIFile> dbDir;
+    nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    rv = dbDir->Append(NS_LITERAL_STRING("cache"));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    rv = FileUtils::BodyDeleteFiles(dbDir, mDeletedBodyIdList);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    aResolver->Resolve(rv);
+  }
+
+private:
+  virtual ~DeleteOrphanedBodyAction() { }
+  nsTArray<nsID> mDeletedBodyIdList;
+};
+
+class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
+{
+public:
+  DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
+    : SyncDBAction(DBAction::Existing)
+    , mManager(aManager)
+    , mCacheId(aCacheId)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::DeleteCache(aConn, mCacheId, mDeletedBodyIdList);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
+    mManager = nullptr;
+  }
+
+private:
+  virtual ~DeleteOrphanedCacheAction() { }
+  nsRefPtr<Manager> mManager;
+  const CacheId mCacheId;
+  nsTArray<nsID> mDeletedBodyIdList;
+};
+
+class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  CacheMatchAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, CacheId aCacheId,
+                   const PCacheRequest& aRequest,
+                   const PCacheQueryParams& aParams,
+                   StreamList* aStreamList)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequest(aRequest)
+    , mParams(aParams)
+    , mStreamList(aStreamList)
+    , mFoundResponse(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    nsresult rv = DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
+                                       &mFoundResponse, &mResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mResponse.mBodyId, stream);
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (!mFoundResponse) {
+      aListener->OnCacheMatch(mRequestId, aRv, nullptr, nullptr);
+    } else {
+      mStreamList->Activate(mCacheId);
+      aListener->OnCacheMatch(mRequestId, aRv, &mResponse, mStreamList);
+    }
+    mStreamList = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+protected:
+  virtual ~CacheMatchAction() { }
+  const CacheId mCacheId;
+  const PCacheRequest mRequest;
+  const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
+  bool mFoundResponse;
+  SavedResponse mResponse;
+};
+
+class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, CacheId aCacheId,
+                      const PCacheRequestOrVoid& aRequestOrVoid,
+                      const PCacheQueryParams& aParams,
+                      StreamList* aStreamList)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequestOrVoid(aRequestOrVoid)
+    , mParams(aParams)
+    , mStreamList(aStreamList)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    nsresult rv = DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid,
+                                          mParams, mSavedResponses);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
+      if (!mSavedResponses[i].mHasBodyId) {
+        continue;
+      }
+
+      nsCOMPtr<nsIInputStream> stream;
+      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
+                               mSavedResponses[i].mBodyId,
+                               getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+      mStreamList->Add(mSavedResponses[i].mBodyId, stream);
+    }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    mStreamList->Activate(mCacheId);
+    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses, mStreamList);
+    mStreamList = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+protected:
+  virtual ~CacheMatchAllAction() { }
+  const CacheId mCacheId;
+  const PCacheRequestOrVoid mRequestOrVoid;
+  const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
+  nsTArray<SavedResponse> mSavedResponses;
+};
+
+class Manager::CachePutAllAction MOZ_FINAL : public DBAction
+{
+public:
+  CachePutAllAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, CacheId aCacheId,
+                    const nsTArray<CacheRequestResponse>& aPutList,
+                    const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                    const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
+    : DBAction(DBAction::Existing)
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId(aRequestId)
+    , mCacheId(aCacheId)
+    , mList(aPutList.Length())
+    , mExpectedAsyncCopyCompletions(0)
+  {
+    MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
+    MOZ_ASSERT(aPutList.Length() == aResponseStreamList.Length());
+
+    for (uint32_t i = 0; i < aPutList.Length(); ++i) {
+      Entry* entry = mList.AppendElement();
+      entry->mRequest = aPutList[i].request();
+      entry->mRequestStream = aRequestStreamList[i];
+      entry->mResponse = aPutList[i].response();
+      entry->mResponseStream = aResponseStreamList[i];
+
+      mExpectedAsyncCopyCompletions += entry->mRequestStream ? 1 : 0;
+      mExpectedAsyncCopyCompletions += entry->mResponseStream ? 1 : 0;
+    }
+  }
+
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aResolver);
+    MOZ_ASSERT(aDBDir);
+    MOZ_ASSERT(aConn);
+    MOZ_ASSERT(!mResolver);
+    MOZ_ASSERT(!mDBDir);
+    MOZ_ASSERT(!mConn);
+
+    mResolver = aResolver;
+    mDBDir = aDBDir;
+    mConn = aConn;
+
+    if (mExpectedAsyncCopyCompletions < 1) {
+      mExpectedAsyncCopyCompletions = 1;
+      OnAsyncCopyComplete(NS_OK);
+      return;
+    }
+
+    nsresult rv = NS_OK;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      rv = StartStreamCopy(aQuotaInfo, mList[i].mRequestStream,
+                           &mList[i].mRequestBodyId,
+                           getter_AddRefs(mList[i].mRequestCopyContext));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        CancelAllStreamCopying();
+        DoResolve(rv);
+        return;
+      }
+
+      rv = StartStreamCopy(aQuotaInfo, mList[i].mResponseStream,
+                           &mList[i].mResponseBodyId,
+                           getter_AddRefs(mList[i].mResponseCopyContext));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        CancelAllStreamCopying();
+        DoResolve(rv);
+        return;
+      }
+    }
+  }
+
+  void
+  OnAsyncCopyComplete(nsresult aRv)
+  {
+    MOZ_ASSERT(mConn);
+    MOZ_ASSERT(mResolver);
+    MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
+
+    // When DoResolve() is called below the "this" object can get destructed
+    // out from under us on the initiating thread.  Ensure that we cleanly
+    // run to completion in this scope before destruction.
+    nsRefPtr<Action> kungFuDeathGrip = this;
+
+    if (NS_FAILED(aRv)) {
+      DoResolve(aRv);
+      return;
+    }
+
+    mExpectedAsyncCopyCompletions -= 1;
+    if (mExpectedAsyncCopyCompletions > 0) {
+      return;
+    }
+
+    mozStorageTransaction trans(mConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = NS_OK;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      Entry& e = mList[i];
+      if (e.mRequestStream) {
+        e.mRequestCopyContext = nullptr;
+        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mRequestBodyId);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          DoResolve(rv);
+          return;
+        }
+      }
+      if (e.mResponseStream) {
+        e.mResponseCopyContext = nullptr;
+        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mResponseBodyId);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          DoResolve(rv);
+          return;
+        }
+      }
+
+      rv = DBSchema::CachePut(mConn, mCacheId, e.mRequest,
+                              e.mRequestStream ? &e.mRequestBodyId : nullptr,
+                              e.mResponse,
+                              e.mResponseStream ? &e.mResponseBodyId : nullptr,
+                              mDeletedBodyIdList);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        DoResolve(rv);
+        return;
+      }
+    }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+
+    DoResolve(rv);
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(Action);
+
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      mList[i].mRequestStream = nullptr;
+      mList[i].mResponseStream = nullptr;
+    }
+
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
+
+    Listener* listener = mManager->GetListener(mListenerId);
+    mManager = nullptr;
+    if (!listener) {
+      return;
+    }
+    listener->OnCachePutAll(mRequestId, aRv);
+  }
+
+  virtual void
+  CancelOnTarget() MOZ_OVERRIDE
+  {
+    CancelAllStreamCopying();
+    mConn = nullptr;
+    mResolver = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+private:
+  virtual ~CachePutAllAction() { }
+
+  nsresult
+  StartStreamCopy(const QuotaInfo& aQuotaInfo, nsIInputStream* aSource,
+                  nsID* aIdOut, nsISupports** aCopyContextOut)
+  {
+    MOZ_ASSERT(aIdOut);
+    MOZ_ASSERT(aCopyContextOut);
+    MOZ_ASSERT(mDBDir);
+
+    if (!aSource) {
+      return NS_OK;
+    }
+
+    nsresult rv = FileUtils::BodyStartWriteStream(aQuotaInfo, mDBDir, aSource,
+                                                  this, AsyncCopyCompleteFunc,
+                                                  aIdOut, aCopyContextOut);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  void
+  CancelAllStreamCopying()
+  {
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      Entry& e = mList[i];
+      if (e.mRequestStream && e.mRequestCopyContext) {
+        CancelStreamCopy(e.mRequestStream, e.mRequestCopyContext,
+                         e.mRequestBodyId);
+        e.mRequestCopyContext = nullptr;
+      }
+      if (e.mResponseStream && e.mResponseCopyContext) {
+        CancelStreamCopy(e.mResponseStream, e.mResponseCopyContext,
+                         e.mResponseBodyId);
+        e.mResponseCopyContext = nullptr;
+      }
+    }
+  }
+
+  void
+  CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
+                   const nsID& aId)
+  {
+    if (!aSource || !aCopyContext) {
+      return;
+    }
+    FileUtils::BodyCancelWrite(mDBDir, aId, aCopyContext);
+  }
+
+  static void
+  AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
+  {
+    MOZ_ASSERT(aClosure);
+    CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
+    action->OnAsyncCopyComplete(aRv);
+  }
+
+  void
+  DoResolve(nsresult aRv)
+  {
+    if (NS_FAILED(aRv)) {
+      CancelAllStreamCopying();
+    }
+
+    mConn = nullptr;
+
+    nsRefPtr<Resolver> resolver;
+    mResolver.swap(resolver);
+
+    if (resolver) {
+      // This can trigger self destruction if a self-ref is not held by the
+      // caller.
+      resolver->Resolve(aRv);
+    }
+  }
+
+  struct Entry
+  {
+    PCacheRequest mRequest;
+    nsCOMPtr<nsIInputStream> mRequestStream;
+    nsID mRequestBodyId;
+    nsCOMPtr<nsISupports> mRequestCopyContext;
+
+    PCacheResponse mResponse;
+    nsCOMPtr<nsIInputStream> mResponseStream;
+    nsID mResponseBodyId;
+    nsCOMPtr<nsISupports> mResponseCopyContext;
+  };
+
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
+  const CacheId mCacheId;
+  nsTArray<Entry> mList;
+  nsRefPtr<Resolver> mResolver;
+  nsCOMPtr<nsIFile> mDBDir;
+  nsCOMPtr<mozIStorageConnection> mConn;
+  uint32_t mExpectedAsyncCopyCompletions;
+  nsTArray<nsID> mDeletedBodyIdList;
+};
+
+class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, CacheId aCacheId,
+                    const PCacheRequest& aRequest,
+                    const PCacheQueryParams& aParams)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequest(aRequest)
+    , mParams(aParams)
+    , mSuccess(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::CacheDelete(aConn, mCacheId, mRequest, mParams,
+                                        mDeletedBodyIdList, &mSuccess);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mSuccess = false;
+      return rv;
+    }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
+    aListener->OnCacheDelete(mRequestId, aRv, mSuccess);
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+protected:
+  virtual ~CacheDeleteAction() { }
+  const CacheId mCacheId;
+  const PCacheRequest mRequest;
+  const PCacheQueryParams mParams;
+  bool mSuccess;
+  nsTArray<nsID> mDeletedBodyIdList;
+};
+
+class Manager::CacheKeysAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  CacheKeysAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, CacheId aCacheId,
+                    const PCacheRequestOrVoid& aRequestOrVoid,
+                    const PCacheQueryParams& aParams,
+                    StreamList* aStreamList)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequestOrVoid(aRequestOrVoid)
+    , mParams(aParams)
+    , mStreamList(aStreamList)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    nsresult rv = DBSchema::CacheKeys(aConn, mCacheId, mRequestOrVoid, mParams,
+                                      mSavedRequests);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
+      if (!mSavedRequests[i].mHasBodyId) {
+        continue;
+      }
+
+      nsCOMPtr<nsIInputStream> stream;
+      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
+                               mSavedRequests[i].mBodyId,
+                               getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+      mStreamList->Add(mSavedRequests[i].mBodyId, stream);
+    }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    mStreamList->Activate(mCacheId);
+    aListener->OnCacheKeys(mRequestId, aRv, mSavedRequests, mStreamList);
+    mStreamList = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+protected:
+  virtual ~CacheKeysAction() { }
+  const CacheId mCacheId;
+  const PCacheRequestOrVoid mRequestOrVoid;
+  const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
+  nsTArray<SavedRequest> mSavedRequests;
+};
+
+class Manager::StorageMatchAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageMatchAction(Manager* aManager, ListenerId aListenerId,
+                     RequestId aRequestId, Namespace aNamespace,
+                     const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams,
+                     StreamList* aStreamList)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mRequest(aRequest)
+    , mParams(aParams)
+    , mStreamList(aStreamList)
+    , mFoundResponse(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    nsresult rv = DBSchema::StorageMatch(aConn, mNamespace, mRequest, mParams,
+                                         &mFoundResponse, &mSavedResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mSavedResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mSavedResponse.mBodyId, stream);
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (!mFoundResponse) {
+      aListener->OnStorageMatch(mRequestId, aRv, nullptr, nullptr);
+    } else {
+      mStreamList->Activate(mSavedResponse.mCacheId);
+      aListener->OnStorageMatch(mRequestId, aRv, &mSavedResponse, mStreamList);
+    }
+    mStreamList = nullptr;
+  }
+
+protected:
+  virtual ~StorageMatchAction() { }
+  const Namespace mNamespace;
+  const PCacheRequest mRequest;
+  const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
+  bool mFoundResponse;
+  SavedResponse mSavedResponse;
+};
+
+class Manager::StorageHasAction : public Manager::BaseAction
+{
+public:
+  StorageHasAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, Namespace aNamespace,
+                   const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheFound(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    CacheId cacheId;
+    return DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
+                                       &mCacheFound, &cacheId);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageHas(mRequestId, aRv, mCacheFound);
+  }
+
+protected:
+  virtual ~StorageHasAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheFound;
+};
+
+class Manager::StorageOpenAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageOpenAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, Namespace aNamespace,
+                    const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    // Look for existing cache
+    bool cacheFound;
+    nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
+                                              &cacheFound, &mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (cacheFound) {
+      return rv;
+    }
+
+    // Cache does not exist, create it instead
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    rv = DBSchema::CreateCache(aConn, &mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = DBSchema::StoragePutCache(aConn, mNamespace, mKey, mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageOpen(mRequestId, aRv, mCacheId);
+  }
+
+private:
+  virtual ~StorageOpenAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  CacheId mCacheId;
+};
+
+class Manager::StorageDeleteAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageDeleteAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace,
+                      const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheDeleted(false)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    bool exists;
+    nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey, &exists,
+                                              &mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!exists) {
+      mCacheDeleted = false;
+      return NS_OK;
+    }
+
+    rv = DBSchema::StorageForgetCache(aConn, mNamespace, mKey);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    mCacheDeleted = true;
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (mCacheDeleted) {
+      // If content is referencing this cache, mark it orphaned to be
+      // deleted later.
+      if (!mManager->SetCacheIdOrphanedIfRefed(mCacheId)) {
+
+        // no outstanding references, delete immediately
+        mManager->CurrentContext()->CancelForCacheId(mCacheId);
+        nsRefPtr<Action> action =
+          new DeleteOrphanedCacheAction(mManager, mCacheId);
+        mManager->CurrentContext()->Dispatch(mManager->mIOThread, action);
+      }
+    }
+
+    aListener->OnStorageDelete(mRequestId, aRv, mCacheDeleted);
+  }
+
+private:
+  virtual ~StorageDeleteAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheDeleted;
+  CacheId mCacheId;
+};
+
+class Manager::StorageKeysAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageKeysAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::StorageGetKeys(aConn, mNamespace, mKeys);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (NS_FAILED(aRv)) {
+      mKeys.Clear();
+    }
+    aListener->OnStorageKeys(mRequestId, aRv, mKeys);
+  }
+
+private:
+  virtual ~StorageKeysAction() { }
+  const Namespace mNamespace;
+  nsTArray<nsString> mKeys;
+};
+
+Manager::StreamList::StreamList(Manager* aManager, Context* aContext)
+  : mManager(aManager)
+  , mContext(aContext)
+  , mCacheId(0)
+  , mStreamControl(nullptr)
+  , mActivated(false)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mContext);
+}
+
+void
+Manager::StreamList::SetStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(aStreamControl);
+
+  // For cases where multiple streams are serialized for a single list
+  // then the control will get passed multiple times.  This ok, but
+  // it should be the same control each time.
+  if (mStreamControl) {
+    MOZ_ASSERT(aStreamControl == mStreamControl);
+    return;
+  }
+
+  mStreamControl = aStreamControl;
+  mStreamControl->SetStreamList(this);
+}
+
+void
+Manager::StreamList::RemoveStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(mStreamControl);
+  mStreamControl = nullptr;
+}
+
+void
+Manager::StreamList::Activate(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mActivated);
+  MOZ_ASSERT(!mCacheId);
+  mActivated = true;
+  mCacheId = aCacheId;
+  mManager->AddRefCacheId(mCacheId);
+  mManager->AddStreamList(this);
+
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    mManager->AddRefBodyId(mList[i].mId);
+  }
+}
+
+void
+Manager::StreamList::Add(const nsID& aId, nsIInputStream* aStream)
+{
+  // All streams should be added on IO thread before we set the stream
+  // control on the owning IPC thread.
+  MOZ_ASSERT(!mStreamControl);
+  MOZ_ASSERT(aStream);
+  Entry* entry = mList.AppendElement();
+  entry->mId = aId;
+  entry->mStream = aStream;
+}
+
+already_AddRefed<nsIInputStream>
+Manager::StreamList::Extract(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      return mList[i].mStream.forget();
+    }
+  }
+  return nullptr;
+}
+
+void
+Manager::StreamList::NoteClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      mList.RemoveElementAt(i);
+      mManager->ReleaseBodyId(aId);
+      break;
+    }
+  }
+
+  if (mList.IsEmpty() && mStreamControl) {
+    mStreamControl->Shutdown();
+  }
+}
+
+void
+Manager::StreamList::NoteClosedAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    mManager->ReleaseBodyId(mList[i].mId);
+  }
+  mList.Clear();
+
+  if (mStreamControl) {
+    mStreamControl->Shutdown();
+  }
+}
+
+void
+Manager::StreamList::Close(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->Close(aId);
+  }
+}
+
+void
+Manager::StreamList::CloseAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->CloseAll();
+  }
+}
+
+Manager::StreamList::~StreamList()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+  if (mActivated) {
+    mManager->RemoveStreamList(this);
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      mManager->ReleaseBodyId(mList[i].mId);
+    }
+    mManager->ReleaseCacheId(mCacheId);
+  }
+}
+
+// static
+already_AddRefed<Manager>
+Manager::GetOrCreate(ManagerId* aManagerId)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().GetOrCreate(aManagerId);
+}
+
+// static
+already_AddRefed<Manager>
+Manager::Get(ManagerId* aManagerId)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().Get(aManagerId);
+}
+
+void
+Manager::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+Manager::AddRefCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      mCacheIdRefs[i].mCount += 1;
+      return;
+    }
+  }
+  CacheIdRefCounter* entry = mCacheIdRefs.AppendElement();
+  entry->mCacheId = aCacheId;
+  entry->mCount = 1;
+  entry->mOrphaned = false;
+}
+
+void
+Manager::ReleaseCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
+      mCacheIdRefs[i].mCount -= 1;
+      MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
+      if (mCacheIdRefs[i].mCount < 1) {
+        bool orphaned = mCacheIdRefs[i].mOrphaned;
+        mCacheIdRefs.RemoveElementAt(i);
+        // TODO: note that we need to check this cache for staleness on startup (bug 1110446)
+        if (orphaned && !mShuttingDown) {
+          CurrentContext()->CancelForCacheId(aCacheId);
+          nsRefPtr<Action> action = new DeleteOrphanedCacheAction(this,
+                                                                  aCacheId);
+          CurrentContext()->Dispatch(mIOThread, action);
+        }
+      }
+      return;
+    }
+  }
+  MOZ_ASSERT_UNREACHABLE("Attempt to release CacheId that is not referenced!");
+}
+
+bool
+Manager::SetCacheIdOrphanedIfRefed(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
+      MOZ_ASSERT(!mCacheIdRefs[i].mOrphaned);
+      mCacheIdRefs[i].mOrphaned = true;
+      return true;
+    }
+  }
+  return false;
+}
+
+void
+Manager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  mShuttingDown = true;
+  for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
+    mStreamLists[i]->CloseAll();
+  }
+
+  // If there is no context, then note that we're done shutting down
+  if (!mContext) {
+    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+    if (so) {
+      so->RemoveManagerId(mManagerId);
+    }
+
+  // Otherwise, cancel the context and note complete when it cleans up
+  } else {
+    mContext->CancelAll();
+  }
+}
+
+already_AddRefed<ManagerId>
+Manager::GetManagerId() const
+{
+  nsRefPtr<ManagerId> ref = mManagerId;
+  return ref.forget();
+}
+
+void
+Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                    const PCacheRequest& aRequest,
+                    const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheMatch(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                            nullptr, nullptr);
+    return;
+  }
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
+                                                 aCacheId, aRequest, aParams,
+                                                 streamList);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
+                       CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
+                       const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheMatchAll(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                               nsTArray<SavedResponse>(), nullptr);
+    return;
+  }
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
+                                                    aCacheId, aRequest, aParams,
+                                                    streamList);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::CachePutAll(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                     const nsTArray<CacheRequestResponse>& aPutList,
+                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCachePutAll(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CachePutAllAction(this, listenerId, aRequestId,
+                                                  aCacheId, aPutList,
+                                                  aRequestStreamList,
+                                                  aResponseStreamList);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
+                     CacheId aCacheId, const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheDelete(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN, false);
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheDeleteAction(this, listenerId, aRequestId,
+                                                  aCacheId, aRequest, aParams);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::CacheKeys(Listener* aListener, RequestId aRequestId,
+                   CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                   const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheKeys(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                           nsTArray<SavedRequest>(), nullptr);
+    return;
+  }
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheKeysAction(this, listenerId, aRequestId,
+                                                aCacheId, aRequestOrVoid,
+                                                aParams, streamList);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageMatch(Listener* aListener, RequestId aRequestId,
+                      Namespace aNamespace, const PCacheRequest& aRequest,
+                      const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageMatch(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                              nullptr, nullptr);
+    return;
+  }
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageMatchAction(this, listenerId, aRequestId,
+                                                   aNamespace, aRequest,
+                                                   aParams, streamList);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageHas(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageHas(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                            false);
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageHasAction(this, listenerId, aRequestId,
+                                                 aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageOpen(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageOpen(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN, 0);
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageOpenAction(this, listenerId, aRequestId,
+                                                  aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageDelete(Listener* aListener, RequestId aRequestId,
+                       Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageDelete(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                               false);
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageDeleteAction(this, listenerId, aRequestId,
+                                                    aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageKeys(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageKeys(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                             nsTArray<nsString>());
+    return;
+  }
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageKeysAction(this, listenerId, aRequestId,
+                                                  aNamespace);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::RemoveContext(Context* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+  mContext = nullptr;
+
+  if (mShuttingDown) {
+    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+    if (so) {
+      so->RemoveManagerId(mManagerId);
+    }
+  }
+}
+
+Manager::Manager(ManagerId* aManagerId)
+  : mManagerId(aManagerId)
+  , mContext(nullptr)
+  , mShuttingDown(false)
+{
+  MOZ_ASSERT(mManagerId);
+
+  nsresult rv = NS_NewNamedThread("DOMCacheThread",
+                                  getter_AddRefs(mIOThread));
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to spawn cache manager IO thread.");
+  }
+
+  nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+  if (so) {
+    so->AddManagerId(mManagerId);
+  } else {
+    Shutdown();
+  }
+}
+
+Manager::~Manager()
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  Shutdown();
+  Factory::Instance().Remove(this);
+  mIOThread->Shutdown();
+}
+
+Context*
+Manager::CurrentContext()
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  if (!mContext) {
+    MOZ_ASSERT(!mShuttingDown);
+    nsRefPtr<Action> setupAction = new SetupAction();
+    mContext = new Context(this, mManagerId, setupAction);
+  }
+  return mContext;
+}
+
+Manager::ListenerId
+Manager::SaveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (mListeners[i] == aListener) {
+      return reinterpret_cast<ListenerId>(aListener);
+    }
+  }
+  mListeners.AppendElement(aListener);
+  return reinterpret_cast<ListenerId>(aListener);
+}
+
+Manager::Listener*
+Manager::GetListener(ListenerId aListenerId) const
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
+      return mListeners[i];
+    }
+  }
+  return nullptr;
+}
+
+void
+Manager::AddStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.AppendElement(aStreamList);
+}
+
+void
+Manager::RemoveStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.RemoveElement(aStreamList);
+}
+
+void
+Manager::AddRefBodyId(const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      mBodyIdRefs[i].mCount += 1;
+      return;
+    }
+  }
+  BodyIdRefCounter* entry = mBodyIdRefs.AppendElement();
+  entry->mBodyId = aBodyId;
+  entry->mCount = 1;
+  entry->mOrphaned = false;
+}
+
+void
+Manager::ReleaseBodyId(const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
+      mBodyIdRefs[i].mCount -= 1;
+      MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
+      if (mBodyIdRefs[i].mCount < 1) {
+        bool orphaned = mBodyIdRefs[i].mOrphaned;
+        mBodyIdRefs.RemoveElementAt(i);
+        // TODO: note that we need to check this body for staleness on startup (bug 1110446)
+        if (orphaned && !mShuttingDown) {
+          nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
+          CurrentContext()->Dispatch(mIOThread, action);
+        }
+      }
+      return;
+    }
+  }
+  MOZ_ASSERT_UNREACHABLE("Attempt to release BodyId that is not referenced!");
+}
+
+// TODO: provide way to set body non-orphaned if its added back to a cache (bug 1110479)
+
+bool
+Manager::SetBodyIdOrphanedIfRefed(const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      MOZ_ASSERT(mBodyIdRefs[i].mCount > 0);
+      MOZ_ASSERT(!mBodyIdRefs[i].mOrphaned);
+      mBodyIdRefs[i].mOrphaned = true;
+      return true;
+    }
+  }
+  return false;
+}
+
+void
+Manager::NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  nsTArray<nsID> deleteNowList;
+  for (uint32_t i = 0; i < aDeletedBodyIdList.Length(); ++i) {
+    if (!SetBodyIdOrphanedIfRefed(aDeletedBodyIdList[i])) {
+      deleteNowList.AppendElement(aDeletedBodyIdList[i]);
+    }
+  }
+
+  if (!deleteNowList.IsEmpty()) {
+    nsRefPtr<Action> action = new DeleteOrphanedBodyAction(deleteNowList);
+    CurrentContext()->Dispatch(mIOThread, action);
+  }
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.h
@@ -0,0 +1,229 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Manager_h
+#define mozilla_dom_cache_Manager_h
+
+#include "mozilla/dom/cache/CacheInitData.h"
+#include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIInputStream;
+class nsIOutputStream;
+class nsIThread;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheRequestResponse;
+class ManagerId;
+class PCacheQueryParams;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+struct SavedRequest;
+struct SavedResponse;
+
+class Manager MOZ_FINAL : public Context::Listener
+{
+public:
+  class StreamList;
+
+  class StreamControl : public PCacheStreamControlParent
+  {
+  public:
+    virtual ~StreamControl() { }
+
+    virtual void SetStreamList(StreamList* aStreamList)=0;
+
+    virtual void Close(const nsID& aId)=0;
+    virtual void CloseAll()=0;
+    virtual void Shutdown()=0;
+  };
+
+  class StreamList
+  {
+  public:
+    StreamList(Manager* aManager, Context* aContext);
+
+    void SetStreamControl(StreamControl* aStreamControl);
+    void RemoveStreamControl(StreamControl* aStreamControl);
+
+    void Activate(CacheId aCacheId);
+
+    void Add(const nsID& aId, nsIInputStream* aStream);
+    already_AddRefed<nsIInputStream> Extract(const nsID& aId);
+
+    void NoteClosed(const nsID& aId);
+    void NoteClosedAll();
+    void Close(const nsID& aId);
+    void CloseAll();
+
+  private:
+    ~StreamList();
+    struct Entry
+    {
+      nsID mId;
+      nsCOMPtr<nsIInputStream> mStream;
+    };
+    nsRefPtr<Manager> mManager;
+    nsRefPtr<Context> mContext;
+    CacheId mCacheId;
+    StreamControl* mStreamControl;
+    nsTArray<Entry> mList;
+    bool mActivated;
+
+  public:
+    NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager::StreamList)
+  };
+
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+
+    virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                              const SavedResponse* aResponse,
+                              StreamList* aStreamList) { }
+    virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                                 const nsTArray<SavedResponse>& aSavedResponses,
+                                 StreamList* aStreamList) { }
+    virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) { }
+    virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
+                               bool aSuccess) { }
+    virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<SavedRequest>& aSavedRequests,
+                             StreamList* aStreamList) { }
+
+    virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
+                                const SavedResponse* aResponse,
+                                StreamList* aStreamList) { }
+    virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
+                              bool aCacheFound) { }
+    virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
+                               CacheId aCacheId) { }
+    virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheDeleted) { }
+    virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                               const nsTArray<nsString>& aKeys) { }
+  };
+
+  static already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId);
+  static already_AddRefed<Manager> Get(ManagerId* aManagerId);
+
+  void RemoveListener(Listener* aListener);
+  void AddRefCacheId(CacheId aCacheId);
+  void ReleaseCacheId(CacheId aCacheId);
+  bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
+  void Shutdown();
+  already_AddRefed<ManagerId> GetManagerId() const;
+
+  // TODO: consider moving CacheId up in the argument lists below (bug 1110485)
+  void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                  const PCacheRequest& aRequest,
+                  const PCacheQueryParams& aParams);
+  void CacheMatchAll(Listener* aListener, RequestId aRequestId,
+                     CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                     const PCacheQueryParams& aParams);
+  void CachePutAll(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                   const nsTArray<CacheRequestResponse>& aPutList,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList);
+  void CacheDelete(Listener* aListener, RequestId aRequestId,
+                   CacheId aCacheId, const PCacheRequest& aRequest,
+                   const PCacheQueryParams& aParams);
+  void CacheKeys(Listener* aListener, RequestId aRequestId,
+                 CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                 const PCacheQueryParams& aParams);
+
+  void StorageMatch(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const PCacheRequest& aRequest,
+                    const PCacheQueryParams& aParams);
+  void StorageHas(Listener* aListener, RequestId aRequestId,
+                  Namespace aNamespace, const nsAString& aKey);
+  void StorageOpen(Listener* aListener, RequestId aRequestId,
+                   Namespace aNamespace, const nsAString& aKey);
+  void StorageDelete(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey);
+  void StorageKeys(Listener* aListener, RequestId aRequestId,
+                   Namespace aNamespace);
+
+  // Context::Listener methods
+  virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
+
+private:
+  class Factory;
+  class BaseAction;
+  class DeleteOrphanedBodyAction;
+  class DeleteOrphanedCacheAction;
+
+  class CacheMatchAction;
+  class CacheMatchAllAction;
+  class CachePutAllAction;
+  class CacheDeleteAction;
+  class CacheKeysAction;
+
+  class StorageMatchAction;
+  class StorageHasAction;
+  class StorageOpenAction;
+  class StorageDeleteAction;
+  class StorageKeysAction;
+
+  typedef uintptr_t ListenerId;
+
+  Manager(ManagerId* aManagerId);
+  ~Manager();
+  Context* CurrentContext();
+
+  ListenerId SaveListener(Listener* aListener);
+  Listener* GetListener(ListenerId aListenerId) const;
+
+  void AddStreamList(StreamList* aStreamList);
+  void RemoveStreamList(StreamList* aStreamList);
+
+  void AddRefBodyId(const nsID& aBodyId);
+  void ReleaseBodyId(const nsID& aBodyId);
+  bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
+  void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
+
+  nsRefPtr<ManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+  nsTArray<Listener*> mListeners;
+  nsTArray<StreamList*> mStreamLists;
+
+  struct CacheIdRefCounter
+  {
+    CacheId mCacheId;
+    uint32_t mCount;
+    bool mOrphaned;
+  };
+  nsTArray<CacheIdRefCounter> mCacheIdRefs;
+
+  struct BodyIdRefCounter
+  {
+    nsID mBodyId;
+    uint32_t mCount;
+    bool mOrphaned;
+  };
+  nsTArray<BodyIdRefCounter> mBodyIdRefs;
+
+  // weak ref as Context destructor clears this pointer
+  Context* mContext;
+
+  bool mShuttingDown;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/ManagerId.cpp b/dom/cache/ManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ManagerId.cpp
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ManagerId.h"
+#include "nsIPrincipal.h"
+#include "nsRefPtr.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+class ReleasePrincipalRunnable : public nsRunnable
+{
+public:
+  ReleasePrincipalRunnable(already_AddRefed<nsIPrincipal> aPrincipal)
+    : mPrincipal(aPrincipal)
+  { }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    mPrincipal = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~ReleasePrincipalRunnable() { }
+
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// static
+nsresult
+ManagerId::Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We currently don't need the system principal logic
+  // because ManagerId only uses the origin for in memory comparisons.  We
+  // also don't do any special logic to host the same Cache for different about:
+  // pages, so we don't need those checks either.
+
+  nsAutoCString origin;
+  nsresult rv = aPrincipal->GetOrigin(getter_Copies(origin));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  uint32_t appId;
+  rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<ManagerId> ref = new ManagerId(aPrincipal, origin, appId,
+                                          inBrowserElement);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+ManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+ManagerId::ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
+                     uint32_t aAppId, bool aInBrowserElement)
+    : mPrincipal(aPrincipal)
+    , mOrigin(aOrigin)
+    , mAppId(aAppId)
+    , mInBrowserElement(aInBrowserElement)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+ManagerId::~ManagerId()
+{
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new ReleasePrincipalRunnable(mPrincipal.forget());
+
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ManagerId release runnable.");
+  }
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ManagerId.h b/dom/cache/ManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ManagerId.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ManagerId_h
+#define mozilla_dom_cache_ManagerId_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsError.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+
+class nsIPrincipal;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class ManagerId MOZ_FINAL
+{
+public:
+  // Main thread only
+  static nsresult Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut);
+
+  // Main thread only
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& Origin() const { return mOrigin; }
+
+  bool operator==(const ManagerId& aOther) const
+  {
+    return mOrigin == aOther.mOrigin &&
+           mAppId == aOther.mAppId &&
+           mInBrowserElement == aOther.mInBrowserElement;
+  }
+
+private:
+  ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
+            uint32_t aAppId, bool aInBrowserElement);
+  ~ManagerId();
+
+  ManagerId(const ManagerId&) MOZ_DELETE;
+  ManagerId& operator=(const ManagerId&) MOZ_DELETE;
+
+  // only accessible on main thread
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // immutable to allow threadsfe access
+  const nsCString mOrigin;
+  const uint32_t mAppId;
+  const bool mInBrowserElement;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(mozilla::dom::cache::ManagerId)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ManagerId_h
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCache.ipdl
@@ -0,0 +1,44 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include PCacheTypes;
+include protocol PFileDescriptorSet;
+
+include protocol PBlob; // FIXME: bug 792908
+include protocol PCacheStreamControl;
+
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCache
+{
+  manager PBackground;
+
+parent:
+  Match(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
+  MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
+  AddAll(RequestId requestId, PCacheRequest[] requests);
+  Put(RequestId requestId, CacheRequestResponse aPut);
+  Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
+  Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
+
+child:
+  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse);
+  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
+  AddAllResponse(RequestId requestId, nsresult aRv);
+  PutResponse(RequestId requestId, nsresult aRv);
+  DeleteResponse(RequestId requestId, nsresult aRv, bool success);
+  KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStorage.ipdl
@@ -0,0 +1,45 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PCache;
+include PCacheTypes;
+include protocol PFileDescriptorSet;
+
+include protocol PBlob; // FIXME: bug 792908
+include protocol PCacheStreamControl;
+
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStorage
+{
+  manager PBackground;
+
+parent:
+  Match(RequestId aRequestId, PCacheRequest aRequest,
+        PCacheQueryParams aParams);
+  Has(RequestId aRequestId, nsString aKey);
+  Open(RequestId aRequestId, nsString aKey);
+  Delete(RequestId aRequestId, nsString aKey);
+  Keys(RequestId aRequestId);
+
+child:
+  MatchResponse(RequestId aRequestId, nsresult aRv,
+                PCacheResponseOrVoid aResponseOrVoid);
+  HasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
+  OpenResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
+  DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
+  KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheStreamControl.ipdl b/dom/cache/PCacheStreamControl.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStreamControl.ipdl
@@ -0,0 +1,30 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStreamControl
+{
+  manager PBackground;
+
+parent:
+  NoteClosed(nsID aStreamId);
+
+child:
+  Close(nsID aStreamId);
+  CloseAll();
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -0,0 +1,89 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PCacheStreamControl;
+include PHeaders;
+include InputStreamParams;
+
+using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
+using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
+using RequestMode from "mozilla/dom/FetchIPCUtils.h";
+using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
+using mozilla::void_t from "ipc/IPCMessageUtils.h";
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+struct PCacheQueryParams
+{
+  bool ignoreSearch;
+  bool ignoreMethod;
+  bool ignoreVary;
+  bool prefixMatch;
+  bool cacheNameSet;
+  nsString cacheName;
+};
+
+struct PCacheReadStream
+{
+  nsID id;
+  OptionalInputStreamParams params;
+  OptionalFileDescriptorSet fds;
+  nullable PCacheStreamControl control;
+};
+
+union PCacheReadStreamOrVoid
+{
+  void_t;
+  PCacheReadStream;
+};
+
+struct PCacheRequest
+{
+  nsCString method;
+  nsString url;
+  nsString urlWithoutQuery;
+  PHeadersEntry[] headers;
+  HeadersGuardEnum headersGuard;
+  nsString referrer;
+  RequestMode mode;
+  RequestCredentials credentials;
+  PCacheReadStreamOrVoid body;
+  uint32_t context;
+};
+
+union PCacheRequestOrVoid
+{
+  void_t;
+  PCacheRequest;
+};
+
+struct PCacheResponse
+{
+  ResponseType type;
+  nsString url;
+  uint32_t status;
+  nsCString statusText;
+  PHeadersEntry[] headers;
+  HeadersGuardEnum headersGuard;
+  PCacheReadStreamOrVoid body;
+};
+
+union PCacheResponseOrVoid
+{
+  void_t;
+  PCacheResponse;
+};
+
+struct CacheRequestResponse
+{
+  PCacheRequest request;
+  PCacheResponse response;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PrincipalVerifier.cpp b/dom/cache/PrincipalVerifier.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/PrincipalVerifier.cpp
@@ -0,0 +1,170 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/PrincipalVerifier.h"
+
+#include "mozilla/AppProcessChecker.h"
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/BackgroundUtils.h"
+#include "nsIPrincipal.h"
+
+namespace {
+
+using mozilla::dom::ContentParent;
+
+class ReleaseContentParentRunnable : public nsRunnable
+{
+public:
+  ReleaseContentParentRunnable(already_AddRefed<ContentParent> aActor)
+    : mActor(aActor)
+  { }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    mActor = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~ReleaseContentParentRunnable() { }
+
+  nsRefPtr<ContentParent> mActor;
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ipc::BackgroundParent;
+using mozilla::ipc::PBackgroundParent;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalInfoToPrincipal;
+
+// static
+nsresult
+PrincipalVerifier::Create(Listener* aListener, PBackgroundParent* aActor,
+                          const PrincipalInfo& aPrincipalInfo,
+                          PrincipalVerifier** aVerifierOut)
+{
+  nsRefPtr<PrincipalVerifier> verifier = new PrincipalVerifier(aListener,
+                                                               aActor,
+                                                               aPrincipalInfo);
+
+  nsresult rv = NS_DispatchToMainThread(verifier);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  verifier.forget(aVerifierOut);
+
+  return NS_OK;
+}
+
+void
+PrincipalVerifier::ClearListener()
+{
+  MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+PrincipalVerifier::PrincipalVerifier(Listener* aListener,
+                                     PBackgroundParent* aActor,
+                                     const PrincipalInfo& aPrincipalInfo)
+  : mListener(aListener)
+  , mActor(BackgroundParent::GetContentParent(aActor))
+  , mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+  , mResult(NS_OK)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mInitiatingThread);
+}
+
+PrincipalVerifier::~PrincipalVerifier()
+{
+  MOZ_ASSERT(!mListener);
+
+  if (!mActor || NS_IsMainThread()) {
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new ReleaseContentParentRunnable(mActor.forget());
+
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ManagerId release runnable.");
+  }
+}
+
+NS_IMETHODIMP
+PrincipalVerifier::Run()
+{
+  if (NS_IsMainThread()) {
+    VerifyOnMainThread();
+    return NS_OK;
+  }
+  CompleteOnInitiatingThread();
+  return NS_OK;
+}
+
+void
+PrincipalVerifier::VerifyOnMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv;
+  nsRefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                              &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    DispatchToInitiatingThread(rv);
+    return;
+  }
+
+  if (NS_WARN_IF(mActor && !AssertAppPrincipal(mActor, principal))) {
+    DispatchToInitiatingThread(NS_ERROR_FAILURE);
+    return;
+  }
+  mActor = nullptr;
+
+  rv = ManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    DispatchToInitiatingThread(rv);
+    return;
+  }
+
+  DispatchToInitiatingThread(NS_OK);
+}
+
+void
+PrincipalVerifier::CompleteOnInitiatingThread()
+{
+  MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+
+  if (!mListener) {
+    return;
+  }
+  mListener->OnPrincipalVerified(mResult, mManagerId);
+}
+
+void
+PrincipalVerifier::DispatchToInitiatingThread(nsresult aRv)
+{
+  mResult = aRv;
+  nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch PrincipalVerifier to initiating thread.");
+  }
+}
+
+} // namesapce cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PrincipalVerifier.h b/dom/cache/PrincipalVerifier.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/PrincipalVerifier.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_PrincipalVerifier_h
+#define mozilla_dom_cache_PrincipalVerifier_h
+
+#include "mozilla/ipc/PBackgroundSharedTypes.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+
+namespace ipc {
+  class PBackgroundParent;
+}
+
+namespace dom {
+namespace cache {
+
+class ManagerId;
+
+class PrincipalVerifier MOZ_FINAL : public nsRunnable
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+
+    virtual void OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)=0;
+  };
+
+  static nsresult
+  Create(Listener* aListener, ipc::PBackgroundParent* aActor,
+         const ipc::PrincipalInfo& aPrincipalInfo,
+         PrincipalVerifier** aVerifierOut);
+
+  void ClearListener();
+
+private:
+  PrincipalVerifier(Listener* aListener, ipc::PBackgroundParent* aActor,
+                    const ipc::PrincipalInfo& aPrincipalInfo);
+  virtual ~PrincipalVerifier();
+
+  void VerifyOnMainThread();
+  void CompleteOnInitiatingThread();
+
+  void DispatchToInitiatingThread(nsresult aRv);
+
+  Listener* mListener;
+  nsRefPtr<ContentParent> mActor;
+  const ipc::PrincipalInfo mPrincipalInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsresult mResult;
+  nsRefPtr<ManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namesapce cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_PrincipalVerifier_h
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/QuotaClient.cpp
@@ -0,0 +1,212 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/QuotaClient.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/dom/quota/UsageInfo.h"
+#include "nsIFile.h"
+#include "nsISimpleEnumerator.h"
+
+namespace {
+
+using mozilla::dom::quota::UsageInfo;
+
+static nsresult
+GetBodyUsage(nsIFile* aDir, UsageInfo* aUsageInfo)
+{
+  nsCOMPtr<nsISimpleEnumerator> entries;
+  nsresult rv = aDir->GetDirectoryEntries(getter_AddRefs(entries));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMore;
+  while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+         !aUsageInfo->Canceled()) {
+    nsCOMPtr<nsISupports> entry;
+    rv = entries->GetNext(getter_AddRefs(entry));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+    if (!file) { return NS_NOINTERFACE; }
+
+    bool isDir;
+    rv = file->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (isDir) {
+      rv = GetBodyUsage(file, aUsageInfo);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      continue;
+    }
+
+    int64_t fileSize;
+    rv = file->GetFileSize(&fileSize);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    MOZ_ASSERT(fileSize >= 0);
+
+    aUsageInfo->AppendToFileUsage(fileSize);
+  }
+
+  return NS_OK;
+}
+
+} // anonymous namespace;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::Client;
+using mozilla::dom::quota::PersistenceType;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::UsageInfo;
+
+Client*
+QuotaClient::Create()
+{
+  // TODO: implement nsIOfflineStorage interface (bug 1110487)
+  return new QuotaClient();
+}
+
+Client::Type
+QuotaClient::GetType()
+{
+  return DOMCACHE;
+}
+
+nsresult
+QuotaClient::InitOrigin(PersistenceType aPersistenceType,
+                        const nsACString& aGroup, const nsACString& aOrigin,
+                        UsageInfo* aUsageInfo)
+{
+  return NS_OK;
+}
+
+nsresult
+QuotaClient::GetUsageForOrigin(PersistenceType aPersistenceType,
+                               const nsACString& aGroup,
+                               const nsACString& aOrigin, UsageInfo* aUsageInfo)
+{
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+
+  nsCOMPtr<nsIFile> dir;
+  nsresult rv = qm->GetDirectoryForOrigin(aPersistenceType, aOrigin,
+                                          getter_AddRefs(dir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dir->Append(NS_LITERAL_STRING(DOMCACHE_DIRECTORY_NAME));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  DebugOnly<bool> exists;
+  MOZ_ASSERT(NS_SUCCEEDED(dir->Exists(&exists)) && exists);
+
+  nsCOMPtr<nsISimpleEnumerator> entries;
+  rv = dir->GetDirectoryEntries(getter_AddRefs(entries));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMore;
+  while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+         !aUsageInfo->Canceled()) {
+    nsCOMPtr<nsISupports> entry;
+    rv = entries->GetNext(getter_AddRefs(entry));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+    if (!file) { return NS_NOINTERFACE; }
+
+    nsAutoString leafName;
+    rv = file->GetLeafName(leafName);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool isDir;
+    rv = file->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (isDir) {
+      if (leafName.EqualsLiteral("morgue")) {
+        rv = GetBodyUsage(file, aUsageInfo);
+      } else {
+        NS_WARNING("Unknown Cache directory found!");
+      }
+
+      continue;
+    }
+
+    // Ignore transient sqlite files
+    if (leafName.EqualsLiteral("db.sqlite-journal") ||
+        leafName.EqualsLiteral("db.sqlite-shm") ||
+        leafName.Find(NS_LITERAL_CSTRING("db.sqlite-mj"), false, 0, 0) == 0) {
+      continue;
+    }
+
+    if (leafName.EqualsLiteral("db.sqlite") ||
+        leafName.EqualsLiteral("db.sqlite-wal")) {
+      int64_t fileSize;
+      rv = file->GetFileSize(&fileSize);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      MOZ_ASSERT(fileSize >= 0);
+
+      aUsageInfo->AppendToDatabaseUsage(fileSize);
+      continue;
+    }
+
+    NS_WARNING("Unknown Cache file found!");
+  }
+
+  return NS_OK;
+}
+
+void
+QuotaClient::OnOriginClearCompleted(PersistenceType aPersistenceType,
+                                    const nsACString& aOrigin)
+{
+}
+
+void
+QuotaClient::ReleaseIOThreadObjects()
+{
+  // nothing to do
+}
+
+bool
+QuotaClient::IsFileServiceUtilized()
+{
+  return false;
+}
+
+bool
+QuotaClient::IsTransactionServiceActivated()
+{
+  return false;
+}
+
+void
+QuotaClient::WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
+                                       nsIRunnable* aCallback)
+{
+  // nothing to do
+}
+
+void
+QuotaClient::ShutdownTransactionService()
+{
+  // nothing to do
+}
+
+QuotaClient::QuotaClient()
+{
+}
+
+QuotaClient::~QuotaClient()
+{
+}
+
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/QuotaClient.h b/dom/cache/QuotaClient.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/QuotaClient.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_QuotaClient_h
+#define mozilla_dom_cache_QuotaClient_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/quota/Client.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class QuotaClient MOZ_FINAL : public quota::Client
+{
+public:
+  static quota::Client*
+  Create();
+
+  // quota::Client methods
+  Type GetType() MOZ_OVERRIDE;
+
+  nsresult InitOrigin(quota::PersistenceType aPersistenceType,
+                      const nsACString& aGroup, const nsACString& aOrigin,
+                      quota::UsageInfo* aUsageInfo) MOZ_OVERRIDE;
+
+  nsresult GetUsageForOrigin(quota::PersistenceType aPersistenceType,
+                             const nsACString& aGroup,
+                             const nsACString& aOrigin,
+                             quota::UsageInfo* aUsageInfo) MOZ_OVERRIDE;
+
+  void OnOriginClearCompleted(quota::PersistenceType aPersistenceType,
+                              const nsACString& aOrigin) MOZ_OVERRIDE;
+
+  void ReleaseIOThreadObjects() MOZ_OVERRIDE;
+
+  bool IsFileServiceUtilized() MOZ_OVERRIDE;
+
+  bool IsTransactionServiceActivated() MOZ_OVERRIDE;
+
+  void WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
+                                 nsIRunnable* aCallback) MOZ_OVERRIDE;
+
+  void ShutdownTransactionService() MOZ_OVERRIDE;
+
+private:
+  QuotaClient();
+  ~QuotaClient();
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::QuotaClient)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_QuotaClient_h
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.cpp
@@ -0,0 +1,481 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ReadStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
+#include "mozilla/ipc/InputStreamParams.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetChild.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "mozilla/SnappyUncompressInputStream.h"
+#include "nsIAsyncInputStream.h"
+#include "nsTArray.h"
+
+namespace {
+
+using mozilla::unused;
+using mozilla::void_t;
+using mozilla::dom::cache::CacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlParent;
+using mozilla::dom::cache::PCacheReadStream;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::PCacheStreamControlParent;
+using mozilla::dom::cache::ReadStream;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::PFileDescriptorSetChild;
+using mozilla::ipc::PFileDescriptorSetParent;
+
+class ReadStreamChild MOZ_FINAL : public ReadStream
+{
+public:
+  ReadStreamChild(PCacheStreamControlChild* aControl, const nsID& aId,
+                  nsIInputStream* aStream)
+    : ReadStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlChild*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual ~ReadStreamChild()
+  {
+    NoteClosed();
+  }
+
+  virtual void NoteClosedOnWorkerThread() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+    mControl->NoteClosed(mId);
+  }
+
+  virtual void ForgetOnWorkerThread() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+  }
+
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    aReadStreamOut->controlParent() = nullptr;
+    aReadStreamOut->controlChild() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    PFileDescriptorSetChild* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  CacheStreamControlChild* mControl;
+};
+
+class ReadStreamParent MOZ_FINAL : public ReadStream
+{
+public:
+  ReadStreamParent(PCacheStreamControlParent* aControl, const nsID& aId,
+                  nsIInputStream* aStream)
+    : ReadStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlParent*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual ~ReadStreamParent()
+  {
+    NoteClosed();
+  }
+
+  virtual void NoteClosedOnWorkerThread() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+    // This can cause mControl to be destructed
+    mControl->RecvNoteClosed(mId);
+    mControl = nullptr;
+  }
+
+  virtual void ForgetOnWorkerThread() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    // This can cause mControl to be destructed
+    mControl->RemoveListener(this);
+    mControl = nullptr;
+  }
+
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    MOZ_ASSERT(!mClosed);
+    MOZ_ASSERT(mControl);
+    aReadStreamOut->controlChild() = nullptr;
+    aReadStreamOut->controlParent() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(!mClosed);
+    MOZ_ASSERT(mControl);
+    PFileDescriptorSetParent* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  CacheStreamControlParent* mControl;
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::FileDescriptorSetParent;
+using mozilla::ipc::InputStreamParams;
+using mozilla::ipc::OptionalFileDescriptorSet;
+using mozilla::ipc::PFileDescriptorSetChild;
+
+class ReadStream::NoteClosedRunnable MOZ_FINAL : public nsCancelableRunnable
+{
+public:
+  NoteClosedRunnable(ReadStream* aStream)
+    : mStream(aStream)
+  { }
+
+  NS_IMETHOD Run()
+  {
+    mStream->NoteClosedOnWorkerThread();
+    return NS_OK;
+  }
+private:
+  ~NoteClosedRunnable() { }
+
+  nsRefPtr<ReadStream> mStream;
+};
+
+class ReadStream::ForgetRunnable MOZ_FINAL : public nsCancelableRunnable
+{
+public:
+  ForgetRunnable(ReadStream* aStream)
+    : mStream(aStream)
+  { }
+
+  NS_IMETHOD Run()
+  {
+    mStream->ForgetOnWorkerThread();
+    return NS_OK;
+  }
+private:
+  ~ForgetRunnable() { }
+
+  nsRefPtr<ReadStream> mStream;
+};
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream,
+                                                   ReadStream);
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  return Create(aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(const PCacheReadStream& aReadStream)
+{
+  if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
+    return nullptr;
+  }
+
+  nsTArray<FileDescriptor> fds;
+  if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetChild* fdSetActor =
+      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  } else if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+    FileDescriptorSetParent* fdSetActor =
+      static_cast<FileDescriptorSetParent*>(aReadStream.fds().get_PFileDescriptorSetParent());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  nsCOMPtr<nsIInputStream> stream =
+    DeserializeInputStream(aReadStream.params(), fds);
+
+  if (!stream) {
+    return nullptr;
+  }
+
+  // Currently we expect all cache read streams to be blocking file streams.
+#ifdef DEBUG
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+  MOZ_ASSERT(!asyncStream);
+#endif
+
+  nsRefPtr<ReadStream> ref;
+
+  if (aReadStream.controlChild()) {
+    ref = new ReadStreamChild(aReadStream.controlChild(), aReadStream.id(),
+                              stream);
+  } else {
+    ref = new ReadStreamParent(aReadStream.controlParent(), aReadStream.id(),
+                               stream);
+  }
+
+  return ref.forget();
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
+                   nsIInputStream* aStream)
+{
+  nsRefPtr<ReadStream> ref = new ReadStreamParent(aControl, aId, aStream);
+  return ref.forget();
+}
+
+void
+ReadStream::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
+{
+  MOZ_ASSERT(aReadStreamOut);
+  PCacheReadStream stream;
+  Serialize(&stream);
+  *aReadStreamOut = stream;
+}
+
+void
+ReadStream::Serialize(PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aReadStreamOut);
+  MOZ_ASSERT(!mClosed);
+
+  aReadStreamOut->id() = mId;
+  SerializeControl(aReadStreamOut);
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(mStream, aReadStreamOut->params(), fds);
+
+  SerializeFds(aReadStreamOut, fds);
+
+  // We're passing ownership across the IPC barrier with the control, so
+  // do not signal that the stream is closed here.
+  Forget();
+}
+
+void
+ReadStream::CloseStream()
+{
+  Close();
+}
+
+void
+ReadStream::CloseStreamWithoutReporting()
+{
+  Forget();
+}
+
+bool
+ReadStream::MatchId(const nsID& aId)
+{
+  return mId.Equals(aId);
+}
+
+ReadStream::ReadStream(const nsID& aId, nsIInputStream* aStream)
+  : mId(aId)
+  , mStream(aStream)
+  , mSnappyStream(new SnappyUncompressInputStream(aStream))
+  , mThread(NS_GetCurrentThread())
+  , mClosed(false)
+{
+  MOZ_ASSERT(mStream);
+}
+
+ReadStream::~ReadStream()
+{
+}
+
+void
+ReadStream::NoteClosed()
+{
+  if (mClosed) {
+    return;
+  }
+
+  if (NS_GetCurrentThread() == mThread) {
+    NoteClosedOnWorkerThread();
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable = new NoteClosedRunnable(this);
+  nsresult rv = mThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to dispatch Cache ReadStream NoteClosed() runnable.");
+  }
+}
+
+void
+ReadStream::Forget()
+{
+  if (mClosed) {
+    return;
+  }
+
+  if (NS_GetCurrentThread() == mThread) {
+    ForgetOnWorkerThread();
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable = new ForgetRunnable(this);
+  nsresult rv = mThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to dispatch Cache ReadStream Forget() runnable.");
+  }
+}
+
+NS_IMETHODIMP
+ReadStream::Close()
+{
+  NoteClosed();
+  return mStream->Close();
+}
+
+NS_IMETHODIMP
+ReadStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mSnappyStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
+
+  // Don't auto-close when end of stream is hit.  We want to close
+  // this stream on a particular thread in the parent case.
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                         uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
+                                            aNumReadOut);
+
+  // Don't auto-close when end of stream is hit.  We want to close
+  // this stream on a particular thread in the parent case.
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mSnappyStream->IsNonBlocking(aNonBlockingOut);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ReadStream_h
+#define mozilla_dom_cache_ReadStream_h
+
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIInputStream.h"
+#include "nsISupportsImpl.h"
+
+class nsIThread;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+class PCacheStreamControlParent;
+
+// IID for the dom::cache::ReadStream interface
+#define NS_DOM_CACHE_IID \
+{0x8e5da7c9, 0x0940, 0x4f1d, \
+  {0x97, 0x25, 0x5c, 0x59, 0x38, 0xdd, 0xb9, 0x9f}}
+
+class ReadStream : public nsIInputStream
+                 , public CacheStreamControlListener
+{
+public:
+  static already_AddRefed<ReadStream>
+  Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+
+  static already_AddRefed<ReadStream>
+  Create(const PCacheReadStream& aReadStream);
+
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlParent* aControl, const nsID& aId,
+         nsIInputStream* aStream);
+
+  void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
+  void Serialize(PCacheReadStream* aReadStreamOut);
+
+  // CacheStreamControlListener methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual void CloseStreamWithoutReporting() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
+
+protected:
+  ReadStream(const nsID& aId, nsIInputStream* aStream);
+  virtual ~ReadStream();
+
+  void NoteClosed();
+  void Forget();
+
+  virtual void NoteClosedOnWorkerThread()=0;
+  virtual void ForgetOnWorkerThread()=0;
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut)=0;
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& fds)=0;
+
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  nsCOMPtr<nsIInputStream> mSnappyStream;
+  nsCOMPtr<nsIThread> mThread;
+  bool mClosed;
+
+public:
+  class NoteClosedRunnable;
+  class ForgetRunnable;
+
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_IID);
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(ReadStream, NS_DOM_CACHE_IID);
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/SavedTypes.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_SavedTypes_h
+#define mozilla_dom_cache_SavedTypes_h
+
+// NOTE: This cannot be rolled into Types.h because the IPC dependency.
+//       breaks webidl unified builds.
+
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIOutputStream.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+struct StreamHolder
+{
+  nsCOMPtr<nsIOutputStream> mValue;
+};
+
+struct SavedRequest
+{
+  SavedRequest() : mHasBodyId(false) { mValue.body() = void_t(); }
+  PCacheRequest mValue;
+  bool mHasBodyId;
+  nsID mBodyId;
+  CacheId mCacheId;
+};
+
+struct SavedResponse
+{
+  SavedResponse() : mHasBodyId(false) { mValue.body() = void_t(); }
+  PCacheResponse mValue;
+  bool mHasBodyId;
+  nsID mBodyId;
+  CacheId mCacheId;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_SavedTypes_h
diff --git a/dom/cache/ShutdownObserver.cpp b/dom/cache/ShutdownObserver.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ShutdownObserver.cpp
@@ -0,0 +1,220 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ShutdownObserver.h"
+
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/Services.h"
+#include "nsIObserverService.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+static bool sInstanceInit = false;
+static nsRefPtr<mozilla::dom::cache::ShutdownObserver> sInstance = nullptr;
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::services::GetObserverService;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ShutdownObserver, nsIObserver);
+
+// static
+already_AddRefed<ShutdownObserver>
+ShutdownObserver::Instance()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  if (!sInstanceInit) {
+    sInstanceInit = true;
+    sInstance = new ShutdownObserver();
+  }
+
+  nsRefPtr<ShutdownObserver> ref = sInstance;
+  return ref.forget();
+}
+
+nsresult
+ShutdownObserver::AddManagerId(ManagerId* aManagerId)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  if (mShuttingDown) {
+    return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
+      this, &ShutdownObserver::AddManagerIdOnMainThread, aManagerId);
+
+  DebugOnly<nsresult> rv =
+    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+  return NS_OK;
+}
+
+void
+ShutdownObserver::RemoveManagerId(ManagerId* aManagerId)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
+      this, &ShutdownObserver::RemoveManagerIdOnMainThread, aManagerId);
+
+  DebugOnly<nsresult> rv =
+    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+}
+
+ShutdownObserver::ShutdownObserver()
+  : mBackgroundThread(NS_GetCurrentThread())
+  , mShuttingDown(false)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethod(this, &ShutdownObserver::InitOnMainThread);
+  DebugOnly<nsresult> rv =
+    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+}
+
+ShutdownObserver::~ShutdownObserver()
+{
+  // This can happen on either main thread or background thread.
+}
+
+void
+ShutdownObserver::InitOnMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIObserverService> os = GetObserverService();
+
+  // If there is no observer service then we are already shutting down,
+  // but content just tried to use the Cache API for the first time.
+  // Trigger an immediate Cache shutdown.
+  if (!os) {
+    DoShutdown();
+    return;
+  }
+
+  os->AddObserver(this, "profile-before-change", false /* weak ref */);
+}
+
+void
+ShutdownObserver::AddManagerIdOnMainThread(ManagerId* aManagerId)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
+    if (*mManagerIds[i] == *aManagerId) {
+      return;
+    }
+  }
+  mManagerIds.AppendElement(aManagerId);
+}
+
+void
+ShutdownObserver::RemoveManagerIdOnMainThread(ManagerId* aManagerId)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
+    if (*mManagerIds[i] == *aManagerId) {
+      mManagerIds.RemoveElementAt(i);
+      return;
+    }
+  }
+}
+
+void
+ShutdownObserver::StartShutdownOnBgThread()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  mShuttingDown = true;
+
+  for (uint32_t i = 0; i < mManagerIdsInProcess.Length(); ++i) {
+    nsRefPtr<Manager> manager = Manager::Get(mManagerIdsInProcess[i]);
+    if (manager) {
+      manager->Shutdown();
+    }
+  }
+}
+
+void
+ShutdownObserver::FinishShutdownOnBgThread()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mShuttingDown);
+
+  sInstance = nullptr;
+}
+
+void
+ShutdownObserver::DoShutdown()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+  if (os) {
+    os->RemoveObserver(this, "profile-before-change");
+  }
+
+  // Copy origins to separate array to process to avoid races
+  mManagerIdsInProcess = mManagerIds;
+
+  // Send shutdown notification to origin managers
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethod(this, &ShutdownObserver::StartShutdownOnBgThread);
+  DebugOnly<nsresult> rv =
+    mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+  runnable = nullptr;
+
+  // Wait for managers to shutdown
+  while (!mManagerIds.IsEmpty()) {
+    if (!NS_ProcessNextEvent()) {
+      NS_WARNING("Something bad happened!");
+      break;
+    }
+  }
+
+  // schedule runnable to clear singleton ref on background thread
+  runnable =
+    NS_NewRunnableMethod(this, &ShutdownObserver::FinishShutdownOnBgThread);
+  rv = mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+}
+
+NS_IMETHODIMP
+ShutdownObserver::Observe(nsISupports* aSubject, const char* aTopic,
+                          const char16_t* aData)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (!strcmp(aTopic, "profile-before-change")) {
+    DoShutdown();
+  }
+
+  return NS_OK;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ShutdownObserver.h b/dom/cache/ShutdownObserver.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ShutdownObserver.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ShutdownObserver_h
+#define mozilla_dom_cache_ShutdownObserver_h
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+#include "nsIObserver.h"
+#include "nsIThread.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class ManagerId;
+
+class ShutdownObserver MOZ_FINAL : public nsIObserver
+{
+public:
+  static already_AddRefed<ShutdownObserver> Instance();
+
+  nsresult AddManagerId(ManagerId* aManagerId);
+  void RemoveManagerId(ManagerId* aManagerId);
+
+private:
+  ShutdownObserver();
+  virtual ~ShutdownObserver();
+
+  void InitOnMainThread();
+  void AddManagerIdOnMainThread(ManagerId* aManagerId);
+  void RemoveManagerIdOnMainThread(ManagerId* aManagerId);
+
+  void StartShutdownOnBgThread();
+  void FinishShutdownOnBgThread();
+
+  void DoShutdown();
+
+  nsCOMPtr<nsIThread> mBackgroundThread;
+
+  // main thread only
+  nsTArray<nsRefPtr<ManagerId>> mManagerIds;
+
+  // set on main thread once and read on bg thread
+  nsTArray<nsRefPtr<ManagerId>> mManagerIdsInProcess;
+
+  // bg thread only
+  bool mShuttingDown;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ShutdownObserver_h
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/TypeUtils.cpp
@@ -0,0 +1,557 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/TypeUtils.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/InternalRequest.h"
+#include "mozilla/dom/Request.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PFileDescriptorSetChild.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "nsCOMPtr.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIIPCSerializableInputStream.h"
+#include "nsStreamUtils.h"
+#include "nsString.h"
+#include "nsURLParsers.h"
+
+namespace {
+
+using mozilla::ErrorResult;
+
+// Utility function to remove the fragment from a URL, check its scheme, and optionally
+// provide a URL without the query.  We're not using nsIURL or URL to do this because
+// they require going to the main thread.
+static void
+ProcessURL(nsAString& aUrl, bool* aSchemeValidOut,
+           nsAString* aUrlWithoutQueryOut, ErrorResult& aRv)
+{
+  NS_ConvertUTF16toUTF8 flatURL(aUrl);
+  const char* url = flatURL.get();
+
+  nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
+
+  uint32_t pathPos;
+  int32_t pathLen;
+  uint32_t schemePos;
+  int32_t schemeLen;
+  nsresult rv = urlParser->ParseURL(url, flatURL.Length(),
+                                    &schemePos, &schemeLen,
+                                    nullptr, nullptr,       // ignore authority
+                                    &pathPos, &pathLen);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return;
+  }
+
+  if (aSchemeValidOut) {
+    nsAutoCString scheme(Substring(flatURL, schemePos, schemeLen));
+    *aSchemeValidOut = scheme.LowerCaseEqualsLiteral("http") ||
+                       scheme.LowerCaseEqualsLiteral("https");
+  }
+
+  uint32_t queryPos;
+  int32_t queryLen;
+  uint32_t refPos;
+  int32_t refLen;
+
+  rv = urlParser->ParsePath(url + pathPos, flatURL.Length() - pathPos,
+                            nullptr, nullptr,               // ignore filepath
+                            &queryPos, &queryLen,
+                            &refPos, &refLen);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return;
+  }
+
+  // TODO: Remove this once Request/Response properly strip the fragment (bug 1110476)
+  if (refLen >= 0) {
+    // ParsePath gives us ref position relative to the start of the path
+    refPos += pathPos;
+
+    aUrl = Substring(aUrl, 0, refPos - 1);
+  }
+
+  if (!aUrlWithoutQueryOut) {
+    return;
+  }
+
+  if (queryLen < 0) {
+    *aUrlWithoutQueryOut = aUrl;
+    return;
+  }
+
+  // ParsePath gives us query position relative to the start of the path
+  queryPos += pathPos;
+
+  // We want everything before the query sine we already removed the trailing
+  // fragment
+  *aUrlWithoutQueryOut = Substring(aUrl, 0, queryPos - 1);
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::void_t;
+using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::PFileDescriptorSetChild;
+using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::OptionalFileDescriptorSet;
+
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
+                           const RequestOrUSVString& aIn,
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  ToPCacheRequest(global, aOut, aIn, aBodyAction, aReferrerAction, aRv);
+}
+
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
+                           const OwningRequestOrUSVString& aIn,
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  return ToPCacheRequest(global, aOut, aIn, aBodyAction, aReferrerAction, aRv);
+}
+
+void
+TypeUtils::ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
+                                 const Optional<RequestOrUSVString>& aIn,
+                                 BodyAction aBodyAction,
+                                 ReferrerAction aReferrerAction,
+                                 ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  return ToPCacheRequestOrVoid(global, aOut, aIn, aBodyAction, aReferrerAction,
+                               aRv);
+}
+
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut, Request& aIn,
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
+{
+  aIn.GetMethod(aOut.method());
+  aIn.GetUrl(aOut.url());
+
+  bool schemeValid;
+  ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
+  if (aRv.Failed()) {
+    return;
+  }
+  // TODO: wrong scheme should trigger different behavior in Match vs Put, etc. (bug 1110462)
+  if (!schemeValid) {
+    NS_NAMED_LITERAL_STRING(label, "Request");
+    aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
+    return;
+  }
+
+  nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
+
+  if (aReferrerAction == ExpandReferrer &&
+      internalRequest->ReferrerIsClient()) {
+    nsAutoCString referrer;
+    GetRequestReferrer(GetGlobalObject(), internalRequest, referrer);
+    aOut.referrer() = NS_ConvertUTF8toUTF16(referrer);
+  } else {
+    aIn.GetReferrer(aOut.referrer());
+  }
+
+  nsRefPtr<InternalHeaders> headers = aIn.GetInternalHeaders();
+  MOZ_ASSERT(headers);
+  headers->GetPHeaders(aOut.headers());
+  aOut.headersGuard() = headers->Guard();
+  aOut.mode() = aIn.Mode();
+  aOut.credentials() = aIn.Credentials();
+  aOut.context() = internalRequest->GetContext();
+
+  if (aBodyAction == IgnoreBody) {
+    aOut.body() = void_t();
+    return;
+  }
+
+  if (aIn.BodyUsed()) {
+    aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
+    return;
+  }
+
+  nsCOMPtr<nsIInputStream> stream;
+  internalRequest->GetBody(getter_AddRefs(stream));
+  if (stream) {
+    aIn.SetBodyUsed();
+  }
+
+  SerializeCacheStream(stream, &aOut.body(), aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+}
+
+// static
+void
+TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal,
+                           PCacheRequest& aOut,
+                           const RequestOrUSVString& aIn,
+                           BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                           ErrorResult& aRv)
+{
+  if (aIn.IsRequest()) {
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aBodyAction, aReferrerAction, aRv);
+    return;
+  }
+
+  RequestInit init;
+  nsRefPtr<Request> request = Request::Constructor(aGlobal, aIn, init, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+  ToPCacheRequest(aOut, *request, aBodyAction, aReferrerAction, aRv);
+}
+
+void
+TypeUtils::ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
+                                 PCacheRequestOrVoid& aOut,
+                                 const Optional<RequestOrUSVString>& aIn,
+                                 BodyAction aBodyAction,
+                                 ReferrerAction aReferrerAction,
+                                 ErrorResult& aRv)
+{
+  if (!aIn.WasPassed()) {
+    aOut = void_t();
+    return;
+  }
+  PCacheRequest request;
+  ToPCacheRequest(aGlobal, request, aIn.Value(), aBodyAction, aReferrerAction,
+                  aRv);
+  if (aRv.Failed()) {
+    return;
+  }
+  aOut = request;
+}
+
+void
+TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
+                           const OwningRequestOrUSVString& aIn,
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
+{
+  if (aIn.IsRequest()) {
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aBodyAction, aReferrerAction,
+                    aRv);
+    return;
+  }
+
+  RequestOrUSVString input;
+  RequestInit init;
+  nsString str;
+  str.Assign(aIn.GetAsUSVString());
+  input.SetAsUSVString().Rebind(str.Data(), str.Length());
+
+  nsRefPtr<Request> request = Request::Constructor(aGlobal, input, init, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+  ToPCacheRequest(aOut, *request, aBodyAction, aReferrerAction, aRv);
+}
+
+void
+TypeUtils::ToPCacheResponseWithoutBody(PCacheResponse& aOut,
+                                       InternalResponse& aIn, ErrorResult& aRv)
+{
+  aOut.type() = aIn.Type();
+
+  nsAutoCString url;
+  aIn.GetUrl(url);
+  aOut.url() = NS_ConvertUTF8toUTF16(url);
+
+  if (aOut.url() != EmptyString()) {
+    bool schemeValid;
+    ProcessURL(aOut.url(), &schemeValid, nullptr, aRv);
+    if (aRv.Failed()) {
+      return;
+    }
+    // TODO: wrong scheme should trigger different behavior in Match vs Put, etc. (bug 1110462)
+    if (!schemeValid) {
+      NS_NAMED_LITERAL_STRING(label, "Response");
+      aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
+      return;
+    }
+  }
+
+  aOut.status() = aIn.GetStatus();
+  aOut.statusText() = aIn.GetStatusText();
+  nsRefPtr<InternalHeaders> headers = aIn.Headers();
+  MOZ_ASSERT(headers);
+  headers->GetPHeaders(aOut.headers());
+  aOut.headersGuard() = headers->Guard();
+}
+
+void
+TypeUtils::ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv)
+{
+  if (aIn.BodyUsed()) {
+    aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
+    return;
+  }
+
+  nsRefPtr<InternalResponse> ir = aIn.GetInternalResponse();
+  ToPCacheResponseWithoutBody(aOut, *ir, aRv);
+
+  nsCOMPtr<nsIInputStream> stream;
+  aIn.GetBody(getter_AddRefs(stream));
+  if (stream) {
+    aIn.SetBodyUsed();
+  }
+
+  SerializeCacheStream(stream, &aOut.body(), aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+}
+
+// static
+void
+TypeUtils::ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
+{
+  aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
+                        aIn.mIgnoreSearch.Value();
+  aOut.ignoreMethod() = aIn.mIgnoreMethod.WasPassed() &&
+                        aIn.mIgnoreMethod.Value();
+  aOut.ignoreVary() = aIn.mIgnoreVary.WasPassed() &&
+                      aIn.mIgnoreVary.Value();
+  aOut.prefixMatch() = aIn.mPrefixMatch.WasPassed() &&
+                       aIn.mPrefixMatch.Value();
+  aOut.cacheNameSet() = aIn.mCacheName.WasPassed();
+  if (aOut.cacheNameSet()) {
+    aOut.cacheName() = aIn.mCacheName.Value();
+  } else {
+    aOut.cacheName() = NS_LITERAL_STRING("");
+  }
+}
+
+already_AddRefed<Response>
+TypeUtils::ToResponse(const PCacheResponse& aIn)
+{
+  nsRefPtr<InternalResponse> ir;
+  switch (aIn.type())
+  {
+    case ResponseType::Error:
+      ir = InternalResponse::NetworkError();
+      break;
+    case ResponseType::Opaque:
+      ir = InternalResponse::OpaqueResponse();
+      break;
+    case ResponseType::Default:
+      ir = new InternalResponse(aIn.status(), aIn.statusText());
+      break;
+    case ResponseType::Basic:
+    {
+      nsRefPtr<InternalResponse> inner = new InternalResponse(aIn.status(),
+                                                              aIn.statusText());
+      ir = InternalResponse::BasicResponse(inner);
+      break;
+    }
+    case ResponseType::Cors:
+    {
+      nsRefPtr<InternalResponse> inner = new InternalResponse(aIn.status(),
+                                                              aIn.statusText());
+      ir = InternalResponse::CORSResponse(inner);
+      break;
+    }
+    default:
+      MOZ_CRASH("Unexpected ResponseType!");
+  }
+  MOZ_ASSERT(ir);
+
+  ir->SetUrl(NS_ConvertUTF16toUTF8(aIn.url()));
+
+  nsRefPtr<InternalHeaders> internalHeaders =
+    new InternalHeaders(aIn.headers(), aIn.headersGuard());
+  ErrorResult result;
+  ir->Headers()->SetGuard(aIn.headersGuard(), result);
+  ir->Headers()->Fill(*internalHeaders, result);
+  MOZ_ASSERT(!result.Failed());
+
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
+  ir->SetBody(stream);
+
+  nsRefPtr<Response> ref = new Response(GetGlobalObject(), ir);
+  return ref.forget();
+}
+
+already_AddRefed<InternalRequest>
+TypeUtils::ToInternalRequest(const PCacheRequest& aIn)
+{
+  nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
+
+  // TODO: Should not set origin on Request as it won't be valid for SystemPrincipal (bug 1110475)
+  internalRequest->SetOrigin(Origin());
+
+  internalRequest->SetMethod(aIn.method());
+  internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
+  internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
+  internalRequest->SetMode(aIn.mode());
+  internalRequest->SetCredentialsMode(aIn.credentials());
+  internalRequest->SetContext(aIn.context());
+
+  nsRefPtr<InternalHeaders> internalHeaders =
+    new InternalHeaders(aIn.headers(), aIn.headersGuard());
+  ErrorResult result;
+  internalRequest->Headers()->SetGuard(aIn.headersGuard(), result);
+  internalRequest->Headers()->Fill(*internalHeaders, result);
+  MOZ_ASSERT(!result.Failed());
+
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
+
+  internalRequest->SetBody(stream);
+
+  return internalRequest.forget();
+}
+
+already_AddRefed<Request>
+TypeUtils::ToRequest(const PCacheRequest& aIn)
+{
+  nsRefPtr<InternalRequest> internalRequest = ToInternalRequest(aIn);
+  nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
+  return request.forget();
+}
+
+void
+TypeUtils::CleanupChildFds(PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return;
+  }
+
+  CleanupChildFds(aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+void
+TypeUtils::CleanupChildFds(PCacheReadStream& aReadStream)
+{
+  if (aReadStream.fds().type() !=
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+    return;
+  }
+
+  nsTArray<FileDescriptor> fds;
+
+  FileDescriptorSetChild* fdSetActor =
+    static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+  MOZ_ASSERT(fdSetActor);
+
+  fdSetActor->ForgetFileDescriptors(fds);
+}
+
+void
+TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
+                                PCacheReadStreamOrVoid* aStreamOut,
+                                ErrorResult& aRv)
+{
+  *aStreamOut = void_t();
+  if (!aStream) {
+    return;
+  }
+
+  nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
+  if (controlled) {
+    controlled->Serialize(aStreamOut);
+    return;
+  }
+
+  // TODO: implement CrossProcessPipe if we cannot directly serialize (bug 1110814)
+  nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
+  if (!serial) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return;
+  }
+
+  PCacheReadStream readStream;
+  readStream.controlChild() = nullptr;
+  readStream.controlParent() = nullptr;
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(aStream, readStream.params(), fds);
+
+  PFileDescriptorSetChild* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    // We should not be serializing until we have an actor ready
+    PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
+    MOZ_ASSERT(manager);
+
+    fdSet = manager->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+  }
+
+  if (fdSet) {
+    readStream.fds() = fdSet;
+  } else {
+    readStream.fds() = void_t();
+  }
+
+  *aStreamOut = readStream;
+}
+
+nsIThread*
+TypeUtils::GetStreamThread()
+{
+  AssertOwningThread();
+
+  if (!mStreamThread) {
+    nsresult rv = NS_NewNamedThread("DOMCacheTypeU",
+                                    getter_AddRefs(mStreamThread));
+    if (NS_FAILED(rv) || !mStreamThread) {
+      MOZ_CRASH("Failed to create DOM Cache serialization thread.");
+    }
+  }
+
+  return mStreamThread;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/TypeUtils.h
@@ -0,0 +1,140 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_TypesUtils_h
+#define mozilla_dom_cache_TypesUtils_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/BindingUtils.h"
+#include "nsCOMPtr.h"
+#include "nsError.h"
+
+class nsIGlobalObject;
+class nsIInputStream;
+
+namespace mozilla {
+namespace dom {
+
+class OwningRequestOrUSVString;
+struct QueryParams;
+class InternalRequest;
+class InternalResponse;
+class Request;
+class RequestOrUSVString;
+class Response;
+template<typename T> class Optional;
+
+namespace cache {
+
+class PCacheQueryParams;
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+class PCacheStreamControlChild;
+
+class TypeUtils
+{
+protected:
+  enum BodyAction
+  {
+    IgnoreBody,
+    ReadBody
+  };
+
+  enum ReferrerAction
+  {
+    PassThroughReferrer,
+    ExpandReferrer
+  };
+
+  virtual ~TypeUtils() { }
+  virtual nsIGlobalObject* GetGlobalObject() const=0;
+  virtual const nsACString& Origin() const=0;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const=0;
+#else
+  inline void AssertOwningThread() const { }
+#endif
+
+  void
+  ToPCacheRequest(PCacheRequest& aOut,
+                  const RequestOrUSVString& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
+
+  void
+  ToPCacheRequest(PCacheRequest& aOut,
+                  const OwningRequestOrUSVString& aIn,
+                  BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                  ErrorResult& aRv);
+
+  void
+  ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
+                        const Optional<RequestOrUSVString>& aIn,
+                        BodyAction aBodyAction,
+                        ReferrerAction aReferrerAction,
+                        ErrorResult& aRv);
+
+  void
+  ToPCacheRequest(PCacheRequest& aOut, Request& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
+
+  void
+  ToPCacheResponseWithoutBody(PCacheResponse& aOut, InternalResponse& aIn,
+                              ErrorResult& aRv);
+
+  void
+  ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
+
+  void
+  ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
+
+  already_AddRefed<Response>
+  ToResponse(const PCacheResponse& aIn);
+
+  already_AddRefed<InternalRequest>
+  ToInternalRequest(const PCacheRequest& aIn);
+
+  already_AddRefed<Request>
+  ToRequest(const PCacheRequest& aIn);
+
+  void CleanupChildFds(PCacheReadStreamOrVoid& aRequest);
+  void CleanupChildFds(PCacheReadStream& aReadStream);
+
+private:
+  void
+  ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
+                  const RequestOrUSVString& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
+
+  void
+  ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
+                        PCacheRequestOrVoid& aOut,
+                        const Optional<RequestOrUSVString>& aIn,
+                        BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                        ErrorResult& aRv);
+
+  void
+  ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
+                  const OwningRequestOrUSVString& aIn,
+                  BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                  ErrorResult& aRv);
+
+  void
+  SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut,
+                       ErrorResult& aRv);
+
+  nsIThread* GetStreamThread();
+
+  nsCOMPtr<nsIThread> mStreamThread;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_TypesUtils_h
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Types.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Types_h
+#define mozilla_dom_cache_Types_h
+
+#include <stdint.h>
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+enum Namespace
+{
+  DEFAULT_NAMESPACE,
+  CHROME_ONLY_NAMESPACE,
+  NUMBER_OF_NAMESPACES
+};
+
+typedef uintptr_t RequestId;
+static const RequestId INVALID_REQUEST_ID = 0;
+
+typedef int32_t CacheId;
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false), mHasUnlimStoragePerm(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+  bool mHasUnlimStoragePerm;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/cache/moz.build
@@ -0,0 +1,77 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom.cache += [
+    'Action.h',
+    'Cache.h',
+    'CacheChild.h',
+    'CacheChildListener.h',
+    'CacheParent.h',
+    'CacheStorage.h',
+    'CacheStorageChild.h',
+    'CacheStorageChildListener.h',
+    'CacheStorageParent.h',
+    'CacheStreamControlChild.h',
+    'CacheStreamControlListener.h',
+    'CacheStreamControlParent.h',
+    'Context.h',
+    'DBAction.h',
+    'DBSchema.h',
+    'FetchPut.h',
+    'FileUtils.h',
+    'IPCUtils.h',
+    'Manager.h',
+    'ManagerId.h',
+    'PrincipalVerifier.h',
+    'QuotaClient.h',
+    'ReadStream.h',
+    'SavedTypes.h',
+    'ShutdownObserver.h',
+    'Types.h',
+    'TypeUtils.h',
+]
+
+SOURCES += [
+    'Action.cpp',
+    'Cache.cpp',
+    'CacheChild.cpp',
+    'CacheParent.cpp',
+    'CacheStorage.cpp',
+    'CacheStorageChild.cpp',
+    'CacheStorageParent.cpp',
+    'CacheStreamControlChild.cpp',
+    'CacheStreamControlParent.cpp',
+    'Context.cpp',
+    'DBAction.cpp',
+    'DBSchema.cpp',
+    'FetchPut.cpp',
+    'FileUtils.cpp',
+    'Manager.cpp',
+    'ManagerId.cpp',
+    'PrincipalVerifier.cpp',
+    'QuotaClient.cpp',
+    'ReadStream.cpp',
+    'ShutdownObserver.cpp',
+    'TypeUtils.cpp',
+]
+
+IPDL_SOURCES += [
+    'CacheInitData.ipdlh',
+    'PCache.ipdl',
+    'PCacheStorage.ipdl',
+    'PCacheStreamControl.ipdl',
+    'PCacheTypes.ipdlh',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+    '../workers',
+]
+
+FAIL_ON_WARNINGS = True
+
+FINAL_LIBRARY = 'xul'
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -42,16 +42,17 @@ DIRS += [
     'apps',
     'base',
     'activities',
     'archivereader',
     'requestsync',
     'bindings',
     'battery',
     'browser-element',
+    'cache',
     'canvas',
     'cellbroadcast',
     'contacts',
     'crypto',
     'phonenumberutils',
     'alarm',
     'datastore',
     'devicestorage',
diff --git a/dom/quota/Client.h b/dom/quota/Client.h
--- a/dom/quota/Client.h
+++ b/dom/quota/Client.h
@@ -11,16 +11,17 @@
 
 #include "PersistenceType.h"
 
 class nsIOfflineStorage;
 class nsIRunnable;
 
 #define IDB_DIRECTORY_NAME "idb"
 #define ASMJSCACHE_DIRECTORY_NAME "asmjs"
+#define DOMCACHE_DIRECTORY_NAME "cache"
 
 BEGIN_QUOTA_NAMESPACE
 
 class OriginOrPatternString;
 class UsageInfo;
 
 // An abstract interface for quota manager clients.
 // Each storage API must provide an implementation of this interface in order
@@ -34,16 +35,17 @@ public:
   NS_IMETHOD_(MozExternalRefCountType)
   Release() = 0;
 
   enum Type {
     IDB = 0,
     //LS,
     //APPCACHE,
     ASMJS,
+    DOMCACHE,
     TYPE_MAX
   };
 
   virtual Type
   GetType() = 0;
 
   static nsresult
   TypeToText(Type aType, nsAString& aText)
@@ -52,16 +54,20 @@ public:
       case IDB:
         aText.AssignLiteral(IDB_DIRECTORY_NAME);
         break;
 
       case ASMJS:
         aText.AssignLiteral(ASMJSCACHE_DIRECTORY_NAME);
         break;
 
+      case DOMCACHE:
+        aText.AssignLiteral(DOMCACHE_DIRECTORY_NAME);
+        break;
+
       case TYPE_MAX:
       default:
         NS_NOTREACHED("Bad id value!");
         return NS_ERROR_UNEXPECTED;
     }
 
     return NS_OK;
   }
@@ -70,16 +76,19 @@ public:
   TypeFromText(const nsAString& aText, Type& aType)
   {
     if (aText.EqualsLiteral(IDB_DIRECTORY_NAME)) {
       aType = IDB;
     }
     else if (aText.EqualsLiteral(ASMJSCACHE_DIRECTORY_NAME)) {
       aType = ASMJS;
     }
+    else if (aText.EqualsLiteral(DOMCACHE_DIRECTORY_NAME)) {
+      aType = DOMCACHE;
+    }
     else {
       return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
   }
 
   // Methods which are called on the IO thred.
diff --git a/dom/quota/QuotaManager.cpp b/dom/quota/QuotaManager.cpp
--- a/dom/quota/QuotaManager.cpp
+++ b/dom/quota/QuotaManager.cpp
@@ -25,16 +25,17 @@
 #include "nsPIDOMWindow.h"
 
 #include <algorithm>
 #include "GeckoProfiler.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/FileService.h"
+#include "mozilla/dom/cache/QuotaClient.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/LazyIdleThread.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsComponentManagerUtils.h"
 #include "nsAboutProtocolUtils.h"
@@ -1414,27 +1415,28 @@ QuotaManager::Init()
     NS_WARNING("Unable to respond to temp storage pref changes!");
   }
 
   if (NS_FAILED(Preferences::AddBoolVarCache(&gTestingEnabled,
                                              PREF_TESTING_FEATURES, false))) {
     NS_WARNING("Unable to respond to testing pref changes!");
   }
 
-  static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::TYPE_MAX == 2,
-                "Fix the registration!");
+  static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::DOMCACHE == 2 &&
+                Client::TYPE_MAX == 3, "Fix the registration!");
 
   NS_ASSERTION(mClients.Capacity() == Client::TYPE_MAX,
                "Should be using an auto array with correct capacity!");
 
   nsRefPtr<Client> idbClient = indexedDB::CreateQuotaClient();
 
   // Register clients.
   mClients.AppendElement(idbClient);
   mClients.AppendElement(asmjscache::CreateClient());
+  mClients.AppendElement(cache::QuotaClient::Create());
 
   return NS_OK;
 }
 
 void
 QuotaManager::InitQuotaForOrigin(PersistenceType aPersistenceType,
                                  const nsACString& aGroup,
                                  const nsACString& aOrigin,
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -4,16 +4,19 @@
 
 #include "BackgroundChildImpl.h"
 
 #include "ActorsChild.h" // IndexedDB
 #include "BroadcastChannelChild.h"
 #include "FileDescriptorSetChild.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobChild.h"
+#include "mozilla/dom/cache/CacheChild.h"
+#include "mozilla/dom/cache/PCacheStorageChild.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "mozilla/layout/VsyncChild.h"
 #include "nsID.h"
 #include "nsTraceRefcnt.h"
 
 namespace {
@@ -41,16 +44,22 @@ public:
   Recv__delete__(const nsCString& aTestArg) MOZ_OVERRIDE;
 };
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace ipc {
 
+using mozilla::dom::cache::PCacheStorageChild;
+using mozilla::dom::cache::CacheChild;
+using mozilla::dom::cache::PCacheChild;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlChild;
+
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl::ThreadLocal
 // -----------------------------------------------------------------------------
 
 BackgroundChildImpl::
 ThreadLocal::ThreadLocal()
 {
   // May happen on any thread!
@@ -226,16 +235,65 @@ BackgroundChildImpl::DeallocPBroadcastCh
                                                  PBroadcastChannelChild* aActor)
 {
   nsRefPtr<dom::BroadcastChannelChild> child =
     dont_AddRef(static_cast<dom::BroadcastChannelChild*>(aActor));
   MOZ_ASSERT(child);
   return true;
 }
 
+// -----------------------------------------------------------------------------
+// Cache API
+// -----------------------------------------------------------------------------
+
+PCacheStorageChild*
+BackgroundChildImpl::AllocPCacheStorageChild(const Namespace& aNamespace,
+                                             const PrincipalInfo& aPrincipalInfo)
+{
+  MOZ_CRASH("CacheStorageChild actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStorageChild(PCacheStorageChild* aActor)
+{
+  // The CacheStorageChild actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
+PCacheChild*
+BackgroundChildImpl::AllocPCacheChild()
+{
+  return new CacheChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
+{
+  // The CacheChild actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
+PCacheStreamControlChild*
+BackgroundChildImpl::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -6,16 +6,23 @@
 #define mozilla_ipc_backgroundchildimpl_h__
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "nsAutoPtr.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
+
+class PCacheChild;
+class PCacheStorageChild;
+class PCacheStreamControlChild;
+
+} // namespace cache
 namespace indexedDB {
 
 class ThreadLocal;
 
 } // namespace indexedDB
 } // namespace dom
 
 namespace ipc {
@@ -79,16 +86,34 @@ protected:
 
   virtual PBroadcastChannelChild*
   AllocPBroadcastChannelChild(const PrincipalInfo& aPrincipalInfo,
                               const nsString& aOrigin,
                               const nsString& aChannel) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBroadcastChannelChild(PBroadcastChannelChild* aActor) MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheStorageChild*
+  AllocPCacheStorageChild(const dom::cache::Namespace& aNamespace,
+                          const PrincipalInfo& aPrincipalInfo) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStorageChild(dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheChild(dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheStreamControlChild*
+  AllocPCacheStreamControlChild() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStreamControlChild(dom::cache::PCacheStreamControlChild* aActor) MOZ_OVERRIDE;
 };
 
 class BackgroundChildImpl::ThreadLocal MOZ_FINAL
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -6,16 +6,19 @@
 
 #include "BroadcastChannelParent.h"
 #include "FileDescriptorSetParent.h"
 #include "mozilla/AppProcessChecker.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
+#include "mozilla/dom/cache/CacheStorageParent.h"
+#include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "mozilla/layout/VsyncParent.h"
 #include "nsNetUtil.h"
@@ -26,16 +29,20 @@
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
 #else
 #define ASSERT_UNLESS_FUZZING(...) MOZ_ASSERT(false)
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
+using mozilla::dom::cache::PCacheParent;
+using mozilla::dom::cache::CacheStorageParent;
+using mozilla::dom::cache::PCacheStorageParent;
+using mozilla::dom::cache::PCacheStreamControlParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -542,16 +549,62 @@ BackgroundParentImpl::RecvShutdownServic
   nsRefPtr<dom::ServiceWorkerRegistrar> service =
     dom::ServiceWorkerRegistrar::Get();
   MOZ_ASSERT(service);
 
   service->Shutdown();
   return true;
 }
 
+PCacheStorageParent*
+BackgroundParentImpl::AllocPCacheStorageParent(const Namespace& aNamespace,
+                                               const PrincipalInfo& aPrincipalInfo)
+{
+  return new CacheStorageParent(this, aNamespace, aPrincipalInfo);
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStorageParent(PCacheStorageParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PCacheParent*
+BackgroundParentImpl::AllocPCacheParent()
+{
+  MOZ_CRASH("CacheParent actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
+{
+  // The CacheParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
+PCacheStreamControlParent*
+BackgroundParentImpl::AllocPCacheStreamControlParent()
+{
+  MOZ_CRASH("CacheStreamControlParent actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  // The CacheStreamControlParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -5,16 +5,22 @@
 #ifndef mozilla_ipc_backgroundparentimpl_h__
 #define mozilla_ipc_backgroundparentimpl_h__
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
 
+namespace cache {
+class PCacheParent;
+class PCacheStorageParent;
+class PCacheStreamControlParent;
+}
+
 namespace layout {
 class VsyncParent;
 }
 
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
@@ -89,14 +95,32 @@ protected:
                             MOZ_OVERRIDE;
 
   virtual bool
   RecvUnregisterServiceWorker(const PrincipalInfo& aPrincipalInfo,
                               const nsString& aScope) MOZ_OVERRIDE;
 
   virtual bool
   RecvShutdownServiceWorkerRegistrar() MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheStorageParent*
+  AllocPCacheStorageParent(const dom::cache::Namespace& aNamespace,
+                           const PrincipalInfo& aPrincipalInfo) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStorageParent(dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheParent(dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
+
+  virtual dom::cache::PCacheStreamControlParent*
+  AllocPCacheStreamControlParent() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStreamControlParent(dom::cache::PCacheStreamControlParent* aActor) MOZ_OVERRIDE;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,33 +1,41 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
+include protocol PCache;
+include protocol PCacheStorage;
+include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 include ServiceWorkerRegistrarTypes;
 
+using mozilla::dom::cache::Namespace from "mozilla/dom/cache/IPCUtils.h";
+
 namespace mozilla {
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
+  manages PCache;
+  manages PCacheStorage;
+  manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PVsync;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(LoggingInfo loggingInfo);
@@ -36,16 +44,22 @@ parent:
 
   PBroadcastChannel(PrincipalInfo pInfo, nsString origin, nsString channel);
 
   RegisterServiceWorker(ServiceWorkerRegistrationData data);
   UnregisterServiceWorker(PrincipalInfo principalInfo,
                           nsString scope);
   ShutdownServiceWorkerRegistrar();
 
+  PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
+
+child:
+  PCache();
+  PCacheStreamControl();
+
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 };
 
 } // namespace ipc
 } // namespace mozilla
