# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fb5e79062202671784b163eff20ccad059132e69
Bug 1397128 P5 Add ReadStream::Inner::EnsureStream() to synchronously open stream when Availabe/Read/ReadSegments is called. r=asuth

diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -8,16 +8,17 @@
 
 #include "mozilla/Unused.h"
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/ipc/IPCStreamUtils.h"
 #include "mozilla/SnappyUncompressInputStream.h"
 #include "nsIAsyncInputStream.h"
+#include "nsStringStream.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::Unused;
 using mozilla::ipc::AutoIPCStream;
@@ -87,16 +88,22 @@ private:
   Forget();
 
   void
   NoteClosedOnOwningThread();
 
   void
   ForgetOnOwningThread();
 
+  nsIInputStream*
+  EnsureStream();
+
+  void
+  AsyncOpenStreamOnOwningThread();
+
   // Weak ref to the stream control actor.  The actor will always call either
   // CloseStream() or CloseStreamWithoutReporting() before it's destroyed.  The
   // weak ref is cleared in the resulting NoteClosedOnOwningThread() or
   // ForgetOnOwningThread() method call.
   StreamControl* mControl;
 
   const nsID mId;
   nsCOMPtr<nsISerialEventTarget> mOwningEventTarget;
@@ -111,16 +118,17 @@ private:
   Atomic<bool> mHasEverBeenRead;
 
 
   // The wrapped stream objects may not be threadsafe.  We need to be able
   // to close a stream on our owning thread while an IO thread is simultaneously
   // reading the same stream.  Therefore, protect all access to these stream
   // objects with a mutex.
   Mutex mMutex;
+  CondVar mCondVar;
   nsCOMPtr<nsIInputStream> mStream;
   nsCOMPtr<nsIInputStream> mSnappyStream;
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::ReadStream::Inner, override)
 };
 
 // ----------------------------------------------------------------------------
 
@@ -198,16 +206,17 @@ private:
 ReadStream::Inner::Inner(StreamControl* aControl, const nsID& aId,
                          nsIInputStream* aStream)
   : mControl(aControl)
   , mId(aId)
   , mOwningEventTarget(GetCurrentThreadSerialEventTarget())
   , mState(Open)
   , mHasEverBeenRead(false)
   , mMutex("dom::cache::ReadStream")
+  , mCondVar(mMutex, "dom::cache::ReadStream")
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
 {
   MOZ_DIAGNOSTIC_ASSERT(mStream);
   MOZ_DIAGNOSTIC_ASSERT(mControl);
   mControl->AddReadStream(this);
 }
 
@@ -283,30 +292,32 @@ ReadStream::Inner::HasEverBeenRead() con
 
 nsresult
 ReadStream::Inner::Close()
 {
   // stream ops can happen on any thread
   nsresult rv = NS_OK;
   {
     MutexAutoLock lock(mMutex);
-    rv = mSnappyStream->Close();
+    if (mSnappyStream) {
+      rv = mSnappyStream->Close();
+    }
   }
   NoteClosed();
   return rv;
 }
 
 nsresult
 ReadStream::Inner::Available(uint64_t* aNumAvailableOut)
 {
   // stream ops can happen on any thread
   nsresult rv = NS_OK;
   {
     MutexAutoLock lock(mMutex);
-    rv = mSnappyStream->Available(aNumAvailableOut);
+    rv = EnsureStream()->Available(aNumAvailableOut);
   }
 
   if (NS_FAILED(rv)) {
     Close();
   }
 
   return rv;
 }
@@ -315,17 +326,17 @@ nsresult
 ReadStream::Inner::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
 {
   // stream ops can happen on any thread
   MOZ_DIAGNOSTIC_ASSERT(aNumReadOut);
 
   nsresult rv = NS_OK;
   {
     MutexAutoLock lock(mMutex);
-    rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
+    rv = EnsureStream()->Read(aBuf, aCount, aNumReadOut);
   }
 
   if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
       *aNumReadOut == 0) {
     Close();
   }
 
   mHasEverBeenRead = true;
@@ -343,17 +354,17 @@ ReadStream::Inner::ReadSegments(nsWriteS
   if (aCount) {
     mHasEverBeenRead = true;
   }
 
 
   nsresult rv = NS_OK;
   {
     MutexAutoLock lock(mMutex);
-    rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+    rv = EnsureStream()->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
   }
 
   if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
                         rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
     Close();
   }
 
   // Verify bytes were actually read before marking as being ever read.  For
@@ -367,17 +378,21 @@ ReadStream::Inner::ReadSegments(nsWriteS
   return rv;
 }
 
 nsresult
 ReadStream::Inner::IsNonBlocking(bool* aNonBlockingOut)
 {
   // stream ops can happen on any thread
   MutexAutoLock lock(mMutex);
-  return mSnappyStream->IsNonBlocking(aNonBlockingOut);
+  if (mSnappyStream) {
+    return mSnappyStream->IsNonBlocking(aNonBlockingOut);
+  }
+  *aNonBlockingOut = false;
+  return NS_OK;
 }
 
 ReadStream::Inner::~Inner()
 {
   // Any thread
   MOZ_DIAGNOSTIC_ASSERT(mState == Closed);
   MOZ_DIAGNOSTIC_ASSERT(!mControl);
 }
@@ -443,16 +458,75 @@ ReadStream::Inner::ForgetOnOwningThread(
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(mControl);
   mControl->ForgetReadStream(this);
   mControl = nullptr;
 }
 
+nsIInputStream*
+ReadStream::Inner::EnsureStream()
+{
+  mMutex.AssertCurrentThreadOwns();
+
+  // We need to block the current thread while we open the stream.  We
+  // cannot do this safely from the main owning thread since it would
+  // trigger deadlock.  This should be ok, though, since a blocking
+  // stream like this should never be read on the owning thread anyway.
+  if (mOwningEventTarget->IsOnCurrentThread()) {
+    MOZ_CRASH("Blocking read on the js/ipc owning thread!");
+  }
+
+  if (mSnappyStream) {
+    return mSnappyStream;
+  }
+
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod("ReadStream::Inner::AsyncOpenStreamOnOwningThread",
+                      this, &ReadStream::Inner::AsyncOpenStreamOnOwningThread);
+  nsresult rv = mOwningEventTarget->Dispatch(r.forget(),
+                                             nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Unused << NS_NewCStringInputStream(getter_AddRefs(mStream), EmptyCString());
+    mSnappyStream = new SnappyUncompressInputStream(mStream);
+    return mSnappyStream;
+  }
+
+  mCondVar.Wait();
+  MOZ_DIAGNOSTIC_ASSERT(mSnappyStream);
+
+  return mSnappyStream;
+}
+
+void
+ReadStream::Inner::AsyncOpenStreamOnOwningThread()
+{
+  MOZ_ASSERT(mOwningEventTarget->IsOnCurrentThread());
+
+  if (!mControl) {
+    MutexAutoLock lock(mMutex);
+    Unused << NS_NewCStringInputStream(getter_AddRefs(mStream), EmptyCString());
+    mSnappyStream = new SnappyUncompressInputStream(mStream);
+    mCondVar.Notify();
+    return;
+  }
+
+  RefPtr<ReadStream::Inner> self = this;
+  mControl->OpenStream(mId, [self](nsCOMPtr<nsIInputStream>&& aStream) {
+    MutexAutoLock lock(self->mMutex);
+    self->mStream = Move(aStream);
+    if (!self->mStream) {
+      Unused << NS_NewCStringInputStream(getter_AddRefs(self->mStream), EmptyCString());
+    }
+    self->mSnappyStream = new SnappyUncompressInputStream(self->mStream);
+    self->mCondVar.Notify();
+  });
+}
+
 // ----------------------------------------------------------------------------
 
 NS_IMPL_ISUPPORTS(cache::ReadStream, nsIInputStream, ReadStream);
 
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(const CacheReadStreamOrVoid& aReadStreamOrVoid)
 {
