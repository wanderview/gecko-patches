# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e758bf489aa3bf92ac2c15e508f04cd285d53516
Bug 1350433 Expose WorkerPrivate::ServiceWorkerScope() instead of using WorkerName() all over the place. r=asuth

diff --git a/dom/console/Console.cpp b/dom/console/Console.cpp
--- a/dom/console/Console.cpp
+++ b/dom/console/Console.cpp
@@ -588,17 +588,17 @@ private:
       nsString id = frame.mFilename;
       nsString innerID;
       if (mWorkerPrivate->IsSharedWorker()) {
         innerID = NS_LITERAL_STRING("SharedWorker");
       } else if (mWorkerPrivate->IsServiceWorker()) {
         innerID = NS_LITERAL_STRING("ServiceWorker");
         // Use scope as ID so the webconsole can decide if the message should
         // show up per tab
-        id.AssignWithConversion(mWorkerPrivate->WorkerName());
+        id.AssignWithConversion(mWorkerPrivate->ServiceWorkerScope());
       } else {
         innerID = NS_LITERAL_STRING("Worker");
       }
 
       mCallData->SetIDs(id, innerID);
     }
 
     // Now we could have the correct window (if we are not window-less).
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -686,17 +686,17 @@ WorkerFetchResolver::FlushConsoleReport(
   if (worker->IsServiceWorker()) {
     // Flush to service worker
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       mReporter->FlushReportsToConsole(0);
       return;
     }
 
-    swm->FlushReportsToAllClients(worker->WorkerName(), mReporter);
+    swm->FlushReportsToAllClients(worker->ServiceWorkerScope(), mReporter);
     return;
   }
 
   if (worker->IsSharedWorker()) {
     // Flush to shared worker
     worker->FlushReportsToSharedWorkers(mReporter);
     return;
   }
diff --git a/dom/workers/ServiceWorkerClient.cpp b/dom/workers/ServiceWorkerClient.cpp
--- a/dom/workers/ServiceWorkerClient.cpp
+++ b/dom/workers/ServiceWorkerClient.cpp
@@ -260,17 +260,17 @@ ServiceWorkerClient::PostMessage(JSConte
                                                           &transferable);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   // At the moment we only expose Client on ServiceWorker globals.
   MOZ_ASSERT(workerPrivate->IsServiceWorker());
   uint32_t serviceWorkerID = workerPrivate->ServiceWorkerID();
-  nsCString scope = workerPrivate->WorkerName();
+  nsCString scope = workerPrivate->ServiceWorkerScope();
 
   RefPtr<ServiceWorkerClientPostMessageRunnable> runnable =
     new ServiceWorkerClientPostMessageRunnable(serviceWorkerID, scope,
                                                mWindowId);
 
   runnable->Write(aCx, aMessage, transferable, JS::CloneDataPolicy().denySharedArrayBuffer(),
                   aRv);
   if (NS_WARN_IF(aRv.Failed())) {
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -828,17 +828,17 @@ class WaitUntilHandler final : public Pr
   {
   }
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
   WaitUntilHandler(WorkerPrivate* aWorkerPrivate, JSContext* aCx)
     : mWorkerPrivate(aWorkerPrivate)
-    , mScope(mWorkerPrivate->WorkerName())
+    , mScope(mWorkerPrivate->ServiceWorkerScope())
     , mLine(0)
     , mColumn(0)
   {
     mWorkerPrivate->AssertIsOnWorkerThread();
 
     // Save the location of the waitUntil() call itself as a fallback
     // in case the rejection value does not contain any location info.
     nsJSUtils::GetCallingLocation(aCx, mSourceSpec, &mLine, &mColumn);
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -533,17 +533,17 @@ private:
                                                     /* isErrorEvent */ false);
       return true;
     }
 
     if (aWorkerPrivate->IsServiceWorker()) {
       RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
       if (swm) {
         swm->HandleError(aCx, aWorkerPrivate->GetPrincipal(),
-                         aWorkerPrivate->WorkerName(),
+                         aWorkerPrivate->ServiceWorkerScope(),
                          aWorkerPrivate->ScriptURL(),
                          EmptyString(), EmptyString(), EmptyString(),
                          0, 0, JSREPORT_ERROR, JSEXN_ERR);
       }
       return true;
     }
 
     if (!aWorkerPrivate->IsAcceptingEvents()) {
@@ -1176,17 +1176,17 @@ private:
 
       // Service workers do not have a main thread parent global, so normal
       // worker error reporting will crash.  Instead, pass the error to
       // the ServiceWorkerManager to report on any controlled documents.
       if (aWorkerPrivate->IsServiceWorker()) {
         RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
         if (swm) {
           swm->HandleError(aCx, aWorkerPrivate->GetPrincipal(),
-                           aWorkerPrivate->WorkerName(),
+                           aWorkerPrivate->ServiceWorkerScope(),
                            aWorkerPrivate->ScriptURL(),
                            mReport.mMessage,
                            mReport.mFilename, mReport.mLine, mReport.mLineNumber,
                            mReport.mColumnNumber, mReport.mFlags,
                            mReport.mExnType);
         }
         return true;
       }
@@ -6902,17 +6902,17 @@ WorkerPrivate::GetOrCreateGlobalScope(JS
 {
   AssertIsOnWorkerThread();
 
   if (!mScope) {
     RefPtr<WorkerGlobalScope> globalScope;
     if (IsSharedWorker()) {
       globalScope = new SharedWorkerGlobalScope(this, WorkerName());
     } else if (IsServiceWorker()) {
-      globalScope = new ServiceWorkerGlobalScope(this, WorkerName());
+      globalScope = new ServiceWorkerGlobalScope(this, ServiceWorkerScope());
     } else {
       globalScope = new DedicatedWorkerGlobalScope(this);
     }
 
     JS::Rooted<JSObject*> global(aCx);
     NS_ENSURE_TRUE(globalScope->WrapGlobalObject(aCx, &global), nullptr);
 
     JSAutoCompartment ac(aCx, global);
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -521,16 +521,23 @@ public:
   }
 
   uint64_t
   ServiceWorkerID() const
   {
     return mLoadInfo.mServiceWorkerID;
   }
 
+  const nsCString&
+  ServiceWorkerScope() const
+  {
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+    return mWorkerName;
+  }
+
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
 
   void
@@ -830,17 +837,17 @@ public:
       MOZ_ASSERT_UNREACHABLE("Invalid worker type");
       return nsIContentPolicy::TYPE_INVALID;
     }
   }
 
   const nsCString&
   WorkerName() const
   {
-    MOZ_ASSERT(IsServiceWorker() || IsSharedWorker());
+    MOZ_ASSERT(IsSharedWorker());
     return mWorkerName;
   }
 
   bool
   IsStorageAllowed() const
   {
     return mLoadInfo.mStorageAllowed;
   }
