# HG changeset patch
# Parent 34828fed163992d13fa46d5a087f2f4a1b3d09ae
# User Ben Kelly <ben@wanderview.com>
Bug 1160013 CachePushStreamChild should hold the parent DOM object alive. r=baku

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -507,17 +507,17 @@ Cache::AssertOwningThread() const
 #endif
 
 CachePushStreamChild*
 Cache::CreatePushStream(nsIAsyncInputStream* aStream)
 {
   NS_ASSERT_OWNINGTHREAD(Cache);
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(aStream);
-  return mActor->CreatePushStream(aStream);
+  return mActor->CreatePushStream(this, aStream);
 }
 
 Cache::~Cache()
 {
   NS_ASSERT_OWNINGTHREAD(Cache);
   if (mActor) {
     mActor->StartDestroyFromListener();
     // DestroyInternal() is called synchronously by StartDestroyFromListener().
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -68,21 +68,21 @@ CacheChild::ExecuteOp(nsIGlobalObject* a
                       nsISupports* aParent, const CacheOpArgs& aArgs)
 {
   mNumChildActors += 1;
   MOZ_ALWAYS_TRUE(SendPCacheOpConstructor(
     new CacheOpChild(GetFeature(), aGlobal, aParent, aPromise), aArgs));
 }
 
 CachePushStreamChild*
-CacheChild::CreatePushStream(nsIAsyncInputStream* aStream)
+CacheChild::CreatePushStream(nsISupports* aParent, nsIAsyncInputStream* aStream)
 {
   mNumChildActors += 1;
   auto actor = SendPCachePushStreamConstructor(
-    new CachePushStreamChild(GetFeature(), aStream));
+    new CachePushStreamChild(GetFeature(), aParent, aStream));
   MOZ_ASSERT(actor);
   return static_cast<CachePushStreamChild*>(actor);
 }
 
 void
 CacheChild::StartDestroyFromListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -38,17 +38,17 @@ public:
   // its destructor to trigger ActorDestroy() if it has not been called yet.
   void ClearListener();
 
   void
   ExecuteOp(nsIGlobalObject* aGlobal, Promise* aPromise,
             nsISupports* aParent, const CacheOpArgs& aArgs);
 
   CachePushStreamChild*
-  CreatePushStream(nsIAsyncInputStream* aStream);
+  CreatePushStream(nsISupports* aParent, nsIAsyncInputStream* aStream);
 
   // Our parent Listener object has gone out of scope and is being destroyed.
   void StartDestroyFromListener();
 
 private:
   // ActorChild methods
 
   // Feature is trying to destroy due to worker shutdown.
diff --git a/dom/cache/CachePushStreamChild.cpp b/dom/cache/CachePushStreamChild.cpp
--- a/dom/cache/CachePushStreamChild.cpp
+++ b/dom/cache/CachePushStreamChild.cpp
@@ -88,20 +88,23 @@ private:
   NS_DECL_THREADSAFE_ISUPPORTS
 };
 
 NS_IMPL_ISUPPORTS(CachePushStreamChild::Callback, nsIInputStreamCallback,
                                                   nsIRunnable,
                                                   nsICancelableRunnable);
 
 CachePushStreamChild::CachePushStreamChild(Feature* aFeature,
+                                           nsISupports* aParent,
                                            nsIAsyncInputStream* aStream)
-  : mStream(aStream)
+  : mParent(aParent)
+  , mStream(aStream)
   , mClosed(false)
 {
+  MOZ_ASSERT(mParent);
   MOZ_ASSERT(mStream);
   MOZ_ASSERT_IF(!NS_IsMainThread(), aFeature);
   SetFeature(aFeature);
 }
 
 CachePushStreamChild::~CachePushStreamChild()
 {
   NS_ASSERT_OWNINGTHREAD(CachePushStreamChild);
diff --git a/dom/cache/CachePushStreamChild.h b/dom/cache/CachePushStreamChild.h
--- a/dom/cache/CachePushStreamChild.h
+++ b/dom/cache/CachePushStreamChild.h
@@ -26,31 +26,33 @@ public:
   void Start();
 
   virtual void StartDestroy() override;
 
 private:
   class Callback;
 
   // This class must be constructed using CacheChild::CreatePushStream()
-  CachePushStreamChild(Feature* aFeature, nsIAsyncInputStream* aStream);
+  CachePushStreamChild(Feature* aFeature, nsISupports* aParent,
+                       nsIAsyncInputStream* aStream);
   ~CachePushStreamChild();
 
   // PCachePushStreamChild methods
   virtual void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   void DoRead();
 
   void Wait();
 
   void OnStreamReady(Callback* aCallback);
 
   void OnEnd(nsresult aRv);
 
+  nsCOMPtr<nsISupports> mParent;
   nsCOMPtr<nsIAsyncInputStream> mStream;
   nsRefPtr<Callback> mCallback;
   bool mClosed;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
