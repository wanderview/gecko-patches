# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6229e775b895f1923cdbfe6825fbfabb4efe4ed0
Bug 1397128 P9 Make content script usage of Cache API use lazy body loading. r=tt

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -283,17 +283,17 @@ Cache::Match(JSContext* aCx, const Reque
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this,
-                       CacheMatchArgs(CacheRequest(), params, OpenMode::Eager),
+                       CacheMatchArgs(CacheRequest(), params, GetOpenMode()),
                        1);
 
   args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
@@ -309,17 +309,17 @@ Cache::MatchAll(JSContext* aCx, const Op
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this,
-                       CacheMatchAllArgs(void_t(), params, OpenMode::Eager),
+                       CacheMatchAllArgs(void_t(), params, GetOpenMode()),
                        1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir = ToInternalRequest(aCx, aRequest.Value(),
                                                    IgnoreBody, aRv);
     if (aRv.Failed()) {
       return nullptr;
     }
@@ -493,17 +493,17 @@ Cache::Keys(JSContext* aCx, const Option
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this,
-                       CacheKeysArgs(void_t(), params, OpenMode::Eager),
+                       CacheKeysArgs(void_t(), params, GetOpenMode()),
                        1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir =
       ToInternalRequest(aCx, aRequest.Value(), IgnoreBody, aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
@@ -686,11 +686,17 @@ Cache::PutAll(JSContext* aCx, const nsTA
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   }
 
   return ExecuteOp(args, aRv);
 }
 
+OpenMode
+Cache::GetOpenMode() const
+{
+  return mNamespace == CHROME_ONLY_NAMESPACE ? OpenMode::Eager : OpenMode::Lazy;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -102,16 +102,19 @@ private:
   AddAll(const GlobalObject& aGlobal, nsTArray<RefPtr<Request>>&& aRequestList,
          CallerType aCallerType, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   PutAll(JSContext* aCx, const nsTArray<RefPtr<Request>>& aRequestList,
          const nsTArray<RefPtr<Response>>& aResponseList,
          ErrorResult& aRv);
 
+  OpenMode
+  GetOpenMode() const;
+
   nsCOMPtr<nsIGlobalObject> mGlobal;
   CacheChild* mActor;
   const Namespace mNamespace;
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Cache)
 };
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -328,17 +328,17 @@ CacheStorage::Match(JSContext* aCx, cons
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
-  entry->mArgs = StorageMatchArgs(CacheRequest(), params, OpenMode::Eager);
+  entry->mArgs = StorageMatchArgs(CacheRequest(), params, GetOpenMode());
   entry->mRequest = request;
 
   mPendingRequests.AppendElement(entry.forget());
   MaybeRunPendingRequests();
 
   return promise.forget();
 }
 
@@ -612,11 +612,17 @@ CacheStorage::MaybeRunPendingRequests()
       entry->mPromise->MaybeReject(rv);
       continue;
     }
     mActor->ExecuteOp(mGlobal, entry->mPromise, this, args.SendAsOpArgs());
   }
   mPendingRequests.Clear();
 }
 
+OpenMode
+CacheStorage::GetOpenMode() const
+{
+  return mNamespace == CHROME_ONLY_NAMESPACE ? OpenMode::Eager : OpenMode::Lazy;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -99,16 +99,19 @@ private:
   CacheStorage(Namespace aNamespace, nsIGlobalObject* aGlobal,
                const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                CacheWorkerHolder* aWorkerHolder);
   explicit CacheStorage(nsresult aFailureResult);
   ~CacheStorage();
 
   void MaybeRunPendingRequests();
 
+  OpenMode
+  GetOpenMode() const;
+
   const Namespace mNamespace;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
   RefPtr<CacheWorkerHolder> mWorkerHolder;
 
   // weak ref cleared in DestroyInternal
   CacheStorageChild* mActor;
 
