# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5dc14dd65d13a040ec0b120dbec393c0353671a8

diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -98,22 +98,16 @@ ServiceWorkerRegistrationMainThread::Reg
   // whether there is still anything to do here.
   if (mOuter) {
     mOuter->RegistrationRemoved();
   }
   StopListeningForEvents();
 }
 
 void
-ServiceWorkerRegistrationMainThread::UpdateFound()
-{
-  mOuter->DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
-}
-
-void
 ServiceWorkerRegistrationMainThread::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
   NS_ENSURE_TRUE_VOID(mOuter);
 
   nsIGlobalObject* global = mOuter->GetParentObject();
   NS_ENSURE_TRUE_VOID(global);
 
   RefPtr<ServiceWorkerRegistrationMainThread> self = this;
@@ -638,34 +632,38 @@ ServiceWorkerRegistrationMainThread::Unr
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
   ServiceWorkerRegistrationDescriptor mDescriptor;
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mInfo;
+  nsCOMPtr<nsISerialEventTarget> mEventTarget;
   bool mListeningForEvents;
 
   // Set and unset on worker thread, used on main-thread and protected by mutex.
   ServiceWorkerRegistrationWorkerThread* mRegistration;
 
   Mutex mMutex;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(WorkerListener, override)
 
   WorkerListener(ServiceWorkerRegistrationWorkerThread* aReg,
-                 const ServiceWorkerRegistrationDescriptor& aDescriptor)
+                 const ServiceWorkerRegistrationDescriptor& aDescriptor,
+                 nsISerialEventTarget* aEventTarget)
     : mDescriptor(aDescriptor)
+    , mEventTarget(aEventTarget)
     , mListeningForEvents(false)
     , mRegistration(aReg)
     , mMutex("WorkerListener::mMutex")
   {
     MOZ_ASSERT(IsCurrentThreadRunningWorker());
+    MOZ_ASSERT(mEventTarget);
     MOZ_ASSERT(mRegistration);
   }
 
   void
   StartListeningForEvents()
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_DIAGNOSTIC_ASSERT(!mListeningForEvents);
@@ -696,24 +694,39 @@ public:
 
     MOZ_DIAGNOSTIC_ASSERT(mInfo);
     mInfo->RemoveInstance(this);
     mListeningForEvents = false;
   }
 
   // ServiceWorkerRegistrationListener
   void
-  UpdateFound() override;
-
-  void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) override
   {
     MOZ_ASSERT(NS_IsMainThread());
+
     mDescriptor = aDescriptor;
-    // TODO: Not implemented
+
+    nsCOMPtr<nsIRunnable> r =
+      NewCancelableRunnableMethod<ServiceWorkerRegistrationDescriptor>(
+        "WorkerListener::UpdateState",
+        this,
+        &WorkerListener::UpdateStateOnWorkerThread,
+        aDescriptor);
+
+    Unused << mEventTarget->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
+  }
+
+  void
+  UpdateStateOnWorkerThread(const ServiceWorkerRegistrationDescriptor& aDescriptor)
+  {
+    MOZ_ASSERT(IsCurrentThreadRunningWorker());
+    if (mRegistration) {
+      mRegistration->UpdateState(aDescriptor);
+    }
   }
 
   void
   RegistrationRemoved() override;
 
   void
   GetScope(nsAString& aScope) const override
   {
@@ -918,17 +931,17 @@ ServiceWorkerRegistrationWorkerThread::I
     // late.
     self->mOuter = nullptr;
   });
 
   if (NS_WARN_IF(!mWorkerRef)) {
     return;
   }
 
-  mListener = new WorkerListener(this, mDescriptor);
+  mListener = new WorkerListener(this, mDescriptor, worker->HybridEventTarget());
 
   nsCOMPtr<nsIRunnable> r =
     NewRunnableMethod("dom::WorkerListener::StartListeningForEvents",
                       mListener,
                       &WorkerListener::StartListeningForEvents);
   MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(r.forget()));
 }
 
@@ -939,68 +952,33 @@ ServiceWorkerRegistrationWorkerThread::R
     return;
   }
 
   MOZ_ASSERT(IsCurrentThreadRunningWorker());
 
   mListener->ClearRegistration();
 
   nsCOMPtr<nsIRunnable> r =
-    NewRunnableMethod("dom::WorkerListener::StopListeningForEvents",
-                      mListener,
-                      &WorkerListener::StopListeningForEvents);
+    NewCancelableRunnableMethod("dom::WorkerListener::StopListeningForEvents",
+                                mListener,
+                                &WorkerListener::StopListeningForEvents);
   // Calling GetPrivate() is safe because this method is called when the
   // WorkerRef is notified.
   MOZ_ALWAYS_SUCCEEDS(mWorkerRef->GetPrivate()->DispatchToMainThread(r.forget()));
 
   mListener = nullptr;
   mWorkerRef = nullptr;
 }
 
-class FireUpdateFoundRunnable final : public WorkerRunnable
+void
+ServiceWorkerRegistrationWorkerThread::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  RefPtr<WorkerListener> mListener;
-public:
-  FireUpdateFoundRunnable(WorkerPrivate* aWorkerPrivate,
-                          WorkerListener* aListener)
-    : WorkerRunnable(aWorkerPrivate)
-    , mListener(aListener)
-  {
-    // Need this assertion for now since runnables which modify busy count can
-    // only be dispatched from parent thread to worker thread and we don't deal
-    // with nested workers. SW threads can't be nested.
-    MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
+  if (mOuter) {
+    mOuter->UpdateState(aDescriptor);
   }
-
-  bool
-  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
-  {
-    MOZ_ASSERT(aWorkerPrivate);
-    aWorkerPrivate->AssertIsOnWorkerThread();
-    mListener->UpdateFound();
-    return true;
-  }
-};
-
-void
-WorkerListener::UpdateFound()
-{
-  MutexAutoLock lock(mMutex);
-  if (!mRegistration) {
-    return;
-  }
-
-  if (NS_IsMainThread()) {
-    RefPtr<FireUpdateFoundRunnable> r =
-      new FireUpdateFoundRunnable(mRegistration->GetWorkerPrivate(lock), this);
-    Unused << NS_WARN_IF(!r->Dispatch());
-    return;
-  }
-
-  mRegistration->UpdateFound();
 }
 
 class RegistrationRemovedWorkerRunnable final : public WorkerRunnable
 {
   RefPtr<WorkerListener> mListener;
 public:
   RegistrationRemovedWorkerRunnable(WorkerPrivate* aWorkerPrivate,
                                     WorkerListener* aListener)
@@ -1038,22 +1016,16 @@ WorkerListener::RegistrationRemoved()
 
     StopListeningForEvents();
     return;
   }
 
   mRegistration->RegistrationRemoved();
 }
 
-void
-ServiceWorkerRegistrationWorkerThread::UpdateFound()
-{
-  mOuter->DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
-}
-
 WorkerPrivate*
 ServiceWorkerRegistrationWorkerThread::GetWorkerPrivate(const MutexAutoLock& aProofOfLock)
 {
   // In this case, calling GetUnsafePrivate() is ok because we have a proof of
   // mutex lock.
   MOZ_ASSERT(mWorkerRef && mWorkerRef->GetUnsafePrivate());
   return mWorkerRef->GetUnsafePrivate();
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
@@ -47,19 +47,16 @@ public:
          ServiceWorkerFailureCallback&& aFailureCB) override;
 
   void
   Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
              ServiceWorkerFailureCallback&& aFailureCB) override;
 
   // ServiceWorkerRegistrationListener
   void
-  UpdateFound() override;
-
-  void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) override;
 
   void
   RegistrationRemoved() override;
 
   void
   GetScope(nsAString& aScope) const override
   {
@@ -115,28 +112,28 @@ public:
   void
   Update(ServiceWorkerRegistrationCallback&& aSuccessCB,
          ServiceWorkerFailureCallback&& aFailureCB) override;
 
   void
   Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
              ServiceWorkerFailureCallback&& aFailureCB) override;
 
-  void
-  UpdateFound();
-
 private:
   ~ServiceWorkerRegistrationWorkerThread();
 
   void
   InitListener();
 
   void
   ReleaseListener();
 
+  void
+  UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor);
+
   // This can be called only by WorkerListener.
   WorkerPrivate*
   GetWorkerPrivate(const MutexAutoLock& aProofOfLock);
 
   ServiceWorkerRegistration* mOuter;
   const ServiceWorkerRegistrationDescriptor mDescriptor;
   const nsString mScope;
   RefPtr<WorkerListener> mListener;
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -802,26 +802,16 @@ ServiceWorkerRegistrationInfo::GetUpdate
   if (!mControlledClientsCounter && mDelayMultiplier < (INT_MAX / 30)) {
     mDelayMultiplier = (mDelayMultiplier ? mDelayMultiplier : 1) * 30;
   }
 
   return delay;
 }
 
 void
-ServiceWorkerRegistrationInfo::FireUpdateFound()
-{
-  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
-  while (it.HasMore()) {
-    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
-    target->UpdateFound();
-  }
-}
-
-void
 ServiceWorkerRegistrationInfo::NotifyRemoved()
 {
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     target->RegistrationRemoved();
   }
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationListener.h b/dom/serviceworkers/ServiceWorkerRegistrationListener.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationListener.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationListener.h
@@ -15,19 +15,16 @@ class ServiceWorkerRegistrationDescripto
 // Used by ServiceWorkerManager to notify ServiceWorkerRegistrations of
 // updatefound event and invalidating ServiceWorker instances.
 class ServiceWorkerRegistrationListener
 {
 public:
   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
 
   virtual void
-  UpdateFound() = 0;
-
-  virtual void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) = 0;
 
   virtual void
   RegistrationRemoved() = 0;
 
   virtual void
   GetScope(nsAString& aScope) const = 0;
 
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -534,22 +534,19 @@ ServiceWorkerUpdateJob::Install()
   mRegistration->TransitionEvaluatingToInstalling();
 
   // Step 6 of the Install algorithm resolving the job promise.
   InvokeResultCallbacks(NS_OK);
 
   // The job promise cannot be rejected after this point, but the job can
   // still fail; e.g. if the install event handler throws, etc.
 
-  // fire the updatefound event
-  nsCOMPtr<nsIRunnable> upr = NewRunnableMethod(
-      "ServiceWorkerRegistrationInfo::FireUpdateFound",
-      mRegistration,
-      &ServiceWorkerRegistrationInfo::FireUpdateFound);
-  NS_DispatchToMainThread(upr);
+  // Note, the updatefound event is fired automatically when the installing
+  // property is set on the ServiceWorkerRegistration binding object.  This
+  // happens via the TransitionEvaluatingToInstalling() call above.
 
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
     new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(
       "ServiceWorkerUpdateJob", this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
 
   // Send the install event to the worker thread
   ServiceWorkerPrivate* workerPrivate =
