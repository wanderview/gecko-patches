# HG changeset patch
# Parent d0c864b8fa7791f50b0c03ba3af9b0c81431870c
# User Ben Kelly <ben@wanderview.com>
Bug 1172629 Skip Cache restart and shrink tests if dom.caches.enabled is not set.  r=ehsan

diff --git a/dom/cache/test/mochitest/test_cache_restart.html b/dom/cache/test/mochitest/test_cache_restart.html
--- a/dom/cache/test/mochitest/test_cache_restart.html
+++ b/dom/cache/test/mochitest/test_cache_restart.html
@@ -19,43 +19,47 @@ function resetStorage() {
       appId = principal.appId;
       inBrowser = principal.isInBrowserElement;
     }
     SpecialPowers.resetStorageForURI(document.documentURI, resolve, appId,
                                      inBrowser);
   });
 }
 
-SimpleTest.waitForExplicitFinish();
-SpecialPowers.pushPrefEnv({
-  "set": [["dom.caches.enabled", true],
-          ["dom.quotaManager.testing", true]],
-}, function() {
-  var name = 'foo';
-  var url = './test_cache_add.js';
-  var cache;
-  caches.open(name).then(function(c) {
-    cache = c;
-    return cache.add(url);
-  }).then(function() {
-    return resetStorage();
-  }).then(function() {
-    return cache.match(url).then(function(resp) {
-      ok(false, 'old cache reference should not work after reset');
-    }).catch(function(err) {
-      ok(true, 'old cache reference should not work after reset');
+// Only run this test when Cache API is already enabled
+if (!SpecialPowers.getBoolPref('dom.caches.enabled')) {
+  ok(true, 'skipping test since dom.caches.enabled is false');
+} else {
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({
+    "set": [["dom.quotaManager.testing", true]]
+  }, function() {
+    var name = 'foo';
+    var url = './test_cache_add.js';
+    var cache;
+    caches.open(name).then(function(c) {
+      cache = c;
+      return cache.add(url);
+    }).then(function() {
+      return resetStorage();
+    }).then(function() {
+      return cache.match(url).then(function(resp) {
+        ok(false, 'old cache reference should not work after reset');
+      }).catch(function(err) {
+        ok(true, 'old cache reference should not work after reset');
+      });
+    }).then(function() {
+      return caches.open(name);
+    }).then(function(c) {
+      cache = c;
+      return cache.match(url);
+    }).then(function(resp) {
+      ok(!!resp, 'cache should work after QM reset');
+      return caches.delete(name);
+    }).then(function(success) {
+      ok(success, 'cache should be deleted');
+      SimpleTest.finish();
     });
-  }).then(function() {
-    return caches.open(name);
-  }).then(function(c) {
-    cache = c;
-    return cache.match(url);
-  }).then(function(resp) {
-    ok(!!resp, 'cache should work after QM reset');
-    return caches.delete(name);
-  }).then(function(success) {
-    ok(success, 'cache should be deleted');
-    SimpleTest.finish();
   });
-});
+}
 </script>
 </body>
 </html>
diff --git a/dom/cache/test/mochitest/test_cache_shrink.html b/dom/cache/test/mochitest/test_cache_shrink.html
--- a/dom/cache/test/mochitest/test_cache_shrink.html
+++ b/dom/cache/test/mochitest/test_cache_shrink.html
@@ -56,76 +56,80 @@ function resetStorage() {
 }
 
 function gc() {
   return new Promise(function(resolve, reject) {
     SpecialPowers.exactGC(window, resolve);
   });
 }
 
-SimpleTest.waitForExplicitFinish();
-SpecialPowers.pushPrefEnv({
-  "set": [["dom.caches.enabled", true],
-          ["dom.quotaManager.testing", true]],
-}, function() {
-  var name = 'foo';
-  var cache = null;
-  var initialUsage = 0;
-  var fullUsage = 0;
-  var endUsage = 0;
-  // start from a fresh origin directory so other tests do not influence our
-  // results
-  clearStorage().then(function() {
-    return storageUsage();
-  }).then(function(usage) {
-    is(0, usage, 'disk usage should be zero to start');
-    return caches.open(name);
-  }).then(function(c) {
-    cache = c;
-    return storageUsage();
-  }).then(function(usage) {
-    initialUsage = usage;
-    return Promise.all(largeUrlList.map(function(url) {
-      return cache.put(new Request(url), new Response());
-    }));
-  }).then(function() {
-    return cache.keys();
-  }).then(function(keyList) {
-    is(keyList.length, largeUrlList.length, 'Large URL list is stored in cache');
-    cache = null;
-    // Ensure the Cache DOM object is gone before proceeding.  If its alive
-    // it will keep the related entries on-disk as well.
-    return gc();
-  }).then(function() {
-    // reset the quota manager storage to ensure the DB connection is flushed
-    return resetStorage();
-  }).then(function() {
-    return storageUsage();
-  }).then(function(usage) {
-    fullUsage = usage;
-    ok(fullUsage > initialUsage, 'disk usage should have grown');
-    return caches.delete(name);
-  }).then(function(result) {
-    ok(result, 'cache should be deleted');
-    // This is a bit superfluous, but its necessary to make sure the Cache is
-    // fully deleted before we proceed.  The deletion actually takes place in
-    // two async steps.  We don't want to resetStorage() until the second step
-    // has taken place.  This extra Cache operation ensure that all the
-    // runnables have been flushed through the threads, etc.
-    return caches.has(name);
-  }).then(function(result) {
-    ok(!result, 'cache should not exist in storage');
-    // reset the quota manager storage to ensure the DB connection is flushed
-    return resetStorage();
-  }).then(function() {
-    return storageUsage();
-  }).then(function(usage) {
-    endUsage = usage;
-    dump("### ### initial:" + initialUsage + ", full:" + fullUsage +
-         ", end:" + endUsage + "\n");
-    ok(endUsage < (fullUsage / 2), 'disk usage should have shrank significantly');
-    ok(endUsage > initialUsage, 'disk usage should not shrink back to orig size');
-    SimpleTest.finish();
+// Only run this test when Cache API is already enabled
+if (!SpecialPowers.getBoolPref('dom.caches.enabled')) {
+  ok(true, 'skipping test since dom.caches.enabled is false');
+} else {
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({
+    "set": [["dom.quotaManager.testing", true]]
+  }, function() {
+    var name = 'foo';
+    var cache = null;
+    var initialUsage = 0;
+    var fullUsage = 0;
+    var endUsage = 0;
+    // start from a fresh origin directory so other tests do not influence our
+    // results
+    clearStorage().then(function() {
+      return storageUsage();
+    }).then(function(usage) {
+      is(0, usage, 'disk usage should be zero to start');
+      return caches.open(name);
+    }).then(function(c) {
+      cache = c;
+      return storageUsage();
+    }).then(function(usage) {
+      initialUsage = usage;
+      return Promise.all(largeUrlList.map(function(url) {
+        return cache.put(new Request(url), new Response());
+      }));
+    }).then(function() {
+      return cache.keys();
+    }).then(function(keyList) {
+      is(keyList.length, largeUrlList.length, 'Large URL list is stored in cache');
+      cache = null;
+      // Ensure the Cache DOM object is gone before proceeding.  If its alive
+      // it will keep the related entries on-disk as well.
+      return gc();
+    }).then(function() {
+      // reset the quota manager storage to ensure the DB connection is flushed
+      return resetStorage();
+    }).then(function() {
+      return storageUsage();
+    }).then(function(usage) {
+      fullUsage = usage;
+      ok(fullUsage > initialUsage, 'disk usage should have grown');
+      return caches.delete(name);
+    }).then(function(result) {
+      ok(result, 'cache should be deleted');
+      // This is a bit superfluous, but its necessary to make sure the Cache is
+      // fully deleted before we proceed.  The deletion actually takes place in
+      // two async steps.  We don't want to resetStorage() until the second step
+      // has taken place.  This extra Cache operation ensure that all the
+      // runnables have been flushed through the threads, etc.
+      return caches.has(name);
+    }).then(function(result) {
+      ok(!result, 'cache should not exist in storage');
+      // reset the quota manager storage to ensure the DB connection is flushed
+      return resetStorage();
+    }).then(function() {
+      return storageUsage();
+    }).then(function(usage) {
+      endUsage = usage;
+      dump("### ### initial:" + initialUsage + ", full:" + fullUsage +
+           ", end:" + endUsage + "\n");
+      ok(endUsage < (fullUsage / 2), 'disk usage should have shrank significantly');
+      ok(endUsage > initialUsage, 'disk usage should not shrink back to orig size');
+      SimpleTest.finish();
+    });
   });
-});
+}
 </script>
 </body>
 </html>
