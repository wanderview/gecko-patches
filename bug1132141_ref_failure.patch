
# HG changeset patch
# User Nikhil Marathe <nsm.nikhil@gmail.com>
# Date 1423680692 28800
# Node ID fb6aeb7a5c3e0ca1e7f38196a6f541b363830b6d
# Parent  af3e6e9cf883ffb50ba6b10c2ee53a6c3e171278
Bug 1132141 - Update storage when ServiceWorker registration fails. r=baku

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -410,17 +410,17 @@ public:
 class CheckWorkerEvaluationAndContinueUpdateWorkerRunnable MOZ_FINAL : public WorkerRunnable
 {
   const nsMainThreadPtrHandle<nsISupports> mJob;
 public:
   CheckWorkerEvaluationAndContinueUpdateWorkerRunnable(WorkerPrivate* aWorkerPrivate,
                                                        const nsMainThreadPtrHandle<nsISupports> aJob)
     : WorkerRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
     , mJob(aJob)
-  { 
+  {
     AssertIsOnMainThread();
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
     if (aWorkerPrivate->WorkerScriptExecutedSuccessfully()) {
@@ -2400,9 +2400,41 @@ ServiceWorkerManager::MaybeRemoveRegistr
 {
   MOZ_ASSERT(aRegistration);
   nsRefPtr<ServiceWorkerInfo> newest = aRegistration->Newest();
   if (!newest) {
     RemoveRegistration(aRegistration);
   }
 }
 
+void
+ServiceWorkerManager::RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
+{
+  MOZ_ASSERT(aRegistration);
+  MOZ_ASSERT(!aRegistration->IsControllingDocuments());
+  MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
+  ServiceWorkerManager::RemoveScope(mOrderedScopes, aRegistration->mScope);
+
+  // Hold a ref since the hashtable may be the last ref.
+  nsRefPtr<ServiceWorkerRegistrationInfo> reg;
+  mServiceWorkerRegistrationInfos.Remove(aRegistration->mScope,
+                                         getter_AddRefs(reg));
+  MOZ_ASSERT(reg);
+
+  // All callers should be either from a job in which case the actor is
+  // available, or from MaybeStopControlling(), in which case, this will only be
+  // called if a valid registration is found. If a valid registration exists,
+  // it means the actor is available since the original map of registrations is
+  // populated by it, and any new registrations wait until the actor is
+  // available before proceeding (See ServiceWorkerRegisterJob::Start).
+  MOZ_ASSERT(mActor);
+
+  PrincipalInfo principalInfo;
+  if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(reg->mPrincipal,
+                                                    &principalInfo)))) {
+    //XXXnsm I can't think of any other reason a stored principal would fail to
+    //convert.
+    NS_WARNING("Unable to unregister serviceworker due to possible OOM");
+    return;
+  }
+  mActor->SendUnregisterServiceWorker(principalInfo, NS_ConvertUTF8toUTF16(reg->mScope));
+}
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -347,24 +347,17 @@ public:
     mServiceWorkerRegistrationInfos.Get(aScope, getter_AddRefs(reg));
     return reg.forget();
   }
 
   ServiceWorkerRegistrationInfo*
   CreateNewRegistration(const nsCString& aScope, nsIPrincipal* aPrincipal);
 
   void
-  RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration)
-  {
-    MOZ_ASSERT(aRegistration);
-    MOZ_ASSERT(!aRegistration->IsControllingDocuments());
-    MOZ_ASSERT(mServiceWorkerRegistrationInfos.Contains(aRegistration->mScope));
-    ServiceWorkerManager::RemoveScope(mOrderedScopes, aRegistration->mScope);
-    mServiceWorkerRegistrationInfos.Remove(aRegistration->mScope);
-  }
+  RemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   ServiceWorkerJobQueue*
   GetOrCreateJobQueue(const nsCString& aScope)
   {
     return mJobQueues.LookupOrAdd(aScope);
   }
 
   void StoreRegistration(nsIPrincipal* aPrincipal,

