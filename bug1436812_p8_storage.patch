# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a1572331357936863a50f5c00deb1f7a5a4da395
Bug 1436812 P8 Move storage permission check and other window specific code to ServiceWorkerContainer. r=baku

diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -319,16 +319,45 @@ ServiceWorkerContainer::Register(const n
     return nullptr;
 
   }
   if (NS_WARN_IF(decision != nsIContentPolicy::ACCEPT)) {
     aRv.Throw(NS_ERROR_CONTENT_BLOCKED);
     return nullptr;
   }
 
+  // Get the string representation for both the script and scope since
+  // we sanitized them above.
+  nsCString cleanedScopeURL;
+  aRv = scopeURI->GetSpec(cleanedScopeURL);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  nsCString cleanedScriptURL;
+  aRv = scriptURI->GetSpec(cleanedScriptURL);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  // Verify that the global is valid and has permission to store
+  // data.  We perform this late so that we can report the final
+  // scope URL in any error message.
+  Unused << GetGlobalIfValid(aRv, [&](nsIDocument* aDoc) {
+    NS_ConvertUTF8toUTF16 reportScope(cleanedScopeURL);
+    const char16_t* param[] = { reportScope.get() };
+    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
+                                    NS_LITERAL_CSTRING("Service Workers"),
+                                    aDoc, nsContentUtils::eDOM_PROPERTIES,
+                                    "ServiceWorkerRegisterStorageError",
+                                    param, 1);
+  });
+
+  window->NoteCalledRegisterForServiceWorkerScope(cleanedScopeURL);
+
   // The spec says that the "client" passed to Register() must be the global
   // where the ServiceWorkerContainer was retrieved from.
   aRv = swm->Register(GetOwner(), scopeURI, scriptURI,
                       static_cast<uint16_t>(aOptions.mUpdateViaCache),
                       getter_AddRefs(promise));
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -764,35 +764,16 @@ ServiceWorkerManager::Register(mozIDOMWi
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   MOZ_ASSERT(doc);
 
-  // Don't allow a service worker to be registered if storage is restricted
-  // for the window.
-  auto storageAllowed = nsContentUtils::StorageAllowedForWindow(window);
-  if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
-    NS_ConvertUTF8toUTF16 reportScope(aScopeURI->GetSpecOrDefault());
-    const char16_t* param[] = { reportScope.get() };
-    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
-                                    NS_LITERAL_CSTRING("Service Workers"), doc,
-                                    nsContentUtils::eDOM_PROPERTIES,
-                                    "ServiceWorkerRegisterStorageError", param,
-                                    1);
-    return NS_ERROR_DOM_SECURITY_ERR;
-  }
-
-  // Don't allow service workers to register when the *document* is chrome.
-  if (NS_WARN_IF(nsContentUtils::IsSystemPrincipal(doc->NodePrincipal()))) {
-    return NS_ERROR_DOM_SECURITY_ERR;
-  }
-
   // Data URLs are not allowed.
   nsCOMPtr<nsIPrincipal> documentPrincipal = doc->NodePrincipal();
 
   nsCString cleanedScope;
   nsresult rv = aScopeURI->GetSpecIgnoringRef(cleanedScope);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return NS_ERROR_FAILURE;
   }
@@ -810,18 +791,16 @@ ServiceWorkerManager::Register(mozIDOMWi
   }
 
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(documentPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  window->NoteCalledRegisterForServiceWorkerScope(cleanedScope);
-
   RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey,
                                                             cleanedScope);
 
   RefPtr<ServiceWorkerResolveWindowPromiseOnRegisterCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnRegisterCallback(window, promise);
 
   nsCOMPtr<nsILoadGroup> loadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID);
   RefPtr<ServiceWorkerRegisterJob> job = new ServiceWorkerRegisterJob(
