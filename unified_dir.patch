# HG changeset patch
# Parent b2f85423b7be37d8c2cbc3dcc1e5b30c7edc292c
# User Ben Kelly <ben@wanderview.com>
Store Cache body files in a central directory.

diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -49,17 +49,17 @@ FileUtils::BodyCreateDir(nsIFile* aBaseD
     if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
   }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, CacheId aCacheId,
+FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
                            nsIFile** aCacheDirOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aCacheDirOut);
 
   nsresult rv = aBaseDir->Clone(aCacheDirOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -71,19 +71,19 @@ FileUtils::BodyGetCacheDir(nsIFile* aBas
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
 
   bool isDir;
   rv = (*aCacheDirOut)->IsDirectory(&isDir);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
 
-  nsAutoString cacheDirName;
-  cacheDirName.AppendInt(aCacheId);
-  rv = (*aCacheDirOut)->Append(cacheDirName);
+  nsAutoString subDirName;
+  subDirName.AppendInt(aId.m3[7]);
+  rv = (*aCacheDirOut)->Append(subDirName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = (*aCacheDirOut)->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (!exists) {
     rv = (*aCacheDirOut)->Create(nsIFile::DIRECTORY_TYPE, 0755);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -93,65 +93,23 @@ FileUtils::BodyGetCacheDir(nsIFile* aBas
     if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
   }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyDeleteCacheDir(nsIFile* aBaseDir, CacheId aCacheId)
-{
-  MOZ_ASSERT(aBaseDir);
-
-  nsCOMPtr<nsIFile> cacheDir;
-  nsresult rv = aBaseDir->Clone(getter_AddRefs(cacheDir));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = cacheDir->Append(NS_LITERAL_STRING("morgue"));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool exists;
-  rv = cacheDir->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
-
-  nsAutoString cacheDirName;
-  cacheDirName.AppendInt(aCacheId);
-  rv = cacheDir->Append(cacheDirName);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = cacheDir->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Already in desired state where cache dir does not exist.
-  if (!exists) {
-    return rv;
-  }
-
-  bool isDir;
-  rv = cacheDir->IsDirectory(&isDir);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
-
-  rv = cacheDir->Remove(true /* recursive */);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  return rv;
-}
-
-// static
-nsresult
-FileUtils::BodyIdToFile(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+FileUtils::BodyIdToFile(nsIFile* aBaseDir, const nsID& aId,
                         BodyFileType aType, nsIFile** aBodyFileOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aBodyFileOut);
 
-  nsresult rv = BodyGetCacheDir(aBaseDir, aCacheId, aBodyFileOut);
+  nsresult rv = BodyGetCacheDir(aBaseDir, aId, aBodyFileOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = (*aBodyFileOut)->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
 
   bool isDir;
@@ -175,20 +133,20 @@ FileUtils::BodyIdToFile(nsIFile* aBaseDi
 
   return rv;
 }
 
 // static
 nsresult
 FileUtils::BodyStartWriteStream(const nsACString& aOrigin,
                                 const nsACString& aBaseDomain,
-                                nsIFile* aBaseDir, CacheId aCacheId,
-                                nsIInputStream* aSource, void* aClosure,
-                                nsAsyncCopyCallbackFun aCallback,
-                                nsID* aIdOut, nsISupports** aCopyContextOut)
+                                nsIFile* aBaseDir, nsIInputStream* aSource,
+                                void* aClosure,
+                                nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                                nsISupports** aCopyContextOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aSource);
   MOZ_ASSERT(aClosure);
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(aIdOut);
   MOZ_ASSERT(aCopyContextOut);
 
@@ -196,28 +154,27 @@ FileUtils::BodyStartWriteStream(const ns
   nsCOMPtr<nsIUUIDGenerator> idGen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = idGen->GenerateUUIDInPlace(aIdOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFile> finalFile;
-  rv = BodyIdToFile(aBaseDir, aCacheId, *aIdOut, BODY_FILE_FINAL,
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_FINAL,
                     getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIFile> tmpFile;
-  rv = BodyIdToFile(aBaseDir, aCacheId, *aIdOut, BODY_FILE_TMP,
-                    getter_AddRefs(tmpFile));
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = tmpFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIOutputStream> fileStream =
     FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
@@ -235,53 +192,50 @@ FileUtils::BodyStartWriteStream(const ns
     return rv;
   }
 
   return rv;
 }
 
 // static
 void
-FileUtils::BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+FileUtils::BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
                            nsISupports* aCopyContext)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aCopyContext);
 
   nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
   unused << NS_WARN_IF(NS_FAILED(rv));
 
   nsCOMPtr<nsIFile> tmpFile;
-  rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_TMP,
-                    getter_AddRefs(tmpFile));
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
   rv = tmpFile->Remove(false /* recursive */);
   unused << NS_WARN_IF(NS_FAILED(rv));
 }
 
 // static
 nsresult
-FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId)
+FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
 {
   MOZ_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> tmpFile;
-  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_TMP,
-                             getter_AddRefs(tmpFile));
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = tmpFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
 
   nsCOMPtr<nsIFile> finalFile;
-  rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
-                    getter_AddRefs(finalFile));
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL, getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIFile> finalDir;
   rv = finalFile->GetParent(getter_AddRefs(finalDir));
@@ -295,25 +249,25 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
 FileUtils::BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
-                    nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                    nsIFile* aBaseDir, const nsID& aId,
                     nsIInputStream** aStreamOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aStreamOut);
 
   nsCOMPtr<nsIFile> finalFile;
-  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
-                    getter_AddRefs(finalFile));
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
+                             getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
 
   nsCOMPtr<nsIInputStream> fileStream =
@@ -325,31 +279,31 @@ FileUtils::BodyOpen(const nsACString& aO
 
   return rv;
 }
 
 // static
 nsresult
 FileUtils::BodyStartReadStream(const nsACString& aOrigin,
                                const nsACString& aBaseDomain,
-                               nsIFile* aBaseDir, CacheId aCacheId,
+                               nsIFile* aBaseDir,
                                const nsID& aId, nsIOutputStream* aDest,
                                void* aClosure,
                                nsAsyncCopyCallbackFun aCallback,
                                nsISupports** aCopyContextOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aDest);
   MOZ_ASSERT(aClosure);
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(aCopyContextOut);
 
   nsCOMPtr<nsIFile> finalFile;
-  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
-                    getter_AddRefs(finalFile));
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
+                             getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
 
   nsCOMPtr<nsIInputStream> fileStream =
@@ -377,24 +331,23 @@ FileUtils::BodyCancelRead(nsISupports* a
 {
   MOZ_ASSERT(aCopyContext);
   nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
   unused << NS_WARN_IF(NS_FAILED(rv));
 }
 
 // static
 nsresult
-FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, CacheId aCacheId,
-                           const nsTArray<nsID>& aIdList)
+FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList)
 {
   nsresult rv = NS_OK;
 
   for (uint32_t i = 0; i < aIdList.Length(); ++i) {
     nsCOMPtr<nsIFile> finalFile;
-    rv = BodyIdToFile(aBaseDir, aCacheId, aIdList[i], BODY_FILE_FINAL,
+    rv = BodyIdToFile(aBaseDir, aIdList[i], BODY_FILE_FINAL,
                       getter_AddRefs(finalFile));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     bool exists;
     rv = finalFile->Exists(&exists);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (NS_WARN_IF(!exists)) {
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -24,55 +24,52 @@ class FileUtils MOZ_FINAL
 public:
   enum BodyFileType
   {
     BODY_FILE_FINAL,
     BODY_FILE_TMP
   };
 
   static nsresult BodyCreateDir(nsIFile* aBaseDir);
-  static nsresult BodyGetCacheDir(nsIFile* aBaseDir, CacheId aCacheId,
+  static nsresult BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
                                   nsIFile** aCacheDirOut);
-  static nsresult BodyDeleteCacheDir(nsIFile* aBaseDir, CacheId aCacheId);
 
   static nsresult
-  BodyIdToFile(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
-               BodyFileType aType, nsIFile** aBodyFileOut);
+  BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+               nsIFile** aBodyFileOut);
 
   static nsresult
   BodyStartWriteStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
-                       nsIFile* aBaseDir, CacheId aCacheId,
+                       nsIFile* aBaseDir,
                        nsIInputStream* aSource, void* aClosure,
                        nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
                        nsISupports** aCopyContextOut);
 
   static void
-  BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+  BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
                   nsISupports* aCopyContext);
 
   static nsresult
-  BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId);
+  BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
 
   static nsresult
   BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
-           nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
-           nsIInputStream** aStreamOut);
+           nsIFile* aBaseDir, const nsID& aId, nsIInputStream** aStreamOut);
 
   static nsresult
   BodyStartReadStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
-                      nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                      nsIFile* aBaseDir, const nsID& aId,
                       nsIOutputStream* aDest, void* aClosure,
                       nsAsyncCopyCallbackFun aCallback,
                       nsISupports** aCopyContextOut);
 
   static void BodyCancelRead(nsISupports* aCopyContext);
 
   static nsresult
-  BodyDeleteFiles(nsIFile* aBaseDir, CacheId aCacheId,
-                  const nsTArray<nsID>& aIdList);
+  BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
 
 private:
   FileUtils() MOZ_DELETE;
   ~FileUtils() MOZ_DELETE;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -165,52 +165,48 @@ protected:
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
 };
 
 class Manager::DeleteOrphanedBodyAction MOZ_FINAL : public Action
 {
 public:
-  DeleteOrphanedBodyAction(CacheId aCacheId,
-                           const nsTArray<nsID>& aDeletedBodyIdList)
-    : mCacheId(aCacheId)
-    , mDeletedBodyIdList(aDeletedBodyIdList)
+  DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
+    : mDeletedBodyIdList(aDeletedBodyIdList)
   { }
 
-  DeleteOrphanedBodyAction(CacheId aCacheId, const nsID& aBodyId)
-    : mCacheId(aCacheId)
+  DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
     mDeletedBodyIdList.AppendElement(aBodyId);
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
     MOZ_ASSERT(aQuotaDir);
 
     nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
-    rv = FileUtils::BodyDeleteFiles(aQuotaDir, mCacheId, mDeletedBodyIdList);
+    rv = FileUtils::BodyDeleteFiles(aQuotaDir, mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
     aResolver->Resolve(rv);
   }
 
 private:
   virtual ~DeleteOrphanedBodyAction() { }
-  const CacheId mCacheId;
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
     : SyncDBAction(DBAction::Existing, aManager->Origin(),
@@ -224,29 +220,26 @@ public:
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = DBSchema::DeleteCache(aConn, mCacheId, mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = FileUtils::BodyDeleteCacheDir(aDBDir, mCacheId);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
-    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
     mManager = nullptr;
   }
 
 private:
   virtual ~DeleteOrphanedCacheAction() { }
   nsRefPtr<Manager> mManager;
   const CacheId mCacheId;
   nsTArray<nsID> mDeletedBodyIdList;
@@ -277,17 +270,17 @@ public:
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
     rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
-                             aDBDir, mCacheId, mResponse.mBodyId,
+                             aDBDir, mResponse.mBodyId,
                              getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mResponse.mBodyId, stream);
 
     return rv;
   }
@@ -344,17 +337,17 @@ public:
 
     for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
       if (!mSavedResponses[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
       rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
-                               aDBDir, mCacheId, mSavedResponses[i].mBodyId,
+                               aDBDir, mSavedResponses[i].mBodyId,
                                getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedResponses[i].mBodyId, stream);
     }
 
     return rv;
@@ -468,25 +461,25 @@ public:
     }
 
     mRequestBodyCopyContext = nullptr;
     mResponseBodyCopyContext = nullptr;
 
     nsresult rv = NS_OK;
 
     if (mRequestBodyStream) {
-      rv = FileUtils::BodyFinalizeWrite(mDBDir, mCacheId, mRequestBodyId);
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mRequestBodyId);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         DoResolve(rv);
         return;
       }
     }
 
     if (mResponseBodyStream) {
-      rv = FileUtils::BodyFinalizeWrite(mDBDir, mCacheId, mResponseBodyId);
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mResponseBodyId);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         DoResolve(rv);
         return;
       }
     }
 
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
@@ -510,17 +503,17 @@ public:
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
 
-    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (!listener) {
       return;
     }
     if (NS_FAILED(aRv)) {
       listener->OnCachePut(mRequestId, aRv);
@@ -560,17 +553,16 @@ private:
 
     if (!aSource) {
       return NS_OK;
     }
 
     nsresult rv = FileUtils::BodyStartWriteStream(mManager->Origin(),
                                                   mManager->BaseDomain(),
                                                   mDBDir,
-                                                  mCacheId,
                                                   aSource,
                                                   this,
                                                   AsyncCopyCompleteFunc,
                                                   aIdOut,
                                                   aCopyContextOut);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
@@ -578,17 +570,17 @@ private:
 
   void
   CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
                    const nsID& aId)
   {
     if (!aSource || !aCopyContext) {
       return;
     }
-    FileUtils::BodyCancelWrite(mDBDir, mCacheId, aId, aCopyContext);
+    FileUtils::BodyCancelWrite(mDBDir, aId, aCopyContext);
   }
 
   static void
   AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
   {
     MOZ_ASSERT(aClosure);
     CachePutAction* action = static_cast<CachePutAction*>(aClosure);
     action->OnAsyncCopyComplete(aRv);
@@ -669,17 +661,17 @@ public:
     }
 
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
+    mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
     aListener->OnCacheDelete(mRequestId, aRv, mSuccess);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
@@ -717,17 +709,17 @@ public:
 
     for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
       if (!mSavedRequests[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
       rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
-                               aDBDir, mCacheId, mSavedRequests[i].mBodyId,
+                               aDBDir, mSavedRequests[i].mBodyId,
                                getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedRequests[i].mBodyId, stream);
     }
 
     return rv;
@@ -780,18 +772,18 @@ public:
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mSavedResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
     rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
-                             aDBDir, mSavedResponse.mCacheId,
-                             mSavedResponse.mBodyId, getter_AddRefs(stream));
+                             aDBDir, mSavedResponse.mBodyId,
+                             getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mSavedResponse.mBodyId, stream);
 
     return rv;
   }
 
@@ -1082,17 +1074,17 @@ Manager::StreamList::Extract(const nsID&
 
 void
 Manager::StreamList::NoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
   for (uint32_t i = 0; i < mList.Length(); ++i) {
     if (mList[i].mId == aId) {
       mList.RemoveElementAt(i);
-      mManager->ReleaseBodyId(mCacheId, aId);
+      mManager->ReleaseBodyId(aId);
       break;
     }
   }
 
   if (mList.IsEmpty() && mStreamControl) {
     mStreamControl->Shutdown();
   }
 }
@@ -1117,17 +1109,17 @@ Manager::StreamList::CloseAll()
 
 Manager::StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
   MOZ_ASSERT(!mStreamControl);
   if (mActivated) {
     mManager->RemoveStreamList(this);
     for (uint32_t i = 0; i < mList.Length(); ++i) {
-      mManager->ReleaseBodyId(mCacheId, mList[i].mId);
+      mManager->ReleaseBodyId(mList[i].mId);
     }
     mManager->ReleaseCacheId(mCacheId);
   }
 }
 
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
@@ -1524,31 +1516,30 @@ Manager::AddRefBodyId(const nsID& aBodyI
   }
   BodyIdRefCounter* entry = mBodyIdRefs.AppendElement();
   entry->mBodyId = aBodyId;
   entry->mCount = 1;
   entry->mOrphaned = false;
 }
 
 void
-Manager::ReleaseBodyId(CacheId aCacheId, const nsID& aBodyId)
+Manager::ReleaseBodyId(const nsID& aBodyId)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
       DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
       mBodyIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
       if (mBodyIdRefs[i].mCount < 1) {
         bool orphaned = mBodyIdRefs[i].mOrphaned;
         mBodyIdRefs.RemoveElementAt(i);
         // TODO: note that we need to check this body for staleness on startup
         if (orphaned && !mShuttingDown) {
-          nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aCacheId,
-                                                                 aBodyId);
+          nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
           CurrentContext()->Dispatch(mIOThread, action);
         }
       }
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release BodyId that is not referenced!");
 }
@@ -1567,29 +1558,27 @@ Manager::SetBodyIdOrphanedIfRefed(const 
       mBodyIdRefs[i].mOrphaned = true;
       return true;
     }
   }
   return false;
 }
 
 void
-Manager::NoteOrphanedBodyIdList(CacheId aCacheId,
-                                const nsTArray<nsID>& aDeletedBodyIdList)
+Manager::NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   nsTArray<nsID> deleteNowList;
   for (uint32_t i = 0; i < aDeletedBodyIdList.Length(); ++i) {
     if (!SetBodyIdOrphanedIfRefed(aDeletedBodyIdList[i])) {
       deleteNowList.AppendElement(aDeletedBodyIdList[i]);
     }
   }
 
   if (!deleteNowList.IsEmpty()) {
-    nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aCacheId,
-                                                           deleteNowList);
+    nsRefPtr<Action> action = new DeleteOrphanedBodyAction(deleteNowList);
     CurrentContext()->Dispatch(mIOThread, action);
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -186,20 +186,19 @@ private:
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   void AddStreamList(StreamList* aStreamList);
   void RemoveStreamList(StreamList* aStreamList);
 
   void AddRefBodyId(const nsID& aBodyId);
-  void ReleaseBodyId(CacheId aCacheId, const nsID& aBodyId);
+  void ReleaseBodyId(const nsID& aBodyId);
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
-  void NoteOrphanedBodyIdList(CacheId aCacheId,
-                              const nsTArray<nsID>& aDeletedBodyIdList);
+  void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
 
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
   nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
