# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c959327c6b75cd4930a6ea087583c38b805e7524
Bug 1397304 Avoid searching the image cache queue for an entry after we just popped it off the queue. r=tnikkel

diff --git a/image/imgLoader.cpp b/image/imgLoader.cpp
--- a/image/imgLoader.cpp
+++ b/image/imgLoader.cpp
@@ -1063,16 +1063,22 @@ imgCacheQueue::IsDirty()
 }
 
 uint32_t
 imgCacheQueue::GetNumElements() const
 {
   return mQueue.Length();
 }
 
+bool
+imgCacheQueue::Contains(imgCacheEntry* aEntry) const
+{
+  return mQueue.Contains(aEntry);
+}
+
 imgCacheQueue::iterator
 imgCacheQueue::begin()
 {
   return mQueue.begin();
 }
 
 imgCacheQueue::const_iterator
 imgCacheQueue::begin() const
@@ -1675,17 +1681,19 @@ imgLoader::CheckCacheLimits(imgCacheTabl
       if (req) {
         LOG_STATIC_FUNC_WITH_PARAM(gImgLog,
                                    "imgLoader::CheckCacheLimits",
                                    "entry", req->CacheKey().Spec());
       }
     }
 
     if (entry) {
-      RemoveFromCache(entry);
+      // We just popped this entry from the queue, so pass AlreadyRemoved
+      // to avoid searching the queue again in RemoveFromCache.
+      RemoveFromCache(entry, QueueState::AlreadyRemoved);
     }
   }
 }
 
 bool
 imgLoader::ValidateRequestWithNewChannel(imgRequest* request,
                                          nsIURI* aURI,
                                          nsIURI* aInitialDocumentURI,
@@ -1974,17 +1982,17 @@ imgLoader::RemoveFromCache(const ImageCa
     AddToUncachedImages(request);
 
     return true;
   }
   return false;
 }
 
 bool
-imgLoader::RemoveFromCache(imgCacheEntry* entry)
+imgLoader::RemoveFromCache(imgCacheEntry* entry, QueueState aQueueState)
 {
   LOG_STATIC_FUNC(gImgLog, "imgLoader::RemoveFromCache entry");
 
   RefPtr<imgRequest> request = entry->GetRequest();
   if (request) {
     const ImageCacheKey& key = request->CacheKey();
     imgCacheTable& cache = GetCache(key);
     imgCacheQueue& queue = GetCacheQueue(key);
@@ -1996,17 +2004,24 @@ imgLoader::RemoveFromCache(imgCacheEntry
     cache.Remove(key);
 
     if (entry->HasNoProxies()) {
       LOG_STATIC_FUNC(gImgLog,
                       "imgLoader::RemoveFromCache removing from tracker");
       if (mCacheTracker) {
         mCacheTracker->RemoveObject(entry);
       }
-      queue.Remove(entry);
+      // Only search the queue to remove the entry if its possible it might
+      // be in the queue.  If we know its not in the queue this would be
+      // wasted work.
+      MOZ_ASSERT_IF(aQueueState == QueueState::AlreadyRemoved,
+                    !queue.Contains(entry));
+      if (aQueueState == QueueState::MaybeExists) {
+        queue.Remove(entry);
+      }
     }
 
     entry->SetEvicted(true);
     request->SetIsInCache(false);
     AddToUncachedImages(request);
 
     return true;
   }
diff --git a/image/imgLoader.h b/image/imgLoader.h
--- a/image/imgLoader.h
+++ b/image/imgLoader.h
@@ -196,16 +196,17 @@ public:
   void Push(imgCacheEntry*);
   void MarkDirty();
   bool IsDirty();
   already_AddRefed<imgCacheEntry> Pop();
   void Refresh();
   uint32_t GetSize() const;
   void UpdateSize(int32_t diff);
   uint32_t GetNumElements() const;
+  bool Contains(imgCacheEntry* aEntry) const;
   typedef nsTArray<RefPtr<imgCacheEntry> > queueContainer;
   typedef queueContainer::iterator iterator;
   typedef queueContainer::const_iterator const_iterator;
 
   iterator begin();
   const_iterator begin() const;
   iterator end();
   const_iterator end() const;
@@ -335,17 +336,26 @@ public:
 
   nsresult ClearChromeImageCache();
   nsresult ClearImageCache();
   void MinimizeCaches();
 
   nsresult InitCache();
 
   bool RemoveFromCache(const ImageCacheKey& aKey);
-  bool RemoveFromCache(imgCacheEntry* entry);
+
+  // Enumeration describing if a given entry is in the cache queue or not.
+  // There are some cases we know the entry is definitely not in the queue.
+  enum class QueueState {
+    MaybeExists,
+    AlreadyRemoved
+  };
+
+  bool RemoveFromCache(imgCacheEntry* entry,
+                       QueueState aQueueState = QueueState::MaybeExists);
 
   bool PutIntoCache(const ImageCacheKey& aKey, imgCacheEntry* aEntry);
 
   void AddToUncachedImages(imgRequest* aRequest);
   void RemoveFromUncachedImages(imgRequest* aRequest);
 
   // Returns true if we should prefer evicting cache entry |two| over cache
   // entry |one|.
