# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7761fa33623249762b06d3e83c18a13761c26289

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -28,16 +28,17 @@ TimeoutExecutor::ScheduleImmediate(const
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor IMMEDIATE\n", this);
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
@@ -86,16 +87,17 @@ TimeoutExecutor::ScheduleDelayed(const T
     delay = aDeadline - aNow + TimeDuration::FromMilliseconds(0.9);
   }
 
   // Finally, this truncates the float delay to integral milliseconds.
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor DELAYED (%0.3f)\n", this, delay.ToMilliseconds());
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline,
@@ -171,16 +173,17 @@ TimeoutExecutor::Shutdown()
 {
   mOwner = nullptr;
 
   if (mTimer) {
     mTimer->Cancel();
     mTimer = nullptr;
   }
 
+  printf_stderr("### ### [%p] TimeoutExecutor SHUTDOWN\n", this);
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
 TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline,
                                TimeoutPrecision aPrecision)
 {
@@ -198,16 +201,17 @@ TimeoutExecutor::MaybeSchedule(const Tim
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
+  printf_stderr("### ### [%p] TimeoutExecutor NONE\n", this);
   mMode = Mode::None;
   mDeadline = TimeStamp();
 }
 
 NS_IMETHODIMP
 TimeoutExecutor::Run()
 {
   // If the executor is canceled and then rescheduled its possible to get
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -361,16 +361,19 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   RefPtr<Timeout> timeout = new Timeout();
   timeout->mIsInterval = aIsInterval;
   timeout->mInterval = interval;
   timeout->mScriptHandler = aHandler;
   timeout->mReason = aReason;
 
+  printf_stderr("### ### [%p] SetTimeout() timeout %p with interval %d\n",
+                this, timeout.get(), timeout->mInterval);
+
   switch (gTimeoutBucketingStrategy) {
   default:
   case TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY: {
     const char* filename = nullptr;
     uint32_t dummyLine = 0, dummyColumn = 0;
     aHandler->GetLocation(&filename, &dummyLine, &dummyColumn);
     timeout->mIsTracking = doc->IsScriptTracking(nsDependentCString(filename));
 
@@ -646,16 +649,18 @@ TimeoutManager::RunTimeout(const TimeSta
             nextDeadline = timeout->When();
             break;
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
+
+    printf_stderr("### ### [%p] RunTimeout %u timeouts\n", this, numTimersToRun);
   }
 
   now = TimeStamp::Now();
 
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.  Note, this *must* be done
   // before we start executing any content script handlers.  If one
   // of them spins the event loop the executor must already be scheduled
@@ -757,16 +762,18 @@ TimeoutManager::RunTimeout(const TimeSta
         // No context means this window was closed or never properly
         // initialized for this language.  This timer will never fire
         // so just remove it.
         timeout->remove();
         continue;
       }
 
       // This timeout is good to run
+      printf_stderr("### ### [%p] RunTimeout execute timeout %p with interval %d\n",
+                    this, timeout.get(), timeout->mInterval);
       bool timeout_was_cleared = mWindow.RunTimeoutHandler(timeout, scx);
       MOZ_LOG(gLog, LogLevel::Debug,
               ("Run%s(TimeoutManager=%p, timeout=%p, tracking=%d) returned %d\n", timeout->mIsInterval ? "Interval" : "Timeout",
                this, timeout.get(),
                int(timeout->mIsTracking),
                !!timeout_was_cleared));
 
       if (timeout_was_cleared) {
diff --git a/toolkit/components/extensions/test/mochitest/test_ext_contentscript_about_blank.html b/toolkit/components/extensions/test/mochitest/test_ext_contentscript_about_blank.html
--- a/toolkit/components/extensions/test/mochitest/test_ext_contentscript_about_blank.html
+++ b/toolkit/components/extensions/test/mochitest/test_ext_contentscript_about_blank.html
@@ -8,16 +8,17 @@
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
 </head>
 <body>
 
 <script type="text/javascript">
 "use strict";
 
 add_task(async function test_contentscript_about_blank() {
+  dump('### ### start test\n');
   const manifest = {
     content_scripts: [
       {
         match_about_blank: true,
         matches: ["http://mochi.test/*/file_with_about_blank.html", "http://example.com/*"],
         all_frames: true,
         css: ["all.css"],
         js: ["all.js"],
@@ -79,39 +80,42 @@ add_task(async function test_contentscri
   await Promise.all([
     extension.awaitMessage("all:top"),
     extension.awaitMessage("all:about:blank"),
     extension.awaitMessage("all:about:srcdoc"),
   ]);
   is(count, 3, "exactly 3 scripts ran");
   win.close();
 
+  dump('### ### waiting for windows to open\n');
   win = window.open("http://mochi.test:8888/" + PATH);
   await Promise.all([
     extension.awaitMessage("all:top"),
     extension.awaitMessage("all:about:blank"),
     extension.awaitMessage("all:about:srcdoc"),
     extension.awaitMessage("mochi_without:top"),
     extension.awaitMessage("mochi_with:top"),
     extension.awaitMessage("mochi_with:about:blank"),
     extension.awaitMessage("mochi_with:about:srcdoc"),
   ]);
+  dump('### ### all windows opened\n');
 
   let style = win.getComputedStyle(win.document.body);
   is(style.color, "rgb(255, 0, 0)", "top window text color is red");
   is(style.backgroundColor, "rgb(255, 255, 0)", "top window background is yellow");
   is(style.textAlign, "right", "top window text is right-aligned");
 
   let a_b = win.document.getElementById("a_b");
   style = a_b.contentWindow.getComputedStyle(a_b.contentDocument.body);
   is(style.color, "rgb(255, 0, 0)", "about:blank iframe text color is red");
   is(style.backgroundColor, "rgba(0, 0, 0, 0)", "about:blank iframe background is transparent");
   is(style.textAlign, "right", "about:blank text is right-aligned");
 
   is(count, 10, "exactly 7 more scripts ran");
   win.close();
 
   await extension.unload();
+  dump('### ### end test\n');
 });
 </script>
 
 </body>
 </html>
