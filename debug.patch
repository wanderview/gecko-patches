# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  51e28599430a807e2564b2311eec81b43fce67b1

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -58,17 +58,19 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = mTimer->PreciseInitWithCallback(this, aDeadline - aNow,
+  TimeDuration delay(aDeadline - aNow);
+  printf_stderr("### ### [%p] TimeoutExecutor::ScheduleDelayed() %0.3f\n", this, delay.ToMilliseconds());
+  rv = mTimer->PreciseInitWithCallback(this, delay,
                                        nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
diff --git a/xpcom/threads/nsTimerImpl.cpp b/xpcom/threads/nsTimerImpl.cpp
--- a/xpcom/threads/nsTimerImpl.cpp
+++ b/xpcom/threads/nsTimerImpl.cpp
@@ -215,16 +215,18 @@ nsTimerImpl::InitCommon(const TimeDurati
   gThread->RemoveTimer(this);
   mCallback.swap(newCallback);
   ++mGeneration;
 
   mType = (uint8_t)aType;
   mDelay = aDelay;
   mTimeout = TimeStamp::Now() + mDelay;
 
+  printf_stderr("### ### [%p] InitCommon() %0.3f\n", this, mDelay.ToMilliseconds());
+
   return gThread->AddTimer(this);
 }
 
 nsresult
 nsTimerImpl::InitWithFuncCallbackCommon(nsTimerCallbackFunc aFunc,
                                         void* aClosure,
                                         uint32_t aDelay,
                                         uint32_t aType,
@@ -294,16 +296,17 @@ nsTimerImpl::PreciseInitWithCallback(nsI
     return NS_ERROR_INVALID_ARG;
   }
 
   Callback cb; // Goes out of scope after the unlock, prevents deadlock
   cb.mType = Callback::Type::Interface;
   cb.mCallback.i = aCallback;
   NS_ADDREF(cb.mCallback.i);
 
+  printf_stderr("### ### [%p] PreciseInitWithCallback() %0.3f\n", this, aDelay.ToMilliseconds());
   MutexAutoLock lock(mMutex);
   return InitCommon(aDelay, aType, mozilla::Move(cb));
 }
 
 nsresult
 nsTimerImpl::Init(nsIObserver* aObserver, uint32_t aDelay, uint32_t aType)
 {
   if (NS_WARN_IF(!aObserver)) {
