# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  11e4ce82197884b601d16f6677a46f15bac33d4e

diff --git a/devtools/client/debugger/test/mochitest/browser_dbg_worker-window.js b/devtools/client/debugger/test/mochitest/browser_dbg_worker-window.js
--- a/devtools/client/debugger/test/mochitest/browser_dbg_worker-window.js
+++ b/devtools/client/debugger/test/mochitest/browser_dbg_worker-window.js
@@ -11,36 +11,47 @@ var TAB_URL = EXAMPLE_URL + "doc_WorkerA
 var WORKER_URL = "code_WorkerActor.attachThread-worker.js";
 
 add_task(function* () {
   yield pushPrefs(["devtools.scratchpad.enabled", true]);
 
   DebuggerServer.init();
   DebuggerServer.addBrowserActors();
 
+  dump('### ### new DebuggerClient\n');
   let client = new DebuggerClient(DebuggerServer.connectPipe());
+  dump('### ### wait for connect\n');
   yield connect(client);
 
+  dump('### ### wait for addTab\n');
   let tab = yield addTab(TAB_URL);
+  dump('### ### wait for listTabs\n');
   let { tabs } = yield listTabs(client);
+  dump('### ### wait for attachTab\n');
   let [, tabClient] = yield attachTab(client, findTab(tabs, TAB_URL));
 
+  dump('### ### wait for listWorkers\n');
   yield listWorkers(tabClient);
+  dump('### ### wait for createWorkerInTab\n');
   yield createWorkerInTab(tab, WORKER_URL);
 
+  dump('### ### wait for listWorkers\n');
   let { workers } = yield listWorkers(tabClient);
+  dump('### ### wait for attachWorker\n');
   let [, workerClient] = yield attachWorker(tabClient,
                                              findWorker(workers, WORKER_URL));
 
+  dump('### ### calling showToolBox()\n');
   let toolbox = yield gDevTools.showToolbox(TargetFactory.forWorker(workerClient),
                                             "jsdebugger",
                                             Toolbox.HostType.WINDOW);
 
   is(toolbox.hostType, "window", "correct host");
 
+  dump('### ### wait for set-host-title\n');
   yield new Promise(done => {
     toolbox.win.parent.addEventListener("message", function onmessage(event) {
       if (event.data.name == "set-host-title") {
         toolbox.win.parent.removeEventListener("message", onmessage);
         done();
       }
     });
   });
@@ -48,14 +59,15 @@ add_task(function* () {
      "worker URL in host title");
 
   let toolTabs = toolbox.doc.querySelectorAll(".devtools-tab");
   let activeTools = [...toolTabs].map(tab=>tab.getAttribute("data-id"));
 
   is(activeTools.join(","), "webconsole,jsdebugger,scratchpad,options",
     "Correct set of tools supported by worker");
 
+  dump('### ### terminateWorkerInTab\n');
   terminateWorkerInTab(tab, WORKER_URL);
   yield waitForWorkerClose(workerClient);
   yield close(client);
 
   yield toolbox.destroy();
 });
diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -27,16 +27,17 @@ TimeoutExecutor::ScheduleImmediate(const
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow + mFlexTime);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor IMMEDIATE\n", this);
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
@@ -70,16 +71,17 @@ TimeoutExecutor::ScheduleDelayed(const T
   // TODO: In the future we could pass a precision argument in and round
   //       up here for low-precision background timers.  We don't really care
   //       if those timers fire late.
   TimeDuration delay(aDeadline - (aNow + mFlexTime));
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor DELAYED (%0.3f)\n", this, delay.ToMilliseconds());
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
@@ -154,16 +156,17 @@ TimeoutExecutor::Shutdown()
 {
   mOwner = nullptr;
 
   if (mTimer) {
     mTimer->Cancel();
     mTimer = nullptr;
   }
 
+  printf_stderr("### ### [%p] TimeoutExecutor SHUTDOWN\n", this);
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
 TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
@@ -180,16 +183,17 @@ TimeoutExecutor::MaybeSchedule(const Tim
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
+  printf_stderr("### ### [%p] TimeoutExecutor NONE\n", this);
   mMode = Mode::None;
   mDeadline = TimeStamp();
 }
 
 NS_IMETHODIMP
 TimeoutExecutor::Run()
 {
   // If the executor is canceled and then rescheduled its possible to get
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -327,16 +327,18 @@ TimeoutManager::IsRunningTimeout() const
   return mRunningTimeout;
 }
 
 nsresult
 TimeoutManager::SetTimeout(nsITimeoutHandler* aHandler,
                            int32_t interval, bool aIsInterval,
                            Timeout::Reason aReason, int32_t* aReturn)
 {
+  printf_stderr("### ### [%p] SetTimeout() %d\n", this, interval);
+
   // If we don't have a document (we could have been unloaded since
   // the call to setTimeout was made), do nothing.
   nsCOMPtr<nsIDocument> doc = mWindow.GetExtantDoc();
   if (!doc) {
     return NS_OK;
   }
 
   // Disallow negative intervals.  If aIsInterval also disallow 0,
@@ -636,16 +638,18 @@ TimeoutManager::RunTimeout(const TimeSta
             nextDeadline = timeout->When();
             break;
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
+
+    printf_stderr("### ### [%p] RunTimeout() executing %u timeouts\n", this, numTimersToRun);
   }
 
   now = TimeStamp::Now();
 
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.  Note, this *must* be done
   // before we start executing any content script handlers.  If one
   // of them spins the event loop the executor must already be scheduled
