# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dea7388bb4dea8efa364c6ce587491e7a84b5bc7

diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -2093,16 +2093,18 @@ public:
 
 void
 ServiceWorkerManager::DispatchFetchEvent(nsIInterceptedChannel* aChannel,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
   MOZ_ASSERT(NS_IsMainThread());
 
+  printf_stderr("### ### [%p] ServiceWorkerManager::%s\n", this, __func__);
+
   nsCOMPtr<nsIChannel> internalChannel;
   aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   nsCOMPtr<nsILoadGroup> loadGroup;
   aRv = internalChannel->GetLoadGroup(getter_AddRefs(loadGroup));
@@ -2221,17 +2223,20 @@ ServiceWorkerManager::DispatchFetchEvent
 
           clientInfo = loadInfo->GetReservedClientInfo();
         }
       }
 
       // First, attempt to mark the reserved client controlled directly.  This
       // will update the controlled status in the ClientManagerService in the
       // parent.  It will also eventually propagate back to the ClientSource.
+      printf_stderr("### ### [%p] ServiceWorkerManager::%s start controlling client\n", this, __func__);
       StartControllingClient(clientInfo.ref(), registration);
+    } else {
+      printf_stderr("### ### [%p] ServiceWorkerManager::%s no client to control\n", this, __func__);
     }
 
     uint32_t redirectMode = nsIHttpChannelInternal::REDIRECT_MODE_MANUAL;
     nsCOMPtr<nsIHttpChannelInternal> http = do_QueryInterface(internalChannel);
     MOZ_ALWAYS_SUCCEEDS(http->GetRedirectMode(&redirectMode));
 
     // Synthetic redirects for non-subresource requests with a "follow"
     // redirect mode may switch controllers.  This is basically worker
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -478,16 +478,24 @@ LoadInfo::LoadInfo(nsIPrincipal* aLoadin
   , mIsPreflight(aIsPreflight)
   , mLoadTriggeredFromExternal(aLoadTriggeredFromExternal)
   , mServiceWorkerTaintingSynthesized(aServiceWorkerTaintingSynthesized)
 {
   // Only top level TYPE_DOCUMENT loads can have a null loadingPrincipal
   MOZ_ASSERT(mLoadingPrincipal || aContentPolicyType == nsIContentPolicy::TYPE_DOCUMENT);
   MOZ_ASSERT(mTriggeringPrincipal);
 
+  if (mReservedClientInfo.isSome()) {
+    printf_stderr("### ### [%p] LoadInfo::%s set reserved client info\n", this, __func__);
+  }
+
+  if (mInitialClientInfo.isSome()) {
+    printf_stderr("### ### [%p] LoadInfo::%s set initial client info\n", this, __func__);
+  }
+
   mRedirectChainIncludingInternalRedirects.SwapElements(
     aRedirectChainIncludingInternalRedirects);
 
   mRedirectChain.SwapElements(aRedirectChain);
 }
 
 void
 LoadInfo::ComputeIsThirdPartyContext(nsPIDOMWindowOuter* aOuterWindow)
@@ -1300,48 +1308,55 @@ LoadInfo::GiveReservedClientSource(Uniqu
   MOZ_DIAGNOSTIC_ASSERT(aClientSource);
   mReservedClientSource = Move(aClientSource);
   SetReservedClientInfo(mReservedClientSource->Info());
 }
 
 UniquePtr<ClientSource>
 LoadInfo::TakeReservedClientSource()
 {
+  printf_stderr("### ### [%p] LoadInfo::%s\n", this, __func__);
   if (mReservedClientSource) {
     // If the reserved ClientInfo was set due to a ClientSource being present,
     // then clear that info object when the ClientSource is taken.
     mReservedClientInfo.reset();
   }
   return Move(mReservedClientSource);
 }
 
 void
 LoadInfo::SetReservedClientInfo(const ClientInfo& aClientInfo)
 {
   MOZ_DIAGNOSTIC_ASSERT(mInitialClientInfo.isNothing());
+  printf_stderr("### ### [%p] LoadInfo::%s\n", this, __func__);
   mReservedClientInfo.emplace(aClientInfo);
 }
 
 const Maybe<ClientInfo>&
 LoadInfo::GetReservedClientInfo()
 {
+  printf_stderr("### ### [%p] LoadInfo::%s exists:%s\n",
+                this, __func__, (mReservedClientInfo.isSome() ? "true" : "false"));
   return mReservedClientInfo;
 }
 
 void
 LoadInfo::SetInitialClientInfo(const ClientInfo& aClientInfo)
 {
   MOZ_DIAGNOSTIC_ASSERT(!mReservedClientSource);
   MOZ_DIAGNOSTIC_ASSERT(mReservedClientInfo.isNothing());
+  printf_stderr("### ### [%p] LoadInfo::%s\n", this, __func__);
   mInitialClientInfo.emplace(aClientInfo);
 }
 
 const Maybe<ClientInfo>&
 LoadInfo::GetInitialClientInfo()
 {
+  printf_stderr("### ### [%p] LoadInfo::%s exists:%s\n",
+                this, __func__, (mInitialClientInfo.isSome() ? "true" : "false"));
   return mInitialClientInfo;
 }
 
 void
 LoadInfo::SetController(const ServiceWorkerDescriptor& aServiceWorker)
 {
   mController.emplace(aServiceWorker);
 }
