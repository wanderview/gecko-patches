# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ce25aa8e3aed64f58cc72fbbacd6bd8f622622c7

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -35,16 +35,18 @@
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/Unused.h"
 
 #include "Fetch.h"
 #include "FetchUtil.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
 
+#include "mozilla/ErrorNames.h"
+
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_ISUPPORTS(FetchDriver,
                   nsIStreamListener, nsIChannelEventSink, nsIInterfaceRequestor,
                   nsIThreadRetargetableStreamListener)
 
 FetchDriver::FetchDriver(InternalRequest* aRequest, nsIPrincipal* aPrincipal,
@@ -458,16 +460,21 @@ FetchDriver::OnStartRequest(nsIRequest* 
   workers::AssertIsOnMainThread();
 
   // Note, this can be called multiple times if we are doing an opaqueredirect.
   // In that case we will get a simulated OnStartRequest() and then the real
   // channel will call in with an errored OnStartRequest().
 
   nsresult rv;
   aRequest->GetStatus(&rv);
+
+  nsAutoCString name;
+  GetErrorName(rv, name);
+  printf_stderr("### ### FetchDriver::OnStartRequest() status:%s\n", name.get());
+
   if (NS_FAILED(rv)) {
     FailWithNetworkError();
     return rv;
   }
 
   // We should only get to the following code once.
   MOZ_ASSERT(!mPipeOutputStream);
   MOZ_ASSERT(mObserver);
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -224,16 +224,17 @@ public:
     }
 
     AutoTArray<InternalHeaders::Entry, 5> entries;
     mInternalResponse->UnfilteredHeaders()->GetEntries(entries);
     for (uint32_t i = 0; i < entries.Length(); ++i) {
        mChannel->SynthesizeHeader(entries[i].mName, entries[i].mValue);
     }
 
+    printf_stderr("### ### FinishResponse() calling SynthesizeServiceWorkerTainting()\n");
     loadInfo->SynthesizeServiceWorkerTainting(mInternalResponse->GetTainting());
 
     rv = mChannel->FinishSynthesizedResponse(mResponseURLSpec);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->Cancel(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -290,16 +290,17 @@ InterceptedChannelChrome::SynthesizeHead
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
 {
+  printf_stderr("### ### FinishSynthesizedResponse() final URL %s\n", nsCString(aFinalURLSpec).get());
   if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Make sure the cache entry's output stream is always closed.  If the
   // channel was intercepted with a null-body response then its possible
   // the synthesis completed without a stream copy operation.
   mResponseBody->Close();
@@ -343,45 +344,51 @@ InterceptedChannelChrome::FinishSynthesi
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     responseURI = originalURI;
   }
 
   bool equal = false;
   originalURI->Equals(responseURI, &equal);
   if (!equal) {
+    printf_stderr("### ### FinishSynthesizedResponse() URIs not equal, redirect\n");
     rv =
         mChannel->StartRedirectChannelToURI(responseURI, nsIChannelEventSink::REDIRECT_INTERNAL);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     bool usingSSL = false;
     responseURI->SchemeIs("https", &usingSSL);
 
     // Then we open a real cache entry to read the synthesized response from.
     rv = mChannel->OpenCacheEntry(usingSSL);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    printf_stderr("### ### FinishSynthesizedResponse() opened the cache entry\n");
+
     mSynthesizedCacheEntry = nullptr;
 
     if (!mChannel->AwaitingCacheCallbacks()) {
       rv = mChannel->ContinueConnect();
       NS_ENSURE_SUCCESS(rv, rv);
     }
+
+    printf_stderr("### ### FinishSynthesizedResponse() success\n");
   }
 
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::Cancel(nsresult aStatus)
 {
   MOZ_ASSERT(NS_FAILED(aStatus));
 
+  printf_stderr("### ### Cancel()\n");
   if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   // we need to use AsyncAbort instead of Cancel since there's no active pump
   // to cancel which will provide OnStart/OnStopRequest to the channel.
diff --git a/netwerk/protocol/http/nsCORSListenerProxy.cpp b/netwerk/protocol/http/nsCORSListenerProxy.cpp
--- a/netwerk/protocol/http/nsCORSListenerProxy.cpp
+++ b/netwerk/protocol/http/nsCORSListenerProxy.cpp
@@ -694,16 +694,17 @@ nsCORSListenerProxy::GetInterface(const 
 }
 
 NS_IMETHODIMP
 nsCORSListenerProxy::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
                                             nsIChannel *aNewChannel,
                                             uint32_t aFlags,
                                             nsIAsyncVerifyRedirectCallback *aCb)
 {
+  printf_stderr("### ### nsCORSListenerProxy::AsyncOnChannelRedirect()\n");
   nsresult rv;
   if (NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags) ||
       NS_IsHSTSUpgradeRedirect(aOldChannel, aNewChannel, aFlags)) {
     // Internal redirects still need to be updated in order to maintain
     // the correct headers.  We use DataURIHandling::Allow, since unallowed
     // data URIs should have been blocked before we got to the internal
     // redirect.
     rv = UpdateChannel(aNewChannel, DataURIHandling::Allow,
diff --git a/testing/web-platform/tests/service-workers/service-worker/fetch-response-taint.https.html b/testing/web-platform/tests/service-workers/service-worker/fetch-response-taint.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/fetch-response-taint.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/fetch-response-taint.https.html
@@ -111,16 +111,17 @@ function for_each_origin_mode_credential
       ['same-origin', 'no-cors', 'cors'].forEach(function(mode) {
           ['omit', 'same-origin', 'include'].forEach(function(credentials) {
               callback(origin, mode, credentials);
             });
         });
     });
 }
 
+/*
 ok_test(BASE_URL, 'same-origin', 'omit', 'basic', 'undefined');
 ok_test(BASE_URL, 'same-origin', 'same-origin', 'basic', 'username2s');
 ok_test(BASE_URL, 'same-origin', 'include', 'basic', 'username2s');
 ok_test(BASE_URL, 'no-cors', 'omit', 'basic', 'undefined');
 ok_test(BASE_URL, 'no-cors', 'same-origin', 'basic', 'username2s');
 ok_test(BASE_URL, 'no-cors', 'include', 'basic', 'username2s');
 ok_test(BASE_URL, 'cors', 'omit', 'basic', 'undefined');
 ok_test(BASE_URL, 'cors', 'same-origin', 'basic', 'username2s');
@@ -133,19 +134,21 @@ ok_test(OTHER_BASE_URL, 'no-cors', 'same
 ok_test(OTHER_BASE_URL, 'no-cors', 'include', 'opaque');
 ng_test(OTHER_BASE_URL, 'cors', 'omit');
 ng_test(OTHER_BASE_URL, 'cors', 'same-origin');
 ng_test(OTHER_BASE_URL, 'cors', 'include');
 ok_test(OTHER_BASE_URL + 'ACAOrigin=*', 'cors', 'omit', 'cors', 'undefined');
 ok_test(OTHER_BASE_URL + 'ACAOrigin=*', 'cors', 'same-origin', 'cors',
         'undefined');
 ng_test(OTHER_BASE_URL + 'ACAOrigin=*', 'cors', 'include');
+*/
 ok_test(OTHER_BASE_URL + 'ACAOrigin=' + BASE_ORIGIN + '&ACACredentials=true',
         'cors', 'include', 'cors', 'username1s')
 
+/*
 for_each_origin_mode_credentials(function(origin, mode, credentials) {
   var url = build_rewrite_url(
       origin, BASE_URL, 'same-origin', 'omit');
   // Fetch to the other origin with same-origin mode should fail.
   if (origin == OTHER_ORIGIN && mode == 'same-origin') {
     ng_test(url, mode, credentials);
   } else {
     // The response type from the SW should be basic
@@ -208,10 +211,11 @@ for_each_origin_mode_credentials(functio
   // Fetch to the other origin with same-origin mode should fail.
   if (origin == OTHER_ORIGIN && mode == 'same-origin') {
     ng_test(url, mode, credentials);
   } else {
     // The response from the SW should be cors.
     ok_test(url, mode, credentials, 'cors', 'username1s');
   }
 });
+*/
 </script>
 </body>
