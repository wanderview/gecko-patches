# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  67667617ff362409095fd6c7320e3a278d76855c

diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -335,24 +335,40 @@ Element::TabIndex()
   }
 
   return TabIndexDefault();
 }
 
 void
 Element::Focus(mozilla::ErrorResult& aError)
 {
+  printf_stderr("### ### [%p] Element::Focus()\n", this);
   nsCOMPtr<nsIDOMElement> domElement = do_QueryInterface(this);
   nsFocusManager* fm = nsFocusManager::GetFocusManager();
   // Also other browsers seem to have the hack to not re-focus (and flush) when
   // the element is already focused.
   if (fm && domElement) {
     if (fm->CanSkipFocus(this)) {
+      printf_stderr("### ### [%p] Element::Focus() calling NeedsFlushBeforeEventHandling()\n", this);
       fm->NeedsFlushBeforeEventHandling(this);
     } else {
+      bool firstPaint = false;
+      {
+        nsIDocument* doc = GetComposedDoc();
+        nsPIDOMWindowOuter* win = doc ? doc->GetWindow() : nullptr;
+        nsIDocShell* docShell = win ? win->GetDocShell() : nullptr;
+        nsIPresShell* presShell = docShell ? docShell->GetPresShell() : nullptr;
+        if (presShell) {
+          firstPaint = presShell->GetIsFirstPaint();
+        } else {
+          printf_stderr("### ### [%p] Element::Focus() no nsIPresShell!\n", this);
+        }
+      }
+      printf_stderr("### ### [%p] Element::Focus() calling SetFocus() - first-paint:%s\n",
+                    this, (firstPaint ? "true" : "false"));
       aError = fm->SetFocus(domElement, 0);
     }
   }
 }
 
 void
 Element::SetTabIndex(int32_t aTabIndex, mozilla::ErrorResult& aError)
 {
diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -27,16 +27,17 @@ TimeoutExecutor::ScheduleImmediate(const
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow + mFlexTime);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor IMMEDIATE\n", mOwner);
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
@@ -61,16 +62,17 @@ TimeoutExecutor::ScheduleDelayed(const T
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
   TimeDuration delay = aDeadline - aNow;
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor DELAYED (%0.3f)\n", mOwner, delay.ToMilliseconds());
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
@@ -145,16 +147,17 @@ TimeoutExecutor::Shutdown()
 {
   mOwner = nullptr;
 
   if (mTimer) {
     mTimer->Cancel();
     mTimer = nullptr;
   }
 
+  printf_stderr("### ### [%p] TimeoutExecutor SHUTDOWN\n", mOwner);
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
 TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
@@ -171,16 +174,17 @@ TimeoutExecutor::MaybeSchedule(const Tim
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
+  printf_stderr("### ### [%p] TimeoutExecutor NONE\n", mOwner);
   mMode = Mode::None;
   mDeadline = TimeStamp();
 }
 
 NS_IMETHODIMP
 TimeoutExecutor::Run()
 {
   MaybeExecute();
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -327,16 +327,19 @@ TimeoutManager::IsRunningTimeout() const
   return mRunningTimeout;
 }
 
 nsresult
 TimeoutManager::SetTimeout(nsITimeoutHandler* aHandler,
                            int32_t interval, bool aIsInterval,
                            Timeout::Reason aReason, int32_t* aReturn)
 {
+  printf_stderr("### ### [%p] TimeoutManager::SetTimeout() delay:%d safe:%s\n", this, interval,
+                (nsContentUtils::IsSafeToRunScript() ? "true" : "false"));
+
   // If we don't have a document (we could have been unloaded since
   // the call to setTimeout was made), do nothing.
   nsCOMPtr<nsIDocument> doc = mWindow.GetExtantDoc();
   if (!doc) {
     return NS_OK;
   }
 
   // Disallow negative intervals.  If aIsInterval also disallow 0,
@@ -472,16 +475,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
            timeout->mTimeoutId));
 
   return NS_OK;
 }
 
 void
 TimeoutManager::ClearTimeout(int32_t aTimerId, Timeout::Reason aReason)
 {
+  printf_stderr("### ### [%p] TimeoutManager::ClearTimeout() %d\n", this, aTimerId);
   uint32_t timerId = (uint32_t)aTimerId;
 
   bool firstTimeout = true;
 
   ForEachUnorderedTimeoutAbortable([&](Timeout* aTimeout) {
     MOZ_LOG(gLog, LogLevel::Debug,
             ("Clear%s(TimeoutManager=%p, timeout=%p, aTimerId=%u, ID=%u, tracking=%d)\n", aTimeout->mIsInterval ? "Interval" : "Timeout",
              this, aTimeout, timerId, aTimeout->mTimeoutId,
@@ -528,16 +532,34 @@ void
 TimeoutManager::RunTimeout(const TimeStamp& aTargetDeadline)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aTargetDeadline.IsNull());
 
   if (mWindow.IsSuspended()) {
     return;
   }
 
+  bool firstPaint = false;
+  bool suppressed = false;
+  {
+    nsIDocShell* docShell = mWindow.GetDocShell();
+    nsIPresShell* presShell = docShell ? docShell->GetPresShell() : nullptr;
+    if (presShell) {
+      firstPaint = presShell->GetIsFirstPaint();
+      suppressed = presShell->IsPaintingSuppressed();
+    } else {
+      printf_stderr("### ### [%p] TimeoutManager::RunTimeout() no nsIPresShell!\n", this);
+    }
+  }
+
+  printf_stderr("### ### [%p] TimeoutManager::RunTimeout() safe:%s first-paint:%s suppressed:%s\n", this,
+                (nsContentUtils::IsSafeToRunScript() ? "true" : "false"),
+                (firstPaint ? "true" : "false"),
+                (suppressed ? "true" : "false"));
+
   NS_ASSERTION(!mWindow.IsFrozen(), "Timeout running on a window in the bfcache!");
 
   // Limit the overall time spent in RunTimeout() to reduce jank.
   uint32_t totalTimeLimitMS = std::max(1u, gMaxConsecutiveCallbacksMilliseconds);
   const TimeDuration totalTimeLimit = TimeDuration::FromMilliseconds(totalTimeLimitMS);
 
   // Allow up to 25% of our total time budget to be used figuring out which
   // timers need to run.  This is the initial loop in this method.
@@ -634,16 +656,18 @@ TimeoutManager::RunTimeout(const TimeSta
             nextDeadline = timeout->When();
             break;
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
+
+    printf_stderr("### ### [%p] TimeoutManager::RunTimeout() executing %u timers\n", this, numTimersToRun);
   }
 
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.
   if (!nextDeadline.IsNull()) {
     MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline));
   }
 
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -1194,18 +1194,20 @@ nsFocusManager::ActivateOrDeactivate(nsP
 }
 
 void
 nsFocusManager::SetFocusInner(nsIContent* aNewContent, int32_t aFlags,
                               bool aFocusChanged, bool aAdjustWidget)
 {
   // if the element is not focusable, just return and leave the focus as is
   nsCOMPtr<nsIContent> contentToFocus = CheckIfFocusable(aNewContent, aFlags);
-  if (!contentToFocus)
+  if (!contentToFocus) {
+    printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() no contentToFocus\n", this);
     return;
+  }
 
   // check if the element to focus is a frame (iframe) containing a child
   // document. Frames are never directly focused; instead focusing a frame
   // means focus what is inside the frame. To do this, the descendant content
   // within the frame is retrieved and that will be focused instead.
   nsCOMPtr<nsPIDOMWindowOuter> newWindow;
   nsCOMPtr<nsPIDOMWindowOuter> subWindow = GetContentWindow(contentToFocus);
   if (subWindow) {
@@ -1228,23 +1230,27 @@ nsFocusManager::SetFocusInner(nsIContent
   // don't allow focus to be placed in docshells or descendants of docshells
   // that are being destroyed. Also, ensure that the page hasn't been
   // unloaded. The prevents content from being refocused during an unload event.
   nsCOMPtr<nsIDocShell> newDocShell = newWindow->GetDocShell();
   nsCOMPtr<nsIDocShell> docShell = newDocShell;
   while (docShell) {
     bool inUnload;
     docShell->GetIsInUnload(&inUnload);
-    if (inUnload)
+    if (inUnload) {
+      printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() docshell unloading\n", this);
       return;
+    }
 
     bool beingDestroyed;
     docShell->IsBeingDestroyed(&beingDestroyed);
-    if (beingDestroyed)
+    if (beingDestroyed) {
+      printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() docshell destroying\n", this);
       return;
+    }
 
     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
     docShell->GetParent(getter_AddRefs(parentDsti));
     docShell = do_QueryInterface(parentDsti);
   }
 
   // if the new element is in the same window as the currently focused element 
   bool isElementInFocusedWindow = (mFocusedWindow == newWindow);
@@ -1253,22 +1259,24 @@ nsFocusManager::SetFocusInner(nsIContent
       nsContentUtils::IsHandlingKeyBoardEvent()) {
     nsCOMPtr<nsIScriptObjectPrincipal> focused =
       do_QueryInterface(mFocusedWindow);
     nsCOMPtr<nsIScriptObjectPrincipal> newFocus =
       do_QueryInterface(newWindow);
     nsIPrincipal* focusedPrincipal = focused->GetPrincipal();
     nsIPrincipal* newPrincipal = newFocus->GetPrincipal();
     if (!focusedPrincipal || !newPrincipal) {
+      printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() no principal\n", this);
       return;
     }
     bool subsumes = false;
     focusedPrincipal->Subsumes(newPrincipal, &subsumes);
     if (!subsumes && !nsContentUtils::LegacyIsCallerChromeOrNativeCode()) {
       NS_WARNING("Not allowed to focus the new window!");
+      printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() cross-origin\n", this);
       return;
     }
   }
 
   // to check if the new element is in the active window, compare the
   // new root docshell for the new element with the active window's docshell.
   bool isElementInActiveWindow = false;
 
@@ -1361,18 +1369,20 @@ nsFocusManager::SetFocusInner(nsIContent
       // to clear out the focus in A, otherwise A would still maintain that B
       // was focused, and B that D was focused.
       nsCOMPtr<nsPIDOMWindowOuter> commonAncestor;
       if (!isElementInFocusedWindow)
         commonAncestor = GetCommonAncestor(newWindow, mFocusedWindow);
 
       if (!Blur(currentIsSameOrAncestor ? mFocusedWindow.get() : nullptr,
                 commonAncestor, !isElementInFocusedWindow, aAdjustWidget,
-                contentToFocus))
+                contentToFocus)) {
+        printf_stderr("### ### [%p] nsFocusManager::SetFocusinner() blur old element failed\n", this);
         return;
+      }
     }
 
     Focus(newWindow, contentToFocus, aFlags, !isElementInFocusedWindow,
           aFocusChanged, false, aAdjustWidget, oldFocusedContent);
   }
   else {
     // otherwise, for inactive windows and when the caller cannot steal the
     // focus, update the node in the window, and  raise the window if desired.
@@ -2159,29 +2169,33 @@ nsFocusManager::SendFocusOrBlurEvent(Eve
           mDelayedBlurFocusEvents[i - 1].mPresShell == aPresShell &&
           mDelayedBlurFocusEvents[i - 1].mDocument == aDocument &&
           mDelayedBlurFocusEvents[i - 1].mTarget == eventTarget &&
           mDelayedBlurFocusEvents[i - 1].mRelatedTarget == aRelatedTarget) {
         mDelayedBlurFocusEvents.RemoveElementAt(i - 1);
       }
     }
 
+    printf_stderr("### ### [%p] SendFocusOrBlurEvent() queued delayed\n", this);
+
     mDelayedBlurFocusEvents.AppendElement(
       nsDelayedBlurOrFocusEvent(aEventMessage, aPresShell,
                                 aDocument, eventTarget, aRelatedTarget));
     return;
   }
 
   // If mDelayedBlurFocusEvents queue is not empty, check if there are events
   // that belongs to this doc, if yes, fire them first.
   if (aDocument && !aDocument->EventHandlingSuppressed() &&
       mDelayedBlurFocusEvents.Length()) {
     FireDelayedEvents(aDocument);
   }
 
+  printf_stderr("### ### [%p] SendFocusOrBlurEvent() fire event\n", this);
+
   FireFocusOrBlurEvent(aEventMessage, aPresShell, aTarget, aWindowRaised,
                        aIsRefocus, aRelatedTarget);
 }
 
 void
 nsFocusManager::FireFocusOrBlurEvent(EventMessage aEventMessage,
                                      nsIPresShell* aPresShell,
                                      nsISupports* aTarget,
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -1864,16 +1864,18 @@ PresShell::Initialize(nscoord aWidth, ns
     } else {
       // Initialize the timer.
 
       // Default to PAINTLOCK_EVENT_DELAY if we can't get the pref value.
       int32_t delay =
         Preferences::GetInt("nglayout.initialpaint.delay",
                             PAINTLOCK_EVENT_DELAY);
 
+      printf_stderr("### ### [%p] PresShell::Initialize() start paint suppression timer %d\n", this, delay);
+
       mPaintSuppressionTimer->SetTarget(
           mDocument->EventTargetFor(TaskCategory::Other));
       mPaintSuppressionTimer->InitWithNamedFuncCallback(
         sPaintSuppressionCallback, this, delay, nsITimer::TYPE_ONE_SHOT,
         "PresShell::sPaintSuppressionCallback");
     }
   }
 
@@ -3880,16 +3882,17 @@ PresShell::UnsuppressAndInvalidate()
   if ((!mDocument->IsResourceDoc() && !mPresContext->EnsureVisible()) ||
       mHaveShutDown) {
     // No point; we're about to be torn down anyway.
     return;
   }
 
   ScheduleBeforeFirstPaint();
 
+  printf_stderr("### ### [%p] PresShell::UnsuppressAndInvalidate()\n", this);
   mPaintingSuppressed = false;
   nsIFrame* rootFrame = mFrameConstructor->GetRootFrame();
   if (rootFrame) {
     // let's assume that outline on a root frame is not supported
     rootFrame->InvalidateFrame();
   }
 
   // now that painting is unsuppressed, focus may be set on the document
@@ -9033,16 +9036,17 @@ PresShell::Freeze()
   MaybeReleaseCapturingContent();
 
   mDocument->EnumerateActivityObservers(FreezeElement, nullptr);
 
   if (mCaret) {
     SetCaretEnabled(false);
   }
 
+  printf_stderr("### ### [%p] PresShell::Freeze() suppressing\n", this);
   mPaintingSuppressed = true;
 
   if (mDocument) {
     mDocument->EnumerateSubDocuments(FreezeSubDocument, nullptr);
   }
 
   nsPresContext* presContext = GetPresContext();
   if (presContext) {
diff --git a/layout/generic/nsImageMap.cpp b/layout/generic/nsImageMap.cpp
--- a/layout/generic/nsImageMap.cpp
+++ b/layout/generic/nsImageMap.cpp
@@ -718,16 +718,18 @@ nsImageMap::FreeAreas()
     Area* area = mAreas.ElementAt(i);
     if (area->mArea->IsInUncomposedDoc()) {
       NS_ASSERTION(area->mArea->GetPrimaryFrame() == mImageFrame,
                    "Unexpected primary frame");
 
       area->mArea->SetPrimaryFrame(nullptr);
     }
 
+    printf_stderr("### ### [%p] nsImageMap::HandleEvent() remove event listeners from %p\n",
+                  this, area->mArea.get());
     area->mArea->RemoveSystemEventListener(NS_LITERAL_STRING("focus"), this,
                                            false);
     area->mArea->RemoveSystemEventListener(NS_LITERAL_STRING("blur"), this,
                                            false);
     delete area;
   }
   mAreas.Clear();
 }
@@ -848,16 +850,18 @@ nsImageMap::AddArea(nsIContent* aArea)
     area = nullptr;
     NS_NOTREACHED("FindAttrValueIn returned an unexpected value.");
     break;
   }
   if (!area)
     return NS_ERROR_OUT_OF_MEMORY;
 
   //Add focus listener to track area focus changes
+  printf_stderr("### ### [%p] nsImageMap::HandleEvent() add event listeners to %p\n",
+                this, aArea);
   aArea->AddSystemEventListener(NS_LITERAL_STRING("focus"), this, false,
                                 false);
   aArea->AddSystemEventListener(NS_LITERAL_STRING("blur"), this, false,
                                 false);
 
   // This is a nasty hack.  It needs to go away: see bug 135040.  Once this is
   // removed, the code added to RestyleManager::RestyleElement,
   // nsCSSFrameConstructor::ContentRemoved (both hacks there), and
@@ -984,30 +988,37 @@ nsresult
 nsImageMap::HandleEvent(nsIDOMEvent* aEvent)
 {
   nsAutoString eventType;
   aEvent->GetType(eventType);
   bool focus = eventType.EqualsLiteral("focus");
   MOZ_ASSERT(focus == !eventType.EqualsLiteral("blur"),
              "Unexpected event type");
 
+  printf_stderr("### ### [%p] nsImageMap::HandleEvent() %s\n",
+                this, (focus ? "focus" : "blur"));
+
   //Set which one of our areas changed focus
   nsCOMPtr<nsIContent> targetContent = do_QueryInterface(
     aEvent->InternalDOMEvent()->GetTarget());
   if (!targetContent) {
+    printf_stderr("### ### [%p] nsImageMap::HandleEvent() %s - no content\n",
+                  this, (focus ? "focus" : "blur"));
     return NS_OK;
   }
   uint32_t i, n = mAreas.Length();
   for (i = 0; i < n; i++) {
     Area* area = mAreas.ElementAt(i);
     if (area->mArea == targetContent) {
       //Set or Remove internal focus
       area->HasFocus(focus);
       //Now invalidate the rect
       if (mImageFrame) {
+        printf_stderr("### ### [%p] nsImageMap::HandleEvent() %s - invalidate frame\n",
+                      this, (focus ? "focus" : "blur"));
         mImageFrame->InvalidateFrame();
       }
       break;
     }
   }
   return NS_OK;
 }
 
diff --git a/layout/reftests/bugs/703186-1-ref.html b/layout/reftests/bugs/703186-1-ref.html
--- a/layout/reftests/bugs/703186-1-ref.html
+++ b/layout/reftests/bugs/703186-1-ref.html
@@ -1,20 +1,22 @@
 <!DOCTYPE html>
 <html class="reftest-wait">
   <head>
     <script type="text/javascript">
       function init()
       {
+        dump('### ### 703186-1-ref.html init()\n');
         document.getElementById("link").focus();
         setTimeout(finish, 0);
       }
 
       function finish()
       {
+        dump('### ### 703186-1-ref.html finish()\n');
         document.documentElement.removeAttribute("class");
       }
     </script>
   </head>
   <body onload="setTimeout(init, 0);">
     <img src="100x80-white-rect-top-right.png" usemap="#map">
     <map name="map">
       <area id="link" shape="rect" coords="10,10,30,30" href="about:blank">
diff --git a/layout/reftests/bugs/703186-1.html b/layout/reftests/bugs/703186-1.html
--- a/layout/reftests/bugs/703186-1.html
+++ b/layout/reftests/bugs/703186-1.html
@@ -1,22 +1,24 @@
 <!DOCTYPE html>
 <html class="reftest-wait">
   <head>
     <script type="text/javascript">
       function init()
       {
+        dump('### ### 703186-1.html init()\n');
         window.addEventListener("focus", function (e) { e.stopPropagation(); },
                                 true);
         document.getElementById("link").focus();
         setTimeout(finish, 0);
       }
 
       function finish()
       {
+        dump('### ### 703186-1.html finish()\n');
         document.documentElement.removeAttribute("class");
       }
     </script>
   </head>
   <body onload="setTimeout(init, 0);">
     <img src="100x80-white-rect-top-right.png" usemap="#map">
     <map name="map">
       <area id="link" shape="rect" coords="10,10,30,30" href="about:blank">
