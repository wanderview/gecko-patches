# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c53c5e0b0730795f7b72679070102a7f5e4cad7b

diff --git a/browser/base/content/test/general/browser_bug462289.js b/browser/base/content/test/general/browser_bug462289.js
--- a/browser/base/content/test/general/browser_bug462289.js
+++ b/browser/base/content/test/general/browser_bug462289.js
@@ -26,18 +26,21 @@ function step2() {
   executeSoon(step3);
 }
 
 function step3() {
   is(gBrowser.selectedTab, tab1, "2nd click on selected tab1 keeps tab selected");
   isnot(document.activeElement, tab1, "2nd click on selected tab1 does not activate tab");
 
   ok(true, "focusing URLBar then sending 1 Shift+Tab.");
+  dump('### ### before focus ' + document.activeElement + '\n');
   gURLBar.focus();
+  dump('### ### after focus ' + document.activeElement + '\n');
   EventUtils.synthesizeKey("VK_TAB", {shiftKey: true});
+  dump('### ### after shift-tab ' + document.activeElement + '\n');
   is(gBrowser.selectedTab, tab1, "tab key to selected tab1 keeps tab selected");
   is(document.activeElement, tab1, "tab key to selected tab1 activates tab");
 
   EventUtils.synthesizeMouseAtCenter(tab1, {});
   executeSoon(step4);
 }
 
 function step4() {
diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -28,16 +28,17 @@ TimeoutExecutor::ScheduleImmediate(const
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor IMMEDIATE\n", this);
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
@@ -86,16 +87,17 @@ TimeoutExecutor::ScheduleDelayed(const T
     delay = aDeadline - aNow + TimeDuration::FromMilliseconds(0.9);
   }
 
   // Finally, this truncates the float delay to integral milliseconds.
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### [%p] TimeoutExecutor DELAYED (%0.3f)\n", this, delay.ToMilliseconds());
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline,
@@ -171,16 +173,17 @@ TimeoutExecutor::Shutdown()
 {
   mOwner = nullptr;
 
   if (mTimer) {
     mTimer->Cancel();
     mTimer = nullptr;
   }
 
+  printf_stderr("### ### [%p] TimeoutExecutor SHUTDOWN\n", this);
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
 TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline,
                                TimeoutPrecision aPrecision)
 {
@@ -198,16 +201,17 @@ TimeoutExecutor::MaybeSchedule(const Tim
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
+  printf_stderr("### ### [%p] TimeoutExecutor NONE\n", this);
   mMode = Mode::None;
   mDeadline = TimeStamp();
 }
 
 NS_IMETHODIMP
 TimeoutExecutor::Run()
 {
   // If the executor is canceled and then rescheduled its possible to get
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -343,16 +343,18 @@ TimeoutManager::SetTimeout(nsITimeoutHan
 {
   // If we don't have a document (we could have been unloaded since
   // the call to setTimeout was made), do nothing.
   nsCOMPtr<nsIDocument> doc = mWindow.GetExtantDoc();
   if (!doc) {
     return NS_OK;
   }
 
+  printf_stderr("### ### [%p] SetTimeout %d\n", mExecutor.get(), interval);
+
   // Disallow negative intervals.  If aIsInterval also disallow 0,
   // because we use that as a "don't repeat" flag.
   interval = std::max(aIsInterval ? 1 : 0, interval);
 
   // Make sure we don't proceed with an interval larger than our timer
   // code can handle. (Note: we already forced |interval| to be non-negative,
   // so the uint32_t cast (to avoid compiler warnings) is ok.)
   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
@@ -646,16 +648,20 @@ TimeoutManager::RunTimeout(const TimeSta
             nextDeadline = timeout->When();
             break;
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
+
+    if (numTimersToRun) {
+      printf_stderr("### ### [%p] RunTimeout executing %u timeouts\n", mExecutor.get(), numTimersToRun);
+    }
   }
 
   now = TimeStamp::Now();
 
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.  Note, this *must* be done
   // before we start executing any content script handlers.  If one
   // of them spins the event loop the executor must already be scheduled
