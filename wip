# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f40e24f40b4c4556944c762d4764eace261297f5

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -16,16 +16,17 @@
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
+#include "mozilla/dom/ReservedClientHelper.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/StartupTimeline.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/Unused.h"
@@ -11524,16 +11525,20 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
 
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
+
+  rv = ReserveClientForChannel(aChannel);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 nsresult
 nsDocShell::ScrollToAnchor(bool aCurHasRef, bool aNewHasRef,
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13,16 +13,18 @@
 // Local Includes
 #include "Navigator.h"
 #include "nsContentSecurityManager.h"
 #include "nsScreen.h"
 #include "nsHistory.h"
 #include "nsDOMNavigationTiming.h"
 #include "nsIDOMStorageManager.h"
 #include "mozilla/dom/Storage.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/IdleRequest.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/StorageEvent.h"
 #include "mozilla/dom/StorageEventBinding.h"
 #include "mozilla/dom/Timeout.h"
 #include "mozilla/dom/TimeoutHandler.h"
 #include "mozilla/dom/TimeoutManager.h"
 #include "mozilla/IntegerPrintfMacros.h"
@@ -2117,16 +2119,19 @@ nsGlobalWindow::FreeInnerObjects()
   mAudioContexts.Clear();
 
   DisableGamepadUpdates();
   mHasGamepad = false;
   mGamepads.Clear();
   DisableVRUpdates();
   mHasVREvents = false;
   mVRDisplays.Clear();
+
+  // This breaks a cycle between the window and the ClientSource object.
+  mClientSource = nullptr;
 }
 
 //*****************************************************************************
 // nsGlobalWindow::nsISupports
 //*****************************************************************************
 
 // QueryInterface implementation for nsGlobalWindow
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalWindow)
@@ -3223,24 +3228,32 @@ nsGlobalWindow::SetNewDocument(nsIDocume
         newInnerWindow->mDoc = aDocument;
 
         // The storage objects contain the URL of the window. We have to
         // recreate them when the innerWindow is reused.
         newInnerWindow->mLocalStorage = nullptr;
         newInnerWindow->mSessionStorage = nullptr;
 
         newInnerWindow->ClearDocumentDependentSlots(cx);
+
+        // Its unclear if we need to mark execution ready again here:
+        // https://github.com/whatwg/html/issues/2456
+        rv = newInnerWindow->InnerExecutionReady();
+        NS_ENSURE_SUCCESS(rv, rv);
       }
     } else {
       newInnerWindow->InnerSetNewDocument(cx, aDocument);
 
       // Initialize DOM classes etc on the inner window.
       JS::Rooted<JSObject*> obj(cx, newInnerGlobal);
       rv = kungFuDeathGrip->InitClasses(obj);
       NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = newInnerWindow->InnerExecutionReady();
+      NS_ENSURE_SUCCESS(rv, rv);
     }
 
     // If the document comes from a JAR, check if the channel was determined
     // to be unsafe. If so, permanently disable script on the compartment by
     // calling Block() and throwing away the key.
     nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(aDocument->GetChannel());
     if (jarChannel && jarChannel->GetIsUnsafe()) {
       xpc::Scriptability::Get(newInnerGlobal).Block();
@@ -3402,16 +3415,75 @@ nsGlobalWindow::InnerSetNewDocument(JSCo
 
   Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
                         mMutationBits ? 1 : 0);
 
   // Clear our mutation bitfield.
   mMutationBits = 0;
 }
 
+nsresult
+nsGlobalWindow::EnsureClientSource()
+{
+  MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
+  MOZ_DIAGNOSTIC_ASSERT(mDoc);
+
+  if (mClientSource) {
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsILoadInfo> loadInfo;
+
+  // Try to get the reserved client from the loading document
+  nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
+  if (channel) {
+    loadInfo = channel->GetLoadInfo();
+    if (loadInfo) {
+      mClientSource = loadInfo->TakeReservedClient();
+    }
+  }
+
+  // If we don't have a reserved client we need to create one now
+  if (!mClientSource) {
+    mClientSource = ClientManager::CreateSource(ClientType::Window,
+                                                mDoc->NodePrincipal());
+    if (!mClientSource) {
+      return NS_ERROR_FAILURE;
+    }
+  }
+
+  // The load may have started controlled the Client as well.  If
+  // so mark it as controlled immediately here.  The actor may
+  // or may not have been notified by the parent side about being
+  // controlled yet.
+  if (loadInfo) {
+    const Maybe<ServiceWorkerDescriptor>& controller =
+      loadInfo->GetController();
+    if (controller.isSome()) {
+      mClientSource->SetController(controller.ref());
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsGlobalWindow::InnerExecutionReady()
+{
+  MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
+
+  nsresult rv = EnsureClientSource();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mClientSource->WindowExecutionReady(AsInner());
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
 void
 nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
 {
   NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
   MOZ_ASSERT(aDocShell);
 
   if (aDocShell == mDocShell) {
     return;
@@ -4312,16 +4384,34 @@ nsPIDOMWindowInner::Thaw()
 }
 
 void
 nsPIDOMWindowInner::SyncStateFromParentWindow()
 {
   nsGlobalWindow::Cast(this)->SyncStateFromParentWindow();
 }
 
+Maybe<ClientInfo>
+nsPIDOMWindowInner::GetClientInfo() const
+{
+  return nsGlobalWindow::Cast(this)->GetClientInfo();
+}
+
+Maybe<ClientState>
+nsPIDOMWindowInner::GetClientState() const
+{
+  return nsGlobalWindow::Cast(this)->GetClientState();
+}
+
+Maybe<ServiceWorkerDescriptor>
+nsPIDOMWindowInner::GetController() const
+{
+  return nsGlobalWindow::Cast(this)->GetController();
+}
+
 bool
 nsPIDOMWindowInner::IsPlayingAudio()
 {
   RefPtr<AudioChannelService> acs = AudioChannelService::Get();
   if (!acs) {
     return false;
   }
   auto outer = GetOuterWindow();
@@ -12425,16 +12515,17 @@ nsGlobalWindow::FreezeInternal()
   MOZ_ASSERT(mSuspendDepth >= mFreezeDepth);
   if (mFreezeDepth != 1) {
     return;
   }
 
   mozilla::dom::workers::FreezeWorkersForWindow(AsInner());
 
   mTimeoutManager->Freeze();
+  mClientSource->Freeze();
 
   NotifyDOMWindowFrozen(this);
 }
 
 void
 nsGlobalWindow::Thaw()
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -12454,16 +12545,17 @@ nsGlobalWindow::ThawInternal()
 
   MOZ_ASSERT(mFreezeDepth != 0);
   mFreezeDepth -= 1;
   MOZ_ASSERT(mSuspendDepth >= mFreezeDepth);
   if (mFreezeDepth != 0) {
     return;
   }
 
+  mClientSource->Thaw();
   mTimeoutManager->Thaw();
 
   mozilla::dom::workers::ThawWorkersForWindow(AsInner());
 
   NotifyDOMWindowThawed(this);
 }
 
 bool
@@ -12562,16 +12654,53 @@ nsGlobalWindow::CallOnChildren(Method aM
     if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
       continue;
     }
 
     (inner->*aMethod)();
   }
 }
 
+Maybe<ClientInfo>
+nsGlobalWindow::GetClientInfo() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ClientInfo> clientInfo;
+  if (mClientSource) {
+    clientInfo.emplace(mClientSource->Info());
+  }
+  return Move(clientInfo);
+}
+
+Maybe<ClientState>
+nsGlobalWindow::GetClientState() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ClientState> clientState;
+  if (mClientSource) {
+    ClientState state;
+    nsresult rv = mClientSource->SnapshotState(&state);
+    if (NS_SUCCEEDED(rv)) {
+      clientState.emplace(state);
+    }
+  }
+  return Move(clientState);
+}
+
+Maybe<ServiceWorkerDescriptor>
+nsGlobalWindow::GetController() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ServiceWorkerDescriptor> controller;
+  if (mClientSource) {
+    controller = mClientSource->GetController();
+  }
+  return Move(controller);
+}
+
 nsresult
 nsGlobalWindow::FireDelayedDOMEvents()
 {
   FORWARD_TO_INNER(FireDelayedDOMEvents, (), NS_ERROR_UNEXPECTED);
 
   if (mApplicationCache) {
     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
   }
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -106,16 +106,17 @@ class IdleRequestExecutor;
 
 namespace mozilla {
 class AbstractThread;
 class DOMEventTargetHelper;
 class ThrottledEventQueue;
 namespace dom {
 class BarProp;
 struct ChannelPixelLayout;
+class ClientSource;
 class Console;
 class Crypto;
 class CustomElementRegistry;
 class DocGroup;
 class External;
 class Function;
 class Gamepad;
 enum class ImageBitmapFormat : uint8_t;
@@ -400,16 +401,20 @@ public:
   void Suspend();
   void Resume();
   virtual bool IsSuspended() const override;
   void Freeze();
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
+  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
+
   virtual nsresult FireDelayedDOMEvents() override;
 
   // Outer windows only.
   virtual bool WouldReuseInnerWindow(nsIDocument* aNewDocument) override;
 
   virtual void SetDocShell(nsIDocShell* aDocShell) override;
   virtual void DetachFromDocShell() override;
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
@@ -1465,16 +1470,22 @@ protected:
 
   void FreeInnerObjects();
   nsGlobalWindow *CallerInnerWindow();
 
   // Only to be called on an inner window.
   // aDocument must not be null.
   void InnerSetNewDocument(JSContext* aCx, nsIDocument* aDocument);
 
+  // inner window only
+  nsresult EnsureClientSource();
+
+  // inner window only
+  nsresult InnerExecutionReady();
+
   // Inner windows only.
   nsresult DefineArgumentsProperty(nsIArray *aArguments);
 
   // Get the parent, returns null if this is a toplevel window
   nsPIDOMWindowOuter* GetParentInternal();
 
 public:
   // popup tracking
@@ -2053,16 +2064,19 @@ protected:
   // after loading.  The value is the ID of the VRDisplay that content should
   // begin presentation on.
   uint32_t mAutoActivateVRDisplayID; // Outer windows only
 
 #ifdef ENABLE_INTL_API
   RefPtr<mozilla::dom::IntlUtils> mIntlUtils;
 #endif
 
+  // inner window only
+  mozilla::UniquePtr<mozilla::dom::ClientSource> mClientSource;
+
   friend class nsDOMScriptableHelper;
   friend class nsDOMWindowUtils;
   friend class mozilla::dom::PostMessageEvent;
   friend class DesktopNotification;
   friend class mozilla::dom::TimeoutManager;
   friend class IdleRequestExecutor;
 
   static WindowByIdTable* sWindowsById;
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -40,20 +40,23 @@ class nsPIWindowRoot;
 class nsXBLPrototypeHandler;
 
 typedef uint32_t SuspendTypes;
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
 class AudioContext;
+class ClientInfo;
+class ClientState;
 class DocGroup;
 class TabGroup;
 class Element;
 class Performance;
+class ServiceWorkerDescriptor;
 class ServiceWorkerRegistration;
 class Timeout;
 class TimeoutManager;
 class CustomElementRegistry;
 enum class CallerType : uint32_t;
 } // namespace dom
 } // namespace mozilla
 
@@ -884,16 +887,20 @@ public:
   void SyncStateFromParentWindow();
 
   bool IsPlayingAudio();
 
   mozilla::dom::TimeoutManager& TimeoutManager();
 
   bool IsRunningTimeout();
 
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
+  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
+
 protected:
   void CreatePerformanceObjectIfNeeded();
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindowInner, NS_PIDOMWINDOWINNER_IID)
 
 // NB: It's very very important that these two classes have identical vtables
 // and memory layout!
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -154,23 +154,21 @@ DOMInterfaces = {
 },
 
 'ChromeWorker': {
     'headerFile': 'mozilla/dom/WorkerPrivate.h',
     'nativeType': 'mozilla::dom::workers::ChromeWorkerPrivate',
 },
 
 'Client': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'Clients': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClients',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClients.h',
+    'nativeType': 'mozilla::dom::Clients',
 },
 
 'console': {
     'nativeType': 'mozilla::dom::Console',
 },
 
 'ConvolverNode': {
     'implicitJSContext': [ 'buffer' ],
@@ -1113,18 +1111,17 @@ DOMInterfaces = {
   'nativeType': 'mozilla::dom::TextTrackRegion',
 },
 
 'WebAuthentication': {
     'implicitJSContext': 'makeCredential',
 },
 
 'WindowClient': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerWindowClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerWindowClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'WebGLActiveInfo': {
     'nativeType': 'mozilla::WebGLActiveInfo',
     'headerFile': 'WebGLActiveInfo.h'
 },
 
 'WebGLBuffer': {
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.cpp
@@ -0,0 +1,267 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Client.h"
+
+#include "mozilla/dom/ClientBinding.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/WorkerScope.h"
+#include "nsIGlobalObject.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::dom::ipc::StructuredCloneData;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Client);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Client);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Client, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Client)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Client::~Client()
+{
+}
+
+void
+Client::EnsureHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(Client);
+  if (!mHandle) {
+    mHandle = ClientManager::CreateHandle(mData.info());
+  }
+}
+
+// TODO: unify this with code in Clients
+nsresult
+Client::GetEndPoint(ClientEndPoint& aEndPointOut)
+{
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
+    if (clientInfo.isSome()) {
+      aEndPointOut = clientInfo.ref();
+      return NS_OK;
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      if (workerPrivate->IsServiceWorker()) {
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        return NS_OK;
+      } else {
+        aEndPointOut = workerPrivate->GetClientInfo();
+        return NS_OK;
+      }
+    }
+  }
+
+  return NS_ERROR_DOM_INVALID_STATE_ERR;
+}
+
+Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
+  : mGlobal(aGlobal)
+  , mData(aData)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+TimeStamp
+Client::CreationTime() const
+{
+  return mData.info().creationTime();
+}
+
+TimeStamp
+Client::LastFocusTime() const
+{
+  if (mData.info().type() != ClientType::Window) {
+    return TimeStamp();
+  }
+  return mData.state().get_ClientWindowState().lastFocusTime();
+}
+
+JSObject*
+Client::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  if (mData.info().type() == ClientType::Window) {
+    return WindowClientBinding::Wrap(aCx, this, aGivenProto);
+  }
+  return ClientBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Client::GetParentObject() const
+{
+  return mGlobal;
+}
+
+void
+Client::GetUrl(nsAString& aUrlOut) const
+{
+  CopyUTF8toUTF16(mData.info().url(), aUrlOut);
+}
+
+void
+Client::GetId(nsAString& aIdOut) const
+{
+  char buf[NSID_LENGTH];
+  mData.info().id().ToProvidedString(buf);
+  NS_ConvertASCIItoUTF16 uuid(buf);
+
+  // Remove {} and the null terminator
+  aIdOut.Assign(Substring(uuid, 1, NSID_LENGTH - 3));
+}
+
+ClientType
+Client::Type() const
+{
+  return mData.info().type();
+}
+
+FrameType
+Client::GetFrameType() const
+{
+  return mData.info().frameType();
+}
+
+void
+Client::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+                    const Sequence<JSObject*>& aTransferable,
+                    ErrorResult& aRv)
+{
+  JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
+  aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
+                                                          &transferable);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  StructuredCloneData data;
+  data.Write(aCx, aMessage, transferable, aRv);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  ClientEndPoint endpoint;
+  aRv = GetEndPoint(endpoint);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  EnsureHandle();
+  RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
+}
+
+VisibilityState
+Client::GetVisibilityState() const
+{
+  return mData.state().get_ClientWindowState().visibilityState();
+}
+
+bool
+Client::Focused() const
+{
+  return mData.state().get_ClientWindowState().focused();
+}
+
+already_AddRefed<Promise>
+Client::Focus(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  aRv = GetEndPoint(endpoint);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_DIAGNOSTIC_ASSERT(workerPrivate);
+    if (!workerPrivate->GlobalScope()->WindowInteractionAllowed()) {
+      outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+      return outerPromise.forget();
+    }
+  }
+
+  EnsureHandle();
+
+  RefPtr<Client> self = this;
+
+  RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [self, outerPromise] (const ClientState& aResult) {
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, ClientInfoAndState(self->mData.info(), aResult));
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+    }
+  }
+
+  RefPtr<Client> self = this;
+
+  ClientNavigateArgs args(mData.info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+
+  RefPtr<ClientOpPromise> innerPromise = ClientManager::Navigate(args);
+
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [self, outerPromise] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.h
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Client_h
+#define _mozilla_dom_Client_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class ClientHandle;
+class Promise;
+template <typename t> class Sequence;
+
+class Client final : public nsISupports
+                   , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+  const ClientInfoAndState mData;
+  RefPtr<ClientHandle> mHandle;
+
+  ~Client();
+
+  void
+  EnsureHandle();
+
+  nsresult
+  GetEndPoint(ClientEndPoint& aEndPointOut);
+
+public:
+  Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData);
+
+  TimeStamp
+  CreationTime() const;
+
+  TimeStamp
+  LastFocusTime() const;
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  // Client Bindings
+  void
+  GetUrl(nsAString& aUrlOut) const;
+
+  void
+  GetId(nsAString& aIdOut) const;
+
+  ClientType
+  Type() const;
+
+  FrameType
+  GetFrameType() const;
+
+  // WindowClient bindings
+  VisibilityState
+  GetVisibilityState() const;
+
+  bool
+  Focused() const;
+
+  already_AddRefed<Promise>
+  Focus(ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Navigate(const nsAString& aURL, ErrorResult& aRv);
+
+  void
+  PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+              const Sequence<JSObject*>& aTransferrable,
+              ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Client)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Client_h
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.cpp
@@ -0,0 +1,254 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Clients.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientsBinding.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "nsIGlobalObject.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::ipc::PrincipalInfo;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Clients);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Clients);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Clients, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Clients)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Clients::~Clients()
+{
+}
+
+nsresult
+Clients::GetEndPoint(ClientEndPoint& aEndPointOut)
+{
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
+    if (clientInfo.isSome()) {
+      aEndPointOut = clientInfo.ref();
+      return NS_OK;
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      if (workerPrivate->IsServiceWorker()) {
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        return NS_OK;
+      } else {
+        aEndPointOut = workerPrivate->GetClientInfo();
+        return NS_OK;
+      }
+    }
+  }
+
+  return NS_ERROR_DOM_INVALID_STATE_ERR;
+}
+
+Clients::Clients(nsIGlobalObject* aGlobal)
+  : mGlobal(aGlobal)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+JSObject*
+Clients::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  return ClientsBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Clients::GetParentObject() const
+{
+  return mGlobal;
+}
+
+already_AddRefed<Promise>
+Clients::Get(const nsAString& aClientID, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsID id;
+  if (!id.Parse(NS_ConvertUTF16toUTF8(aClientID).get())) {
+    // Invalid ID means we will definitely not find a match, so just
+    // resolve with undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = GetEndPoint(endpoint);
+  if (NS_FAILED(rv)) {
+    // If we can't get an endpoint then we don't have a recognizeable
+    // principal and we won't effectively match anything.  Resolve
+    // undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor
+      ? endpoint.get_ServiceWorkerDescriptor().principalInfo()
+      : endpoint.get_ClientInfo().principalInfo();
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  RefPtr<ClientOpPromise> innerPromise =
+    ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo));
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolve(
+        new Client(global, aResult.get_ClientInfoAndState()));
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    });
+
+  return outerPromise.forget();
+}
+
+namespace {
+
+class MatchAllComparator final
+{
+public:
+  bool
+  LessThan(Client* aLeft, Client* aRight) const
+  {
+    TimeStamp leftFocusTime = aLeft->LastFocusTime();
+    TimeStamp rightFocusTime = aRight->LastFocusTime();
+    // If the focus times are the same, then default to creation order.
+    // MatchAll should return oldest Clients first.
+    if (leftFocusTime == rightFocusTime) {
+      return aLeft->CreationTime() < aRight->CreationTime();
+    }
+
+    // Otherwise compare focus times.  We reverse the logic here so
+    // that the most recently focused window is first in the list.
+    if (!leftFocusTime.IsNull() && rightFocusTime.IsNull()) {
+      return true;
+    }
+    if (leftFocusTime.IsNull() && !rightFocusTime.IsNull()) {
+      return false;
+    }
+    return leftFocusTime > rightFocusTime;
+  }
+
+  bool
+  Equals(Client* aLeft, Client* aRight) const
+  {
+    return aLeft->LastFocusTime() == aRight->LastFocusTime() &&
+           aLeft->CreationTime() == aRight->CreationTime();
+  }
+};
+
+} // anonymous namespace
+
+already_AddRefed<Promise>
+Clients::MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = GetEndPoint(endpoint);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return outerPromise.forget();
+  }
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  // We don't expose this reserved clients yet
+  const bool includeReserved = false;
+  ClientMatchAllArgs args(endpoint, aOptions.mType,
+                          aOptions.mIncludeUncontrolled,
+                          includeReserved);
+  RefPtr<ClientOpPromise> innerPromise = ClientManager::MatchAll(args);
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      nsTArray<RefPtr<Client>> clientList;
+      for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
+        clientList.AppendElement(new Client(global, value));
+      }
+      clientList.Sort(MatchAllComparator());
+      outerPromise->MaybeResolve(clientList);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
+{
+  // TODO: OMG this will take a lot of work
+  aRv.Throw(NS_ERROR_FAILURE);
+  return nullptr;
+}
+
+already_AddRefed<Promise>
+Clients::Claim(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = GetEndPoint(endpoint);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return outerPromise.forget();
+  }
+
+  if (endpoint.type() != ClientEndPoint::TServiceWorkerDescriptor) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  const ServiceWorkerDescriptor& serviceWorker =
+    endpoint.get_ServiceWorkerDescriptor();
+
+  if (serviceWorker.state() != ServiceWorkerState::Activating &&
+      serviceWorker.state() != ServiceWorkerState::Activated) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  RefPtr<ClientOpPromise> innerPromise =
+    ClientManager::Claim(ClientClaimArgs(serviceWorker));
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Clients.h b/dom/clients/api/Clients.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Clients_h
+#define _mozilla_dom_Clients_h
+
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class ClientEndPoint;
+struct ClientQueryOptions;
+class Promise;
+
+class Clients final : public nsISupports
+                    , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+
+  ~Clients();
+
+  nsresult
+  GetEndPoint(ClientEndPoint& aEndPointOut);
+
+public:
+  explicit Clients(nsIGlobalObject* aGlobal);
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  already_AddRefed<Promise>
+  Get(const nsAString& aClientID, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  OpenWindow(const nsAString& aURL, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Claim(ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Clients)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Clients_h
diff --git a/dom/clients/api/moz.build b/dom/clients/api/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/moz.build
@@ -0,0 +1,32 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'Client.h',
+  'Clients.h',
+]
+
+UNIFIED_SOURCES += [
+  'Client.cpp',
+  'Clients.cpp',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+  '/dom/workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -0,0 +1,181 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandle.h"
+
+#include "ClientHandleChild.h"
+#include "ClientHandleOpChild.h"
+#include "ClientManager.h"
+#include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::ipc::StructuredCloneData;
+
+ClientHandle::~ClientHandle()
+{
+  Shutdown();
+}
+
+void
+ClientHandle::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (IsShutdown()) {
+    return;
+  }
+
+  ShutdownThing();
+
+  mManager->ForgetHandle(this);
+  mManager = nullptr;
+}
+
+already_AddRefed<ClientOpPromise>
+ClientHandle::StartOp(const ClientOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  // Hold a ref to the client until the remote operation completes.  Otherwise
+  // the ClientHandle might get de-refed and teardown the actor before we
+  // get an answer.
+  RefPtr<ClientHandle> kungFuGrip = this;
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+                [kungFuGrip] (const ClientOpResult &) { },
+                [kungFuGrip] (nsresult) { });
+
+  MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
+    ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
+    if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
+      // Constructor failure will reject promise via ActorDestroy()
+      return;
+    }
+  });
+
+  RefPtr<ClientOpPromise> ref = promise.get();
+  return ref.forget();
+}
+
+ClientHandle::ClientHandle(ClientManager* aManager,
+                           const ClientInfo& aClientInfo)
+  : mManager(aManager)
+  , mClientInfo(aClientInfo)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
+}
+
+void
+ClientHandle::Activate(PClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientHandle);
+
+  if (IsShutdown()) {
+    return;
+  }
+
+  PClientHandleChild* actor = aActor->SendPClientHandleConstructor(mClientInfo);
+  if (!actor) {
+    Shutdown();
+    return;
+  }
+
+  ActivateThing(static_cast<ClientHandleChild*>(actor));
+
+  MaybeExecuteTaskList();
+}
+
+void
+ClientHandle::ExecutionReady(const ClientInfo& aClientInfo)
+{
+  mClientInfo = aClientInfo;
+}
+
+const ClientInfo&
+ClientHandle::Info() const
+{
+  return mClientInfo;
+}
+
+already_AddRefed<GenericPromise>
+ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
+{
+  RefPtr<GenericPromise::Private> outerPromise =
+    new GenericPromise::Private(__func__);
+
+  RefPtr<ClientOpPromise> innerPromise =
+    StartOp(ClientControlledArgs(aServiceWorker));
+
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Resolve(true, __func__);
+    }, [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    });
+
+  RefPtr<GenericPromise> ref = outerPromise.get();
+  return ref.forget();
+}
+
+already_AddRefed<ClientStatePromise>
+ClientHandle::Focus()
+{
+  RefPtr<ClientStatePromise::Private> outerPromise =
+    new ClientStatePromise::Private(__func__);
+
+  RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
+
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Resolve(aResult.get_ClientState(), __func__);
+    }, [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    });
+
+  RefPtr<ClientStatePromise> ref = outerPromise.get();
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise>
+ClientHandle::PostMessage(StructuredCloneData& aData,
+                          const ClientEndPoint& aEndPoint)
+{
+  RefPtr<GenericPromise> ref;
+
+  ClientPostMessageArgs args;
+  args.endpoint() = aEndPoint;
+
+  // TODO: Ideally we should be able to wait for the actor to initialize,
+  //       but for now just fail the postMessage() if its not ready.  We
+  //       need a RefCounted version of the StructuredCloneData in order
+  //       to capture it in the lambda here.
+  if (!GetActor() ||
+      !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
+                                                      args.clonedData())) {
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    ref.forget();
+  }
+
+  RefPtr<GenericPromise::Private> outerPromise =
+    new GenericPromise::Private(__func__);
+
+  RefPtr<ClientOpPromise> innerPromise = StartOp(args);
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Resolve(true, __func__);
+    }, [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    });
+
+  ref = outerPromise.get();
+  return ref.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandle.h
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandle_h
+#define _mozilla_dom_ClientHandle_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/ClientThing.h"
+#include "mozilla/MozPromise.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+
+namespace dom {
+
+class ClientManager;
+class ClientHandleChild;
+class PClientManagerChild;
+class ServiceWorkerDescriptor;
+
+namespace ipc {
+class StructuredCloneData;
+}
+
+class ClientHandle final : public ClientThing<ClientHandleChild>
+{
+  friend class ClientManager;
+  friend class ClientHandleChild;
+
+  RefPtr<ClientManager> mManager;
+  ClientInfo mClientInfo;
+
+  ~ClientHandle();
+
+  void
+  Shutdown();
+
+  already_AddRefed<ClientOpPromise>
+  StartOp(const ClientOpConstructorArgs& aArgs);
+
+  // Private methods called by ClientManager
+  ClientHandle(ClientManager* aManager,
+               const ClientInfo& aClientInfo);
+
+  void
+  Activate(PClientManagerChild* aActor);
+
+  // Private methods called by ClientHandleChild
+  void
+  ExecutionReady(const ClientInfo& aClientInfo);
+
+public:
+  const ClientInfo&
+  Info() const;
+
+  already_AddRefed<GenericPromise>
+  Control(const ServiceWorkerDescriptor& aServiceWorker);
+
+  already_AddRefed<ClientStatePromise>
+  Focus();
+
+  already_AddRefed<GenericPromise>
+  PostMessage(ipc::StructuredCloneData& aData,
+              const ClientEndPoint& aEndPoint);
+
+  NS_INLINE_DECL_REFCOUNTING(ClientHandle);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandle_h
diff --git a/dom/clients/manager/ClientHandleChild.cpp b/dom/clients/manager/ClientHandleChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleChild.cpp
@@ -0,0 +1,82 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleChild.h"
+
+#include "ClientHandleOpChild.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientHandleChild::RecvExecutionReady(const ClientInfo& aClientInfo)
+{
+  if (mHandle) {
+    mHandle->ExecutionReady(aClientInfo);
+  }
+  return IPC_OK();
+}
+
+void
+ClientHandleChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mHandle) {
+    mHandle->RevokeActor(this);
+    MOZ_DIAGNOSTIC_ASSERT(!mHandle);
+  }
+}
+
+PClientHandleOpChild*
+ClientHandleChild::AllocPClientHandleOpChild(const ClientOpConstructorArgs& aArgs)
+{
+  MOZ_ASSERT_UNREACHABLE("ClientHandleOpChild must be explicitly constructed.");
+  return nullptr;
+}
+
+bool
+ClientHandleChild::DeallocPClientHandleOpChild(PClientHandleOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+ClientHandleChild::ClientHandleChild(const ClientInfo& aClientInfo)
+  : mHandle(nullptr)
+  , mTeardownStarted(false)
+{
+}
+
+void
+ClientHandleChild::SetOwner(ClientThing<ClientHandleChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mHandle);
+  mHandle = static_cast<ClientHandle*>(aThing);
+  MOZ_DIAGNOSTIC_ASSERT(mHandle);
+}
+
+void
+ClientHandleChild::RevokeOwner(ClientThing<ClientHandleChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mHandle);
+  MOZ_DIAGNOSTIC_ASSERT(mHandle == static_cast<ClientHandle*>(aThing));
+  mHandle = nullptr;
+}
+
+void
+ClientHandleChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  Unused << SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleChild.h b/dom/clients/manager/ClientHandleChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleChild.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleChild_h
+#define _mozilla_dom_ClientHandleChild_h
+
+#include "mozilla/dom/PClientHandleChild.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandle;
+class ClientInfo;
+template <typename ActorType> class ClientThing;
+
+class ClientHandleChild final : public PClientHandleChild
+{
+  ClientHandle* mHandle;
+  bool mTeardownStarted;
+
+  // PClientHandleChild interface
+  mozilla::ipc::IPCResult
+  RecvExecutionReady(const ClientInfo& aClientInfo) override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleOpChild*
+  AllocPClientHandleOpChild(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleOpChild(PClientHandleOpChild* aActor) override;
+
+public:
+  explicit ClientHandleChild(const ClientInfo& aClientInfo);
+
+  void
+  SetOwner(ClientThing<ClientHandleChild>* aThing);
+
+  void
+  RevokeOwner(ClientThing<ClientHandleChild>* aThing);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleChild_h
diff --git a/dom/clients/manager/ClientHandleOpChild.cpp b/dom/clients/manager/ClientHandleOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleOpChild.cpp
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleOpChild.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientHandleOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientHandleOpChild::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientHandleOpChild::ClientHandleOpChild(const ClientOpConstructorArgs& aArgs,
+                                         ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientHandleOpChild::~ClientHandleOpChild()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpChild.h b/dom/clients/manager/ClientHandleOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleOpChild.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleOpChild_h
+#define _mozilla_dom_ClientHandleOpChild_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientHandleOpChild.h"
+#include "mozilla/MozPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandleOpChild final : public PClientHandleOpChild
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientHandleOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientHandleOpChild(const ClientOpConstructorArgs& aArgs,
+                      ClientOpPromise::Private* aPromise);
+
+  ~ClientHandleOpChild();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleOpChild_h
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -0,0 +1,87 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleOpParent.h"
+
+#include "ClientHandleParent.h"
+#include "ClientSourceParent.h"
+#include "mozilla/dom/PClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+ClientSourceParent*
+ClientHandleOpParent::GetSource() const
+{
+  auto handle = static_cast<ClientHandleParent*>(Manager());
+  return handle->GetSource();
+}
+
+AbstractThread*
+ClientHandleOpParent::BackgroundThread() const
+{
+  auto handle = static_cast<ClientHandleParent*>(Manager());
+  return handle->BackgroundThread();
+}
+
+void
+ClientHandleOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+void
+ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs)
+{
+  ClientSourceParent* source = GetSource();
+  if (!source) {
+    Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+    return;
+  }
+
+  RefPtr<ClientOpPromise> p;
+
+  // ClientPostMessageArgs can contain PBlob actors.  This means we
+  // can't just forward the args from one PBackground manager to
+  // another.  Instead, unpack the structured clone data and repack
+  // it into a new set of arguments.
+  if (aArgs.type() == ClientOpConstructorArgs::TClientPostMessageArgs) {
+    const ClientPostMessageArgs& orig = aArgs.get_ClientPostMessageArgs();
+
+    ClientPostMessageArgs rebuild;
+    rebuild.endpoint() = orig.endpoint();
+
+    StructuredCloneData data;
+    data.BorrowFromClonedMessageDataForBackgroundParent(orig.clonedData());
+    if (!data.BuildClonedMessageDataForBackgroundParent(source->Manager()->Manager(),
+                                                        rebuild.clonedData())) {
+      Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+      return;
+    }
+
+    p = source->StartOp(rebuild);
+  }
+
+  // Other argument types can just be forwarded straight through.
+  else {
+    p = source->StartOp(aArgs);
+  }
+
+  // Capturing `this` is safe here because we disconnect the promise in
+  // ActorDestroy() which ensures neither lambda is called if the actor
+  // is destroyed before the source operation completes.
+  p->Then(BackgroundThread(), __func__,
+      [this] (const ClientOpResult& aResult) {
+        mPromiseRequestHolder.Complete();
+        Unused << PClientHandleOpParent::Send__delete__(this, aResult);
+      }, [this] (const ClientOpResult& aResult) {
+        mPromiseRequestHolder.Complete();
+        Unused << PClientHandleOpParent::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpParent.h b/dom/clients/manager/ClientHandleOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleOpParent.h
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleOpParent_h
+#define _mozilla_dom_ClientHandleOpParent_h
+
+#include "mozilla/dom/PClientHandleOpParent.h"
+
+#include "mozilla/MozPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSourceParent;
+
+class ClientHandleOpParent final : public PClientHandleOpParent
+{
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  ClientSourceParent*
+  GetSource() const;
+
+  AbstractThread*
+  BackgroundThread() const;
+
+  // PClientHandleOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  ClientHandleOpParent() = default;
+  ~ClientHandleOpParent() = default;
+
+  void
+  Init(const ClientOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleOpParent_h
diff --git a/dom/clients/manager/ClientHandleParent.cpp b/dom/clients/manager/ClientHandleParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleParent.cpp
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleParent.h"
+
+#include "ClientHandleOpParent.h"
+#include "ClientManagerService.h"
+#include "ClientSourceParent.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientHandleParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientHandleParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mSource) {
+    mSource->DetachHandle(this);
+    mSource = nullptr;
+  }
+}
+
+PClientHandleOpParent*
+ClientHandleParent::AllocPClientHandleOpParent(const ClientOpConstructorArgs& aArgs)
+{
+  return new ClientHandleOpParent();
+}
+
+bool
+ClientHandleParent::DeallocPClientHandleOpParent(PClientHandleOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+IPCResult
+ClientHandleParent::RecvPClientHandleOpConstructor(PClientHandleOpParent* aActor,
+                                                   const ClientOpConstructorArgs& aArgs)
+{
+  auto actor = static_cast<ClientHandleOpParent*>(aActor);
+  actor->Init(aArgs);
+  return IPC_OK();
+}
+
+ClientHandleParent::ClientHandleParent()
+  : mService(ClientManagerService::GetOrCreateInstance())
+  , mSource(nullptr)
+{
+}
+
+ClientHandleParent::~ClientHandleParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mSource);
+}
+
+void
+ClientHandleParent::Init(const ClientInfo& aClientInfo)
+{
+  mSource = mService->FindSource(aClientInfo.id(), aClientInfo.principalInfo());
+  if (!mSource) {
+    Unused << Send__delete__(this);
+    return;
+  }
+
+  mSource->AttachHandle(this);
+}
+
+ClientSourceParent*
+ClientHandleParent::GetSource() const
+{
+  return mSource;
+}
+
+AbstractThread*
+ClientHandleParent::BackgroundThread() const
+{
+  return mService->BackgroundThread();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleParent.h b/dom/clients/manager/ClientHandleParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleParent.h
@@ -0,0 +1,58 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleParent_h
+#define _mozilla_dom_ClientHandleParent_h
+
+#include "mozilla/dom/PClientHandleParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientControlledArgs;
+class ClientInfo;
+class ClientManagerService;
+class ClientSourceParent;
+
+class ClientHandleParent final : public PClientHandleParent
+{
+  RefPtr<ClientManagerService> mService;
+  ClientSourceParent* mSource;
+
+  // PClientHandleParent interface
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleOpParent*
+  AllocPClientHandleOpParent(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleOpParent(PClientHandleOpParent* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientHandleOpConstructor(PClientHandleOpParent* aActor,
+                                 const ClientOpConstructorArgs& aArgs) override;
+
+public:
+  ClientHandleParent();
+  ~ClientHandleParent();
+
+  void
+  Init(const ClientInfo& aClientInfo);
+
+  ClientSourceParent*
+  GetSource() const;
+
+  AbstractThread*
+  BackgroundThread() const;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleParent_h
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -0,0 +1,149 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientSource;
+include DOMTypes;
+include PBackgroundSharedTypes;
+include ServiceWorkerDescriptor;
+using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
+using ClientType from "mozilla/dom/ClientIPCUtils.h";
+using FrameType from "mozilla/dom/ClientIPCUtils.h";
+using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+
+struct ClientSourceConstructorArgs
+{
+  nsID id;
+  ClientType type;
+  PrincipalInfo principalInfo;
+  TimeStamp creationTime;
+};
+
+struct ClientInfo
+{
+  nsID id;
+  ClientType type;
+  PrincipalInfo principalInfo;
+  TimeStamp creationTime;
+  nsCString url;
+  FrameType frameType;
+};
+
+struct ClientWindowState
+{
+  VisibilityState visibilityState;
+  TimeStamp lastFocusTime;
+  bool focused;
+};
+
+struct ClientWorkerState
+{
+};
+
+union ClientState
+{
+  ClientWindowState;
+  ClientWorkerState;
+};
+
+struct ClientInfoAndState
+{
+  ClientInfo info;
+  ClientState state;
+};
+
+struct ClientSourceExecutionReadyArgs
+{
+  nsCString url;
+  FrameType frameType;
+};
+
+struct ClientControlledArgs
+{
+  ServiceWorkerDescriptor serviceWorker;
+};
+
+struct ClientFocusArgs
+{
+};
+
+struct ClientNavigateArgs
+{
+  ClientInfo target;
+  nsCString url;
+  nsCString baseURL;
+};
+
+union ClientEndPoint
+{
+  ClientInfo;
+  ServiceWorkerDescriptor;
+};
+
+struct ClientPostMessageArgs
+{
+  ClonedMessageData clonedData;
+  ClientEndPoint endpoint;
+};
+
+struct ClientGetStateArgs
+{
+};
+
+struct ClientMatchAllArgs
+{
+  ClientEndPoint endpoint;
+  ClientType type;
+  bool includeUncontrolled;
+  bool includeReserved;
+};
+
+struct ClientClaimArgs
+{
+  ServiceWorkerDescriptor serviceWorker;
+};
+
+struct ClientGetInfoAndStateArgs
+{
+  nsID id;
+  PrincipalInfo principalInfo;
+};
+
+union ClientOpConstructorArgs
+{
+  ClientControlledArgs;
+  ClientFocusArgs;
+  ClientNavigateArgs;
+  ClientPostMessageArgs;
+  ClientGetStateArgs;
+  ClientMatchAllArgs;
+  ClientClaimArgs;
+  ClientGetInfoAndStateArgs;
+};
+
+struct ClientList
+{
+  ClientInfoAndState[] values;
+};
+
+struct ClientNavigateOpConstructorArgs
+{
+  PClientSource target;
+  nsCString url;
+  nsCString baseURL;
+};
+
+union ClientOpResult
+{
+  nsresult;
+  ClientState;
+  ClientInfoAndState;
+  ClientList;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientIPCUtils.h b/dom/clients/manager/ClientIPCUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientIPCUtils.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientIPCUtils_h
+#define _mozilla_dom_ClientIPCUtils_h
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/ClientBinding.h"
+#include "mozilla/dom/ClientsBinding.h"
+#include "mozilla/dom/DocumentBinding.h"
+
+namespace IPC {
+  template<>
+  struct ParamTraits<mozilla::dom::ClientType> :
+    public ContiguousEnumSerializer<mozilla::dom::ClientType,
+                                    mozilla::dom::ClientType::Window,
+                                    mozilla::dom::ClientType::EndGuard_>
+  {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::FrameType> :
+    public ContiguousEnumSerializer<mozilla::dom::FrameType,
+                                    mozilla::dom::FrameType::Auxiliary,
+                                    mozilla::dom::FrameType::EndGuard_>
+  {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::VisibilityState> :
+    public ContiguousEnumSerializer<mozilla::dom::VisibilityState,
+                                    mozilla::dom::VisibilityState::Hidden,
+                                    mozilla::dom::VisibilityState::EndGuard_>
+  {};
+} // namespace IPC
+
+#endif // _mozilla_dom_ClientIPCUtils_h
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManager.cpp
@@ -0,0 +1,373 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManager.h"
+
+#include "ClientHandle.h"
+#include "ClientManagerChild.h"
+#include "ClientManagerOpChild.h"
+#include "ClientSource.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "prthread.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::Terminating;
+using mozilla::dom::workers::WorkerHolderToken;
+using mozilla::dom::workers::WorkerPrivate;
+
+namespace {
+
+uint32_t kBadThreadLocalIndex = -1;
+uint32_t sClientManagerThreadLocalIndex = kBadThreadLocalIndex;
+
+} // anonymous namespace
+
+class ClientManager::PBackgroundCreateCallback final : public nsIIPCBackgroundChildCreateCallback
+{
+  RefPtr<ClientManager> mManager;
+
+  ~PBackgroundCreateCallback()
+  {
+  }
+
+public:
+  explicit PBackgroundCreateCallback(ClientManager* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(mManager);
+  }
+
+  void
+  ActorCreated(PBackgroundChild* aActor) override
+  {
+    mManager->PBackgroundActorCreated(aActor);
+    mManager = nullptr;
+  }
+
+  void
+  ActorFailed() override
+  {
+    mManager->Shutdown();
+    mManager = nullptr;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ClientManager::PBackgroundCreateCallback,
+                  nsIIPCBackgroundChildCreateCallback);
+
+ClientManager::ClientManager()
+{
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    PBackgroundActorCreated(actor);
+    return;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+  RefPtr<PBackgroundCreateCallback> cb = new PBackgroundCreateCallback(this);
+  bool ok = BackgroundChild::GetOrCreateForCurrentThread(cb);
+  if (NS_WARN_IF(!ok)) {
+    Shutdown();
+  }
+}
+
+ClientManager::~ClientManager()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(mPendingSourceList.IsEmpty());
+  MOZ_ASSERT(mPendingHandleList.IsEmpty());
+
+  Shutdown();
+
+  MOZ_DIAGNOSTIC_ASSERT(this == PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+  PRStatus status =
+    PR_SetThreadPrivate(sClientManagerThreadLocalIndex, nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+}
+
+void
+ClientManager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (IsShutdown()) {
+    return;
+  }
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Shutdown();
+  }
+
+  nsTArray<ClientHandle*> pendingHandleList;
+  mPendingHandleList.SwapElements(pendingHandleList);
+  for (ClientHandle* handle : pendingHandleList) {
+    handle->Shutdown();
+  }
+
+  ShutdownThing();
+}
+
+UniquePtr<ClientSource>
+ClientManager::CreateSourceInternal(ClientType aType,
+                                    const PrincipalInfo& aPrincipal)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (IsShutdown()) {
+    return nullptr;
+  }
+
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> idGen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  nsID id;
+  rv = idGen->GenerateUUIDInPlace(&id);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+
+  ClientSourceConstructorArgs args(id, aType, aPrincipal, TimeStamp::Now());
+  UniquePtr<ClientSource> source(new ClientSource(this, args));
+
+  // TODO: Replace with MaybeExecute()?  How to handle error shutdown? How
+  //       to track UniquePtr<ClientSource>?
+  if (GetActor()) {
+    source->Activate(GetActor());
+  } else {
+    mPendingSourceList.AppendElement(source.get());
+  }
+
+  return Move(source);
+}
+
+already_AddRefed<ClientHandle>
+ClientManager::CreateHandleInternal(const ClientInfo& aClientInfo)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (IsShutdown()) {
+    return nullptr;
+  }
+
+  RefPtr<ClientHandle> handle = new ClientHandle(this, aClientInfo);
+
+  // TODO: Replace with MaybeExecute()?  How to handle error shutdown?
+  if (GetActor()) {
+    handle->Activate(GetActor());
+  } else {
+    mPendingHandleList.AppendElement(handle);
+  }
+
+  return handle.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientManager::StartOp(const ClientOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  // Hold a ref to the client until the remote operation completes.  Otherwise
+  // the ClientHandle might get de-refed and teardown the actor before we
+  // get an answer.
+  RefPtr<ClientManager> kungFuGrip = this;
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+                [kungFuGrip] (const ClientOpResult&) { },
+                [kungFuGrip] (nsresult) { });
+
+  MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
+    ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
+    if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
+      // Constructor failure will reject promise via ActorDestroy()
+      return;
+    }
+  });
+
+  RefPtr<ClientOpPromise> ref = promise.get();
+  return ref.forget();
+}
+
+void
+ClientManager::ForgetSource(ClientSource* aSource)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  mPendingSourceList.RemoveElement(aSource);
+}
+
+WorkerPrivate*
+ClientManager::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_DIAGNOSTIC_ASSERT(GetActor());
+  return GetActor()->GetWorkerPrivate();
+}
+
+void
+ClientManager::ForgetHandle(ClientHandle* aHandle)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  mPendingHandleList.RemoveElement(aHandle);
+}
+
+void
+ClientManager::PBackgroundActorCreated(PBackgroundChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(aActor);
+
+  if (IsShutdown()) {
+    return;
+  }
+
+  RefPtr<WorkerHolderToken> workerHolderToken;
+  if (!NS_IsMainThread()) {
+    workerHolderToken =
+      WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Terminating);
+    if (NS_WARN_IF(!workerHolderToken)) {
+      Shutdown();
+      return;
+    }
+  }
+
+  ClientManagerChild* actor = new ClientManagerChild(workerHolderToken);
+  PClientManagerChild *sentActor = aActor->SendPClientManagerConstructor(actor);
+  if (NS_WARN_IF(!sentActor)) {
+    Shutdown();
+    return;
+  }
+  MOZ_ASSERT(sentActor == actor);
+
+  ActivateThing(static_cast<ClientManagerChild*>(actor));
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Activate(GetActor());
+  }
+
+  nsTArray<ClientHandle*> pendingHandleList;
+  mPendingHandleList.SwapElements(pendingHandleList);
+  for (ClientHandle* handle : pendingHandleList) {
+    handle->Activate(GetActor());
+  }
+}
+
+// static
+void
+ClientManager::Startup()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  PRStatus status =
+    PR_NewThreadPrivateIndex(&sClientManagerThreadLocalIndex, nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+}
+
+// static
+already_AddRefed<ClientManager>
+ClientManager::GetOrCreateForCurrentThread()
+{
+  MOZ_DIAGNOSTIC_ASSERT(sClientManagerThreadLocalIndex != kBadThreadLocalIndex);
+  RefPtr<ClientManager> cm =
+    static_cast<ClientManager*>(PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+
+  if (!cm) {
+    cm = new ClientManager();
+
+    PRStatus status =
+      PR_SetThreadPrivate(sClientManagerThreadLocalIndex, cm.get());
+    MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+  }
+
+  MOZ_ASSERT(cm);
+  return cm.forget();
+}
+
+// static
+UniquePtr<ClientSource>
+ClientManager::CreateSource(ClientType aType, nsIPrincipal* aPrincipal)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(aPrincipal);
+
+  PrincipalInfo principalInfo;
+  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateSourceInternal(aType, principalInfo);
+}
+
+// static
+UniquePtr<ClientSource>
+ClientManager::CreateSource(ClientType aType, const PrincipalInfo& aPrincipal)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateSourceInternal(aType, aPrincipal);
+}
+
+// static
+already_AddRefed<ClientHandle>
+ClientManager::CreateHandle(const ClientInfo& aClientInfo)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateHandleInternal(aClientInfo);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::MatchAll(const ClientMatchAllArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Claim(const ClientClaimArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManager.h
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManager_h
+#define _mozilla_dom_ClientManager_h
+
+#include "mozilla/dom/PClientManager.h"
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/ClientThing.h"
+#include "nsTArray.h"
+
+class nsIPrincipal;
+class nsIURI;
+
+namespace mozilla {
+namespace ipc {
+class PBackgroundChild;
+class PrincipalInfo;
+} // namespace ipc
+namespace dom {
+
+class ClientHandle;
+class ClientManagerChild;
+class ClientSource;
+enum class ClientType : uint8_t;
+
+namespace workers {
+class WorkerPrivate;
+} // workers namespace
+
+class ClientManager final : public ClientThing<ClientManagerChild>
+{
+  friend class ClientHandle;
+  friend class ClientManagerChild;
+  friend class ClientSource;
+  class PBackgroundCreateCallback;
+
+  nsTArray<ClientSource*> mPendingSourceList;
+  nsTArray<ClientHandle*> mPendingHandleList;
+
+  ClientManager();
+  ~ClientManager();
+
+  void
+  Shutdown();
+
+  UniquePtr<ClientSource>
+  CreateSourceInternal(ClientType aType,
+                       const mozilla::ipc::PrincipalInfo& aPrincipal);
+
+  already_AddRefed<ClientHandle>
+  CreateHandleInternal(const ClientInfo& aClientInfo);
+
+  already_AddRefed<ClientOpPromise>
+  StartOp(const ClientOpConstructorArgs& aArgs);
+
+  void
+  PBackgroundActorCreated(mozilla::ipc::PBackgroundChild* aActor);
+
+  // Private methods called by ClientSource
+  void
+  ForgetSource(ClientSource* aSource);
+
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+
+  // Private methods calls by ClientHandle
+  void
+  ForgetHandle(ClientHandle* aHandle);
+
+public:
+  static void
+  Startup();
+
+  static already_AddRefed<ClientManager>
+  GetOrCreateForCurrentThread();
+
+  static UniquePtr<ClientSource>
+  CreateSource(ClientType aType, nsIPrincipal* aPrincipal);
+
+  static UniquePtr<ClientSource>
+  CreateSource(ClientType aType, const mozilla::ipc::PrincipalInfo& aPrincipal);
+
+  static already_AddRefed<ClientHandle>
+  CreateHandle(const ClientInfo& aClientInfo);
+
+  static already_AddRefed<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs);
+
+  static already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs);
+
+  static already_AddRefed<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+
+  static already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerActors.cpp b/dom/clients/manager/ClientManagerActors.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerActors.cpp
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+#include "ClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+PClientManagerChild*
+AllocClientManagerChild()
+{
+  MOZ_ASSERT_UNREACHABLE("Default ClientManagerChild allocator should not be invoked");
+  return nullptr;
+}
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientManagerParent*
+AllocClientManagerParent()
+{
+  return new ClientManagerParent();
+}
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerActors.h b/dom/clients/manager/ClientManagerActors.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerActors.h
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerActors_h
+#define _mozilla_dom_ClientManagerActors_h
+
+namespace mozilla {
+namespace dom {
+
+class PClientManagerChild;
+class PClientManagerParent;
+
+PClientManagerChild*
+AllocClientManagerChild();
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor);
+
+PClientManagerParent*
+AllocClientManagerParent();
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor);
+
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerActors_h
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -0,0 +1,152 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+
+#include "ClientHandleChild.h"
+#include "ClientManager.h"
+#include "ClientManagerOpChild.h"
+#include "ClientNavigateOpChild.h"
+#include "ClientSourceChild.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::WorkerHolderToken;
+using mozilla::dom::workers::WorkerPrivate;
+
+void
+ClientManagerChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->RemoveListener(this);
+    mWorkerHolderToken = nullptr;
+
+  }
+
+  if (mManager) {
+    mManager->RevokeActor(this);
+    MOZ_ASSERT(!mManager);
+  }
+}
+
+PClientHandleChild*
+ClientManagerChild::AllocPClientHandleChild(const ClientInfo& aClientInfo)
+{
+  return new ClientHandleChild(aClientInfo);
+}
+
+bool
+ClientManagerChild::DeallocPClientHandleChild(PClientHandleChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientManagerOpChild*
+ClientManagerChild::AllocPClientManagerOpChild(const ClientOpConstructorArgs& aArgs)
+{
+  MOZ_ASSERT_UNREACHABLE("ClientManagerOpChild must be explicitly constructed.");
+  return nullptr;
+}
+
+bool
+ClientManagerChild::DeallocPClientManagerOpChild(PClientManagerOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientNavigateOpChild*
+ClientManagerChild::AllocPClientNavigateOpChild(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  return new ClientNavigateOpChild();
+}
+
+bool
+ClientManagerChild::DeallocPClientNavigateOpChild(PClientNavigateOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+mozilla::ipc::IPCResult
+ClientManagerChild::RecvPClientNavigateOpConstructor(PClientNavigateOpChild* aActor,
+                                   const ClientNavigateOpConstructorArgs& aArgs)
+{
+  auto actor = static_cast<ClientNavigateOpChild*>(aActor);
+  actor->Init(aArgs);
+  return IPC_OK();
+}
+
+PClientSourceChild*
+ClientManagerChild::AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceChild(aArgs);
+}
+
+bool
+ClientManagerChild::DeallocPClientSourceChild(PClientSourceChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+void
+ClientManagerChild::WorkerShuttingDown()
+{
+  MaybeStartTeardown();
+}
+
+ClientManagerChild::ClientManagerChild(WorkerHolderToken* aWorkerHolderToken)
+  : mManager(nullptr)
+  , mWorkerHolderToken(aWorkerHolderToken)
+  , mTeardownStarted(false)
+{
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolderToken);
+
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->AddListener(this);
+  }
+}
+
+void
+ClientManagerChild::SetOwner(ClientThing<ClientManagerChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aThing);
+  MOZ_DIAGNOSTIC_ASSERT(!mManager);
+  mManager = static_cast<ClientManager*>(aThing);
+}
+
+void
+ClientManagerChild::RevokeOwner(ClientThing<ClientManagerChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager == static_cast<ClientManager*>(aThing));
+  mManager = nullptr;
+}
+
+void
+ClientManagerChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  SendTeardown();
+}
+
+WorkerPrivate*
+ClientManagerChild::GetWorkerPrivate() const
+{
+  if (!mWorkerHolderToken) {
+    return nullptr;
+  }
+  return mWorkerHolderToken->GetWorkerPrivate();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerChild.h b/dom/clients/manager/ClientManagerChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerChild.h
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerChild_h
+#define _mozilla_dom_ClientManagerChild_h
+
+#include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace workers {
+class WorkerPrivate;
+} // workers namespace
+
+class ClientManagerChild final : public PClientManagerChild
+                               , public mozilla::dom::workers::WorkerHolderToken::Listener
+{
+  // Weak reference.  The ClientManager will call RevokeManager() when
+  // it is destroyed.
+  ClientManager* mManager;
+
+  RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
+  bool mTeardownStarted;
+
+  // PClientManagerChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleChild*
+  AllocPClientHandleChild(const ClientInfo& aClientInfo) override;
+
+  bool
+  DeallocPClientHandleChild(PClientHandleChild* aActor) override;
+
+  PClientManagerOpChild*
+  AllocPClientManagerOpChild(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientManagerOpChild(PClientManagerOpChild* aActor) override;
+
+  PClientNavigateOpChild*
+  AllocPClientNavigateOpChild(const ClientNavigateOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientNavigateOpChild(PClientNavigateOpChild* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientNavigateOpConstructor(PClientNavigateOpChild* aActor,
+                                   const ClientNavigateOpConstructorArgs& aArgs) override;
+
+  PClientSourceChild*
+  AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceChild(PClientSourceChild* aActor) override;
+
+  // WorkerHolderToken::Listener interface
+  void
+  WorkerShuttingDown() override;
+
+public:
+  explicit ClientManagerChild(workers::WorkerHolderToken* aWorkerHolderToken);
+
+  void
+  SetOwner(ClientThing<ClientManagerChild>* aThing);
+
+  void
+  RevokeOwner(ClientThing<ClientManagerChild>* aThing);
+
+  void
+  MaybeStartTeardown();
+
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerChild_h
diff --git a/dom/clients/manager/ClientManagerOpChild.cpp b/dom/clients/manager/ClientManagerOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerOpChild.cpp
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerOpChild.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientManagerOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientManagerOpChild::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientManagerOpChild::ClientManagerOpChild(const ClientOpConstructorArgs& aArgs,
+                                           ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientManagerOpChild::~ClientManagerOpChild()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerOpChild.h b/dom/clients/manager/ClientManagerOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerOpChild.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerOpChild_h
+#define _mozilla_dom_ClientManagerOpChild_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientManagerOpChild.h"
+#include "mozilla/MozPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerOpChild final : public PClientManagerOpChild
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientManagerOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientManagerOpChild(const ClientOpConstructorArgs& aArgs,
+                       ClientOpPromise::Private* aPromise);
+
+  ~ClientManagerOpChild();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerOpChild_h
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -0,0 +1,81 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerOpParent.h"
+
+#include "ClientManagerService.h"
+
+namespace mozilla {
+namespace dom {
+
+template <typename Method, typename Args>
+void
+ClientManagerOpParent::DoServiceOp(Method aMethod, const Args& aArgs)
+{
+  RefPtr<ClientOpPromise> p = (mService->*aMethod)(aArgs);
+
+  // Capturing `this` is safe here because we disconnect the promise in
+  // ActorDestroy() which ensures neither lambda is called if the actor
+  // is destroyed before the source operation completes.
+  p->Then(mService->BackgroundThread(), __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientManagerOpParent::Send__delete__(this, aResult);
+    }, [this] (nsresult aRv) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientManagerOpParent::Send__delete__(this, aRv);
+    })->Track(mPromiseRequestHolder);
+}
+
+void
+ClientManagerOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+ClientManagerOpParent::ClientManagerOpParent(ClientManagerService* aService)
+  : mService(aService)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mService);
+}
+
+void
+ClientManagerOpParent::Init(const ClientOpConstructorArgs& aArgs)
+{
+  switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientNavigateArgs:
+    {
+      DoServiceOp(&ClientManagerService::Navigate,
+                  aArgs.get_ClientNavigateArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientMatchAllArgs:
+    {
+      DoServiceOp(&ClientManagerService::MatchAll,
+                  aArgs.get_ClientMatchAllArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientClaimArgs:
+    {
+      DoServiceOp(&ClientManagerService::Claim, aArgs.get_ClientClaimArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
+    {
+      DoServiceOp(&ClientManagerService::GetInfoAndState,
+                  aArgs.get_ClientGetInfoAndStateArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_ASSERT_UNREACHABLE("Unknown Client operation!");
+      break;
+    }
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerOpParent.h b/dom/clients/manager/ClientManagerOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerOpParent.h
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerOpParent_h
+#define _mozilla_dom_ClientManagerOpParent_h
+
+#include "mozilla/dom/PClientManagerOpParent.h"
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerService;
+
+class ClientManagerOpParent final : public PClientManagerOpParent
+{
+  RefPtr<ClientManagerService> mService;
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  template <typename Method, typename Args>
+  void
+  DoServiceOp(Method aMethod, const Args& aArgs);
+
+  // PClientManagerOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientManagerOpParent(ClientManagerService* aService);
+  ~ClientManagerOpParent() = default;
+
+  void
+  Init(const ClientOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerOpParent_h
diff --git a/dom/clients/manager/ClientManagerParent.cpp b/dom/clients/manager/ClientManagerParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerParent.cpp
@@ -0,0 +1,114 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerParent.h"
+
+#include "ClientHandleParent.h"
+#include "ClientManagerService.h"
+#include "ClientManagerOpParent.h"
+#include "ClientSourceParent.h"
+#include "mozilla/dom/PClientNavigateOpParent.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientManagerParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientManagerParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+PClientHandleParent*
+ClientManagerParent::AllocPClientHandleParent(const ClientInfo& aClientInfo)
+{
+  return new ClientHandleParent();
+}
+
+bool
+ClientManagerParent::DeallocPClientHandleParent(PClientHandleParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+IPCResult
+ClientManagerParent::RecvPClientHandleConstructor(PClientHandleParent* aActor,
+                                                  const ClientInfo& aClientInfo)
+{
+  ClientHandleParent* actor = static_cast<ClientHandleParent*>(aActor);
+  actor->Init(aClientInfo);
+  return IPC_OK();
+}
+
+PClientManagerOpParent*
+ClientManagerParent::AllocPClientManagerOpParent(const ClientOpConstructorArgs& aArgs)
+{
+  return new ClientManagerOpParent(mService);
+}
+
+bool
+ClientManagerParent::DeallocPClientManagerOpParent(PClientManagerOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+IPCResult
+ClientManagerParent::RecvPClientManagerOpConstructor(PClientManagerOpParent* aActor,
+                                                     const ClientOpConstructorArgs& aArgs)
+{
+  ClientManagerOpParent* actor = static_cast<ClientManagerOpParent*>(aActor);
+  actor->Init(aArgs);
+  return IPC_OK();
+}
+
+PClientNavigateOpParent*
+ClientManagerParent::AllocPClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  MOZ_ASSERT_UNREACHABLE("ClientNavigateOpParent should be explicitly constructed.");
+  return nullptr;
+}
+
+bool
+ClientManagerParent::DeallocPClientNavigateOpParent(PClientNavigateOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientSourceParent*
+ClientManagerParent::AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceParent(aArgs);
+}
+
+bool
+ClientManagerParent::DeallocPClientSourceParent(PClientSourceParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+ClientManagerParent::ClientManagerParent()
+  : mService(ClientManagerService::GetOrCreateInstance())
+{
+}
+
+ClientManagerParent::~ClientManagerParent()
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerParent.h b/dom/clients/manager/ClientManagerParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerParent.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerParent_h
+#define _mozilla_dom_ClientManagerParent_h
+
+#include "mozilla/dom/PClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerService;
+
+class ClientManagerParent final : public PClientManagerParent
+{
+  RefPtr<ClientManagerService> mService;
+
+  // PClientManagerParent interface
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleParent*
+  AllocPClientHandleParent(const ClientInfo& aClientInfo) override;
+
+  bool
+  DeallocPClientHandleParent(PClientHandleParent* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientHandleConstructor(PClientHandleParent* aActor,
+                               const ClientInfo& aClientInfo) override;
+
+  PClientManagerOpParent*
+  AllocPClientManagerOpParent(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientManagerOpParent(PClientManagerOpParent* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientManagerOpConstructor(PClientManagerOpParent* aActor,
+                                 const ClientOpConstructorArgs& aArgs) override;
+
+  PClientNavigateOpParent*
+  AllocPClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientNavigateOpParent(PClientNavigateOpParent* aActor) override;
+
+  PClientSourceParent*
+  AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceParent(PClientSourceParent* aActor) override;
+
+public:
+  ClientManagerParent();
+  ~ClientManagerParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerParent_h
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -0,0 +1,419 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerService.h"
+
+#include "ClientNavigateOpParent.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsURLParsers.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::AssertIsOnBackgroundThread;
+using mozilla::ipc::ContentPrincipalInfo;
+
+namespace {
+
+ClientManagerService* sClientManagerServiceInstance = nullptr;
+
+bool
+OriginFromSpec(const nsCString& aSpec, nsACString& aOriginOut)
+{
+  nsCOMPtr<nsIURLParser> parser = new nsStdURLParser();
+  uint32_t schemePos;
+  int32_t schemeLen;
+  uint32_t authPos;
+  int32_t authLen;
+  nsresult rv = parser->ParseURL(aSpec.get(), aSpec.Length(),
+                                 &schemePos, &schemeLen,
+                                 &authPos, &authLen,
+                                 nullptr, nullptr);
+  NS_ENSURE_SUCCESS(rv, false);
+
+  if (schemeLen > 0) {
+    aOriginOut = nsDependentCSubstring(aSpec.get() + schemePos, schemeLen);
+  }
+  if (authLen > 0) {
+    aOriginOut += nsDependentCSubstring(aSpec.get() + authPos, authLen);
+  }
+
+  return true;
+}
+
+bool
+IsSameOrigin(const nsCString& aLeft, const nsCString& aRight)
+{
+  nsAutoCString leftOrigin;
+  nsAutoCString rightOrigin;
+
+  // TODO: replace this with originNoSuffix when implemented in bug 1340163
+  return OriginFromSpec(aLeft, leftOrigin) &&
+         OriginFromSpec(aRight, rightOrigin) &&
+         leftOrigin == rightOrigin;
+}
+
+bool
+MatchPrincipalInfo(const PrincipalInfo& aLeft, const PrincipalInfo& aRight)
+{
+  if (aLeft.type() != aRight.type()) {
+    return false;
+  }
+
+  switch (aLeft.type()) {
+    case PrincipalInfo::TContentPrincipalInfo:
+    {
+      const ContentPrincipalInfo& leftContent = aLeft.get_ContentPrincipalInfo();
+      const ContentPrincipalInfo& rightContent = aRight.get_ContentPrincipalInfo();
+      return leftContent.attrs() == rightContent.attrs() &&
+             IsSameOrigin(leftContent.spec(), rightContent.spec());
+    }
+    case PrincipalInfo::TSystemPrincipalInfo:
+    {
+      // system principal always matches
+      return true;
+    }
+    case PrincipalInfo::TNullPrincipalInfo:
+    {
+      // null principal never matches
+      return false;
+    }
+    default:
+    {
+      break;
+    }
+  }
+
+  // TODO: figure out how expanded principal should work
+  MOZ_CRASH("unexpected principal type!");
+}
+
+} // anonymous namespace
+
+ClientManagerService::ClientManagerService()
+ : mBackgroundThread(AbstractThread::CreateXPCOMThreadWrapper(NS_GetCurrentThread(), false))
+{
+  AssertIsOnBackgroundThread();
+}
+
+ClientManagerService::~ClientManagerService()
+{
+  AssertIsOnBackgroundThread();
+  MOZ_DIAGNOSTIC_ASSERT(mSourceList.IsEmpty());
+
+  MOZ_DIAGNOSTIC_ASSERT(sClientManagerServiceInstance == this);
+  sClientManagerServiceInstance = nullptr;
+}
+
+// static
+already_AddRefed<ClientManagerService>
+ClientManagerService::GetOrCreateInstance()
+{
+  AssertIsOnBackgroundThread();
+
+  if (!sClientManagerServiceInstance) {
+    sClientManagerServiceInstance = new ClientManagerService();
+  }
+
+  RefPtr<ClientManagerService> ref(sClientManagerServiceInstance);
+  return ref.forget();
+}
+
+AbstractThread*
+ClientManagerService::BackgroundThread() const
+{
+  return mBackgroundThread;
+}
+
+void
+ClientManagerService::AddSource(ClientSourceParent* aSource)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aSource);
+  MOZ_ASSERT(!mSourceList.Contains(aSource));
+  mSourceList.AppendElement(aSource);
+}
+
+void
+ClientManagerService::RemoveSource(ClientSourceParent* aSource)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aSource);
+  MOZ_ALWAYS_TRUE(mSourceList.RemoveElement(aSource));
+}
+
+ClientSourceParent*
+ClientManagerService::FindSource(const nsID& aID, const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+  for (ClientSourceParent* source : mSourceList) {
+    MOZ_DIAGNOSTIC_ASSERT(source);
+    if (!source->IsFrozen() &&
+        source->Info().id() == aID &&
+        MatchPrincipalInfo(source->Info().principalInfo(), aPrincipalInfo)) {
+      return source;
+    }
+  }
+  return nullptr;
+}
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.target().id(),
+                                          aArgs.target().principalInfo());
+  if (!source) {
+    // TODO: it would be really nice to specify a useful type error message here
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  PClientManagerParent* manager = source->Manager();
+  MOZ_DIAGNOSTIC_ASSERT(manager);
+
+  ClientNavigateOpConstructorArgs args;
+  args.url() = aArgs.url();
+  args.baseURL() = aArgs.baseURL();
+
+  // This is safe to do because the ClientSourceChild cannot directly delete
+  // itself.  Instead it sends a Teardown message to the parent which then
+  // calls delete.  That means we can be sure that we are not racing with
+  // source destruction here.
+  args.targetParent() = source;
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  ClientNavigateOpParent* op = new ClientNavigateOpParent(args, promise);
+  PClientNavigateOpParent* result =
+    manager->SendPClientNavigateOpConstructor(op, args);
+  if (!result) {
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise;
+  return ref.forget();
+}
+
+namespace
+{
+
+class PromiseListHolder final
+{
+  RefPtr<AbstractThread> mTarget;
+  RefPtr<ClientOpPromise::Private> mResultPromise;
+  nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
+  nsTArray<ClientInfoAndState> mResultList;
+  uint32_t mOutstandingPromiseCount;
+
+  void
+  ProcessSuccess(const ClientInfoAndState& aResult)
+  {
+    mResultList.AppendElement(aResult);
+    ProcessCompletion();
+  }
+
+  void
+  ProcessCompletion()
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mOutstandingPromiseCount > 0);
+    mOutstandingPromiseCount -= 1;
+    MaybeFinish();
+  }
+
+  ~PromiseListHolder() = default;
+public:
+  explicit PromiseListHolder(AbstractThread* aTarget)
+    : mTarget(aTarget)
+    , mResultPromise(new ClientOpPromise::Private(__func__))
+    , mOutstandingPromiseCount(0)
+  {
+  }
+
+  already_AddRefed<ClientOpPromise>
+  GetResultPromise()
+  {
+    RefPtr<PromiseListHolder> kungFuDeathGrip = this;
+    mResultPromise->Then(AbstractThread::GetCurrent(), __func__,
+      [kungFuDeathGrip] (const ClientOpResult& aResult) { },
+      [kungFuDeathGrip] (nsresult aResult) { });
+
+    RefPtr<ClientOpPromise> ref = mResultPromise;
+    return ref.forget();
+  }
+
+  void
+  AddPromise(already_AddRefed<ClientOpPromise> aPromise)
+  {
+    mPromiseList.AppendElement(aPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mPromiseList.LastElement());
+    mOutstandingPromiseCount += 1;
+
+    RefPtr<PromiseListHolder> self(this);
+    mPromiseList.LastElement()->Then(mTarget, __func__,
+      [self] (const ClientOpResult& aResult) {
+        // TODO: This is pretty clunky.  Try to figure out a better
+        //       wait for MatchAll() and Claim() to share this code
+        //       even though they expect different return values.
+        if (aResult.type() == ClientOpResult::TClientInfoAndState) {
+          self->ProcessSuccess(aResult.get_ClientInfoAndState());
+        } else {
+          self->ProcessCompletion();
+        }
+      }, [self] (nsresult aResult) {
+        self->ProcessCompletion();
+      });
+  }
+
+  void
+  MaybeFinish()
+  {
+    if (!mOutstandingPromiseCount) {
+      mResultPromise->Resolve(mResultList, __func__);
+    }
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(PromiseListHolder)
+};
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::MatchAll(const ClientMatchAllArgs& aArgs)
+{
+  AssertIsOnBackgroundThread();
+
+  const ClientEndPoint& endpoint = aArgs.endpoint();
+
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TClientInfo
+      ? endpoint.get_ClientInfo().principalInfo()
+      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+
+  RefPtr<PromiseListHolder> promiseList =
+    new PromiseListHolder(mBackgroundThread);
+
+  for (ClientSourceParent* source : mSourceList) {
+    MOZ_DIAGNOSTIC_ASSERT(source);
+
+    if (source->IsFrozen()) {
+      continue;
+    }
+
+    if (!MatchPrincipalInfo(source->Info().principalInfo(), principalInfo)) {
+      continue;
+    }
+
+    if (aArgs.type() != ClientType::All &&
+        source->Info().type() != aArgs.type()) {
+      continue;
+    }
+
+    if (!aArgs.includeUncontrolled()) {
+      if (endpoint.type() != ClientEndPoint::TServiceWorkerDescriptor) {
+        continue;
+      }
+
+
+      const Maybe<ServiceWorkerDescriptor>& controller =
+        source->GetController();
+      if (controller.isNothing()) {
+        continue;
+      }
+
+      const ServiceWorkerDescriptor serviceWorker =
+        endpoint.get_ServiceWorkerDescriptor();
+
+      if(controller.ref().id() != serviceWorker.id() ||
+         controller.ref().scope() != serviceWorker.scope()) {
+        continue;
+      }
+    }
+
+    if (!aArgs.includeReserved() && !source->ExecutionReady()) {
+      continue;
+    }
+
+    promiseList->AddPromise(
+      source->StartOp(ClientGetInfoAndStateArgs(source->Info().id(),
+                                                source->Info().principalInfo())));
+  }
+
+  // Maybe finish the promise now in case we didn't find any matching clients.
+  promiseList->MaybeFinish();
+
+  return promiseList->GetResultPromise();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::Claim(const ClientClaimArgs& aArgs)
+{
+  AssertIsOnBackgroundThread();
+
+  const ServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
+  const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
+
+  RefPtr<PromiseListHolder> promiseList =
+    new PromiseListHolder(mBackgroundThread);
+
+  for (ClientSourceParent* source : mSourceList) {
+    MOZ_DIAGNOSTIC_ASSERT(source);
+
+    if (source->IsFrozen()) {
+      continue;
+    }
+
+    if (!MatchPrincipalInfo(source->Info().principalInfo(), principalInfo)) {
+      continue;
+    }
+
+    const Maybe<ServiceWorkerDescriptor>& controller = source->GetController();
+    if (controller.isSome() &&
+        controller.ref().scope() == serviceWorker.scope() &&
+        controller.ref().id() == serviceWorker.id()) {
+      continue;
+    }
+
+    // TODO: This logic to determine if a service worker should control
+    //       a particular client should be moved to the ServiceWorkerManager.
+    //       This can't happen until the SWM is moved to the parent process,
+    //       though.
+    if (!source->ExecutionReady() ||
+        source->Info().type() == ClientType::Serviceworker ||
+        source->Info().url().Find(serviceWorker.scope()) != 0) {
+      continue;
+    }
+
+    promiseList->AddPromise(source->StartOp(aArgs));
+  }
+
+  // Maybe finish the promise now in case we didn't find any matching clients.
+  promiseList->MaybeFinish();
+
+  return promiseList->GetResultPromise();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.id(), aArgs.principalInfo());
+  if (!source) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  // TODO: maybe change this to just GetState from source and use local info?
+  return source->StartOp(aArgs);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerService.h
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerService_h
+#define _mozilla_dom_ClientManagerService_h
+
+#include "nsTArray.h"
+
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+
+namespace ipc {
+class PrincipalInfo;
+}
+
+namespace dom {
+
+class ClientSourceParent;
+
+class ClientManagerService final
+{
+  RefPtr<AbstractThread> mBackgroundThread;
+
+  // TODO: break this up by principal/id?
+  // TODO: use something that is not O(n) on clients
+  nsTArray<ClientSourceParent*> mSourceList;
+
+  ClientManagerService();
+  ~ClientManagerService();
+
+public:
+  static already_AddRefed<ClientManagerService>
+  GetOrCreateInstance();
+
+  AbstractThread*
+  BackgroundThread() const;
+
+  void
+  AddSource(ClientSourceParent* aSource);
+
+  void
+  RemoveSource(ClientSourceParent* aSource);
+
+  ClientSourceParent*
+  FindSource(const nsID& aID,
+             const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
+
+  already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManagerService)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerService_h
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -0,0 +1,266 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientNavigateOpChild.h"
+
+#include "mozilla/Unused.h"
+#include "nsGlobalWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellLoadInfo.h"
+#include "nsIWebNavigation.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class NavigateLoadListener final : public nsIWebProgressListener
+                                 , public nsSupportsWeakReference
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  RefPtr<nsPIDOMWindowOuter> mOuterWindow;
+  nsCOMPtr<nsIURI> mBaseURL;
+
+  ~NavigateLoadListener() = default;
+
+public:
+  NavigateLoadListener(ClientOpPromise::Private* aPromise,
+                       nsPIDOMWindowOuter* aOuterWindow,
+                       nsIURI* aBaseURL)
+    : mPromise(aPromise)
+    , mOuterWindow(aOuterWindow)
+    , mBaseURL(aBaseURL)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mOuterWindow);
+    MOZ_DIAGNOSTIC_ASSERT(mBaseURL);
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aResult) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+        !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
+    if (!channel) {
+      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIURI> channelURL;
+    nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
+    if (NS_FAILED(rv)) {
+      mPromise->Reject(rv, __func__);
+      return NS_OK;
+    }
+
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_DIAGNOSTIC_ASSERT(ssm);
+    rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      return NS_OK;
+    }
+
+    // TODO: legacy code only did this for same-origin, was that intentional
+    Unused << nsContentUtils::DispatchFocusChromeEvent(mOuterWindow);
+
+    // TODO: Not clear this progress listener guarantees following assertions...
+
+    nsPIDOMWindowInner* innerWindow = mOuterWindow->GetCurrentInnerWindow();
+    MOZ_DIAGNOSTIC_ASSERT(innerWindow);
+
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
+
+    Maybe<ClientState> clientState = innerWindow->GetClientState();
+    MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
+
+    mPromise->Resolve(ClientInfoAndState(clientInfo.ref(), clientState.ref()),
+                      __func__);
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   nsIURI* aLocation, uint32_t aFlags) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(NavigateLoadListener, nsIWebProgressListener,
+                                        nsISupportsWeakReference);
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientNavigateOpChild::DoNavigate(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceChild* targetActor =
+    static_cast<ClientSourceChild*>(aArgs.targetChild());
+  MOZ_DIAGNOSTIC_ASSERT(targetActor);
+
+  ClientSource* target = targetActor->GetSource();
+  if (!target) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  nsPIDOMWindowInner* window = target->GetInnerWindow();
+  if (!window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // In theory we could do the URL work before paying the IPC overhead
+  // cost, but in practice its easier to do it here.  The ClientHandle
+  // may be off-main-thread while this method is guaranteed to always
+  // be main thread.
+  nsCOMPtr<nsIURI> baseURL;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIURI> url;
+  rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  if (url->GetSpecOrDefault().EqualsLiteral("about:blank")) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+  if (!doc || !doc->IsActive()) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (!principal) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+  if (!docShell || !webProgress) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
+  rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  loadInfo->SetTriggeringPrincipal(principal);
+  loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
+  loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContent);
+  loadInfo->SetSourceDocShell(docShell);
+  rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  nsCOMPtr<nsIWebProgressListener> listener =
+    new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_FAILED(rv)) {
+    promise->Reject(rv, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise.get();
+
+  ref->Then(AbstractThread::GetCurrent(), __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+
+  return ref.forget();
+}
+
+void
+ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+void
+ClientNavigateOpChild::Init(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> promise = DoNavigate(aArgs);
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpChild.h b/dom/clients/manager/ClientNavigateOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpChild.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientNavigateOpChild_h
+#define _mozilla_dom_ClientNavigateOpChild_h
+
+#include "mozilla/dom/PClientNavigateOpChild.h"
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+
+class ClientNavigateOpChild final : public PClientNavigateOpChild
+{
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  already_AddRefed<ClientOpPromise>
+  DoNavigate(const ClientNavigateOpConstructorArgs& aArgs);
+
+  // PClientNavigateOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  ClientNavigateOpChild() = default;
+  ~ClientNavigateOpChild() = default;
+
+  void
+  Init(const ClientNavigateOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientNavigateOpChild_h
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientNavigateOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+void
+ClientNavigateOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientNavigateOpParent::ClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs,
+                                               ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientNavigateOpParent::~ClientNavigateOpParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpParent.h b/dom/clients/manager/ClientNavigateOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpParent.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientNavigateOpParent_h
+#define _mozilla_dom_ClientNavigateOpParent_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientNavigateOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientNavigateOpParent final : public PClientNavigateOpParent
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientNavigateOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs,
+                         ClientOpPromise::Private* aPromise);
+
+  ~ClientNavigateOpParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientNavigateOpParent_h
diff --git a/dom/clients/manager/ClientOpPromise.h b/dom/clients/manager/ClientOpPromise.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpPromise.h
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpPromise_h
+#define _mozilla_dom_ClientOpPromise_h
+
+#include "mozilla/MozPromise.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+typedef MozPromise<ClientOpResult, nsresult, false> ClientOpPromise;
+
+typedef MozPromise<ClientState, nsresult, false> ClientStatePromise;
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpPromise_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSource.cpp
@@ -0,0 +1,566 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSource.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+#include "mozilla/dom/MessageEvent.h"
+#include "mozilla/dom/MessageEventBinding.h"
+#include "mozilla/dom/Navigator.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/WorkerScope.h"
+#include "mozilla/dom/ServiceWorkerContainer.h"
+#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/workers/bindings/ServiceWorker.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::ipc::StructuredCloneData;
+using mozilla::dom::workers::ServiceWorkerInfo;
+using mozilla::dom::workers::ServiceWorkerManager;
+using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
+using mozilla::dom::workers::WorkerPrivate;
+
+void
+ClientSource::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (IsShutdown()) {
+    return;
+  }
+
+  ShutdownThing();
+
+  mManager->ForgetSource(this);
+  mManager = nullptr;
+}
+
+void
+ClientSource::ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
+{
+  // TODO: delivered queued messages
+  mClientInfo.url() = aArgs.url();
+  mClientInfo.frameType() = aArgs.frameType();
+  MaybeExecute([aArgs](PClientSourceChild* aActor) {
+    aActor->SendExecutionReady(aArgs);
+  });
+}
+
+nsresult
+ClientSource::SnapshotWindowState(ClientWindowState* aStateOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (!window || !window->IsCurrentInnerWindow() ||
+      !window->HasActiveDocument()) {
+    aStateOut->focused() = false;
+    aStateOut->lastFocusTime() = TimeStamp();
+    aStateOut->visibilityState() = VisibilityState::Hidden;
+    return NS_OK;
+  }
+
+  nsIDocument* doc = window->GetExtantDoc();
+  if (NS_WARN_IF(!doc)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  ErrorResult rv;
+  aStateOut->focused() = doc->HasFocus(rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    rv.SuppressException();
+    return rv.StealNSResult();
+  }
+
+  aStateOut->lastFocusTime() = doc->LastFocusTime();
+  aStateOut->visibilityState() = doc->VisibilityState();
+
+  return NS_OK;
+}
+
+ClientSource::ClientSource(ClientManager* aManager,
+                           const ClientSourceConstructorArgs& aArgs)
+  : mManager(aManager)
+  , mOwner(void_t())
+  , mArgs(aArgs)
+  , mClientInfo(mArgs.id(), mArgs.type(), mArgs.principalInfo(), mArgs.creationTime(),
+                EmptyCString(), FrameType::None)
+{
+  MOZ_ASSERT(mManager);
+}
+
+void
+ClientSource::Activate(PClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_ASSERT(!GetActor());
+
+  if (IsShutdown()) {
+    return;
+  }
+
+  PClientSourceChild* actor = aActor->SendPClientSourceConstructor(mArgs);
+  if (!actor) {
+    Shutdown();
+    return;
+  }
+
+  ActivateThing(static_cast<ClientSourceChild*>(actor));
+  MaybeExecuteTaskList();
+}
+
+ClientSource::~ClientSource()
+{
+  Shutdown();
+}
+
+nsPIDOMWindowInner*
+ClientSource::GetInnerWindow() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
+    return nullptr;
+  }
+  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
+}
+
+WorkerPrivate*
+ClientSource::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<WorkerPrivate*>()) {
+    return nullptr;
+  }
+  return mOwner.as<WorkerPrivate*>();
+}
+
+void
+ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  // Its safe to store the WorkerPrivate* here because the ClientSource
+  // is explicitly destroyed by WorkerPrivate before exiting its run loop.
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<void_t>());
+  mOwner = AsVariant(aWorkerPrivate);
+
+  ClientSourceExecutionReadyArgs args(
+    aWorkerPrivate->GetLocationInfo().mHref,
+    FrameType::None);
+
+  ExecutionReady(args);
+}
+
+nsresult
+ClientSource::WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow);
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->IsCurrentInnerWindow());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->HasActiveDocument());
+
+  nsIDocument* doc = aInnerWindow->GetExtantDoc();
+  if (NS_WARN_IF(!doc)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  nsCString spec;
+
+  nsIURI* uri = doc->GetOriginalURI();
+  if (uri) {
+    nsresult rv = uri->GetSpec(spec);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+  }
+
+  nsPIDOMWindowOuter* outer = aInnerWindow->GetOuterWindow();
+  if (NS_WARN_IF(!outer)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  FrameType frameType = FrameType::Top_level;
+  if (!outer->IsTopLevelWindow()) {
+    frameType = FrameType::Nested;
+  } else if(outer->HadOriginalOpener()) {
+    frameType = FrameType::Auxiliary;
+  }
+
+  ClientSourceExecutionReadyArgs args(spec, frameType);
+  ExecutionReady(args);
+
+  // We should either be setting a window execution ready for the
+  // first time or setting the same window execution ready again.
+  // The secondary calls are due to initial about:blank replacement.
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<void_t>() ||
+                        GetInnerWindow() == aInnerWindow);
+
+  // This creates a cycle with the window.  It is broken when
+  // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
+  mOwner = AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow));
+
+  return NS_OK;
+}
+
+void
+ClientSource::Freeze()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendFreeze();
+  });
+}
+
+void
+ClientSource::Thaw()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendThaw();
+  });
+}
+
+const ClientInfo&
+ClientSource::Info() const
+{
+  return mClientInfo;
+}
+
+void
+ClientSource::WorkerSyncPing(WorkerPrivate* aWorkerPrivate)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate == mManager->GetWorkerPrivate());
+  aWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(GetActor());
+  GetActor()->SendWorkerSyncPing();
+}
+
+void
+ClientSource::SetController(const ServiceWorkerDescriptor& aServiceWorker)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+
+  if (mController.isSome() && mController.ref() == aServiceWorker) {
+    return;
+  }
+
+  mController.reset();
+  mController.emplace(aServiceWorker);
+
+  RefPtr<ServiceWorkerContainer> swc;
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (window) {
+    RefPtr<Navigator> navigator =
+      static_cast<Navigator*>(window->GetNavigator());
+    if (navigator) {
+      swc = navigator->ServiceWorker();
+    }
+  }
+
+  // TODO: Also self.navigator.serviceWorker on workers when its exposed there
+
+  if (swc) {
+    IgnoredErrorResult ignored;
+    swc->ControllerChanged(ignored);
+  }
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::Control(const ClientControlledArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+
+  SetController(aArgs.serviceWorker());
+
+  RefPtr<ClientOpPromise> ref =
+    ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  return ref.forget();;
+}
+
+const Maybe<ServiceWorkerDescriptor>&
+ClientSource::GetController() const
+{
+  return mController;
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::Focus(const ClientFocusArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+
+  RefPtr<ClientOpPromise> ref;
+
+  if (mArgs.type() != ClientType::Window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (!window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv =
+    nsContentUtils::DispatchFocusChromeEvent(window->GetOuterWindow());
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ClientState state;
+  rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(state, __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  RefPtr<ClientOpPromise> ref;
+
+  const ClientEndPoint& endpoint = aArgs.endpoint();
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TClientInfo
+      ? endpoint.get_ClientInfo().principalInfo()
+      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+
+  // TODO: this should probably not require strict spec matching
+  if (false && !(mClientInfo.principalInfo() == principalInfo)) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  StructuredCloneData clonedData;
+  clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
+
+  RefPtr<ServiceWorkerContainer> target;
+  nsCOMPtr<nsIGlobalObject> globalObject;
+  if (mClientInfo.type() == ClientType::Window) {
+    MOZ_ASSERT(NS_IsMainThread());
+    nsPIDOMWindowInner* window = GetInnerWindow();
+    if (window) {
+      globalObject = nsGlobalWindow::Cast(window);
+      RefPtr<Navigator> navigator =
+        static_cast<Navigator*>(window->GetNavigator());
+      if (navigator) {
+        target = navigator->ServiceWorker();
+      }
+    }
+  } else {
+    WorkerPrivate* wp = GetWorkerPrivate();
+    if (wp) {
+      wp->AssertIsOnWorkerThread();
+      JSContext* cx = wp->GetJSContext();
+      if (cx) {
+        JSObject* global = JS::CurrentGlobalOrNull(cx);
+        if (global) {
+          globalObject = xpc::NativeGlobal(global);
+        } else {
+          globalObject = wp->GlobalScope();
+        }
+      }
+      // TODO: Set target to self.navigator.serviceWorker on workers when its exposed there
+    }
+  }
+
+  if (!target) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_NOT_IMPLEMENTED, __func__);
+    return ref.forget();
+  }
+
+  // If AutoJSAPI::Init() fails then either global is nullptr or not
+  // in a usable state.  Treat this as a postMessage() before ExecutionReady
+  // and just queue the message.  We will deliver the messages later
+  // when the Client is marked ExecutionReady.
+  AutoJSAPI jsapi;
+  if (!jsapi.Init(globalObject)) {
+    // TODO: queue messages until ExecutionReady
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  JSContext* cx = jsapi.cx();
+
+  ErrorResult result;
+  JS::Rooted<JS::Value> messageData(cx);
+  clonedData.Read(cx, &messageData, result);
+  if (result.MaybeSetPendingException(cx)) {
+    // We reported the error in the current window context.  Resolve
+    // promise instead of rejecting.
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  RootedDictionary<MessageEventInit> init(cx);
+
+  init.mData = messageData;
+  if (!clonedData.TakeTransferredPortsAsSequence(init.mPorts)) {
+    // Report the error in the current window context and resolve the
+    // promise instead of rejecting.
+    xpc::Throw(cx, NS_ERROR_OUT_OF_MEMORY);
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  // Currently we only support firing these messages on window Clients.
+  // Once we expose ServiceWorkerContainer and the ServiceWorker on Worker
+  // threads then this will need to change.
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(principalInfo, &rv);
+  if (NS_FAILED(rv) || !principal) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  nsAutoCString origin;
+  rv = principal->GetOriginNoSuffix(origin);
+  if (NS_SUCCEEDED(rv)) {
+    CopyUTF8toUTF16(origin, init.mOrigin);
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    // Shutting down. Just don't deliver this message.
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
+    const ServiceWorkerDescriptor& swd = endpoint.get_ServiceWorkerDescriptor();
+    RefPtr<ServiceWorkerRegistrationInfo> reg =
+      swm->GetRegistration(principal, swd.scope());
+    if (reg) {
+      RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(swd.id());
+      if (serviceWorker) {
+        init.mSource.SetValue().SetAsServiceWorker() =
+          serviceWorker->GetOrCreateInstance(GetInnerWindow());
+      }
+    }
+  }
+
+  // Eventually we should expose Client in MessageEvent.source.
+
+  RefPtr<MessageEvent> event =
+    MessageEvent::Constructor(target, NS_LITERAL_STRING("message"), init);
+  event->SetTrusted(true);
+
+  bool status = false;
+  target->DispatchEvent(static_cast<dom::Event*>(event.get()), &status);
+  if (!status) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::GetState(const ClientGetStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientState state;
+  nsresult rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(state, __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::Claim(const ClientClaimArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  // Today the ServiceWorkerManager maintains its own list of
+  // nsIDocument objects controlled by each service worker.  We
+  // need to try to update that data structure for now.  If we
+  // can't, however, then simply mark the Client as controlled.
+  // In the future this will be enough for the SWM as well since
+  // it will eventually hold ClientHandle objects instead of
+  // nsIDocuments.
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  nsPIDOMWindowInner* innerWindow = GetInnerWindow();
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+  if (!swm || !doc) {
+    SetController(aArgs.serviceWorker());
+
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> outerPromise =
+    new ClientOpPromise::Private(__func__);
+
+  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, aArgs.serviceWorker());
+  p->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise] (bool aResult) {
+      outerPromise->Resolve(NS_OK, __func__);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->Reject(aResult, __func__);
+    });
+
+  ref = outerPromise;
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientState state;
+  nsresult rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo, state),
+                                          __func__);
+  return ref.forget();
+}
+
+nsresult
+ClientSource::SnapshotState(ClientState* aStateOut)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(aStateOut);
+
+  // TODO: Handle state on reserved client where no window/workerprivate yet.
+
+  if (mArgs.type() == ClientType::Window) {
+    *aStateOut = ClientWindowState();
+    return SnapshotWindowState(&aStateOut->get_ClientWindowState());
+  }
+
+  *aStateOut = ClientWorkerState();
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSource.h
@@ -0,0 +1,120 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSource_h
+#define _mozilla_dom_ClientSource_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientThing.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/Variant.h"
+#include "ClientOpPromise.h"
+
+class nsPIDOMWindowInner;
+
+namespace mozilla {
+namespace dom {
+
+class ClientManager;
+class ClientSourceChild;
+class ClientSourceExecutionReadyArgs;
+class PClientManagerChild;
+
+namespace workers {
+class WorkerPrivate;
+} // workers namespace
+
+class ClientSource final : public ClientThing<ClientSourceChild>
+{
+  friend class ClientManager;
+  friend class ClientSourceChild;
+
+  NS_DECL_OWNINGTHREAD
+
+  RefPtr<ClientManager> mManager;
+
+  Variant<void_t,
+          RefPtr<nsPIDOMWindowInner>,
+          mozilla::dom::workers::WorkerPrivate*> mOwner;
+
+  const ClientSourceConstructorArgs mArgs;
+  ClientInfo mClientInfo;
+  Maybe<ServiceWorkerDescriptor> mController;
+
+  void
+  Shutdown();
+
+  void
+  ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
+
+  nsresult
+  SnapshotWindowState(ClientWindowState* aStateOut);
+
+  // Private methods called by ClientManager
+  ClientSource(ClientManager* aManager,
+               const ClientSourceConstructorArgs& aArgs);
+
+  void
+  Activate(PClientManagerChild* aActor);
+
+public:
+  ~ClientSource();
+
+  nsPIDOMWindowInner*
+  GetInnerWindow() const;
+
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+
+  void
+  WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
+
+  nsresult
+  WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
+
+  void
+  Freeze();
+
+  void
+  Thaw();
+
+  const ClientInfo&
+  Info() const;
+
+  void
+  WorkerSyncPing(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
+
+  void
+  SetController(const ServiceWorkerDescriptor& aServiceWorker);
+
+  already_AddRefed<ClientOpPromise>
+  Control(const ClientControlledArgs& aArgs);
+
+  const Maybe<ServiceWorkerDescriptor>&
+  GetController() const;
+
+  already_AddRefed<ClientOpPromise>
+  Focus(const ClientFocusArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  PostMessage(const ClientPostMessageArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  GetState(const ClientGetStateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+
+  nsresult
+  SnapshotState(ClientState* aStateOut);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSource_h
diff --git a/dom/clients/manager/ClientSourceChild.cpp b/dom/clients/manager/ClientSourceChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceChild.cpp
@@ -0,0 +1,85 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceChild.h"
+
+#include "ClientSourceOpChild.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientSourceChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mSource) {
+    mSource->RevokeActor(this);
+    MOZ_ASSERT(!mSource);
+  }
+}
+
+PClientSourceOpChild*
+ClientSourceChild::AllocPClientSourceOpChild(const ClientOpConstructorArgs& aArgs)
+{
+  return new ClientSourceOpChild();
+}
+
+bool
+ClientSourceChild::DeallocPClientSourceOpChild(PClientSourceOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+IPCResult
+ClientSourceChild::RecvPClientSourceOpConstructor(PClientSourceOpChild* aActor,
+                                                  const ClientOpConstructorArgs& aArgs)
+{
+  auto actor = static_cast<ClientSourceOpChild*>(aActor);
+  actor->Init(aArgs);
+  return IPC_OK();
+}
+
+ClientSourceChild::ClientSourceChild(const ClientSourceConstructorArgs& aArgs)
+  : mSource(nullptr)
+  , mTeardownStarted(false)
+{
+}
+
+void
+ClientSourceChild::SetOwner(ClientThing<ClientSourceChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aThing);
+  MOZ_DIAGNOSTIC_ASSERT(!mSource);
+  mSource = static_cast<ClientSource*>(aThing);
+}
+
+void
+ClientSourceChild::RevokeOwner(ClientThing<ClientSourceChild>* aThing)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mSource);
+  MOZ_DIAGNOSTIC_ASSERT(mSource == static_cast<ClientSource*>(aThing));
+  mSource = nullptr;
+}
+
+ClientSource*
+ClientSourceChild::GetSource() const
+{
+  return mSource;
+}
+
+void
+ClientSourceChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  Unused << SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceChild.h b/dom/clients/manager/ClientSourceChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceChild.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceChild_h
+#define _mozilla_dom_ClientSourceChild_h
+
+#include "mozilla/dom/PClientSourceChild.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+class ClientSourceConstructorArgs;
+template <typename ActorType> class ClientThing;
+
+class ClientSourceChild final : public PClientSourceChild
+{
+  ClientSource* mSource;
+  bool mTeardownStarted;
+
+  // PClientSourceChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientSourceOpChild*
+  AllocPClientSourceOpChild(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceOpChild(PClientSourceOpChild* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientSourceOpConstructor(PClientSourceOpChild* aActor,
+                                 const ClientOpConstructorArgs& aArgs) override;
+
+public:
+  explicit ClientSourceChild(const ClientSourceConstructorArgs& aArgs);
+
+  void
+  SetOwner(ClientThing<ClientSourceChild>* aThing);
+
+  void
+  RevokeOwner(ClientThing<ClientSourceChild>* aThing);
+
+  ClientSource*
+  GetSource() const;
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceChild_h
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceOpChild.h"
+
+#include "ClientSource.h"
+#include "ClientSourceChild.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+ClientSource*
+ClientSourceOpChild::GetSource() const
+{
+  auto actor = static_cast<ClientSourceChild*>(Manager());
+  return actor->GetSource();
+}
+
+template <typename Method, typename Args>
+void
+ClientSourceOpChild::DoSourceOp(Method aMethod, const Args& aArgs)
+{
+  ClientSource* source = GetSource();
+  if (!source) {
+    Unused << PClientSourceOpChild::Send__delete__(this, NS_ERROR_ABORT);
+    return;
+  }
+
+  RefPtr<ClientOpPromise> p = (source->*aMethod)(aArgs);
+
+  // Capturing `this` is safe here because we disconnect the promise in
+  // ActorDestroy() which ensures neither lambda is called if the actor
+  // is destroyed before the source operation completes.
+  p->Then(AbstractThread::GetCurrent(), __func__,
+    [this, aArgs] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientSourceOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aRv) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientSourceOpChild::Send__delete__(this, aRv);
+    })->Track(mPromiseRequestHolder);
+}
+
+void
+ClientSourceOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+void
+ClientSourceOpChild::Init(const ClientOpConstructorArgs& aArgs)
+{
+  ClientSource* source = GetSource();
+  if (!source) {
+    Unused << PClientSourceOpChild::Send__delete__(this, NS_ERROR_ABORT);
+    return;
+  }
+
+  switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientControlledArgs:
+    {
+      DoSourceOp(&ClientSource::Control, aArgs.get_ClientControlledArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientFocusArgs:
+    {
+      DoSourceOp(&ClientSource::Focus, aArgs.get_ClientFocusArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientPostMessageArgs:
+    {
+      DoSourceOp(&ClientSource::PostMessage, aArgs.get_ClientPostMessageArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetStateArgs:
+    {
+      DoSourceOp(&ClientSource::GetState, aArgs.get_ClientGetStateArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientClaimArgs:
+    {
+      DoSourceOp(&ClientSource::Claim, aArgs.get_ClientClaimArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
+    {
+      DoSourceOp(&ClientSource::GetInfoAndState,
+                 aArgs.get_ClientGetInfoAndStateArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_ASSERT_UNREACHABLE("Unknown Client operation!");
+      break;
+    }
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceOpChild.h b/dom/clients/manager/ClientSourceOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceOpChild.h
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceOpChild_h
+#define _mozilla_dom_ClientSourceOpChild_h
+
+#include "mozilla/dom/PClientSourceOpChild.h"
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+
+class ClientSourceOpChild final : public PClientSourceOpChild
+{
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  ClientSource*
+  GetSource() const;
+
+  template <typename Method, typename Args>
+  void
+  DoSourceOp(Method aMethod, const Args& aArgs);
+
+  // PClientSourceOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  ClientSourceOpChild() = default;
+  ~ClientSourceOpChild() = default;
+
+  void
+  Init(const ClientOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceOpChild_h
diff --git a/dom/clients/manager/ClientSourceOpParent.cpp b/dom/clients/manager/ClientSourceOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceOpParent.cpp
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+void
+ClientSourceOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientSourceOpParent::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientSourceOpParent::ClientSourceOpParent(const ClientOpConstructorArgs& aArgs,
+                                           ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientSourceOpParent::~ClientSourceOpParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceOpParent.h b/dom/clients/manager/ClientSourceOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceOpParent.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceOpParent_h
+#define _mozilla_dom_ClientSourceOpParent_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientSourceOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSourceOpParent final : public PClientSourceOpParent
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientSourceOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientSourceOpParent(const ClientOpConstructorArgs& aArgs,
+                       ClientOpPromise::Private* aPromise);
+
+  ~ClientSourceOpParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceOpParent_h
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -0,0 +1,188 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceParent.h"
+
+#include "ClientHandleParent.h"
+#include "ClientManagerService.h"
+#include "ClientSourceOpParent.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+using mozilla::ipc::PrincipalInfo;
+
+IPCResult
+ClientSourceParent::RecvWorkerSyncPing()
+{
+  // Do nothing here.  This is purely a sync message allowing the child to
+  // confirm that the actor has been created on the parent process.
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult
+ClientSourceParent::RecvRedirect(const ClientSourceConstructorArgs& aArgs)
+{
+  mService->RemoveSource(this);
+  mClientInfo.id() = aArgs.id();
+  mClientInfo.type() = aArgs.type();
+  mClientInfo.principalInfo() = aArgs.principalInfo();
+  mService->AddSource(this);
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
+{
+  // TODO: Validate this against nsIURI and nsIPrincipal
+  // TODO: mark execution ready
+  mClientInfo.url() = aArgs.url();
+  mClientInfo.frameType() = aArgs.frameType();
+  mExecutionReady = true;
+
+  for (ClientHandleParent* handle : mHandleList) {
+    Unused << handle->SendExecutionReady(mClientInfo);
+  }
+
+  return IPC_OK();
+};
+
+IPCResult
+ClientSourceParent::RecvFreeze()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
+  mFrozen = true;
+
+  nsTArray<ClientHandleParent*> handleList;
+  mHandleList.SwapElements(handleList);
+  for (ClientHandleParent* handle : handleList) {
+    Unused << ClientHandleParent::Send__delete__(handle);
+  }
+
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvThaw()
+{
+  MOZ_DIAGNOSTIC_ASSERT(mFrozen);
+  mFrozen = false;
+  return IPC_OK();
+}
+
+void
+ClientSourceParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  mService->RemoveSource(this);
+
+  nsTArray<ClientHandleParent*> handleList;
+  mHandleList.SwapElements(handleList);
+  for (ClientHandleParent* handle : handleList) {
+    Unused << ClientHandleParent::Send__delete__(handle);
+  }
+}
+
+PClientSourceOpParent*
+ClientSourceParent::AllocPClientSourceOpParent(const ClientOpConstructorArgs& aArgs)
+{
+  MOZ_ASSERT_UNREACHABLE("ClientSourceOpParent should be explicitly constructed.");
+  return nullptr;
+}
+
+bool
+ClientSourceParent::DeallocPClientSourceOpParent(PClientSourceOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+  : mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime(),
+                EmptyCString(), FrameType::None)
+  , mService(ClientManagerService::GetOrCreateInstance())
+  , mExecutionReady(false)
+  , mFrozen(false)
+{
+  mService->AddSource(this);
+}
+
+ClientSourceParent::~ClientSourceParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(mHandleList.IsEmpty());
+}
+
+bool
+ClientSourceParent::IsFrozen() const
+{
+  return mFrozen;
+}
+
+const ClientInfo&
+ClientSourceParent::Info() const
+{
+  return mClientInfo;
+}
+
+bool
+ClientSourceParent::ExecutionReady() const
+{
+  return mExecutionReady;
+}
+
+const Maybe<ServiceWorkerDescriptor>&
+ClientSourceParent::GetController() const
+{
+  return mController;
+}
+
+void
+ClientSourceParent::AttachHandle(ClientHandleParent* aClientHandle)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
+  MOZ_ASSERT(!mHandleList.Contains(aClientHandle));
+  mHandleList.AppendElement(aClientHandle);
+}
+
+void
+ClientSourceParent::DetachHandle(ClientHandleParent* aClientHandle)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
+  mHandleList.RemoveElement(aClientHandle);
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSourceParent::StartOp(const ClientOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  // If we are being controlled, remember that data before propagating
+  // on to the ClientSource.
+  if (aArgs.type() == ClientOpConstructorArgs::TClientControlledArgs) {
+    mController.reset();
+    mController.emplace(aArgs.get_ClientControlledArgs().serviceWorker());
+  }
+
+  // Constructor failure will reject promise via ActorDestroy()
+  ClientSourceOpParent* actor = new ClientSourceOpParent(aArgs, promise);
+  Unused << SendPClientSourceOpConstructor(actor, aArgs);
+
+  RefPtr<ClientOpPromise> ref = promise.get();
+  return ref.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -0,0 +1,88 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceParent_h
+#define _mozilla_dom_ClientSourceParent_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientSourceParent.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandleParent;
+class ClientManagerService;
+class ClientSourceConstructorArgs;
+class ClientSourceExecutionReadyArgs;
+class ClientSourceParent;
+
+class ClientSourceParent final : public PClientSourceParent
+{
+  ClientInfo mClientInfo;
+  Maybe<ServiceWorkerDescriptor> mController;
+  RefPtr<ClientManagerService> mService;
+  nsTArray<ClientHandleParent*> mHandleList;
+  bool mExecutionReady;
+  bool mFrozen;
+
+  // PClientSourceParent
+  mozilla::ipc::IPCResult
+  RecvWorkerSyncPing() override;
+
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  mozilla::ipc::IPCResult
+  RecvRedirect(const ClientSourceConstructorArgs& aArgs) override;
+
+  mozilla::ipc::IPCResult
+  RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs) override;
+
+  mozilla::ipc::IPCResult
+  RecvFreeze() override;
+
+  mozilla::ipc::IPCResult
+  RecvThaw() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientSourceOpParent*
+  AllocPClientSourceOpParent(const ClientOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceOpParent(PClientSourceOpParent* aActor) override;
+
+public:
+  explicit ClientSourceParent(const ClientSourceConstructorArgs& aArgs);
+  ~ClientSourceParent();
+
+  bool
+  IsFrozen() const;
+
+  const ClientInfo&
+  Info() const;
+
+  bool
+  ExecutionReady() const;
+
+  const Maybe<ServiceWorkerDescriptor>&
+  GetController() const;
+
+  void
+  AttachHandle(ClientHandleParent* aClientSource);
+
+  void
+  DetachHandle(ClientHandleParent* aClientSource);
+
+  already_AddRefed<ClientOpPromise>
+  StartOp(const ClientOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceParent_h
diff --git a/dom/clients/manager/ClientThing.h b/dom/clients/manager/ClientThing.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientThing.h
@@ -0,0 +1,137 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientThing_h
+#define _mozilla_dom_ClientThing_h
+
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+
+template <typename ActorType>
+class ClientThing
+{
+  class Task
+  {
+  public:
+    virtual ~Task() { }
+
+    virtual void
+    Execute(ActorType* aActor) = 0;
+  };
+
+  template <typename Callable>
+  class TaskImpl final : public Task
+  {
+    Callable mCallable;
+
+  public:
+    explicit TaskImpl(Callable aCallable)
+      : mCallable(aCallable)
+    { }
+
+    void
+    Execute(ActorType* aActor) override
+    {
+      MOZ_DIAGNOSTIC_ASSERT(aActor);
+      mCallable(aActor);
+    }
+  };
+
+  nsTArray<UniquePtr<Task>> mTaskList;
+  ActorType* mActor;
+  bool mShutdown;
+
+protected:
+  ClientThing()
+    : mActor(nullptr)
+    , mShutdown(false)
+  {
+  }
+
+  ~ClientThing()
+  {
+    ShutdownThing();
+  }
+
+  ActorType*
+  GetActor() const
+  {
+    return mActor;
+  }
+
+  bool
+  IsShutdown() const
+  {
+    return mShutdown;
+  }
+
+  template<typename Callable>
+  void
+  MaybeExecute(Callable aCallable)
+  {
+    if (mShutdown) {
+      return;
+    }
+    mTaskList.AppendElement(new TaskImpl<Callable>(aCallable));
+    MaybeExecuteTaskList();
+  }
+
+  void
+  MaybeExecuteTaskList()
+  {
+    if (mShutdown || !mActor) {
+      return;
+    }
+    nsTArray<UniquePtr<Task>> taskList;
+    mTaskList.SwapElements(taskList);
+    for (UniquePtr<Task>& t : taskList) {
+      t->Execute(mActor);
+    }
+  }
+
+  void
+  ActivateThing(ActorType* aActor)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(aActor);
+    MOZ_DIAGNOSTIC_ASSERT(!mActor);
+    mActor = aActor;
+    mActor->SetOwner(this);
+  }
+
+  void
+  RevokeActor(ActorType* aActor)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mActor);
+    MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
+    mActor->RevokeOwner(this);
+    mActor = nullptr;
+  }
+
+  void
+  ShutdownThing()
+  {
+    if (mShutdown) {
+      return;
+    }
+    mShutdown = true;
+
+    // TODO: We should provide a way to pass an error code to all
+    //       pending tasks.
+    mTaskList.Clear();
+
+    if (mActor) {
+      mActor->RevokeOwner(this);
+      mActor->MaybeStartTeardown();
+      mActor = nullptr;
+    }
+  }
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientThing_h
diff --git a/dom/clients/manager/PClientHandle.ipdl b/dom/clients/manager/PClientHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientHandle.ipdl
@@ -0,0 +1,34 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include protocol PClientHandleOp;
+include protocol PBlob;
+include protocol PChildToParentStream;
+include protocol PParentToChildStream;
+include protocol PFileDescriptorSet;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientHandle
+{
+  manager PClientManager;
+
+  manages PClientHandleOp;
+
+parent:
+  async Teardown();
+
+  async PClientHandleOp(ClientOpConstructorArgs aArgs);
+
+child:
+  async ExecutionReady(ClientInfo aClientInfo);
+
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientHandleOp.ipdl b/dom/clients/manager/PClientHandleOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientHandleOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientHandle;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientHandleOp
+{
+  manager PClientHandle;
+
+child:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientManager.ipdl b/dom/clients/manager/PClientManager.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientManager.ipdl
@@ -0,0 +1,41 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PClientHandle;
+include protocol PClientManagerOp;
+include protocol PClientNavigateOp;
+include protocol PClientSource;
+include protocol PChildToParentStream;
+include protocol PParentToChildStream;
+include protocol PFileDescriptorSet;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+sync protocol PClientManager
+{
+  manager PBackground;
+
+  manages PClientHandle;
+  manages PClientManagerOp;
+  manages PClientNavigateOp;
+  manages PClientSource;
+
+parent:
+  async Teardown();
+
+  async PClientHandle(ClientInfo aClientInfo);
+  async PClientManagerOp(ClientOpConstructorArgs aArgs);
+  async PClientSource(ClientSourceConstructorArgs aArgs);
+
+child:
+  async PClientNavigateOp(ClientNavigateOpConstructorArgs aArgs);
+
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientManagerOp.ipdl b/dom/clients/manager/PClientManagerOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientManagerOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientManagerOp
+{
+  manager PClientManager;
+
+child:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientNavigateOp.ipdl b/dom/clients/manager/PClientNavigateOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientNavigateOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientNavigateOp
+{
+  manager PClientManager;
+
+parent:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientSource.ipdl b/dom/clients/manager/PClientSource.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientSource.ipdl
@@ -0,0 +1,37 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include protocol PClientSourceOp;
+include protocol PBlob;
+include protocol PChildToParentStream;
+include protocol PParentToChildStream;
+include protocol PFileDescriptorSet;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+sync protocol PClientSource
+{
+  manager PClientManager;
+
+  manages PClientSourceOp;
+
+parent:
+  sync WorkerSyncPing();
+  async Teardown();
+  async Redirect(ClientSourceConstructorArgs aArgs);
+  async ExecutionReady(ClientSourceExecutionReadyArgs aArgs);
+  async Freeze();
+  async Thaw();
+
+child:
+  async PClientSourceOp(ClientOpConstructorArgs aArgs);
+
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientSourceOp.ipdl b/dom/clients/manager/PClientSourceOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientSourceOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientSource;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientSourceOp
+{
+  manager PClientSource;
+
+parent:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ReservedClientHelper.cpp b/dom/clients/manager/ReservedClientHelper.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ReservedClientHelper.cpp
@@ -0,0 +1,179 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ReservedClientHelper.h"
+
+#include "ClientManager.h"
+#include "ClientSource.h"
+#include "MainThreadUtils.h"
+#include "nsContentUtils.h"
+#include "nsIAsyncVerifyRedirectCallback.h"
+#include "nsIChannel.h"
+#include "nsIChannelEventSink.h"
+#include "nsIInterfaceRequestor.h"
+#include "nsIInterfaceRequestorUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class ReserveClientHelper final : public nsIInterfaceRequestor
+                                , public nsIChannelEventSink
+{
+  nsCOMPtr<nsIInterfaceRequestor> mOuter;
+
+  ~ReserveClientHelper()
+  {
+  }
+
+  NS_IMETHOD
+  GetInterface(const nsIID & aIID, void **aResultOut) override
+  {
+    if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
+      *aResultOut = static_cast<nsIChannelEventSink*>(this);
+      NS_ADDREF_THIS();
+      return NS_OK;
+    }
+
+    if (mOuter) {
+      return mOuter->GetInterface(aIID, aResultOut);
+    }
+
+    return NS_ERROR_NO_INTERFACE;
+  }
+
+  NS_IMETHOD
+  AsyncOnChannelRedirect(nsIChannel *aOldChannel,
+                         nsIChannel *aNewChannel,
+                         uint32_t aFlags,
+                         nsIAsyncVerifyRedirectCallback *aCallback) override
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    nsCOMPtr<nsILoadInfo> oldLoadInfo;
+    nsresult rv = aOldChannel->GetLoadInfo(getter_AddRefs(oldLoadInfo));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    nsCOMPtr<nsILoadInfo> newLoadInfo;
+    rv = aNewChannel->GetLoadInfo(getter_AddRefs(newLoadInfo));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    rv = nsContentUtils::CheckSameOrigin(aOldChannel, aNewChannel);
+    if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_DOM_BAD_URI)) {
+      return rv;
+    }
+
+    UniquePtr<ClientSource> reservedClient = oldLoadInfo->TakeReservedClient();
+
+    // If its a same-origin redirect we just move our reserved client to the
+    // new channel.
+    if (NS_SUCCEEDED(rv)) {
+      newLoadInfo->GiveReservedClient(Move(reservedClient));
+    }
+
+    // If its a cross-origin redirect then we discard the old reserved client
+    // and create a new one.
+    else {
+      // If CheckSameOrigin() worked, then the security manager must exist.
+      nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+      MOZ_DIAGNOSTIC_ASSERT(ssm);
+
+      nsCOMPtr<nsIPrincipal> principal;
+      rv = ssm->GetChannelResultPrincipal(aNewChannel, getter_AddRefs(principal));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      reservedClient =
+        ClientManager::CreateSource(ClientType::Window, principal);
+
+      newLoadInfo->GiveReservedClient(Move(reservedClient));
+    }
+
+    nsCOMPtr<nsIChannelEventSink> outerSink = do_GetInterface(mOuter);
+    if (outerSink) {
+      return outerSink->AsyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags,
+                                               aCallback);
+    }
+
+    aCallback->OnRedirectVerifyCallback(NS_OK);
+    return NS_OK;
+  }
+
+public:
+  explicit ReserveClientHelper(nsIInterfaceRequestor* aOuter)
+    : mOuter(aOuter)
+  {
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ReserveClientHelper, nsIInterfaceRequestor,
+                                       nsIChannelEventSink);
+
+} // anonymous namespace
+
+nsresult
+ReserveClientForChannel(nsIChannel* aChannel)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIInterfaceRequestor> outer;
+  nsresult rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outer));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+  if (!ssm) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal;
+  rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(principal));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  nsCOMPtr<nsILoadInfo> loadInfo;
+  rv = aChannel->GetLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // Wait to reserve the client until we are reasonably sure this method
+  // will succeed.
+  UniquePtr<ClientSource> reservedClient =
+    ClientManager::CreateSource(ClientType::Window, principal);
+  if (!reservedClient) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<ReserveClientHelper> helper =
+    new ReserveClientHelper(outer);
+
+  // Only set the callbacks helper if we are able to reserve the client
+  // successfully.
+  rv = aChannel->SetNotificationCallbacks(helper);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // Finally preserve the reserved client on the nsILoadInfo once the
+  // redirect helper has been added to the channel.
+  loadInfo->GiveReservedClient(Move(reservedClient));
+
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ReservedClientHelper.h b/dom/clients/manager/ReservedClientHelper.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ReservedClientHelper.h
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ReservedClientHelper_h
+#define _mozilla_dom_ReservedClientHelper_h
+
+#include "nsError.h"
+
+class nsIChannel;
+
+namespace mozilla {
+namespace dom {
+
+nsresult
+ReserveClientForChannel(nsIChannel* aChannel);
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ReservedClientHelper_h
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/moz.build
@@ -0,0 +1,68 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'ClientHandle.h',
+  'ClientIPCUtils.h',
+  'ClientManager.h',
+  'ClientManagerActors.h',
+  'ClientOpPromise.h',
+  'ClientSource.h',
+  'ClientThing.h',
+  'ReservedClientHelper.h',
+]
+
+UNIFIED_SOURCES += [
+  'ClientHandle.cpp',
+  'ClientHandleChild.cpp',
+  'ClientHandleOpChild.cpp',
+  'ClientHandleOpParent.cpp',
+  'ClientHandleParent.cpp',
+  'ClientManager.cpp',
+  'ClientManagerActors.cpp',
+  'ClientManagerChild.cpp',
+  'ClientManagerOpChild.cpp',
+  'ClientManagerOpParent.cpp',
+  'ClientManagerParent.cpp',
+  'ClientManagerService.cpp',
+  'ClientNavigateOpChild.cpp',
+  'ClientNavigateOpParent.cpp',
+  'ClientSource.cpp',
+  'ClientSourceChild.cpp',
+  'ClientSourceOpChild.cpp',
+  'ClientSourceOpParent.cpp',
+  'ClientSourceParent.cpp',
+  'ReservedClientHelper.cpp',
+]
+
+IPDL_SOURCES += [
+  'ClientIPCTypes.ipdlh',
+  'PClientHandle.ipdl',
+  'PClientHandleOp.ipdl',
+  'PClientManager.ipdl',
+  'PClientManagerOp.ipdl',
+  'PClientNavigateOp.ipdl',
+  'PClientSource.ipdl',
+  'PClientSourceOp.ipdl',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+  '/dom/base',
+  '/dom/workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/clients/moz.build b/dom/clients/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/moz.build
@@ -0,0 +1,10 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+  'api',
+  'manager',
+]
diff --git a/dom/console/moz.build b/dom/console/moz.build
--- a/dom/console/moz.build
+++ b/dom/console/moz.build
@@ -30,16 +30,18 @@ UNIFIED_SOURCES += [
     'ConsoleReportCollector.cpp',
 ]
 
 EXTRA_COMPONENTS += [
     'ConsoleAPI.manifest',
     'ConsoleAPIStorage.js',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/docshell/base',
     '/dom/base',
     '/dom/workers',
     '/js/xpconnect/src',
 ]
 
 MOCHITEST_MANIFESTS += [ 'tests/mochitest.ini' ]
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -29,16 +29,17 @@
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/MutableBlobStreamListener.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/URLSearchParams.h"
+#include "mozilla/dom/workers/bindings/WorkerHolder.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/Telemetry.h"
 
 #include "BodyExtractor.h"
 #include "FetchObserver.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
 
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -15,31 +15,31 @@
 #include "nsError.h"
 #include "nsProxyRelease.h"
 #include "nsString.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/RequestBinding.h"
-#include "mozilla/dom/workers/bindings/WorkerHolder.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
 class BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString;
 class BlobImpl;
 class InternalRequest;
 class OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString;
 class RequestOrUSVString;
 enum class CallerType : uint32_t;
 
 namespace workers {
+class WorkerHolder;
 class WorkerPrivate;
 } // namespace workers
 
 already_AddRefed<Promise>
 FetchRequest(nsIGlobalObject* aGlobal, const RequestOrUSVString& aInput,
              const RequestInit& aInit, CallerType aCallerType,
              ErrorResult& aRv);
 
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -16,16 +16,17 @@
 
 #include "mozilla/Attributes.h"
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessHangMonitorIPC.h"
 #include "mozilla/Unused.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperChild.h"
 #include "mozilla/docshell/OfflineCacheUpdateChild.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ContentBridgeChild.h"
 #include "mozilla/dom/ContentBridgeParent.h"
 #include "mozilla/dom/VideoDecoderManagerChild.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ExternalHelperAppChild.h"
 #include "mozilla/dom/FileCreatorHelper.h"
@@ -963,16 +964,19 @@ void
 ContentChild::InitXPCOM(const XPCOMInitData& aXPCOMInit,
                         const mozilla::dom::ipc::StructuredCloneData& aInitialData)
 {
   SET_PREF_PHASE(pref_initPhase::BEGIN_ALL_PREFS);
   for (unsigned int i = 0; i < aXPCOMInit.prefs().Length(); i++) {
     Preferences::SetPreference(aXPCOMInit.prefs().ElementAt(i));
   }
   SET_PREF_PHASE(pref_initPhase::END_ALL_PREFS);
+
+  ClientManager::Startup();
+
   // Do this as early as possible to get the parent process to initialize the
   // background thread since we'll likely need database information very soon.
   BackgroundChild::Startup();
 
   nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
     new BackgroundChildPrimer();
   if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
     MOZ_CRASH("Failed to create PBackgroundChild!");
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -36,16 +36,17 @@
 #if defined(XP_WIN) && defined(ACCESSIBILITY)
 #include "mozilla/a11y/AccessibleWrap.h"
 #endif
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/DataStorage.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperParent.h"
 #include "mozilla/docshell/OfflineCacheUpdateParent.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/FileCreatorHelper.h"
 #include "mozilla/dom/FileSystemSecurity.h"
 #include "mozilla/dom/ExternalHelperAppParent.h"
 #include "mozilla/dom/GetFilesHelper.h"
 #include "mozilla/dom/GeolocationBinding.h"
@@ -608,16 +609,17 @@ ContentParent::StartUp()
 
   // Note: This reporter measures all ContentParents.
   RegisterStrongMemoryReporter(new ContentParentsMemoryReporter());
 
   mozilla::dom::time::InitializeDateCacheCleaner();
 
   BlobParent::Startup(BlobParent::FriendKey());
 
+  ClientManager::Startup();
   BackgroundChild::Startup();
 
   // Try to preallocate a process that we can use later.
   PreallocatedProcessManager::AllocateAfterDelay();
 
   sDisableUnsafeCPOWWarnings = PR_GetEnv("DISABLE_UNSAFE_CPOW_WARNINGS");
 
 #if defined(XP_LINUX) && defined(MOZ_CONTENT_SANDBOX)
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -43,16 +43,17 @@ DIRS += ['interfaces/' + i for i in inte
 DIRS += [
     'animation',
     'base',
     'bindings',
     'battery',
     'browser-element',
     'cache',
     'canvas',
+    'clients',
     'commandhandler',
     'crypto',
     'encoding',
     'events',
     'fetch',
     'file',
     'filehandle',
     'filesystem',
diff --git a/dom/network/ConnectionWorker.cpp b/dom/network/ConnectionWorker.cpp
--- a/dom/network/ConnectionWorker.cpp
+++ b/dom/network/ConnectionWorker.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <limits>
 #include "mozilla/Hal.h"
 #include "ConnectionWorker.h"
 #include "WorkerRunnable.h"
+#include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace network {
 
 class ConnectionProxy final : public NetworkObserver
                             , public WorkerHolder
 {
diff --git a/dom/performance/moz.build b/dom/performance/moz.build
--- a/dom/performance/moz.build
+++ b/dom/performance/moz.build
@@ -30,15 +30,17 @@ UNIFIED_SOURCES += [
     'PerformanceObserver.cpp',
     'PerformanceObserverEntryList.cpp',
     'PerformanceResourceTiming.cpp',
     'PerformanceService.cpp',
     'PerformanceTiming.cpp',
     'PerformanceWorker.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/dom/workers',
 ]
 
 MOCHITEST_MANIFESTS += [ 'tests/mochitest.ini' ]
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/webidl/Client.webidl b/dom/webidl/Client.webidl
--- a/dom/webidl/Client.webidl
+++ b/dom/webidl/Client.webidl
@@ -8,30 +8,32 @@
  *
  */
 
 [Exposed=ServiceWorker]
 interface Client {
   readonly attribute USVString url;
 
   // Remove frameType in bug 1290936
+  [BinaryName="GetFrameType"]
   readonly attribute FrameType frameType;
 
   readonly attribute ClientType type;
   readonly attribute DOMString id;
 
   // Implement reserved in bug 1264177
   // readonly attribute boolean reserved;
 
   [Throws]
   void postMessage(any message, optional sequence<object> transfer = []);
 };
 
 [Exposed=ServiceWorker]
 interface WindowClient : Client {
+  [BinaryName="GetVisibilityState"]
   readonly attribute VisibilityState visibilityState;
   readonly attribute boolean focused;
 
   // Implement ancestorOrigins in bug 1264180
   // [SameObject] readonly attribute FrozenArray<USVString> ancestorOrigins;
 
   [Throws, NewObject]
   Promise<WindowClient> focus();
diff --git a/dom/webidl/Clients.webidl b/dom/webidl/Clients.webidl
--- a/dom/webidl/Clients.webidl
+++ b/dom/webidl/Clients.webidl
@@ -10,27 +10,29 @@
 
 [Exposed=ServiceWorker]
 interface Clients {
   // The objects returned will be new instances every time
   [NewObject]
   Promise<any> get(DOMString id);
   [NewObject]
   Promise<sequence<Client>> matchAll(optional ClientQueryOptions options);
-  [NewObject,
-   Func="mozilla::dom::ServiceWorkerGlobalScope::OpenWindowEnabled"]
+  // TODO: fix pref enabled func
+  [NewObject]
   Promise<WindowClient?> openWindow(USVString url);
   [NewObject]
   Promise<void> claim();
 };
 
 dictionary ClientQueryOptions {
   boolean includeUncontrolled = false;
   ClientType type = "window";
 };
 
 enum ClientType {
   "window",
   "worker",
   "sharedworker",
+  // https://github.com/w3c/ServiceWorker/issues/1036
+  "serviceworker",
   "all"
 };
 
diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -10,17 +10,18 @@
  *
  * You are granted a license to use, reproduce and create derivative works of
  * this document.
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
-  [SameObject] readonly attribute Clients clients;
+  [SameObject, BinaryName="GetClients"]
+  readonly attribute Clients clients;
   [SameObject] readonly attribute ServiceWorkerRegistration registration;
 
   [Throws, NewObject]
   Promise<void> skipWaiting();
 
   attribute EventHandler oninstall;
   attribute EventHandler onactivate;
 
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -46,16 +46,17 @@
 #include "mozilla/LoadContext.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Cache.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/dom/ChannelInfo.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/InternalResponse.h"
 #include "mozilla/dom/nsCSPService.h"
 #include "mozilla/dom/nsCSPUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
@@ -260,16 +261,17 @@ struct ScriptLoadInfo
   // resolution.
   RefPtr<Promise> mCachePromise;
 
   // The reader stream the cache entry should be filled from, for those cases
   // when we're going to have an mCachePromise.
   nsCOMPtr<nsIInputStream> mCacheReadStream;
 
   nsCOMPtr<nsIChannel> mChannel;
+  Maybe<ClientInfo> mReservedClientInfo;
   char16_t* mScriptTextBuf;
   size_t mScriptTextLength;
 
   nsresult mLoadResult;
   bool mLoadingFinished;
   bool mExecutionScheduled;
   bool mExecutionResult;
 
@@ -563,16 +565,17 @@ class ScriptLoaderRunnable final : publi
   friend class CachePromiseHandler;
   friend class CacheScriptLoader;
   friend class LoaderListener;
 
   WorkerPrivate* mWorkerPrivate;
   nsCOMPtr<nsIEventTarget> mSyncLoopTarget;
   nsTArray<ScriptLoadInfo> mLoadInfos;
   RefPtr<CacheCreator> mCacheCreator;
+  Maybe<ServiceWorkerDescriptor> mController;
   bool mIsMainScript;
   WorkerScriptType mWorkerScriptType;
   bool mCanceled;
   bool mCanceledMainThread;
   ErrorResult& mRv;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
@@ -956,16 +959,22 @@ private:
     // We don't care about progress so just use the simple stream loader for
     // OnStreamComplete notification only.
     nsCOMPtr<nsIStreamLoader> loader;
     rv = NS_NewStreamLoader(getter_AddRefs(loader), listener);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
 
+    if (IsMainWorkerScript()) {
+      MOZ_DIAGNOSTIC_ASSERT(loadInfo.mReservedClientInfo.isSome());
+      nsCOMPtr<nsILoadInfo> chanLoadInfo = channel->GetLoadInfo();
+      chanLoadInfo->SetReservedClientInfo(loadInfo.mReservedClientInfo.ref());
+    }
+
     if (loadInfo.mCacheStatus != ScriptLoadInfo::ToBeCached) {
       rv = channel->AsyncOpen2(loader);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     } else {
       nsCOMPtr<nsIOutputStream> writer;
 
@@ -1169,16 +1178,20 @@ private:
 
       mWorkerPrivate->SetReferrerPolicyFromHeaderValue(tRPHeaderCValue);
 
       WorkerPrivate* parent = mWorkerPrivate->GetParent();
       if (parent) {
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
       }
+
+      if (chanLoadInfo) {
+        mController = chanLoadInfo->GetController();
+      }
     }
 
     return NS_OK;
   }
 
   void
   DataReceivedFromCache(uint32_t aIndex, const uint8_t* aString,
                         uint32_t aStringLen,
@@ -1896,16 +1909,24 @@ ScriptExecutorRunnable::WorkerRun(JSCont
     NS_ASSERTION(!loadInfo.mChannel, "Should no longer have a channel!");
     NS_ASSERTION(loadInfo.mExecutionScheduled, "Should be scheduled!");
 
     if (!loadInfo.mExecutionResult) {
       return true;
     }
   }
 
+  if (mIsWorkerScript) {
+    if (mScriptLoader.mController.isSome()) {
+      aWorkerPrivate->Control(mScriptLoader.mController.ref());
+    }
+
+    aWorkerPrivate->ExecutionReady();
+  }
+
   // If nothing else has failed, our ErrorResult better not be a failure either.
   MOZ_ASSERT(!mScriptLoader.mRv.Failed(), "Who failed it and why?");
 
   // Slightly icky action at a distance, but there's no better place to stash
   // this value, really.
   JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
   MOZ_ASSERT(global);
 
@@ -2221,16 +2242,20 @@ LoadMainScript(WorkerPrivate* aWorkerPri
                ErrorResult& aRv)
 {
   nsTArray<ScriptLoadInfo> loadInfos;
 
   ScriptLoadInfo* info = loadInfos.AppendElement();
   info->mURL = aScriptURL;
   info->mLoadFlags = aWorkerPrivate->GetLoadFlags();
 
+  // We are loading the main script, so the worker's Client must be
+  // reserved.
+  info->mReservedClientInfo.emplace(aWorkerPrivate->GetClientInfo());
+
   LoadAllScripts(aWorkerPrivate, loadInfos, true, aWorkerScriptType, aRv);
 }
 
 void
 Load(WorkerPrivate* aWorkerPrivate,
      const nsTArray<nsString>& aScriptURLs, WorkerScriptType aWorkerScriptType,
      ErrorResult& aRv)
 {
diff --git a/dom/workers/ServiceWorker.cpp b/dom/workers/ServiceWorker.cpp
--- a/dom/workers/ServiceWorker.cpp
+++ b/dom/workers/ServiceWorker.cpp
@@ -3,17 +3,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "WorkerPrivate.h"
 
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 
@@ -90,16 +89,24 @@ ServiceWorker::PostMessage(JSContext* aC
 
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(GetParentObject());
   if (!window || !window->GetExtantDoc()) {
     NS_WARNING("Trying to call post message from an invalid dom object.");
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
-  UniquePtr<ServiceWorkerClientInfo> clientInfo(new ServiceWorkerClientInfo(window->GetExtantDoc()));
+  Maybe<ClientInfo> clientInfo = window->GetClientInfo();
+  Maybe<ClientState> clientState = window->GetClientState();
+  if (clientInfo.isNothing() || clientState.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+
   ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
-  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable, Move(clientInfo));
+  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
+                                        ClientInfoAndState(clientInfo.ref(),
+                                                           clientState.ref()));
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -237,25 +237,30 @@ public:
 
 class ResolveClaimRunnable final : public WorkerRunnable
 {
   RefPtr<PromiseWorkerProxy> mPromiseProxy;
   nsresult mResult;
 
 public:
   ResolveClaimRunnable(WorkerPrivate* aWorkerPrivate,
-                       PromiseWorkerProxy* aPromiseProxy,
-                       nsresult aResult)
+                       PromiseWorkerProxy* aPromiseProxy)
     : WorkerRunnable(aWorkerPrivate)
     , mPromiseProxy(aPromiseProxy)
-    , mResult(aResult)
+    , mResult(NS_OK)
   {
     AssertIsOnMainThread();
   }
 
+  void
+  SetResult(nsresult aResult)
+  {
+    mResult = aResult;
+  }
+
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
     aWorkerPrivate->AssertIsOnWorkerThread();
 
     RefPtr<Promise> promise = mPromiseProxy->WorkerPromise();
     MOZ_ASSERT(promise);
@@ -294,30 +299,39 @@ public:
     MutexAutoLock lock(mPromiseProxy->Lock());
     if (mPromiseProxy->CleanedUp()) {
       return NS_OK;
     }
 
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
-    nsresult rv = NS_OK;
+    RefPtr<ResolveClaimRunnable> resolveRunnable =
+      new ResolveClaimRunnable(workerPrivate, mPromiseProxy);
+
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       // browser shutdown
-      rv = NS_ERROR_FAILURE;
-    } else {
-      rv = swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
-                             mServiceWorkerID);
+      resolveRunnable->SetResult(NS_ERROR_FAILURE);
+      resolveRunnable->Dispatch();
+      return NS_OK;
     }
 
-    RefPtr<ResolveClaimRunnable> r =
-      new ResolveClaimRunnable(workerPrivate, mPromiseProxy, rv);
+    RefPtr<GenericPromise::AllPromiseType> p =
+      swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
+                        mServiceWorkerID);
+    p->Then(AbstractThread::GetCurrent(), __func__,
+      [resolveRunnable](const nsTArray<bool>& aResultList) {
+        resolveRunnable->SetResult(NS_OK);
+        resolveRunnable->Dispatch();
+      }, [resolveRunnable](nsresult aRv) {
+        resolveRunnable->SetResult(aRv);
+        resolveRunnable->Dispatch();
+      });
 
-    r->Dispatch();
     return NS_OK;
   }
 };
 
 class ResolveOpenWindowRunnable final : public WorkerRunnable
 {
 public:
   ResolveOpenWindowRunnable(PromiseWorkerProxy* aPromiseProxy,
diff --git a/dom/workers/ServiceWorkerDescriptor.ipdlh b/dom/workers/ServiceWorkerDescriptor.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerDescriptor.ipdlh
@@ -0,0 +1,24 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+
+using ServiceWorkerState from "mozilla/dom/ServiceWorkerIPCUtils.h";
+
+namespace mozilla {
+namespace dom {
+
+// IPC type with enough information to create a ServiceWorker DOM object
+// in a child process.  Today this just includes data require to look
+// up the ServiceWorkerInfo from the ServiceWorkerManager.
+struct ServiceWorkerDescriptor
+{
+  uint64_t id;
+  PrincipalInfo principalInfo;
+  nsCString scope;
+  ServiceWorkerState state;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -19,22 +19,22 @@
 #include "nsContentUtils.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "nsStreamUtils.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsSerializationHelper.h"
 #include "nsQueryObject.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/BodyUtil.h"
+#include "mozilla/dom/Client.h"
 #include "mozilla/dom/DOMException.h"
 #include "mozilla/dom/DOMExceptionBinding.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/PushMessageDataBinding.h"
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -10,16 +10,17 @@
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/ExtendableEventBinding.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
+#include "mozilla/dom/workers/Workers.h"
 
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
@@ -263,17 +264,17 @@ public:
   }
 };
 
 class ExtendableMessageEvent final : public ExtendableEvent
 {
   JS::Heap<JS::Value> mData;
   nsString mOrigin;
   nsString mLastEventId;
-  RefPtr<ServiceWorkerClient> mClient;
+  RefPtr<Client> mClient;
   RefPtr<ServiceWorker> mServiceWorker;
   RefPtr<MessagePort> mMessagePort;
   nsTArray<RefPtr<MessagePort>> mPorts;
 
 protected:
   explicit ExtendableMessageEvent(EventTarget* aOwner);
   ~ExtendableMessageEvent();
 
diff --git a/dom/workers/ServiceWorkerIPCUtils.h b/dom/workers/ServiceWorkerIPCUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerIPCUtils.h
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ServiceWorkerIPCUtils_h
+#define _mozilla_dom_ServiceWorkerIPCUtils_h
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/ServiceWorkerBinding.h"
+
+namespace IPC {
+  template<>
+  struct ParamTraits<mozilla::dom::ServiceWorkerState> :
+    public ContiguousEnumSerializer<mozilla::dom::ServiceWorkerState,
+                                    mozilla::dom::ServiceWorkerState::Installing,
+                                    mozilla::dom::ServiceWorkerState::EndGuard_>
+  {};
+
+} // namespace IPC
+
+#endif // _mozilla_dom_ServiceWorkerIPCUtils_h
diff --git a/dom/workers/ServiceWorkerInfo.cpp b/dom/workers/ServiceWorkerInfo.cpp
--- a/dom/workers/ServiceWorkerInfo.cpp
+++ b/dom/workers/ServiceWorkerInfo.cpp
@@ -161,49 +161,51 @@ ServiceWorkerInfo::UpdateState(ServiceWo
   }
   // Activated can only go to redundant.
   MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
 #endif
   // Flush any pending functional events to the worker when it transitions to the
   // activated state.
   // TODO: Do we care that these events will race with the propagation of the
   //       state change?
-  if (aState == ServiceWorkerState::Activated && mState != aState) {
-    mServiceWorkerPrivate->Activated();
+  if (mState != aState) {
+    mServiceWorkerPrivate->UpdateState(aState);
   }
   mState = aState;
   nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
   if (mState == ServiceWorkerState::Redundant) {
     serviceWorkerScriptCache::PurgeCache(mPrincipal, mCacheName);
   }
 }
 
 ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                                      const nsACString& aScope,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName,
                                      nsLoadFlags aLoadFlags)
   : mPrincipal(aPrincipal)
-  , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mCacheName(aCacheName)
   , mLoadFlags(aLoadFlags)
   , mState(ServiceWorkerState::EndGuard_)
-  , mServiceWorkerID(GetNextID())
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
   , mSkipWaitingFlag(false)
   , mHandlesFetch(Unknown)
 {
   MOZ_ASSERT(mPrincipal);
   // cache origin attributes so we can use them off main thread
   mOriginAttributes = mPrincipal->OriginAttributesRef();
-  MOZ_ASSERT(!mScope.IsEmpty());
   MOZ_ASSERT(!mScriptSpec.IsEmpty());
   MOZ_ASSERT(!mCacheName.IsEmpty());
+
+  mDescriptor.id() = GetNextID();
+  mDescriptor.scope() = aScope;
+  MOZ_ALWAYS_SUCCEEDS(
+    PrincipalToPrincipalInfo(aPrincipal, &mDescriptor.principalInfo()));
 }
 
 ServiceWorkerInfo::~ServiceWorkerInfo()
 {
   MOZ_ASSERT(mServiceWorkerPrivate);
   mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
 }
 
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -23,27 +23,23 @@ class ServiceWorkerPrivate;
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
 class ServiceWorkerInfo final : public nsIServiceWorkerInfo
 {
 private:
   nsCOMPtr<nsIPrincipal> mPrincipal;
-  const nsCString mScope;
+  ServiceWorkerDescriptor mDescriptor;
   const nsCString mScriptSpec;
   const nsString mCacheName;
   const nsLoadFlags mLoadFlags;
   ServiceWorkerState mState;
   OriginAttributes mOriginAttributes;
 
-  // This id is shared with WorkerPrivate to match requests issued by service
-  // workers to their corresponding serviceWorkerInfo.
-  uint64_t mServiceWorkerID;
-
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
   // There is a high chance of there being at least one ServiceWorker
   // associated with this all the time.
   AutoTArray<ServiceWorker*, 1> mInstances;
 
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   bool mSkipWaitingFlag;
@@ -82,17 +78,17 @@ public:
   ScriptSpec() const
   {
     return mScriptSpec;
   }
 
   const nsCString&
   Scope() const
   {
-    return mScope;
+    return mDescriptor.scope();
   }
 
   bool SkipWaitingFlag() const
   {
     AssertIsOnMainThread();
     return mSkipWaitingFlag;
   }
 
@@ -130,17 +126,23 @@ public:
   GetLoadFlags() const
   {
     return mLoadFlags;
   }
 
   uint64_t
   ID() const
   {
-    return mServiceWorkerID;
+    return mDescriptor.id();
+  }
+
+  const ServiceWorkerDescriptor&
+  Descriptor() const
+  {
+    return mDescriptor;
   }
 
   void
   UpdateState(ServiceWorkerState aState);
 
   // Only used to set initial state when loading from disk!
   void
   SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -30,16 +30,18 @@
 #include "jsapi.h"
 
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/ErrorNames.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/DOMError.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/NotificationEvent.h"
@@ -59,17 +61,16 @@
 #include "nsGlobalWindow.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerInfo.h"
 #include "ServiceWorkerJobQueue.h"
 #include "ServiceWorkerManagerChild.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerRegisterJob.h"
 #include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
@@ -2380,17 +2381,18 @@ ServiceWorkerManager::MaybeStartControll
                                             const nsAString& aDocumentId)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(aDoc);
   if (registration) {
     MOZ_ASSERT(!mControlledDocuments.Contains(aDoc));
-    StartControllingADocument(registration, aDoc, aDocumentId);
+    RefPtr<GenericPromise> p =
+      StartControllingADocument(registration, aDoc, aDocumentId);
   }
 }
 
 void
 ServiceWorkerManager::MaybeStopControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
@@ -2420,30 +2422,45 @@ ServiceWorkerManager::MaybeCheckNavigati
   //    algorithm.
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   mControlledDocuments.Get(aDoc, getter_AddRefs(registration));
   if (registration) {
     registration->MaybeScheduleUpdate();
   }
 }
 
-void
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                                                 nsIDocument* aDoc,
                                                 const nsAString& aDocumentId)
 {
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(aDoc);
 
+  RefPtr<GenericPromise> ref = GenericPromise::CreateAndResolve(true, __func__);
+
   aRegistration->StartControllingADocument();
   mControlledDocuments.Put(aDoc, aRegistration);
   if (!aDocumentId.IsEmpty()) {
     aDoc->SetId(aDocumentId);
   }
+  ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
+  nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
+  if (activeWorker && innerWindow) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref());
+      if (clientHandle) {
+        ref = clientHandle->Control(activeWorker->Descriptor());
+      }
+    }
+  }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
 {
   aRegistration->StopControllingADocument();
   if (aRegistration->IsControllingDocuments() || !aRegistration->IsIdle()) {
     return;
@@ -2608,28 +2625,25 @@ ServiceWorkerManager::GetServiceWorkerFo
 
 namespace {
 
 class ContinueDispatchFetchEventRunnable : public Runnable
 {
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
-  nsString mDocumentId;
   bool mIsReload;
 public:
   ContinueDispatchFetchEventRunnable(ServiceWorkerPrivate* aServiceWorkerPrivate,
                                      nsIInterceptedChannel* aChannel,
                                      nsILoadGroup* aLoadGroup,
-                                     const nsAString& aDocumentId,
                                      bool aIsReload)
     : mServiceWorkerPrivate(aServiceWorkerPrivate)
     , mChannel(aChannel)
     , mLoadGroup(aLoadGroup)
-    , mDocumentId(aDocumentId)
     , mIsReload(aIsReload)
   {
     MOZ_ASSERT(aServiceWorkerPrivate);
     MOZ_ASSERT(aChannel);
   }
 
   void
   HandleError()
@@ -2658,18 +2672,29 @@ public:
     // if that happens.
     nsresult status;
     rv = channel->GetStatus(&status);
     if (NS_WARN_IF(NS_FAILED(rv) || NS_FAILED(status))) {
       HandleError();
       return NS_OK;
     }
 
-    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup,
-                                               mDocumentId, mIsReload);
+    nsString clientId;
+    nsCOMPtr<nsILoadInfo> loadInfo = channel->GetLoadInfo();
+    if (loadInfo) {
+      Maybe<ClientInfo> clientInfo = loadInfo->GetClientInfo();
+      if (clientInfo.isSome()) {
+        char buf[NSID_LENGTH];
+        clientInfo.ref().id().ToProvidedString(buf);
+        CopyUTF8toUTF16(nsDependentCString(buf), clientId);
+      }
+    }
+
+    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup, clientId,
+                                               mIsReload);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       HandleError();
     }
 
     return NS_OK;
   }
 };
 
@@ -2684,44 +2709,36 @@ ServiceWorkerManager::DispatchFetchEvent
                                          bool aIsSubresourceLoad,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerInfo> serviceWorker;
   nsCOMPtr<nsILoadGroup> loadGroup;
-  nsAutoString documentId;
 
   if (aIsSubresourceLoad) {
     MOZ_ASSERT(aDoc);
 
     serviceWorker = GetActiveWorkerInfoForDocument(aDoc);
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     loadGroup = aDoc->GetDocumentLoadGroup();
-    nsresult rv = aDoc->GetOrCreateId(documentId);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
-    }
   } else {
     nsCOMPtr<nsIChannel> internalChannel;
     aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     internalChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 
-    // TODO: Use aDocumentIdForTopLevelNavigation for potentialClientId, pending
-    // the spec change.
-
     nsCOMPtr<nsIURI> uri;
     aRv = aChannel->GetSecureUpgradedChannelURI(getter_AddRefs(uri));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     // non-subresource request means the URI contains the principal
     nsCOMPtr<nsIPrincipal> principal =
@@ -2740,29 +2757,52 @@ ServiceWorkerManager::DispatchFetchEvent
     // before we get to this point.  Therefore we must handle a nullptr
     // active worker here.
     serviceWorker = registration->GetActive();
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
+    // If there is a reserved client it should be marked as controlled before
+    // the FetchEvent.
+    nsCOMPtr<nsILoadInfo> loadInfo = internalChannel->GetLoadInfo();
+    if (loadInfo) {
+      const Maybe<ClientInfo>& clientInfo = loadInfo->GetReservedClientInfo();
+      if (clientInfo.isSome()) {
+        // First, attempt to mark the reserved client controlled directly.  This
+        // will update the controlled status in the ClientManagerService in the
+        // parent.  It will also eventually propagate back to the ClientSource.
+        RefPtr<ClientHandle> clientHandle =
+          ClientManager::CreateHandle(clientInfo.ref());
+        if (clientHandle) {
+          RefPtr<GenericPromise> p =
+            clientHandle->Control(serviceWorker->Descriptor());
+        }
+
+        // But we also note the reserved state on the LoadInfo.  This allows the
+        // ClientSource to be updated immediately after the nsIChannel starts.
+        // This is necessary to have the correct controller in place for immediate
+        // follow-on requests.
+        loadInfo->SetController(serviceWorker->Descriptor());
+      }
+    }
+
     AddNavigationInterception(serviceWorker->Scope(), aChannel);
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
 
   nsCOMPtr<nsIRunnable> continueRunnable =
     new ContinueDispatchFetchEventRunnable(serviceWorker->WorkerPrivate(),
-                                           aChannel, loadGroup,
-                                           documentId, aIsReload);
+                                           aChannel, loadGroup, aIsReload);
 
   nsCOMPtr<nsIChannel> innerChannel;
   aRv = aChannel->GetChannel(getter_AddRefs(innerChannel));
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   nsCOMPtr<nsIUploadChannel2> uploadChannel = do_QueryInterface(innerChannel);
@@ -2836,32 +2876,52 @@ ServiceWorkerManager::GetDocumentRegistr
 NS_IMETHODIMP
 ServiceWorkerManager::GetDocumentController(nsPIDOMWindowInner* aWindow,
                                             nsISupports** aServiceWorker)
 {
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  Maybe<ServiceWorkerDescriptor> controller = aWindow->GetController();
+  if (controller.isNothing()) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
   if (!doc) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  RefPtr<ServiceWorkerRegistrationInfo> registration;
-  nsresult rv = GetDocumentRegistration(doc, getter_AddRefs(registration));
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (!principal) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  nsAutoCString scopeKey;
+  nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  MOZ_ASSERT(registration->GetActive());
-  RefPtr<ServiceWorker> serviceWorker =
-    registration->GetActive()->GetOrCreateInstance(aWindow);
-
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(scopeKey, controller.ref().scope());
+  if (NS_WARN_IF(!registration)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorkerInfo> active = registration->GetActive();
+  if (NS_WARN_IF(!active) ||
+      NS_WARN_IF(!(active->Descriptor() == controller.ref()))) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorker> serviceWorker = active->GetOrCreateInstance(aWindow);
   serviceWorker.forget(aServiceWorker);
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetInstalling(nsPIDOMWindowInner* aWindow,
                                     const nsAString& aScope,
                                     nsISupports** aServiceWorker)
 {
@@ -3171,47 +3231,17 @@ ServiceWorkerManager::UpdateInternal(nsI
                                registration->GetLoadFlags());
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);
 
   queue->ScheduleJob(job);
 }
 
-namespace {
-
-static void
-FireControllerChangeOnDocument(nsIDocument* aDocument)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDocument);
-
-  nsCOMPtr<nsPIDOMWindowInner> w = aDocument->GetInnerWindow();
-  if (!w) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-    return;
-  }
-
-  auto* window = nsGlobalWindow::Cast(w.get());
-  ErrorResult result;
-  dom::Navigator* navigator = window->GetNavigator(result);
-  if (NS_WARN_IF(result.Failed())) {
-    result.SuppressException();
-    return;
-  }
-
-  RefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
-  container->ControllerChanged(result);
-  if (result.Failed()) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-  }
-}
-
-} // anonymous namespace
-
+/* TODO
 UniquePtr<ServiceWorkerClientInfo>
 ServiceWorkerManager::GetClient(nsIPrincipal* aPrincipal,
                                 const nsAString& aClientId,
                                 ErrorResult& aRv)
 {
   UniquePtr<ServiceWorkerClientInfo> clientInfo;
   nsCOMPtr<nsISupportsInterfacePointer> ifptr =
     do_CreateInstance(NS_SUPPORTS_INTERFACE_POINTER_CONTRACTID);
@@ -3245,17 +3275,19 @@ ServiceWorkerManager::GetClient(nsIPrinc
   if (!IsFromAuthenticatedOrigin(doc)) {
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return clientInfo;
   }
 
   clientInfo.reset(new ServiceWorkerClientInfo(doc));
   return clientInfo;
 }
-
+*/
+
+/* TODO
 void
 ServiceWorkerManager::GetAllClients(nsIPrincipal* aPrincipal,
                                     const nsCString& aScope,
                                     uint64_t aServiceWorkerID,
                                     bool aIncludeUncontrolled,
                                     nsTArray<ServiceWorkerClientInfo>& aDocuments)
 {
   MOZ_ASSERT(aPrincipal);
@@ -3337,88 +3369,128 @@ ServiceWorkerManager::GetAllClients(nsIP
   uint32_t ordinal = 0;
   for (uint32_t i = 0; i < docList.Length(); ++i) {
     aDocuments.AppendElement(ServiceWorkerClientInfo(docList[i], ordinal));
     ordinal += 1;
   }
 
   aDocuments.Sort();
 }
-
-void
+*/
+
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
                                        ServiceWorkerRegistrationInfo* aWorkerRegistration)
 {
   MOZ_ASSERT(aWorkerRegistration);
   MOZ_ASSERT(aWorkerRegistration->GetActive());
 
+  RefPtr<GenericPromise> ref;
+
   // Same origin check
   if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
-    return;
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_SECURITY_ERR, __func__);
+    return ref.forget();
   }
 
   // The registration that should be controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
     GetServiceWorkerRegistrationInfo(aDocument);
 
   // The registration currently controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> controllingRegistration;
   GetDocumentRegistration(aDocument, getter_AddRefs(controllingRegistration));
 
   if (aWorkerRegistration != matchingRegistration ||
-        aWorkerRegistration == controllingRegistration) {
-    return;
+      aWorkerRegistration == controllingRegistration) {
+    ref = GenericPromise::CreateAndResolve(true, __func__);
+    return ref.forget();
   }
 
   if (controllingRegistration) {
     StopControllingADocument(controllingRegistration);
   }
 
-  StartControllingADocument(aWorkerRegistration, aDocument, NS_LITERAL_STRING(""));
-  FireControllerChangeOnDocument(aDocument);
+  ref = StartControllingADocument(aWorkerRegistration, aDocument,
+                                  NS_LITERAL_STRING(""));
+  return ref.forget();
 }
 
-nsresult
+already_AddRefed<GenericPromise>
+ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
+                                       const ServiceWorkerDescriptor& aServiceWorker)
+{
+  RefPtr<GenericPromise> ref;
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aServiceWorker.principalInfo());
+  if (!principal) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(principal, aServiceWorker.scope());
+  if (!registration) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  ref = MaybeClaimClient(aDoc, registration);
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise::AllPromiseType>
 ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
                                    const nsCString& aScope, uint64_t aId)
 {
+  RefPtr<GenericPromise::AllPromiseType> ref;
+
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aPrincipal, aScope);
 
   if (!registration || !registration->GetActive() ||
       !(registration->GetActive()->ID() == aId)) {
     // The worker is not active.
-    return NS_ERROR_DOM_INVALID_STATE_ERR;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
   if (NS_WARN_IF(!obs)) {
-    return NS_ERROR_FAILURE;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_FAILURE,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsISimpleEnumerator> enumerator;
   nsresult rv = obs->EnumerateObservers("service-worker-get-client",
                                         getter_AddRefs(enumerator));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
+    ref = GenericPromise::AllPromiseType::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  AutoTArray<RefPtr<GenericPromise>, 32> claimPromiseList;
 
   bool loop = true;
   while (NS_SUCCEEDED(enumerator->HasMoreElements(&loop)) && loop) {
     nsCOMPtr<nsISupports> ptr;
     rv = enumerator->GetNext(getter_AddRefs(ptr));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ptr);
-    MaybeClaimClient(doc, registration);
-  }
-
-  return NS_OK;
+    claimPromiseList.AppendElement(MaybeClaimClient(doc, registration));
+  }
+
+  ref = GenericPromise::All(AbstractThread::GetCurrent(), claimPromiseList);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::SetSkipWaitingFlag(nsIPrincipal* aPrincipal,
                                          const nsCString& aScope,
                                          uint64_t aServiceWorkerID)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -3437,30 +3509,47 @@ ServiceWorkerManager::SetSkipWaitingFlag
   worker->SetSkipWaitingFlag();
 
   if (worker->State() == ServiceWorkerState::Installed) {
     registration->TryToActivateAsync();
   }
 }
 
 void
-ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration)
 {
   AssertIsOnMainThread();
+
+  RefPtr<ServiceWorkerInfo> activeWorker = aRegistration->GetActive();
+  MOZ_DIAGNOSTIC_ASSERT(activeWorker);
+
   for (auto iter = mControlledDocuments.Iter(); !iter.Done(); iter.Next()) {
     if (iter.UserData() != aRegistration) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(iter.Key());
     if (NS_WARN_IF(!doc)) {
       continue;
     }
 
-    FireControllerChangeOnDocument(doc);
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      continue;
+    }
+
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref());
+      if (clientHandle) {
+        RefPtr<GenericPromise> p =
+          clientHandle->Control(activeWorker->Descriptor());
+      }
+    }
   }
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
                                       const nsACString& aScope) const
 {
   MOZ_ASSERT(aPrincipal);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -10,16 +10,17 @@
 #include "nsIServiceWorkerManager.h"
 #include "nsCOMPtr.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/ConsoleReportCollector.h"
 #include "mozilla/LinkedList.h"
+#include "mozilla/MozPromise.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/TypedEnumBits.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerCommon.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
@@ -41,17 +42,16 @@ class OriginAttributes;
 
 namespace dom {
 
 class ServiceWorkerRegistrar;
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
-class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
@@ -270,33 +270,39 @@ public:
               const nsString& aMessage,
               const nsString& aFilename,
               const nsString& aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags,
               JSExnType aExnType);
 
+  /*
   UniquePtr<ServiceWorkerClientInfo>
   GetClient(nsIPrincipal* aPrincipal,
             const nsAString& aClientId,
             ErrorResult& aRv);
 
   void
   GetAllClients(nsIPrincipal* aPrincipal,
                 const nsCString& aScope,
                 uint64_t aServiceWorkerID,
                 bool aIncludeUncontrolled,
                 nsTArray<ServiceWorkerClientInfo>& aDocuments);
+  */
 
-  void
+  already_AddRefed<GenericPromise>
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
-  nsresult
+  already_AddRefed<GenericPromise>
+  MaybeClaimClient(nsIDocument* aDoc,
+                   const ServiceWorkerDescriptor& aServiceWorker);
+
+  already_AddRefed<GenericPromise::AllPromiseType>
   ClaimClients(nsIPrincipal* aPrincipal, const nsCString& aScope, uint64_t aId);
 
   void
   SetSkipWaitingFlag(nsIPrincipal* aPrincipal, const nsCString& aScope,
                      uint64_t aServiceWorkerID);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
@@ -385,17 +391,17 @@ private:
                                             WhichServiceWorker aWhichOne);
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
   NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
 
-  void
+  already_AddRefed<GenericPromise>
   StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                             nsIDocument* aDoc,
                             const nsAString& aDocumentId);
 
   void
   StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
@@ -435,17 +441,17 @@ private:
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration);
+  UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   StorePendingReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                            Promise* aPromise);
 
   void
   CheckPendingReadyPromises();
 
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -2,47 +2,49 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerPrivate.h"
 
 #include "ServiceWorkerManager.h"
-#include "ServiceWorkerWindowClient.h"
 #include "nsContentUtils.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPushErrorReporter.h"
 #include "nsISupportsImpl.h"
 #include "nsITimedChannel.h"
 #include "nsIUploadChannel2.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/Client.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 BEGIN_WORKERS_NAMESPACE
 
+using mozilla::ipc::PrincipalInfo;
+
 NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTION(ServiceWorkerPrivate, mSupportsArray)
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(ServiceWorkerPrivate, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(ServiceWorkerPrivate, Release)
 
 // Tracks the "dom.disable_open_click_delay" preference.  Modified on main
@@ -463,29 +465,28 @@ public:
 
     return NS_OK;
   }
 };
 
 class SendMesssageEventRunnable final : public ExtendableEventWorkerRunnable
                                       , public StructuredCloneHolder
 {
-  UniquePtr<ServiceWorkerClientInfo> mEventSource;
+  const ClientInfoAndState mClientInfoAndState;
 
 public:
   SendMesssageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                             KeepAliveToken* aKeepAliveToken,
-                            UniquePtr<ServiceWorkerClientInfo>&& aEventSource)
+                            const ClientInfoAndState& aClientInfoAndState)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
     , StructuredCloneHolder(CloningSupported, TransferringSupported,
                             StructuredCloneScope::SameProcessDifferentThread)
-    , mEventSource(Move(aEventSource))
+    , mClientInfoAndState(aClientInfoAndState)
   {
     AssertIsOnMainThread();
-    MOZ_ASSERT(mEventSource);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
@@ -494,26 +495,24 @@ public:
       return true;
     }
 
     Sequence<OwningNonNull<MessagePort>> ports;
     if (!TakeTransferredPortsAsSequence(ports)) {
       return true;
     }
 
-    RefPtr<ServiceWorkerClient> client = new ServiceWorkerWindowClient(sgo,
-                                                                       *mEventSource);
     RootedDictionary<ExtendableMessageEventInit> init(aCx);
 
     init.mBubbles = false;
     init.mCancelable = false;
 
     init.mData = messageData;
     init.mPorts = ports;
-    init.mSource.SetValue().SetAsClient() = client;
+    init.mSource.SetValue().SetAsClient() = new Client(sgo, mClientInfoAndState);
 
     RefPtr<EventTarget> target = aWorkerPrivate->GlobalScope();
     RefPtr<ExtendableMessageEvent> extendableEvent =
       ExtendableMessageEvent::Constructor(target, NS_LITERAL_STRING("message"),
                                           init, rv);
     if (NS_WARN_IF(rv.Failed())) {
       rv.SuppressException();
       return false;
@@ -529,17 +528,17 @@ public:
 };
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendMessageEvent(JSContext* aCx,
                                        JS::Handle<JS::Value> aMessage,
                                        const Sequence<JSObject*>& aTransferable,
-                                       UniquePtr<ServiceWorkerClientInfo>&& aClientInfo)
+                                       const ClientInfoAndState& aClientInfoAndState)
 {
   AssertIsOnMainThread();
 
   ErrorResult rv(SpawnWorkerIfNeeded(MessageEvent, nullptr));
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
@@ -548,17 +547,17 @@ ServiceWorkerPrivate::SendMessageEvent(J
   rv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                          &transferable);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
   RefPtr<SendMesssageEventRunnable> runnable =
-    new SendMesssageEventRunnable(mWorkerPrivate, token, Move(aClientInfo));
+    new SendMesssageEventRunnable(mWorkerPrivate, token, aClientInfoAndState);
 
   runnable->Write(aCx, aMessage, transferable, JS::CloneDataPolicy(), rv);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   if (!runnable->Dispatch()) {
     return NS_ERROR_FAILURE;
@@ -1311,24 +1310,24 @@ class FetchEventRunnable : public Extend
 public:
   FetchEventRunnable(WorkerPrivate* aWorkerPrivate,
                      KeepAliveToken* aKeepAliveToken,
                      nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      // CSP checks might require the worker script spec
                      // later on.
                      const nsACString& aScriptSpec,
                      nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
-                     const nsAString& aDocumentId,
+                     const nsAString& aClientId,
                      bool aIsReload,
                      bool aMarkLaunchServiceWorkerEnd)
     : ExtendableFunctionalEventWorkerRunnable(
         aWorkerPrivate, aKeepAliveToken, aRegistration)
     , mInterceptedChannel(aChannel)
     , mScriptSpec(aScriptSpec)
-    , mClientId(aDocumentId)
+    , mClientId(aClientId)
     , mIsReload(aIsReload)
     , mMarkLaunchServiceWorkerEnd(aMarkLaunchServiceWorkerEnd)
     , mCacheMode(RequestCache::Default)
     , mRequestMode(RequestMode::No_cors)
     , mRequestRedirect(RequestRedirect::Follow)
     // By default we set it to same-origin since normal HTTP fetches always
     // send credentials to same-origin websites unless explicitly forbidden.
     , mRequestCredentials(RequestCredentials::Same_origin)
@@ -1572,17 +1571,20 @@ private:
 
     MOZ_ASSERT_IF(internalReq->IsNavigationRequest(),
                   request->Redirect() == RequestRedirect::Manual);
 
     RootedDictionary<FetchEventInit> init(aCx);
     init.mRequest = request;
     init.mBubbles = false;
     init.mCancelable = true;
-    if (!mClientId.IsEmpty()) {
+    // Only expose the FetchEvent.clientId on subresource requests for now.
+    // Once we implement .reservedClientId we can then start shipping
+    // .clientId values on non-subresource requests.
+    if (!mClientId.IsEmpty() && !internalReq->IsNavigationRequest()) {
       init.mClientId = mClientId;
     }
     init.mIsReload = mIsReload;
     RefPtr<FetchEvent> event =
       FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, result);
     if (NS_WARN_IF(result.Failed())) {
       result.SuppressException();
       return false;
@@ -1618,18 +1620,17 @@ private:
 
 NS_IMPL_ISUPPORTS_INHERITED(FetchEventRunnable, WorkerRunnable, nsIHttpHeaderVisitor)
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendFetchEvent(nsIInterceptedChannel* aChannel,
                                      nsILoadGroup* aLoadGroup,
-                                     const nsAString& aDocumentId,
-                                     bool aIsReload)
+                                     const nsAString& aClientId, bool aIsReload)
 {
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(!mInfo || !swm)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1684,17 +1685,17 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
     new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(registration, false));
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
 
 
   RefPtr<FetchEventRunnable> r =
     new FetchEventRunnable(mWorkerPrivate, token, handle,
                            mInfo->ScriptSpec(), regInfo,
-                           aDocumentId, aIsReload, newWorkerCreated);
+                           aClientId, aIsReload, newWorkerCreated);
   rv = r->Init();
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   if (mInfo->State() == ServiceWorkerState::Activating) {
     mPendingFunctionalEvents.AppendElement(r.forget());
     return NS_OK;
@@ -1756,17 +1757,26 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   info.mResolvedScriptURI = info.mBaseURI;
   MOZ_ASSERT(!mInfo->CacheName().IsEmpty());
   info.mServiceWorkerCacheName = mInfo->CacheName();
-  info.mServiceWorkerID = mInfo->ID();
+
+  PrincipalInfo principalInfo;
+  rv = PrincipalToPrincipalInfo(mInfo->Principal(), &principalInfo);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  info.mServiceWorkerDescriptor.emplace(ServiceWorkerDescriptor(mInfo->ID(),
+                                                                principalInfo,
+                                                                mInfo->Scope(),
+                                                                mInfo->State()));
+
   info.mLoadGroup = aLoadGroup;
   info.mLoadFailedAsyncRunnable = aLoadFailedRunnable;
 
   // If we are loading a script for a ServiceWorker then we must not
   // try to intercept it.  If the interception matches the current
   // ServiceWorker's scope then we could deadlock the load.
   info.mLoadFlags = mInfo->GetLoadFlags() |
                     nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
@@ -1823,17 +1833,17 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   AutoJSAPI jsapi;
   jsapi.Init();
   ErrorResult error;
   NS_ConvertUTF8toUTF16 scriptSpec(mInfo->ScriptSpec());
 
   mWorkerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
                                               scriptSpec,
                                               false, WorkerTypeService,
-                                              mInfo->Scope(), &info, error);
+                                              EmptyCString(), &info, error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   RenewKeepAliveToken(aWhy);
 
   if (aNewWorkerCreated) {
     *aNewWorkerCreated = true;
@@ -1892,25 +1902,58 @@ ServiceWorkerPrivate::TerminateWorker()
 void
 ServiceWorkerPrivate::NoteDeadServiceWorkerInfo()
 {
   AssertIsOnMainThread();
   mInfo = nullptr;
   TerminateWorker();
 }
 
+namespace {
+
+class UpdateStateControlRunnable : public MainThreadWorkerControlRunnable
+{
+  const ServiceWorkerState mState;
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->UpdateServiceWorkerState(mState);
+    return true;
+  }
+
+public:
+  UpdateStateControlRunnable(WorkerPrivate* aWorkerPrivate,
+                             ServiceWorkerState aState)
+    : MainThreadWorkerControlRunnable(aWorkerPrivate)
+    , mState(aState)
+  {
+  }
+};
+
+} // anonymous namespace
+
 void
-ServiceWorkerPrivate::Activated()
+ServiceWorkerPrivate::UpdateState(ServiceWorkerState aState)
 {
   AssertIsOnMainThread();
 
-  // If we had to queue up events due to the worker activating, that means
-  // the worker must be currently running.  We should be called synchronously
-  // when the worker becomes activated.
-  MOZ_ASSERT_IF(!mPendingFunctionalEvents.IsEmpty(), mWorkerPrivate);
+  if (!mWorkerPrivate) {
+    MOZ_DIAGNOSTIC_ASSERT(mPendingFunctionalEvents.IsEmpty());
+    return;
+  }
+
+  RefPtr<WorkerRunnable> r =
+    new UpdateStateControlRunnable(mWorkerPrivate, aState);
+  Unused << r->Dispatch();
+
+  if (aState != ServiceWorkerState::Activated) {
+    return;
+  }
 
   nsTArray<RefPtr<WorkerRunnable>> pendingEvents;
   mPendingFunctionalEvents.SwapElements(pendingEvents);
 
   for (uint32_t i = 0; i < pendingEvents.Length(); ++i) {
     RefPtr<WorkerRunnable> r = pendingEvents[i].forget();
     if (NS_WARN_IF(!r->Dispatch())) {
       NS_WARNING("Failed to dispatch pending functional event!");
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -13,16 +13,19 @@
 
 #define NOTIFICATION_CLICK_EVENT_NAME "notificationclick"
 #define NOTIFICATION_CLOSE_EVENT_NAME "notificationclose"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
+
+class ClientInfoAndState;
+
 namespace workers {
 
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
 class KeepAliveToken;
 
 class LifeCycleEventCallback : public Runnable
 {
@@ -78,17 +81,17 @@ protected:
   NS_DECL_OWNINGTHREAD
 
 public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
   nsresult
   SendMessageEvent(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                    const Sequence<JSObject*>& aTransferable,
-                   UniquePtr<ServiceWorkerClientInfo>&& aClientInfo);
+                   const ClientInfoAndState& aClientInfoAndState);
 
   // This is used to validate the worker script and continue the installation
   // process.
   nsresult
   CheckScriptEvaluation(LifeCycleEventCallback* aCallback);
 
   nsresult
   SendLifeCycleEvent(const nsAString& aEventType,
@@ -112,20 +115,18 @@ public:
                         const nsAString& aBody,
                         const nsAString& aTag,
                         const nsAString& aIcon,
                         const nsAString& aData,
                         const nsAString& aBehavior,
                         const nsAString& aScope);
 
   nsresult
-  SendFetchEvent(nsIInterceptedChannel* aChannel,
-                 nsILoadGroup* aLoadGroup,
-                 const nsAString& aDocumentId,
-                 bool aIsReload);
+  SendFetchEvent(nsIInterceptedChannel* aChannel, nsILoadGroup* aLoadGroup,
+                 const nsAString& aClientId, bool aIsReload);
 
   void
   StoreISupports(nsISupports* aSupports);
 
   void
   RemoveISupports(nsISupports* aSupports);
 
   // This will terminate the current running worker thread and drop the
@@ -138,17 +139,17 @@ public:
 
   void
   NoteDeadServiceWorkerInfo();
 
   void
   NoteStoppedControllingDocuments();
 
   void
-  Activated();
+  UpdateState(ServiceWorkerState aState);
 
   nsresult
   GetDebugger(nsIWorkerDebugger** aResult);
 
   nsresult
   AttachDebugger();
 
   nsresult
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -244,20 +244,18 @@ ServiceWorkerRegistrationInfo::Activate(
     return;
   }
 
   TransitionWaitingToActive();
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   // "Queue a task to fire a simple event named controllerchange..."
-  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
-    NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      swm, &ServiceWorkerManager::FireControllerChange, this);
-  NS_DispatchToMainThread(controllerChangeRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mActiveWorker);
+  swm->UpdateClientControllers(this);
 
   nsCOMPtr<nsIRunnable> failRunnable =
     NewRunnableMethod<bool>(this,
                             &ServiceWorkerRegistrationInfo::FinishActivate,
                             false /* success */);
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
     new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(this));
diff --git a/dom/workers/WorkerHolderToken.cpp b/dom/workers/WorkerHolderToken.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.cpp
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WorkerHolderToken.h"
+
+#include "WorkerPrivate.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+// static
+already_AddRefed<WorkerHolderToken>
+WorkerHolderToken::Create(WorkerPrivate* aWorkerPrivate, Status aShutdownStatus)
+{
+  MOZ_ASSERT(aWorkerPrivate);
+
+  RefPtr<WorkerHolderToken> workerHolder =
+    new WorkerHolderToken(aShutdownStatus);
+
+  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, aShutdownStatus))) {
+    return nullptr;
+  }
+
+  return workerHolder.forget();
+}
+
+void
+WorkerHolderToken::AddListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+
+  // Allow an actor to be added after we've entered the Notifying case.  We
+  // can't stop the actor creation from racing with out destruction of the
+  // other actors and we need to wait for this extra one to close as well.
+  // Signal it should destroy itself right away.
+  if (mShuttingDown) {
+    aListener->WorkerShuttingDown();
+  }
+}
+
+void
+WorkerHolderToken::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+
+  DebugOnly<bool> removed = mListenerList.RemoveElement(aListener);
+
+  MOZ_ASSERT(removed);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+}
+
+bool
+WorkerHolderToken::IsShuttingDown() const
+{
+  return mShuttingDown;
+}
+
+WorkerPrivate*
+WorkerHolderToken::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  return mWorkerPrivate;
+}
+
+WorkerHolderToken::WorkerHolderToken(Status aShutdownStatus)
+  : mShutdownStatus(aShutdownStatus)
+  , mShuttingDown(false)
+{
+}
+
+WorkerHolderToken::~WorkerHolderToken()
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+bool
+WorkerHolderToken::Notify(Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+
+  // When the service worker thread is stopped we will get Terminating,
+  // but nothing higher than that.  We must shut things down at Terminating.
+  if (aStatus < mShutdownStatus || mShuttingDown) {
+    return true;
+  }
+
+  mShuttingDown = true;
+
+  // Start the asynchronous destruction of our actors.  These will call back
+  // into RemoveActor() once the actor is destroyed.
+  for (uint32_t i = 0; i < mListenerList.Length(); ++i) {
+    mListenerList[i]->WorkerShuttingDown();
+  }
+
+  return true;
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/WorkerHolderToken.h b/dom/workers/WorkerHolderToken.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_WorkerHolderToken_h
+#define mozilla_dom_workers_WorkerHolderToken_h
+
+#include "nsISupportsImpl.h"
+#include "nsTArray.h"
+#include "WorkerHolder.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+class WorkerPrivate;
+
+class WorkerHolderToken final : public WorkerHolder
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void
+    WorkerShuttingDown() = 0;
+  };
+
+  static already_AddRefed<WorkerHolderToken>
+  Create(workers::WorkerPrivate* aWorkerPrivate, Status aShutdownStatus);
+
+  void
+  AddListener(Listener* aListener);
+
+  void
+  RemoveListener(Listener* aListener);
+
+  bool
+  IsShuttingDown() const;
+
+  WorkerPrivate*
+  GetWorkerPrivate() const;
+
+private:
+  explicit WorkerHolderToken(Status aShutdownStatus);
+
+  ~WorkerHolderToken();
+
+  // WorkerHolder methods
+  virtual bool
+  Notify(workers::Status aStatus) override;
+
+  nsTArray<Listener*> mListenerList;
+  const Status mShutdownStatus;
+  bool mShuttingDown;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(WorkerHolderToken)
+};
+
+END_WORKERS_NAMESPACE
+
+#endif // mozilla_dom_workers_WorkerHolderToken_h
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -42,16 +42,18 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/ContentEvents.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/Likely.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/Move.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Console.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/ErrorEventBinding.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/MessageEvent.h"
@@ -577,16 +579,18 @@ private:
   // run we have not yet done our load so don't know things like our final
   // principal and whatnot.
 
   virtual bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
+    aWorkerPrivate->ReserveClient();
+
     ErrorResult rv;
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL, WorkerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
     // return false and don't SetWorkerScriptExecutedSuccessfully() in that
     // case, but don't throw anything on aCx.  The idea is to not dispatch error
     // events if our load is canceled with that error code.
     if (rv.ErrorCodeIs(NS_BINDING_ABORTED)) {
@@ -647,16 +651,18 @@ private:
 
     WorkerDebuggerGlobalScope* globalScope =
       aWorkerPrivate->CreateDebuggerGlobalScope(aCx);
     if (!globalScope) {
       NS_WARNING("Failed to make global!");
       return false;
     }
 
+    aWorkerPrivate->ReserveClient();
+
     JS::Rooted<JSObject*> global(aCx, globalScope->GetWrapper());
 
     ErrorResult rv;
     JSAutoCompartment ac(aCx, global);
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL,
                                  DebuggerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
@@ -1746,17 +1752,16 @@ public:
 
 NS_IMPL_ISUPPORTS(WorkerControlEventTarget, nsIEventTarget)
 
 END_WORKERS_NAMESPACE
 
 WorkerLoadInfo::WorkerLoadInfo()
   : mLoadFlags(nsIRequest::LOAD_NORMAL)
   , mWindowID(UINT64_MAX)
-  , mServiceWorkerID(0)
   , mReferrerPolicy(net::RP_Unset)
   , mFromWindow(false)
   , mEvalAllowed(false)
   , mReportCSPViolations(false)
   , mXHRParamsAllowed(false)
   , mPrincipalIsSystem(false)
   , mStorageAllowed(false)
   , mServiceWorkersTestingInWindow(false)
@@ -1803,19 +1808,19 @@ WorkerLoadInfo::StealFrom(WorkerLoadInfo
   aOther.mInterfaceRequestor.swap(mInterfaceRequestor);
 
   MOZ_ASSERT(!mPrincipalInfo);
   mPrincipalInfo = aOther.mPrincipalInfo.forget();
 
   mDomain = aOther.mDomain;
   mOrigin = aOther.mOrigin;
   mServiceWorkerCacheName = aOther.mServiceWorkerCacheName;
+  mServiceWorkerDescriptor = aOther.mServiceWorkerDescriptor;
   mLoadFlags = aOther.mLoadFlags;
   mWindowID = aOther.mWindowID;
-  mServiceWorkerID = aOther.mServiceWorkerID;
   mReferrerPolicy = aOther.mReferrerPolicy;
   mFromWindow = aOther.mFromWindow;
   mEvalAllowed = aOther.mEvalAllowed;
   mReportCSPViolations = aOther.mReportCSPViolations;
   mXHRParamsAllowed = aOther.mXHRParamsAllowed;
   mPrincipalIsSystem = aOther.mPrincipalIsSystem;
   mStorageAllowed = aOther.mStorageAllowed;
   mServiceWorkersTestingInWindow = aOther.mServiceWorkersTestingInWindow;
@@ -4607,16 +4612,18 @@ WorkerPrivate::Constructor(JSContext* aC
   }
 
   // Only service and shared workers can have names.
   MOZ_ASSERT_IF(aWorkerType != WorkerTypeDedicated,
                 !aWorkerName.IsVoid());
   MOZ_ASSERT_IF(aWorkerType == WorkerTypeDedicated,
                 aWorkerName.IsEmpty());
 
+  NS_ConvertUTF16toUTF8 scriptURL(aScriptURL);
+
   Maybe<WorkerLoadInfo> stackLoadInfo;
   if (!aLoadInfo) {
     stackLoadInfo.emplace();
 
     nsresult rv = GetLoadInfo(aCx, nullptr, parent, aScriptURL,
                               aIsChromeWorker, InheritLoadGroup,
                               aWorkerType, stackLoadInfo.ptr());
     aRv.MightThrowJSException();
@@ -5046,16 +5053,18 @@ WorkerPrivate::DoRunLoop(JSContext* aCx)
       }
 
       // If we're supposed to die then we should exit the loop.
       if (currentStatus == Killing) {
         // Flush uncaught rejections immediately, without
         // waiting for a next tick.
         PromiseDebugging::FlushUncaughtRejections();
 
+        mClientSource = nullptr;
+
         ShutdownGCTimers();
 
         DisableMemoryReporter();
 
         {
           MutexAutoLock lock(mMutex);
 
           mStatus = Dead;
@@ -5206,16 +5215,81 @@ WorkerPrivate::DispatchToMainThread(alre
 
 nsIEventTarget*
 WorkerPrivate::ControlEventTarget()
 {
   return mWorkerControlEventTarget;
 }
 
 void
+WorkerPrivate::ReserveClient()
+{
+  AssertIsOnWorkerThread();
+  MOZ_ASSERT(!mClientSource);
+
+  ClientType type;
+  switch(Type()) {
+    case WorkerTypeDedicated:
+      type = ClientType::Worker;
+      break;
+    case WorkerTypeShared:
+      type = ClientType::Sharedworker;
+      break;
+    case WorkerTypeService:
+      type = ClientType::Serviceworker;
+      break;
+    default:
+      MOZ_CRASH("unknown worker type!");
+  }
+
+  mClientSource = ClientManager::CreateSource(type, GetPrincipalInfo());
+
+  // Shortly after the client is reserved we will try loading the main script
+  // for the worker.  This may get intercepted by the ServiceWorkerManager
+  // which will then try to create a ClientHandle.  Its actually possible for
+  // the main thread to create this ClientHandle before our IPC message creating
+  // the ClientSource completes.  To avoid this race we synchronously ping our
+  // parent Client actor here.  This ensure the worker Client is created in
+  // the parent before the main thread might try reaching it with a
+  // ClientHandle.
+  //
+  // An alternative solution would have been to handle the out-of-order operations
+  // on the parent side.  We could have created a small window where we allow
+  // ClientHandle objects to exist without a ClientSource.  We would then time
+  // out these handles if they stayed orphaned for too long.  This approach would
+  // be much more complex, but also avoid this extra bit of latency when starting
+  // workers.
+  mClientSource->WorkerSyncPing(this);
+}
+
+const ClientInfo&
+WorkerPrivate::GetClientInfo() const
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  return mClientSource->Info();
+}
+
+void
+WorkerPrivate::Control(const ServiceWorkerDescriptor& aServiceWorker)
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  mClientSource->SetController(aServiceWorker);
+}
+
+void
+WorkerPrivate::ExecutionReady()
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  mClientSource->WorkerExecutionReady(this);
+}
+
+void
 WorkerPrivate::InitializeGCTimers()
 {
   AssertIsOnWorkerThread();
 
   // We need a timer for GC. The basic plan is to run a non-shrinking GC
   // periodically (PERIODIC_GC_TIMER_DELAY_SEC) while the worker is running.
   // Once the worker goes idle we set a short (IDLE_GC_TIMER_DELAY_SEC) timer to
   // run a shrinking GC. If the worker receives more messages then the short
@@ -5547,16 +5621,18 @@ WorkerPrivate::ClearDebuggerEventQueue()
 
 bool
 WorkerPrivate::FreezeInternal()
 {
   AssertIsOnWorkerThread();
 
   NS_ASSERTION(!mFrozen, "Already frozen!");
 
+  mClientSource->Freeze();
+
   mFrozen = true;
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Freeze(nullptr);
   }
 
   return true;
 }
@@ -5568,16 +5644,19 @@ WorkerPrivate::ThawInternal()
 
   NS_ASSERTION(mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Thaw(nullptr);
   }
 
   mFrozen = false;
+
+  mClientSource->Thaw();
+
   return true;
 }
 
 void
 WorkerPrivate::TraverseTimeouts(nsCycleCollectionTraversalCallback& cb)
 {
   for (uint32_t i = 0; i < mTimeouts.Length(); ++i) {
     TimeoutInfo* tmp = mTimeouts[i];
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -57,16 +57,18 @@ template<class T> class nsMainThreadPtrH
 
 namespace JS {
 struct RuntimeStats;
 } // namespace JS
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
+class ClientInfo;
+class ClientSource;
 class Function;
 class MessagePort;
 class MessagePortIdentifier;
 class PromiseNativeHandler;
 class StructuredCloneHolder;
 class WorkerDebuggerGlobalScope;
 class WorkerGlobalScope;
 } // namespace dom
@@ -79,17 +81,16 @@ struct PRThread;
 
 class ReportDebuggerErrorRunnable;
 class PostDebuggerMessageRunnable;
 
 BEGIN_WORKERS_NAMESPACE
 
 class AutoSyncLoopHolder;
 class SharedWorker;
-class ServiceWorkerClientInfo;
 class WorkerControlEventTarget;
 class WorkerControlRunnable;
 class WorkerDebugger;
 class WorkerPrivate;
 class WorkerRunnable;
 class WorkerThread;
 
 // SharedMutex is a small wrapper around an (internal) reference-counted Mutex
@@ -518,24 +519,23 @@ public:
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
   uint64_t
   ServiceWorkerID() const
   {
-    return mLoadInfo.mServiceWorkerID;
+    return GetServiceWorkerDescriptor().id();
   }
 
   const nsCString&
   ServiceWorkerScope() const
   {
-    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
-    return mWorkerName;
+    return GetServiceWorkerDescriptor().scope();
   }
 
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
@@ -548,21 +548,37 @@ public:
   {
     AssertIsOnMainThread();
     return mLoadInfo.mResolvedScriptURI;
   }
 
   const nsString&
   ServiceWorkerCacheName() const
   {
-    MOZ_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
     AssertIsOnMainThread();
     return mLoadInfo.mServiceWorkerCacheName;
   }
 
+  const ServiceWorkerDescriptor&
+  GetServiceWorkerDescriptor() const
+  {
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
+    return mLoadInfo.mServiceWorkerDescriptor.ref();
+  }
+
+  void
+  UpdateServiceWorkerState(ServiceWorkerState aState)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
+    mLoadInfo.mServiceWorkerDescriptor.ref().state() = aState;
+  }
+
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mLoadInfo.mChannelInfo;
   }
 
   void
   SetChannelInfo(const ChannelInfo& aChannelInfo)
@@ -1029,16 +1045,17 @@ class WorkerPrivate : public WorkerPriva
   // fired on the main thread if the worker script fails to load
   nsCOMPtr<nsIRunnable> mLoadFailedRunnable;
 
   JS::UniqueChars mDefaultLocale; // nulled during worker JSContext init
   TimeStamp mKillTime;
   uint32_t mErrorHandlerRecursionCount;
   uint32_t mNextTimeoutId;
   Status mStatus;
+  UniquePtr<ClientSource> mClientSource;
   bool mFrozen;
   bool mTimerRunning;
   bool mRunningExpiredTimeouts;
   bool mPendingEventQueueClearing;
   bool mCancelAllPendingRunnables;
   bool mPeriodicGCTimerRunning;
   bool mIdleGCTimerRunning;
   bool mWorkerScriptExecutedSuccessfully;
@@ -1453,16 +1470,28 @@ public:
                        uint32_t aFlags = NS_DISPATCH_NORMAL);
 
   // Get an event target that will dispatch runnables as control runnables on
   // the worker thread.  Implement nsICancelableRunnable if you wish to take
   // action on cancelation.
   nsIEventTarget*
   ControlEventTarget();
 
+  void
+  ReserveClient();
+
+  const ClientInfo&
+  GetClientInfo() const;
+
+  void
+  Control(const ServiceWorkerDescriptor& aServiceWorker);
+
+  void
+  ExecutionReady();
+
 private:
   WorkerPrivate(WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsACString& aSharedWorkerName,
                 WorkerLoadInfo& aLoadInfo);
 
   bool
   MayContinueRunning()
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WorkerScope.h"
 
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/Clients.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/Fetch.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IDBFactory.h"
 #include "mozilla/dom/ImageBitmap.h"
 #include "mozilla/dom/ImageBitmapBinding.h"
 #include "mozilla/dom/Performance.h"
@@ -27,29 +28,29 @@
 #include "mozilla/dom/WorkerLocation.h"
 #include "mozilla/dom/WorkerNavigator.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/Services.h"
 #include "nsServiceManagerUtils.h"
 
 #include "nsIDocument.h"
 #include "nsIServiceWorkerManager.h"
+#include "nsIScriptError.h"
 #include "nsIScriptTimeoutHandler.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #include "Crypto.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
-#include "ServiceWorkerClients.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerRegistration.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 extern already_AddRefed<nsIScriptTimeoutHandler>
@@ -603,24 +604,25 @@ ServiceWorkerGlobalScope::WrapGlobalObje
   JS::CompartmentOptions options;
   mWorkerPrivate->CopyJSCompartmentOptions(options);
 
   return ServiceWorkerGlobalScopeBinding::Wrap(aCx, this, this, options,
                                                GetWorkerPrincipal(),
                                                true, aReflector);
 }
 
-ServiceWorkerClients*
-ServiceWorkerGlobalScope::Clients()
+already_AddRefed<Clients>
+ServiceWorkerGlobalScope::GetClients()
 {
   if (!mClients) {
-    mClients = new ServiceWorkerClients(this);
+    mClients = new Clients(this);
   }
 
-  return mClients;
+  RefPtr<Clients> ref = mClients;
+  return ref.forget();
 }
 
 ServiceWorkerRegistration*
 ServiceWorkerGlobalScope::Registration()
 {
   if (!mRegistration) {
     mRegistration =
       ServiceWorkerRegistration::CreateForWorker(mWorkerPrivate, mScope);
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -14,16 +14,17 @@
 #include "nsWeakReference.h"
 #include "mozilla/dom/ImageBitmapSource.h"
 
 namespace mozilla {
 namespace dom {
 
 class AnyCallback;
 struct ChannelPixelLayout;
+class Clients;
 class Console;
 class Crypto;
 class Function;
 class IDBFactory;
 enum class ImageBitmapFormat : uint8_t;
 class Performance;
 class Promise;
 class RequestOrUSVString;
@@ -35,17 +36,16 @@ enum class CallerType : uint32_t;
 namespace cache {
 
 class CacheStorage;
 
 } // namespace cache
 
 namespace workers {
 
-class ServiceWorkerClients;
 class WorkerPrivate;
 
 } // namespace workers
 
 class WorkerGlobalScope : public DOMEventTargetHelper,
                           public nsIGlobalObject,
                           public nsSupportsWeakReference
 {
@@ -250,17 +250,17 @@ public:
   Close(JSContext* aCx);
 
   IMPL_EVENT_HANDLER(connect)
 };
 
 class ServiceWorkerGlobalScope final : public WorkerGlobalScope
 {
   const nsString mScope;
-  RefPtr<workers::ServiceWorkerClients> mClients;
+  RefPtr<Clients> mClients;
   RefPtr<ServiceWorkerRegistration> mRegistration;
 
   ~ServiceWorkerGlobalScope();
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerGlobalScope,
                                            WorkerGlobalScope)
@@ -277,18 +277,18 @@ public:
   OpenWindowEnabled(JSContext* aCx, JSObject* aObj);
 
   void
   GetScope(nsString& aScope) const
   {
     aScope = mScope;
   }
 
-  workers::ServiceWorkerClients*
-  Clients();
+  already_AddRefed<Clients>
+  GetClients();
 
   ServiceWorkerRegistration*
   Registration();
 
   already_AddRefed<Promise>
   SkipWaiting(ErrorResult& aRv);
 
   IMPL_EVENT_HANDLER(activate)
diff --git a/dom/workers/Workers.h b/dom/workers/Workers.h
--- a/dom/workers/Workers.h
+++ b/dom/workers/Workers.h
@@ -16,16 +16,17 @@
 #include "nsDebug.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 #include "nsILoadContext.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsIInterfaceRequestor.h"
 #include "mozilla/dom/ChannelInfo.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/net/ReferrerPolicy.h"
 
 #define BEGIN_WORKERS_NAMESPACE \
   namespace mozilla { namespace dom { namespace workers {
 #define END_WORKERS_NAMESPACE \
   } /* namespace workers */ } /* namespace dom */ } /* namespace mozilla */
 #define USING_WORKERS_NAMESPACE \
   using namespace mozilla::dom::workers;
@@ -252,22 +253,22 @@ struct WorkerLoadInfo
   // Only set if we have a custom overriden load group
   RefPtr<InterfaceRequestor> mInterfaceRequestor;
 
   nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
   nsCString mDomain;
   nsString mOrigin; // Derived from mPrincipal; can be used on worker thread.
 
   nsString mServiceWorkerCacheName;
+  Maybe<ServiceWorkerDescriptor> mServiceWorkerDescriptor;
 
   ChannelInfo mChannelInfo;
   nsLoadFlags mLoadFlags;
 
   uint64_t mWindowID;
-  uint64_t mServiceWorkerID;
 
   net::ReferrerPolicy mReferrerPolicy;
   bool mFromWindow;
   bool mEvalAllowed;
   bool mReportCSPViolations;
   bool mXHRParamsAllowed;
   bool mPrincipalIsSystem;
   bool mStorageAllowed;
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -8,16 +8,17 @@ with Files("**"):
     BUG_COMPONENT = ("Core", "DOM: Workers")
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
     'FileReaderSync.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
     'ServiceWorkerEvents.h',
+    'ServiceWorkerIPCUtils.h',
     'ServiceWorkerRegistrar.h',
     'ServiceWorkerRegistration.h',
     'WorkerLocation.h',
     'WorkerNavigator.h',
     'WorkerPrefs.h',
     'WorkerPrivate.h',
     'WorkerRunnable.h',
     'WorkerScope.h',
@@ -30,21 +31,19 @@ EXPORTS.mozilla.dom.workers += [
     'ServiceWorkerRegistrationInfo.h',
     'WorkerDebuggerManager.h',
     'Workers.h',
 ]
 
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
-    'ServiceWorkerClient.h',
-    'ServiceWorkerClients.h',
-    'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
+    'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
     'nsIWorkerDebugger.idl',
     'nsIWorkerDebuggerManager.idl',
 ]
@@ -52,18 +51,16 @@ XPIDL_SOURCES += [
 UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
-    'ServiceWorkerClient.cpp',
-    'ServiceWorkerClients.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
@@ -73,31 +70,32 @@ UNIFIED_SOURCES += [
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerUpdaterChild.cpp',
     'ServiceWorkerUpdaterParent.cpp',
-    'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
+    'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
 IPDL_SOURCES += [
     'PServiceWorkerManager.ipdl',
     'PServiceWorkerUpdater.ipdl',
+    'ServiceWorkerDescriptor.ipdlh',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
     '/dom/base',
     '/dom/bindings',
diff --git a/dom/xslt/base/moz.build b/dom/xslt/base/moz.build
--- a/dom/xslt/base/moz.build
+++ b/dom/xslt/base/moz.build
@@ -8,16 +8,18 @@ UNIFIED_SOURCES += [
     'txDouble.cpp',
     'txExpandedName.cpp',
     'txExpandedNameMap.cpp',
     'txList.cpp',
     'txNamespaceMap.cpp',
     'txURIUtils.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '..',
     '../xml',
     '../xpath',
     '../xslt',
 ]
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/xul/moz.build b/dom/xul/moz.build
--- a/dom/xul/moz.build
+++ b/dom/xul/moz.build
@@ -38,16 +38,18 @@ XPIDL_SOURCES += [
 ]
 
 XPIDL_MODULE = 'xul'
 
 UNIFIED_SOURCES += [
     'nsXULControllers.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/docshell/base',
     '/dom/base',
     '/dom/html',
     '/dom/xbl',
     '/dom/xml',
     '/dom/xul/templates',
     '/layout/base',
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -10,16 +10,17 @@
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PFileSystemRequestChild.h"
 #include "mozilla/dom/FileSystemTaskBase.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
@@ -521,16 +522,28 @@ BackgroundChildImpl::AllocPGamepadTestCh
 bool
 BackgroundChildImpl::DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor)
 {
   MOZ_ASSERT(aActor);
   delete static_cast<dom::GamepadTestChannelChild*>(aActor);
   return true;
 }
 
+mozilla::dom::PClientManagerChild*
+BackgroundChildImpl::AllocPClientManagerChild()
+{
+  return mozilla::dom::AllocClientManagerChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPClientManagerChild(mozilla::dom::PClientManagerChild* aActor)
+{
+  return mozilla::dom::DeallocClientManagerChild(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 mozilla::ipc::IPCResult
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -185,16 +185,22 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelChild(PGamepadEventChannelChild* aActor) override;
 
   virtual PGamepadTestChannelChild*
   AllocPGamepadTestChannelChild() override;
 
   virtual bool
   DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor) override;
+
+  virtual PClientManagerChild*
+  AllocPClientManagerChild() override;
+
+  virtual bool
+  DeallocPClientManagerChild(PClientManagerChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -9,16 +9,17 @@
 #include "BroadcastChannelParent.h"
 #include "FileDescriptorSetParent.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasParent.h"
 #endif
 #include "mozilla/media/MediaParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/FileSystemBase.h"
 #include "mozilla/dom/FileSystemRequestParent.h"
 #include "mozilla/dom/GamepadEventChannelParent.h"
 #include "mozilla/dom/GamepadTestChannelParent.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/PGamepadEventChannelParent.h"
 #include "mozilla/dom/PGamepadTestChannelParent.h"
@@ -864,16 +865,28 @@ bool
 BackgroundParentImpl::DeallocPGamepadTestChannelParent(dom::PGamepadTestChannelParent *aActor)
 {
   MOZ_ASSERT(aActor);
   RefPtr<dom::GamepadTestChannelParent> parent =
     dont_AddRef(static_cast<dom::GamepadTestChannelParent*>(aActor));
   return true;
 }
 
+mozilla::dom::PClientManagerParent*
+BackgroundParentImpl::AllocPClientManagerParent()
+{
+  return mozilla::dom::AllocClientManagerParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPClientManagerParent(mozilla::dom::PClientManagerParent* aActor)
+{
+  return mozilla::dom::DeallocClientManagerParent(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -213,14 +213,20 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelParent(PGamepadEventChannelParent *aActor) override;
 
   virtual PGamepadTestChannelParent*
   AllocPGamepadTestChannelParent() override;
 
   virtual bool
   DeallocPGamepadTestChannelParent(PGamepadTestChannelParent* aActor) override;
+
+  virtual PClientManagerParent*
+  AllocPClientManagerParent() override;
+
+  virtual bool
+  DeallocPClientManagerParent(PClientManagerParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -6,16 +6,17 @@ include protocol PAsmJSCacheEntry;
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundIndexedDBUtils;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
+include protocol PClientManager;
 include protocol PFileDescriptorSet;
 include protocol PFileSystemRequest;
 include protocol PGamepadEventChannel;
 include protocol PGamepadTestChannel;
 include protocol PMemoryStream;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PQuota;
@@ -51,16 +52,17 @@ sync protocol PBackground
   manages PBackgroundIDBFactory;
   manages PBackgroundIndexedDBUtils;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
+  manages PClientManager;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
   manages PGamepadEventChannel;
   manages PGamepadTestChannel;
   manages PMemoryStream;
   manages PMessagePort;
   manages PCameras;
   manages PQuota;
@@ -109,16 +111,18 @@ parent:
   async PFileSystemRequest(FileSystemParams params);
 
   async PGamepadEventChannel();
 
   async PGamepadTestChannel();
 
   async PMemoryStream(uint64_t aSize);
 
+  async PClientManager();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
   async PParentToChildStream();
 
 both:
   async PBlob(BlobConstructorParams params);
diff --git a/ipc/ipdl/sync-messages.ini b/ipc/ipdl/sync-messages.ini
--- a/ipc/ipdl/sync-messages.ini
+++ b/ipc/ipdl/sync-messages.ini
@@ -1086,8 +1086,10 @@ description =
 [PPrinting::SavePrintSettings]
 description =
 [PHandlerService::FillHandlerInfo]
 description =
 [PHandlerService::Exists]
 description =
 [PHandlerService::GetTypeFromExtension]
 description =
+[PClientSource::WorkerSyncPing]
+description = Synchronous ping allowing worker thread to confirm actor is created.  Necessary to avoid racing with ClientHandle actors on main thread.
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/LoadInfo.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozIThirdPartyUtil.h"
 #include "nsFrameLoader.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIDocShell.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIFrameLoader.h"
@@ -88,16 +89,21 @@ LoadInfo::LoadInfo(nsIPrincipal* aLoadin
   // if the load is sandboxed, we can not also inherit the principal
   if (mSecurityFlags & nsILoadInfo::SEC_SANDBOXED) {
     mForceInheritPrincipalDropped =
       (mSecurityFlags & nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL);
     mSecurityFlags &= ~nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL;
   }
 
   if (aLoadingContext) {
+    nsCOMPtr<nsPIDOMWindowInner> contextInner = aLoadingContext->OwnerDoc()->GetInnerWindow();
+    if (contextInner) {
+      mClientInfo = contextInner->GetClientInfo();
+    }
+
     nsCOMPtr<nsPIDOMWindowOuter> contextOuter = aLoadingContext->OwnerDoc()->GetWindow();
     if (contextOuter) {
       ComputeIsThirdPartyContext(contextOuter);
       mOuterWindowID = contextOuter->WindowID();
       nsCOMPtr<nsPIDOMWindowOuter> parent = contextOuter->GetScriptableParent();
       mParentOuterWindowID = parent ? parent->WindowID() : mOuterWindowID;
     }
 
@@ -264,16 +270,17 @@ LoadInfo::LoadInfo(nsPIDOMWindowOuter* a
 #endif
 }
 
 LoadInfo::LoadInfo(const LoadInfo& rhs)
   : mLoadingPrincipal(rhs.mLoadingPrincipal)
   , mTriggeringPrincipal(rhs.mTriggeringPrincipal)
   , mPrincipalToInherit(rhs.mPrincipalToInherit)
   , mSandboxedLoadingPrincipal(rhs.mSandboxedLoadingPrincipal)
+  // by default do not propagate the reserved Client
   , mLoadingContext(rhs.mLoadingContext)
   , mSecurityFlags(rhs.mSecurityFlags)
   , mInternalContentPolicyType(rhs.mInternalContentPolicyType)
   , mTainting(rhs.mTainting)
   , mUpgradeInsecureRequests(rhs.mUpgradeInsecureRequests)
   , mVerifySignedContent(rhs.mVerifySignedContent)
   , mEnforceSRI(rhs.mEnforceSRI)
   , mForceInheritPrincipalDropped(rhs.mForceInheritPrincipalDropped)
@@ -869,16 +876,66 @@ LoadInfo::SetIsPreflight()
 }
 
 void
 LoadInfo::SetUpgradeInsecureRequests()
 {
   mUpgradeInsecureRequests = true;
 }
 
+void
+LoadInfo::GiveReservedClient(UniquePtr<ClientSource>&& aClientSource)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aClientSource);
+  mReservedClient = Move(aClientSource);
+  SetReservedClientInfo(mReservedClient->Info());
+}
+
+UniquePtr<ClientSource>
+LoadInfo::TakeReservedClient()
+{
+  return Move(mReservedClient);
+}
+
+void
+LoadInfo::SetReservedClientInfo(const ClientInfo& aClientInfo)
+{
+  mReservedClientInfo.emplace(aClientInfo);
+}
+
+const Maybe<ClientInfo>&
+LoadInfo::GetReservedClientInfo() const
+{
+  return mReservedClientInfo;
+}
+
+void
+LoadInfo::SetClientInfo(const ClientInfo& aClientInfo)
+{
+  mClientInfo.emplace(aClientInfo);
+}
+
+const Maybe<ClientInfo>&
+LoadInfo::GetClientInfo() const
+{
+  return mClientInfo;
+}
+
+void
+LoadInfo::SetController(const ServiceWorkerDescriptor& aServiceWorker)
+{
+  mController.emplace(aServiceWorker);
+}
+
+const mozilla::Maybe<ServiceWorkerDescriptor>&
+LoadInfo::GetController() const
+{
+  return mController;
+}
+
 NS_IMETHODIMP
 LoadInfo::GetIsPreflight(bool* aIsPreflight)
 {
   *aIsPreflight = mIsPreflight;
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -10,16 +10,18 @@
 #include "nsIContentPolicy.h"
 #include "nsILoadInfo.h"
 #include "nsIPrincipal.h"
 #include "nsIWeakReferenceUtils.h" // for nsWeakPtr
 #include "nsIURI.h"
 #include "nsTArray.h"
 
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
 
 class nsINode;
 class nsPIDOMWindowOuter;
 
 namespace mozilla {
 
 namespace dom {
 class XMLHttpRequestMainThread;
@@ -70,16 +72,41 @@ public:
   // creates a copy of the loadinfo which is appropriate to use for a
   // separate request. I.e. not for a redirect or an inner channel, but
   // when a separate request is made with the same security properties.
   already_AddRefed<nsILoadInfo> CloneForNewRequest() const;
 
   void SetIsPreflight();
   void SetUpgradeInsecureRequests();
 
+  // c++ specific methods defined in nsILoadInfo
+  void
+  GiveReservedClient(mozilla::UniquePtr<mozilla::dom::ClientSource>&& aClientSource) override;
+
+  mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeReservedClient() override;
+
+  void
+  SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
+
+  const Maybe<mozilla::dom::ClientInfo>&
+  GetReservedClientInfo() const override;
+
+  void
+  SetClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
+
+  const Maybe<mozilla::dom::ClientInfo>&
+  GetClientInfo() const override;
+
+  void
+  SetController(const mozilla::dom::ServiceWorkerDescriptor& aServiceWorker) override;
+
+  const mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor>&
+  GetController() const override;
+
 private:
   // private constructor that is only allowed to be called from within
   // HttpChannelParent and FTPChannelParent declared as friends undeneath.
   // In e10s we can not serialize nsINode, hence we store the innerWindowID.
   // Please note that aRedirectChain uses swapElements.
   LoadInfo(nsIPrincipal* aLoadingPrincipal,
            nsIPrincipal* aTriggeringPrincipal,
            nsIPrincipal* aPrincipalToInherit,
@@ -123,16 +150,20 @@ private:
   void SetIncludeCookiesSecFlag();
   friend class mozilla::dom::XMLHttpRequestMainThread;
 
   // if you add a member, please also update the copy constructor
   nsCOMPtr<nsIPrincipal>           mLoadingPrincipal;
   nsCOMPtr<nsIPrincipal>           mTriggeringPrincipal;
   nsCOMPtr<nsIPrincipal>           mPrincipalToInherit;
   nsCOMPtr<nsIPrincipal>           mSandboxedLoadingPrincipal;
+  UniquePtr<mozilla::dom::ClientSource> mReservedClient;
+  Maybe<mozilla::dom::ClientInfo>  mReservedClientInfo;
+  Maybe<mozilla::dom::ClientInfo>  mClientInfo;
+  Maybe<mozilla::dom::ServiceWorkerDescriptor> mController;
   nsWeakPtr                        mLoadingContext;
   nsSecurityFlags                  mSecurityFlags;
   nsContentPolicyType              mInternalContentPolicyType;
   LoadTainting                     mTainting;
   bool                             mUpgradeInsecureRequests;
   bool                             mVerifySignedContent;
   bool                             mEnforceSRI;
   bool                             mForceInheritPrincipalDropped;
diff --git a/netwerk/base/nsILoadInfo.idl b/netwerk/base/nsILoadInfo.idl
--- a/netwerk/base/nsILoadInfo.idl
+++ b/netwerk/base/nsILoadInfo.idl
@@ -10,18 +10,28 @@
 interface nsIDOMDocument;
 interface nsINode;
 interface nsIPrincipal;
 
 %{C++
 #include "nsTArray.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/LoadTainting.h"
+#include "mozilla/UniquePtr.h"
 
 class nsCString;
+
+namespace mozilla {
+namespace dom {
+class ClientInfo;
+class ClientSource;
+class ServiceWorkerDescriptor;
+} // namespace dom
+} // namespace mozilla
+
 %}
 
 [ref] native const_nsIPrincipalArray(const nsTArray<nsCOMPtr<nsIPrincipal>>);
 native OriginAttributes(mozilla::OriginAttributes);
 [ref] native const_OriginAttributesRef(const mozilla::OriginAttributes);
 [ref] native StringArrayRef(const nsTArray<nsCString>);
 
 typedef unsigned long nsSecurityFlags;
@@ -742,9 +752,36 @@ interface nsILoadInfo : nsISupports
 
   /**
    * Returns the null principal of the resulting resource if the SEC_SANDBOXED
    * flag is set.  Otherwise returns null.  This is used by
    * GetChannelResultPrincipal() to ensure that the same null principal object
    * is returned every time.
    */
   [noscript] readonly attribute nsIPrincipal sandboxedLoadingPrincipal;
+
+%{ C++
+  // TODO: rename this to be clear its the window-only client source
+  virtual void
+  GiveReservedClient(mozilla::UniquePtr<mozilla::dom::ClientSource>&& aClientSource) = 0;
+
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeReservedClient() = 0;
+
+  virtual void
+  SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
+
+  virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
+  GetReservedClientInfo() const = 0;
+
+  virtual void
+  SetClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
+
+  virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
+  GetClientInfo() const = 0;
+
+  virtual void
+  SetController(const mozilla::dom::ServiceWorkerDescriptor& aServiceWorker) = 0;
+
+  virtual const mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor>&
+  GetController() const = 0;
+%}
 };
diff --git a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini b/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
+++ /dev/null
@@ -1,5 +0,0 @@
-[clients-matchall-client-types.https.html]
-  type: testharness
-  [Verify matchAll() with window and sharedworker client types]
-    expected: FAIL
-
diff --git a/testing/web-platform/tests/service-workers/service-worker/clients-matchall-client-types.https.html b/testing/web-platform/tests/service-workers/service-worker/clients-matchall-client-types.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/clients-matchall-client-types.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/clients-matchall-client-types.https.html
@@ -8,37 +8,42 @@ var scope = 'resources/clients-matchall-
 var iframe_url = scope + '-iframe.html';
 var shared_worker_url = scope + '-shared-worker.js';
 
 /* visibilityState, focused, url, frameType */
 var expected_only_window = [
     ['visible', true, new URL(iframe_url, location).href, 'window', 'nested']
 ];
 var expected_only_shared_worker = [
-    [,,new URL(shared_worker_url, location).href, 'sharedworker', 'none']
+    [undefined,undefined,new URL(shared_worker_url, location).href, 'sharedworker', 'none']
 ];
 var expected_window_and_shared_worker = [
     ['visible', true, new URL(iframe_url, location).href, 'window', 'nested'],
-    [,,new URL(shared_worker_url, location).href, 'sharedworker', 'none']
+    [undefined,undefined,new URL(shared_worker_url, location).href, 'sharedworker', 'none']
 ];
 
 function test_matchall(frame, expected, query_options) {
   // Make sure the frame gets focus.
   frame.focus();
   expected.sort(function(a, b) { return a[2] > b[2] ? 1 : -1; });
   return new Promise(function(resolve, reject) {
     var channel = new MessageChannel();
     channel.port1.onmessage = function(e) {
-      if (typeof e.data === 'string') {
-        return reject(e.data);
+      try {
+        if (typeof e.data === 'string') {
+          return reject(e.data);
+        }
+        assert_equals(e.data.length, expected.length);
+        for (var i = 0; i < e.data.length; i++) {
+          assert_array_equals(e.data[i], expected[i]);
+        }
+        resolve();
+      } catch (e) {
+        reject(e);
       }
-      assert_equals(e.data.length, expected.length);
-      for (var i = 0; i < e.data.length; i++)
-        assert_array_equals(e.data[i], expected[i]);
-      resolve();
     };
     frame.contentWindow.navigator.serviceWorker.controller.postMessage(
         {port:channel.port2, options:query_options},
         [channel.port2]);
   });
 }
 
 promise_test(function(t) {
