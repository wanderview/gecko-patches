# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a668bbeee4772ee8bcc1f3a52408a849908fb993

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -12442,42 +12442,31 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
     // timers that *should* have fired before aTimeout *will* be fired
     // now.
 
     deadline = aTimeout->mWhen;
   } else {
     deadline = now;
   }
 
-  static const uint32_t kMaxSequentialTimeouts = 10;
-
   // The timeout list is kept in deadline order. Discover the latest timeout
   // whose deadline has expired. On some platforms, native timeout events fire
   // "early", but we handled that above by setting deadline to aTimeout->mWhen
   // if the timer fired early.  So we can stop walking if we get to timeouts
   // whose mWhen is greater than deadline, since once that happens we know
   // nothing past that point is expired.
   last_expired_timeout = nullptr;
-  uint32_t count = 0;
   for (nsTimeout *timeout = mTimeouts.getFirst();
        timeout && timeout->mWhen <= deadline;
        timeout = timeout->getNext()) {
     if (timeout->mFiringDepth == 0) {
       // Mark any timeouts that are on the list to be fired with the
       // firing depth so that we can reentrantly run timeouts
       timeout->mFiringDepth = firingDepth;
       last_expired_timeout = timeout;
-
-      // Run a limited number of timers at once to avoid janking the main
-      // thread.  Any timers beyond this will get picked up on the next
-      // timer runnable which should fire immediately.
-      count += 1;
-      if (count > kMaxSequentialTimeouts) {
-        break;
-      }
     }
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_timeout) {
     return;
