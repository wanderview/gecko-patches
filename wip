# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5a8673596c857dd799a60a7a48de40b9b44d04f8

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3638,16 +3638,27 @@ nsGlobalWindow::DefineArgumentsProperty(
   return ctx->SetProperty(obj, "arguments", aArguments);
 }
 
 void
 nsGlobalWindow::MaybeApplyBackPressure()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
+  if (IsOuterWindow()) {
+    nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
+    if (!inner) {
+      return;
+    }
+    inner->MaybeApplyBackPressure();
+    return;
+  }
+
+  MOZ_ASSERT(IsInnerWindow());
+
   // If we are already suspended, then we don't need to apply back
   // pressure for ThrottledEventQueue reasons.  This also avoids repeatedly
   // calling SuspendTimeout() if this routine is executed many times
   // before dropping below the backpressure threshold.
   if (IsSuspended()) {
     return;
   }
 
@@ -3658,25 +3669,40 @@ nsGlobalWindow::MaybeApplyBackPressure()
 
   static const uint32_t kThrottledEventQueueBackPressure = 5000;
   if (taskQueue->Length() < kThrottledEventQueueBackPressure) {
     return;
   }
 
   // First attempt to queue a runnable to resume running timeouts.  We do
   // this first in order to verify we can dispatch successfully.
-  nsCOMPtr<nsIRunnable> r = NewRunnableMethod(this, &nsGlobalWindow::Resume);
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod(this, &nsGlobalWindow::RemoveBackPressure);
   nsresult rv = taskQueue->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS_VOID(rv);
 
   // Since the resume is dispatched we can go ahead and suspend the window
   // now.  Once the task queue drains the resume will automatically get
   // executed balancing this suspend.
-  // TODO: Consider suppressing event handling as well.
   Suspend();
+
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->SuppressEventHandling(nsIDocument::eEvents);
+  }
+}
+
+void
+nsGlobalWindow::RemoveBackPressure()
+{
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+  }
+  Resume();
 }
 
 //*****************************************************************************
 // nsGlobalWindow::nsIScriptObjectPrincipal
 //*****************************************************************************
 
 nsIPrincipal*
 nsGlobalWindow::GetPrincipal()
@@ -8553,16 +8579,23 @@ nsGlobalWindow::PostMessageMozOuter(JSCo
   JS::Rooted<JS::Value> message(aCx, aMessage);
   JS::Rooted<JS::Value> transfer(aCx, aTransfer);
 
   event->Write(aCx, message, transfer, JS::CloneDataPolicy(), aError);
   if (NS_WARN_IF(aError.Failed())) {
     return;
   }
 
+  nsCOMPtr<nsIEventTarget> teq = GetThrottledEventQueue();
+  if (teq) {
+    aError = teq->Dispatch(event.forget(), NS_DISPATCH_NORMAL);
+    MaybeApplyBackPressure();
+    return;
+  }
+
   aError = NS_DispatchToCurrentThread(event);
 }
 
 void
 nsGlobalWindow::PostMessageMoz(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                                const nsAString& aTargetOrigin,
                                JS::Handle<JS::Value> aTransfer,
                                nsIPrincipal& aSubjectPrincipal,
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1704,16 +1704,19 @@ private:
   friend class nsPIDOMWindow<nsISupports>;
 
   // Apply back pressure to the window if the TabGroup ThrottledEventQueue
   // exists and has too many runnables waiting to run.  For example, suspend
   // timers until we have a chance to catch up, etc.
   void
   MaybeApplyBackPressure();
 
+  void
+  RemoveBackPressure();
+
   mozilla::dom::TabGroup* TabGroupInner();
   mozilla::dom::TabGroup* TabGroupOuter();
 
 protected:
   // These members are only used on outer window objects. Make sure
   // you never set any of these on an inner object!
   bool                          mFullScreen : 1;
   bool                          mFullscreenMode : 1;
diff --git a/dom/broadcastchannel/BroadcastChannel.cpp b/dom/broadcastchannel/BroadcastChannel.cpp
--- a/dom/broadcastchannel/BroadcastChannel.cpp
+++ b/dom/broadcastchannel/BroadcastChannel.cpp
@@ -8,16 +8,17 @@
 #include "BroadcastChannelChild.h"
 #include "mozilla/dom/BroadcastChannelBinding.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/StructuredCloneHolder.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ThrottledEventQueue.h"
 #include "nsContentUtils.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
 #include "nsIBFCacheEntry.h"
 #include "nsIDocument.h"
 #include "nsISupportsPrimitives.h"
 
@@ -437,20 +438,20 @@ BroadcastChannel::PostMessageInternal(JS
 }
 
 void
 BroadcastChannel::PostMessageData(BroadcastChannelMessage* aData)
 {
   RemoveDocFromBFCache();
 
   if (mActor) {
-    RefPtr<BCPostMessageRunnable> runnable =
+    nsCOMPtr<nsIRunnable> runnable =
       new BCPostMessageRunnable(mActor, aData);
 
-    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+    if (NS_FAILED(DispatchToCurrentThread(runnable.forget()))) {
       NS_WARNING("Failed to dispatch to the current thread!");
     }
 
     return;
   }
 
   mPendingMessages.AppendElement(aData);
 }
@@ -463,19 +464,19 @@ BroadcastChannel::Close()
   }
 
   if (mPendingMessages.IsEmpty()) {
     // We cannot call Shutdown() immediatelly because we could have some
     // postMessage runnable already dispatched. Instead, we change the state to
     // StateClosed and we shutdown the actor asynchrounsly.
 
     mState = StateClosed;
-    RefPtr<CloseRunnable> runnable = new CloseRunnable(this);
+    nsCOMPtr<nsIRunnable> runnable = new CloseRunnable(this);
 
-    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+    if (NS_FAILED(DispatchToCurrentThread(runnable.forget()))) {
       NS_WARNING("Failed to dispatch to the current thread!");
     }
   } else {
     MOZ_ASSERT(!mActor);
     mState = StateClosing;
   }
 }
 
@@ -520,18 +521,18 @@ BroadcastChannel::Shutdown()
   mState = StateClosed;
 
   // The DTOR of this WorkerHolder will release the worker for us.
   mWorkerHolder = nullptr;
 
   if (mActor) {
     mActor->SetParent(nullptr);
 
-    RefPtr<TeardownRunnable> runnable = new TeardownRunnable(mActor);
-    NS_DispatchToCurrentThread(runnable);
+    nsCOMPtr<nsIRunnable> runnable = new TeardownRunnable(mActor);
+    DispatchToCurrentThread(runnable.forget());
 
     mActor = nullptr;
   }
 
   // If shutdown() is called we have to release the reference if we still keep
   // it.
   if (mIsKeptAlive) {
     mIsKeptAlive = false;
@@ -657,16 +658,27 @@ BroadcastChannel::RemoveDocFromBFCache()
   nsCOMPtr<nsIBFCacheEntry> bfCacheEntry = doc->GetBFCacheEntry();
   if (!bfCacheEntry) {
     return;
   }
 
   bfCacheEntry->RemoveFromBFCacheSync();
 }
 
+nsresult
+BroadcastChannel::DispatchToCurrentThread(already_AddRefed<nsIRunnable> aEvent)
+{
+  if (!NS_IsMainThread() || !GetOwner() || !GetOwner()->GetThrottledEventQueue()) {
+    return NS_DispatchToCurrentThread(Move(aEvent));
+  }
+
+  nsCOMPtr<nsIEventTarget> target = GetOwner()->GetThrottledEventQueue();
+  return target->Dispatch(Move(aEvent), NS_DISPATCH_NORMAL);
+}
+
 NS_IMPL_CYCLE_COLLECTION_CLASS(BroadcastChannel)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(BroadcastChannel,
                                                   DOMEventTargetHelper)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(BroadcastChannel,
                                                 DOMEventTargetHelper)
diff --git a/dom/broadcastchannel/BroadcastChannel.h b/dom/broadcastchannel/BroadcastChannel.h
--- a/dom/broadcastchannel/BroadcastChannel.h
+++ b/dom/broadcastchannel/BroadcastChannel.h
@@ -102,16 +102,19 @@ private:
 
   bool IsCertainlyAliveForCC() const override
   {
     return mIsKeptAlive;
   }
 
   void RemoveDocFromBFCache();
 
+  nsresult
+  DispatchToCurrentThread(already_AddRefed<nsIRunnable> aEvent);
+
   RefPtr<BroadcastChannelChild> mActor;
   nsTArray<RefPtr<BroadcastChannelMessage>> mPendingMessages;
 
   nsAutoPtr<workers::WorkerHolder> mWorkerHolder;
 
   nsAutoPtr<PrincipalInfo> mPrincipalInfo;
 
   nsCString mOrigin;
