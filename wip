# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d91344a03ff0d4f79c8967947078867d4c19d484
wip

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3441,16 +3441,36 @@ nsDocShell::MaybeCreateInitialClientSour
     ClientManager::CreateSource(ClientType::Window,
                                 win->EventTargetFor(TaskCategory::Other),
                                 principal);
 
   // Mark the initial client as execution ready, but owned by the docshell.
   // If the client is actually used this will cause ClientSource to force
   // the creation of the initial about:blank by calling nsDocShell::GetDocument().
   mInitialClientSource->DocShellExecutionReady(this);
+
+  // Next, check to see if the parent is controlled.
+  nsCOMPtr<nsIDocShell> parent = GetParentDocshell();
+  nsPIDOMWindowOuter* parentOuter = parent ? parent->GetWindow() : nullptr;
+  nsPIDOMWindowInner* parentInner = parentOuter ? parentOuter->GetCurrentInnerWindow() : nullptr;
+  if (!parentInner) {
+    return;
+  }
+
+  Maybe<ServiceWorkerDescriptor> controller(parentInner->GetController());
+  if (controller.isNothing()) {
+    return;
+  }
+
+  // If the parent is controlled then propagate that controller to the
+  // initial about:blank client as well.
+  RefPtr<ClientHandle> handle =
+    ClientManager::CreateHandle(mInitialClientSource->Info(),
+                                parentInner->EventTargetFor(TaskCategory::Other));
+  RefPtr<GenericPromise> ref = handle->Control(controller.ref());
 }
 
 Maybe<ClientInfo>
 nsDocShell::GetInitialClientInfo() const
 {
   if (mInitialClientSource) {
     Maybe<ClientInfo> result;
     result.emplace(mInitialClientSource->Info());
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -12,16 +12,19 @@
 
 // Local Includes
 #include "Navigator.h"
 #include "nsContentSecurityManager.h"
 #include "nsScreen.h"
 #include "nsHistory.h"
 #include "nsDOMNavigationTiming.h"
 #include "nsIDOMStorageManager.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
+#include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/LocalStorage.h"
 #include "mozilla/dom/Storage.h"
 #include "mozilla/dom/IdleRequest.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/StorageEvent.h"
 #include "mozilla/dom/StorageEventBinding.h"
 #include "mozilla/dom/StorageNotifierService.h"
 #include "mozilla/dom/StorageUtils.h"
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -1566,26 +1566,45 @@ nsGlobalWindowInner::EnsureClientSource(
     }
   }
 
   // If we don't have a reserved client or an initial client, then create
   // one now.  This can happen in certain cases where we avoid preallocating
   // the client in the docshell.  This mainly occurs in situations where
   // the principal is not clearly inherited from the parent; e.g. sandboxed
   // iframes, window.open(), etc.
+  // TODO: We may not be marking initial about:blank documents created
+  //       this way as controlled by a service worker properly.  The
+  //       controller should be coming from the same place as the inheritted
+  //       principal.  We do this in docshell, but as mentioned we aren't
+  //       smart enough to handle all cases yet.  For example, a
+  //       window.open() with new URL should inherit the controller from
+  //       the opener, but we probably don't handle that yet.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 EventTargetFor(TaskCategory::Other),
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
     newClientSource = true;
   }
 
+  // The load may have started controlling the Client as well.  If
+  // so mark it as controlled immediately here.  The actor may
+  // or may not have been notified by the parent side about being
+  // controlled yet.
+  if (loadInfo) {
+    const Maybe<ServiceWorkerDescriptor>& controller =
+      loadInfo->GetController();
+    if (controller.isSome()) {
+      mClientSource->SetController(controller.ref());
+    }
+  }
+
   // Its possible that we got a client just after being frozen in
   // the bfcache.  In that case freeze the client immediately.
   if (newClientSource && IsFrozen()) {
     mClientSource->Freeze();
   }
 
   return NS_OK;
 }
@@ -2094,16 +2113,28 @@ nsPIDOMWindowInner::SyncStateFromParentW
 }
 
 Maybe<ClientInfo>
 nsPIDOMWindowInner::GetClientInfo() const
 {
   return Move(nsGlobalWindowInner::Cast(this)->GetClientInfo());
 }
 
+Maybe<ClientState>
+nsPIDOMWindowInner::GetClientState() const
+{
+  return Move(nsGlobalWindowInner::Cast(this)->GetClientState());
+}
+
+Maybe<ServiceWorkerDescriptor>
+nsPIDOMWindowInner::GetController() const
+{
+  return Move(nsGlobalWindowInner::Cast(this)->GetController());
+}
+
 void
 nsGlobalWindowInner::UpdateTopInnerWindow()
 {
   if (!IsInnerWindow() || IsTopInnerWindow() || !mTopInnerWindow) {
     return;
   }
 
   mTopInnerWindow->UpdateWebSocketCount(-(int32_t)mNumOfOpenWebSockets);
@@ -6222,16 +6253,42 @@ nsGlobalWindowInner::GetClientInfo() con
   MOZ_ASSERT(NS_IsMainThread());
   Maybe<ClientInfo> clientInfo;
   if (mClientSource) {
     clientInfo.emplace(mClientSource->Info());
   }
   return Move(clientInfo);
 }
 
+Maybe<ClientState>
+nsGlobalWindowInner::GetClientState() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ClientState> clientState;
+  if (mClientSource) {
+    ClientState state;
+    nsresult rv = mClientSource->SnapshotState(&state);
+    if (NS_SUCCEEDED(rv)) {
+      clientState.emplace(state);
+    }
+  }
+  return Move(clientState);
+}
+
+Maybe<ServiceWorkerDescriptor>
+nsGlobalWindowInner::GetController() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ServiceWorkerDescriptor> controller;
+  if (mClientSource) {
+    controller = mClientSource->GetController();
+  }
+  return Move(controller);
+}
+
 nsresult
 nsGlobalWindowInner::FireDelayedDOMEvents()
 {
   if (mApplicationCache) {
     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
   }
 
   // Fires an offline status event if the offline status has changed
diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -368,16 +368,18 @@ public:
   void Resume();
   virtual bool IsSuspended() const override;
   void Freeze();
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
+  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
   virtual nsresult FireDelayedDOMEvents() override;
 
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
                                   nsISupports *aState,
                                   bool aForceReuseInnerWindow) override;
 
   virtual void SetOpenerWindow(nsPIDOMWindowOuter* aOpener,
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -42,20 +42,22 @@ class nsXBLPrototypeHandler;
 
 typedef uint32_t SuspendTypes;
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
 class AudioContext;
 class ClientInfo;
+class ClientState;
 class DocGroup;
 class TabGroup;
 class Element;
 class Performance;
+class ServiceWorkerDescriptor;
 class ServiceWorkerRegistration;
 class Timeout;
 class TimeoutManager;
 class CustomElementRegistry;
 enum class CallerType : uint32_t;
 } // namespace dom
 } // namespace mozilla
 
@@ -928,16 +930,18 @@ public:
   // Increase/Decrease the number of open WebSockets.
   void UpdateWebSocketCount(int32_t aDelta);
 
   // Return true if there are any open WebSockets that could block
   // timeout-throttling.
   bool HasOpenWebSockets() const;
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
+  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
   mozilla::dom::TabGroup* TabGroup();
 protected:
   void CreatePerformanceObjectIfNeeded();
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindowInner, NS_PIDOMWINDOWINNER_IID)
 
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -145,23 +145,21 @@ DOMInterfaces = {
 },
 
 'ChromeWorker': {
     'headerFile': 'mozilla/dom/WorkerPrivate.h',
     'nativeType': 'mozilla::dom::workers::ChromeWorkerPrivate',
 },
 
 'Client': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'Clients': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClients',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClients.h',
+    'nativeType': 'mozilla::dom::Clients',
 },
 
 'console': {
     'nativeType': 'mozilla::dom::Console',
 },
 
 'ConvolverNode': {
     'implicitJSContext': [ 'buffer' ],
@@ -1113,18 +1111,17 @@ DOMInterfaces = {
     'nativeType': 'mozilla::extensions::WebExtensionContentScript',
 },
 
 'WebExtensionPolicy': {
     'nativeType': 'mozilla::extensions::WebExtensionPolicy',
 },
 
 'WindowClient': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerWindowClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerWindowClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'WebGLActiveInfo': {
     'nativeType': 'mozilla::WebGLActiveInfo',
     'headerFile': 'WebGLActiveInfo.h'
 },
 
 'WebGLBuffer': {
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.cpp
@@ -0,0 +1,248 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Client.h"
+
+#include "ClientDOMUtil.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientState.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/WorkerScope.h"
+#include "nsIGlobalObject.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::dom::ipc::StructuredCloneData;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::Client);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::Client);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(mozilla::dom::Client, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(mozilla::dom::Client)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Client::~Client()
+{
+}
+
+void
+Client::EnsureHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(mozilla::dom::Client);
+  if (!mHandle) {
+    mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()),
+                                          mGlobal->EventTargetFor(TaskCategory::Other));
+  }
+}
+
+Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
+  : mGlobal(aGlobal)
+  , mData(MakeUnique<ClientInfoAndState>(aData))
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+TimeStamp
+Client::CreationTime() const
+{
+  return mData->info().creationTime();
+}
+
+TimeStamp
+Client::LastFocusTime() const
+{
+  if (mData->info().type() != ClientType::Window) {
+    return TimeStamp();
+  }
+  return mData->state().get_IPCClientWindowState().lastFocusTime();
+}
+
+JSObject*
+Client::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  if (mData->info().type() == ClientType::Window) {
+    return WindowClientBinding::Wrap(aCx, this, aGivenProto);
+  }
+  return ClientBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Client::GetParentObject() const
+{
+  return mGlobal;
+}
+
+void
+Client::GetUrl(nsAString& aUrlOut) const
+{
+  CopyUTF8toUTF16(mData->info().url(), aUrlOut);
+}
+
+void
+Client::GetId(nsAString& aIdOut) const
+{
+  char buf[NSID_LENGTH];
+  mData->info().id().ToProvidedString(buf);
+  NS_ConvertASCIItoUTF16 uuid(buf);
+
+  // Remove {} and the null terminator
+  aIdOut.Assign(Substring(uuid, 1, NSID_LENGTH - 3));
+}
+
+ClientType
+Client::Type() const
+{
+  return mData->info().type();
+}
+
+FrameType
+Client::GetFrameType() const
+{
+  return mData->info().frameType();
+}
+
+void
+Client::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+                    const Sequence<JSObject*>& aTransferable,
+                    ErrorResult& aRv)
+{
+  JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
+  aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
+                                                          &transferable);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  StructuredCloneData data;
+  data.Write(aCx, aMessage, transferable, aRv);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  ClientEndPoint endpoint;
+  aRv = ClientGetEndPoint(mGlobal, &endpoint);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  EnsureHandle();
+  RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
+}
+
+VisibilityState
+Client::GetVisibilityState() const
+{
+  return mData->state().get_IPCClientWindowState().visibilityState();
+}
+
+bool
+Client::Focused() const
+{
+  return mData->state().get_IPCClientWindowState().focused();
+}
+
+already_AddRefed<Promise>
+Client::Focus(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  aRv = ClientGetEndPoint(mGlobal, &endpoint);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  bool interactionAllowed = false;
+
+  if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_DIAGNOSTIC_ASSERT(workerPrivate);
+    interactionAllowed = workerPrivate->GlobalScope()->WindowInteractionAllowed();
+  } else {
+    // TODO: hook this up to the gPopupControlState code in nsGlobalWindow
+    interactionAllowed = false;
+  }
+
+  if (!interactionAllowed) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+    return outerPromise.forget();
+  }
+
+  EnsureHandle();
+
+  RefPtr<Client> self = this;
+
+  RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
+  innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
+    [self, outerPromise] (const ClientState& aResult) {
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+    }
+  }
+
+  RefPtr<Client> self = this;
+
+  ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+
+  StartClientManagerOp(&ClientManager::Navigate, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [self, outerPromise] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.h
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Client_h
+#define _mozilla_dom_Client_h
+
+#include "mozilla/dom/ClientBinding.h"
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class ClientHandle;
+class ClientInfoAndState;
+class Promise;
+
+template <typename t> class Sequence;
+
+class Client final : public nsISupports
+                   , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+  UniquePtr<ClientInfoAndState> mData;
+  RefPtr<ClientHandle> mHandle;
+
+  ~Client();
+
+  void
+  EnsureHandle();
+
+public:
+  Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData);
+
+  TimeStamp
+  CreationTime() const;
+
+  TimeStamp
+  LastFocusTime() const;
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  // Client Bindings
+  void
+  GetUrl(nsAString& aUrlOut) const;
+
+  void
+  GetId(nsAString& aIdOut) const;
+
+  ClientType
+  Type() const;
+
+  FrameType
+  GetFrameType() const;
+
+  // WindowClient bindings
+  VisibilityState
+  GetVisibilityState() const;
+
+  bool
+  Focused() const;
+
+  already_AddRefed<Promise>
+  Focus(ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Navigate(const nsAString& aURL, ErrorResult& aRv);
+
+  void
+  PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+              const Sequence<JSObject*>& aTransferrable,
+              ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(mozilla::dom::Client)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Client_h
diff --git a/dom/clients/api/ClientDOMUtil.cpp b/dom/clients/api/ClientDOMUtil.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.cpp
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientDOMUtil.h"
+
+namespace mozilla {
+namespace dom {
+
+nsresult
+ClientGetEndPoint(nsIGlobalObject* aGlobal, ClientEndPoint* aEndPointOut)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(aEndPointOut);
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  if (window) {
+    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
+    if (clientInfo.isSome()) {
+      *aEndPointOut = clientInfo.ref().ToIPC();
+      return NS_OK;
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      if (workerPrivate->IsServiceWorker()) {
+        *aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
+        return NS_OK;
+      } else {
+        *aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
+        return NS_OK;
+      }
+    }
+  }
+
+  return NS_ERROR_DOM_INVALID_STATE_ERR;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientDOMUtil_h
+#define _mozilla_dom_ClientDOMUtil_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+namespace dom {
+
+class ClientEndPoint;
+
+nsresult
+ClientGetEndPoint(nsIGlobalObject* aGlobal, ClientEndPoint* aEndPointOut);
+
+// TODO: Add a ClientHandle version of this wrapper for Client methods.
+template<typename Func, typename Arg, typename Resolve, typename Reject>
+void
+StartClientManagerOp(Func aFunc, const Arg& aArg, nsISerialEventTarget* aTarget,
+                     Resolve aResolve, Reject aReject)
+{
+  using mozilla::dom::workers::Closing;
+  using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+  using mozilla::dom::workers::WorkerHolderToken;
+
+  RefPtr<WorkerHolderToken> token;
+  if (!NS_IsMainThread()) {
+    token = WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Closing);
+  }
+
+  RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
+  promise->Then(aTarget, __func__,
+    [aResolve, token](const ClientOpResult& aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aResolve(aResult);
+    }, [aReject, token](nsresult aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aReject(aResult);
+    });
+}
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientDOMUtil_h
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.cpp
@@ -0,0 +1,294 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Clients.h"
+
+#include "ClientDOMUtil.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientsBinding.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "nsIGlobalObject.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::ipc::PrincipalInfo;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Clients);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Clients);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Clients, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Clients)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Clients::~Clients()
+{
+}
+
+Clients::Clients(nsIGlobalObject* aGlobal)
+  : mGlobal(aGlobal)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+JSObject*
+Clients::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  return ClientsBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Clients::GetParentObject() const
+{
+  return mGlobal;
+}
+
+already_AddRefed<Promise>
+Clients::Get(const nsAString& aClientID, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsID id;
+  if (!id.Parse(NS_ConvertUTF16toUTF8(aClientID).get())) {
+    // Invalid ID means we will definitely not find a match, so just
+    // resolve with undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
+  if (NS_FAILED(rv)) {
+    // If we can't get an endpoint then we don't have a recognizeable
+    // principal and we won't effectively match anything.  Resolve
+    // undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor
+      ? endpoint.get_IPCServiceWorkerDescriptor().principalInfo()
+      : endpoint.get_IPCClientInfo().principalInfo();
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+  nsCOMPtr<nsISerialEventTarget> target =
+    mGlobal->EventTargetFor(TaskCategory::Other);
+
+  RefPtr<ClientOpPromise> innerPromise =
+    ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
+                                   target);
+  innerPromise->Then(target, __func__,
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolve(
+        new Client(global, aResult.get_ClientInfoAndState()));
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    });
+
+  return outerPromise.forget();
+}
+
+namespace {
+
+class MatchAllComparator final
+{
+public:
+  bool
+  LessThan(Client* aLeft, Client* aRight) const
+  {
+    TimeStamp leftFocusTime = aLeft->LastFocusTime();
+    TimeStamp rightFocusTime = aRight->LastFocusTime();
+    // If the focus times are the same, then default to creation order.
+    // MatchAll should return oldest Clients first.
+    if (leftFocusTime == rightFocusTime) {
+      return aLeft->CreationTime() < aRight->CreationTime();
+    }
+
+    // Otherwise compare focus times.  We reverse the logic here so
+    // that the most recently focused window is first in the list.
+    if (!leftFocusTime.IsNull() && rightFocusTime.IsNull()) {
+      return true;
+    }
+    if (leftFocusTime.IsNull() && !rightFocusTime.IsNull()) {
+      return false;
+    }
+    return leftFocusTime > rightFocusTime;
+  }
+
+  bool
+  Equals(Client* aLeft, Client* aRight) const
+  {
+    return aLeft->LastFocusTime() == aRight->LastFocusTime() &&
+           aLeft->CreationTime() == aRight->CreationTime();
+  }
+};
+
+} // anonymous namespace
+
+already_AddRefed<Promise>
+Clients::MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return outerPromise.forget();
+  }
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  // We don't expose this reserved clients yet
+  const bool includeReserved = false;
+  ClientMatchAllArgs args(endpoint, aOptions.mType,
+                          aOptions.mIncludeUncontrolled,
+                          includeReserved);
+  StartClientManagerOp(&ClientManager::MatchAll, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      nsTArray<RefPtr<Client>> clientList;
+      for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
+        clientList.AppendElement(new Client(global, value));
+      }
+      clientList.Sort(MatchAllComparator());
+      outerPromise->MaybeResolve(clientList);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  if (aURL.EqualsLiteral("about:blank")) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_TYPE_ERR);
+    return outerPromise.forget();
+  }
+
+  bool interactionAllowed = false;
+
+  PrincipalInfo principalInfo;
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+    nsIDocument* doc = window->GetExtantDoc();
+    if (doc) {
+      nsIPrincipal* principal = doc->NodePrincipal();
+      if (principal) {
+        aRv = PrincipalToPrincipalInfo(principal, &principalInfo);
+        if (aRv.Failed()) {
+          return outerPromise.forget();
+        }
+      }
+    }
+    // TODO: hook this up to the gPopupControlState code in nsGlobalWindow
+    interactionAllowed = false;
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+      principalInfo = workerPrivate->GetPrincipalInfo();
+
+      interactionAllowed = workerPrivate->GlobalScope()->WindowInteractionAllowed();
+    }
+  }
+
+  if (!interactionAllowed) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+    return outerPromise.forget();
+  }
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  ClientOpenWindowArgs args(principalInfo, NS_ConvertUTF16toUTF8(aURL), baseURL);
+  StartClientManagerOp(&ClientManager::OpenWindow, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> client =
+        new Client(global, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(client);
+    }, [outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Clients::Claim(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  ClientEndPoint endpoint;
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
+  if (NS_FAILED(rv)) {
+    aRv.Throw(rv);
+    return outerPromise.forget();
+  }
+
+  if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  const IPCServiceWorkerDescriptor& serviceWorker =
+    endpoint.get_IPCServiceWorkerDescriptor();
+
+  if (serviceWorker.state() != ServiceWorkerState::Activating &&
+      serviceWorker.state() != ServiceWorkerState::Activated) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Clients.h b/dom/clients/api/Clients.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Clients_h
+#define _mozilla_dom_Clients_h
+
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+struct ClientQueryOptions;
+class Promise;
+
+class Clients final : public nsISupports
+                    , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+
+  ~Clients();
+
+public:
+  explicit Clients(nsIGlobalObject* aGlobal);
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  already_AddRefed<Promise>
+  Get(const nsAString& aClientID, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  OpenWindow(const nsAString& aURL, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Claim(ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Clients)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Clients_h
diff --git a/dom/clients/api/moz.build b/dom/clients/api/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/moz.build
@@ -0,0 +1,33 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'Client.h',
+  'Clients.h',
+]
+
+UNIFIED_SOURCES += [
+  'Client.cpp',
+  'ClientDOMUtil.cpp',
+  'Clients.cpp',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+  '/dom/workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -4,22 +4,26 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandle.h"
 
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
+#include "ClientState.h"
 #include "mozilla/dom/PClientManagerChild.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::dom::ipc::StructuredCloneData;
+
 ClientHandle::~ClientHandle()
 {
   Shutdown();
 }
 
 void
 ClientHandle::Shutdown()
 {
@@ -117,10 +121,64 @@ ClientHandle::Control(const ServiceWorke
     },
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
   return outerPromise.forget();
 }
 
+already_AddRefed<ClientStatePromise>
+ClientHandle::Focus()
+{
+  RefPtr<ClientStatePromise::Private> outerPromise =
+    new ClientStatePromise::Private(__func__);
+
+  RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
+
+  innerPromise->Then(mSerialEventTarget, __func__,
+    [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
+    }, [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    });
+
+  RefPtr<ClientStatePromise> ref = outerPromise.get();
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise>
+ClientHandle::PostMessage(StructuredCloneData& aData,
+                          const ClientEndPoint& aEndPoint)
+{
+  RefPtr<GenericPromise> ref;
+
+  ClientPostMessageArgs args;
+  args.endpoint() = aEndPoint;
+
+  // TODO: Ideally we should be able to wait for the actor to initialize,
+  //       but for now just fail the postMessage() if its not ready.  We
+  //       need a RefCounted version of the StructuredCloneData in order
+  //       to capture it in the lambda here.
+  if (!GetActor() ||
+      !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
+                                                      args.clonedData())) {
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<GenericPromise::Private> outerPromise =
+    new GenericPromise::Private(__func__);
+
+  RefPtr<ClientOpPromise> innerPromise = StartOp(args);
+  innerPromise->Then(mSerialEventTarget, __func__,
+    [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Resolve(true, __func__);
+    }, [outerPromise](const ClientOpResult& aResult) {
+      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    });
+
+  ref = outerPromise.get();
+  return ref.forget();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -14,22 +14,27 @@
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 namespace mozilla {
 
 namespace dom {
 
+class ClientEndPoint;
 class ClientManager;
 class ClientHandleChild;
 class ClientOpConstructorArgs;
 class PClientManagerChild;
 class ServiceWorkerDescriptor;
 
+namespace ipc {
+class StructuredCloneData;
+}
+
 // The ClientHandle allows code to take a simple ClientInfo struct and
 // convert it into a live actor-backed object attached to a particular
 // ClientSource somewhere in the browser.  If the ClientSource is
 // destroyed then the ClientHandle will simply begin to reject operations.
 // We do not currently provide a way to be notified when the ClientSource
 // is destroyed, but this could be added in the future.
 class ClientHandle final : public ClientThing<ClientHandleChild>
 {
@@ -65,15 +70,22 @@ public:
   Info() const;
 
   // Mark the ClientSource attached to this handle as controlled by the
   // given service worker.  The promise will resolve true if the ClientSource
   // is successfully marked or reject if the operation could not be completed.
   RefPtr<GenericPromise>
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
+  already_AddRefed<ClientStatePromise>
+  Focus();
+
+  already_AddRefed<GenericPromise>
+  PostMessage(ipc::StructuredCloneData& aData,
+              const ClientEndPoint& aEndPoint);
+
   NS_INLINE_DECL_REFCOUNTING(ClientHandle);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientHandle_h
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandleOpParent.h"
 
 #include "ClientHandleParent.h"
 #include "ClientSourceParent.h"
+#include "mozilla/dom/PClientManagerParent.h"
 
 namespace mozilla {
 namespace dom {
 
 ClientSourceParent*
 ClientHandleOpParent::GetSource() const
 {
   auto handle = static_cast<ClientHandleParent*>(Manager());
@@ -29,17 +30,43 @@ void
 ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   ClientSourceParent* source = GetSource();
   if (!source) {
     Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
-  RefPtr<ClientOpPromise> p = source->StartOp(aArgs);
+  RefPtr<ClientOpPromise> p;
+
+  // ClientPostMessageArgs can contain PBlob actors.  This means we
+  // can't just forward the args from one PBackground manager to
+  // another.  Instead, unpack the structured clone data and repack
+  // it into a new set of arguments.
+  if (aArgs.type() == ClientOpConstructorArgs::TClientPostMessageArgs) {
+    const ClientPostMessageArgs& orig = aArgs.get_ClientPostMessageArgs();
+
+    ClientPostMessageArgs rebuild;
+    rebuild.endpoint() = orig.endpoint();
+
+    StructuredCloneData data;
+    data.BorrowFromClonedMessageDataForBackgroundParent(orig.clonedData());
+    if (!data.BuildClonedMessageDataForBackgroundParent(source->Manager()->Manager(),
+                                                        rebuild.clonedData())) {
+      Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+      return;
+    }
+
+    p = source->StartOp(rebuild);
+  }
+
+  // Other argument types can just be forwarded straight through.
+  else {
+    p = source->StartOp(aArgs);
+  }
 
   // Capturing 'this' is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientHandleOpParent::Send__delete__(this, aResult);
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -45,39 +45,113 @@ struct IPCClientWorkerState
 };
 
 union IPCClientState
 {
   IPCClientWindowState;
   IPCClientWorkerState;
 };
 
+struct ClientInfoAndState
+{
+  IPCClientInfo info;
+  IPCClientState state;
+};
+
 struct ClientSourceExecutionReadyArgs
 {
   nsCString url;
   FrameType frameType;
 };
 
 struct ClientControlledArgs
 {
   IPCServiceWorkerDescriptor serviceWorker;
 };
 
+struct ClientFocusArgs
+{
+};
+
+struct ClientNavigateArgs
+{
+  IPCClientInfo target;
+  nsCString url;
+  nsCString baseURL;
+};
+
+union ClientEndPoint
+{
+  IPCClientInfo;
+  IPCServiceWorkerDescriptor;
+};
+
+struct ClientPostMessageArgs
+{
+  ClonedMessageData clonedData;
+  ClientEndPoint endpoint;
+};
+
+struct ClientGetStateArgs
+{
+};
+
+struct ClientMatchAllArgs
+{
+  ClientEndPoint endpoint;
+  ClientType type;
+  bool includeUncontrolled;
+  bool includeReserved;
+};
+
+struct ClientClaimArgs
+{
+  IPCServiceWorkerDescriptor serviceWorker;
+};
+
+struct ClientGetInfoAndStateArgs
+{
+  nsID id;
+  PrincipalInfo principalInfo;
+};
+
 struct ClientOpenWindowArgs
 {
+  PrincipalInfo principalInfo;
+  nsCString url;
+  nsCString baseURL;
 };
 
 union ClientOpConstructorArgs
 {
   ClientControlledArgs;
+  ClientFocusArgs;
+  ClientNavigateArgs;
+  ClientPostMessageArgs;
+  ClientGetStateArgs;
+  ClientMatchAllArgs;
+  ClientClaimArgs;
+  ClientGetInfoAndStateArgs;
+  ClientOpenWindowArgs;
+};
+
+struct ClientList
+{
+  ClientInfoAndState[] values;
 };
 
 struct ClientNavigateOpConstructorArgs
 {
+  PClientSource target;
+  nsCString url;
+  nsCString baseURL;
 };
 
 union ClientOpResult
 {
   nsresult;
+  IPCClientState;
+  ClientInfoAndState;
+  ClientList;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -240,10 +240,55 @@ ClientManager::CreateSource(ClientType a
 already_AddRefed<ClientHandle>
 ClientManager::CreateHandle(const ClientInfo& aClientInfo,
                             nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->CreateHandleInternal(aClientInfo, aSerialEventTarget);
 }
 
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::MatchAll(const ClientMatchAllArgs& aArgs,
+                        nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Claim(const ClientClaimArgs& aArgs,
+                     nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
+                               nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Navigate(const ClientNavigateArgs& aArgs,
+                        nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::OpenWindow(const ClientOpenWindowArgs& aArgs,
+                          nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -5,43 +5,50 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientManager_h
 #define _mozilla_dom_ClientManager_h
 
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/ClientThing.h"
 
 class nsIPrincipal;
+class nsIURI;
 
 namespace mozilla {
 namespace ipc {
 class PBackgroundChild;
 class PrincipalInfo;
 } // namespace ipc
 namespace dom {
 
+class ClientClaimArgs;
+class ClientGetInfoAndStateArgs;
 class ClientHandle;
 class ClientInfo;
 class ClientManagerChild;
+class ClientMatchAllArgs;
+class ClientNavigateArgs;
 class ClientOpConstructorArgs;
+class ClientOpenWindowArgs;
 class ClientSource;
 enum class ClientType : uint8_t;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
 // The ClientManager provides a per-thread singleton interface workering
 // with the client subsystem.  It allows globals to create ClientSource
 // objects.  It allows other parts of the system to attach to this globals
 // by creating ClientHandle objects.  The ClientManager also provides
 // methods for querying the list of clients active in the system.
 class ClientManager final : public ClientThing<ClientManagerChild>
 {
   friend class ClientManagerChild;
+  friend class ClientSource;
 
   ClientManager();
   ~ClientManager();
 
   // Utility method to trigger a shutdown of the ClientManager.  This
   // is called in various error conditions or when the last reference
   // is dropped.
   void
@@ -87,15 +94,31 @@ public:
   static UniquePtr<ClientSource>
   CreateSource(ClientType aType, nsISerialEventTarget* aEventTarget,
                const mozilla::ipc::PrincipalInfo& aPrincipal);
 
   static already_AddRefed<ClientHandle>
   CreateHandle(const ClientInfo& aClientInfo,
                nsISerialEventTarget* aSerialEventTarget);
 
+  static already_AddRefed<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs, nsISerialEventTarget* aTarget);
+
+  static already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs, nsISerialEventTarget* aTarget);
+
+  static already_AddRefed<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
+                  nsISerialEventTarget* aTarget);
+
+  static already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs, nsISerialEventTarget* aTarget);
+
+  static already_AddRefed<ClientOpPromise>
+  OpenWindow(const ClientOpenWindowArgs& aArgs, nsISerialEventTarget* aTarget);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
--- a/dom/clients/manager/ClientManagerChild.cpp
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerChild.h"
 
 #include "ClientHandleChild.h"
+#include "ClientManager.h"
 #include "ClientManagerOpChild.h"
 #include "ClientNavigateOpChild.h"
 #include "ClientSourceChild.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::workers::WorkerHolderToken;
@@ -115,24 +116,24 @@ ClientManagerChild::ClientManagerChild(W
   }
 }
 
 void
 ClientManagerChild::SetOwner(ClientThing<ClientManagerChild>* aThing)
 {
   MOZ_DIAGNOSTIC_ASSERT(aThing);
   MOZ_DIAGNOSTIC_ASSERT(!mManager);
-  mManager = aThing;
+  mManager = static_cast<ClientManager*>(aThing);
 }
 
 void
 ClientManagerChild::RevokeOwner(ClientThing<ClientManagerChild>* aThing)
 {
   MOZ_DIAGNOSTIC_ASSERT(mManager);
-  MOZ_DIAGNOSTIC_ASSERT(mManager == aThing);
+  MOZ_DIAGNOSTIC_ASSERT(mManager == static_cast<ClientManager*>(aThing));
   mManager = nullptr;
 }
 
 void
 ClientManagerChild::MaybeStartTeardown()
 {
   if (mTeardownStarted) {
     return;
diff --git a/dom/clients/manager/ClientManagerChild.h b/dom/clients/manager/ClientManagerChild.h
--- a/dom/clients/manager/ClientManagerChild.h
+++ b/dom/clients/manager/ClientManagerChild.h
@@ -1,31 +1,32 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientManagerChild_h
 #define _mozilla_dom_ClientManagerChild_h
 
-#include "ClientThing.h"
 #include "mozilla/dom/PClientManagerChild.h"
 #include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
 
 namespace mozilla {
 namespace dom {
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
 class ClientManagerChild final : public PClientManagerChild
                                , public mozilla::dom::workers::WorkerHolderToken::Listener
 {
-  ClientThing<ClientManagerChild>* mManager;
+  // Weak reference.  The ClientManager will call RevokeManager() when
+  // it is destroyed.
+  ClientManager* mManager;
 
   RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
   bool mTeardownStarted;
 
   // PClientManagerChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -2,30 +2,93 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerOpParent.h"
 
 #include "ClientManagerService.h"
+#include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::BackgroundParent;
+
+template <typename Method, typename... Args>
+void
+ClientManagerOpParent::DoServiceOp(Method aMethod, Args&&... aArgs)
+{
+  // Note, we need perfect forarding of the template type in order
+  // to allow already_AddRefed<> to be passed as an arg.
+  RefPtr<ClientOpPromise> p = (mService->*aMethod)(Forward<Args>(aArgs)...);
+
+  // Capturing `this` is safe here because we disconnect the promise in
+  // ActorDestroy() which ensures neither lambda is called if the actor
+  // is destroyed before the source operation completes.
+  p->Then(GetCurrentThreadSerialEventTarget(), __func__,
+    [this] (const mozilla::dom::ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientManagerOpParent::Send__delete__(this, aResult);
+    }, [this] (nsresult aRv) {
+      mPromiseRequestHolder.Complete();
+      Unused << PClientManagerOpParent::Send__delete__(this, aRv);
+    })->Track(mPromiseRequestHolder);
+}
+
 void
 ClientManagerOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  mPromiseRequestHolder.DisconnectIfExists();
 }
 
 ClientManagerOpParent::ClientManagerOpParent(ClientManagerService* aService)
   : mService(aService)
 {
   MOZ_DIAGNOSTIC_ASSERT(mService);
 }
 
 void
 ClientManagerOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
+  switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientNavigateArgs:
+    {
+      DoServiceOp(&ClientManagerService::Navigate,
+                  aArgs.get_ClientNavigateArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientMatchAllArgs:
+    {
+      DoServiceOp(&ClientManagerService::MatchAll,
+                  aArgs.get_ClientMatchAllArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientClaimArgs:
+    {
+      DoServiceOp(&ClientManagerService::Claim, aArgs.get_ClientClaimArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
+    {
+      DoServiceOp(&ClientManagerService::GetInfoAndState,
+                  aArgs.get_ClientGetInfoAndStateArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientOpenWindowArgs:
+    {
+      RefPtr<ContentParent> contentParent =
+        BackgroundParent::GetContentParent(Manager()->Manager());
+      DoServiceOp(&ClientManagerService::OpenWindow,
+                  aArgs.get_ClientOpenWindowArgs(), contentParent.forget());
+      break;
+    }
+    default:
+    {
+      MOZ_ASSERT_UNREACHABLE("Unknown Client operation!");
+      break;
+    }
+  }
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerOpParent.h b/dom/clients/manager/ClientManagerOpParent.h
--- a/dom/clients/manager/ClientManagerOpParent.h
+++ b/dom/clients/manager/ClientManagerOpParent.h
@@ -2,25 +2,31 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientManagerOpParent_h
 #define _mozilla_dom_ClientManagerOpParent_h
 
 #include "mozilla/dom/PClientManagerOpParent.h"
+#include "ClientOpPromise.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientManagerService;
 
 class ClientManagerOpParent final : public PClientManagerOpParent
 {
   RefPtr<ClientManagerService> mService;
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  template <typename Method, typename... Args>
+  void
+  DoServiceOp(Method aMethod, Args&&... aArgs);
 
   // PClientManagerOpParent interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
 public:
   explicit ClientManagerOpParent(ClientManagerService* aService);
   ~ClientManagerOpParent() = default;
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -1,19 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerService.h"
 
+#include "ClientNavigateOpParent.h"
+#include "ClientOpenWindowOpParent.h"
+#include "ClientOpenWindowUtils.h"
 #include "ClientSourceParent.h"
+#include "mozilla/dom/ContentParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
+#include "mozilla/Unused.h"
+#include "nsIXULRuntime.h"
+#include "nsProxyRelease.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 using mozilla::ipc::ContentPrincipalInfo;
 using mozilla::ipc::PrincipalInfo;
 
@@ -129,10 +136,352 @@ ClientManagerService::FindSource(const n
   if (source->IsFrozen() ||
       !MatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
     return nullptr;
   }
 
   return source;
 }
 
+already_AddRefed<ClientOpPromise>
+ClientManagerService::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.target().id(),
+                                          aArgs.target().principalInfo());
+  if (!source) {
+    // TODO: it would be really nice to specify a useful type error message here
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  PClientManagerParent* manager = source->Manager();
+  MOZ_DIAGNOSTIC_ASSERT(manager);
+
+  ClientNavigateOpConstructorArgs args;
+  args.url() = aArgs.url();
+  args.baseURL() = aArgs.baseURL();
+
+  // This is safe to do because the ClientSourceChild cannot directly delete
+  // itself.  Instead it sends a Teardown message to the parent which then
+  // calls delete.  That means we can be sure that we are not racing with
+  // source destruction here.
+  args.targetParent() = source;
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  ClientNavigateOpParent* op = new ClientNavigateOpParent(args, promise);
+  PClientNavigateOpParent* result =
+    manager->SendPClientNavigateOpConstructor(op, args);
+  if (!result) {
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise;
+  return ref.forget();
+}
+
+namespace
+{
+
+class PromiseListHolder final
+{
+  RefPtr<ClientOpPromise::Private> mResultPromise;
+  nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
+  nsTArray<ClientInfoAndState> mResultList;
+  uint32_t mOutstandingPromiseCount;
+
+  void
+  ProcessSuccess(const ClientInfoAndState& aResult)
+  {
+    mResultList.AppendElement(aResult);
+    ProcessCompletion();
+  }
+
+  void
+  ProcessCompletion()
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mOutstandingPromiseCount > 0);
+    mOutstandingPromiseCount -= 1;
+    MaybeFinish();
+  }
+
+  ~PromiseListHolder() = default;
+public:
+  PromiseListHolder()
+    : mResultPromise(new ClientOpPromise::Private(__func__))
+    , mOutstandingPromiseCount(0)
+  {
+  }
+
+  already_AddRefed<ClientOpPromise>
+  GetResultPromise()
+  {
+    RefPtr<PromiseListHolder> kungFuDeathGrip = this;
+    mResultPromise->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
+      [kungFuDeathGrip] (const ClientOpResult& aResult) { },
+      [kungFuDeathGrip] (nsresult aResult) { });
+
+    RefPtr<ClientOpPromise> ref = mResultPromise;
+    return ref.forget();
+  }
+
+  void
+  AddPromise(RefPtr<ClientOpPromise>&& aPromise)
+  {
+    mPromiseList.AppendElement(Move(aPromise));
+    MOZ_DIAGNOSTIC_ASSERT(mPromiseList.LastElement());
+    mOutstandingPromiseCount += 1;
+
+    RefPtr<PromiseListHolder> self(this);
+    mPromiseList.LastElement()->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
+      [self] (const ClientOpResult& aResult) {
+        // TODO: This is pretty clunky.  Try to figure out a better
+        //       wait for MatchAll() and Claim() to share this code
+        //       even though they expect different return values.
+        if (aResult.type() == ClientOpResult::TClientInfoAndState) {
+          self->ProcessSuccess(aResult.get_ClientInfoAndState());
+        } else {
+          self->ProcessCompletion();
+        }
+      }, [self] (nsresult aResult) {
+        self->ProcessCompletion();
+      });
+  }
+
+  void
+  MaybeFinish()
+  {
+    if (!mOutstandingPromiseCount) {
+      mResultPromise->Resolve(mResultList, __func__);
+    }
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(PromiseListHolder)
+};
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::MatchAll(const ClientMatchAllArgs& aArgs)
+{
+  AssertIsOnBackgroundThread();
+
+  const ClientEndPoint& endpoint = aArgs.endpoint();
+
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TIPCClientInfo
+      ? endpoint.get_IPCClientInfo().principalInfo()
+      : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
+
+  RefPtr<PromiseListHolder> promiseList = new PromiseListHolder();
+
+  for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
+    ClientSourceParent* source = iter.UserData();
+    MOZ_DIAGNOSTIC_ASSERT(source);
+
+    if (source->IsFrozen()) {
+      continue;
+    }
+
+    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
+      continue;
+    }
+
+    if (aArgs.type() != ClientType::All &&
+        source->Info().Type() != aArgs.type()) {
+      continue;
+    }
+
+    if (!aArgs.includeUncontrolled()) {
+      if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
+        continue;
+      }
+
+
+      const Maybe<ServiceWorkerDescriptor>& controller =
+        source->GetController();
+      if (controller.isNothing()) {
+        continue;
+      }
+
+      const IPCServiceWorkerDescriptor& serviceWorker =
+        endpoint.get_IPCServiceWorkerDescriptor();
+
+      if(controller.ref().Id() != serviceWorker.id() ||
+         controller.ref().Scope() != serviceWorker.scope()) {
+        continue;
+      }
+    }
+
+    if (!aArgs.includeReserved() && !source->ExecutionReady()) {
+      continue;
+    }
+
+    promiseList->AddPromise(
+      source->StartOp(Move(ClientGetInfoAndStateArgs(source->Info().Id(),
+                                                     source->Info().PrincipalInfo()))));
+  }
+
+  // Maybe finish the promise now in case we didn't find any matching clients.
+  promiseList->MaybeFinish();
+
+  return promiseList->GetResultPromise();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::Claim(const ClientClaimArgs& aArgs)
+{
+  AssertIsOnBackgroundThread();
+
+  const IPCServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
+  const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
+
+  RefPtr<PromiseListHolder> promiseList = new PromiseListHolder();
+
+  for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
+    ClientSourceParent* source = iter.UserData();
+    MOZ_DIAGNOSTIC_ASSERT(source);
+
+    if (source->IsFrozen()) {
+      continue;
+    }
+
+    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
+      continue;
+    }
+
+    const Maybe<ServiceWorkerDescriptor>& controller = source->GetController();
+    if (controller.isSome() &&
+        controller.ref().Scope() == serviceWorker.scope() &&
+        controller.ref().Id() == serviceWorker.id()) {
+      continue;
+    }
+
+    // TODO: This logic to determine if a service worker should control
+    //       a particular client should be moved to the ServiceWorkerManager.
+    //       This can't happen until the SWM is moved to the parent process,
+    //       though.
+    if (!source->ExecutionReady() ||
+        source->Info().Type() == ClientType::Serviceworker ||
+        source->Info().URL().Find(serviceWorker.scope()) != 0) {
+      continue;
+    }
+
+    promiseList->AddPromise(source->StartOp(aArgs));
+  }
+
+  // Maybe finish the promise now in case we didn't find any matching clients.
+  promiseList->MaybeFinish();
+
+  return promiseList->GetResultPromise();
+}
+
+RefPtr<ClientOpPromise>
+ClientManagerService::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.id(), aArgs.principalInfo());
+  if (!source) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  // TODO: maybe change this to just GetState from source and use local info?
+  return source->StartOp(aArgs);
+}
+
+namespace {
+
+class OpenWindowRunnable : public Runnable
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  const ClientOpenWindowArgs mArgs;
+  RefPtr<ContentParent> mSourceProcess;
+
+  ~OpenWindowRunnable()
+  {
+    NS_ReleaseOnMainThreadSystemGroup(mSourceProcess.forget());
+  }
+
+public:
+  OpenWindowRunnable(ClientOpPromise::Private* aPromise,
+                     const ClientOpenWindowArgs& aArgs,
+                     already_AddRefed<ContentParent> aSourceProcess)
+    : Runnable("ClientManagerService::OpenWindowRunnable")
+    , mPromise(aPromise)
+    , mArgs(aArgs)
+    , mSourceProcess(aSourceProcess)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    if (!BrowserTabsRemoteAutostart()) {
+      RefPtr<ClientOpPromise> p = ClientOpenWindowInCurrentProcess(mArgs);
+      p->ChainTo(mPromise.forget(), __func__);
+      return NS_OK;
+    }
+
+    RefPtr<ContentParent> targetProcess;
+
+    // Possibly try to open the window in the same process that called
+    // openWindow().  This is a temporary compat setting until the
+    // multi-e10s service worker refactor is complete.
+    if (Preferences::GetBool("dom.clients.openwindow_favors_same_process",
+                             false)) {
+      targetProcess = mSourceProcess;
+    }
+
+    // Otherwise, use our normal remote process selection mechanism for
+    // opening the window.  This will start a process if one is not
+    // present.
+    if (!targetProcess) {
+      targetProcess =
+        ContentParent::GetNewOrUsedBrowserProcess(NS_LITERAL_STRING(DEFAULT_REMOTE_TYPE),
+                                                  ContentParent::GetInitialProcessPriority(nullptr),
+                                                  nullptr);
+    }
+
+    ClientOpenWindowOpParent* actor =
+      new ClientOpenWindowOpParent(mArgs, mPromise);
+
+    // If this fails the actor will be automatically destroyed which will
+    // reject the promise.
+    Unused << targetProcess->SendPClientOpenWindowOpConstructor(actor, mArgs);
+
+    return NS_OK;
+  }
+};
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::OpenWindow(const ClientOpenWindowArgs& aArgs,
+                                 already_AddRefed<ContentParent> aSourceProcess)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  // TODO: How do we clean this up if bg thread and main thread shutdown?
+
+  nsCOMPtr<nsIRunnable> r = new OpenWindowRunnable(promise, aArgs,
+                                                   Move(aSourceProcess));
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other,
+                                            r.forget()));
+
+  RefPtr<ClientOpPromise> ref = promise;
+  return ref.forget();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -1,21 +1,25 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientManagerService_h
 #define _mozilla_dom_ClientManagerService_h
 
-#include "mozilla/ipc/PBackgroundSharedTypes.h"
+#include "ClientOpPromise.h"
 #include "nsDataHashtable.h"
 
 namespace mozilla {
 
+namespace ipc {
+class PrincipalInfo;
+}
+
 namespace dom {
 
 class ClientSourceParent;
 
 // Define a singleton service to manage client activity throughout the
 // browser.  This service runs on the PBackground thread.  To interact
 // it with it please use the ClientManager and ClientHandle classes.
 class ClientManagerService final
@@ -36,15 +40,31 @@ public:
 
   bool
   RemoveSource(ClientSourceParent* aSource);
 
   ClientSourceParent*
   FindSource(const nsID& aID,
              const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
+  already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs);
+
+  RefPtr<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  OpenWindow(const ClientOpenWindowArgs& aArgs,
+             already_AddRefed<ContentParent> aSourceProcess);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManagerService)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManagerService_h
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -1,23 +1,276 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientNavigateOpChild.h"
 
+#include "mozilla/Unused.h"
+#include "nsGlobalWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellLoadInfo.h"
+#include "nsIWebNavigation.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsNetUtil.h"
+
 namespace mozilla {
 namespace dom {
 
+namespace {
+
+class NavigateLoadListener final : public nsIWebProgressListener
+                                 , public nsSupportsWeakReference
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  RefPtr<nsPIDOMWindowOuter> mOuterWindow;
+  nsCOMPtr<nsIURI> mBaseURL;
+
+  ~NavigateLoadListener() = default;
+
+public:
+  NavigateLoadListener(ClientOpPromise::Private* aPromise,
+                       nsPIDOMWindowOuter* aOuterWindow,
+                       nsIURI* aBaseURL)
+    : mPromise(aPromise)
+    , mOuterWindow(aOuterWindow)
+    , mBaseURL(aBaseURL)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mOuterWindow);
+    MOZ_DIAGNOSTIC_ASSERT(mBaseURL);
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aResult) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+        !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
+    if (!channel) {
+      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIURI> channelURL;
+    nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
+    if (NS_FAILED(rv)) {
+      mPromise->Reject(rv, __func__);
+      return NS_OK;
+    }
+
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_DIAGNOSTIC_ASSERT(ssm);
+    rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      return NS_OK;
+    }
+
+    // TODO: legacy code only did this for same-origin, was that intentional
+    Unused << nsContentUtils::DispatchFocusChromeEvent(mOuterWindow);
+
+    // TODO: Not clear this progress listener guarantees following assertions...
+
+    nsPIDOMWindowInner* innerWindow = mOuterWindow->GetCurrentInnerWindow();
+    MOZ_DIAGNOSTIC_ASSERT(innerWindow);
+
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
+
+    Maybe<ClientState> clientState = innerWindow->GetClientState();
+    MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
+
+    mPromise->Resolve(ClientInfoAndState(clientInfo.ref().ToIPC(),
+                                         clientState.ref().ToIPC()), __func__);
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   nsIURI* aLocation, uint32_t aFlags) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(NavigateLoadListener, nsIWebProgressListener,
+                                        nsISupportsWeakReference);
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientNavigateOpChild::DoNavigate(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceChild* targetActor =
+    static_cast<ClientSourceChild*>(aArgs.targetChild());
+  MOZ_DIAGNOSTIC_ASSERT(targetActor);
+
+  ClientSource* target = targetActor->GetSource();
+  if (!target) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  nsPIDOMWindowInner* window = target->GetInnerWindow();
+  if (!window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  mSerialEventTarget = window->EventTargetFor(TaskCategory::Other);
+
+  // In theory we could do the URL work before paying the IPC overhead
+  // cost, but in practice its easier to do it here.  The ClientHandle
+  // may be off-main-thread while this method is guaranteed to always
+  // be main thread.
+  nsCOMPtr<nsIURI> baseURL;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIURI> url;
+  rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  if (url->GetSpecOrDefault().EqualsLiteral("about:blank")) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+  if (!doc || !doc->IsActive()) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (!principal) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+  if (!docShell || !webProgress) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
+  rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  loadInfo->SetTriggeringPrincipal(principal);
+  loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
+  loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContent);
+  loadInfo->SetSourceDocShell(docShell);
+  rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  nsCOMPtr<nsIWebProgressListener> listener =
+    new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_FAILED(rv)) {
+    promise->Reject(rv, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise.get();
+
+  ref->Then(mSerialEventTarget, __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+
+  return ref.forget();
+}
+
 void
 ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientNavigateOpChild::Init(const ClientNavigateOpConstructorArgs& aArgs)
 {
+  RefPtr<ClientOpPromise> promise = DoNavigate(aArgs);
+
+  // Normally we get the event target from the window in DoNavigate().  If a
+  // failure occurred, though, we may need to fall back to the current thread
+  // target.
+  if (!mSerialEventTarget) {
+    mSerialEventTarget = GetCurrentThreadSerialEventTarget();
+  }
+
+  promise->Then(mSerialEventTarget, __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpChild.h b/dom/clients/manager/ClientNavigateOpChild.h
--- a/dom/clients/manager/ClientNavigateOpChild.h
+++ b/dom/clients/manager/ClientNavigateOpChild.h
@@ -2,22 +2,31 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientNavigateOpChild_h
 #define _mozilla_dom_ClientNavigateOpChild_h
 
 #include "mozilla/dom/PClientNavigateOpChild.h"
+#include "ClientOpPromise.h"
 
 namespace mozilla {
 namespace dom {
 
+class ClientSource;
+
 class ClientNavigateOpChild final : public PClientNavigateOpChild
 {
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
+
+  already_AddRefed<ClientOpPromise>
+  DoNavigate(const ClientNavigateOpConstructorArgs& aArgs);
+
   // PClientNavigateOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
 public:
   ClientNavigateOpChild() = default;
   ~ClientNavigateOpChild() = default;
 
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
--- a/dom/clients/manager/ClientNavigateOpParent.cpp
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -9,16 +9,20 @@
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ClientNavigateOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
 }
 
 IPCResult
 ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
   if (aResult.type() == ClientOpResult::Tnsresult &&
       NS_FAILED(aResult.get_nsresult())) {
     mPromise->Reject(aResult.get_nsresult(), __func__);
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
--- a/dom/clients/manager/ClientOpenWindowOpChild.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -1,23 +1,43 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientOpenWindowOpChild.h"
+#include "ClientOpenWindowUtils.h"
+#include "mozilla/SystemGroup.h"
 
 namespace mozilla {
 namespace dom {
 
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowOpChild::DoOpenWindow(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref =
+    ClientOpenWindowInCurrentProcess(aArgs);
+  return ref.forget();
+}
+
 void
 ClientOpenWindowOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
 {
+  RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
+  promise->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientOpenWindowOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientOpenWindowOpChild::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.h b/dom/clients/manager/ClientOpenWindowOpChild.h
--- a/dom/clients/manager/ClientOpenWindowOpChild.h
+++ b/dom/clients/manager/ClientOpenWindowOpChild.h
@@ -2,22 +2,30 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientOpenWindowOpChild_h
 #define _mozilla_dom_ClientOpenWindowOpChild_h
 
 #include "mozilla/dom/PClientOpenWindowOpChild.h"
+#include "ClientOpPromise.h"
 
 namespace mozilla {
 namespace dom {
 
+class ClientSource;
+
 class ClientOpenWindowOpChild final : public PClientOpenWindowOpChild
 {
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  already_AddRefed<ClientOpPromise>
+  DoOpenWindow(const ClientOpenWindowArgs& aArgs);
+
   // PClientOpenWindowOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
 public:
   ClientOpenWindowOpChild() = default;
   ~ClientOpenWindowOpChild() = default;
 
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -0,0 +1,464 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientOpenWindowUtils.h"
+
+#include "ClientInfo.h"
+#include "ClientState.h"
+#include "nsContentUtils.h"
+#include "nsIBrowserDOMWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDOMChromeWindow.h"
+#include "nsIURI.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsIWindowWatcher.h"
+#include "nsNetUtil.h"
+#include "nsPIDOMWindow.h"
+#include "nsPIWindowWatcher.h"
+
+#ifdef MOZ_WIDGET_ANDROID
+#include "FennecJNIWrappers.h"
+#endif
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class WebProgressListener final : public nsIWebProgressListener
+                                , public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  WebProgressListener(nsPIDOMWindowOuter* aWindow,
+                      nsIURI* aBaseURI,
+                      already_AddRefed<ClientOpPromise::Private> aPromise)
+  : mPromise(aPromise)
+  , mWindow(aWindow)
+  , mBaseURI(aBaseURI)
+  {
+    MOZ_ASSERT(aWindow);
+    MOZ_ASSERT(aWindow->IsOuterWindow());
+    MOZ_ASSERT(aBaseURI);
+    MOZ_ASSERT(NS_IsMainThread());
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress,
+                nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aStatus) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+         !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    // Our caller keeps a strong reference, so it is safe to remove the listener
+    // from ServiceWorkerPrivate.
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
+    if (NS_WARN_IF(!doc)) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    // Check same origin.
+    nsCOMPtr<nsIScriptSecurityManager> securityManager =
+      nsContentUtils::GetSecurityManager();
+    nsresult rv = securityManager->CheckSameOriginURI(doc->GetOriginalURI(),
+                                                      mBaseURI, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    Maybe<ClientInfo> info = innerWindow->GetClientInfo();
+    Maybe<ClientState> state = innerWindow->GetClientState();
+
+    if (NS_WARN_IF(info.isNothing() || state.isNothing())) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    mPromise->Resolve(ClientInfoAndState(info.ref().ToIPC(), state.ref().ToIPC()),
+                      __func__);
+    mPromise = nullptr;
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   int32_t aCurSelfProgress,
+                   int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress,
+                   int32_t aMaxTotalProgress) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   nsIURI* aLocation,
+                   uint32_t aFlags) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress,
+                 nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+private:
+  ~WebProgressListener()
+  {
+    if (mPromise) {
+      mPromise->Reject(NS_ERROR_ABORT, __func__);
+      mPromise = nullptr;
+    }
+  }
+
+  RefPtr<ClientOpPromise::Private> mPromise;
+  // TODO: make window a weak ref and stop cycle collecting
+  nsCOMPtr<nsPIDOMWindowOuter> mWindow;
+  nsCOMPtr<nsIURI> mBaseURI;
+};
+
+NS_IMPL_ISUPPORTS(WebProgressListener, nsIWebProgressListener,
+                                       nsISupportsWeakReference);
+
+nsresult
+OpenWindow(const ClientOpenWindowArgs& aArgs,
+           nsPIDOMWindowOuter** aWindow)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWindow);
+
+  // [[1. Let url be the result of parsing url with entry settings object's API
+  //   base URL.]]
+  nsCOMPtr<nsIURI> uri;
+
+  nsCOMPtr<nsIURI> baseURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NS_ERROR_TYPE_ERR;
+  }
+
+  rv = NS_NewURI(getter_AddRefs(uri), aArgs.url(), nullptr, baseURI);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NS_ERROR_TYPE_ERR;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aArgs.principalInfo());
+  MOZ_DIAGNOSTIC_ASSERT(principal);
+
+  // [[6.1 Open Window]]
+  if (XRE_IsContentProcess()) {
+
+    // Let's create a sandbox in order to have a valid JSContext and correctly
+    // propagate the SubjectPrincipal.
+    AutoJSAPI jsapi;
+    jsapi.Init();
+
+    JSContext* cx = jsapi.cx();
+
+    nsIXPConnect* xpc = nsContentUtils::XPConnect();
+    MOZ_DIAGNOSTIC_ASSERT(xpc);
+
+    JS::Rooted<JSObject*> sandbox(cx);
+    rv = xpc->CreateSandbox(cx, principal, sandbox.address());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return NS_ERROR_TYPE_ERR;
+    }
+
+    JSAutoCompartment ac(cx, sandbox);
+
+    // ContentProcess
+    nsCOMPtr<nsIWindowWatcher> wwatch =
+      do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+    nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
+    NS_ENSURE_STATE(pwwatch);
+
+    nsCString spec;
+    rv = uri->GetSpec(spec);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    nsCOMPtr<mozIDOMWindowProxy> newWindow;
+    rv = pwwatch->OpenWindow2(nullptr,
+                              spec.get(),
+                              nullptr,
+                              nullptr,
+                              false, false, true, nullptr,
+                              // Not a spammy popup; we got permission, we swear!
+                              /* aIsPopupSpam = */ false,
+                              // Don't force noopener.  We're not passing in an
+                              // opener anyway, and we _do_ want the returned
+                              // window.
+                              /* aForceNoOpener = */ false,
+                              /* aLoadInfp = */ nullptr,
+                              getter_AddRefs(newWindow));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+    nsCOMPtr<nsPIDOMWindowOuter> pwindow = nsPIDOMWindowOuter::From(newWindow);
+    pwindow.forget(aWindow);
+    MOZ_DIAGNOSTIC_ASSERT(*aWindow);
+    return NS_OK;
+  }
+
+  // Find the most recent browser window and open a new tab in it.
+  nsCOMPtr<nsPIDOMWindowOuter> browserWindow =
+    nsContentUtils::GetMostRecentNonPBWindow();
+  if (!browserWindow) {
+    // It is possible to be running without a browser window on Mac OS, so
+    // we need to open a new chrome window.
+    // TODO(catalinb): open new chrome window. Bug 1218080
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  nsCOMPtr<nsIDOMChromeWindow> chromeWin = do_QueryInterface(browserWindow);
+  if (NS_WARN_IF(!chromeWin)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIBrowserDOMWindow> bwin;
+  chromeWin->GetBrowserDOMWindow(getter_AddRefs(bwin));
+
+  if (NS_WARN_IF(!bwin)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<mozIDOMWindowProxy> win;
+  rv = bwin->OpenURI(uri, nullptr,
+                     nsIBrowserDOMWindow::OPEN_DEFAULTWINDOW,
+                     nsIBrowserDOMWindow::OPEN_NEW,
+                     principal,
+                     getter_AddRefs(win));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  NS_ENSURE_STATE(win);
+
+  nsCOMPtr<nsPIDOMWindowOuter> pWin = nsPIDOMWindowOuter::From(win);
+  pWin.forget(aWindow);
+  MOZ_DIAGNOSTIC_ASSERT(*aWindow);
+
+  return NS_OK;
+}
+
+void
+WaitForLoad(const ClientOpenWindowArgs& aArgs,
+            nsPIDOMWindowOuter* aOuterWindow,
+            ClientOpPromise::Private* aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aOuterWindow);
+
+  RefPtr<ClientOpPromise::Private> promise = aPromise;
+
+  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    promise->Reject(rv, __func__);
+    return;
+  }
+
+  nsCOMPtr<nsIURI> baseURI;
+  rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    promise->Reject(rv, __func__);
+    return;
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = aOuterWindow->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+
+  if (NS_WARN_IF(!webProgress)) {
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    return;
+  }
+
+  RefPtr<ClientOpPromise> ref = promise;
+
+  RefPtr<WebProgressListener> listener =
+    new WebProgressListener(aOuterWindow, baseURI, promise.forget());
+
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    promise->Reject(rv, __func__);
+    return;
+  }
+
+  // Hold the listener alive until the promise settles
+  ref->Then(aOuterWindow->EventTargetFor(TaskCategory::Other), __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+}
+
+#ifdef MOZ_WIDGET_ANDROID
+
+class LaunchObserver final : public nsIObserver
+{
+  RefPtr<GenericPromise::Private> mPromise;
+
+  LaunchObserver()
+    : mPromise(new GenericPromise::Private(__func__))
+  {
+  }
+
+  ~LaunchObserver() = default;
+
+  NS_IMETHOD
+  Observe(nsISupports* aSubject, const char* aTopic, const char16_t * aData) override
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (os) {
+      os->RemoveObserver(this, "BrowserChrome:Ready");
+    }
+    mPromise->Resolve(true, __func__);
+    return NS_OK;
+  }
+
+public:
+  static already_AddRefed<LaunchObserver>
+  Create()
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (NS_WARN_IF(!os)) {
+      return nullptr;
+    }
+
+    RefPtr<LaunchObserver> ref = new LaunchObserver();
+
+    nsresult rv = os->AddObserver(ref, "BrowserChrome:Ready", /* weakRef */ false);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    return ref.forget();
+  }
+
+  void
+  Cancel()
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (os) {
+      os->RemoveObserver(this, "BrowserChrome:Ready");
+    }
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+  }
+
+  GenericPromise*
+  Promise()
+  {
+    return mPromise;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(LaunchObserver, nsIObserver);
+
+#endif // MOZ_WIDGET_ANDROID
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+  RefPtr<ClientOpPromise> ref = promise;
+
+#ifdef MOZ_WIDGET_ANDROID
+  // This fires an intent that will start launching Fennec and foreground it,
+  // if necessary.  We create an observer so that we can determine when
+  // the launch has completed.
+  RefPtr<LaunchObserver> launchObserver = LaunchObserver::Create();
+  java::GeckoApp::LaunchOrBringToFront();
+#endif // MOZ_WIDGET_ANDROID
+
+  nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
+  nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+
+#ifdef MOZ_WIDGET_ANDROID
+  // If we get the NOT_AVAILABLE error that means the browser is still
+  // launching on android.  Use the observer we created above to wait
+  // until the launch completes and then try to open the window again.
+  if (rv == NS_ERROR_NOT_AVAILABLE && launchObserver) {
+    RefPtr<GenericPromise> p = launchObserver->Promise();
+    p->Then(outerWindow->EventTargetFor(TaskCategory::Other), __func__,
+      [aArgs, promise] (bool aResult) {
+        nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
+        nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          promise->Reject(rv, __func__);
+        }
+
+        WaitForLoad(aArgs, outerWindow, promise);
+      }, [promise] (nsresult aResult) {
+        promise->Reject(aResult, __func__);
+      });
+    return ref.forget();
+  }
+
+  // If we didn't get the NOT_AVAILABLE error then there is no need
+  // wait for the browser to launch.  Cancel the observer so that it
+  // will release.
+  if (launchObserver) {
+    launchObserver->Cancel();
+  }
+#endif // MOZ_WIDGET_ANDROID
+
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    promise->Reject(rv, __func__);
+    return ref.forget();
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(outerWindow);
+  WaitForLoad(aArgs, outerWindow, promise);
+
+  return ref.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowUtils.h b/dom/clients/manager/ClientOpenWindowUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowUtils.h
@@ -0,0 +1,21 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpenWindowUtils_h
+#define _mozilla_dom_ClientOpenWindowUtils_h
+
+#include "ClientOpPromise.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs &aArgs);
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpenWindowUtils_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -6,25 +6,39 @@
 
 #include "ClientSource.h"
 
 #include "ClientManager.h"
 #include "ClientManagerChild.h"
 #include "ClientSourceChild.h"
 #include "ClientValidation.h"
 #include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+#include "mozilla/dom/MessageEvent.h"
+#include "mozilla/dom/MessageEventBinding.h"
+#include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/WorkerScope.h"
+#include "mozilla/dom/ServiceWorkerContainer.h"
+#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/workers/bindings/ServiceWorker.h"
+#include "nsContentUtils.h"
 #include "nsIDocShell.h"
 #include "nsPIDOMWindow.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::dom::ipc::StructuredCloneData;
+using mozilla::dom::workers::ServiceWorkerInfo;
+using mozilla::dom::workers::ServiceWorkerManager;
+using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
 using mozilla::dom::workers::WorkerPrivate;
 using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalInfoToPrincipal;
 
 void
 ClientSource::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   if (IsShutdown()) {
     return;
   }
@@ -49,16 +63,47 @@ ClientSource::ExecutionReady(const Clien
 
   mClientInfo.SetURL(aArgs.url());
   mClientInfo.SetFrameType(aArgs.frameType());
   MaybeExecute([aArgs](PClientSourceChild* aActor) {
     aActor->SendExecutionReady(aArgs);
   });
 }
 
+nsresult
+ClientSource::SnapshotWindowState(ClientState* aStateOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (!window || !window->IsCurrentInnerWindow() ||
+      !window->HasActiveDocument()) {
+    *aStateOut = ClientState(ClientWindowState(VisibilityState::Hidden,
+                                               TimeStamp(), false));
+    return NS_OK;
+  }
+
+  nsIDocument* doc = window->GetExtantDoc();
+  if (NS_WARN_IF(!doc)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  ErrorResult rv;
+  bool focused = doc->HasFocus(rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    rv.SuppressException();
+    return rv.StealNSResult();
+  }
+
+  *aStateOut = ClientState(ClientWindowState(doc->VisibilityState(),
+                                             doc->LastFocusTime(), focused));
+
+  return NS_OK;
+}
+
 WorkerPrivate*
 ClientSource::GetWorkerPrivate() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   if (!mOwner.is<WorkerPrivate*>()) {
     return nullptr;
   }
   return mOwner.as<WorkerPrivate*>();
@@ -69,16 +114,28 @@ ClientSource::GetDocShell() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   if (!mOwner.is<nsCOMPtr<nsIDocShell>>()) {
     return nullptr;
   }
   return mOwner.as<nsCOMPtr<nsIDocShell>>();
 }
 
+void
+ClientSource::MaybeCreateInitialDocument()
+{
+  nsIDocShell* docshell = GetDocShell();
+  if (docshell) {
+    // Force the create of the initial document if it does not exist yet.
+    Unused << docshell->GetDocument();
+
+    MOZ_DIAGNOSTIC_ASSERT(GetInnerWindow());
+  }
+}
+
 ClientSource::ClientSource(ClientManager* aManager,
                            nsISerialEventTarget* aEventTarget,
                            const ClientSourceConstructorArgs& aArgs)
   : mManager(aManager)
   , mEventTarget(aEventTarget)
   , mOwner(AsVariant(Nothing()))
   , mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
 {
@@ -253,26 +310,54 @@ ClientSource::Thaw()
 
 const ClientInfo&
 ClientSource::Info() const
 {
   return mClientInfo;
 }
 
 void
+ClientSource::WorkerSyncPing(WorkerPrivate* aWorkerPrivate)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate == mManager->GetWorkerPrivate());
+  aWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(GetActor());
+  GetActor()->SendWorkerSyncPing();
+}
+
+void
 ClientSource::SetController(const ServiceWorkerDescriptor& aServiceWorker)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   if (mController.isSome() && mController.ref() == aServiceWorker) {
     return;
   }
 
   mController.reset();
   mController.emplace(aServiceWorker);
+
+  RefPtr<ServiceWorkerContainer> swc;
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (window) {
+    RefPtr<Navigator> navigator =
+      static_cast<Navigator*>(window->GetNavigator());
+    if (navigator) {
+      swc = navigator->ServiceWorker();
+    }
+  }
+
+  // TODO: Also self.navigator.serviceWorker on workers when its exposed there
+
+  if (swc && nsContentUtils::IsSafeToRunScript()) {
+    IgnoredErrorResult ignored;
+    swc->ControllerChanged(ignored);
+  }
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
@@ -283,16 +368,309 @@ ClientSource::Control(const ClientContro
 }
 
 const Maybe<ServiceWorkerDescriptor>&
 ClientSource::GetController() const
 {
   return mController;
 }
 
+already_AddRefed<ClientOpPromise>
+ClientSource::Focus(const ClientFocusArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+
+  RefPtr<ClientOpPromise> ref;
+
+  if (mClientInfo.Type() != ClientType::Window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  nsPIDOMWindowOuter* outer = nullptr;
+
+  nsPIDOMWindowInner* inner = GetInnerWindow();
+  if (inner) {
+    outer = inner->GetOuterWindow();
+  } else {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      outer = docshell->GetWindow();
+    }
+  }
+
+  if (!outer) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(outer);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ClientState state;
+  rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  RefPtr<ClientOpPromise> ref;
+
+  const ClientEndPoint& endpoint = aArgs.endpoint();
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TIPCClientInfo
+      ? endpoint.get_IPCClientInfo().principalInfo()
+      : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
+
+  // TODO: this should probably not require strict spec matching
+  if (false && !(mClientInfo.PrincipalInfo() == principalInfo)) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  StructuredCloneData clonedData;
+  clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
+
+  RefPtr<ServiceWorkerContainer> target;
+  nsCOMPtr<nsIGlobalObject> globalObject;
+  if (mClientInfo.Type() == ClientType::Window) {
+    MOZ_ASSERT(NS_IsMainThread());
+    // We don't need to force the creation of the about:blank document
+    // here because there is no postMessage listener.  If a listener
+    // was registered then the document will already be created.
+    nsPIDOMWindowInner* window = GetInnerWindow();
+    if (window) {
+      globalObject = do_QueryInterface(window);
+      RefPtr<Navigator> navigator =
+        static_cast<Navigator*>(window->GetNavigator());
+      if (navigator) {
+        target = navigator->ServiceWorker();
+      }
+    }
+  } else {
+    WorkerPrivate* wp = GetWorkerPrivate();
+    if (wp) {
+      wp->AssertIsOnWorkerThread();
+      JSContext* cx = wp->GetJSContext();
+      if (cx) {
+        JSObject* global = JS::CurrentGlobalOrNull(cx);
+        if (global) {
+          globalObject = xpc::NativeGlobal(global);
+        } else {
+          globalObject = wp->GlobalScope();
+        }
+      }
+      // TODO: Set target to self.navigator.serviceWorker on workers when its exposed there
+    }
+  }
+
+  if (!target) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_NOT_IMPLEMENTED, __func__);
+    return ref.forget();
+  }
+
+  // If AutoJSAPI::Init() fails then either global is nullptr or not
+  // in a usable state.  Treat this as a postMessage() before ExecutionReady
+  // and just queue the message.  We will deliver the messages later
+  // when the Client is marked ExecutionReady.
+  AutoJSAPI jsapi;
+  if (!jsapi.Init(globalObject)) {
+    // TODO: queue messages until ExecutionReady
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  JSContext* cx = jsapi.cx();
+
+  ErrorResult result;
+  JS::Rooted<JS::Value> messageData(cx);
+  clonedData.Read(cx, &messageData, result);
+  if (result.MaybeSetPendingException(cx)) {
+    // We reported the error in the current window context.  Resolve
+    // promise instead of rejecting.
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  RootedDictionary<MessageEventInit> init(cx);
+
+  init.mData = messageData;
+  if (!clonedData.TakeTransferredPortsAsSequence(init.mPorts)) {
+    // Report the error in the current window context and resolve the
+    // promise instead of rejecting.
+    xpc::Throw(cx, NS_ERROR_OUT_OF_MEMORY);
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  // Currently we only support firing these messages on window Clients.
+  // Once we expose ServiceWorkerContainer and the ServiceWorker on Worker
+  // threads then this will need to change.
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(principalInfo, &rv);
+  if (NS_FAILED(rv) || !principal) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  nsAutoCString origin;
+  rv = principal->GetOriginNoSuffix(origin);
+  if (NS_SUCCEEDED(rv)) {
+    CopyUTF8toUTF16(origin, init.mOrigin);
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    // Shutting down. Just don't deliver this message.
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
+    const IPCServiceWorkerDescriptor& swd = endpoint.get_IPCServiceWorkerDescriptor();
+    RefPtr<ServiceWorkerRegistrationInfo> reg =
+      swm->GetRegistration(principal, swd.scope());
+    if (reg) {
+      RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(swd.id());
+      if (serviceWorker) {
+        init.mSource.SetValue().SetAsServiceWorker() =
+          serviceWorker->GetOrCreateInstance(GetInnerWindow());
+      }
+    }
+  }
+
+  // Eventually we should expose Client in MessageEvent.source.
+
+  RefPtr<MessageEvent> event =
+    MessageEvent::Constructor(target, NS_LITERAL_STRING("message"), init);
+  event->SetTrusted(true);
+
+  bool status = false;
+  target->DispatchEvent(static_cast<dom::Event*>(event.get()), &status);
+  if (!status) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::GetState(const ClientGetStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientState state;
+  nsresult rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::Claim(const ClientClaimArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ServiceWorkerDescriptor swd(aArgs.serviceWorker());
+
+  // Today the ServiceWorkerManager maintains its own list of
+  // nsIDocument objects controlled by each service worker.  We
+  // need to try to update that data structure for now.  If we
+  // can't, however, then simply mark the Client as controlled.
+  // In the future this will be enough for the SWM as well since
+  // it will eventually hold ClientHandle objects instead of
+  // nsIDocuments.
+  nsPIDOMWindowInner* innerWindow = GetInnerWindow();
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+  RefPtr<ServiceWorkerManager> swm = doc ? ServiceWorkerManager::GetInstance()
+                                         : nullptr;
+  if (!swm || !doc) {
+    SetController(swd);
+
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> outerPromise =
+    new ClientOpPromise::Private(__func__);
+
+  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
+  p->Then(mEventTarget, __func__,
+    [outerPromise] (bool aResult) {
+      outerPromise->Resolve(NS_OK, __func__);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->Reject(aResult, __func__);
+    });
+
+  ref = outerPromise;
+  return ref.forget();
+}
+
+already_AddRefed<ClientOpPromise>
+ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientState state;
+  nsresult rv = SnapshotState(&state);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo.ToIPC(),
+                                                             state.ToIPC()), __func__);
+  return ref.forget();
+}
+
+nsresult
+ClientSource::SnapshotState(ClientState* aStateOut)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(aStateOut);
+
+  // TODO: Handle state on reserved client where no window/workerprivate yet.
+
+  if (mClientInfo.Type() == ClientType::Window) {
+    MaybeCreateInitialDocument();
+    nsresult rv = SnapshotWindowState(aStateOut);
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+    return NS_OK;
+  }
+
+  *aStateOut = ClientState(ClientWorkerState());
+  return NS_OK;
+}
+
 nsISerialEventTarget*
 ClientSource::EventTarget() const
 {
   return mEventTarget;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -7,28 +7,39 @@
 #define _mozilla_dom_ClientSource_h
 
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/Variant.h"
 
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
 class nsIDocShell;
 class nsISerialEventTarget;
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
+class ClientClaimArgs;
 class ClientControlledArgs;
+class ClientFocusArgs;
+class ClientGetInfoAndStateArgs;
+class ClientGetStateArgs;
 class ClientManager;
+class ClientPostMessageArgs;
 class ClientSourceChild;
 class ClientSourceConstructorArgs;
 class ClientSourceExecutionReadyArgs;
+class ClientState;
+class ClientWindowState;
 class PClientManagerChild;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
 // ClientSource is an RAII style class that is designed to be held via
 // a UniquePtr<>.  When created ClientSource will register the existence
@@ -60,16 +71,22 @@ class ClientSource final : public Client
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
 
   mozilla::dom::workers::WorkerPrivate*
   GetWorkerPrivate() const;
 
   nsIDocShell*
   GetDocShell() const;
 
+  void
+  MaybeCreateInitialDocument();
+
+  nsresult
+  SnapshotWindowState(ClientState* aStateOut);
+
   // Private methods called by ClientManager
   ClientSource(ClientManager* aManager,
                nsISerialEventTarget* aEventTarget,
                const ClientSourceConstructorArgs& aArgs);
 
   void
   Activate(PClientManagerChild* aActor);
 
@@ -92,16 +109,19 @@ public:
   Freeze();
 
   void
   Thaw();
 
   const ClientInfo&
   Info() const;
 
+  void
+  WorkerSyncPing(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
+
   // Synchronously mark the ClientSource as controlled by the given service
   // worker.  This can happen as a result of a remote operation or directly
   // by local code.  For example, if a client's initial network load is
   // intercepted by a controlling service worker then this should be called
   // immediately.
   //
   // Note, there is no way to clear the controlling service worker because
   // the specification does not allow that operation.
@@ -113,16 +133,34 @@ public:
   RefPtr<ClientOpPromise>
   Control(const ClientControlledArgs& aArgs);
 
   // Get the ClientSource's current controlling service worker, if one has
   // been set.
   const Maybe<ServiceWorkerDescriptor>&
   GetController() const;
 
+  already_AddRefed<ClientOpPromise>
+  Focus(const ClientFocusArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  PostMessage(const ClientPostMessageArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  GetState(const ClientGetStateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  Claim(const ClientClaimArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+
+  nsresult
+  SnapshotState(ClientState* aStateOut);
+
   nsISerialEventTarget*
   EventTarget() const;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientSource_h
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -69,16 +69,42 @@ void
 ClientSourceOpChild::Init(const ClientOpConstructorArgs& aArgs)
 {
   switch (aArgs.type()) {
     case ClientOpConstructorArgs::TClientControlledArgs:
     {
       DoSourceOp(&ClientSource::Control, aArgs.get_ClientControlledArgs());
       break;
     }
+    case ClientOpConstructorArgs::TClientFocusArgs:
+    {
+      DoSourceOp(&ClientSource::Focus, aArgs.get_ClientFocusArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientPostMessageArgs:
+    {
+      DoSourceOp(&ClientSource::PostMessage, aArgs.get_ClientPostMessageArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetStateArgs:
+    {
+      DoSourceOp(&ClientSource::GetState, aArgs.get_ClientGetStateArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientClaimArgs:
+    {
+      DoSourceOp(&ClientSource::Claim, aArgs.get_ClientClaimArgs());
+      break;
+    }
+    case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
+    {
+      DoSourceOp(&ClientSource::GetInfoAndState,
+                 aArgs.get_ClientGetInfoAndStateArgs());
+      break;
+    }
     default:
     {
       MOZ_ASSERT_UNREACHABLE("unknown client operation!");
       break;
     }
   }
 }
 
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
--- a/dom/clients/manager/ClientSourceParent.cpp
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -78,16 +78,24 @@ ClientSourceParent::KillInvalidChild()
   // trust that process any more.  We have to do this on the main thread, so
   // there is a small window of time before we kill the process.  This is why
   // we start the actor destruction immediately above.
   nsCOMPtr<nsIRunnable> r = new KillContentParentRunnable(Move(process));
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 }
 
 IPCResult
+ClientSourceParent::RecvWorkerSyncPing()
+{
+  // Do nothing here.  This is purely a sync message allowing the child to
+  // confirm that the actor has been created on the parent process.
+  return IPC_OK();
+}
+
+IPCResult
 ClientSourceParent::RecvTeardown()
 {
   Unused << Send__delete__(this);
   return IPC_OK();
 }
 
 IPCResult
 ClientSourceParent::RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
@@ -204,16 +212,28 @@ ClientSourceParent::Info() const
 }
 
 bool
 ClientSourceParent::IsFrozen() const
 {
   return mFrozen;
 }
 
+bool
+ClientSourceParent::ExecutionReady() const
+{
+  return mExecutionReady;
+}
+
+const Maybe<ServiceWorkerDescriptor>&
+ClientSourceParent::GetController() const
+{
+  return mController;
+}
+
 void
 ClientSourceParent::AttachHandle(ClientHandleParent* aClientHandle)
 {
   MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
   MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
   MOZ_ASSERT(!mHandleList.Contains(aClientHandle));
   mHandleList.AppendElement(aClientHandle);
 }
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
--- a/dom/clients/manager/ClientSourceParent.h
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -26,16 +26,19 @@ class ClientSourceParent final : public 
   bool mExecutionReady;
   bool mFrozen;
 
   void
   KillInvalidChild();
 
   // PClientSourceParent
   mozilla::ipc::IPCResult
+  RecvWorkerSyncPing() override;
+
+  mozilla::ipc::IPCResult
   RecvTeardown() override;
 
   mozilla::ipc::IPCResult
   RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs) override;
 
   mozilla::ipc::IPCResult
   RecvFreeze() override;
 
@@ -59,16 +62,22 @@ public:
   Init();
 
   const ClientInfo&
   Info() const;
 
   bool
   IsFrozen() const;
 
+  bool
+  ExecutionReady() const;
+
+  const Maybe<ServiceWorkerDescriptor>&
+  GetController() const;
+
   void
   AttachHandle(ClientHandleParent* aClientSource);
 
   void
   DetachHandle(ClientHandleParent* aClientSource);
 
   RefPtr<ClientOpPromise>
   StartOp(const ClientOpConstructorArgs& aArgs);
diff --git a/dom/clients/manager/PClientSource.ipdl b/dom/clients/manager/PClientSource.ipdl
--- a/dom/clients/manager/PClientSource.ipdl
+++ b/dom/clients/manager/PClientSource.ipdl
@@ -15,16 +15,17 @@ namespace dom {
 
 sync protocol PClientSource
 {
   manager PClientManager;
 
   manages PClientSourceOp;
 
 parent:
+  sync WorkerSyncPing();
   async Teardown();
   async ExecutionReady(ClientSourceExecutionReadyArgs aArgs);
   async Freeze();
   async Thaw();
 
 child:
   async PClientSourceOp(ClientOpConstructorArgs aArgs);
 
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -33,16 +33,17 @@ UNIFIED_SOURCES += [
   'ClientManagerOpParent.cpp',
   'ClientManagerParent.cpp',
   'ClientManagerService.cpp',
   'ClientNavigateOpChild.cpp',
   'ClientNavigateOpParent.cpp',
   'ClientOpenWindowOpActors.cpp',
   'ClientOpenWindowOpChild.cpp',
   'ClientOpenWindowOpParent.cpp',
+  'ClientOpenWindowUtils.cpp',
   'ClientPrefs.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ClientState.cpp',
   'ClientValidation.cpp',
@@ -58,17 +59,19 @@ IPDL_SOURCES += [
   'PClientOpenWindowOp.ipdl',
   'PClientSource.ipdl',
   'PClientSourceOp.ipdl',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
+  '/dom/base',
   '/dom/workers',
+  '/netwerk/base',
 ]
 
 FINAL_LIBRARY = 'xul'
 
 MOCHITEST_MANIFESTS += [
 ]
 
 BROWSER_CHROME_MANIFESTS += [
diff --git a/dom/clients/moz.build b/dom/clients/moz.build
--- a/dom/clients/moz.build
+++ b/dom/clients/moz.build
@@ -1,9 +1,10 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DIRS += [
+  'api',
   'manager',
 ]
diff --git a/dom/console/moz.build b/dom/console/moz.build
--- a/dom/console/moz.build
+++ b/dom/console/moz.build
@@ -30,16 +30,18 @@ UNIFIED_SOURCES += [
     'ConsoleReportCollector.cpp',
 ]
 
 EXTRA_COMPONENTS += [
     'ConsoleAPI.manifest',
     'ConsoleAPIStorage.js',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/docshell/base',
     '/dom/base',
     '/dom/workers',
     '/js/xpconnect/src',
 ]
 
 MOCHITEST_MANIFESTS += [ 'tests/mochitest.ini' ]
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -33,16 +33,17 @@
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/MutableBlobStreamListener.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/URLSearchParams.h"
+#include "mozilla/dom/workers/bindings/WorkerHolder.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/Telemetry.h"
 
 #include "BodyExtractor.h"
 #include "FetchObserver.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
 
diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -134,16 +134,17 @@ MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLAT
                                           PRFileDesc,
                                           PR_Close);
 
 namespace dom {
 namespace indexedDB {
 
 using namespace mozilla::dom::quota;
 using namespace mozilla::ipc;
+using mozilla::dom::quota::Client;
 
 namespace {
 
 class ConnectionPool;
 class Cursor;
 class Database;
 struct DatabaseActorInfo;
 class DatabaseFile;
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -639,16 +639,18 @@ public:
   void OnCompositorDeviceReset() override;
 
   virtual PClientOpenWindowOpParent*
   AllocPClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs) override;
 
   virtual bool
   DeallocPClientOpenWindowOpParent(PClientOpenWindowOpParent* aActor) override;
 
+  static hal::ProcessPriority GetInitialProcessPriority(Element* aFrameElement);
+
   // Control the priority of the IPC messages for input events.
   void SetInputPriorityEventEnabled(bool aEnabled);
   bool IsInputPriorityEventEnabled()
   {
     return mIsInputPriorityEventEnabled;
   }
 
   static bool IsInputEventQueueSupported();
@@ -672,18 +674,16 @@ private:
    * removed from this list, but will still be in the sContentParents list for
    * the GetAll/GetAllEvenIfDead APIs.
    */
   static nsClassHashtable<nsStringHashKey, nsTArray<ContentParent*>>* sBrowserContentParents;
   static nsTArray<ContentParent*>* sPrivateContent;
   static nsDataHashtable<nsUint32HashKey, ContentParent*> *sJSPluginContentParents;
   static StaticAutoPtr<LinkedList<ContentParent> > sContentParents;
 
-  static hal::ProcessPriority GetInitialProcessPriority(Element* aFrameElement);
-
   static ContentBridgeParent* CreateContentBridgeParent(const TabContext& aContext,
                                                         const hal::ProcessPriority& aPriority,
                                                         const TabId& aOpenerTabId,
                                                         const TabId& aTabId);
 
   // Hide the raw constructor methods since we don't want client code
   // using them.
   virtual PBrowserParent* SendPBrowserConstructor(
diff --git a/dom/network/ConnectionWorker.cpp b/dom/network/ConnectionWorker.cpp
--- a/dom/network/ConnectionWorker.cpp
+++ b/dom/network/ConnectionWorker.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <limits>
 #include "mozilla/Hal.h"
 #include "ConnectionWorker.h"
 #include "WorkerRunnable.h"
+#include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace network {
 
 class ConnectionProxy final : public NetworkObserver
                             , public WorkerHolder
 {
diff --git a/dom/performance/moz.build b/dom/performance/moz.build
--- a/dom/performance/moz.build
+++ b/dom/performance/moz.build
@@ -32,15 +32,17 @@ UNIFIED_SOURCES += [
     'PerformanceObserver.cpp',
     'PerformanceObserverEntryList.cpp',
     'PerformanceResourceTiming.cpp',
     'PerformanceService.cpp',
     'PerformanceTiming.cpp',
     'PerformanceWorker.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/dom/workers',
 ]
 
 MOCHITEST_MANIFESTS += [ 'tests/mochitest.ini' ]
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/webidl/Client.webidl b/dom/webidl/Client.webidl
--- a/dom/webidl/Client.webidl
+++ b/dom/webidl/Client.webidl
@@ -8,30 +8,32 @@
  *
  */
 
 [Exposed=ServiceWorker]
 interface Client {
   readonly attribute USVString url;
 
   // Remove frameType in bug 1290936
+  [BinaryName="GetFrameType"]
   readonly attribute FrameType frameType;
 
   readonly attribute ClientType type;
   readonly attribute DOMString id;
 
   // Implement reserved in bug 1264177
   // readonly attribute boolean reserved;
 
   [Throws]
   void postMessage(any message, optional sequence<object> transfer = []);
 };
 
 [Exposed=ServiceWorker]
 interface WindowClient : Client {
+  [BinaryName="GetVisibilityState"]
   readonly attribute VisibilityState visibilityState;
   readonly attribute boolean focused;
 
   // Implement ancestorOrigins in bug 1264180
   // [SameObject] readonly attribute FrozenArray<USVString> ancestorOrigins;
 
   [Throws, NewObject]
   Promise<WindowClient> focus();
diff --git a/dom/webidl/Clients.webidl b/dom/webidl/Clients.webidl
--- a/dom/webidl/Clients.webidl
+++ b/dom/webidl/Clients.webidl
@@ -10,18 +10,18 @@
 
 [Exposed=ServiceWorker]
 interface Clients {
   // The objects returned will be new instances every time
   [NewObject]
   Promise<any> get(DOMString id);
   [NewObject]
   Promise<sequence<Client>> matchAll(optional ClientQueryOptions options);
-  [NewObject,
-   Func="mozilla::dom::ServiceWorkerGlobalScope::OpenWindowEnabled"]
+  // TODO: fix pref enabled func
+  [NewObject]
   Promise<WindowClient?> openWindow(USVString url);
   [NewObject]
   Promise<void> claim();
 };
 
 dictionary ClientQueryOptions {
   boolean includeUncontrolled = false;
   ClientType type = "window";
diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -10,17 +10,18 @@
  *
  * You are granted a license to use, reproduce and create derivative works of
  * this document.
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
-  [SameObject] readonly attribute Clients clients;
+  [SameObject, BinaryName="GetClients"]
+  readonly attribute Clients clients;
   [SameObject] readonly attribute ServiceWorkerRegistration registration;
 
   [Throws, NewObject]
   Promise<void> skipWaiting();
 
   attribute EventHandler oninstall;
   attribute EventHandler onactivate;
 
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -565,16 +565,17 @@ class ScriptLoaderRunnable final : publi
   friend class CachePromiseHandler;
   friend class CacheScriptLoader;
   friend class LoaderListener;
 
   WorkerPrivate* mWorkerPrivate;
   nsCOMPtr<nsIEventTarget> mSyncLoopTarget;
   nsTArray<ScriptLoadInfo> mLoadInfos;
   RefPtr<CacheCreator> mCacheCreator;
+  Maybe<ServiceWorkerDescriptor> mController;
   bool mIsMainScript;
   WorkerScriptType mWorkerScriptType;
   bool mCanceled;
   bool mCanceledMainThread;
   ErrorResult& mRv;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
@@ -1211,16 +1212,20 @@ private:
 
       mWorkerPrivate->SetReferrerPolicyFromHeaderValue(tRPHeaderCValue);
 
       WorkerPrivate* parent = mWorkerPrivate->GetParent();
       if (parent) {
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
       }
+
+      if (chanLoadInfo) {
+        mController = chanLoadInfo->GetController();
+      }
     }
 
     return NS_OK;
   }
 
   void
   DataReceivedFromCache(uint32_t aIndex, const uint8_t* aString,
                         uint32_t aStringLen,
@@ -1976,19 +1981,22 @@ ScriptExecutorRunnable::WorkerRun(JSCont
                                     loadInfo.mLoadResult, loadInfo.mURL);
       // Top level scripts only!
       if (mIsWorkerScript) {
         aWorkerPrivate->MaybeDispatchLoadFailedRunnable();
       }
       return true;
     }
 
-    // If this is a top level scropt that succeeded, then mark the
-    // Client execution ready.
+    // If this is a top level script that succeeded, then mark the
+    // Client execution ready and possibly controlled by a service worker.
     if (mIsWorkerScript) {
+      if (mScriptLoader.mController.isSome()) {
+        aWorkerPrivate->Control(mScriptLoader.mController.ref());
+      }
       aWorkerPrivate->ExecutionReady();
     }
 
     NS_ConvertUTF16toUTF8 filename(loadInfo.mURL);
 
     JS::CompileOptions options(aCx);
     options.setFileAndLine(filename.get(), 1)
            .setNoScriptRval(true);
diff --git a/dom/workers/ServiceWorker.cpp b/dom/workers/ServiceWorker.cpp
--- a/dom/workers/ServiceWorker.cpp
+++ b/dom/workers/ServiceWorker.cpp
@@ -3,22 +3,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "WorkerPrivate.h"
 
 #include "mozilla/Preferences.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
@@ -94,16 +95,24 @@ ServiceWorker::PostMessage(JSContext* aC
   }
 
   auto storageAllowed = nsContentUtils::StorageAllowedForWindow(window);
   if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return;
   }
 
-  UniquePtr<ServiceWorkerClientInfo> clientInfo(new ServiceWorkerClientInfo(window->GetExtantDoc()));
+  Maybe<ClientInfo> clientInfo = window->GetClientInfo();
+  Maybe<ClientState> clientState = window->GetClientState();
+  if (clientInfo.isNothing() || clientState.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+
   ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
-  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable, Move(clientInfo));
+  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
+                                        ClientInfoAndState(clientInfo.ref().ToIPC(),
+                                                           clientState.ref().ToIPC()));
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -239,25 +239,30 @@ public:
 
 class ResolveClaimRunnable final : public WorkerRunnable
 {
   RefPtr<PromiseWorkerProxy> mPromiseProxy;
   nsresult mResult;
 
 public:
   ResolveClaimRunnable(WorkerPrivate* aWorkerPrivate,
-                       PromiseWorkerProxy* aPromiseProxy,
-                       nsresult aResult)
+                       PromiseWorkerProxy* aPromiseProxy)
     : WorkerRunnable(aWorkerPrivate)
     , mPromiseProxy(aPromiseProxy)
-    , mResult(aResult)
+    , mResult(NS_OK)
   {
     AssertIsOnMainThread();
   }
 
+  void
+  SetResult(nsresult aResult)
+  {
+    mResult = aResult;
+  }
+
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
     aWorkerPrivate->AssertIsOnWorkerThread();
 
     RefPtr<Promise> promise = mPromiseProxy->WorkerPromise();
     MOZ_ASSERT(promise);
@@ -297,30 +302,39 @@ public:
     MutexAutoLock lock(mPromiseProxy->Lock());
     if (mPromiseProxy->CleanedUp()) {
       return NS_OK;
     }
 
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
-    nsresult rv = NS_OK;
+    RefPtr<ResolveClaimRunnable> resolveRunnable =
+      new ResolveClaimRunnable(workerPrivate, mPromiseProxy);
+
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       // browser shutdown
-      rv = NS_ERROR_FAILURE;
-    } else {
-      rv = swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
-                             mServiceWorkerID);
+      resolveRunnable->SetResult(NS_ERROR_FAILURE);
+      resolveRunnable->Dispatch();
+      return NS_OK;
     }
 
-    RefPtr<ResolveClaimRunnable> r =
-      new ResolveClaimRunnable(workerPrivate, mPromiseProxy, rv);
+    RefPtr<GenericPromise::AllPromiseType> p =
+      swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
+                        mServiceWorkerID);
+    p->Then(AbstractThread::GetCurrent(), __func__,
+      [resolveRunnable](const nsTArray<bool>& aResultList) {
+        resolveRunnable->SetResult(NS_OK);
+        resolveRunnable->Dispatch();
+      }, [resolveRunnable](nsresult aRv) {
+        resolveRunnable->SetResult(aRv);
+        resolveRunnable->Dispatch();
+      });
 
-    r->Dispatch();
     return NS_OK;
   }
 };
 
 class ResolveOpenWindowRunnable final : public WorkerRunnable
 {
 public:
   ResolveOpenWindowRunnable(PromiseWorkerProxy* aPromiseProxy,
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -26,16 +26,17 @@
 #include "nsQueryObject.h"
 #include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/BodyUtil.h"
+#include "mozilla/dom/Client.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/PushMessageDataBinding.h"
 #include "mozilla/dom/PushUtil.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/TypedArray.h"
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -264,17 +264,17 @@ public:
   }
 };
 
 class ExtendableMessageEvent final : public ExtendableEvent
 {
   JS::Heap<JS::Value> mData;
   nsString mOrigin;
   nsString mLastEventId;
-  RefPtr<ServiceWorkerClient> mClient;
+  RefPtr<Client> mClient;
   RefPtr<ServiceWorker> mServiceWorker;
   RefPtr<MessagePort> mMessagePort;
   nsTArray<RefPtr<MessagePort>> mPorts;
 
 protected:
   explicit ExtendableMessageEvent(EventTarget* aOwner);
   ~ExtendableMessageEvent();
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -32,16 +32,18 @@
 
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/ErrorNames.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/SystemGroup.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Request.h"
@@ -60,17 +62,16 @@
 #include "nsGlobalWindow.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerInfo.h"
 #include "ServiceWorkerJobQueue.h"
 #include "ServiceWorkerManagerChild.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerRegisterJob.h"
 #include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
@@ -2279,17 +2280,18 @@ ServiceWorkerManager::MaybeStartControll
                                             const nsAString& aDocumentId)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(aDoc);
   if (registration) {
     MOZ_ASSERT(!mControlledDocuments.Contains(aDoc));
-    StartControllingADocument(registration, aDoc, aDocumentId);
+    RefPtr<GenericPromise> p =
+      StartControllingADocument(registration, aDoc, aDocumentId);
   }
 }
 
 void
 ServiceWorkerManager::MaybeStopControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
@@ -2319,35 +2321,51 @@ ServiceWorkerManager::MaybeCheckNavigati
   //    algorithm.
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   mControlledDocuments.Get(aDoc, getter_AddRefs(registration));
   if (registration) {
     registration->MaybeScheduleUpdate();
   }
 }
 
-void
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                                                 nsIDocument* aDoc,
                                                 const nsAString& aDocumentId)
 {
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(aDoc);
 
 #ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
   auto storageAllowed = nsContentUtils::StorageAllowedForDocument(aDoc);
   MOZ_DIAGNOSTIC_ASSERT(storageAllowed == nsContentUtils::StorageAccess::eAllow);
 #endif // MOZ_DIAGNOSTIC_ASSERT_ENABLED
 
+  RefPtr<GenericPromise> ref = GenericPromise::CreateAndResolve(true, __func__);
+
   aRegistration->StartControllingADocument();
   mControlledDocuments.Put(aDoc, aRegistration);
   if (!aDocumentId.IsEmpty()) {
     aDoc->SetId(aDocumentId);
   }
+  ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
+  nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
+  if (activeWorker && innerWindow) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    SystemGroup::EventTargetFor(TaskCategory::Other));
+      if (clientHandle) {
+        ref = clientHandle->Control(activeWorker->Descriptor());
+      }
+    }
+  }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
 {
   aRegistration->StopControllingADocument();
   if (aRegistration->IsControllingDocuments() || !aRegistration->IsIdle()) {
     return;
@@ -2512,30 +2530,27 @@ ServiceWorkerManager::GetServiceWorkerFo
 
 namespace {
 
 class ContinueDispatchFetchEventRunnable : public Runnable
 {
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
-  nsString mDocumentId;
   bool mIsReload;
 public:
   ContinueDispatchFetchEventRunnable(
     ServiceWorkerPrivate* aServiceWorkerPrivate,
     nsIInterceptedChannel* aChannel,
     nsILoadGroup* aLoadGroup,
-    const nsAString& aDocumentId,
     bool aIsReload)
     : Runnable("dom::workers::ContinueDispatchFetchEventRunnable")
     , mServiceWorkerPrivate(aServiceWorkerPrivate)
     , mChannel(aChannel)
     , mLoadGroup(aLoadGroup)
-    , mDocumentId(aDocumentId)
     , mIsReload(aIsReload)
   {
     MOZ_ASSERT(aServiceWorkerPrivate);
     MOZ_ASSERT(aChannel);
   }
 
   void
   HandleError()
@@ -2566,18 +2581,29 @@ public:
     // if that happens.
     nsresult status;
     rv = channel->GetStatus(&status);
     if (NS_WARN_IF(NS_FAILED(rv) || NS_FAILED(status))) {
       HandleError();
       return NS_OK;
     }
 
-    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup,
-                                               mDocumentId, mIsReload);
+    nsString clientId;
+    nsCOMPtr<nsILoadInfo> loadInfo = channel->GetLoadInfo();
+    if (loadInfo) {
+      Maybe<ClientInfo> clientInfo = loadInfo->GetClientInfo();
+      if (clientInfo.isSome()) {
+        char buf[NSID_LENGTH];
+        clientInfo.ref().Id().ToProvidedString(buf);
+        CopyUTF8toUTF16(nsDependentCString(buf), clientId);
+      }
+    }
+
+    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup, clientId,
+                                               mIsReload);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       HandleError();
     }
 
     return NS_OK;
   }
 };
 
@@ -2592,44 +2618,36 @@ ServiceWorkerManager::DispatchFetchEvent
                                          bool aIsSubresourceLoad,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerInfo> serviceWorker;
   nsCOMPtr<nsILoadGroup> loadGroup;
-  nsAutoString documentId;
 
   if (aIsSubresourceLoad) {
     MOZ_ASSERT(aDoc);
 
     serviceWorker = GetActiveWorkerInfoForDocument(aDoc);
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     loadGroup = aDoc->GetDocumentLoadGroup();
-    nsresult rv = aDoc->GetOrCreateId(documentId);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
-    }
   } else {
     nsCOMPtr<nsIChannel> internalChannel;
     aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     internalChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 
-    // TODO: Use aDocumentIdForTopLevelNavigation for potentialClientId, pending
-    // the spec change.
-
     nsCOMPtr<nsIURI> uri;
     aRv = aChannel->GetSecureUpgradedChannelURI(getter_AddRefs(uri));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     // non-subresource request means the URI contains the principal
     nsCOMPtr<nsIPrincipal> principal =
@@ -2648,29 +2666,56 @@ ServiceWorkerManager::DispatchFetchEvent
     // before we get to this point.  Therefore we must handle a nullptr
     // active worker here.
     serviceWorker = registration->GetActive();
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
+    // If there is a reserved client it should be marked as controlled before
+    // the FetchEvent.
+    nsCOMPtr<nsILoadInfo> loadInfo = internalChannel->GetLoadInfo();
+    if (loadInfo) {
+      Maybe<ClientInfo> clientInfo = loadInfo->GetReservedClientInfo();
+      if (clientInfo.isNothing()) {
+        clientInfo = loadInfo->GetInitialClientInfo();
+      }
+      if (clientInfo.isSome()) {
+        // First, attempt to mark the reserved client controlled directly.  This
+        // will update the controlled status in the ClientManagerService in the
+        // parent.  It will also eventually propagate back to the ClientSource.
+        RefPtr<ClientHandle> clientHandle =
+          ClientManager::CreateHandle(clientInfo.ref(),
+                                      SystemGroup::EventTargetFor(TaskCategory::Other));
+        if (clientHandle) {
+          RefPtr<GenericPromise> p =
+            clientHandle->Control(serviceWorker->Descriptor());
+        }
+
+        // But we also note the reserved state on the LoadInfo.  This allows the
+        // ClientSource to be updated immediately after the nsIChannel starts.
+        // This is necessary to have the correct controller in place for immediate
+        // follow-on requests.
+        loadInfo->SetController(serviceWorker->Descriptor());
+      }
+    }
+
     AddNavigationInterception(serviceWorker->Scope(), aChannel);
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
 
   nsCOMPtr<nsIRunnable> continueRunnable =
     new ContinueDispatchFetchEventRunnable(serviceWorker->WorkerPrivate(),
-                                           aChannel, loadGroup,
-                                           documentId, aIsReload);
+                                           aChannel, loadGroup, aIsReload);
 
   // When this service worker was registered, we also sent down the permissions
   // for the runnable. They should have arrived by now, but we still need to
   // wait for them if they have not.
   nsCOMPtr<nsIRunnable> permissionsRunnable = NS_NewRunnableFunction(
     "dom::workers::ServiceWorkerManager::DispatchFetchEvent", [=]() {
       nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
       MOZ_ALWAYS_SUCCEEDS(permMgr->WhenPermissionsAvailable(serviceWorker->Principal(),
@@ -2754,32 +2799,52 @@ ServiceWorkerManager::GetDocumentRegistr
 NS_IMETHODIMP
 ServiceWorkerManager::GetDocumentController(nsPIDOMWindowInner* aWindow,
                                             nsISupports** aServiceWorker)
 {
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  Maybe<ServiceWorkerDescriptor> controller = aWindow->GetController();
+  if (controller.isNothing()) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  if (!doc) {
+  if (NS_WARN_IF(!doc)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  RefPtr<ServiceWorkerRegistrationInfo> registration;
-  nsresult rv = GetDocumentRegistration(doc, getter_AddRefs(registration));
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (NS_WARN_IF(!principal)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  nsAutoCString scopeKey;
+  nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  MOZ_ASSERT(registration->GetActive());
-  RefPtr<ServiceWorker> serviceWorker =
-    registration->GetActive()->GetOrCreateInstance(aWindow);
-
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(scopeKey, controller.ref().Scope());
+  if (NS_WARN_IF(!registration)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorkerInfo> active = registration->GetActive();
+  if (NS_WARN_IF(!active) ||
+      NS_WARN_IF(active->Descriptor().Id() != controller.ref().Id())) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorker> serviceWorker = active->GetOrCreateInstance(aWindow);
   serviceWorker.forget(aServiceWorker);
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetInstalling(nsPIDOMWindowInner* aWindow,
                                     const nsAString& aScope,
                                     nsISupports** aServiceWorker)
 {
@@ -3074,46 +3139,17 @@ ServiceWorkerManager::UpdateInternal(nsI
                                registration->GetUpdateViaCache());
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);
 
   queue->ScheduleJob(job);
 }
 
-namespace {
-
-static void
-FireControllerChangeOnDocument(nsIDocument* aDocument)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDocument);
-
-  nsCOMPtr<nsPIDOMWindowInner> w = aDocument->GetInnerWindow();
-  if (!w) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-    return;
-  }
-
-  auto* window = nsGlobalWindowInner::Cast(w.get());
-  dom::Navigator* navigator = window->Navigator();
-  if (!navigator) {
-    return;
-  }
-
-  RefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
-  ErrorResult result;
-  container->ControllerChanged(result);
-  if (result.Failed()) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-  }
-}
-
-} // anonymous namespace
-
+/* TODO
 UniquePtr<ServiceWorkerClientInfo>
 ServiceWorkerManager::GetClient(nsIPrincipal* aPrincipal,
                                 const nsAString& aClientId,
                                 ErrorResult& aRv)
 {
   UniquePtr<ServiceWorkerClientInfo> clientInfo;
   nsCOMPtr<nsISupportsInterfacePointer> ifptr =
     do_CreateInstance(NS_SUPPORTS_INTERFACE_POINTER_CONTRACTID);
@@ -3155,17 +3191,19 @@ ServiceWorkerManager::GetClient(nsIPrinc
     nsContentUtils::StorageAllowedForWindow(doc->GetInnerWindow());
   if (storageAccess != nsContentUtils::StorageAccess::eAllow) {
     return clientInfo;
   }
 
   clientInfo.reset(new ServiceWorkerClientInfo(doc));
   return clientInfo;
 }
-
+*/
+
+/* TODO
 void
 ServiceWorkerManager::GetAllClients(nsIPrincipal* aPrincipal,
                                     const nsCString& aScope,
                                     uint64_t aServiceWorkerID,
                                     bool aIncludeUncontrolled,
                                     nsTArray<ServiceWorkerClientInfo>& aDocuments)
 {
   MOZ_ASSERT(aPrincipal);
@@ -3255,88 +3293,128 @@ ServiceWorkerManager::GetAllClients(nsIP
   uint32_t ordinal = 0;
   for (uint32_t i = 0; i < docList.Length(); ++i) {
     aDocuments.AppendElement(ServiceWorkerClientInfo(docList[i], ordinal));
     ordinal += 1;
   }
 
   aDocuments.Sort();
 }
-
-void
+*/
+
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
                                        ServiceWorkerRegistrationInfo* aWorkerRegistration)
 {
   MOZ_ASSERT(aWorkerRegistration);
   MOZ_ASSERT(aWorkerRegistration->GetActive());
 
+  RefPtr<GenericPromise> ref;
+
   // Same origin check
   if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
-    return;
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_SECURITY_ERR, __func__);
+    return ref.forget();
   }
 
   // The registration that should be controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
     GetServiceWorkerRegistrationInfo(aDocument);
 
   // The registration currently controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> controllingRegistration;
   GetDocumentRegistration(aDocument, getter_AddRefs(controllingRegistration));
 
   if (aWorkerRegistration != matchingRegistration ||
-        aWorkerRegistration == controllingRegistration) {
-    return;
+      aWorkerRegistration == controllingRegistration) {
+    ref = GenericPromise::CreateAndResolve(true, __func__);
+    return ref.forget();
   }
 
   if (controllingRegistration) {
     StopControllingADocument(controllingRegistration);
   }
 
-  StartControllingADocument(aWorkerRegistration, aDocument, NS_LITERAL_STRING(""));
-  FireControllerChangeOnDocument(aDocument);
+  ref = StartControllingADocument(aWorkerRegistration, aDocument,
+                                  NS_LITERAL_STRING(""));
+  return ref.forget();
 }
 
-nsresult
+already_AddRefed<GenericPromise>
+ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
+                                       const ServiceWorkerDescriptor& aServiceWorker)
+{
+  RefPtr<GenericPromise> ref;
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
+  if (!principal) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(principal, aServiceWorker.Scope());
+  if (!registration) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  ref = MaybeClaimClient(aDoc, registration);
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise::AllPromiseType>
 ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
                                    const nsCString& aScope, uint64_t aId)
 {
+  RefPtr<GenericPromise::AllPromiseType> ref;
+
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aPrincipal, aScope);
 
   if (!registration || !registration->GetActive() ||
       !(registration->GetActive()->ID() == aId)) {
     // The worker is not active.
-    return NS_ERROR_DOM_INVALID_STATE_ERR;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
   if (NS_WARN_IF(!obs)) {
-    return NS_ERROR_FAILURE;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_FAILURE,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsISimpleEnumerator> enumerator;
   nsresult rv = obs->EnumerateObservers("service-worker-get-client",
                                         getter_AddRefs(enumerator));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
+    ref = GenericPromise::AllPromiseType::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  AutoTArray<RefPtr<GenericPromise>, 32> claimPromiseList;
 
   bool loop = true;
   while (NS_SUCCEEDED(enumerator->HasMoreElements(&loop)) && loop) {
     nsCOMPtr<nsISupports> ptr;
     rv = enumerator->GetNext(getter_AddRefs(ptr));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ptr);
-    MaybeClaimClient(doc, registration);
-  }
-
-  return NS_OK;
+    claimPromiseList.AppendElement(MaybeClaimClient(doc, registration));
+  }
+
+  ref = GenericPromise::All(AbstractThread::GetCurrent(), claimPromiseList);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::SetSkipWaitingFlag(nsIPrincipal* aPrincipal,
                                          const nsCString& aScope,
                                          uint64_t aServiceWorkerID)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -3355,38 +3433,55 @@ ServiceWorkerManager::SetSkipWaitingFlag
   worker->SetSkipWaitingFlag();
 
   if (worker->State() == ServiceWorkerState::Installed) {
     registration->TryToActivateAsync();
   }
 }
 
 void
-ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration)
 {
   AssertIsOnMainThread();
 
-  AutoTArray<nsCOMPtr<nsIDocument>, 16> documents;
+  RefPtr<ServiceWorkerInfo> activeWorker = aRegistration->GetActive();
+  MOZ_DIAGNOSTIC_ASSERT(activeWorker);
+
+  AutoTArray<nsCOMPtr<nsPIDOMWindowInner>, 16> innerWindows;
   for (auto iter = mControlledDocuments.Iter(); !iter.Done(); iter.Next()) {
     if (iter.UserData() != aRegistration) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(iter.Key());
     if (NS_WARN_IF(!doc)) {
       continue;
     }
 
-    documents.AppendElement(doc);
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      continue;
+    }
+
+    innerWindows.AppendElement(innerWindow);
   }
 
   // Fire event after iterating mControlledDocuments is done to prevent
   // modification by reentering from the event handlers during iteration.
-  for (auto& doc : documents) {
-    FireControllerChangeOnDocument(doc);
+  for (auto& innerWindow : innerWindows) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    innerWindow->EventTargetFor(TaskCategory::Other));
+      if (clientHandle) {
+        RefPtr<GenericPromise> p =
+          clientHandle->Control(activeWorker->Descriptor());
+      }
+    }
   }
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
                                       const nsACString& aScope) const
 {
   MOZ_ASSERT(aPrincipal);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -10,16 +10,17 @@
 #include "nsIServiceWorkerManager.h"
 #include "nsCOMPtr.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/ConsoleReportCollector.h"
 #include "mozilla/LinkedList.h"
+#include "mozilla/MozPromise.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/TypedEnumBits.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerCommon.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
@@ -40,17 +41,16 @@ class OriginAttributes;
 
 namespace dom {
 
 class ServiceWorkerRegistrar;
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
-class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
@@ -267,33 +267,39 @@ public:
               const nsString& aMessage,
               const nsString& aFilename,
               const nsString& aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags,
               JSExnType aExnType);
 
+  /*
   UniquePtr<ServiceWorkerClientInfo>
   GetClient(nsIPrincipal* aPrincipal,
             const nsAString& aClientId,
             ErrorResult& aRv);
 
   void
   GetAllClients(nsIPrincipal* aPrincipal,
                 const nsCString& aScope,
                 uint64_t aServiceWorkerID,
                 bool aIncludeUncontrolled,
                 nsTArray<ServiceWorkerClientInfo>& aDocuments);
+  */
 
-  void
+  already_AddRefed<GenericPromise>
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
-  nsresult
+  already_AddRefed<GenericPromise>
+  MaybeClaimClient(nsIDocument* aDoc,
+                   const ServiceWorkerDescriptor& aServiceWorker);
+
+  already_AddRefed<GenericPromise::AllPromiseType>
   ClaimClients(nsIPrincipal* aPrincipal, const nsCString& aScope, uint64_t aId);
 
   void
   SetSkipWaitingFlag(nsIPrincipal* aPrincipal, const nsCString& aScope,
                      uint64_t aServiceWorkerID);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
@@ -385,17 +391,17 @@ private:
                                             WhichServiceWorker aWhichOne);
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
   NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
 
-  void
+  already_AddRefed<GenericPromise>
   StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                             nsIDocument* aDoc,
                             const nsAString& aDocumentId);
 
   void
   StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
@@ -435,17 +441,17 @@ private:
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration);
+  UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   StorePendingReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                            Promise* aPromise);
 
   bool
   CheckReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                     Promise* aPromise);
diff --git a/dom/workers/ServiceWorkerManagerService.h b/dom/workers/ServiceWorkerManagerService.h
--- a/dom/workers/ServiceWorkerManagerService.h
+++ b/dom/workers/ServiceWorkerManagerService.h
@@ -5,16 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerManagerService_h
 #define mozilla_dom_ServiceWorkerManagerService_h
 
 #include "nsISupportsImpl.h"
 #include "nsHashKeys.h"
 #include "nsTHashtable.h"
+#include "nsTArray.h"
 
 namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -2,17 +2,16 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerPrivate.h"
 
 #include "ServiceWorkerManager.h"
-#include "ServiceWorkerWindowClient.h"
 #include "nsContentUtils.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPushErrorReporter.h"
 #include "nsISupportsImpl.h"
 #include "nsITimedChannel.h"
@@ -20,30 +19,34 @@
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/Client.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 BEGIN_WORKERS_NAMESPACE
 
+using mozilla::ipc::PrincipalInfo;
+
 NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTION(ServiceWorkerPrivate, mSupportsArray)
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(ServiceWorkerPrivate, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(ServiceWorkerPrivate, Release)
 
 // Tracks the "dom.serviceWorkers.disable_open_click_delay" preference.  Modified
@@ -481,29 +484,28 @@ public:
 
     return NS_OK;
   }
 };
 
 class SendMesssageEventRunnable final : public ExtendableEventWorkerRunnable
                                       , public StructuredCloneHolder
 {
-  UniquePtr<ServiceWorkerClientInfo> mEventSource;
+  const ClientInfoAndState mClientInfoAndState;
 
 public:
   SendMesssageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                             KeepAliveToken* aKeepAliveToken,
-                            UniquePtr<ServiceWorkerClientInfo>&& aEventSource)
+                            const ClientInfoAndState& aClientInfoAndState)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
     , StructuredCloneHolder(CloningSupported, TransferringSupported,
                             StructuredCloneScope::SameProcessDifferentThread)
-    , mEventSource(Move(aEventSource))
+    , mClientInfoAndState(aClientInfoAndState)
   {
     AssertIsOnMainThread();
-    MOZ_ASSERT(mEventSource);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
@@ -512,26 +514,25 @@ public:
       return true;
     }
 
     Sequence<OwningNonNull<MessagePort>> ports;
     if (!TakeTransferredPortsAsSequence(ports)) {
       return true;
     }
 
-    RefPtr<ServiceWorkerClient> client = new ServiceWorkerWindowClient(sgo,
-                                                                       *mEventSource);
     RootedDictionary<ExtendableMessageEventInit> init(aCx);
 
     init.mBubbles = false;
     init.mCancelable = false;
 
     init.mData = messageData;
     init.mPorts = ports;
-    init.mSource.SetValue().SetAsClient() = client;
+
+    init.mSource.SetValue().SetAsClient() = new Client(sgo, mClientInfoAndState);
 
     RefPtr<EventTarget> target = aWorkerPrivate->GlobalScope();
     RefPtr<ExtendableMessageEvent> extendableEvent =
       ExtendableMessageEvent::Constructor(target, NS_LITERAL_STRING("message"),
                                           init, rv);
     if (NS_WARN_IF(rv.Failed())) {
       rv.SuppressException();
       return false;
@@ -547,17 +548,17 @@ public:
 };
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendMessageEvent(JSContext* aCx,
                                        JS::Handle<JS::Value> aMessage,
                                        const Sequence<JSObject*>& aTransferable,
-                                       UniquePtr<ServiceWorkerClientInfo>&& aClientInfo)
+                                       const ClientInfoAndState& aClientInfoAndState)
 {
   AssertIsOnMainThread();
 
   ErrorResult rv(SpawnWorkerIfNeeded(MessageEvent, nullptr));
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
@@ -566,17 +567,17 @@ ServiceWorkerPrivate::SendMessageEvent(J
   rv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                          &transferable);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
   RefPtr<SendMesssageEventRunnable> runnable =
-    new SendMesssageEventRunnable(mWorkerPrivate, token, Move(aClientInfo));
+    new SendMesssageEventRunnable(mWorkerPrivate, token, aClientInfoAndState);
 
   runnable->Write(aCx, aMessage, transferable, JS::CloneDataPolicy(), rv);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   if (!runnable->Dispatch()) {
     return NS_ERROR_FAILURE;
@@ -1339,24 +1340,24 @@ class FetchEventRunnable : public Extend
 public:
   FetchEventRunnable(WorkerPrivate* aWorkerPrivate,
                      KeepAliveToken* aKeepAliveToken,
                      nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      // CSP checks might require the worker script spec
                      // later on.
                      const nsACString& aScriptSpec,
                      nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
-                     const nsAString& aDocumentId,
+                     const nsAString& aClientId,
                      bool aIsReload,
                      bool aMarkLaunchServiceWorkerEnd)
     : ExtendableFunctionalEventWorkerRunnable(
         aWorkerPrivate, aKeepAliveToken, aRegistration)
     , mInterceptedChannel(aChannel)
     , mScriptSpec(aScriptSpec)
-    , mClientId(aDocumentId)
+    , mClientId(aClientId)
     , mIsReload(aIsReload)
     , mMarkLaunchServiceWorkerEnd(aMarkLaunchServiceWorkerEnd)
     , mCacheMode(RequestCache::Default)
     , mRequestMode(RequestMode::No_cors)
     , mRequestRedirect(RequestRedirect::Follow)
     // By default we set it to same-origin since normal HTTP fetches always
     // send credentials to same-origin websites unless explicitly forbidden.
     , mRequestCredentials(RequestCredentials::Same_origin)
@@ -1619,17 +1620,20 @@ private:
 
     MOZ_ASSERT_IF(internalReq->IsNavigationRequest(),
                   request->Redirect() == RequestRedirect::Manual);
 
     RootedDictionary<FetchEventInit> init(aCx);
     init.mRequest = request;
     init.mBubbles = false;
     init.mCancelable = true;
-    if (!mClientId.IsEmpty()) {
+    // Only expose the FetchEvent.clientId on subresource requests for now.
+    // Once we implement .reservedClientId we can then start shipping
+    // .clientId values on non-subresource requests.
+    if (!mClientId.IsEmpty() && !internalReq->IsNavigationRequest()) {
       init.mClientId = mClientId;
     }
     init.mIsReload = mIsReload;
     RefPtr<FetchEvent> event =
       FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, result);
     if (NS_WARN_IF(result.Failed())) {
       result.SuppressException();
       return false;
@@ -1665,18 +1669,17 @@ private:
 
 NS_IMPL_ISUPPORTS_INHERITED(FetchEventRunnable, WorkerRunnable, nsIHttpHeaderVisitor)
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendFetchEvent(nsIInterceptedChannel* aChannel,
                                      nsILoadGroup* aLoadGroup,
-                                     const nsAString& aDocumentId,
-                                     bool aIsReload)
+                                     const nsAString& aClientId, bool aIsReload)
 {
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(!mInfo || !swm)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1743,17 +1746,17 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
       "ServiceWorkerRegistrationInfo", registration, false));
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
 
 
   RefPtr<FetchEventRunnable> r =
     new FetchEventRunnable(mWorkerPrivate, token, handle,
                            mInfo->ScriptSpec(), regInfo,
-                           aDocumentId, aIsReload, newWorkerCreated);
+                           aClientId, aIsReload, newWorkerCreated);
   rv = r->Init();
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   if (mInfo->State() == ServiceWorkerState::Activating) {
     mPendingFunctionalEvents.AppendElement(r.forget());
     return NS_OK;
@@ -1892,17 +1895,17 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   jsapi.Init();
   ErrorResult error;
   NS_ConvertUTF8toUTF16 scriptSpec(mInfo->ScriptSpec());
 
   mWorkerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
                                               scriptSpec,
                                               false, WorkerTypeService,
                                               VoidString(),
-                                              mInfo->Scope(),
+                                              EmptyCString(),
                                               &info, error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   RenewKeepAliveToken(aWhy);
 
   if (aNewWorkerCreated) {
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -13,16 +13,19 @@
 
 #define NOTIFICATION_CLICK_EVENT_NAME "notificationclick"
 #define NOTIFICATION_CLOSE_EVENT_NAME "notificationclose"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
+
+class ClientInfoAndState;
+
 namespace workers {
 
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
 class KeepAliveToken;
 
 class LifeCycleEventCallback : public Runnable
 {
@@ -80,17 +83,17 @@ protected:
   NS_DECL_OWNINGTHREAD
 
 public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
   nsresult
   SendMessageEvent(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                    const Sequence<JSObject*>& aTransferable,
-                   UniquePtr<ServiceWorkerClientInfo>&& aClientInfo);
+                   const ClientInfoAndState& aClientInfoAndState);
 
   // This is used to validate the worker script and continue the installation
   // process.
   nsresult
   CheckScriptEvaluation(LifeCycleEventCallback* aCallback);
 
   nsresult
   SendLifeCycleEvent(const nsAString& aEventType,
@@ -114,20 +117,18 @@ public:
                         const nsAString& aBody,
                         const nsAString& aTag,
                         const nsAString& aIcon,
                         const nsAString& aData,
                         const nsAString& aBehavior,
                         const nsAString& aScope);
 
   nsresult
-  SendFetchEvent(nsIInterceptedChannel* aChannel,
-                 nsILoadGroup* aLoadGroup,
-                 const nsAString& aDocumentId,
-                 bool aIsReload);
+  SendFetchEvent(nsIInterceptedChannel* aChannel, nsILoadGroup* aLoadGroup,
+                 const nsAString& aClientId, bool aIsReload);
 
   void
   StoreISupports(nsISupports* aSupports);
 
   void
   RemoveISupports(nsISupports* aSupports);
 
   // This will terminate the current running worker thread and drop the
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -269,23 +269,18 @@ ServiceWorkerRegistrationInfo::Activate(
     return;
   }
 
   TransitionWaitingToActive();
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   // "Queue a task to fire a simple event named controllerchange..."
-  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
-    NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      "dom::workers::ServiceWorkerManager::FireControllerChange",
-      swm,
-      &ServiceWorkerManager::FireControllerChange,
-      this);
-  NS_DispatchToMainThread(controllerChangeRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mActiveWorker);
+  swm->UpdateClientControllers(this);
 
   nsCOMPtr<nsIRunnable> failRunnable = NewRunnableMethod<bool>(
     "dom::workers::ServiceWorkerRegistrationInfo::FinishActivate",
     this,
     &ServiceWorkerRegistrationInfo::FinishActivate,
     false /* success */);
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -5321,27 +5321,60 @@ WorkerPrivate::EnsureClientSource()
       MOZ_CRASH("unknown worker type!");
   }
 
   mClientSource = ClientManager::CreateSource(type, mWorkerHybridEventTarget,
                                               GetPrincipalInfo());
   if (mFrozen) {
     mClientSource->Freeze();
   }
+
+  // Shortly after the client is reserved we will try loading the main script
+  // for the worker.  This may get intercepted by the ServiceWorkerManager
+  // which will then try to create a ClientHandle.  Its actually possible for
+  // the main thread to create this ClientHandle before our IPC message creating
+  // the ClientSource completes.  To avoid this race we synchronously ping our
+  // parent Client actor here.  This ensure the worker Client is created in
+  // the parent before the main thread might try reaching it with a
+  // ClientHandle.
+  //
+  // An alternative solution would have been to handle the out-of-order operations
+  // on the parent side.  We could have created a small window where we allow
+  // ClientHandle objects to exist without a ClientSource.  We would then time
+  // out these handles if they stayed orphaned for too long.  This approach would
+  // be much more complex, but also avoid this extra bit of latency when starting
+  // workers.
+  //
+  // Note, we only have to do this for workers that can be controlled by a
+  // service worker.  So avoid the sync overhead here if we are starting a
+  // service worker or a chrome worker.
+  if (Type() != WorkerTypeService && !IsChromeWorker()) {
+    mClientSource->WorkerSyncPing(this);
+  }
 }
 
 const ClientInfo&
 WorkerPrivate::GetClientInfo() const
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   return mClientSource->Info();
 }
 
 void
+WorkerPrivate::Control(const ServiceWorkerDescriptor& aServiceWorker)
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(!IsChromeWorker());
+  MOZ_DIAGNOSTIC_ASSERT(Type() != WorkerTypeService);
+  mClientSource->SetController(aServiceWorker);
+}
+
+void
 WorkerPrivate::ExecutionReady()
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   mClientSource->WorkerExecutionReady(this);
 }
 
 void
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1499,16 +1499,19 @@ public:
 
   void
   EnsureClientSource();
 
   const ClientInfo&
   GetClientInfo() const;
 
   void
+  Control(const ServiceWorkerDescriptor& aServiceWorker);
+
+  void
   ExecutionReady();
 
 private:
   WorkerPrivate(WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsAString& aWorkerName,
                 const nsACString& aServiceWorkerScope,
                 WorkerLoadInfo& aLoadInfo);
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WorkerScope.h"
 
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/Clients.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/Fetch.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IDBFactory.h"
 #include "mozilla/dom/ImageBitmap.h"
 #include "mozilla/dom/ImageBitmapBinding.h"
 #include "mozilla/dom/Performance.h"
@@ -27,29 +28,29 @@
 #include "mozilla/dom/WorkerLocation.h"
 #include "mozilla/dom/WorkerNavigator.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/Services.h"
 #include "nsServiceManagerUtils.h"
 
 #include "nsIDocument.h"
 #include "nsIServiceWorkerManager.h"
+#include "nsIScriptError.h"
 #include "nsIScriptTimeoutHandler.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #include "Crypto.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
-#include "ServiceWorkerClients.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerRegistration.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 extern already_AddRefed<nsIScriptTimeoutHandler>
@@ -629,24 +630,25 @@ ServiceWorkerGlobalScope::WrapGlobalObje
   JS::CompartmentOptions options;
   mWorkerPrivate->CopyJSCompartmentOptions(options);
 
   return ServiceWorkerGlobalScopeBinding::Wrap(aCx, this, this, options,
                                                GetWorkerPrincipal(),
                                                true, aReflector);
 }
 
-ServiceWorkerClients*
-ServiceWorkerGlobalScope::Clients()
+already_AddRefed<Clients>
+ServiceWorkerGlobalScope::GetClients()
 {
   if (!mClients) {
-    mClients = new ServiceWorkerClients(this);
+    mClients = new Clients(this);
   }
 
-  return mClients;
+  RefPtr<Clients> ref = mClients;
+  return ref.forget();
 }
 
 ServiceWorkerRegistration*
 ServiceWorkerGlobalScope::Registration()
 {
   if (!mRegistration) {
     mRegistration =
       ServiceWorkerRegistration::CreateForWorker(mWorkerPrivate, mScope);
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -14,16 +14,17 @@
 #include "nsWeakReference.h"
 #include "mozilla/dom/ImageBitmapSource.h"
 
 namespace mozilla {
 namespace dom {
 
 class AnyCallback;
 struct ChannelPixelLayout;
+class Clients;
 class Console;
 class Crypto;
 class Function;
 class IDBFactory;
 enum class ImageBitmapFormat : uint8_t;
 class Performance;
 class Promise;
 class RequestOrUSVString;
@@ -35,17 +36,16 @@ enum class CallerType : uint32_t;
 namespace cache {
 
 class CacheStorage;
 
 } // namespace cache
 
 namespace workers {
 
-class ServiceWorkerClients;
 class WorkerPrivate;
 
 } // namespace workers
 
 class WorkerGlobalScope : public DOMEventTargetHelper,
                           public nsIGlobalObject,
                           public nsSupportsWeakReference
 {
@@ -277,17 +277,17 @@ public:
   Close(JSContext* aCx);
 
   IMPL_EVENT_HANDLER(connect)
 };
 
 class ServiceWorkerGlobalScope final : public WorkerGlobalScope
 {
   const nsString mScope;
-  RefPtr<workers::ServiceWorkerClients> mClients;
+  RefPtr<Clients> mClients;
   RefPtr<ServiceWorkerRegistration> mRegistration;
 
   ~ServiceWorkerGlobalScope();
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerGlobalScope,
                                            WorkerGlobalScope)
@@ -304,18 +304,18 @@ public:
   OpenWindowEnabled(JSContext* aCx, JSObject* aObj);
 
   void
   GetScope(nsString& aScope) const
   {
     aScope = mScope;
   }
 
-  workers::ServiceWorkerClients*
-  Clients();
+  already_AddRefed<Clients>
+  GetClients();
 
   ServiceWorkerRegistration*
   Registration();
 
   already_AddRefed<Promise>
   SkipWaiting(ErrorResult& aRv);
 
   IMPL_EVENT_HANDLER(activate)
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -32,19 +32,16 @@ EXPORTS.mozilla.dom.workers += [
     'ServiceWorkerRegistrationInfo.h',
     'WorkerDebuggerManager.h',
     'Workers.h',
 ]
 
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
-    'ServiceWorkerClient.h',
-    'ServiceWorkerClients.h',
-    'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
     'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
@@ -55,18 +52,16 @@ XPIDL_SOURCES += [
 UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
-    'ServiceWorkerClient.cpp',
-    'ServiceWorkerClients.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
@@ -77,17 +72,16 @@ UNIFIED_SOURCES += [
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerUpdaterChild.cpp',
     'ServiceWorkerUpdaterParent.cpp',
-    'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
     'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
diff --git a/dom/workers/test/serviceworkers/openWindow_worker.js b/dom/workers/test/serviceworkers/openWindow_worker.js
--- a/dom/workers/test/serviceworkers/openWindow_worker.js
+++ b/dom/workers/test/serviceworkers/openWindow_worker.js
@@ -55,37 +55,37 @@ onmessage = function(event) {
   if (event.data == "testNoPopup") {
     client = event.source;
 
     var results = [];
     var promises = [];
     promises.push(testForUrl("about:blank", "TypeError", null, results));
     promises.push(testForUrl("http://example.com", "InvalidAccessError", null, results));
     promises.push(testForUrl("_._*`InvalidURL", "InvalidAccessError", null, results));
-    Promise.all(promises).then(function(e) {
+    event.waitUntil(Promise.all(promises).then(function(e) {
       client.postMessage(results);
-    });
+    }));
   }
   if (event.data == "NEW_WINDOW") {
     window_count += 1;
     if (window_count == expected_window_count) {
       resolve_got_all_windows();
     }
   }
 
   if (event.data == "CHECK_NUMBER_OF_WINDOWS") {
-    got_all_windows.then(function() {
+    event.waitUntil(got_all_windows.then(function() {
       return clients.matchAll();
     }).then(function(cl) {
       event.source.postMessage({result: cl.length == expected_window_count,
                                 message: "The number of windows is correct."});
       for (i = 0; i < cl.length; i++) {
         cl[i].postMessage("CLOSE");
       }
-    });
+    }));
   }
 }
 
 onnotificationclick = function(e) {
   var results = [];
   var promises = [];
 
   var redirect = "http://mochi.test:8888/tests/dom/workers/test/serviceworkers/redirect.sjs?"
@@ -104,13 +104,13 @@ onnotificationclick = function(e) {
 			   {url: same_origin}, results));
   promises.push(testForUrl(redirect + different_origin, null, null, results));
 
   promises.push(testForUrl(redirect_xorigin + "open_window/client.html", null,
 			   null, results));
   promises.push(testForUrl(redirect_xorigin + same_origin, null,
 			   {url: same_origin}, results));
 
-  Promise.all(promises).then(function(e) {
+  e.waitUntil(Promise.all(promises).then(function(e) {
     client.postMessage(results);
-  });
+  }));
 }
 
diff --git a/dom/xslt/base/moz.build b/dom/xslt/base/moz.build
--- a/dom/xslt/base/moz.build
+++ b/dom/xslt/base/moz.build
@@ -8,16 +8,18 @@ UNIFIED_SOURCES += [
     'txDouble.cpp',
     'txExpandedName.cpp',
     'txExpandedNameMap.cpp',
     'txList.cpp',
     'txNamespaceMap.cpp',
     'txURIUtils.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '..',
     '../xml',
     '../xpath',
     '../xslt',
 ]
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/xul/moz.build b/dom/xul/moz.build
--- a/dom/xul/moz.build
+++ b/dom/xul/moz.build
@@ -38,16 +38,18 @@ XPIDL_SOURCES += [
 ]
 
 XPIDL_MODULE = 'xul'
 
 UNIFIED_SOURCES += [
     'nsXULControllers.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/docshell/base',
     '/dom/base',
     '/dom/html',
     '/dom/xbl',
     '/dom/xml',
     '/dom/xul/templates',
     '/layout/base',
diff --git a/ipc/ipdl/sync-messages.ini b/ipc/ipdl/sync-messages.ini
--- a/ipc/ipdl/sync-messages.ini
+++ b/ipc/ipdl/sync-messages.ini
@@ -1054,8 +1054,10 @@ description =
 [PHandlerService::ExistsForProtocol]
 description = bug 1382323
 [PHandlerService::Exists]
 description =
 [PHandlerService::GetTypeFromExtension]
 description =
 [PLayerTransaction::ShutdownSync]
 description = bug 1363126
+[PClientSource::WorkerSyncPing]
+description = Synchronous ping allowing worker thread to confirm actor is created. Necessary to avoid racing with ClientHandle actors on main thread.
diff --git a/modules/libpref/init/all.js b/modules/libpref/init/all.js
--- a/modules/libpref/init/all.js
+++ b/modules/libpref/init/all.js
@@ -5874,16 +5874,23 @@ pref("layers.advanced.image-layers", 2);
 pref("layers.advanced.outline-layers", 2);
 pref("layers.advanced.solid-color", false);
 pref("layers.advanced.table", false);
 pref("layers.advanced.text-layers", 2);
 
 // Enable lowercased response header name
 pref("dom.xhr.lowercase_header.enabled", false);
 
+// Control whether clients.openWindow() opens windows in the same process
+// that called the API vs following our normal multi-process selection
+// algorithm.  Restricting openWindow to same process improves service worker
+// web compat in the short term.  Once the SW multi-e10s refactor is complete
+// this can be removed.
+pref("dom.clients.openwindow_favors_same_process", true);
+
 // When a crash happens, whether to include heap regions of the crash context
 // in the minidump. Enabled by default on nightly and aurora.
 #ifdef RELEASE_OR_BETA
 pref("toolkit.crashreporter.include_context_heap", false);
 #else
 pref("toolkit.crashreporter.include_context_heap", true);
 #endif
 
diff --git a/testing/web-platform/meta/MANIFEST.json b/testing/web-platform/meta/MANIFEST.json
--- a/testing/web-platform/meta/MANIFEST.json
+++ b/testing/web-platform/meta/MANIFEST.json
@@ -280948,16 +280948,36 @@
      {}
     ]
    ],
    "service-workers/service-worker/resources/404.py": [
     [
      {}
     ]
    ],
+   "service-workers/service-worker/resources/about-blank-replacement-frame.html": [
+    [
+     {}
+    ]
+   ],
+   "service-workers/service-worker/resources/about-blank-replacement-ping-frame.html": [
+    [
+     {}
+    ]
+   ],
+   "service-workers/service-worker/resources/about-blank-replacement-popup-frame.html": [
+    [
+     {}
+    ]
+   ],
+   "service-workers/service-worker/resources/about-blank-replacement-worker.js": [
+    [
+     {}
+    ]
+   ],
    "service-workers/service-worker/resources/appcache-ordering.install.html": [
     [
      {}
     ]
    ],
    "service-workers/service-worker/resources/appcache-ordering.is-appcached.html": [
     [
      {}
@@ -351243,16 +351263,24 @@
     ]
    ],
    "service-workers/service-worker/ServiceWorkerGlobalScope/update.https.html": [
     [
      "/service-workers/service-worker/ServiceWorkerGlobalScope/update.https.html",
      {}
     ]
    ],
+   "service-workers/service-worker/about-blank-replacement.https.html": [
+    [
+     "/service-workers/service-worker/about-blank-replacement.https.html",
+     {
+      "timeout": "long"
+     }
+    ]
+   ],
    "service-workers/service-worker/activate-event-after-install-state-change.https.html": [
     [
      "/service-workers/service-worker/activate-event-after-install-state-change.https.html",
      {}
     ]
    ],
    "service-workers/service-worker/activation-after-registration.https.html": [
     [
@@ -578110,16 +578138,20 @@
   "service-workers/service-worker/ServiceWorkerGlobalScope/unregister.https.html": [
    "9fe4c10b921a84dc086cea47d48bb34fdbb28eee",
    "testharness"
   ],
   "service-workers/service-worker/ServiceWorkerGlobalScope/update.https.html": [
    "f574c7a96a1ca766445cd0b427b9963b18c62795",
    "testharness"
   ],
+  "service-workers/service-worker/about-blank-replacement.https.html": [
+   "d764525c6fe7f6a15aee3f8c99bee20e34560173",
+   "testharness"
+  ],
   "service-workers/service-worker/activate-event-after-install-state-change.https.html": [
    "9d1971d9b5dcb52a14a0d2313065e27766c0489a",
    "testharness"
   ],
   "service-workers/service-worker/activation-after-registration.https.html": [
    "913c58ba58de077b82d0ec9cc21258610b26fe97",
    "testharness"
   ],
@@ -578758,16 +578790,32 @@
   "service-workers/service-worker/resource-timing.https.html": [
    "a835a0baeb4fcc0c44e6be28502f89308464acc5",
    "testharness"
   ],
   "service-workers/service-worker/resources/404.py": [
    "567d0a7de3ef54adaa8339bb04632a2ecfcc57a5",
    "support"
   ],
+  "service-workers/service-worker/resources/about-blank-replacement-frame.html": [
+   "7b0b74e54ff0f673964cd71c27a120a801e81393",
+   "support"
+  ],
+  "service-workers/service-worker/resources/about-blank-replacement-ping-frame.html": [
+   "ce59e1fac0a1801b99c5adab964b31eaefe473e6",
+   "support"
+  ],
+  "service-workers/service-worker/resources/about-blank-replacement-popup-frame.html": [
+   "e0c2045a646bb4aa2b7cc5eec36cd9419ed56bd6",
+   "support"
+  ],
+  "service-workers/service-worker/resources/about-blank-replacement-worker.js": [
+   "53ce81249094bcc3b23e4185b701263e3c0148ec",
+   "support"
+  ],
   "service-workers/service-worker/resources/appcache-ordering.install.html": [
    "2fbe9f464383783774f08276b8e2cc7103fee83c",
    "support"
   ],
   "service-workers/service-worker/resources/appcache-ordering.is-appcached.html": [
    "4e7b85b7e2d9dbcd6def515b856db51020b54595",
    "support"
   ],
diff --git a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini b/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
+++ /dev/null
@@ -1,8 +0,0 @@
-[clients-matchall-client-types.https.html]
-  type: testharness
-  [Verify matchAll() with window and sharedworker client types]
-    expected: FAIL
-
-  [Verify matchAll() with {window, sharedworker, worker} client types]
-    expected: FAIL
-
diff --git a/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html b/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html
@@ -0,0 +1,102 @@
+<!DOCTYPE html>
+<title>Service Worker: about:blank replacement handling</title>
+<meta name=timeout content=long>
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="/common/get-host-info.sub.js"></script>
+<script src="resources/test-helpers.sub.js"></script>
+<body>
+<script>
+const worker = 'resources/about-blank-replacement-worker.js';
+
+// Helper routine that creates an iframe that internally has some kind
+// of nested window.  The nested window could be another iframe or
+// it could be a popup window.
+function createFrameWithNestedWindow(url) {
+  return new Promise(resolve => {
+    let frame = document.createElement('iframe');
+    frame.src = url;
+    document.body.appendChild(frame);
+
+    window.addEventListener('message', function onMsg(evt) {
+      if (evt.data.type !== 'NESTED_LOADED') {
+        return;
+      }
+      window.removeEventListener('message', onMsg);
+      resolve(frame);
+    });
+  });
+}
+
+// Helper routine to request the given worker find the client with
+// the specified URL using the clients.matchAll() API.
+function getClientIdByURL(worker, url) {
+  return new Promise(resolve => {
+    navigator.serviceWorker.addEventListener('message', function onMsg(evt) {
+      if (evt.data.type !== 'GET_CLIENT_ID') {
+        return;
+      }
+      navigator.serviceWorker.removeEventListener('message', onMsg);
+      resolve(evt.data.result);
+    });
+    worker.postMessage({ type: 'GET_CLIENT_ID', url: url.toString() });
+  });
+}
+
+async function doAsyncTest(t, scope, extraSearchParams) {
+  let reg = await service_worker_unregister_and_register(t, worker, scope);
+  await wait_for_state(t, reg.installing, 'activated');
+
+  // Load the scope as a frame.  We expect this in turn to have a nested
+  // iframe.  The service worker will intercept the load of the nested
+  // iframe and populate its body with the client ID of the initial
+  // about:blank document it sees via clients.matchAll().
+  let frame = await createFrameWithNestedWindow(scope);
+  let initialResult = frame.contentWindow.nested().document.body.textContent;
+  assert_false(initialResult.startsWith('failure:'), `result: ${initialResult}`);
+
+  // Next, ask the service worker to find the final client ID for the fully
+  // loaded nested frame.
+  let nestedURL = new URL(scope, window.location);
+  nestedURL.searchParams.set('nested', true);
+  extraSearchParams = extraSearchParams || {};
+  for (let p in extraSearchParams) {
+    nestedURL.searchParams.set(p, extraSearchParams[p]);
+  }
+  let finalResult = await getClientIdByURL(reg.active, nestedURL);
+  assert_false(finalResult.startsWith('failure:'), `result: ${finalResult}`);
+
+  // The initial about:blank client and the final loaded client should have
+  // the same ID value.
+  assert_equals(initialResult, finalResult, 'client ID values should match');
+
+  frame.remove();
+  await service_worker_unregister_and_done(t, scope);
+}
+
+promise_test(async function(t) {
+  // Execute a test where the nested frame is simple loaded normally.
+  await doAsyncTest(t, 'resources/about-blank-replacement-frame.html');
+}, 'Initial about:blank is controlled, exposed to clients.matchAll(), and ' +
+   'matches final Client.');
+
+promise_test(async function(t) {
+  // Execute a test where the nested frame is modified immediately by
+  // its parent.  In this case we add a message listener so the service
+  // worker can ping the client to verify its existence.  This ping-pong
+  // check is performed during the initial load and when verifying the
+  // final loaded client.
+  await doAsyncTest(t, 'resources/about-blank-replacement-ping-frame.html',
+                    { 'ping': true });
+}, 'Initial about:blank modified by parent is controlled, exposed to ' +
+   'clients.matchAll(), and matches final Client.');
+
+promise_test(async function(t) {
+  // Execute a test where the nested window is a popup window instead of
+  // an iframe.  This should behave the same as the simple iframe case.
+  await doAsyncTest(t, 'resources/about-blank-replacement-popup-frame.html');
+}, 'Popup initial about:blank is controlled, exposed to clients.matchAll(), and ' +
+   'matches final Client.');
+
+</script>
+</body>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html
@@ -0,0 +1,22 @@
+<!doctype html>
+<html>
+<body>
+<script>
+function nestedLoaded() {
+  parent.postMessage({ type: 'NESTED_LOADED' }, '*');
+}
+</script>
+<iframe src="?nested=true" id="nested" onload="nestedLoaded()"></iframe>
+<script>
+// Helper routine to make it slightly easier for our parent to find
+// the nested frame.
+function nested() {
+  return document.getElementById('nested').contentWindow;
+}
+
+// NOTE: Make sure not to touch the iframe directly here.  We want to
+//       test the case where the initial about:blank document is not
+//       directly accessed before load.
+</script>
+</body>
+</html>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html
@@ -0,0 +1,32 @@
+<!doctype html>
+<html>
+<body>
+<script>
+function nestedLoaded() {
+  parent.postMessage({ type: 'NESTED_LOADED' }, '*');
+}
+</script>
+<iframe src="?nested=true&ping=true" id="nested" onload="nestedLoaded()"></iframe>
+<script>
+// Helper routine to make it slightly easier for our parent to find
+// the nested frame.
+function nested() {
+  return document.getElementById('nested').contentWindow;
+}
+
+// This modifies the nested iframe immediately and does not wait for it to
+// load.  This effectively modifies the global for the initial about:blank
+// document.  Any modifications made here should be preserved after the
+// frame loads because the global should be re-used.
+let win = nested();
+win.navigator.serviceWorker.addEventListener('message', evt => {
+  if (evt.data.type === 'PING') {
+    evt.source.postMessage({
+      type: 'PONG',
+      location: win.location.toString()
+    });
+  }
+});
+</script>
+</body>
+</html>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-popup-frame.html b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-popup-frame.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-popup-frame.html
@@ -0,0 +1,19 @@
+<!doctype html>
+<html>
+<body>
+<script>
+function nestedLoaded() {
+  parent.postMessage({ type: 'NESTED_LOADED' }, '*');
+}
+
+let popup = window.open('?nested=true');
+popup.onload = nestedLoaded;
+
+// Helper routine to make it slightly easier for our parent to find
+// the nested popup window.
+function nested() {
+  return popup;
+}
+</script>
+</body>
+</html>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js
@@ -0,0 +1,112 @@
+// Helper routine to delay the nested frame load until we are done interacting
+// with the initial about:blank client.
+let resolveDelayed;
+function delayedResponse() {
+  return new Promise(resolve => {
+    resolveDelayed = resolve;
+  });
+}
+
+// Helper routine to find a client that matches a particular URL.  Note, we
+// require that Client to be controlled to avoid false matches with other
+// about:blank windows the browser might have.  The initial about:blank should
+// inherit the controller from its parent.
+async function getClientByURL(url) {
+  let list = await clients.matchAll();
+  for (client of list) {
+    if (client.url === url) {
+      return client;
+    }
+  }
+}
+
+// Helper routine to perform a ping-pong with the given target client.  We
+// expect the Client to respond with its location URL.
+async function pingPong(target) {
+  function waitForPong() {
+    return new Promise(resolve => {
+      self.addEventListener('message', function onMessage(evt) {
+        if (evt.data.type === 'PONG') {
+          resolve(evt.data.location);
+        }
+      });
+    });
+  }
+
+  target.postMessage({ type: 'PING' })
+  return await waitForPong(target);
+}
+
+addEventListener('fetch', async evt => {
+  let url = new URL(evt.request.url);
+  if (!url.searchParams.get('nested')) {
+    return;
+  }
+
+  // Delay the load of the nested frame so we can examine the Client
+  // representing the window while it has the initial about:blank document.
+  evt.respondWith(delayedResponse());
+
+  // Find the initial about:blank document.
+  let client = await getClientByURL('about:blank');
+  if (!client) {
+    resolveDelayed(new Response('failure: could not find about:blank client'));
+    return;
+  }
+
+  // If the nested frame is configured to support a ping-pong, then
+  // ping it now to verify its message listener exists.  We also
+  // verify the Client's idea of its own location URL while we are doing
+  // this.
+  if (url.searchParams.get('ping')) {
+    let loc = await pingPong(client);
+    if (loc !== 'about:blank') {
+      resolveDelayed(new Response(`failure: got location {$loc}, expected about:blank`));
+      return;
+    }
+  }
+
+  // Finally, allow the nested frame to complete loading.  We place the
+  // Client ID we found for the initial about:blank in the body.
+  resolveDelayed(new Response(client.id));
+});
+
+addEventListener('message', evt => {
+  if (evt.data.type !== 'GET_CLIENT_ID') {
+    return;
+  }
+
+  evt.waitUntil(async function() {
+    let url = new URL(evt.data.url);
+
+    // Find the given Client by its URL.
+    let client = await getClientByURL(evt.data.url);
+    if (!client) {
+      evt.source.postMessage({
+        type: 'GET_CLIENT_ID',
+        result: `failure: could not find ${evt.data.url} client`
+      });
+      return;
+    }
+
+    // If the Client supports a ping-pong, then do it now to verify
+    // the message listener exists and its location matches the
+    // Client object.
+    if (url.searchParams.get('ping')) {
+      let loc = await pingPong(client);
+      if (loc !== evt.data.url) {
+        evt.source.postMessage({
+          type: 'GET_CLIENT_ID',
+          result: `failure: got location ${loc}, expected ${evt.data.url}`
+        });
+        return;
+      }
+    }
+
+    // Finally, send the client ID back.
+    evt.source.postMessage({
+      type: 'GET_CLIENT_ID',
+      result: client.id
+    });
+  }());
+});
