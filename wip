# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0bcea6bac1797e14b00af45cc7c368d12460ab7f

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -25,17 +25,17 @@ Timeout::Timeout()
 {
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(Timeout)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mWindow)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mScriptHandler)
-  tmp->remove();
+  //tmp->remove();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mWindow)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(Timeout, AddRef)
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -490,19 +490,28 @@ TimeoutManager::ClearTimeout(int32_t aTi
     if (aTimeout->mTimeoutId == timerId && aTimeout->mReason == aReason) {
       if (aTimeout->mRunning) {
         /* We're running from inside the aTimeout. Mark this
            aTimeout for deferred deletion by the code in
            RunTimeout() */
         aTimeout->mIsInterval = false;
       }
       else {
+        if (mNormalTimeouts.LastInsertionPoint() == aTimeout) {
+          mNormalTimeouts.ClearLastInsertionPoint();
+        }
+
+        if (mTrackingTimeouts.LastInsertionPoint() == aTimeout) {
+          mTrackingTimeouts.ClearLastInsertionPoint();
+        }
+
         /* Delete the aTimeout from the pending aTimeout list */
         aTimeout->remove();
       }
+
       return true; // abort!
     }
 
     firstTimeout = false;
 
     return false;
   });
 
@@ -692,16 +701,19 @@ TimeoutManager::RunTimeout(const TimeSta
 
   last_tracking_insertion_point = mTrackingTimeouts.InsertionPoint();
   if (!last_expired_timeout_is_normal) {
     // If we ever start setting mTrackingTimeoutInsertionPoint to a non-dummy timeout,
     // the logic in ResetTimersForThrottleReduction will need to change.
     mTrackingTimeouts.SetInsertionPoint(dummy_tracking_timeout);
   }
 
+  mNormalTimeouts.ClearLastInsertionPoint();
+  mTrackingTimeouts.ClearLastInsertionPoint();
+
   // We stop iterating each list when we go past the last expired timeout from
   // that list that we have observed above.  That timeout will either be the
   // dummy timeout for the list that the last expired timeout came from, or it
   // will be the next item after the last timeout we looked at (or nullptr if
   // we have exhausted the entire list while looking for the last expired
   // timeout).
   {
     // Use a nested scope in order to make sure the strong references held by
@@ -742,32 +754,42 @@ TimeoutManager::RunTimeout(const TimeSta
       // Get the script context (a strong ref to prevent it going away)
       // for this timeout and ensure the script language is enabled.
       nsCOMPtr<nsIScriptContext> scx = mWindow.GetContextInternal();
 
       if (!scx) {
         // No context means this window was closed or never properly
         // initialized for this language.  This timer will never fire
         // so just remove it.
+        if (mNormalTimeouts.LastInsertionPoint() == timeout) {
+          mNormalTimeouts.ClearLastInsertionPoint();
+        }
+
+        if (mTrackingTimeouts.LastInsertionPoint() == timeout) {
+          mTrackingTimeouts.ClearLastInsertionPoint();
+        }
         timeout->remove();
         continue;
       }
 
       // This timeout is good to run
       bool timeout_was_cleared = mWindow.RunTimeoutHandler(timeout, scx);
       MOZ_LOG(gLog, LogLevel::Debug,
               ("Run%s(TimeoutManager=%p, timeout=%p, tracking=%d) returned %d\n", timeout->mIsInterval ? "Interval" : "Timeout",
                this, timeout.get(),
                int(timeout->mIsTracking),
                !!timeout_was_cleared));
 
       if (timeout_was_cleared) {
         // Make sure the iterator isn't holding any Timeout objects alive.
         runIter.Clear();
 
+        mNormalTimeouts.ClearLastInsertionPoint();
+        mTrackingTimeouts.ClearLastInsertionPoint();
+
         mNormalTimeouts.SetInsertionPoint(last_normal_insertion_point);
         mTrackingTimeouts.SetInsertionPoint(last_tracking_insertion_point);
 
         // Since ClearAllTimeouts() was called the lists should be empty.
         MOZ_DIAGNOSTIC_ASSERT(!HasTimeouts());
 
         return;
       }
@@ -777,16 +799,23 @@ TimeoutManager::RunTimeout(const TimeSta
       // If we have a regular interval timer, we re-schedule the
       // timeout, accounting for clock drift.
       bool needsReinsertion = RescheduleTimeout(timeout, now);
 
       // Running a timeout can cause another timeout to be deleted, so
       // we need to reset the pointer to the following timeout.
       runIter.UpdateIterator();
 
+      if (mNormalTimeouts.LastInsertionPoint() == timeout) {
+        mNormalTimeouts.ClearLastInsertionPoint();
+      }
+
+      if (mTrackingTimeouts.LastInsertionPoint() == timeout) {
+        mTrackingTimeouts.ClearLastInsertionPoint();
+      }
       timeout->remove();
 
       if (needsReinsertion) {
         // Insert interval timeout onto the corresponding list sorted in
         // deadline order. AddRefs timeout.
         if (runIter.PickedTrackingIter()) {
           mTrackingTimeouts.Insert(timeout,
                                    mWindow.IsFrozen() ? Timeouts::SortBy::TimeRemaining
@@ -973,16 +1002,19 @@ TimeoutManager::Timeouts::ResetTimersFor
       // optimization saves us a lot of work.
       Timeout* prevTimeout = timeout->getPrevious();
       if (prevTimeout && prevTimeout->When() > timeout->When()) {
         // It is safe to remove and re-insert because When() is now
         // strictly smaller than it used to be, so we know we'll insert
         // |timeout| before nextTimeout.
         NS_ASSERTION(!nextTimeout ||
                      timeout->When() < nextTimeout->When(), "How did that happen?");
+        if (LastInsertionPoint() == timeout) {
+          ClearLastInsertionPoint();
+        }
         timeout->remove();
         // Insert() will reset mFiringId. Make sure to undo that.
         uint32_t firingId = timeout->mFiringId;
         Insert(timeout, aSortBy);
         timeout->mFiringId = firingId;
       }
 
       timeout = nextTimeout;
@@ -1024,46 +1056,96 @@ TimeoutManager::ClearAllTimeouts()
     aTimeout->mCleared = true;
   });
 
   if (seenRunningTimeout) {
     mNormalTimeouts.SetInsertionPoint(nullptr);
     mTrackingTimeouts.SetInsertionPoint(nullptr);
   }
 
+  mNormalTimeouts.ClearLastInsertionPoint();
+  mTrackingTimeouts.ClearLastInsertionPoint();
+
   // Clear out our list
   mNormalTimeouts.Clear();
   mTrackingTimeouts.Clear();
 }
 
 void
 TimeoutManager::Timeouts::Insert(Timeout* aTimeout, SortBy aSortBy)
 {
+  uint32_t count = 1;
+
+  // This condition needs to match the one in SetTimeoutOrInterval that
+  // determines whether to set When() or TimeRemaining().
+  auto greaterThan = [&aSortBy](Timeout* aLeft, Timeout* aRight) {
+    return aSortBy == SortBy::TimeRemaining ?
+      aLeft->TimeRemaining() > aRight->TimeRemaining() :
+      aLeft->When() > aRight->When();
+  };
+
+
+  Timeout* prevSibling = GetLast();
+  bool backward = true;
+  /*
+  if (mTimeoutLastInsertionPoint &&
+      (!InsertionPoint() || greaterThan(mTimeoutLastInsertionPoint, InsertionPoint()))) {
+    prevSibling = mTimeoutLastInsertionPoint;
+    if (greaterThan(aTimeout, prevSibling)) {
+      backward = false;
+    }
+  }
+  */
+  if (mTimeoutLastInsertionPoint) {
+    if (greaterThan(mTimeoutLastInsertionPoint, aTimeout)) {
+      prevSibling = mTimeoutLastInsertionPoint;
+    } else if (!InsertionPoint() || greaterThan(mTimeoutLastInsertionPoint, InsertionPoint())) {
+      prevSibling = mTimeoutLastInsertionPoint;
+      backward = false;
+    } else if (InsertionPoint()) {
+      prevSibling = InsertionPoint();
+      backward = false;
+    }
+  }
 
   // Start at mLastTimeout and go backwards.  Don't go further than insertion
   // point, though.  This optimizes for the common case of insertion at the end.
-  Timeout* prevSibling;
-  for (prevSibling = GetLast();
-       prevSibling && prevSibling != InsertionPoint() &&
-         // This condition needs to match the one in SetTimeoutOrInterval that
-         // determines whether to set When() or TimeRemaining().
-         (aSortBy == SortBy::TimeRemaining ?
-          prevSibling->TimeRemaining() > aTimeout->TimeRemaining() :
-          prevSibling->When() > aTimeout->When());
-       prevSibling = prevSibling->getPrevious()) {
-    /* Do nothing; just searching */
+  if (backward) {
+    for (;
+         prevSibling && prevSibling != InsertionPoint() &&
+           greaterThan(prevSibling, aTimeout);
+         prevSibling = prevSibling->getPrevious()) {
+      /* Do nothing; just searching */
+      count += 1;
+    }
+  } else {
+    for (;
+         prevSibling && greaterThan(aTimeout, prevSibling);
+         prevSibling = prevSibling->getNext()) {
+      /* Do nothing; just searching */
+      count += 1;
+    }
   }
 
+  printf_stderr("### ### looked at %u timers, mTimeoutLastInsertionPoint was %p\n",
+                count, mTimeoutLastInsertionPoint);
+
   // Now link in aTimeout after prevSibling.
   if (prevSibling) {
-    prevSibling->setNext(aTimeout);
+    if (backward) {
+      prevSibling->setNext(aTimeout);
+    } else {
+      prevSibling->setPrevious(aTimeout);
+    }
   } else {
     InsertFront(aTimeout);
   }
 
+  mTimeoutLastInsertionPoint = aTimeout;
+
   aTimeout->mFiringId = InvalidFiringId;
 }
 
 Timeout*
 TimeoutManager::BeginRunningTimeout(Timeout* aTimeout)
 {
   Timeout* currentTimeout = mRunningTimeout;
   mRunningTimeout = aTimeout;
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -129,16 +129,17 @@ private:
 
   bool
   IsInvalidFiringId(uint32_t aFiringId) const;
 
 private:
   struct Timeouts {
     Timeouts()
       : mTimeoutInsertionPoint(nullptr)
+      , mTimeoutLastInsertionPoint(nullptr)
     {
     }
 
     // Insert aTimeout into the list, before all timeouts that would
     // fire after it, but no earlier than mTimeoutInsertionPoint, if any.
     enum class SortBy
     {
       TimeRemaining,
@@ -156,21 +157,32 @@ private:
     bool IsEmpty() const { return mTimeoutList.isEmpty(); }
     void InsertFront(Timeout* aTimeout) { mTimeoutList.insertFront(aTimeout); }
     void Clear() { mTimeoutList.clear(); }
 
     void SetInsertionPoint(Timeout* aTimeout)
     {
       mTimeoutInsertionPoint = aTimeout;
     }
+
     Timeout* InsertionPoint()
     {
       return mTimeoutInsertionPoint;
     }
 
+    void ClearLastInsertionPoint()
+    {
+      mTimeoutLastInsertionPoint = nullptr;
+    }
+
+    Timeout* LastInsertionPoint()
+    {
+      return mTimeoutLastInsertionPoint;
+    }
+
     template <class Callable>
     void ForEach(Callable c)
     {
       for (Timeout* timeout = GetFirst();
            timeout;
            timeout = timeout->getNext()) {
         c(timeout);
       }
@@ -199,16 +211,17 @@ private:
     // non-null.  In that case, the dummy timeout pointed to by
     // mTimeoutInsertionPoint may have a later mWhen than some of the timeouts
     // that come after it.
     TimeoutList               mTimeoutList;
     // If mTimeoutInsertionPoint is non-null, insertions should happen after it.
     // This is a dummy timeout at the moment; if that ever changes, the logic in
     // ResetTimersForThrottleReduction needs to change.
     mozilla::dom::Timeout*    mTimeoutInsertionPoint;
+    mozilla::dom::Timeout*    mTimeoutLastInsertionPoint;
   };
 
   friend class OrderedTimeoutIterator;
 
   // Each nsGlobalWindow object has a TimeoutManager member.  This reference
   // points to that holder object.
   nsGlobalWindow&             mWindow;
   // The executor is specific to the nsGlobalWindow/TimeoutManager, but it
