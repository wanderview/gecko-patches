# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1ba3bbf0f04820ba49fdfee312ff201b4abd0bd0

diff --git a/dom/base/Link.cpp b/dom/base/Link.cpp
--- a/dom/base/Link.cpp
+++ b/dom/base/Link.cpp
@@ -105,18 +105,17 @@ Link::TryDNSPrefetchPreconnectOrPrefetch
   if (!mElement->GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel)) {
     return;
   }
 
   if (!nsContentUtils::PrefetchEnabled(mElement->OwnerDoc()->GetDocShell())) {
     return;
   }
 
-  uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(rel,
-                         mElement->NodePrincipal());
+  uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(rel);
 
   if ((linkTypes & nsStyleLinkElement::ePREFETCH) ||
       (linkTypes & nsStyleLinkElement::eNEXT)){
     nsCOMPtr<nsIPrefetchService> prefetchService(do_GetService(NS_PREFETCHSERVICE_CONTRACTID));
     if (prefetchService) {
       nsCOMPtr<nsIURI> uri(GetURI());
       if (uri) {
         nsCOMPtr<nsIDOMNode> domNode = GetAsDOMNode(mElement);
diff --git a/dom/base/nsContentSink.cpp b/dom/base/nsContentSink.cpp
--- a/dom/base/nsContentSink.cpp
+++ b/dom/base/nsContentSink.cpp
@@ -692,17 +692,17 @@ nsContentSink::ProcessLinkHeader(const n
 
 nsresult
 nsContentSink::ProcessLink(const nsSubstring& aAnchor, const nsSubstring& aHref,
                            const nsSubstring& aRel, const nsSubstring& aTitle,
                            const nsSubstring& aType, const nsSubstring& aMedia,
                            const nsSubstring& aCrossOrigin)
 {
   uint32_t linkTypes =
-    nsStyleLinkElement::ParseLinkTypes(aRel, mDocument->NodePrincipal());
+    nsStyleLinkElement::ParseLinkTypes(aRel);
 
   // The link relation may apply to a different resource, specified
   // in the anchor parameter. For the link relations supported so far,
   // we simply abort if the link applies to a resource different to the
   // one we've loaded
   if (!LinkContextIsOurDocument(aAnchor)) {
     return NS_OK;
   }
diff --git a/dom/base/nsStyleLinkElement.cpp b/dom/base/nsStyleLinkElement.cpp
--- a/dom/base/nsStyleLinkElement.cpp
+++ b/dom/base/nsStyleLinkElement.cpp
@@ -123,88 +123,69 @@ nsStyleLinkElement::SetLineNumber(uint32
 }
 
 /* virtual */ uint32_t
 nsStyleLinkElement::GetLineNumber()
 {
   return mLineNumber;
 }
 
-/* static */ bool
-nsStyleLinkElement::IsImportEnabled()
-{
-  static bool sAdded = false;
-  static bool sImportsEnabled;
-  if (!sAdded) {
-    // This part runs only once because of the static flag.
-    Preferences::AddBoolVarCache(&sImportsEnabled,
-                                 "dom.htmlimports.enabled",
-                                 false);
-    sAdded = true;
-  }
-
-  return sImportsEnabled;
-}
-
-static uint32_t ToLinkMask(const nsAString& aLink, nsIPrincipal* aPrincipal)
+static uint32_t ToLinkMask(const nsAString& aLink)
 {
   // Keep this in sync with sRelValues in HTMLLinkElement.cpp
   if (aLink.EqualsLiteral("prefetch"))
     return nsStyleLinkElement::ePREFETCH;
   else if (aLink.EqualsLiteral("dns-prefetch"))
     return nsStyleLinkElement::eDNS_PREFETCH;
   else if (aLink.EqualsLiteral("stylesheet"))
     return nsStyleLinkElement::eSTYLESHEET;
   else if (aLink.EqualsLiteral("next"))
     return nsStyleLinkElement::eNEXT;
   else if (aLink.EqualsLiteral("alternate"))
     return nsStyleLinkElement::eALTERNATE;
-  else if (aLink.EqualsLiteral("import") &&
-           nsStyleLinkElement::IsImportEnabled())
-    return nsStyleLinkElement::eHTMLIMPORT;
   else if (aLink.EqualsLiteral("preconnect"))
     return nsStyleLinkElement::ePRECONNECT;
   else if (aLink.EqualsLiteral("prerender"))
     return nsStyleLinkElement::ePRERENDER;
   else
     return 0;
 }
 
-uint32_t nsStyleLinkElement::ParseLinkTypes(const nsAString& aTypes, nsIPrincipal* aPrincipal)
+uint32_t nsStyleLinkElement::ParseLinkTypes(const nsAString& aTypes)
 {
   uint32_t linkMask = 0;
   nsAString::const_iterator start, done;
   aTypes.BeginReading(start);
   aTypes.EndReading(done);
   if (start == done)
     return linkMask;
 
   nsAString::const_iterator current(start);
   bool inString = !nsContentUtils::IsHTMLWhitespace(*current);
   nsAutoString subString;
-  
+
   while (current != done) {
     if (nsContentUtils::IsHTMLWhitespace(*current)) {
       if (inString) {
         nsContentUtils::ASCIIToLower(Substring(start, current), subString);
-        linkMask |= ToLinkMask(subString, aPrincipal);
+        linkMask |= ToLinkMask(subString);
         inString = false;
       }
     }
     else {
       if (!inString) {
         start = current;
         inString = true;
       }
     }
     ++current;
   }
   if (inString) {
     nsContentUtils::ASCIIToLower(Substring(start, current), subString);
-    linkMask |= ToLinkMask(subString, aPrincipal);
+    linkMask |= ToLinkMask(subString);
   }
   return linkMask;
 }
 
 NS_IMETHODIMP
 nsStyleLinkElement::UpdateStyleSheet(nsICSSLoaderObserver* aObserver,
                                      bool* aWillNotify,
                                      bool* aIsAlternate,
diff --git a/dom/base/nsStyleLinkElement.h b/dom/base/nsStyleLinkElement.h
--- a/dom/base/nsStyleLinkElement.h
+++ b/dom/base/nsStyleLinkElement.h
@@ -57,29 +57,23 @@ public:
   virtual uint32_t GetLineNumber() override;
 
   enum RelValue {
     ePREFETCH =     0x00000001,
     eDNS_PREFETCH = 0x00000002,
     eSTYLESHEET =   0x00000004,
     eNEXT =         0x00000008,
     eALTERNATE =    0x00000010,
-    eHTMLIMPORT =   0x00000020,
-    ePRECONNECT =   0x00000040,
-    ePRERENDER =    0x00000080
+    ePRECONNECT =   0x00000020,
+    ePRERENDER =    0x00000040
   };
 
   // The return value is a bitwise or of 0 or more RelValues.
-  // aPrincipal is used to check if HTML imports is enabled for the
-  // provided principal.
-  static uint32_t ParseLinkTypes(const nsAString& aTypes,
-                                 nsIPrincipal* aPrincipal);
+  static uint32_t ParseLinkTypes(const nsAString& aTypes);
 
-  static bool IsImportEnabled();
-  
   void UpdateStyleSheetInternal()
   {
     UpdateStyleSheetInternal(nullptr, nullptr);
   }
 protected:
   /**
    * @param aOldDocument should be non-null only if we're updating because we
    *                     removed the node from the document.
diff --git a/dom/html/HTMLLinkElement.cpp b/dom/html/HTMLLinkElement.cpp
--- a/dom/html/HTMLLinkElement.cpp
+++ b/dom/html/HTMLLinkElement.cpp
@@ -62,24 +62,22 @@ HTMLLinkElement::~HTMLLinkElement()
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(HTMLLinkElement)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(HTMLLinkElement,
                                                   nsGenericHTMLElement)
   tmp->nsStyleLinkElement::Traverse(cb);
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRelList)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mImportLoader)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(HTMLLinkElement,
                                                 nsGenericHTMLElement)
   tmp->nsStyleLinkElement::Unlink();
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mRelList)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mImportLoader)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_ADDREF_INHERITED(HTMLLinkElement, Element)
 NS_IMPL_RELEASE_INHERITED(HTMLLinkElement, Element)
 
 
 // QueryInterface implementation for HTMLLinkElement
 NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(HTMLLinkElement)
@@ -170,19 +168,16 @@ HTMLLinkElement::BindToTree(nsIDocument*
 
   if (IsInComposedDoc()) {
     TryDNSPrefetchPreconnectOrPrefetchOrPrerender();
   }
 
   void (HTMLLinkElement::*update)() = &HTMLLinkElement::UpdateStyleSheetInternal;
   nsContentUtils::AddScriptRunner(NewRunnableMethod(this, update));
 
-  void (HTMLLinkElement::*updateImport)() = &HTMLLinkElement::UpdateImport;
-  nsContentUtils::AddScriptRunner(NewRunnableMethod(this, updateImport));
-
   CreateAndDispatchEvent(aDocument, NS_LITERAL_STRING("DOMLinkAdded"));
 
   return rv;
 }
 
 void
 HTMLLinkElement::LinkAdded()
 {
@@ -217,17 +212,16 @@ HTMLLinkElement::UnbindFromTree(bool aDe
   // ShadowRoot.
   ShadowRoot* oldShadowRoot = GetBindingParent() ?
     GetBindingParent()->GetShadowRoot() : nullptr;
 
   CreateAndDispatchEvent(oldDoc, NS_LITERAL_STRING("DOMLinkRemoved"));
   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
 
   UpdateStyleSheetInternal(oldDoc, oldShadowRoot);
-  UpdateImport();
 }
 
 bool
 HTMLLinkElement::ParseAttribute(int32_t aNamespaceID,
                                 nsIAtom* aAttribute,
                                 const nsAString& aValue,
                                 nsAttrValue& aResult)
 {
@@ -276,64 +270,16 @@ HTMLLinkElement::CreateAndDispatchEvent(
 
   RefPtr<AsyncEventDispatcher> asyncDispatcher =
     new AsyncEventDispatcher(this, aEventName, true, true);
   // Always run async in order to avoid running script when the content
   // sink isn't expecting it.
   asyncDispatcher->PostDOMEvent();
 }
 
-void
-HTMLLinkElement::UpdateImport()
-{
-  // 1. link node should be attached to the document.
-  nsCOMPtr<nsIDocument> doc = GetUncomposedDoc();
-  if (!doc) {
-    // We might have been just removed from the document, so
-    // let's remove ourself from the list of link nodes of
-    // the import and reset mImportLoader.
-    if (mImportLoader) {
-      mImportLoader->RemoveLinkElement(this);
-      mImportLoader = nullptr;
-    }
-    return;
-  }
-
-  // 2. rel type should be import.
-  nsAutoString rel;
-  GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel);
-  uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(rel, NodePrincipal());
-  if (!(linkTypes & eHTMLIMPORT)) {
-    mImportLoader = nullptr;
-    return;
-  }
-
-  nsCOMPtr<nsIURI> uri = GetHrefURI();
-  if (!uri) {
-    mImportLoader = nullptr;
-    return;
-  }
-
-  if (!nsStyleLinkElement::IsImportEnabled()) {
-    // For now imports are hidden behind a pref...
-    return;
-  }
-
-  RefPtr<ImportManager> manager = doc->ImportManager();
-  MOZ_ASSERT(manager, "ImportManager should be created lazily when needed");
-
-  {
-    // The load even might fire sooner than we could set mImportLoader so
-    // we must use async event and a scriptBlocker here.
-    nsAutoScriptBlocker scriptBlocker;
-    // CORS check will happen at the start of the load.
-    mImportLoader = manager->Get(uri, this, doc);
-  }
-}
-
 nsresult
 HTMLLinkElement::BeforeSetAttr(int32_t aNameSpaceID, nsIAtom* aName,
                                const nsAttrValueOrString* aValue, bool aNotify)
 {
   if (aNameSpaceID == kNameSpaceID_None &&
       (aName == nsGkAtoms::href || aName == nsGkAtoms::rel)) {
     CancelDNSPrefetch(HTML_LINK_DNS_PREFETCH_DEFERRED,
                       HTML_LINK_DNS_PREFETCH_REQUESTED);
@@ -368,29 +314,22 @@ HTMLLinkElement::AfterSetAttr(int32_t aN
          aName == nsGkAtoms::rel ||
          aName == nsGkAtoms::title ||
          aName == nsGkAtoms::media ||
          aName == nsGkAtoms::type)) {
       bool dropSheet = false;
       if (aName == nsGkAtoms::rel) {
         nsAutoString value;
         aValue->ToString(value);
-        uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(value,
-                                                                NodePrincipal());
+        uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(value);
         if (GetSheet()) {
           dropSheet = !(linkTypes & nsStyleLinkElement::eSTYLESHEET);
-        } else if (linkTypes & eHTMLIMPORT) {
-          UpdateImport();
         }
       }
 
-      if (aName == nsGkAtoms::href) {
-        UpdateImport();
-      }
-
       if ((aName == nsGkAtoms::rel || aName == nsGkAtoms::href) &&
           IsInComposedDoc()) {
         TryDNSPrefetchPreconnectOrPrefetchOrPrerender();
       }
 
       UpdateStyleSheetInternal(nullptr, nullptr,
                                dropSheet ||
                                (aName == nsGkAtoms::title ||
@@ -403,20 +342,16 @@ HTMLLinkElement::AfterSetAttr(int32_t aN
     if (aNameSpaceID == kNameSpaceID_None) {
       if (aName == nsGkAtoms::href ||
           aName == nsGkAtoms::rel ||
           aName == nsGkAtoms::title ||
           aName == nsGkAtoms::media ||
           aName == nsGkAtoms::type) {
         UpdateStyleSheetInternal(nullptr, nullptr, true);
       }
-      if (aName == nsGkAtoms::href ||
-          aName == nsGkAtoms::rel) {
-        UpdateImport();
-      }
     }
   }
 
   return nsGenericHTMLElement::AfterSetAttr(aNameSpaceID, aName, aValue,
                                             aOldValue, aNotify);
 }
 
 nsresult
@@ -444,37 +379,32 @@ HTMLLinkElement::GetLinkTarget(nsAString
   if (aTarget.IsEmpty()) {
     GetBaseTarget(aTarget);
   }
 }
 
 static const DOMTokenListSupportedToken sSupportedRelValues[] = {
   // Keep this in sync with ToLinkMask in nsStyleLinkElement.cpp.
   // "import" must come first because it's conditional.
-  "import",
   "prefetch",
   "dns-prefetch",
   "stylesheet",
   "next",
   "alternate",
   "preconnect",
   "icon",
   "search",
   nullptr
 };
 
 nsDOMTokenList* 
 HTMLLinkElement::RelList()
 {
   if (!mRelList) {
-    const DOMTokenListSupportedTokenArray relValues =
-      nsStyleLinkElement::IsImportEnabled() ?
-        sSupportedRelValues : &sSupportedRelValues[1];
-
-    mRelList = new nsDOMTokenList(this, nsGkAtoms::rel, relValues);
+    mRelList = new nsDOMTokenList(this, nsGkAtoms::rel, sSupportedRelValues);
   }
   return mRelList;
 }
 
 already_AddRefed<nsIURI>
 HTMLLinkElement::GetHrefURI() const
 {
   return GetHrefURIForAnchors();
@@ -503,17 +433,17 @@ HTMLLinkElement::GetStyleSheetInfo(nsASt
   aTitle.Truncate();
   aType.Truncate();
   aMedia.Truncate();
   *aIsScoped = false;
   *aIsAlternate = false;
 
   nsAutoString rel;
   GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel);
-  uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(rel, NodePrincipal());
+  uint32_t linkTypes = nsStyleLinkElement::ParseLinkTypes(rel);
   // Is it a stylesheet link?
   if (!(linkTypes & nsStyleLinkElement::eSTYLESHEET)) {
     return;
   }
 
   nsAutoString title;
   GetAttr(kNameSpaceID_None, nsGkAtoms::title, title);
   title.CompressWhitespace();
@@ -568,16 +498,10 @@ HTMLLinkElement::SizeOfExcludingThis(moz
 }
 
 JSObject*
 HTMLLinkElement::WrapNode(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return HTMLLinkElementBinding::Wrap(aCx, this, aGivenProto);
 }
 
-already_AddRefed<nsIDocument>
-HTMLLinkElement::GetImport()
-{
-  return mImportLoader ? RefPtr<nsIDocument>(mImportLoader->GetImport()).forget() : nullptr;
-}
-
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/html/HTMLLinkElement.h b/dom/html/HTMLLinkElement.h
--- a/dom/html/HTMLLinkElement.h
+++ b/dom/html/HTMLLinkElement.h
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_HTMLLinkElement_h
 #define mozilla_dom_HTMLLinkElement_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/Link.h"
-#include "ImportManager.h"
 #include "nsGenericHTMLElement.h"
 #include "nsIDOMHTMLLinkElement.h"
 #include "nsStyleLinkElement.h"
 
 namespace mozilla {
 class EventChainPostVisitor;
 class EventChainPreVisitor;
 namespace dom {
@@ -38,18 +37,16 @@ public:
   NS_DECL_NSIDOMHTMLLINKELEMENT
 
   // DOM memory reporter participant
   NS_DECL_SIZEOF_EXCLUDING_THIS
 
   void LinkAdded();
   void LinkRemoved();
 
-  void UpdateImport();
-
   // nsIDOMEventTarget
   virtual nsresult GetEventTargetParent(
                      EventChainPreVisitor& aVisitor) override;
   virtual nsresult PostHandleEvent(
                      EventChainPostVisitor& aVisitor) override;
 
   // nsINode
   virtual nsresult Clone(mozilla::dom::NodeInfo* aNodeInfo, nsINode** aResult,
@@ -161,22 +158,16 @@ public:
   {
     GetEnumAttr(nsGkAtoms::referrerpolicy, EmptyCString().get(), aReferrer);
   }
   mozilla::net::ReferrerPolicy GetLinkReferrerPolicy() override
   {
     return GetReferrerPolicyAsEnum();
   }
 
-  already_AddRefed<nsIDocument> GetImport();
-  already_AddRefed<ImportLoader> GetImportLoader()
-  {
-    return RefPtr<ImportLoader>(mImportLoader).forget();
-  }
-
   virtual CORSMode GetCORSMode() const override;
 
   virtual void NodeInfoChanged(nsIDocument* aOldDoc) final override
   {
     ClearHasPendingLinkUpdate();
     nsGenericHTMLElement::NodeInfoChanged(aOldDoc);
   }
 
@@ -187,17 +178,14 @@ protected:
   virtual already_AddRefed<nsIURI> GetStyleSheetURL(bool* aIsInline) override;
   virtual void GetStyleSheetInfo(nsAString& aTitle,
                                  nsAString& aType,
                                  nsAString& aMedia,
                                  bool* aIsScoped,
                                  bool* aIsAlternate) override;
 protected:
   RefPtr<nsDOMTokenList> mRelList;
-
-private:
-  RefPtr<ImportLoader> mImportLoader;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_HTMLLinkElement_h
diff --git a/dom/webidl/HTMLLinkElement.webidl b/dom/webidl/HTMLLinkElement.webidl
--- a/dom/webidl/HTMLLinkElement.webidl
+++ b/dom/webidl/HTMLLinkElement.webidl
@@ -41,19 +41,13 @@ partial interface HTMLLinkElement {
   [SetterThrows, Pure]
            attribute DOMString charset;
   [SetterThrows, Pure]
            attribute DOMString rev;
   [SetterThrows, Pure]
            attribute DOMString target;
 };
 
-// http://w3c.github.io/webcomponents/spec/imports/#interface-import
-partial interface HTMLLinkElement {
-    [Func="nsDocument::IsWebComponentsEnabled"]
-    readonly attribute Document? import;
-};
-
 // https://w3c.github.io/webappsec/specs/subresourceintegrity/#htmllinkelement-1
 partial interface HTMLLinkElement {
   [SetterThrows]
   attribute DOMString integrity;
 };
diff --git a/testing/profiles/prefs_general.js b/testing/profiles/prefs_general.js
--- a/testing/profiles/prefs_general.js
+++ b/testing/profiles/prefs_general.js
@@ -55,17 +55,16 @@ user_pref("app.update.staging.enabled", 
 user_pref("app.update.url.android", "");
 // Make sure GMPInstallManager won't hit the network.
 user_pref("media.gmp-manager.url.override", "http://%(server)s/dummy-gmp-manager.xml");
 user_pref("media.gmp-manager.updateEnabled", false);
 user_pref("dom.w3c_touch_events.enabled", 1);
 user_pref("layout.accessiblecaret.enabled_on_touch", false);
 user_pref("dom.webcomponents.enabled", true);
 user_pref("dom.webcomponents.customelements.enabled", true);
-user_pref("dom.htmlimports.enabled", true);
 // Existing tests assume there is no font size inflation.
 user_pref("font.size.inflation.emPerLine", 0);
 user_pref("font.size.inflation.minTwips", 0);
 // Disable the caret blinking so we get stable snapshot
 user_pref("ui.caretBlinkTime", -1);
 
 // AddonManager tests require that the experiments provider be present.
 user_pref("experiments.supported", true);
diff --git a/testing/web-platform/meta/service-workers/service-worker/fetch-request-html-imports.https.html.ini b/testing/web-platform/meta/service-workers/service-worker/fetch-request-html-imports.https.html.ini
--- a/testing/web-platform/meta/service-workers/service-worker/fetch-request-html-imports.https.html.ini
+++ b/testing/web-platform/meta/service-workers/service-worker/fetch-request-html-imports.https.html.ini
@@ -1,15 +1,5 @@
 [fetch-request-html-imports.https.html]
   type: testharness
-  disabled:
-    if debug: https://bugzilla.mozilla.org/show_bug.cgi?id=1367072
-  expected:
-    if debug and not e10s and (os == "linux") and (version == "Ubuntu 16.04") and (processor == "x86") and (bits == 32): CRASH
-    if debug and e10s and (os == "linux") and (version == "Ubuntu 16.04") and (processor == "x86_64") and (bits == 64): TIMEOUT
-    if debug and not e10s and (os == "win") and (version == "6.1.7601") and (processor == "x86") and (bits == 32): CRASH
-    if debug and e10s and (os == "linux") and (version == "Ubuntu 16.04") and (processor == "x86") and (bits == 32): TIMEOUT
-    if debug and e10s and (os == "win") and (version == "6.1.7601") and (processor == "x86") and (bits == 32): TIMEOUT
-    if debug and not e10s and (os == "win") and (version == "6.2.9200") and (processor == "x86_64") and (bits == 64): CRASH
-    if debug and not e10s and (os == "linux") and (version == "Ubuntu 16.04") and (processor == "x86_64") and (bits == 64): CRASH
   [Verify the FetchEvent for HTMLImports]
     expected: FAIL
 
