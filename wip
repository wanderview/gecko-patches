# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c2e8a05876634b321a02c945e0db70383faa35c0

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3658,25 +3658,40 @@ nsGlobalWindow::MaybeApplyBackPressure()
 
   static const uint32_t kThrottledEventQueueBackPressure = 5000;
   if (taskQueue->Length() < kThrottledEventQueueBackPressure) {
     return;
   }
 
   // First attempt to queue a runnable to resume running timeouts.  We do
   // this first in order to verify we can dispatch successfully.
-  nsCOMPtr<nsIRunnable> r = NewRunnableMethod(this, &nsGlobalWindow::Resume);
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod(this, &nsGlobalWindow::RemoveBackPressure);
   nsresult rv = taskQueue->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS_VOID(rv);
 
   // Since the resume is dispatched we can go ahead and suspend the window
   // now.  Once the task queue drains the resume will automatically get
   // executed balancing this suspend.
-  // TODO: Consider suppressing event handling as well.
   Suspend();
+
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->SuppressEventHandling(nsIDocument::eEvents);
+  }
+}
+
+void
+nsGlobalWindow::RemoveBackPressure()
+{
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+  }
+  Resume();
 }
 
 //*****************************************************************************
 // nsGlobalWindow::nsIScriptObjectPrincipal
 //*****************************************************************************
 
 nsIPrincipal*
 nsGlobalWindow::GetPrincipal()
@@ -8553,16 +8568,23 @@ nsGlobalWindow::PostMessageMozOuter(JSCo
   JS::Rooted<JS::Value> message(aCx, aMessage);
   JS::Rooted<JS::Value> transfer(aCx, aTransfer);
 
   event->Write(aCx, message, transfer, JS::CloneDataPolicy(), aError);
   if (NS_WARN_IF(aError.Failed())) {
     return;
   }
 
+  nsCOMPtr<nsIEventTarget> teq = GetThrottledEventQueue();
+  if (teq) {
+    aError = teq->Dispatch(event.forget(), NS_DISPATCH_NORMAL);
+    MaybeApplyBackPressure();
+    return;
+  }
+
   aError = NS_DispatchToCurrentThread(event);
 }
 
 void
 nsGlobalWindow::PostMessageMoz(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                                const nsAString& aTargetOrigin,
                                JS::Handle<JS::Value> aTransfer,
                                nsIPrincipal& aSubjectPrincipal,
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1704,16 +1704,19 @@ private:
   friend class nsPIDOMWindow<nsISupports>;
 
   // Apply back pressure to the window if the TabGroup ThrottledEventQueue
   // exists and has too many runnables waiting to run.  For example, suspend
   // timers until we have a chance to catch up, etc.
   void
   MaybeApplyBackPressure();
 
+  void
+  RemoveBackPressure();
+
   mozilla::dom::TabGroup* TabGroupInner();
   mozilla::dom::TabGroup* TabGroupOuter();
 
 protected:
   // These members are only used on outer window objects. Make sure
   // you never set any of these on an inner object!
   bool                          mFullScreen : 1;
   bool                          mFullscreenMode : 1;
