# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a6c7e9359b3f7ca211e3aa281176bbc8a61b6918
wip

diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -145,23 +145,21 @@ DOMInterfaces = {
 },
 
 'ChromeWorker': {
     'headerFile': 'mozilla/dom/WorkerPrivate.h',
     'nativeType': 'mozilla::dom::workers::ChromeWorkerPrivate',
 },
 
 'Client': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'Clients': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerClients',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerClients.h',
+    'nativeType': 'mozilla::dom::Clients',
 },
 
 'console': {
     'nativeType': 'mozilla::dom::Console',
 },
 
 'ConvolverNode': {
     'implicitJSContext': [ 'buffer' ],
@@ -1106,18 +1104,17 @@ DOMInterfaces = {
     'nativeType': 'mozilla::extensions::WebExtensionContentScript',
 },
 
 'WebExtensionPolicy': {
     'nativeType': 'mozilla::extensions::WebExtensionPolicy',
 },
 
 'WindowClient': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorkerWindowClient',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorkerWindowClient.h',
+    'nativeType': 'mozilla::dom::Client',
 },
 
 'WebGLActiveInfo': {
     'nativeType': 'mozilla::WebGLActiveInfo',
     'headerFile': 'WebGLActiveInfo.h'
 },
 
 'WebGLBuffer': {
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.cpp
@@ -0,0 +1,260 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Client.h"
+
+#include "ClientDOMUtil.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientState.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/WorkerScope.h"
+#include "nsIGlobalObject.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::dom::ipc::StructuredCloneData;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::Client);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::Client);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(mozilla::dom::Client, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(mozilla::dom::Client)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Client::~Client()
+{
+}
+
+void
+Client::EnsureHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(mozilla::dom::Client);
+  if (!mHandle) {
+    mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()),
+                                          mGlobal->EventTargetFor(TaskCategory::Other));
+  }
+}
+
+Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
+  : mGlobal(aGlobal)
+  , mData(MakeUnique<ClientInfoAndState>(aData))
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+TimeStamp
+Client::CreationTime() const
+{
+  return mData->info().creationTime();
+}
+
+TimeStamp
+Client::LastFocusTime() const
+{
+  if (mData->info().type() != ClientType::Window) {
+    return TimeStamp();
+  }
+  return mData->state().get_IPCClientWindowState().lastFocusTime();
+}
+
+JSObject*
+Client::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  if (mData->info().type() == ClientType::Window) {
+    return WindowClientBinding::Wrap(aCx, this, aGivenProto);
+  }
+  return ClientBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Client::GetParentObject() const
+{
+  return mGlobal;
+}
+
+void
+Client::GetUrl(nsAString& aUrlOut) const
+{
+  CopyUTF8toUTF16(mData->info().url(), aUrlOut);
+}
+
+void
+Client::GetId(nsAString& aIdOut) const
+{
+  char buf[NSID_LENGTH];
+  mData->info().id().ToProvidedString(buf);
+  NS_ConvertASCIItoUTF16 uuid(buf);
+
+  // Remove {} and the null terminator
+  aIdOut.Assign(Substring(uuid, 1, NSID_LENGTH - 3));
+}
+
+ClientType
+Client::Type() const
+{
+  return mData->info().type();
+}
+
+FrameType
+Client::GetFrameType() const
+{
+  return mData->info().frameType();
+}
+
+void
+Client::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+                    const Sequence<JSObject*>& aTransferable,
+                    ErrorResult& aRv)
+{
+  JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
+  aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
+                                                          &transferable);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  StructuredCloneData data;
+  data.Write(aCx, aMessage, transferable, aRv);
+  if (aRv.Failed()) {
+    return;
+  }
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    return;
+  }
+
+  MOZ_ASSERT(!NS_IsMainThread());
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+  if (!workerPrivate) {
+    aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    return;
+  }
+
+  if (!workerPrivate->IsServiceWorker()) {
+    aRv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    return;
+  }
+
+  EnsureHandle();
+  mHandle->PostMessage(data, workerPrivate->GetServiceWorkerDescriptor());
+}
+
+VisibilityState
+Client::GetVisibilityState() const
+{
+  return mData->state().get_IPCClientWindowState().visibilityState();
+}
+
+bool
+Client::Focused() const
+{
+  return mData->state().get_IPCClientWindowState().focused();
+}
+
+already_AddRefed<Promise>
+Client::Focus(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  Maybe<ClientInfo> info(ClientGetInfo(mGlobal));
+  if (info.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  bool interactionAllowed = false;
+
+  if (info.ref().Type() == ClientType::Serviceworker) {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_DIAGNOSTIC_ASSERT(workerPrivate);
+    interactionAllowed = workerPrivate->GlobalScope()->WindowInteractionAllowed();
+  } else {
+    // TODO: hook this up to the gPopupControlState code in nsGlobalWindow
+    interactionAllowed = false;
+  }
+
+  if (!interactionAllowed) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+    return outerPromise.forget();
+  }
+
+  EnsureHandle();
+
+  RefPtr<Client> self = this;
+
+  RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
+  innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
+    [self, outerPromise] (const ClientState& aResult) {
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+    }
+  }
+
+  RefPtr<Client> self = this;
+
+  ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+
+  StartClientManagerOp(&ClientManager::Navigate, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [self, outerPromise] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(newClient);
+    }, [self, outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Client.h
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Client_h
+#define _mozilla_dom_Client_h
+
+#include "mozilla/dom/ClientBinding.h"
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class ClientHandle;
+class ClientInfoAndState;
+class Promise;
+
+template <typename t> class Sequence;
+
+class Client final : public nsISupports
+                   , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+  UniquePtr<ClientInfoAndState> mData;
+  RefPtr<ClientHandle> mHandle;
+
+  ~Client();
+
+  void
+  EnsureHandle();
+
+public:
+  Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData);
+
+  TimeStamp
+  CreationTime() const;
+
+  TimeStamp
+  LastFocusTime() const;
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  // Client Bindings
+  void
+  GetUrl(nsAString& aUrlOut) const;
+
+  void
+  GetId(nsAString& aIdOut) const;
+
+  ClientType
+  Type() const;
+
+  FrameType
+  GetFrameType() const;
+
+  // WindowClient bindings
+  VisibilityState
+  GetVisibilityState() const;
+
+  bool
+  Focused() const;
+
+  already_AddRefed<Promise>
+  Focus(ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Navigate(const nsAString& aURL, ErrorResult& aRv);
+
+  void
+  PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
+              const Sequence<JSObject*>& aTransferrable,
+              ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(mozilla::dom::Client)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Client_h
diff --git a/dom/clients/api/ClientDOMUtil.cpp b/dom/clients/api/ClientDOMUtil.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.cpp
@@ -0,0 +1,34 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientDOMUtil.h"
+
+namespace mozilla {
+namespace dom {
+
+Maybe<ClientInfo>
+ClientGetInfo(nsIGlobalObject* aGlobal)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aGlobal);
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  if (window) {
+    return Move(window->GetClientInfo());
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      Maybe<ClientInfo> info;
+      info.emplace(workerPrivate->GetClientInfo());
+      return Move(info);
+    }
+  }
+
+  return Maybe<ClientInfo>();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientDOMUtil_h
+#define _mozilla_dom_ClientDOMUtil_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+namespace dom {
+
+class ClientInfo;
+
+Maybe<ClientInfo>
+ClientGetInfo(nsIGlobalObject* aGlobal);
+
+// TODO: Add a ClientHandle version of this wrapper for Client methods.
+template<typename Func, typename Arg, typename Resolve, typename Reject>
+void
+StartClientManagerOp(Func aFunc, const Arg& aArg, nsISerialEventTarget* aTarget,
+                     Resolve aResolve, Reject aReject)
+{
+  using mozilla::dom::workers::Closing;
+  using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+  using mozilla::dom::workers::WorkerHolderToken;
+
+  RefPtr<WorkerHolderToken> token;
+  if (!NS_IsMainThread()) {
+    token = WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Closing);
+  }
+
+  RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
+  promise->Then(aTarget, __func__,
+    [aResolve, token](const ClientOpResult& aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aResolve(aResult);
+    }, [aReject, token](nsresult aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aReject(aResult);
+    });
+}
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientDOMUtil_h
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.cpp
@@ -0,0 +1,294 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "Clients.h"
+
+#include "ClientDOMUtil.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientsBinding.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "nsIGlobalObject.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
+using mozilla::ipc::PrincipalInfo;
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Clients);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Clients);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Clients, mGlobal);
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Clients)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Clients::~Clients()
+{
+}
+
+Clients::Clients(nsIGlobalObject* aGlobal)
+  : mGlobal(aGlobal)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+}
+
+JSObject*
+Clients::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  return ClientsBinding::Wrap(aCx, this, aGivenProto);
+}
+
+nsIGlobalObject*
+Clients::GetParentObject() const
+{
+  return mGlobal;
+}
+
+already_AddRefed<Promise>
+Clients::Get(const nsAString& aClientID, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  nsID id;
+  if (!id.Parse(NS_ConvertUTF16toUTF8(aClientID).get())) {
+    // Invalid ID means we will definitely not find a match, so just
+    // resolve with undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  Maybe<ClientInfo> info(ClientGetInfo(mGlobal));
+  if (info.isNothing()) {
+    // If we can't get an info then we don't have a recognizeable
+    // principal and we won't effectively match anything.  Resolve
+    // undefined indicating "not found".
+    outerPromise->MaybeResolveWithUndefined();
+    return outerPromise.forget();
+  }
+
+  const PrincipalInfo& principalInfo = info.ref().PrincipalInfo();
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+  nsCOMPtr<nsISerialEventTarget> target =
+    mGlobal->EventTargetFor(TaskCategory::Other);
+
+  RefPtr<ClientOpPromise> innerPromise =
+    ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
+                                   target);
+  innerPromise->Then(target, __func__,
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolve(
+        new Client(global, aResult.get_ClientInfoAndState()));
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    });
+
+  return outerPromise.forget();
+}
+
+namespace {
+
+class MatchAllComparator final
+{
+public:
+  bool
+  LessThan(Client* aLeft, Client* aRight) const
+  {
+    TimeStamp leftFocusTime = aLeft->LastFocusTime();
+    TimeStamp rightFocusTime = aRight->LastFocusTime();
+    // If the focus times are the same, then default to creation order.
+    // MatchAll should return oldest Clients first.
+    if (leftFocusTime == rightFocusTime) {
+      return aLeft->CreationTime() < aRight->CreationTime();
+    }
+
+    // Otherwise compare focus times.  We reverse the logic here so
+    // that the most recently focused window is first in the list.
+    if (!leftFocusTime.IsNull() && rightFocusTime.IsNull()) {
+      return true;
+    }
+    if (leftFocusTime.IsNull() && !rightFocusTime.IsNull()) {
+      return false;
+    }
+    return leftFocusTime > rightFocusTime;
+  }
+
+  bool
+  Equals(Client* aLeft, Client* aRight) const
+  {
+    return aLeft->LastFocusTime() == aRight->LastFocusTime() &&
+           aLeft->CreationTime() == aRight->CreationTime();
+  }
+};
+
+} // anonymous namespace
+
+already_AddRefed<Promise>
+Clients::MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  Maybe<ClientInfo> info(ClientGetInfo(mGlobal));
+  if (info.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  if (info.ref().Type() != ClientType::Serviceworker) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  ClientMatchAllArgs args(workerPrivate->GetServiceWorkerDescriptor().ToIPC(),
+                          aOptions.mType,
+                          aOptions.mIncludeUncontrolled);
+  StartClientManagerOp(&ClientManager::MatchAll, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      nsTArray<RefPtr<Client>> clientList;
+      for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
+        clientList.AppendElement(new Client(global, value));
+      }
+      clientList.Sort(MatchAllComparator());
+      outerPromise->MaybeResolve(clientList);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  if (aURL.EqualsLiteral("about:blank")) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_TYPE_ERR);
+    return outerPromise.forget();
+  }
+
+  bool interactionAllowed = false;
+
+  PrincipalInfo principalInfo;
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+    nsIDocument* doc = window->GetExtantDoc();
+    if (doc) {
+      nsIPrincipal* principal = doc->NodePrincipal();
+      if (principal) {
+        aRv = PrincipalToPrincipalInfo(principal, &principalInfo);
+        if (aRv.Failed()) {
+          return outerPromise.forget();
+        }
+      }
+    }
+    // TODO: hook this up to the gPopupControlState code in nsGlobalWindow
+    interactionAllowed = false;
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+      principalInfo = workerPrivate->GetPrincipalInfo();
+
+      interactionAllowed = workerPrivate->GlobalScope()->WindowInteractionAllowed();
+    }
+  }
+
+  if (!interactionAllowed) {
+    outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
+    return outerPromise.forget();
+  }
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  ClientOpenWindowArgs args(principalInfo, NS_ConvertUTF16toUTF8(aURL), baseURL);
+  StartClientManagerOp(&ClientManager::OpenWindow, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> client =
+        new Client(global, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(client);
+    }, [outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
+}
+
+already_AddRefed<Promise>
+Clients::Claim(ErrorResult& aRv)
+{
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  Maybe<ClientInfo> info(ClientGetInfo(mGlobal));
+  if (info.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  if (info.ref().Type() != ClientType::Serviceworker) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+  const ServiceWorkerDescriptor& serviceWorker =
+    workerPrivate->GetServiceWorkerDescriptor();
+
+  if (serviceWorker.State() != ServiceWorkerState::Activating &&
+      serviceWorker.State() != ServiceWorkerState::Activated) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return outerPromise.forget();
+  }
+
+  StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker.ToIPC()),
+    mGlobal->EventTargetFor(TaskCategory::Other),
+    [outerPromise] (const ClientOpResult& aResult) {
+      outerPromise->MaybeResolveWithUndefined();
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->MaybeReject(aResult);
+    });
+
+  return outerPromise.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/Clients.h b/dom/clients/api/Clients.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/Clients.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_Clients_h
+#define _mozilla_dom_Clients_h
+
+#include "nsCOMPtr.h"
+#include "nsISupports.h"
+#include "nsWrapperCache.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+struct ClientQueryOptions;
+class Promise;
+
+class Clients final : public nsISupports
+                    , public nsWrapperCache
+{
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+
+  ~Clients();
+
+public:
+  explicit Clients(nsIGlobalObject* aGlobal);
+
+  // nsWrapperCache interface methods
+  JSObject*
+  WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+  // DOM bindings methods
+  nsIGlobalObject*
+  GetParentObject() const;
+
+  already_AddRefed<Promise>
+  Get(const nsAString& aClientID, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  OpenWindow(const nsAString& aURL, ErrorResult& aRv);
+
+  already_AddRefed<Promise>
+  Claim(ErrorResult& aRv);
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Clients)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_Clients_h
diff --git a/dom/clients/api/moz.build b/dom/clients/api/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/moz.build
@@ -0,0 +1,33 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'Client.h',
+  'Clients.h',
+]
+
+UNIFIED_SOURCES += [
+  'Client.cpp',
+  'ClientDOMUtil.cpp',
+  'Clients.cpp',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+  '/dom/workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -350,16 +350,33 @@ ClientSource::SetController(const Servic
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   if (mController.isSome() && mController.ref() == aServiceWorker) {
     return;
   }
 
   mController.reset();
   mController.emplace(aServiceWorker);
+
+  RefPtr<ServiceWorkerContainer> swc;
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (window) {
+    RefPtr<Navigator> navigator =
+      static_cast<Navigator*>(window->GetNavigator());
+    if (navigator) {
+      swc = navigator->ServiceWorker();
+    }
+  }
+
+  // TODO: Also self.navigator.serviceWorker on workers when its exposed there
+
+  if (swc && nsContentUtils::IsSafeToRunScript()) {
+    IgnoredErrorResult ignored;
+    swc->ControllerChanged(ignored);
+  }
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
@@ -544,21 +561,49 @@ ClientSource::PostMessage(const ClientPo
 
   ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
   return ref.forget();
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::Claim(const ClientClaimArgs& aArgs)
 {
-  SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
+  RefPtr<ClientOpPromise> ref;
+
+  ServiceWorkerDescriptor swd(aArgs.serviceWorker());
 
-  RefPtr<ClientOpPromise> ref =
-    ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  // Today the ServiceWorkerManager maintains its own list of
+  // nsIDocument objects controlled by each service worker.  We
+  // need to try to update that data structure for now.  If we
+  // can't, however, then simply mark the Client as controlled.
+  // In the future this will be enough for the SWM as well since
+  // it will eventually hold ClientHandle objects instead of
+  // nsIDocuments.
+  nsPIDOMWindowInner* innerWindow = GetInnerWindow();
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+  RefPtr<ServiceWorkerManager> swm = doc ? ServiceWorkerManager::GetInstance()
+                                         : nullptr;
+  if (!swm || !doc) {
+    SetController(swd);
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
 
+  RefPtr<ClientOpPromise::Private> outerPromise =
+    new ClientOpPromise::Private(__func__);
+
+  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
+  p->Then(mEventTarget, __func__,
+    [outerPromise] (bool aResult) {
+      outerPromise->Resolve(NS_OK, __func__);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->Reject(aResult, __func__);
+    });
+
+  ref = outerPromise;
   return ref.forget();
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
diff --git a/dom/clients/moz.build b/dom/clients/moz.build
--- a/dom/clients/moz.build
+++ b/dom/clients/moz.build
@@ -1,9 +1,10 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 DIRS += [
+  'api',
   'manager',
 ]
diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -134,16 +134,17 @@ MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLAT
                                           PRFileDesc,
                                           PR_Close);
 
 namespace dom {
 namespace indexedDB {
 
 using namespace mozilla::dom::quota;
 using namespace mozilla::ipc;
+using mozilla::dom::quota::Client;
 
 namespace {
 
 class ConnectionPool;
 class Cursor;
 class Database;
 struct DatabaseActorInfo;
 class DatabaseFile;
diff --git a/dom/webidl/Client.webidl b/dom/webidl/Client.webidl
--- a/dom/webidl/Client.webidl
+++ b/dom/webidl/Client.webidl
@@ -8,30 +8,32 @@
  *
  */
 
 [Exposed=ServiceWorker]
 interface Client {
   readonly attribute USVString url;
 
   // Remove frameType in bug 1290936
+  [BinaryName="GetFrameType"]
   readonly attribute FrameType frameType;
 
   readonly attribute ClientType type;
   readonly attribute DOMString id;
 
   // Implement reserved in bug 1264177
   // readonly attribute boolean reserved;
 
   [Throws]
   void postMessage(any message, optional sequence<object> transfer = []);
 };
 
 [Exposed=ServiceWorker]
 interface WindowClient : Client {
+  [BinaryName="GetVisibilityState"]
   readonly attribute VisibilityState visibilityState;
   readonly attribute boolean focused;
 
   // Implement ancestorOrigins in bug 1264180
   // [SameObject] readonly attribute FrozenArray<USVString> ancestorOrigins;
 
   [Throws, NewObject]
   Promise<WindowClient> focus();
diff --git a/dom/webidl/Clients.webidl b/dom/webidl/Clients.webidl
--- a/dom/webidl/Clients.webidl
+++ b/dom/webidl/Clients.webidl
@@ -10,18 +10,18 @@
 
 [Exposed=ServiceWorker]
 interface Clients {
   // The objects returned will be new instances every time
   [NewObject]
   Promise<any> get(DOMString id);
   [NewObject]
   Promise<sequence<Client>> matchAll(optional ClientQueryOptions options);
-  [NewObject,
-   Func="mozilla::dom::ServiceWorkerGlobalScope::OpenWindowEnabled"]
+  // TODO: fix pref enabled func
+  [NewObject]
   Promise<WindowClient?> openWindow(USVString url);
   [NewObject]
   Promise<void> claim();
 };
 
 dictionary ClientQueryOptions {
   boolean includeUncontrolled = false;
   ClientType type = "window";
diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -10,17 +10,18 @@
  *
  * You are granted a license to use, reproduce and create derivative works of
  * this document.
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
-  [SameObject] readonly attribute Clients clients;
+  [SameObject, BinaryName="GetClients"]
+  readonly attribute Clients clients;
   [SameObject] readonly attribute ServiceWorkerRegistration registration;
 
   [Throws, NewObject]
   Promise<void> skipWaiting();
 
   attribute EventHandler oninstall;
   attribute EventHandler onactivate;
 
diff --git a/dom/workers/ServiceWorker.cpp b/dom/workers/ServiceWorker.cpp
--- a/dom/workers/ServiceWorker.cpp
+++ b/dom/workers/ServiceWorker.cpp
@@ -3,22 +3,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "WorkerPrivate.h"
 
 #include "mozilla/Preferences.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
@@ -97,16 +98,24 @@ ServiceWorker::PostMessage(JSContext* aC
   if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
     ServiceWorkerManager::LocalizeAndReportToAllClients(
       mInfo->Scope(), "ServiceWorkerPostMessageStorageError",
       nsTArray<nsString> { NS_ConvertUTF8toUTF16(mInfo->Scope()) });
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return;
   }
 
-  UniquePtr<ServiceWorkerClientInfo> clientInfo(new ServiceWorkerClientInfo(window->GetExtantDoc()));
+  Maybe<ClientInfo> clientInfo = window->GetClientInfo();
+  Maybe<ClientState> clientState = window->GetClientState();
+  if (clientInfo.isNothing() || clientState.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+
   ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
-  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable, Move(clientInfo));
+  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
+                                        ClientInfoAndState(clientInfo.ref().ToIPC(),
+                                                           clientState.ref().ToIPC()));
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -239,25 +239,30 @@ public:
 
 class ResolveClaimRunnable final : public WorkerRunnable
 {
   RefPtr<PromiseWorkerProxy> mPromiseProxy;
   nsresult mResult;
 
 public:
   ResolveClaimRunnable(WorkerPrivate* aWorkerPrivate,
-                       PromiseWorkerProxy* aPromiseProxy,
-                       nsresult aResult)
+                       PromiseWorkerProxy* aPromiseProxy)
     : WorkerRunnable(aWorkerPrivate)
     , mPromiseProxy(aPromiseProxy)
-    , mResult(aResult)
+    , mResult(NS_OK)
   {
     AssertIsOnMainThread();
   }
 
+  void
+  SetResult(nsresult aResult)
+  {
+    mResult = aResult;
+  }
+
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
     aWorkerPrivate->AssertIsOnWorkerThread();
 
     RefPtr<Promise> promise = mPromiseProxy->WorkerPromise();
     MOZ_ASSERT(promise);
@@ -297,30 +302,39 @@ public:
     MutexAutoLock lock(mPromiseProxy->Lock());
     if (mPromiseProxy->CleanedUp()) {
       return NS_OK;
     }
 
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
-    nsresult rv = NS_OK;
+    RefPtr<ResolveClaimRunnable> resolveRunnable =
+      new ResolveClaimRunnable(workerPrivate, mPromiseProxy);
+
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       // browser shutdown
-      rv = NS_ERROR_FAILURE;
-    } else {
-      rv = swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
-                             mServiceWorkerID);
+      resolveRunnable->SetResult(NS_ERROR_FAILURE);
+      resolveRunnable->Dispatch();
+      return NS_OK;
     }
 
-    RefPtr<ResolveClaimRunnable> r =
-      new ResolveClaimRunnable(workerPrivate, mPromiseProxy, rv);
+    RefPtr<GenericPromise::AllPromiseType> p =
+      swm->ClaimClients(workerPrivate->GetPrincipal(), mScope,
+                        mServiceWorkerID);
+    p->Then(AbstractThread::GetCurrent(), __func__,
+      [resolveRunnable](const nsTArray<bool>& aResultList) {
+        resolveRunnable->SetResult(NS_OK);
+        resolveRunnable->Dispatch();
+      }, [resolveRunnable](nsresult aRv) {
+        resolveRunnable->SetResult(aRv);
+        resolveRunnable->Dispatch();
+      });
 
-    r->Dispatch();
     return NS_OK;
   }
 };
 
 class ResolveOpenWindowRunnable final : public WorkerRunnable
 {
 public:
   ResolveOpenWindowRunnable(PromiseWorkerProxy* aPromiseProxy,
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -26,16 +26,17 @@
 #include "nsQueryObject.h"
 #include "ServiceWorkerClient.h"
 #include "ServiceWorkerManager.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/BodyUtil.h"
+#include "mozilla/dom/Client.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/PushMessageDataBinding.h"
 #include "mozilla/dom/PushUtil.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/TypedArray.h"
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -264,17 +264,17 @@ public:
   }
 };
 
 class ExtendableMessageEvent final : public ExtendableEvent
 {
   JS::Heap<JS::Value> mData;
   nsString mOrigin;
   nsString mLastEventId;
-  RefPtr<ServiceWorkerClient> mClient;
+  RefPtr<Client> mClient;
   RefPtr<ServiceWorker> mServiceWorker;
   RefPtr<MessagePort> mMessagePort;
   nsTArray<RefPtr<MessagePort>> mPorts;
 
 protected:
   explicit ExtendableMessageEvent(EventTarget* aOwner);
   ~ExtendableMessageEvent();
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -62,17 +62,16 @@
 #include "nsGlobalWindow.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
-#include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerInfo.h"
 #include "ServiceWorkerJobQueue.h"
 #include "ServiceWorkerManagerChild.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerRegisterJob.h"
 #include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
@@ -2551,30 +2550,27 @@ ServiceWorkerManager::GetServiceWorkerFo
 
 namespace {
 
 class ContinueDispatchFetchEventRunnable : public Runnable
 {
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
-  nsString mDocumentId;
   bool mIsReload;
 public:
   ContinueDispatchFetchEventRunnable(
     ServiceWorkerPrivate* aServiceWorkerPrivate,
     nsIInterceptedChannel* aChannel,
     nsILoadGroup* aLoadGroup,
-    const nsAString& aDocumentId,
     bool aIsReload)
     : Runnable("dom::workers::ContinueDispatchFetchEventRunnable")
     , mServiceWorkerPrivate(aServiceWorkerPrivate)
     , mChannel(aChannel)
     , mLoadGroup(aLoadGroup)
-    , mDocumentId(aDocumentId)
     , mIsReload(aIsReload)
   {
     MOZ_ASSERT(aServiceWorkerPrivate);
     MOZ_ASSERT(aChannel);
   }
 
   void
   HandleError()
@@ -2605,18 +2601,29 @@ public:
     // if that happens.
     nsresult status;
     rv = channel->GetStatus(&status);
     if (NS_WARN_IF(NS_FAILED(rv) || NS_FAILED(status))) {
       HandleError();
       return NS_OK;
     }
 
-    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup,
-                                               mDocumentId, mIsReload);
+    nsString clientId;
+    nsCOMPtr<nsILoadInfo> loadInfo = channel->GetLoadInfo();
+    if (loadInfo) {
+      Maybe<ClientInfo> clientInfo = loadInfo->GetClientInfo();
+      if (clientInfo.isSome()) {
+        char buf[NSID_LENGTH];
+        clientInfo.ref().Id().ToProvidedString(buf);
+        CopyUTF8toUTF16(nsDependentCString(buf), clientId);
+      }
+    }
+
+    rv = mServiceWorkerPrivate->SendFetchEvent(mChannel, mLoadGroup, clientId,
+                                               mIsReload);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       HandleError();
     }
 
     return NS_OK;
   }
 };
 
@@ -2631,44 +2638,36 @@ ServiceWorkerManager::DispatchFetchEvent
                                          bool aIsSubresourceLoad,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerInfo> serviceWorker;
   nsCOMPtr<nsILoadGroup> loadGroup;
-  nsAutoString documentId;
 
   if (aIsSubresourceLoad) {
     MOZ_ASSERT(aDoc);
 
     serviceWorker = GetActiveWorkerInfoForDocument(aDoc);
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     loadGroup = aDoc->GetDocumentLoadGroup();
-    nsresult rv = aDoc->GetOrCreateId(documentId);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
-    }
   } else {
     nsCOMPtr<nsIChannel> internalChannel;
     aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     internalChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 
-    // TODO: Use aDocumentIdForTopLevelNavigation for potentialClientId, pending
-    // the spec change.
-
     nsCOMPtr<nsIURI> uri;
     aRv = aChannel->GetSecureUpgradedChannelURI(getter_AddRefs(uri));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     // non-subresource request means the URI contains the principal
     nsCOMPtr<nsIPrincipal> principal =
@@ -2738,18 +2737,17 @@ ServiceWorkerManager::DispatchFetchEvent
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
 
   nsCOMPtr<nsIRunnable> continueRunnable =
     new ContinueDispatchFetchEventRunnable(serviceWorker->WorkerPrivate(),
-                                           aChannel, loadGroup,
-                                           documentId, aIsReload);
+                                           aChannel, loadGroup, aIsReload);
 
   // When this service worker was registered, we also sent down the permissions
   // for the runnable. They should have arrived by now, but we still need to
   // wait for them if they have not.
   nsCOMPtr<nsIRunnable> permissionsRunnable = NS_NewRunnableFunction(
     "dom::workers::ServiceWorkerManager::DispatchFetchEvent", [=]() {
       nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
       MOZ_ALWAYS_SUCCEEDS(permMgr->WhenPermissionsAvailable(serviceWorker->Principal(),
@@ -2833,32 +2831,52 @@ ServiceWorkerManager::GetDocumentRegistr
 NS_IMETHODIMP
 ServiceWorkerManager::GetDocumentController(nsPIDOMWindowInner* aWindow,
                                             nsISupports** aServiceWorker)
 {
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  Maybe<ServiceWorkerDescriptor> controller = aWindow->GetController();
+  if (controller.isNothing()) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  if (!doc) {
+  if (NS_WARN_IF(!doc)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  RefPtr<ServiceWorkerRegistrationInfo> registration;
-  nsresult rv = GetDocumentRegistration(doc, getter_AddRefs(registration));
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (NS_WARN_IF(!principal)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  nsAutoCString scopeKey;
+  nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  MOZ_ASSERT(registration->GetActive());
-  RefPtr<ServiceWorker> serviceWorker =
-    registration->GetActive()->GetOrCreateInstance(aWindow);
-
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(scopeKey, controller.ref().Scope());
+  if (NS_WARN_IF(!registration)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorkerInfo> active = registration->GetActive();
+  if (NS_WARN_IF(!active) ||
+      NS_WARN_IF(active->Descriptor().Id() != controller.ref().Id())) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorker> serviceWorker = active->GetOrCreateInstance(aWindow);
   serviceWorker.forget(aServiceWorker);
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetInstalling(nsPIDOMWindowInner* aWindow,
                                     const nsAString& aScope,
                                     nsISupports** aServiceWorker)
 {
@@ -3153,46 +3171,17 @@ ServiceWorkerManager::UpdateInternal(nsI
                                registration->GetUpdateViaCache());
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);
 
   queue->ScheduleJob(job);
 }
 
-namespace {
-
-static void
-FireControllerChangeOnDocument(nsIDocument* aDocument)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDocument);
-
-  nsCOMPtr<nsPIDOMWindowInner> w = aDocument->GetInnerWindow();
-  if (!w) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-    return;
-  }
-
-  auto* window = nsGlobalWindowInner::Cast(w.get());
-  dom::Navigator* navigator = window->Navigator();
-  if (!navigator) {
-    return;
-  }
-
-  RefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
-  ErrorResult result;
-  container->ControllerChanged(result);
-  if (result.Failed()) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-  }
-}
-
-} // anonymous namespace
-
+/* TODO
 UniquePtr<ServiceWorkerClientInfo>
 ServiceWorkerManager::GetClient(nsIPrincipal* aPrincipal,
                                 const nsAString& aClientId,
                                 ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   UniquePtr<ServiceWorkerClientInfo> clientInfo;
   nsCOMPtr<nsISupportsInterfacePointer> ifptr =
@@ -3239,17 +3228,19 @@ ServiceWorkerManager::GetClient(nsIPrinc
                                     nsContentUtils::eDOM_PROPERTIES,
                                     "ServiceWorkerGetClientStorageError");
     return clientInfo;
   }
 
   clientInfo.reset(new ServiceWorkerClientInfo(doc));
   return clientInfo;
 }
-
+*/
+
+/* TODO
 void
 ServiceWorkerManager::GetAllClients(nsIPrincipal* aPrincipal,
                                     const nsCString& aScope,
                                     uint64_t aServiceWorkerID,
                                     bool aIncludeUncontrolled,
                                     nsTArray<ServiceWorkerClientInfo>& aDocuments)
 {
   AssertIsOnMainThread();
@@ -3344,88 +3335,128 @@ ServiceWorkerManager::GetAllClients(nsIP
   uint32_t ordinal = 0;
   for (uint32_t i = 0; i < docList.Length(); ++i) {
     aDocuments.AppendElement(ServiceWorkerClientInfo(docList[i], ordinal));
     ordinal += 1;
   }
 
   aDocuments.Sort();
 }
-
-void
+*/
+
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
                                        ServiceWorkerRegistrationInfo* aWorkerRegistration)
 {
   MOZ_ASSERT(aWorkerRegistration);
   MOZ_ASSERT(aWorkerRegistration->GetActive());
 
+  RefPtr<GenericPromise> ref;
+
   // Same origin check
   if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
-    return;
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_SECURITY_ERR, __func__);
+    return ref.forget();
   }
 
   // The registration that should be controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
     GetServiceWorkerRegistrationInfo(aDocument);
 
   // The registration currently controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> controllingRegistration;
   GetDocumentRegistration(aDocument, getter_AddRefs(controllingRegistration));
 
   if (aWorkerRegistration != matchingRegistration ||
-        aWorkerRegistration == controllingRegistration) {
-    return;
+      aWorkerRegistration == controllingRegistration) {
+    ref = GenericPromise::CreateAndResolve(true, __func__);
+    return ref.forget();
   }
 
   if (controllingRegistration) {
     StopControllingADocument(controllingRegistration);
   }
 
-  StartControllingADocument(aWorkerRegistration, aDocument, NS_LITERAL_STRING(""));
-  FireControllerChangeOnDocument(aDocument);
+  ref = StartControllingADocument(aWorkerRegistration, aDocument,
+                                  NS_LITERAL_STRING(""));
+  return ref.forget();
 }
 
-nsresult
+already_AddRefed<GenericPromise>
+ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
+                                       const ServiceWorkerDescriptor& aServiceWorker)
+{
+  RefPtr<GenericPromise> ref;
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
+  if (!principal) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(principal, aServiceWorker.Scope());
+  if (!registration) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  ref = MaybeClaimClient(aDoc, registration);
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise::AllPromiseType>
 ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
                                    const nsCString& aScope, uint64_t aId)
 {
+  RefPtr<GenericPromise::AllPromiseType> ref;
+
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aPrincipal, aScope);
 
   if (!registration || !registration->GetActive() ||
       !(registration->GetActive()->ID() == aId)) {
     // The worker is not active.
-    return NS_ERROR_DOM_INVALID_STATE_ERR;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
   if (NS_WARN_IF(!obs)) {
-    return NS_ERROR_FAILURE;
+    ref = GenericPromise::AllPromiseType::CreateAndReject(NS_ERROR_FAILURE,
+                                                          __func__);
+    return ref.forget();
   }
 
   nsCOMPtr<nsISimpleEnumerator> enumerator;
   nsresult rv = obs->EnumerateObservers("service-worker-get-client",
                                         getter_AddRefs(enumerator));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
+    ref = GenericPromise::AllPromiseType::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  AutoTArray<RefPtr<GenericPromise>, 32> claimPromiseList;
 
   bool loop = true;
   while (NS_SUCCEEDED(enumerator->HasMoreElements(&loop)) && loop) {
     nsCOMPtr<nsISupports> ptr;
     rv = enumerator->GetNext(getter_AddRefs(ptr));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(ptr);
-    MaybeClaimClient(doc, registration);
-  }
-
-  return NS_OK;
+    claimPromiseList.AppendElement(MaybeClaimClient(doc, registration));
+  }
+
+  ref = GenericPromise::All(AbstractThread::GetCurrent(), claimPromiseList);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::SetSkipWaitingFlag(nsIPrincipal* aPrincipal,
                                          const nsCString& aScope,
                                          uint64_t aServiceWorkerID)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -3444,38 +3475,52 @@ ServiceWorkerManager::SetSkipWaitingFlag
   worker->SetSkipWaitingFlag();
 
   if (worker->State() == ServiceWorkerState::Installed) {
     registration->TryToActivateAsync();
   }
 }
 
 void
-ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration)
 {
   AssertIsOnMainThread();
 
-  AutoTArray<nsCOMPtr<nsIDocument>, 16> documents;
+  RefPtr<ServiceWorkerInfo> activeWorker = aRegistration->GetActive();
+  MOZ_DIAGNOSTIC_ASSERT(activeWorker);
+
+  AutoTArray<nsCOMPtr<nsPIDOMWindowInner>, 16> innerWindows;
   for (auto iter = mControlledDocuments.Iter(); !iter.Done(); iter.Next()) {
     if (iter.UserData() != aRegistration) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(iter.Key());
     if (NS_WARN_IF(!doc)) {
       continue;
     }
 
-    documents.AppendElement(doc);
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      continue;
+    }
+
+    innerWindows.AppendElement(innerWindow);
   }
 
   // Fire event after iterating mControlledDocuments is done to prevent
   // modification by reentering from the event handlers during iteration.
-  for (auto& doc : documents) {
-    FireControllerChangeOnDocument(doc);
+  for (auto& innerWindow : innerWindows) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    innerWindow->EventTargetFor(TaskCategory::Other));
+      clientHandle->Control(activeWorker->Descriptor());
+    }
   }
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
                                       const nsACString& aScope) const
 {
   MOZ_ASSERT(aPrincipal);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -41,17 +41,16 @@ class OriginAttributes;
 
 namespace dom {
 
 class ServiceWorkerRegistrar;
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
-class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
@@ -268,33 +267,39 @@ public:
               const nsString& aMessage,
               const nsString& aFilename,
               const nsString& aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags,
               JSExnType aExnType);
 
+  /*
   UniquePtr<ServiceWorkerClientInfo>
   GetClient(nsIPrincipal* aPrincipal,
             const nsAString& aClientId,
             ErrorResult& aRv);
 
   void
   GetAllClients(nsIPrincipal* aPrincipal,
                 const nsCString& aScope,
                 uint64_t aServiceWorkerID,
                 bool aIncludeUncontrolled,
                 nsTArray<ServiceWorkerClientInfo>& aDocuments);
+  */
 
-  void
+  already_AddRefed<GenericPromise>
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
-  nsresult
+  already_AddRefed<GenericPromise>
+  MaybeClaimClient(nsIDocument* aDoc,
+                   const ServiceWorkerDescriptor& aServiceWorker);
+
+  already_AddRefed<GenericPromise::AllPromiseType>
   ClaimClients(nsIPrincipal* aPrincipal, const nsCString& aScope, uint64_t aId);
 
   void
   SetSkipWaitingFlag(nsIPrincipal* aPrincipal, const nsCString& aScope,
                      uint64_t aServiceWorkerID);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
@@ -436,17 +441,17 @@ private:
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration);
+  UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   StorePendingReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                            Promise* aPromise);
 
   bool
   CheckReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                     Promise* aPromise);
diff --git a/dom/workers/ServiceWorkerManagerService.h b/dom/workers/ServiceWorkerManagerService.h
--- a/dom/workers/ServiceWorkerManagerService.h
+++ b/dom/workers/ServiceWorkerManagerService.h
@@ -5,16 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerManagerService_h
 #define mozilla_dom_ServiceWorkerManagerService_h
 
 #include "nsISupportsImpl.h"
 #include "nsHashKeys.h"
 #include "nsTHashtable.h"
+#include "nsTArray.h"
 
 namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -21,30 +21,34 @@
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/Client.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 BEGIN_WORKERS_NAMESPACE
 
+using mozilla::ipc::PrincipalInfo;
+
 NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTION(ServiceWorkerPrivate, mSupportsArray)
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(ServiceWorkerPrivate, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(ServiceWorkerPrivate, Release)
 
 // Tracks the "dom.serviceWorkers.disable_open_click_delay" preference.  Modified
@@ -482,29 +486,28 @@ public:
 
     return NS_OK;
   }
 };
 
 class SendMesssageEventRunnable final : public ExtendableEventWorkerRunnable
                                       , public StructuredCloneHolder
 {
-  UniquePtr<ServiceWorkerClientInfo> mEventSource;
+  const ClientInfoAndState mClientInfoAndState;
 
 public:
   SendMesssageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                             KeepAliveToken* aKeepAliveToken,
-                            UniquePtr<ServiceWorkerClientInfo>&& aEventSource)
+                            const ClientInfoAndState& aClientInfoAndState)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
     , StructuredCloneHolder(CloningSupported, TransferringSupported,
                             StructuredCloneScope::SameProcessDifferentThread)
-    , mEventSource(Move(aEventSource))
+    , mClientInfoAndState(aClientInfoAndState)
   {
     AssertIsOnMainThread();
-    MOZ_ASSERT(mEventSource);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
@@ -513,26 +516,25 @@ public:
       return true;
     }
 
     Sequence<OwningNonNull<MessagePort>> ports;
     if (!TakeTransferredPortsAsSequence(ports)) {
       return true;
     }
 
-    RefPtr<ServiceWorkerClient> client = new ServiceWorkerWindowClient(sgo,
-                                                                       *mEventSource);
     RootedDictionary<ExtendableMessageEventInit> init(aCx);
 
     init.mBubbles = false;
     init.mCancelable = false;
 
     init.mData = messageData;
     init.mPorts = ports;
-    init.mSource.SetValue().SetAsClient() = client;
+
+    init.mSource.SetValue().SetAsClient() = new Client(sgo, mClientInfoAndState);
 
     RefPtr<EventTarget> target = aWorkerPrivate->GlobalScope();
     RefPtr<ExtendableMessageEvent> extendableEvent =
       ExtendableMessageEvent::Constructor(target, NS_LITERAL_STRING("message"),
                                           init, rv);
     if (NS_WARN_IF(rv.Failed())) {
       rv.SuppressException();
       return false;
@@ -548,17 +550,17 @@ public:
 };
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendMessageEvent(JSContext* aCx,
                                        JS::Handle<JS::Value> aMessage,
                                        const Sequence<JSObject*>& aTransferable,
-                                       UniquePtr<ServiceWorkerClientInfo>&& aClientInfo)
+                                       const ClientInfoAndState& aClientInfoAndState)
 {
   AssertIsOnMainThread();
 
   ErrorResult rv(SpawnWorkerIfNeeded(MessageEvent, nullptr));
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
@@ -567,17 +569,17 @@ ServiceWorkerPrivate::SendMessageEvent(J
   rv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                          &transferable);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
   RefPtr<SendMesssageEventRunnable> runnable =
-    new SendMesssageEventRunnable(mWorkerPrivate, token, Move(aClientInfo));
+    new SendMesssageEventRunnable(mWorkerPrivate, token, aClientInfoAndState);
 
   runnable->Write(aCx, aMessage, transferable, JS::CloneDataPolicy(), rv);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   if (!runnable->Dispatch()) {
     return NS_ERROR_FAILURE;
@@ -1340,24 +1342,24 @@ class FetchEventRunnable : public Extend
 public:
   FetchEventRunnable(WorkerPrivate* aWorkerPrivate,
                      KeepAliveToken* aKeepAliveToken,
                      nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      // CSP checks might require the worker script spec
                      // later on.
                      const nsACString& aScriptSpec,
                      nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
-                     const nsAString& aDocumentId,
+                     const nsAString& aClientId,
                      bool aIsReload,
                      bool aMarkLaunchServiceWorkerEnd)
     : ExtendableFunctionalEventWorkerRunnable(
         aWorkerPrivate, aKeepAliveToken, aRegistration)
     , mInterceptedChannel(aChannel)
     , mScriptSpec(aScriptSpec)
-    , mClientId(aDocumentId)
+    , mClientId(aClientId)
     , mIsReload(aIsReload)
     , mMarkLaunchServiceWorkerEnd(aMarkLaunchServiceWorkerEnd)
     , mCacheMode(RequestCache::Default)
     , mRequestMode(RequestMode::No_cors)
     , mRequestRedirect(RequestRedirect::Follow)
     // By default we set it to same-origin since normal HTTP fetches always
     // send credentials to same-origin websites unless explicitly forbidden.
     , mRequestCredentials(RequestCredentials::Same_origin)
@@ -1632,17 +1634,20 @@ private:
 
     MOZ_ASSERT_IF(internalReq->IsNavigationRequest(),
                   request->Redirect() == RequestRedirect::Manual);
 
     RootedDictionary<FetchEventInit> init(aCx);
     init.mRequest = request;
     init.mBubbles = false;
     init.mCancelable = true;
-    if (!mClientId.IsEmpty()) {
+    // Only expose the FetchEvent.clientId on subresource requests for now.
+    // Once we implement .reservedClientId we can then start shipping
+    // .clientId values on non-subresource requests.
+    if (!mClientId.IsEmpty() && !internalReq->IsNavigationRequest()) {
       init.mClientId = mClientId;
     }
     init.mIsReload = mIsReload;
     RefPtr<FetchEvent> event =
       FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, result);
     if (NS_WARN_IF(result.Failed())) {
       result.SuppressException();
       return false;
@@ -1678,18 +1683,17 @@ private:
 
 NS_IMPL_ISUPPORTS_INHERITED(FetchEventRunnable, WorkerRunnable, nsIHttpHeaderVisitor)
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendFetchEvent(nsIInterceptedChannel* aChannel,
                                      nsILoadGroup* aLoadGroup,
-                                     const nsAString& aDocumentId,
-                                     bool aIsReload)
+                                     const nsAString& aClientId, bool aIsReload)
 {
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(!mInfo || !swm)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -1756,17 +1760,17 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
       "ServiceWorkerRegistrationInfo", registration, false));
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
 
 
   RefPtr<FetchEventRunnable> r =
     new FetchEventRunnable(mWorkerPrivate, token, handle,
                            mInfo->ScriptSpec(), regInfo,
-                           aDocumentId, aIsReload, newWorkerCreated);
+                           aClientId, aIsReload, newWorkerCreated);
   rv = r->Init();
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   if (mInfo->State() == ServiceWorkerState::Activating) {
     mPendingFunctionalEvents.AppendElement(r.forget());
     return NS_OK;
@@ -1905,17 +1909,17 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   jsapi.Init();
   ErrorResult error;
   NS_ConvertUTF8toUTF16 scriptSpec(mInfo->ScriptSpec());
 
   mWorkerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
                                               scriptSpec,
                                               false, WorkerTypeService,
                                               VoidString(),
-                                              mInfo->Scope(),
+                                              EmptyCString(),
                                               &info, error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   RenewKeepAliveToken(aWhy);
 
   if (aNewWorkerCreated) {
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -13,16 +13,19 @@
 
 #define NOTIFICATION_CLICK_EVENT_NAME "notificationclick"
 #define NOTIFICATION_CLOSE_EVENT_NAME "notificationclose"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
+
+class ClientInfoAndState;
+
 namespace workers {
 
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
 class KeepAliveToken;
 
 class LifeCycleEventCallback : public Runnable
 {
@@ -80,17 +83,17 @@ protected:
   NS_DECL_OWNINGTHREAD
 
 public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
   nsresult
   SendMessageEvent(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                    const Sequence<JSObject*>& aTransferable,
-                   UniquePtr<ServiceWorkerClientInfo>&& aClientInfo);
+                   const ClientInfoAndState& aClientInfoAndState);
 
   // This is used to validate the worker script and continue the installation
   // process.
   nsresult
   CheckScriptEvaluation(LifeCycleEventCallback* aCallback);
 
   nsresult
   SendLifeCycleEvent(const nsAString& aEventType,
@@ -114,20 +117,18 @@ public:
                         const nsAString& aBody,
                         const nsAString& aTag,
                         const nsAString& aIcon,
                         const nsAString& aData,
                         const nsAString& aBehavior,
                         const nsAString& aScope);
 
   nsresult
-  SendFetchEvent(nsIInterceptedChannel* aChannel,
-                 nsILoadGroup* aLoadGroup,
-                 const nsAString& aDocumentId,
-                 bool aIsReload);
+  SendFetchEvent(nsIInterceptedChannel* aChannel, nsILoadGroup* aLoadGroup,
+                 const nsAString& aClientId, bool aIsReload);
 
   void
   StoreISupports(nsISupports* aSupports);
 
   void
   RemoveISupports(nsISupports* aSupports);
 
   // This will terminate the current running worker thread and drop the
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -269,23 +269,18 @@ ServiceWorkerRegistrationInfo::Activate(
     return;
   }
 
   TransitionWaitingToActive();
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   // "Queue a task to fire a simple event named controllerchange..."
-  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
-    NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      "dom::workers::ServiceWorkerManager::FireControllerChange",
-      swm,
-      &ServiceWorkerManager::FireControllerChange,
-      this);
-  NS_DispatchToMainThread(controllerChangeRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mActiveWorker);
+  swm->UpdateClientControllers(this);
 
   nsCOMPtr<nsIRunnable> failRunnable = NewRunnableMethod<bool>(
     "dom::workers::ServiceWorkerRegistrationInfo::FinishActivate",
     this,
     &ServiceWorkerRegistrationInfo::FinishActivate,
     false /* success */);
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WorkerScope.h"
 
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/Clients.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/Fetch.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IDBFactory.h"
 #include "mozilla/dom/ImageBitmap.h"
 #include "mozilla/dom/ImageBitmapBinding.h"
 #include "mozilla/dom/Performance.h"
@@ -27,29 +28,29 @@
 #include "mozilla/dom/WorkerLocation.h"
 #include "mozilla/dom/WorkerNavigator.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/Services.h"
 #include "nsServiceManagerUtils.h"
 
 #include "nsIDocument.h"
 #include "nsIServiceWorkerManager.h"
+#include "nsIScriptError.h"
 #include "nsIScriptTimeoutHandler.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #include "Crypto.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
-#include "ServiceWorkerClients.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerRegistration.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 extern already_AddRefed<nsIScriptTimeoutHandler>
@@ -629,24 +630,25 @@ ServiceWorkerGlobalScope::WrapGlobalObje
   JS::CompartmentOptions options;
   mWorkerPrivate->CopyJSCompartmentOptions(options);
 
   return ServiceWorkerGlobalScopeBinding::Wrap(aCx, this, this, options,
                                                GetWorkerPrincipal(),
                                                true, aReflector);
 }
 
-ServiceWorkerClients*
-ServiceWorkerGlobalScope::Clients()
+already_AddRefed<Clients>
+ServiceWorkerGlobalScope::GetClients()
 {
   if (!mClients) {
-    mClients = new ServiceWorkerClients(this);
+    mClients = new Clients(this);
   }
 
-  return mClients;
+  RefPtr<Clients> ref = mClients;
+  return ref.forget();
 }
 
 ServiceWorkerRegistration*
 ServiceWorkerGlobalScope::Registration()
 {
   if (!mRegistration) {
     mRegistration =
       ServiceWorkerRegistration::CreateForWorker(mWorkerPrivate, mScope);
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -14,16 +14,17 @@
 #include "nsWeakReference.h"
 #include "mozilla/dom/ImageBitmapSource.h"
 
 namespace mozilla {
 namespace dom {
 
 class AnyCallback;
 struct ChannelPixelLayout;
+class Clients;
 class Console;
 class Crypto;
 class Function;
 class IDBFactory;
 enum class ImageBitmapFormat : uint8_t;
 class Performance;
 class Promise;
 class RequestOrUSVString;
@@ -35,17 +36,16 @@ enum class CallerType : uint32_t;
 namespace cache {
 
 class CacheStorage;
 
 } // namespace cache
 
 namespace workers {
 
-class ServiceWorkerClients;
 class WorkerPrivate;
 
 } // namespace workers
 
 class WorkerGlobalScope : public DOMEventTargetHelper,
                           public nsIGlobalObject,
                           public nsSupportsWeakReference
 {
@@ -277,17 +277,17 @@ public:
   Close(JSContext* aCx);
 
   IMPL_EVENT_HANDLER(connect)
 };
 
 class ServiceWorkerGlobalScope final : public WorkerGlobalScope
 {
   const nsString mScope;
-  RefPtr<workers::ServiceWorkerClients> mClients;
+  RefPtr<Clients> mClients;
   RefPtr<ServiceWorkerRegistration> mRegistration;
 
   ~ServiceWorkerGlobalScope();
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerGlobalScope,
                                            WorkerGlobalScope)
@@ -304,18 +304,18 @@ public:
   OpenWindowEnabled(JSContext* aCx, JSObject* aObj);
 
   void
   GetScope(nsString& aScope) const
   {
     aScope = mScope;
   }
 
-  workers::ServiceWorkerClients*
-  Clients();
+  already_AddRefed<Clients>
+  GetClients();
 
   ServiceWorkerRegistration*
   Registration();
 
   already_AddRefed<Promise>
   SkipWaiting(ErrorResult& aRv);
 
   IMPL_EVENT_HANDLER(activate)
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -32,19 +32,16 @@ EXPORTS.mozilla.dom.workers += [
     'ServiceWorkerRegistrationInfo.h',
     'WorkerDebuggerManager.h',
     'Workers.h',
 ]
 
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
-    'ServiceWorkerClient.h',
-    'ServiceWorkerClients.h',
-    'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
     'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
@@ -55,18 +52,16 @@ XPIDL_SOURCES += [
 UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
-    'ServiceWorkerClient.cpp',
-    'ServiceWorkerClients.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
@@ -77,17 +72,16 @@ UNIFIED_SOURCES += [
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerUpdaterChild.cpp',
     'ServiceWorkerUpdaterParent.cpp',
-    'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
     'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
diff --git a/dom/workers/test/serviceworkers/openWindow_worker.js b/dom/workers/test/serviceworkers/openWindow_worker.js
--- a/dom/workers/test/serviceworkers/openWindow_worker.js
+++ b/dom/workers/test/serviceworkers/openWindow_worker.js
@@ -55,37 +55,37 @@ onmessage = function(event) {
   if (event.data == "testNoPopup") {
     client = event.source;
 
     var results = [];
     var promises = [];
     promises.push(testForUrl("about:blank", "TypeError", null, results));
     promises.push(testForUrl("http://example.com", "InvalidAccessError", null, results));
     promises.push(testForUrl("_._*`InvalidURL", "InvalidAccessError", null, results));
-    Promise.all(promises).then(function(e) {
+    event.waitUntil(Promise.all(promises).then(function(e) {
       client.postMessage(results);
-    });
+    }));
   }
   if (event.data == "NEW_WINDOW") {
     window_count += 1;
     if (window_count == expected_window_count) {
       resolve_got_all_windows();
     }
   }
 
   if (event.data == "CHECK_NUMBER_OF_WINDOWS") {
-    got_all_windows.then(function() {
+    event.waitUntil(got_all_windows.then(function() {
       return clients.matchAll();
     }).then(function(cl) {
       event.source.postMessage({result: cl.length == expected_window_count,
                                 message: "The number of windows is correct."});
       for (i = 0; i < cl.length; i++) {
         cl[i].postMessage("CLOSE");
       }
-    });
+    }));
   }
 }
 
 onnotificationclick = function(e) {
   var results = [];
   var promises = [];
 
   var redirect = "http://mochi.test:8888/tests/dom/workers/test/serviceworkers/redirect.sjs?"
@@ -104,13 +104,13 @@ onnotificationclick = function(e) {
 			   {url: same_origin}, results));
   promises.push(testForUrl(redirect + different_origin, null, null, results));
 
   promises.push(testForUrl(redirect_xorigin + "open_window/client.html", null,
 			   null, results));
   promises.push(testForUrl(redirect_xorigin + same_origin, null,
 			   {url: same_origin}, results));
 
-  Promise.all(promises).then(function(e) {
+  e.waitUntil(Promise.all(promises).then(function(e) {
     client.postMessage(results);
-  });
+  }));
 }
 
diff --git a/testing/web-platform/meta/service-workers/service-worker/about-blank-replacement.https.html.ini b/testing/web-platform/meta/service-workers/service-worker/about-blank-replacement.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/service-workers/service-worker/about-blank-replacement.https.html.ini
+++ /dev/null
@@ -1,10 +0,0 @@
-[about-blank-replacement.https.html]
-  [Initial about:blank is controlled, exposed to clients.matchAll(), and matches final Client.]
-    expected: FAIL
-
-  [Initial about:blank modified by parent is controlled, exposed to clients.matchAll(), and matches final Client.]
-    expected: FAIL
-
-  [Popup initial about:blank is controlled, exposed to clients.matchAll(), and matches final Client.]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini b/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/service-workers/service-worker/clients-matchall-client-types.https.html.ini
+++ /dev/null
@@ -1,8 +0,0 @@
-[clients-matchall-client-types.https.html]
-  type: testharness
-  [Verify matchAll() with window and sharedworker client types]
-    expected: FAIL
-
-  [Verify matchAll() with {window, sharedworker, worker} client types]
-    expected: FAIL
-
