# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a59c1ae01c470c78a08239584598d2ff2ef43923

diff --git a/js/src/builtin/ReadableStream.cpp b/js/src/builtin/ReadableStream.cpp
--- a/js/src/builtin/ReadableStream.cpp
+++ b/js/src/builtin/ReadableStream.cpp
@@ -71,26 +71,27 @@ ReadableStreamConstructor(JSContext* cx,
     if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStream,
                                          &ctorFun))
     {
         return false;
     }
     MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
 
     InvokeArgs invokeArgs(cx);
-    if (!invokeArgs.init(args.length() >= 2 ? 2 : args.length()))
-        return false;
-    invokeArgs.setCallee(ctorFun);
-    invokeArgs.setThis(ObjectValue(*readableStream));
+    if (!invokeArgs.init(args.length() > 2 ? 2: args.length()))
+      return false;
+
     if (args.length() >= 1)
       invokeArgs[0].set(args.get(0));
     if (args.length() >= 2)
       invokeArgs[1].set(args.get(1));
 
-    if (!Call(cx, ctorFun, readableStream, invokeArgs, args.rval()))
+    RootedValue newTarget(cx, ObjectValue(*readableStream));
+
+    if (!Call(cx, ctorFun, newTarget, invokeArgs, args.rval()))
         return false;
 
     args.rval().setObject(*readableStream);
     return true;
 }
 
 bool
 ReadableStreamControllerConstructor(JSContext* cx, unsigned argc, Value* vp)
@@ -110,22 +111,22 @@ ReadableStreamControllerConstructor(JSCo
   {
       return false;
   }
   MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
 
   InvokeArgs invokeArgs(cx);
   if (!invokeArgs.init(args.length() >= 1 ? 1: 0))
       return false;
-  invokeArgs.setCallee(ctorFun);
-  invokeArgs.setThis(ObjectValue(*readableStreamController));
   if (args.length() >= 1)
     invokeArgs[0].set(args.get(0));
 
-  if (!Call(cx, ctorFun, readableStreamController, invokeArgs, args.rval()))
+  RootedValue newTarget(cx, ObjectValue(*readableStreamController));
+
+  if (!Call(cx, ctorFun, newTarget, invokeArgs, args.rval()))
       return false;
 
   args.rval().setObject(*readableStreamController);
   return true;
 }
 
 bool
 ReadableStreamReaderConstructor(JSContext* cx, unsigned argc, Value* vp)
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -39,17 +39,17 @@ function ReadableStream(underlyingSource
   // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
   // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
   // Step 11. ReturnIfAbrupt(startResult).
   let startResult = InvokeOrNoop(underlyingSource, "start",
     UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
   // Step 12. Resolve startResult as a promise:
-  Promise.resolve(startResult).then(() => {
+  GetPromiseCtor().resolve(startResult).then(() => {
 this._log += 'resolved ' + startResult;
     // Set this@[[started]] to true.
     UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
     // Perform RequestReadableStreamPull(this).
     RequestReadableStreamPull(this);
   }, (r) => {
     // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
     if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
@@ -68,25 +68,25 @@ function ReadableStream_locked() {
 }
 
 // Streams spec, 3.2.4.2. cancel(reason)
 function ReadableStream_cancel(reason) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
 
   if (IsReadableStreamLocked(this)) {
     try {
       ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
 
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
 function ReadableStream_getReader() {
@@ -119,19 +119,21 @@ function ReadableStream_tee() {
 }
 
 
 // Streams spec, 3.3.1. Class Definition
 function ReadableStreamController(stream) {
   if (!IsObject(this) || !IsReadableStreamController(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
   }
+  /*
   if (UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT) !== undefined) {
     ThrowSomething("TypeError", "stream@[[controller]] is not undefined");
   }
+  */
   UnsafeSetReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT, stream);
 }
 
 // Streams spec, 3.3.4.1. get desiredSize
 function ReadableStreamController_desiredSize() {
   if (!IsObject(this) || !IsReadableStreamController(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "desiredSize", typeof this);
   }
@@ -199,75 +201,75 @@ function ReadableStreamReader(stream) {
   switch (streamState) {
     case READABLESTREAM_READABLE_STATE:
       let deferred = CreateDeferred();
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
       break;
     case READABLESTREAM_CLOSED_STATE:
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-        Promise.resolve(undefined));
+        GetPromiseCtor().resolve(undefined));
       break;
     case READABLESTREAM_ERRORED_STATE:
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-        Promise.reject(UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
+        GetPromiseCtor().reject(UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
       break;
     default:
       ThrowSomething("Error", "Unexpected stream state");
       break;
   }
 }
 
 // Streams spec, 3.4.4.1. get closed
 function ReadableStreamReader_closed() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "closed", typeof this);
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
   return UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
 }
 
 // Streams spec, 3.4.4.2. cancel(reason)
 function ReadableStreamReader_cancel(reason) {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "cancel", typeof this);
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
   let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   if (ownerReadableStream === undefined) {
     try {
       ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
   return CancelReadableStream(ownerReadableStream, reason);
 }
 
 // Streams spec, 3.4.4.3. read()
 function ReadableStreamReader_read() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "read", typeof this);
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
   let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   if (ownerReadableStream === undefined) {
     try {
       ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
     } catch (e) {
-      return Promise.reject(e);
+      return GetPromiseCtor().reject(e);
     }
   }
   return ReadFromReadableStreamReader(this);
 }
 
 // Streams spec, 3.4.4.4. releaseLock()
 function ReadableStreamReader_releaseLock() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
@@ -289,17 +291,17 @@ function ReadableStreamReader_releaseLoc
     releaseLockException = e;
   }
   if (ownerReadableStreamState === READABLESTREAM_READABLE_STATE) {
     let deferred = UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
     UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
     deferred.reject(releaseLockException);
   } else {
     UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-      Promise.reject(releaseLockException));
+      GetPromiseCtor().reject(releaseLockException));
   }
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_READER_SLOT, undefined);
   UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, undefined);
 }
 
 
 // Streams spec, 3.5.1. AcquireReadableStreamReader ( stream )
 function AcquireReadableStreamReader(stream) {
@@ -307,43 +309,43 @@ function AcquireReadableStreamReader(str
   return new ReadableStreamReaderCtor(stream);
 }
 
 // Streams spec, 3.5.2. CancelReadableStream ( stream, reason )
 function CancelReadableStream(stream, reason) {
   UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
   let streamState = UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
   if (streamState === READABLESTREAM_CLOSED_STATE) {
-    return Promise.resolve(undefined);
+    return GetPromiseCtor().resolve(undefined);
   }
   if (streamState === READABLESTREAM_ERRORED_STATE) {
-    return Promise.reject(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
+    return GetPromiseCtor().reject(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
   }
   UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
   FinishClosingReadableStream(stream);
   let sourceCancelPromise = PromiseInvokeOrNoop(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT), "cancel", reason);
   return sourceCancelPromise.then(() => undefined);
 }
 
 // Streams spec, 3.5.3. CloseReadableStream ( stream )
 function CloseReadableStream(stream) {
-  assert(UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
   assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
   if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
     return;
   }
   UnsafeSetReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT, true);
   if (UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT).length === 0) {
     FinishClosingReadableStream(stream);
   }
 }
 
 // Streams spec, 3.5.4. EnqueueInReadableStream ( stream, chunk )
 function EnqueueInReadableStream(stream, chunk) {
-  assert(UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
   assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
   if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
     return;
   }
   let readRequests;
   if (IsReadableStreamLocked(stream) &&
       (readRequests = UnsafeGetObjectFromReservedSlot(
         UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT),
@@ -432,32 +434,32 @@ function IsReadableStreamLocked(stream) 
 
 // Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
 function ReadFromReadableStreamReader(reader) {
   let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
   let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
   if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
-    return Promise.resolve(CreateIterResultObject(undefined, true));
+    return GetPromiseCtor().resolve(CreateIterResultObject(undefined, true));
   }
   if (ownerReadableStreamState === READABLESTREAM_ERRORED_STATE) {
-    return Promise.reject(UnsafeGetReservedSlot(ownerReadableStream, READABLESTREAM_STORED_ERROR_SLOT));
+    return GetPromiseCtor().reject(UnsafeGetReservedSlot(ownerReadableStream, READABLESTREAM_STORED_ERROR_SLOT));
   }
   assert(UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT) === READABLESTREM_READABLE_STATE, "reader@[[ownerReadableStream]]@[[state]] is \"readable\"");
   let queue = UnsafeGetObjectFromReservedSlot(ownerReadableStream, READABLESTREAM_QUEUE_SLOT)
   if (queue.length !== 0) {
     let chunk = DequeueValue(queue);
     if (UnsafeGetBooleanFromReservedSlot(ownerReadableStream, READABLESTREAM_CLOSE_REQUESTED_SLOT) &&
         queue.length === 0) {
       FinishClosingReadableStream(ownerReadableStream);
     } else {
       RequestReadableStreamPull(ownerReadableStream);
     }
-    return Promise.resolve(CreateIterResultObject(chunk, false));
+    return GetPromiseCtor().resolve(CreateIterResultObject(chunk, false));
   } else {
     let readRequestDeferred = CreateDeferred();
     let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
     callFunction(std_Array_push, readRequests, readRequestDeferred);
     RequestReadableStreamPull(ownerReadableStream);
     return readRequestDeferred.promise;
   }
 }
@@ -555,19 +557,19 @@ function InvokeOrNoop(obj, methodName, a
   return callContentFunction(method, obj, arg);
 }
 
 // Streams spec, 6.4.6. PromiseInvokeOrNoop ( O, P, args )
 // FIXME per spec
 function PromiseInvokeOrNoop(obj, methodName, arg) {
   try {
     let result = InvokeOrNoop(obj, methodName, arg);
-    return Promise.resolve(result);
+    return GetPromiseCtor().resolve(result);
   } catch (e) {
-    return Promise.reject(e);
+    return GetPromiseCtor().reject(e);
   }
 }
 
 // Streams spec, 6.4.7. ValidateAndNormalizeQueuingStrategy ( size, highWaterMark )
 function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
   if (size !== undefined && !IsCallable(size)) {
     ThrowTypeError(JSMSG_NOT_FUNCTION, DecompileArg(0, size));
   }
@@ -587,24 +589,31 @@ function ThrowSomething(name, msg) {
 }
 
 function CreateIterResultObject(value, done) {
   return {value: value, done: done};
 }
 
 // intrinsic wrappers
 function CreateDeferred() {
+  var Promise = GetPromiseCtor();
   var obj = {};
   obj.promise = new Promise(function (resolve, reject) {
     obj.resolve = resolve;
     obj.reject = reject;
   });
   return obj;
 }
 
+var _promiseCtorHolder  = {__proto__: null};
+function GetPromiseCtor() {
+    return _promiseCtorHolder.ctor ||
+           (_promiseCtorHolder.ctor = _GetOriginalPromiseConstructor());
+}
+
 var _originalReadableStreamControllerCtorHolder = {__proto__: null};
 function GetReadableStreamControllerCtor() {
     return _originalReadableStreamControllerCtorHolder.ctor ||
            (_originalReadableStreamControllerCtorHolder.ctor = _GetOriginalReadableStreamControllerConstructor());
 }
 
 var _originalReadableStreamReaderCtorHolder = {__proto__: null};
 function GetReadableStreamReaderCtor() {
diff --git a/js/src/vm/SelfHosting.cpp b/js/src/vm/SelfHosting.cpp
--- a/js/src/vm/SelfHosting.cpp
+++ b/js/src/vm/SelfHosting.cpp
@@ -23,16 +23,17 @@
 #include "jswrapper.h"
 #include "selfhosted.out.h"
 
 #include "builtin/Intl.h"
 #include "builtin/MapObject.h"
 #include "builtin/ModuleObject.h"
 #include "builtin/Object.h"
 #include "builtin/Promise.h"
+#include "builtin/ReadableStream.h"
 #include "builtin/Reflect.h"
 #include "builtin/SelfHostingDefines.h"
 #include "builtin/SIMD.h"
 #include "builtin/TypedObject.h"
 #include "builtin/WeakSetObject.h"
 #include "gc/Marking.h"
 #include "gc/Policy.h"
 #include "jit/AtomicOperations.h"
@@ -1996,16 +1997,44 @@ intrinsic_IsWrappedPromiseObject(JSConte
     RootedObject obj(cx, &args[0].toObject());
     MOZ_ASSERT(!obj->is<PromiseObject>(),
                "Unwrapped promises should be filtered out in inlineable code");
     args.rval().setBoolean(JS::IsPromiseObject(obj));
     return true;
 }
 
 static bool
+intrinsic_OriginalReadableStreamReaderConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    MOZ_ASSERT(args.length() == 0);
+
+    JSObject* obj = GlobalObject::getOrCreateReadableStreamReaderConstructor(cx, cx->global());
+    if (!obj)
+        return false;
+
+    args.rval().setObject(*obj);
+    return true;
+}
+
+static bool
+intrinsic_OriginalReadableStreamControllerConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    MOZ_ASSERT(args.length() == 0);
+
+    JSObject* obj = GlobalObject::getOrCreateReadableStreamControllerConstructor(cx, cx->global());
+    if (!obj)
+        return false;
+
+    args.rval().setObject(*obj);
+    return true;
+}
+
+static bool
 intrinsic_HostResolveImportedModule(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     MOZ_ASSERT(args.length() == 2);
     MOZ_ASSERT(args[0].toObject().is<ModuleObject>());
     MOZ_ASSERT(args[1].isString());
 
     RootedFunction moduleResolveHook(cx, cx->global()->moduleResolveHook());
@@ -2489,16 +2518,22 @@ static const JSFunctionSpec intrinsic_fu
     JS_FN("IsPromise",                      intrinsic_IsInstanceOfBuiltin<PromiseObject>, 1,0),
     JS_FN("IsWrappedPromise",               intrinsic_IsWrappedPromiseObject,     1, 0),
     JS_FN("_EnqueuePromiseJob",             intrinsic_EnqueuePromiseJob,          1, 0),
     JS_FN("_GetOriginalPromiseConstructor", intrinsic_OriginalPromiseConstructor, 0, 0),
     JS_FN("RejectUnwrappedPromise",         intrinsic_RejectUnwrappedPromise,     2, 0),
     JS_FN("CallPromiseMethodIfWrapped",
           CallNonGenericSelfhostedMethod<Is<PromiseObject>>,      2,0),
 
+    JS_FN("IsReadableStream", intrinsic_IsInstanceOfBuiltin<ReadableStream>, 1, 0),
+    JS_FN("IsReadableStreamController", intrinsic_IsInstanceOfBuiltin<ReadableStreamController>, 1, 0),
+    JS_FN("IsReadableStreamReader", intrinsic_IsInstanceOfBuiltin<ReadableStreamReader>, 1, 0),
+    JS_FN("_GetOriginalReadableStreamReaderConstructor", intrinsic_OriginalReadableStreamReaderConstructor, 0, 0),
+    JS_FN("_GetOriginalReadableStreamControllerConstructor", intrinsic_OriginalReadableStreamControllerConstructor, 0, 0),
+
     // See builtin/TypedObject.h for descriptors of the typedobj functions.
     JS_FN("NewOpaqueTypedObject",           js::NewOpaqueTypedObject, 1, 0),
     JS_FN("NewDerivedTypedObject",          js::NewDerivedTypedObject, 3, 0),
     JS_FN("TypedObjectBuffer",              TypedObject::GetBuffer, 1, 0),
     JS_FN("TypedObjectByteOffset",          TypedObject::GetByteOffset, 1, 0),
     JS_FN("AttachTypedObject",              js::AttachTypedObject, 3, 0),
     JS_FN("TypedObjectIsAttached",          js::TypedObjectIsAttached, 1, 0),
     JS_FN("TypedObjectTypeDescr",           js::TypedObjectTypeDescr, 1, 0),
