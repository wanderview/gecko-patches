# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bb5c5d71bd02ff2240a97f10843f44d19c09ff06

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -455,17 +455,17 @@ nsDocShell::Init()
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ASSERTION(mLoadGroup, "Something went wrong!");
 
   mContentListener = new nsDSURIContentListener(this);
   rv = mContentListener->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
-  mInterceptController = new ServiceWorkerInterceptController();
+  //mInterceptController = new ServiceWorkerInterceptController();
 
   // We want to hold a strong ref to the loadgroup, so it better hold a weak
   // ref to us...  use an InterfaceRequestorProxy to do this.
   nsCOMPtr<nsIInterfaceRequestor> proxy =
     new InterfaceRequestorProxy(static_cast<nsIInterfaceRequestor*>(this));
   mLoadGroup->SetNotificationCallbacks(proxy);
 
   rv = nsDocLoader::AddDocLoaderAsChildOfRoot(this);
@@ -518,17 +518,18 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(
   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   NS_INTERFACE_MAP_ENTRY(nsIWebPageDescriptor)
   NS_INTERFACE_MAP_ENTRY(nsIAuthPromptProvider)
   NS_INTERFACE_MAP_ENTRY(nsILoadContext)
   NS_INTERFACE_MAP_ENTRY(nsIWebShellServices)
   NS_INTERFACE_MAP_ENTRY(nsILinkHandler)
   NS_INTERFACE_MAP_ENTRY(nsIClipboardCommands)
   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageManager)
-  NS_INTERFACE_MAP_ENTRY(nsINetworkInterceptController)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsINetworkInterceptController,
+                                     mInterceptController)
   NS_INTERFACE_MAP_ENTRY(nsIDeprecationWarner)
 NS_INTERFACE_MAP_END_INHERITING(nsDocLoader)
 
 NS_IMETHODIMP
 nsDocShell::GetInterface(const nsIID& aIID, void** aSink)
 {
   NS_PRECONDITION(aSink, "null out param");
 
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -1796,25 +1796,25 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
                                           nsILoadGroup* aLoadGroup)
 {
   AssertIsOnMainThread();
 
   // XXXcatalinb: We need to have a separate load group that's linked to
   // an existing tab child to pass security checks on b2g.
   // This should be fixed in bug 1125961, but for now we enforce updating
   // the overriden load group when intercepting a fetch.
-  MOZ_ASSERT_IF(aWhy == FetchEvent, aLoadGroup);
+  //MOZ_ASSERT_IF(aWhy == FetchEvent, aLoadGroup);
 
   // Defaults to no new worker created, but if there is one, we'll set the value
   // to true at the end of this function.
   if (aNewWorkerCreated) {
     *aNewWorkerCreated = false;
   }
 
-  if (mWorkerPrivate) {
+  if (mWorkerPrivate && aLoadGroup) {
     mWorkerPrivate->UpdateOverridenLoadGroup(aLoadGroup);
     RenewKeepAliveToken(aWhy);
 
     return NS_OK;
   }
 
   // Sanity check: mSupportsArray should be empty if we're about to
   // spin up a new worker.
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -168,16 +168,19 @@ struct HttpChannelOpenArgs
   uint32_t                    cacheKey;
   uint64_t                    requestContextID;
   OptionalCorsPreflightArgs   preflightArgs;
   uint32_t                    initialRwin;
   bool                        blockAuthPrompt;
   bool                        suspendAfterSynthesizeResponse;
   bool                        allowStaleCacheContent;
   nsCString                   contentTypeHint;
+  uint32_t                    corsMode;
+  uint32_t                    redirectMode;
+  uint32_t                    fetchCacheMode;
   uint64_t                    channelId;
   uint64_t                    contentWindowId;
   nsCString                   preferredAlternativeType;
   uint64_t                    topLevelOuterContentWindowId;
   TimeStamp                   launchServiceWorkerStart;
   TimeStamp                   launchServiceWorkerEnd;
   TimeStamp                   dispatchFetchEventStart;
   TimeStamp                   dispatchFetchEventEnd;
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -430,24 +430,26 @@ class StartRequestEvent : public NeckoTa
                     const uint32_t& aCacheExpirationTime,
                     const nsCString& aCachedCharset,
                     const nsCString& aSecurityInfoSerialization,
                     const NetAddr& aSelfAddr,
                     const NetAddr& aPeerAddr,
                     const uint32_t& aCacheKey,
                     const nsCString& altDataType,
                     const int64_t& altDataLen,
-                    Maybe<ServiceWorkerDescriptor>&& aController)
+                    Maybe<ServiceWorkerDescriptor>&& aController,
+                    const bool& aApplyConversion)
   : NeckoTargetChannelEvent<HttpChannelChild>(aChild)
   , mChannelStatus(aChannelStatus)
   , mResponseHead(aResponseHead)
   , mRequestHeaders(aRequestHeaders)
   , mUseResponseHead(aUseResponseHead)
   , mIsFromCache(aIsFromCache)
   , mCacheEntryAvailable(aCacheEntryAvailable)
+  , mApplyConversion(aApplyConversion)
   , mCacheEntryId(aCacheEntryId)
   , mCacheFetchCount(aCacheFetchCount)
   , mCacheExpirationTime(aCacheExpirationTime)
   , mCachedCharset(aCachedCharset)
   , mSecurityInfoSerialization(aSecurityInfoSerialization)
   , mSelfAddr(aSelfAddr)
   , mPeerAddr(aPeerAddr)
   , mCacheKey(aCacheKey)
@@ -460,26 +462,27 @@ class StartRequestEvent : public NeckoTa
   {
     LOG(("StartRequestEvent [this=%p]\n", mChild));
     mChild->OnStartRequest(mChannelStatus, mResponseHead, mUseResponseHead,
                            mRequestHeaders, mIsFromCache, mCacheEntryAvailable,
                            mCacheEntryId, mCacheFetchCount,
                            mCacheExpirationTime, mCachedCharset,
                            mSecurityInfoSerialization, mSelfAddr, mPeerAddr,
                            mCacheKey, mAltDataType, mAltDataLen,
-                           mController);
+                           mController, mApplyConversion);
   }
 
  private:
   nsresult mChannelStatus;
   nsHttpResponseHead mResponseHead;
   nsHttpHeaderArray mRequestHeaders;
   bool mUseResponseHead;
   bool mIsFromCache;
   bool mCacheEntryAvailable;
+  bool mApplyConversion;
   uint64_t mCacheEntryId;
   int32_t mCacheFetchCount;
   uint32_t mCacheExpirationTime;
   nsCString mCachedCharset;
   nsCString mSecurityInfoSerialization;
   NetAddr mSelfAddr;
   NetAddr mPeerAddr;
   uint32_t mCacheKey;
@@ -501,17 +504,18 @@ HttpChannelChild::RecvOnStartRequest(con
                                      const nsCString& cachedCharset,
                                      const nsCString& securityInfoSerialization,
                                      const NetAddr& selfAddr,
                                      const NetAddr& peerAddr,
                                      const int16_t& redirectCount,
                                      const uint32_t& cacheKey,
                                      const nsCString& altDataType,
                                      const int64_t& altDataLen,
-                                     const OptionalIPCServiceWorkerDescriptor& aController)
+                                     const OptionalIPCServiceWorkerDescriptor& aController,
+                                     const bool& aApplyConversion)
 {
   LOG(("HttpChannelChild::RecvOnStartRequest [this=%p]\n", this));
   // mFlushedForDiversion and mDivertingToParent should NEVER be set at this
   // stage, as they are set in the listener's OnStartRequest.
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "mFlushedForDiversion should be unset before OnStartRequest!");
   MOZ_RELEASE_ASSERT(!mDivertingToParent,
     "mDivertingToParent should be unset before OnStartRequest!");
@@ -527,17 +531,18 @@ HttpChannelChild::RecvOnStartRequest(con
   mEventQ->RunOrEnqueue(new StartRequestEvent(this, channelStatus, responseHead,
                                               useResponseHead, requestHeaders,
                                               isFromCache, cacheEntryAvailable,
                                               cacheEntryId, cacheFetchCount,
                                               cacheExpirationTime, cachedCharset,
                                               securityInfoSerialization,
                                               selfAddr, peerAddr, cacheKey,
                                               altDataType, altDataLen,
-                                              Move(controller)));
+                                              Move(controller),
+                                              aApplyConversion));
 
   {
     // Child's mEventQ is to control the execution order of the IPC messages
     // from both main thread IPDL and PBackground IPDL.
     // To guarantee the ordering, PBackground IPC messages that are sent after
     // OnStartRequest will be throttled until OnStartRequest hits the Child's
     // mEventQ.
     MutexAutoLock lock(mBgChildMutex);
@@ -568,17 +573,18 @@ HttpChannelChild::OnStartRequest(const n
                                  const uint32_t& cacheExpirationTime,
                                  const nsCString& cachedCharset,
                                  const nsCString& securityInfoSerialization,
                                  const NetAddr& selfAddr,
                                  const NetAddr& peerAddr,
                                  const uint32_t& cacheKey,
                                  const nsCString& altDataType,
                                  const int64_t& altDataLen,
-                                 const Maybe<ServiceWorkerDescriptor>& aController)
+                                 const Maybe<ServiceWorkerDescriptor>& aController,
+                                 const bool& aApplyConversion)
 {
   LOG(("HttpChannelChild::OnStartRequest [this=%p]\n", this));
 
   // mFlushedForDiversion and mDivertingToParent should NEVER be set at this
   // stage, as they are set in the listener's OnStartRequest.
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "mFlushedForDiversion should be unset before OnStartRequest!");
   MOZ_RELEASE_ASSERT(!mDivertingToParent,
@@ -606,16 +612,18 @@ HttpChannelChild::OnStartRequest(const n
   mPeerAddr = peerAddr;
 
   mAvailableCachedAltDataType = altDataType;
   mAltDataLength = altDataLen;
 
   const Maybe<ServiceWorkerDescriptor>& prevController =
     mLoadInfo->GetController();
 
+  SetApplyConversion(aApplyConversion);
+
   // If we got a service worker controller from the parent, then note
   // it on the LoadInfo.  This may indicate that a non-subresource request
   // was intercepted and the resulting window/worker should be controlled.
   if (aController.isSome() && prevController.isNothing()) {
     mLoadInfo->SetController(aController.ref());
   }
 
   // If we did not set a controller, then verify it was either because:
@@ -2735,16 +2743,20 @@ HttpChannelChild::ContinueAsyncOpen()
   openArgs.contentTypeHint() = mContentTypeHint;
 
   nsresult rv = mozilla::ipc::LoadInfoToLoadInfoArgs(mLoadInfo, &openArgs.loadInfo());
   NS_ENSURE_SUCCESS(rv, rv);
 
   EnsureRequestContextID();
   openArgs.requestContextID() = mRequestContextID;
 
+  openArgs.corsMode() = mCorsMode;
+  openArgs.redirectMode() = mRedirectMode;
+  openArgs.fetchCacheMode() = mFetchCacheMode;
+
   openArgs.channelId() = mChannelId;
 
   openArgs.contentWindowId() = contentWindowId;
   openArgs.topLevelOuterContentWindowId() = mTopLevelOuterContentWindowId;
 
   LOG(("HttpChannelChild::ContinueAsyncOpen this=%p gid=%" PRIu64 " topwinid=%" PRIx64,
        this, mChannelId, mTopLevelOuterContentWindowId));
 
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -140,17 +140,18 @@ protected:
                                              const nsCString& cachedCharset,
                                              const nsCString& securityInfoSerialization,
                                              const NetAddr& selfAddr,
                                              const NetAddr& peerAddr,
                                              const int16_t& redirectCount,
                                              const uint32_t& cacheKey,
                                              const nsCString& altDataType,
                                              const int64_t& altDataLen,
-                                             const OptionalIPCServiceWorkerDescriptor& aController) override;
+                                             const OptionalIPCServiceWorkerDescriptor& aController,
+                                             const bool& aApplyConversion) override;
   mozilla::ipc::IPCResult RecvFailedAsyncOpen(const nsresult& status) override;
   mozilla::ipc::IPCResult RecvRedirect1Begin(const uint32_t& registrarId,
                                              const URIParams& newURI,
                                              const uint32_t& redirectFlags,
                                              const nsHttpResponseHead& responseHead,
                                              const nsCString& securityInfoSerialization,
                                              const uint64_t& channelId,
                                              const NetAddr& oldPeerAddr) override;
@@ -407,17 +408,18 @@ private:
                       const uint32_t& cacheExpirationTime,
                       const nsCString& cachedCharset,
                       const nsCString& securityInfoSerialization,
                       const NetAddr& selfAddr,
                       const NetAddr& peerAddr,
                       const uint32_t& cacheKey,
                       const nsCString& altDataType,
                       const int64_t& altDataLen,
-                      const Maybe<mozilla::dom::ServiceWorkerDescriptor>& aController);
+                      const Maybe<mozilla::dom::ServiceWorkerDescriptor>& aController,
+                      const bool& aApplyConversion);
   void MaybeDivertOnData(const nsCString& data,
                          const uint64_t& offset,
                          const uint32_t& count);
   void OnTransportAndData(const nsresult& channelStatus,
                           const nsresult& status,
                           const uint64_t& offset,
                           const uint32_t& count,
                           const nsCString& data);
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -137,16 +137,17 @@ HttpChannelParent::Init(const HttpChanne
                        a.entityID(), a.chooseApplicationCache(),
                        a.appCacheClientID(), a.allowSpdy(), a.allowAltSvc(), a.beConservative(),
                        a.tlsFlags(), a.loadInfo(), a.synthesizedResponseHead(),
                        a.synthesizedSecurityInfoSerialization(),
                        a.cacheKey(), a.requestContextID(), a.preflightArgs(),
                        a.initialRwin(), a.blockAuthPrompt(),
                        a.suspendAfterSynthesizeResponse(),
                        a.allowStaleCacheContent(), a.contentTypeHint(),
+                       a.corsMode(), a.redirectMode(), a.fetchCacheMode(),
                        a.channelId(), a.contentWindowId(), a.preferredAlternativeType(),
                        a.topLevelOuterContentWindowId(),
                        a.launchServiceWorkerStart(),
                        a.launchServiceWorkerEnd(),
                        a.dispatchFetchEventStart(),
                        a.dispatchFetchEventEnd(),
                        a.handleFetchEventStart(),
                        a.handleFetchEventEnd(),
@@ -475,16 +476,19 @@ HttpChannelParent::DoAsyncOpen(  const U
                                  const uint32_t&            aCacheKey,
                                  const uint64_t&            aRequestContextID,
                                  const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                  const uint32_t&            aInitialRwin,
                                  const bool&                aBlockAuthPrompt,
                                  const bool&                aSuspendAfterSynthesizeResponse,
                                  const bool&                aAllowStaleCacheContent,
                                  const nsCString&           aContentTypeHint,
+                                 const uint32_t&            aCorsMode,
+                                 const uint32_t&            aRedirectMode,
+                                 const uint32_t&            aFetchCacheMode,
                                  const uint64_t&            aChannelId,
                                  const uint64_t&            aContentWindowId,
                                  const nsCString&           aPreferredAlternativeType,
                                  const uint64_t&            aTopLevelOuterContentWindowId,
                                  const TimeStamp&           aLaunchServiceWorkerStart,
                                  const TimeStamp&           aLaunchServiceWorkerEnd,
                                  const TimeStamp&           aDispatchFetchEventStart,
                                  const TimeStamp&           aDispatchFetchEventEnd,
@@ -531,16 +535,21 @@ HttpChannelParent::DoAsyncOpen(  const U
     return SendFailedAsyncOpen(rv);
   }
 
   RefPtr<HttpBaseChannel> httpChannel = do_QueryObject(channel, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
+  // Set attributes needed to create a FetchEvent from this channel.
+  httpChannel->SetCorsMode(aCorsMode);
+  httpChannel->SetRedirectMode(aRedirectMode);
+  httpChannel->SetFetchCacheMode(aFetchCacheMode);
+
   // Set the channelId allocated in child to the parent instance
   httpChannel->SetChannelId(aChannelId);
   httpChannel->SetTopLevelContentWindowId(aContentWindowId);
   httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
 
   RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(httpChannel);
   if (httpChannelImpl) {
     httpChannelImpl->SetWarningReporter(this);
@@ -662,20 +671,20 @@ HttpChannelParent::DoAsyncOpen(  const U
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
       rv = httpChannel->OverrideSecurityInfo(secInfo);
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   } else {
-    nsLoadFlags newLoadFlags;
-    httpChannel->GetLoadFlags(&newLoadFlags);
-    newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
-    httpChannel->SetLoadFlags(newLoadFlags);
+    //nsLoadFlags newLoadFlags;
+    //httpChannel->GetLoadFlags(&newLoadFlags);
+    //newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+    //httpChannel->SetLoadFlags(newLoadFlags);
   }
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
@@ -1476,19 +1485,25 @@ HttpChannelParent::OnStartRequest(nsIReq
       if (mIPCClosed ||
           !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
       {
         return NS_ERROR_UNEXPECTED;
       }
     }
   }
 
+  // Propagate whether or not conversion should occur from the parent-side
+  // channel to the child-side channel.  The disable the parent-side
+  // conversion so that it only occurs in the child.
+  bool applyConversion = true;
   nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(aRequest);
-  if (encodedChannel)
+  if (encodedChannel) {
+    Unused << chan->GetApplyConversion(&applyConversion);
     encodedChannel->SetApplyConversion(false);
+  }
 
   // Keep the cache entry for future use in RecvSetCacheTokenCachedCharset().
   // It could be already released by nsHttpChannel at that time.
   nsCOMPtr<nsISupports> cacheEntry;
   nsresult channelStatus = NS_OK;
   uint32_t cacheKeyValue = 0;
   nsAutoCString altDataType;
 
@@ -1553,17 +1568,18 @@ HttpChannelParent::OnStartRequest(nsIReq
                           cacheEntryId,
                           fetchCount, expirationTime,
                           cachedCharset, secInfoSerialization,
                           chan->GetSelfAddr(), chan->GetPeerAddr(),
                           redirectCount,
                           cacheKeyValue,
                           altDataType,
                           altDataLen,
-                          ipcController))
+                          ipcController,
+                          applyConversion))
   {
     rv = NS_ERROR_UNEXPECTED;
   }
   requestHead->Exit();
 
   // OnStartRequest is sent to content process successfully.
   // Notify PHttpBackgroundChannelChild that all following IPC mesasges
   // should be run after OnStartRequest is handled.
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -161,16 +161,19 @@ protected:
               const uint32_t&            aCacheKey,
               const uint64_t&            aRequestContextID,
               const OptionalCorsPreflightArgs& aCorsPreflightArgs,
               const uint32_t&            aInitialRwin,
               const bool&                aBlockAuthPrompt,
               const bool&                aSuspendAfterSynthesizeResponse,
               const bool&                aAllowStaleCacheContent,
               const nsCString&           aContentTypeHint,
+              const uint32_t&            aCorsMode,
+              const uint32_t&            aRedirectMode,
+              const uint32_t&            aFetchCacheMode,
               const uint64_t&            aChannelId,
               const uint64_t&            aContentWindowId,
               const nsCString&           aPreferredAlternativeType,
               const uint64_t&            aTopLevelOuterContentWindowId,
               const TimeStamp&           aLaunchServiceWorkerStart,
               const TimeStamp&           aLaunchServiceWorkerEnd,
               const TimeStamp&           aDispatchFetchEventStart,
               const TimeStamp&           aDispatchFetchEventEnd,
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -3,38 +3,41 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // HttpLog.h should generally be included first
 #include "HttpLog.h"
 
 #include "HttpChannelParentListener.h"
+#include "mozilla/dom/ServiceWorkerInterceptController.h"
 #include "mozilla/net/HttpChannelParent.h"
 #include "mozilla/Unused.h"
 #include "nsIAuthPrompt.h"
 #include "nsIAuthPrompt2.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsIRedirectChannelRegistrar.h"
 #include "nsIPromptFactory.h"
 #include "nsIWindowWatcher.h"
 #include "nsQueryObject.h"
 
 using mozilla::Unused;
+using mozilla::dom::ServiceWorkerInterceptController;
 
 namespace mozilla {
 namespace net {
 
 HttpChannelParentListener::HttpChannelParentListener(HttpChannelParent* aInitialChannel)
   : mNextListener(aInitialChannel)
   , mRedirectChannelId(0)
   , mSuspendedForDiversion(false)
   , mShouldIntercept(false)
   , mShouldSuspendIntercept(false)
   , mInterceptCanceled(false)
+  , mInterceptController(new ServiceWorkerInterceptController())
 {
   LOG(("HttpChannelParentListener::HttpChannelParentListener [this=%p, next=%p]",
        this, aInitialChannel));
 }
 
 HttpChannelParentListener::~HttpChannelParentListener()
 {
 }
@@ -274,17 +277,22 @@ HttpChannelParentListener::OnRedirectRes
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParentListener::ShouldPrepareForIntercept(nsIURI* aURI,
                                                      nsIChannel* aChannel,
                                                      bool* aShouldIntercept)
 {
   *aShouldIntercept = mShouldIntercept;
-  return NS_OK;
+  if (*aShouldIntercept) {
+    return NS_OK;
+  }
+
+  return mInterceptController->ShouldPrepareForIntercept(aURI, aChannel,
+                                                         aShouldIntercept);
 }
 
 class HeaderVisitor final : public nsIHttpHeaderVisitor
 {
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   ~HeaderVisitor()
   {
   }
@@ -344,36 +352,40 @@ HttpChannelParentListener::ChannelInterc
     return NS_OK;
   }
 
   if (mShouldSuspendIntercept) {
     mInterceptedChannel = aChannel;
     return NS_OK;
   }
 
-  nsAutoCString statusText;
-  mSynthesizedResponseHead->StatusText(statusText);
-  aChannel->SynthesizeStatus(mSynthesizedResponseHead->Status(), statusText);
-  nsCOMPtr<nsIHttpHeaderVisitor> visitor = new HeaderVisitor(aChannel);
-  DebugOnly<nsresult> rv =
-    mSynthesizedResponseHead->VisitHeaders(visitor,
-                                           nsHttpHeaderArray::eFilterResponse);
-  MOZ_ASSERT(NS_SUCCEEDED(rv));
+  if (mShouldIntercept) {
+    nsAutoCString statusText;
+    mSynthesizedResponseHead->StatusText(statusText);
+    aChannel->SynthesizeStatus(mSynthesizedResponseHead->Status(), statusText);
+    nsCOMPtr<nsIHttpHeaderVisitor> visitor = new HeaderVisitor(aChannel);
+    DebugOnly<nsresult> rv =
+      mSynthesizedResponseHead->VisitHeaders(visitor,
+                                             nsHttpHeaderArray::eFilterResponse);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
 
-  nsCOMPtr<nsIRunnable> event = new FinishSynthesizedResponse(aChannel);
-  NS_DispatchToCurrentThread(event);
+    nsCOMPtr<nsIRunnable> event = new FinishSynthesizedResponse(aChannel);
+    NS_DispatchToCurrentThread(event);
 
-  mSynthesizedResponseHead = nullptr;
+    mSynthesizedResponseHead = nullptr;
 
-  MOZ_ASSERT(mNextListener);
-  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
-  MOZ_ASSERT(channel);
-  channel->ResponseSynthesized();
+    MOZ_ASSERT(mNextListener);
+    RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+    MOZ_ASSERT(channel);
+    channel->ResponseSynthesized();
 
-  return NS_OK;
+    return NS_OK;
+  }
+
+  return mInterceptController->ChannelIntercepted(aChannel);
 }
 
 //-----------------------------------------------------------------------------
 
 nsresult
 HttpChannelParentListener::SuspendForDiversion()
 {
   if (NS_WARN_IF(mSuspendedForDiversion)) {
diff --git a/netwerk/protocol/http/HttpChannelParentListener.h b/netwerk/protocol/http/HttpChannelParentListener.h
--- a/netwerk/protocol/http/HttpChannelParentListener.h
+++ b/netwerk/protocol/http/HttpChannelParentListener.h
@@ -77,16 +77,18 @@ private:
   // interception first occurs.  In this case cancelation is deferred until
   // the interception takes place.
   bool mInterceptCanceled;
 
   nsAutoPtr<nsHttpResponseHead> mSynthesizedResponseHead;
 
   // Handle to the channel wrapper if this channel has been intercepted.
   nsCOMPtr<nsIInterceptedChannel> mInterceptedChannel;
+
+  nsCOMPtr<nsINetworkInterceptController> mInterceptController;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(HttpChannelParentListener,
                               HTTP_CHANNEL_PARENT_LISTENER_IID)
 
 } // namespace net
 } // namespace mozilla
 
diff --git a/netwerk/protocol/http/PHttpChannel.ipdl b/netwerk/protocol/http/PHttpChannel.ipdl
--- a/netwerk/protocol/http/PHttpChannel.ipdl
+++ b/netwerk/protocol/http/PHttpChannel.ipdl
@@ -105,17 +105,18 @@ child:
                        nsCString           cachedCharset,
                        nsCString           securityInfoSerialization,
                        NetAddr             selfAddr,
                        NetAddr             peerAddr,
                        int16_t             redirectCount,
                        uint32_t            cacheKey,
                        nsCString           altDataType,
                        int64_t             altDataLength,
-                       OptionalIPCServiceWorkerDescriptor controller);
+                       OptionalIPCServiceWorkerDescriptor controller,
+                       bool                applyConversion);
 
   // Used to cancel child channel if we hit errors during creating and
   // AsyncOpen of nsHttpChannel on the parent.
   async FailedAsyncOpen(nsresult status);
 
   // Called to initiate content channel redirect, starts talking to sinks
   // on the content process and reports result via Redirect2Verify above
   async Redirect1Begin(uint32_t           registrarId,
