# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a793136c90bc5d32f2c82aa7dea4bc300c4f1836

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -17,16 +17,17 @@
 #include "mozilla/dom/ChromeUtils.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
+#include "mozilla/dom/ReservedClientHelper.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/StartupTimeline.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/Unused.h"
@@ -11501,16 +11502,20 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
 
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
+
+  rv = ReserveClientForChannel(aChannel);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
 nsresult
 nsDocShell::ScrollToAnchor(bool aCurHasRef, bool aNewHasRef,
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13,16 +13,18 @@
 // Local Includes
 #include "Navigator.h"
 #include "nsContentSecurityManager.h"
 #include "nsScreen.h"
 #include "nsHistory.h"
 #include "nsDOMNavigationTiming.h"
 #include "nsIDOMStorageManager.h"
 #include "mozilla/dom/Storage.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/IdleRequest.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/StorageEvent.h"
 #include "mozilla/dom/StorageEventBinding.h"
 #include "mozilla/dom/Timeout.h"
 #include "mozilla/dom/TimeoutHandler.h"
 #include "mozilla/dom/TimeoutManager.h"
 #include "mozilla/IntegerPrintfMacros.h"
@@ -2030,16 +2032,19 @@ nsGlobalWindow::FreeInnerObjects()
   mAudioContexts.Clear();
 
   DisableGamepadUpdates();
   mHasGamepad = false;
   mGamepads.Clear();
   DisableVRUpdates();
   mHasVREvents = false;
   mVRDisplays.Clear();
+
+  // This breaks a cycle between the window and the ClientSource object.
+  mClientSource = nullptr;
 }
 
 //*****************************************************************************
 // nsGlobalWindow::nsISupports
 //*****************************************************************************
 
 // QueryInterface implementation for nsGlobalWindow
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalWindow)
@@ -3134,16 +3139,19 @@ nsGlobalWindow::SetNewDocument(nsIDocume
       }
     } else {
       newInnerWindow->InnerSetNewDocument(cx, aDocument);
 
       // Initialize DOM classes etc on the inner window.
       JS::Rooted<JSObject*> obj(cx, newInnerGlobal);
       rv = kungFuDeathGrip->InitClasses(obj);
       NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = newInnerWindow->InnerExecutionReady();
+      NS_ENSURE_SUCCESS(rv, rv);
     }
 
     // If the document comes from a JAR, check if the channel was determined
     // to be unsafe. If so, permanently disable script on the compartment by
     // calling Block() and throwing away the key.
     nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(aDocument->GetChannel());
     if (jarChannel && jarChannel->GetIsUnsafe()) {
       xpc::Scriptability::Get(newInnerGlobal).Block();
@@ -3301,16 +3309,62 @@ nsGlobalWindow::InnerSetNewDocument(JSCo
 
   Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
                         mMutationBits ? 1 : 0);
 
   // Clear our mutation bitfield.
   mMutationBits = 0;
 }
 
+nsresult
+nsGlobalWindow::EnsureClientSource()
+{
+  MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
+  MOZ_DIAGNOSTIC_ASSERT(mDoc);
+  MOZ_DIAGNOSTIC_ASSERT(!mClientSource);
+
+  // Try to get the reserved client from the loading document
+  nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
+  if (channel) {
+    nsCOMPtr<nsILoadInfo> loadInfo;
+    nsresult rv = channel->GetLoadInfo(getter_AddRefs(loadInfo));
+    if (NS_SUCCEEDED(rv) && loadInfo) {
+      mClientSource = loadInfo->TakeReservedClient();
+    }
+  }
+
+  // We got a reserved client, so there is nothing left to do
+  if (mClientSource) {
+    return NS_OK;
+  }
+
+  // We need to create a reserved client now
+  mClientSource = ClientManager::CreateSource(ClientType::Window,
+                                              mDoc->NodePrincipal());
+  if (!mClientSource) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+nsresult
+nsGlobalWindow::InnerExecutionReady()
+{
+  MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
+
+  nsresult rv = EnsureClientSource();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mClientSource->WindowExecutionReady(AsInner());
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
 void
 nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
 {
   NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
   MOZ_ASSERT(aDocShell);
 
   if (aDocShell == mDocShell) {
     return;
@@ -4175,16 +4229,22 @@ nsPIDOMWindowInner::Thaw()
 }
 
 void
 nsPIDOMWindowInner::SyncStateFromParentWindow()
 {
   nsGlobalWindow::Cast(this)->SyncStateFromParentWindow();
 }
 
+Maybe<ClientInfo>
+nsPIDOMWindowInner::GetClientInfo() const
+{
+  return nsGlobalWindow::Cast(this)->GetClientInfo();
+}
+
 bool
 nsPIDOMWindowInner::IsPlayingAudio()
 {
   RefPtr<AudioChannelService> acs = AudioChannelService::Get();
   if (!acs) {
     return false;
   }
   auto outer = GetOuterWindow();
@@ -12418,16 +12478,27 @@ nsGlobalWindow::CallOnChildren(Method aM
     if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
       continue;
     }
 
     (inner->*aMethod)();
   }
 }
 
+Maybe<ClientInfo>
+nsGlobalWindow::GetClientInfo() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ClientInfo> clientInfo;
+  if (mClientSource) {
+    clientInfo.emplace(mClientSource->Info());
+  }
+  return Move(clientInfo);
+}
+
 nsresult
 nsGlobalWindow::FireDelayedDOMEvents()
 {
   FORWARD_TO_INNER(FireDelayedDOMEvents, (), NS_ERROR_UNEXPECTED);
 
   if (mApplicationCache) {
     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
   }
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -106,16 +106,17 @@ class IdleRequestExecutor;
 
 namespace mozilla {
 class AbstractThread;
 class DOMEventTargetHelper;
 class ThrottledEventQueue;
 namespace dom {
 class BarProp;
 struct ChannelPixelLayout;
+class ClientSource;
 class Console;
 class Crypto;
 class CustomElementRegistry;
 class DocGroup;
 class External;
 class Function;
 class Gamepad;
 enum class ImageBitmapFormat : uint8_t;
@@ -397,16 +398,18 @@ public:
   void Suspend();
   void Resume();
   virtual bool IsSuspended() const override;
   void Freeze();
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+
   virtual nsresult FireDelayedDOMEvents() override;
 
   // Outer windows only.
   virtual bool WouldReuseInnerWindow(nsIDocument* aNewDocument) override;
 
   virtual void SetDocShell(nsIDocShell* aDocShell) override;
   virtual void DetachFromDocShell() override;
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
@@ -1448,16 +1451,22 @@ protected:
 
   void FreeInnerObjects();
   nsGlobalWindow *CallerInnerWindow();
 
   // Only to be called on an inner window.
   // aDocument must not be null.
   void InnerSetNewDocument(JSContext* aCx, nsIDocument* aDocument);
 
+  // inner window only
+  nsresult EnsureClientSource();
+
+  // inner window only
+  nsresult InnerExecutionReady();
+
   // Inner windows only.
   nsresult DefineArgumentsProperty(nsIArray *aArguments);
 
   // Get the parent, returns null if this is a toplevel window
   nsPIDOMWindowOuter* GetParentInternal();
 
 public:
   // popup tracking
@@ -2027,16 +2036,19 @@ protected:
   // This is the CC generation the last time we called CanSkip.
   uint32_t mCanSkipCCGeneration;
 
   // The VR Displays for this window
   nsTArray<RefPtr<mozilla::dom::VRDisplay>> mVRDisplays;
 
   RefPtr<mozilla::dom::VREventObserver> mVREventObserver;
 
+  // inner window only
+  mozilla::UniquePtr<mozilla::dom::ClientSource> mClientSource;
+
   friend class nsDOMScriptableHelper;
   friend class nsDOMWindowUtils;
   friend class mozilla::dom::PostMessageEvent;
   friend class DesktopNotification;
   friend class mozilla::dom::TimeoutManager;
   friend class IdleRequestExecutor;
 
   static WindowByIdTable* sWindowsById;
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -40,16 +40,17 @@ class nsPIWindowRoot;
 class nsXBLPrototypeHandler;
 
 typedef uint32_t SuspendTypes;
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
 class AudioContext;
+class ClientInfo;
 class DocGroup;
 class TabGroup;
 class Element;
 class Performance;
 class ServiceWorkerRegistration;
 class Timeout;
 class TimeoutManager;
 class CustomElementRegistry;
@@ -880,16 +881,18 @@ public:
   void SyncStateFromParentWindow();
 
   bool IsPlayingAudio();
 
   mozilla::dom::TimeoutManager& TimeoutManager();
 
   bool IsRunningTimeout();
 
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+
 protected:
   void CreatePerformanceObjectIfNeeded();
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(nsPIDOMWindowInner, NS_PIDOMWINDOWINNER_IID)
 
 // NB: It's very very important that these two classes have identical vtables
 // and memory layout!
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -0,0 +1,146 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandle.h"
+
+#include "ClientHandleChild.h"
+#include "ClientManager.h"
+#include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandle::Op
+{
+public:
+  virtual ~Op() { }
+
+  virtual void
+  Execute(PClientHandleChild* aActor) = 0;
+};
+
+template<typename Callable>
+class ClientHandle::OpImpl final : public ClientHandle::Op
+{
+  Callable mCallable;
+
+public:
+  explicit OpImpl(Callable aCallable)
+    : mCallable(aCallable)
+  { }
+
+  void
+  Execute(PClientHandleChild* aActor) override
+  {
+    MOZ_DIAGNOSTIC_ASSERT(aActor);
+    mCallable(aActor);
+  }
+};
+
+ClientHandle::~ClientHandle()
+{
+  Shutdown();
+}
+
+void
+ClientHandle::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (mShutdown) {
+    return;
+  }
+  mShutdown = true;
+
+  mOpList.Clear();
+
+  if (mActor) {
+    mActor->RevokeHandle(this);
+    mActor->MaybeStartTeardown();
+    mActor = nullptr;
+  }
+
+  mManager->ForgetHandle(this);
+  mManager = nullptr;
+}
+
+template<typename Callable>
+void
+ClientHandle::MaybeExecute(Callable aCallable)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientHandle);
+  if (mShutdown) {
+    return;
+  }
+  mOpList.AppendElement(new OpImpl<Callable>(aCallable));
+  MaybeExecuteOpList();
+}
+
+void
+ClientHandle::MaybeExecuteOpList()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientHandle);
+  if (mShutdown || !mActor) {
+    return;
+  }
+  nsTArray<UniquePtr<Op>> opList;
+  mOpList.SwapElements(opList);
+  for (UniquePtr<Op>& o : opList) {
+    o->Execute(mActor);
+  }
+}
+
+ClientHandle::ClientHandle(ClientManager* aManager)
+  : mManager(aManager)
+  , mActor(nullptr)
+  , mShutdown(false)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
+}
+
+void
+ClientHandle::Activate(PClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientHandle);
+  MOZ_ASSERT(!mActor);
+
+  if (mShutdown) {
+    return;
+  }
+
+  ClientHandleConstructorArgs args;
+  PClientHandleChild* actor = aActor->SendPClientHandleConstructor(args);
+  if (!actor) {
+    Shutdown();
+    return;
+  }
+
+  mActor = static_cast<ClientHandleChild*>(actor);
+  mActor->SetHandle(this);
+
+  MaybeExecuteOpList();
+}
+
+void
+ClientHandle::RevokeActor(ClientHandleChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientHandle);
+  MOZ_ASSERT(mActor);
+  mActor->RevokeHandle(this);
+  mActor = nullptr;
+}
+
+void
+ClientHandle::SetControlled(const nsACString& aScope, uint64_t aServiceWorkerID)
+{
+  nsCString scope(aScope);
+  MaybeExecute([scope, aServiceWorkerID](PClientHandleChild* aActor) {
+    aActor->SendControlled(ClientControlledArgs(scope, aServiceWorkerID));
+  });
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandle.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandle_h
+#define _mozilla_dom_ClientHandle_h
+
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManager;
+class ClientHandleChild;
+class PClientManagerChild;
+
+class ClientHandle final
+{
+  friend class ClientManager;
+  friend class ClientHandleChild;
+
+  class Op;
+  template<typename Callable> class OpImpl;
+
+  RefPtr<ClientManager> mManager;
+  nsTArray<UniquePtr<Op>> mOpList;
+  ClientHandleChild* mActor;
+  bool mShutdown;
+
+  ~ClientHandle();
+
+  void
+  Shutdown();
+
+  template<typename Callable>
+  void
+  MaybeExecute(Callable aCallable);
+
+  void
+  MaybeExecuteOpList();
+
+  // Private methods called by ClientManager
+  explicit ClientHandle(ClientManager* aManager);
+
+  void
+  Activate(PClientManagerChild* aActor);
+
+  // Private methods called by ClientHandleChild
+  void
+  RevokeActor(ClientHandleChild* aActor);
+
+public:
+  void
+  SetControlled(const nsACString& aScope, uint64_t aServiceWorkerID);
+
+  NS_INLINE_DECL_REFCOUNTING(ClientHandle);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandle_h
diff --git a/dom/clients/manager/ClientHandleChild.cpp b/dom/clients/manager/ClientHandleChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleChild.cpp
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleChild.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientHandleChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mHandle) {
+    mHandle->RevokeActor(this);
+    MOZ_DIAGNOSTIC_ASSERT(!mHandle);
+  }
+}
+
+ClientHandleChild::ClientHandleChild(const ClientHandleConstructorArgs& aArgs)
+  : mHandle(nullptr)
+  , mTeardownStarted(false)
+{
+}
+
+void
+ClientHandleChild::SetHandle(ClientHandle* aHandle)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mHandle);
+  mHandle = aHandle;
+  MOZ_DIAGNOSTIC_ASSERT(mHandle);
+}
+
+void
+ClientHandleChild::RevokeHandle(ClientHandle* aHandle)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mHandle);
+  MOZ_DIAGNOSTIC_ASSERT(mHandle == aHandle);
+  mHandle = nullptr;
+}
+
+void
+ClientHandleChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  Unused << SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleChild.h b/dom/clients/manager/ClientHandleChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleChild.h
@@ -0,0 +1,42 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleChild_h
+#define _mozilla_dom_ClientHandleChild_h
+
+#include "mozilla/dom/PClientHandleChild.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandle;
+class ClientHandleConstructorArgs;
+
+class ClientHandleChild final : public PClientHandleChild
+{
+  ClientHandle* mHandle;
+  bool mTeardownStarted;
+
+  // PClientHandleChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientHandleChild(const ClientHandleConstructorArgs& aArgs);
+
+  void
+  SetHandle(ClientHandle* aHandle);
+
+  void
+  RevokeHandle(ClientHandle* aHandle);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleChild_h
diff --git a/dom/clients/manager/ClientHandleParent.cpp b/dom/clients/manager/ClientHandleParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleParent.cpp
@@ -0,0 +1,42 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleParent.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientHandleParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+IPCResult
+ClientHandleParent::RecvControlled(const ClientControlledArgs& aArgs)
+{
+  printf_stderr("### ### RecvControlled() scope:%s id:%lu\n",
+                aArgs.scope().get(), aArgs.serviceWorkerID());
+  return IPC_OK();
+}
+
+void
+ClientHandleParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+ClientHandleParent::ClientHandleParent(const ClientHandleConstructorArgs& aArgs)
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleParent.h b/dom/clients/manager/ClientHandleParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientHandleParent.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleParent_h
+#define _mozilla_dom_ClientHandleParent_h
+
+#include "mozilla/dom/PClientHandleParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientControlledArgs;
+class ClientHandleConstructorArgs;
+
+class ClientHandleParent final : public PClientHandleParent
+{
+  // PClientHandleParent interface
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  mozilla::ipc::IPCResult
+  RecvControlled(const ClientControlledArgs& aArgs) override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientHandleParent(const ClientHandleConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleParent_h
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -0,0 +1,67 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
+using ClientType from "mozilla/dom/ClientIPCUtils.h";
+using FrameType from "mozilla/dom/ClientIPCUtils.h";
+using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+
+struct ClientHandleConstructorArgs
+{
+  bool todo;
+};
+
+struct ClientSourceConstructorArgs
+{
+  nsID id;
+  ClientType type;
+  PrincipalInfo principal;
+  TimeStamp creationTime;
+};
+
+struct ClientWindowState
+{
+  VisibilityState visibilityState;
+  TimeStamp lastFocusTime;
+  bool focused;
+};
+
+struct ClientWorkerState
+{
+};
+
+union ClientState
+{
+  nsresult;
+  ClientWindowState;
+  ClientWorkerState;
+};
+
+struct ClientSourceExecutionReadyArgs
+{
+  nsCString url;
+  FrameType frameType;
+};
+
+struct ClientControlledArgs
+{
+  nsCString scope;
+  uint64_t serviceWorkerID;
+};
+
+struct ClientInfo
+{
+  nsID id;
+  ClientType type;
+  PrincipalInfo principal;
+  nsCString url;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientIPCUtils.h b/dom/clients/manager/ClientIPCUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientIPCUtils.h
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientIPCUtils_h
+#define _mozilla_dom_ClientIPCUtils_h
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/ClientBinding.h"
+#include "mozilla/dom/ClientsBinding.h"
+#include "mozilla/dom/DocumentBinding.h"
+
+namespace IPC {
+  template<>
+  struct ParamTraits<mozilla::dom::ClientType> :
+    public ContiguousEnumSerializer<mozilla::dom::ClientType,
+                                    mozilla::dom::ClientType::Window,
+                                    mozilla::dom::ClientType::EndGuard_>
+  {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::FrameType> :
+    public ContiguousEnumSerializer<mozilla::dom::FrameType,
+                                    mozilla::dom::FrameType::Auxiliary,
+                                    mozilla::dom::FrameType::EndGuard_>
+  {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::VisibilityState> :
+    public ContiguousEnumSerializer<mozilla::dom::VisibilityState,
+                                    mozilla::dom::VisibilityState::Hidden,
+                                    mozilla::dom::VisibilityState::EndGuard_>
+  {};
+} // namespace IPC
+
+#endif // _mozilla_dom_ClientIPCUtils_h
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManager.cpp
@@ -0,0 +1,319 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManager.h"
+
+#include "ClientManagerChild.h"
+#include "ClientSource.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "prthread.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::Terminating;
+using mozilla::dom::workers::WorkerHolderToken;
+
+namespace {
+
+uint32_t kBadThreadLocalIndex = -1;
+uint32_t sClientManagerThreadLocalIndex = kBadThreadLocalIndex;
+
+} // anonymous namespace
+
+class ClientManager::PBackgroundCreateCallback final : public nsIIPCBackgroundChildCreateCallback
+{
+  RefPtr<ClientManager> mManager;
+
+  ~PBackgroundCreateCallback()
+  {
+  }
+
+public:
+  explicit PBackgroundCreateCallback(ClientManager* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(mManager);
+  }
+
+  void
+  ActorCreated(PBackgroundChild* aActor) override
+  {
+    mManager->PBackgroundActorCreated(aActor);
+    mManager = nullptr;
+  }
+
+  void
+  ActorFailed() override
+  {
+    mManager->Shutdown();
+    mManager = nullptr;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ClientManager::PBackgroundCreateCallback,
+                  nsIIPCBackgroundChildCreateCallback);
+
+ClientManager::ClientManager()
+  : mActor(nullptr)
+  , mShutdown(false)
+{
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    PBackgroundActorCreated(actor);
+    return;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+  RefPtr<PBackgroundCreateCallback> cb = new PBackgroundCreateCallback(this);
+  bool ok = BackgroundChild::GetOrCreateForCurrentThread(cb);
+  if (NS_WARN_IF(!ok)) {
+    Shutdown();
+  }
+}
+
+ClientManager::~ClientManager()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(mPendingSourceList.IsEmpty());
+  MOZ_ASSERT(mPendingHandleList.IsEmpty());
+
+  Shutdown();
+
+  MOZ_DIAGNOSTIC_ASSERT(this == PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+  PRStatus status =
+    PR_SetThreadPrivate(sClientManagerThreadLocalIndex, nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+}
+
+void
+ClientManager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (mShutdown) {
+    return;
+  }
+  mShutdown = true;
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Shutdown();
+  }
+
+  nsTArray<ClientHandle*> pendingHandleList;
+  mPendingHandleList.SwapElements(pendingHandleList);
+  for (ClientHandle* handle : pendingHandleList) {
+    handle->Shutdown();
+  }
+
+  if (!mActor) {
+    return;
+  }
+  mActor->RevokeManager(this);
+  mActor->MaybeStartTeardown();
+  mActor = nullptr;
+}
+
+UniquePtr<ClientSource>
+ClientManager::CreateSourceInternal(ClientType aType,
+                                    const PrincipalInfo& aPrincipal)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (mShutdown) {
+    return nullptr;
+  }
+
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> idGen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  nsID id;
+  rv = idGen->GenerateUUIDInPlace(&id);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+
+  ClientSourceConstructorArgs args(id, aType, aPrincipal, TimeStamp::Now());
+  UniquePtr<ClientSource> source(new ClientSource(this, args));
+
+  if (mActor) {
+    source->Activate(mActor);
+  } else {
+    mPendingSourceList.AppendElement(source.get());
+  }
+
+  return Move(source);
+}
+
+already_AddRefed<ClientHandle>
+ClientManager::CreateHandleInternal(const ClientInfo& aClientInfo)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (mShutdown) {
+    return nullptr;
+  }
+
+  RefPtr<ClientHandle> handle = new ClientHandle(this);
+
+  if (mActor) {
+    handle->Activate(mActor);
+  } else {
+    mPendingHandleList.AppendElement(handle);
+  }
+
+  return handle.forget();
+}
+
+void
+ClientManager::RevokeActor(ClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(mActor);
+  MOZ_ASSERT(mActor == aActor);
+  mActor->RevokeManager(this);
+  mActor = nullptr;
+}
+
+void
+ClientManager::ForgetSource(ClientSource* aSource)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  mPendingSourceList.RemoveElement(aSource);
+}
+
+void
+ClientManager::ForgetHandle(ClientHandle* aHandle)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  mPendingHandleList.RemoveElement(aHandle);
+}
+
+void
+ClientManager::PBackgroundActorCreated(PBackgroundChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(aActor);
+
+  if (mShutdown) {
+    return;
+  }
+
+  RefPtr<WorkerHolderToken> workerHolderToken;
+  if (!NS_IsMainThread()) {
+    workerHolderToken =
+      WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Terminating);
+    if (NS_WARN_IF(!workerHolderToken)) {
+      Shutdown();
+      return;
+    }
+  }
+
+  ClientManagerChild* actor = new ClientManagerChild(this, workerHolderToken);
+  PClientManagerChild *sentActor = aActor->SendPClientManagerConstructor(actor);
+  if (NS_WARN_IF(!sentActor)) {
+    Shutdown();
+    return;
+  }
+  MOZ_ASSERT(sentActor == actor);
+
+  mActor = static_cast<ClientManagerChild*>(actor);
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Activate(mActor);
+  }
+
+  nsTArray<ClientHandle*> pendingHandleList;
+  mPendingHandleList.SwapElements(pendingHandleList);
+  for (ClientHandle* handle : pendingHandleList) {
+    handle->Activate(mActor);
+  }
+}
+
+// static
+void
+ClientManager::Startup()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  PRStatus status =
+    PR_NewThreadPrivateIndex(&sClientManagerThreadLocalIndex, nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+}
+
+// static
+already_AddRefed<ClientManager>
+ClientManager::GetOrCreateForCurrentThread()
+{
+  MOZ_DIAGNOSTIC_ASSERT(sClientManagerThreadLocalIndex != kBadThreadLocalIndex);
+  RefPtr<ClientManager> cm =
+    static_cast<ClientManager*>(PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+
+  if (!cm) {
+    cm = new ClientManager();
+
+    PRStatus status =
+      PR_SetThreadPrivate(sClientManagerThreadLocalIndex, cm.get());
+    MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+  }
+
+  MOZ_ASSERT(cm);
+  return cm.forget();
+}
+
+// static
+UniquePtr<ClientSource>
+ClientManager::CreateSource(ClientType aType, nsIPrincipal* aPrincipal)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(aPrincipal);
+
+  PrincipalInfo principalInfo;
+  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateSourceInternal(aType, principalInfo);
+}
+
+// static
+UniquePtr<ClientSource>
+ClientManager::CreateSource(ClientType aType, const PrincipalInfo& aPrincipal)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateSourceInternal(aType, aPrincipal);
+}
+
+// static
+already_AddRefed<ClientHandle>
+ClientManager::CreateHandle(const ClientInfo& aClientInfo)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->CreateHandleInternal(aClientInfo);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManager.h
@@ -0,0 +1,89 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManager_h
+#define _mozilla_dom_ClientManager_h
+
+#include "mozilla/dom/PClientManager.h"
+#include "nsTArray.h"
+
+class nsIPrincipal;
+class nsIURI;
+
+namespace mozilla {
+namespace ipc {
+class PBackgroundChild;
+class PrincipalInfo;
+} // namespace ipc
+namespace dom {
+
+class ClientHandle;
+class ClientManagerChild;
+class ClientSource;
+enum class ClientType : uint8_t;
+
+class ClientManager final
+{
+  friend class ClientHandle;
+  friend class ClientManagerChild;
+  friend class ClientSource;
+  class PBackgroundCreateCallback;
+
+  ClientManagerChild* mActor;
+  nsTArray<ClientSource*> mPendingSourceList;
+  nsTArray<ClientHandle*> mPendingHandleList;
+  bool mShutdown;
+
+  ClientManager();
+  ~ClientManager();
+
+  void
+  Shutdown();
+
+  UniquePtr<ClientSource>
+  CreateSourceInternal(ClientType aType,
+                       const mozilla::ipc::PrincipalInfo& aPrincipal);
+
+  already_AddRefed<ClientHandle>
+  CreateHandleInternal(const ClientInfo& aClientInfo);
+
+  void
+  PBackgroundActorCreated(mozilla::ipc::PBackgroundChild* aActor);
+
+  // Private methods called by ClientManagerChild
+  void
+  RevokeActor(ClientManagerChild* aActor);
+
+  // Private methods called by ClientSource
+  void
+  ForgetSource(ClientSource* aSource);
+
+  // Private methods calls by ClientHandle
+  void
+  ForgetHandle(ClientHandle* aHandle);
+
+public:
+  static void
+  Startup();
+
+  static already_AddRefed<ClientManager>
+  GetOrCreateForCurrentThread();
+
+  static UniquePtr<ClientSource>
+  CreateSource(ClientType aType, nsIPrincipal* aPrincipal);
+
+  static UniquePtr<ClientSource>
+  CreateSource(ClientType aType, const mozilla::ipc::PrincipalInfo& aPrincipal);
+
+  static already_AddRefed<ClientHandle>
+  CreateHandle(const ClientInfo& aClientInfo);
+
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerActors.cpp b/dom/clients/manager/ClientManagerActors.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerActors.cpp
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+#include "ClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+PClientManagerChild*
+AllocClientManagerChild()
+{
+  MOZ_ASSERT_UNREACHABLE("Default ClientManagerChild allocator should not be invoked");
+  return nullptr;
+}
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientManagerParent*
+AllocClientManagerParent()
+{
+  return new ClientManagerParent();
+}
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerActors.h b/dom/clients/manager/ClientManagerActors.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerActors.h
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerActors_h
+#define _mozilla_dom_ClientManagerActors_h
+
+namespace mozilla {
+namespace dom {
+
+class PClientManagerChild;
+class PClientManagerParent;
+
+PClientManagerChild*
+AllocClientManagerChild();
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor);
+
+PClientManagerParent*
+AllocClientManagerParent();
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor);
+
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerActors_h
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -0,0 +1,98 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+
+#include "ClientHandleChild.h"
+#include "ClientManager.h"
+#include "ClientSourceChild.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::WorkerHolderToken;
+
+void
+ClientManagerChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->RemoveListener(this);
+    mWorkerHolderToken = nullptr;
+
+  }
+
+  if (mManager) {
+    mManager->RevokeActor(this);
+    MOZ_ASSERT(!mManager);
+  }
+}
+
+PClientHandleChild*
+ClientManagerChild::AllocPClientHandleChild(const ClientHandleConstructorArgs& aArgs)
+{
+  return new ClientHandleChild(aArgs);
+}
+
+bool
+ClientManagerChild::DeallocPClientHandleChild(PClientHandleChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientSourceChild*
+ClientManagerChild::AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceChild(aArgs);
+}
+
+bool
+ClientManagerChild::DeallocPClientSourceChild(PClientSourceChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+void
+ClientManagerChild::WorkerShuttingDown()
+{
+  MaybeStartTeardown();
+}
+
+ClientManagerChild::ClientManagerChild(ClientManager* aManager,
+                                       WorkerHolderToken* aWorkerHolderToken)
+  : mManager(aManager)
+  , mWorkerHolderToken(aWorkerHolderToken)
+  , mTeardownStarted(false)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolderToken);
+
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->AddListener(this);
+  }
+}
+
+void
+ClientManagerChild::RevokeManager(ClientManager* aManager)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mManager == aManager);
+  mManager = nullptr;
+}
+
+void
+ClientManagerChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerChild.h b/dom/clients/manager/ClientManagerChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerChild.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerChild_h
+#define _mozilla_dom_ClientManagerChild_h
+
+#include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerChild final : public PClientManagerChild
+                               , public mozilla::dom::workers::WorkerHolderToken::Listener
+{
+  // Weak reference.  The ClientManager will call RevokeManager() when
+  // it is destroyed.
+  ClientManager* mManager;
+
+  RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
+  bool mTeardownStarted;
+
+  // PClientManagerChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleChild*
+  AllocPClientHandleChild(const ClientHandleConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleChild(PClientHandleChild* aActor) override;
+
+  PClientSourceChild*
+  AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceChild(PClientSourceChild* aActor) override;
+
+  // WorkerHolderToken::Listener interface
+  void
+  WorkerShuttingDown() override;
+
+public:
+  ClientManagerChild(ClientManager* aManager,
+                     mozilla::dom::workers::WorkerHolderToken* aWorkerHolderToken);
+
+  void
+  RevokeManager(ClientManager* aManager);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerChild_h
diff --git a/dom/clients/manager/ClientManagerParent.cpp b/dom/clients/manager/ClientManagerParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerParent.cpp
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerParent.h"
+
+#include "ClientHandleParent.h"
+#include "ClientManagerService.h"
+#include "ClientSourceParent.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientManagerParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientManagerParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+PClientHandleParent*
+ClientManagerParent::AllocPClientHandleParent(const ClientHandleConstructorArgs& aArgs)
+{
+  return new ClientHandleParent(aArgs);
+}
+
+bool
+ClientManagerParent::DeallocPClientHandleParent(PClientHandleParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientSourceParent*
+ClientManagerParent::AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceParent(aArgs);
+}
+
+bool
+ClientManagerParent::DeallocPClientSourceParent(PClientSourceParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+ClientManagerParent::ClientManagerParent()
+  : mService(ClientManagerService::GetOrCreateInstance())
+{
+}
+
+ClientManagerParent::~ClientManagerParent()
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerParent.h b/dom/clients/manager/ClientManagerParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerParent.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerParent_h
+#define _mozilla_dom_ClientManagerParent_h
+
+#include "mozilla/dom/PClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerService;
+
+class ClientManagerParent final : public PClientManagerParent
+{
+  RefPtr<ClientManagerService> mService;
+
+  // PClientManagerParent interface
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleParent*
+  AllocPClientHandleParent(const ClientHandleConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleParent(PClientHandleParent* aActor) override;
+
+  PClientSourceParent*
+  AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceParent(PClientSourceParent* aActor) override;
+
+public:
+  ClientManagerParent();
+  ~ClientManagerParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerParent_h
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerService.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+namespace {
+
+ClientManagerService* sClientManagerServiceInstance = nullptr;
+
+} // anonymous namespace
+
+ClientManagerService::ClientManagerService()
+{
+  AssertIsOnBackgroundThread();
+  printf_stderr("### ### [%p] ClientManagerService()\n", this);
+}
+
+ClientManagerService::~ClientManagerService()
+{
+  AssertIsOnBackgroundThread();
+
+  printf_stderr("### ### [%p] ~ClientManagerService()\n", this);
+
+  MOZ_ASSERT(mSourceList.IsEmpty());
+
+  MOZ_DIAGNOSTIC_ASSERT(sClientManagerServiceInstance == this);
+  sClientManagerServiceInstance = nullptr;
+}
+
+// static
+already_AddRefed<ClientManagerService>
+ClientManagerService::GetOrCreateInstance()
+{
+  AssertIsOnBackgroundThread();
+
+  if (!sClientManagerServiceInstance) {
+    sClientManagerServiceInstance = new ClientManagerService();
+  }
+
+  RefPtr<ClientManagerService> ref(sClientManagerServiceInstance);
+  return ref.forget();
+}
+
+void
+ClientManagerService::AddSource(ClientSourceParent* aSource)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aSource);
+  MOZ_ASSERT(!mSourceList.Contains(aSource));
+  nsCString type(ClientTypeValues::strings[(uint8_t)aSource->Type()].value,
+                 ClientTypeValues::strings[(uint8_t)aSource->Type()].length);
+  nsCString spec;
+  if (aSource->GetPrincipalInfo().type() == PrincipalInfo::TContentPrincipalInfo) {
+    spec = aSource->GetPrincipalInfo().get_ContentPrincipalInfo().spec();
+  }
+  printf_stderr("### ### [%p] ClientManagerService::AddSource(%p) list %lu to %lu - type:%s origin:%s\n",
+                this, aSource, mSourceList.Length(), (mSourceList.Length() + 1),
+                type.get(), spec.get());
+  mSourceList.AppendElement(aSource);
+}
+
+void
+ClientManagerService::RemoveSource(ClientSourceParent* aSource)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aSource);
+  nsCString type(ClientTypeValues::strings[(uint8_t)aSource->Type()].value,
+                 ClientTypeValues::strings[(uint8_t)aSource->Type()].length);
+  nsCString spec;
+  if (aSource->GetPrincipalInfo().type() == PrincipalInfo::TContentPrincipalInfo) {
+    spec = aSource->GetPrincipalInfo().get_ContentPrincipalInfo().spec();
+  }
+  printf_stderr("### ### [%p] ClientManagerService::RemoveSource(%p) list %lu to %lu - type:%s origin:%s\n",
+                this, aSource, mSourceList.Length(), (mSourceList.Length() - 1),
+                type.get(), spec.get());
+  MOZ_ALWAYS_TRUE(mSourceList.RemoveElement(aSource));
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientManagerService.h
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerService_h
+#define _mozilla_dom_ClientManagerService_h
+
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSourceParent;
+
+class ClientManagerService final
+{
+  // TODO: break this up by principal/id?
+  // TODO: use something that is not O(n) on clients
+  nsTArray<ClientSourceParent*> mSourceList;
+
+  ClientManagerService();
+  ~ClientManagerService();
+
+public:
+  static already_AddRefed<ClientManagerService>
+  GetOrCreateInstance();
+
+  void
+  AddSource(ClientSourceParent* aSource);
+
+  void
+  RemoveSource(ClientSourceParent* aSource);
+
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManagerService)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerService_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSource.cpp
@@ -0,0 +1,291 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSource.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/WorkerPrivate.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::WorkerPrivate;
+
+class ClientSource::Op
+{
+public:
+  virtual ~Op() { }
+
+  virtual void
+  Execute(PClientSourceChild* aActor) = 0;
+};
+
+template<typename Callable>
+class ClientSource::OpImpl final : public ClientSource::Op
+{
+  Callable mCallable;
+
+public:
+  explicit OpImpl(Callable aCallable)
+    : mCallable(aCallable)
+  { }
+
+  void
+  Execute(PClientSourceChild* aActor) override
+  {
+    MOZ_DIAGNOSTIC_ASSERT(aActor);
+    mCallable(aActor);
+  }
+};
+
+void
+ClientSource::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (mShutdown) {
+    return;
+  }
+  mShutdown = true;
+
+  mOpList.Clear();
+
+  if (mActor) {
+    mActor->RevokeSource(this);
+    mActor->MaybeStartTeardown();
+    mActor = nullptr;
+  }
+
+  mManager->ForgetSource(this);
+  mManager = nullptr;
+}
+
+template<typename Callable>
+void
+ClientSource::MaybeExecute(Callable aCallable)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (mShutdown) {
+    return;
+  }
+  mOpList.AppendElement(new OpImpl<Callable>(aCallable));
+  MaybeExecuteOpList();
+}
+
+void
+ClientSource::MaybeExecuteOpList()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (mShutdown || !mActor) {
+    return;
+  }
+  nsTArray<UniquePtr<Op>> opList;
+  mOpList.SwapElements(opList);
+  for (UniquePtr<Op>& o : opList) {
+    o->Execute(mActor);
+  }
+}
+
+void
+ClientSource::ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
+{
+  mClientInfo.url() = aArgs.url();
+  MaybeExecute([aArgs](PClientSourceChild* aActor) {
+    aActor->SendExecutionReady(aArgs);
+  });
+}
+
+nsresult
+ClientSource::SnapshotWindowState(nsPIDOMWindowInner* aInnerWindow,
+                                  ClientWindowState* aStateOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow);
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->IsCurrentInnerWindow());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->HasActiveDocument());
+
+  nsIDocument* doc = aInnerWindow->GetExtantDoc();
+  if (NS_WARN_IF(!doc)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  ErrorResult rv;
+  aStateOut->focused() = doc->HasFocus(rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    rv.SuppressException();
+    return rv.StealNSResult();
+  }
+
+  aStateOut->lastFocusTime() = doc->LastFocusTime();
+  aStateOut->visibilityState() = doc->VisibilityState();
+
+  return NS_OK;
+}
+
+ClientSource::ClientSource(ClientManager* aManager,
+                           const ClientSourceConstructorArgs& aArgs)
+  : mManager(aManager)
+  , mArgs(aArgs)
+  , mClientInfo(mArgs.id(), mArgs.type(), mArgs.principal(), EmptyCString())
+  , mActor(nullptr)
+  , mShutdown(false)
+{
+  MOZ_ASSERT(mManager);
+}
+
+void
+ClientSource::Activate(PClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_ASSERT(!mActor);
+
+  if (mShutdown) {
+    return;
+  }
+
+  PClientSourceChild* actor = aActor->SendPClientSourceConstructor(mArgs);
+  if (!actor) {
+    Shutdown();
+    return;
+  }
+
+  mActor = static_cast<ClientSourceChild*>(actor);
+  mActor->SetSource(this);
+
+  MaybeExecuteOpList();
+}
+
+void
+ClientSource::RevokeActor(ClientSourceChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_ASSERT(mActor);
+  mActor->RevokeSource(this);
+  mActor = nullptr;
+}
+
+void
+ClientSource::RequestState()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+
+  if (mArgs.type() != ClientType::Window) {
+    Unused << mActor->SendState(ClientWorkerState());
+    return;
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(mInnerWindow);
+
+  ClientWindowState state;
+
+  nsresult rv = SnapshotWindowState(mInnerWindow, &state);
+  if (NS_FAILED(rv)) {
+    Unused << mActor->SendState(rv);
+    return;
+  }
+
+  Unused << mActor->SendState(state);
+}
+
+ClientSource::~ClientSource()
+{
+  Shutdown();
+}
+
+nsresult
+ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  ClientSourceExecutionReadyArgs args(
+    NS_ConvertUTF16toUTF8(aWorkerPrivate->ScriptURL()),
+    FrameType::None);
+
+  ExecutionReady(args);
+
+  return NS_OK;
+}
+
+nsresult
+ClientSource::WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow);
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->IsCurrentInnerWindow());
+  MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->HasActiveDocument());
+
+  nsIDocument* doc = aInnerWindow->GetExtantDoc();
+  if (NS_WARN_IF(!doc)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  nsCString spec;
+
+  nsIURI* uri = doc->GetOriginalURI();
+  if (uri) {
+    nsresult rv = uri->GetSpec(spec);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+  }
+
+  nsPIDOMWindowOuter* outer = aInnerWindow->GetOuterWindow();
+  if (NS_WARN_IF(!outer)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  FrameType frameType = FrameType::Top_level;
+  if (!outer->IsTopLevelWindow()) {
+    frameType = FrameType::Nested;
+  } else if(outer->HadOriginalOpener()) {
+    frameType = FrameType::Auxiliary;
+  }
+
+  ClientSourceExecutionReadyArgs args(spec, frameType);
+  ExecutionReady(args);
+
+  // This creates a cycle with the window.  It is broken when
+  // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
+  mInnerWindow = aInnerWindow;
+
+  return NS_OK;
+}
+
+void
+ClientSource::Freeze()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendFreeze();
+  });
+}
+
+void
+ClientSource::Thaw()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendThaw();
+  });
+}
+
+const ClientInfo&
+ClientSource::Info() const
+{
+  return mClientInfo;
+}
+
+void
+ClientSource::WorkerSyncPing(WorkerPrivate* aWorkerPrivate)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  mActor->SendWorkerSyncPing();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSource.h
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSource_h
+#define _mozilla_dom_ClientSource_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManager;
+class ClientSourceChild;
+class ClientSourceExecutionReadyArgs;
+class PClientManagerChild;
+
+namespace workers {
+class WorkerPrivate;
+} // workers namespace
+
+class ClientSource final
+{
+  class Op;
+  template<typename Callable> class OpImpl;
+  friend class ClientManager;
+  friend class ClientSourceChild;
+
+  NS_DECL_OWNINGTHREAD
+
+  RefPtr<ClientManager> mManager;
+  RefPtr<nsPIDOMWindowInner> mInnerWindow;
+  const ClientSourceConstructorArgs mArgs;
+  ClientInfo mClientInfo;
+  nsTArray<UniquePtr<Op>> mOpList;
+  ClientSourceChild* mActor;
+  bool mShutdown;
+
+  void
+  Shutdown();
+
+  template<typename Callable>
+  void
+  MaybeExecute(Callable aCallable);
+
+  void
+  MaybeExecuteOpList();
+
+  void
+  ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
+
+  nsresult
+  SnapshotWindowState(nsPIDOMWindowInner* aInnerWindow,
+                      ClientWindowState* aStateOut);
+
+  // Private methods called by ClientManager
+  ClientSource(ClientManager* aManager,
+               const ClientSourceConstructorArgs& aArgs);
+
+  void
+  Activate(PClientManagerChild* aActor);
+
+  // Private methods called by ClientSourceChild
+  void
+  RevokeActor(ClientSourceChild* aActor);
+
+  void
+  RequestState();
+
+public:
+  ~ClientSource();
+
+  nsresult
+  WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
+
+  nsresult
+  WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
+
+  void
+  Freeze();
+
+  void
+  Thaw();
+
+  const ClientInfo&
+  Info() const;
+
+  void
+  WorkerSyncPing(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSource_h
diff --git a/dom/clients/manager/ClientSourceChild.cpp b/dom/clients/manager/ClientSourceChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceChild.cpp
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceChild.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientSourceChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mSource) {
+    mSource->RevokeActor(this);
+    MOZ_ASSERT(!mSource);
+  }
+}
+
+IPCResult
+ClientSourceChild::RecvRequestState()
+{
+  if (mSource) {
+    mSource->RequestState();
+  }
+
+  return IPC_OK();
+}
+
+ClientSourceChild::ClientSourceChild(const ClientSourceConstructorArgs& aArgs)
+  : mSource(nullptr)
+  , mTeardownStarted(false)
+{
+}
+
+void
+ClientSourceChild::SetSource(ClientSource* aSource)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mSource);
+  mSource = aSource;
+  MOZ_DIAGNOSTIC_ASSERT(mSource);
+}
+
+void
+ClientSourceChild::RevokeSource(ClientSource* aSource)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mSource);
+  MOZ_DIAGNOSTIC_ASSERT(mSource == aSource);
+  mSource = nullptr;
+}
+
+void
+ClientSourceChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  Unused << SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceChild.h b/dom/clients/manager/ClientSourceChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceChild.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceChild_h
+#define _mozilla_dom_ClientSourceChild_h
+
+#include "mozilla/dom/PClientSourceChild.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+class ClientSourceConstructorArgs;
+
+class ClientSourceChild final : public PClientSourceChild
+{
+  ClientSource* mSource;
+  bool mTeardownStarted;
+
+  // PClientSourceChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  RecvRequestState() override;
+
+public:
+  explicit ClientSourceChild(const ClientSourceConstructorArgs& aArgs);
+
+  void
+  SetSource(ClientSource* aSource);
+
+  void
+  RevokeSource(ClientSource* aSource);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceChild_h
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceParent.h"
+
+#include "ClientManagerService.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+using mozilla::ipc::PrincipalInfo;
+
+IPCResult
+ClientSourceParent::RecvWorkerSyncPing()
+{
+  // Do nothing here.  This is purely a sync message allowing the child to
+  // confirm that the actor has been created on the parent process.
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+mozilla::ipc::IPCResult
+ClientSourceParent::RecvRedirect(const ClientSourceConstructorArgs& aArgs)
+{
+  mService->RemoveSource(this);
+  mArgs = aArgs;
+  mService->AddSource(this);
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
+{
+  // TODO: Validate this against nsIURI and nsIPrincipal
+  // TODO: mark execution ready
+  printf_stderr("### ### ExecutionReady() %s\n", aArgs.url().get());
+  return IPC_OK();
+};
+
+IPCResult
+ClientSourceParent::RecvFreeze()
+{
+  // TODO: impl freeze
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvThaw()
+{
+  // TODO: impl thaw
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvState(const ClientState& aState)
+{
+  // TODO: impl recv state
+  return IPC_OK();
+}
+
+void
+ClientSourceParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+  : mArgs(aArgs)
+  , mService(ClientManagerService::GetOrCreateInstance())
+{
+  mService->AddSource(this);
+}
+
+ClientSourceParent::~ClientSourceParent()
+{
+  mService->RemoveSource(this);
+}
+
+ClientType
+ClientSourceParent::Type() const
+{
+  return mArgs.type();
+}
+
+const PrincipalInfo&
+ClientSourceParent::GetPrincipalInfo() const
+{
+  return mArgs.principal();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceParent_h
+#define _mozilla_dom_ClientSourceParent_h
+
+#include "mozilla/dom/PClientSourceParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerService;
+class ClientSourceConstructorArgs;
+class ClientSourceExecutionReadyArgs;
+
+class ClientSourceParent final : public PClientSourceParent
+{
+  ClientSourceConstructorArgs mArgs;
+  RefPtr<ClientManagerService> mService;
+  nsCString mCreationURL;
+
+  // PClientSourceParent
+  mozilla::ipc::IPCResult
+  RecvWorkerSyncPing() override;
+
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  mozilla::ipc::IPCResult
+  RecvRedirect(const ClientSourceConstructorArgs& aArgs) override;
+
+  mozilla::ipc::IPCResult
+  RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs) override;
+
+  mozilla::ipc::IPCResult
+  RecvFreeze() override;
+
+  mozilla::ipc::IPCResult
+  RecvThaw() override;
+
+  mozilla::ipc::IPCResult
+  RecvState(const ClientState& aState) override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientSourceParent(const ClientSourceConstructorArgs& aArgs);
+  ~ClientSourceParent();
+
+  ClientType
+  Type() const;
+
+  const mozilla::ipc::PrincipalInfo&
+  GetPrincipalInfo() const;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceParent_h
diff --git a/dom/clients/manager/PClientHandle.ipdl b/dom/clients/manager/PClientHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientHandle.ipdl
@@ -0,0 +1,25 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientHandle
+{
+  manager PClientManager;
+
+parent:
+  async Teardown();
+
+  async Controlled(ClientControlledArgs aArgs);
+
+child:
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientManager.ipdl b/dom/clients/manager/PClientManager.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientManager.ipdl
@@ -0,0 +1,31 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PClientHandle;
+include protocol PClientSource;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+sync protocol PClientManager
+{
+  manager PBackground;
+
+  manages PClientHandle;
+  manages PClientSource;
+
+parent:
+  async Teardown();
+
+  async PClientHandle(ClientHandleConstructorArgs aArgs);
+  async PClientSource(ClientSourceConstructorArgs aArgs);
+
+child:
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/PClientSource.ipdl b/dom/clients/manager/PClientSource.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientSource.ipdl
@@ -0,0 +1,30 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+sync protocol PClientSource
+{
+  manager PClientManager;
+
+parent:
+  sync WorkerSyncPing();
+  async Teardown();
+  async Redirect(ClientSourceConstructorArgs aArgs);
+  async ExecutionReady(ClientSourceExecutionReadyArgs aArgs);
+  async Freeze();
+  async Thaw();
+  async State(ClientState aState);
+
+child:
+  async RequestState();
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ReservedClientHelper.cpp b/dom/clients/manager/ReservedClientHelper.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ReservedClientHelper.cpp
@@ -0,0 +1,174 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ReservedClientHelper.h"
+
+#include "nsIAsyncVerifyRedirectCallback.h"
+#include "nsIInterfaceRequestor.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "nsIChannelEventSink.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class ReserveClientHelper final : public nsIInterfaceRequestor
+                                , public nsIChannelEventSink
+{
+  nsCOMPtr<nsIInterfaceRequestor> mOuter;
+
+  ~ReserveClientHelper()
+  {
+  }
+
+  NS_IMETHOD
+  GetInterface(const nsIID & aIID, void **aResultOut) override
+  {
+    if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
+      *aResultOut = static_cast<nsIChannelEventSink*>(this);
+      NS_ADDREF_THIS();
+      return NS_OK;
+    }
+
+    if (mOuter) {
+      return mOuter->GetInterface(aIID, aResultOut);
+    }
+
+    return NS_ERROR_NO_INTERFACE;
+  }
+
+  NS_IMETHOD
+  AsyncOnChannelRedirect(nsIChannel *aOldChannel,
+                         nsIChannel *aNewChannel,
+                         uint32_t aFlags,
+                         nsIAsyncVerifyRedirectCallback *aCallback) override
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    nsCOMPtr<nsILoadInfo> oldLoadInfo;
+    nsresult rv = aOldChannel->GetLoadInfo(getter_AddRefs(oldLoadInfo));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    nsCOMPtr<nsILoadInfo> newLoadInfo;
+    rv = aNewChannel->GetLoadInfo(getter_AddRefs(newLoadInfo));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    rv = nsContentUtils::CheckSameOrigin(aOldChannel, aNewChannel);
+    if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_DOM_BAD_URI)) {
+      return rv;
+    }
+
+    UniquePtr<ClientSource> reservedClient = oldLoadInfo->TakeReservedClient();
+
+    // If its a same-origin redirect we just move our reserved client to the
+    // new channel.
+    if (NS_SUCCEEDED(rv)) {
+      newLoadInfo->GiveReservedClient(Move(reservedClient));
+    }
+
+    // If its a cross-origin redirect then we discard the old reserved client
+    // and create a new one.
+    else {
+      // If CheckSameOrigin() worked, then the security manager must exist.
+      nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+      MOZ_DIAGNOSTIC_ASSERT(ssm);
+
+      nsCOMPtr<nsIPrincipal> principal;
+      rv = ssm->GetChannelResultPrincipal(aNewChannel, getter_AddRefs(principal));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      reservedClient =
+        ClientManager::CreateSource(ClientType::Window, principal);
+
+      newLoadInfo->GiveReservedClient(Move(reservedClient));
+    }
+
+    nsCOMPtr<nsIChannelEventSink> outerSink = do_GetInterface(mOuter);
+    if (outerSink) {
+      return outerSink->AsyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags,
+                                               aCallback);
+    }
+
+    aCallback->OnRedirectVerifyCallback(NS_OK);
+    return NS_OK;
+  }
+
+public:
+  explicit ReserveClientHelper(nsIInterfaceRequestor* aOuter)
+    : mOuter(aOuter)
+  {
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ReserveClientHelper, nsIInterfaceRequestor,
+                                       nsIChannelEventSink);
+
+} // anonymous namespace
+
+nsresult
+ReserveClientForChannel(nsIChannel* aChannel)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIInterfaceRequestor> outer;
+  nsresult rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outer));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+  if (!ssm) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal;
+  rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(principal));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  nsCOMPtr<nsILoadInfo> loadInfo;
+  rv = aChannel->GetLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // Wait to reserve the client until we are reasonably sure this method
+  // will succeed.
+  UniquePtr<ClientSource> reservedClient =
+    ClientManager::CreateSource(ClientType::Window, principal);
+  if (!reservedClient) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<ReserveClientHelper> helper =
+    new ReserveClientHelper(outer);
+
+  // Only set the callbacks helper if we are able to reserve the client
+  // successfully.
+  rv = aChannel->SetNotificationCallbacks(helper);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  // Finally preserve the reserved client on the nsILoadInfo once the
+  // redirect helper has been added to the channel.
+  loadInfo->GiveReservedClient(Move(reservedClient));
+
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ReservedClientHelper.h b/dom/clients/manager/ReservedClientHelper.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ReservedClientHelper.h
@@ -0,0 +1,20 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ReservedClientHelper_h
+#define _mozilla_dom_ReservedClientHelper_h
+
+class nsIChannel;
+
+namespace mozilla {
+namespace dom {
+
+nsresult
+ReserveClientForChannel(nsIChannel* aChannel);
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ReservedClientHelper_h
diff --git a/dom/clients/manager/WorkerClientSourceMainThreadProxy.cpp b/dom/clients/manager/WorkerClientSourceMainThreadProxy.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/WorkerClientSourceMainThreadProxy.cpp
@@ -0,0 +1,25 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WorkerClientSourceMainThreadProxy.h"
+
+namespace mozilla {
+namespace dom {
+
+// static
+UniquePtr<WorkerClientSourceMainThreadProxy>
+WorkerClientSourceMainThreadProxyCreate(WorkerPrivate* aWorkerPrivate,
+                                        UniquePtr<ClientSource>&& aClientSource)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  // TODO
+  return nullptr;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/WorkerClientSourceMainThreadProxy.h b/dom/clients/manager/WorkerClientSourceMainThreadProxy.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/WorkerClientSourceMainThreadProxy.h
@@ -0,0 +1,22 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_WorkerClientSourceMainThreadProxy_h
+#define _mozilla_dom_WorkerClientSourceMainThreadProxy_h
+
+namespace mozilla {
+namespace dom {
+
+class WorkerClientSourceMainThreadProxy final
+{
+public:
+  static UniquePtr<WorkerClientSourceMainThreadProxy>
+  Create(WorkerPrivate* aWorkerPrivate, UniquePtr<ClientSource>&& aClientSource);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_WorkerClientSourceMainThreadProxy_h
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/moz.build
@@ -0,0 +1,55 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'ClientHandle.h',
+  'ClientIPCUtils.h',
+  'ClientManager.h',
+  'ClientManagerActors.h',
+  'ClientSource.h',
+  'ReservedClientHelper.h',
+  'WorkerClientSourceMainThreadProxy.h',
+]
+
+UNIFIED_SOURCES += [
+  'ClientHandle.cpp',
+  'ClientHandleChild.cpp',
+  'ClientHandleParent.cpp',
+  'ClientManager.cpp',
+  'ClientManagerActors.cpp',
+  'ClientManagerChild.cpp',
+  'ClientManagerParent.cpp',
+  'ClientManagerService.cpp',
+  'ClientSource.cpp',
+  'ClientSourceChild.cpp',
+  'ClientSourceParent.cpp',
+  'ReservedClientHelper.cpp',
+  'WorkerClientSourceMainThreadProxy.cpp',
+]
+
+IPDL_SOURCES += [
+  'ClientIPCTypes.ipdlh',
+  'PClientHandle.ipdl',
+  'PClientManager.ipdl',
+  'PClientSource.ipdl',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+  '../../workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/clients/moz.build b/dom/clients/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/moz.build
@@ -0,0 +1,9 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += [
+  'manager',
+]
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -16,16 +16,17 @@
 
 #include "mozilla/Attributes.h"
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessHangMonitorIPC.h"
 #include "mozilla/Unused.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperChild.h"
 #include "mozilla/docshell/OfflineCacheUpdateChild.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ContentBridgeChild.h"
 #include "mozilla/dom/ContentBridgeParent.h"
 #include "mozilla/dom/VideoDecoderManagerChild.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ExternalHelperAppChild.h"
 #include "mozilla/dom/FileCreatorHelper.h"
@@ -958,16 +959,19 @@ void
 ContentChild::InitXPCOM(const XPCOMInitData& aXPCOMInit,
                         const mozilla::dom::ipc::StructuredCloneData& aInitialData)
 {
   SET_PREF_PHASE(pref_initPhase::BEGIN_ALL_PREFS);
   for (unsigned int i = 0; i < aXPCOMInit.prefs().Length(); i++) {
     Preferences::SetPreference(aXPCOMInit.prefs().ElementAt(i));
   }
   SET_PREF_PHASE(pref_initPhase::END_ALL_PREFS);
+
+  ClientManager::Startup();
+
   // Do this as early as possible to get the parent process to initialize the
   // background thread since we'll likely need database information very soon.
   BackgroundChild::Startup();
 
   nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
     new BackgroundChildPrimer();
   if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
     MOZ_CRASH("Failed to create PBackgroundChild!");
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -33,16 +33,17 @@
 #if defined(XP_WIN) && defined(ACCESSIBILITY)
 #include "mozilla/a11y/AccessibleWrap.h"
 #endif
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/DataStorage.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperParent.h"
 #include "mozilla/docshell/OfflineCacheUpdateParent.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/FileCreatorHelper.h"
 #include "mozilla/dom/ExternalHelperAppParent.h"
 #include "mozilla/dom/GetFilesHelper.h"
 #include "mozilla/dom/GeolocationBinding.h"
 #include "mozilla/dom/MemoryReportRequest.h"
@@ -606,16 +607,17 @@ ContentParent::StartUp()
 
   // Note: This reporter measures all ContentParents.
   RegisterStrongMemoryReporter(new ContentParentsMemoryReporter());
 
   mozilla::dom::time::InitializeDateCacheCleaner();
 
   BlobParent::Startup(BlobParent::FriendKey());
 
+  ClientManager::Startup();
   BackgroundChild::Startup();
 
   // Try to preallocate a process that we can use later.
   PreallocatedProcessManager::AllocateAfterDelay();
 
   sDisableUnsafeCPOWWarnings = PR_GetEnv("DISABLE_UNSAFE_CPOW_WARNINGS");
 
 #if defined(XP_LINUX) && defined(MOZ_CONTENT_SANDBOX)
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -43,16 +43,17 @@ DIRS += ['interfaces/' + i for i in inte
 DIRS += [
     'animation',
     'base',
     'bindings',
     'battery',
     'browser-element',
     'cache',
     'canvas',
+    'clients',
     'commandhandler',
     'crypto',
     'devicestorage',
     'encoding',
     'events',
     'fetch',
     'file',
     'filehandle',
diff --git a/dom/webidl/Clients.webidl b/dom/webidl/Clients.webidl
--- a/dom/webidl/Clients.webidl
+++ b/dom/webidl/Clients.webidl
@@ -26,11 +26,13 @@ dictionary ClientQueryOptions {
   boolean includeUncontrolled = false;
   ClientType type = "window";
 };
 
 enum ClientType {
   "window",
   "worker",
   "sharedworker",
+  // https://github.com/w3c/ServiceWorker/issues/1036
+  "serviceworker",
   "all"
 };
 
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -46,16 +46,17 @@
 #include "mozilla/LoadContext.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Cache.h"
 #include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/dom/ChannelInfo.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/InternalResponse.h"
 #include "mozilla/dom/nsCSPService.h"
 #include "mozilla/dom/nsCSPUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
@@ -260,16 +261,17 @@ struct ScriptLoadInfo
   // resolution.
   RefPtr<Promise> mCachePromise;
 
   // The reader stream the cache entry should be filled from, for those cases
   // when we're going to have an mCachePromise.
   nsCOMPtr<nsIInputStream> mCacheReadStream;
 
   nsCOMPtr<nsIChannel> mChannel;
+  Maybe<ClientInfo> mReservedClientInfo;
   char16_t* mScriptTextBuf;
   size_t mScriptTextLength;
 
   nsresult mLoadResult;
   bool mLoadingFinished;
   bool mExecutionScheduled;
   bool mExecutionResult;
 
@@ -956,16 +958,22 @@ private:
     // We don't care about progress so just use the simple stream loader for
     // OnStreamComplete notification only.
     nsCOMPtr<nsIStreamLoader> loader;
     rv = NS_NewStreamLoader(getter_AddRefs(loader), listener);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
 
+    if (IsMainWorkerScript()) {
+      MOZ_DIAGNOSTIC_ASSERT(loadInfo.mReservedClientInfo.isSome());
+      nsCOMPtr<nsILoadInfo> chanLoadInfo = channel->GetLoadInfo();
+      chanLoadInfo->SetReservedClientInfo(loadInfo.mReservedClientInfo.ref());
+    }
+
     if (loadInfo.mCacheStatus != ScriptLoadInfo::ToBeCached) {
       rv = channel->AsyncOpen2(loader);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     } else {
       nsCOMPtr<nsIOutputStream> writer;
 
@@ -2216,16 +2224,20 @@ LoadMainScript(WorkerPrivate* aWorkerPri
                ErrorResult& aRv)
 {
   nsTArray<ScriptLoadInfo> loadInfos;
 
   ScriptLoadInfo* info = loadInfos.AppendElement();
   info->mURL = aScriptURL;
   info->mLoadFlags = aWorkerPrivate->GetLoadFlags();
 
+  // We are loading the main script, so the worker's Client must be
+  // reserved.
+  info->mReservedClientInfo.emplace(aWorkerPrivate->GetClientInfo());
+
   LoadAllScripts(aWorkerPrivate, loadInfos, true, aWorkerScriptType, aRv);
 }
 
 void
 Load(WorkerPrivate* aWorkerPrivate,
      const nsTArray<nsString>& aScriptURLs, WorkerScriptType aWorkerScriptType,
      ErrorResult& aRv)
 {
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -30,16 +30,18 @@
 #include "jsapi.h"
 
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/ErrorNames.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/DOMError.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/NotificationEvent.h"
@@ -2200,16 +2202,28 @@ ServiceWorkerManager::StartControllingAD
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(aDoc);
 
   aRegistration->StartControllingADocument();
   mControlledDocuments.Put(aDoc, aRegistration);
   if (!aDocumentId.IsEmpty()) {
     aDoc->SetId(aDocumentId);
   }
+  ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
+  nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
+  if (activeWorker && innerWindow) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref());
+      if (clientHandle) {
+        clientHandle->SetControlled(activeWorker->Scope(), activeWorker->ID());
+      }
+    }
+  }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
 }
 
 void
 ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
 {
   aRegistration->StopControllingADocument();
   if (aRegistration->IsControllingDocuments() || !aRegistration->IsIdle()) {
@@ -2507,16 +2521,31 @@ ServiceWorkerManager::DispatchFetchEvent
     // before we get to this point.  Therefore we must handle a nullptr
     // active worker here.
     serviceWorker = registration->GetActive();
     if (!serviceWorker) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
+    // If there is a reserved client it should be marked as controlled before
+    // the FetchEvent.
+    nsCOMPtr<nsILoadInfo> loadInfo = internalChannel->GetLoadInfo();
+    if (loadInfo) {
+      const Maybe<ClientInfo>& clientInfo = loadInfo->GetReservedClientInfo();
+      if (clientInfo.isSome()) {
+        RefPtr<ClientHandle> clientHandle =
+          ClientManager::CreateHandle(clientInfo.ref());
+        if (clientHandle) {
+          clientHandle->SetControlled(serviceWorker->Scope(),
+                                      serviceWorker->ID());
+        }
+      }
+    }
+
     AddNavigationInterception(serviceWorker->Scope(), aChannel);
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
diff --git a/dom/workers/WorkerHolderToken.cpp b/dom/workers/WorkerHolderToken.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.cpp
@@ -0,0 +1,99 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WorkerHolderToken.h"
+
+#include "WorkerPrivate.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+// static
+already_AddRefed<WorkerHolderToken>
+WorkerHolderToken::Create(WorkerPrivate* aWorkerPrivate, Status aShutdownStatus)
+{
+  MOZ_ASSERT(aWorkerPrivate);
+
+  RefPtr<WorkerHolderToken> workerHolder =
+    new WorkerHolderToken(aShutdownStatus);
+
+  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, aShutdownStatus))) {
+    return nullptr;
+  }
+
+  return workerHolder.forget();
+}
+
+void
+WorkerHolderToken::AddListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+
+  // Allow an actor to be added after we've entered the Notifying case.  We
+  // can't stop the actor creation from racing with out destruction of the
+  // other actors and we need to wait for this extra one to close as well.
+  // Signal it should destroy itself right away.
+  if (mShuttingDown) {
+    aListener->WorkerShuttingDown();
+  }
+}
+
+void
+WorkerHolderToken::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+
+  DebugOnly<bool> removed = mListenerList.RemoveElement(aListener);
+
+  MOZ_ASSERT(removed);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+}
+
+bool
+WorkerHolderToken::IsShuttingDown() const
+{
+  return mShuttingDown;
+}
+
+WorkerHolderToken::WorkerHolderToken(Status aShutdownStatus)
+  : mShutdownStatus(aShutdownStatus)
+  , mShuttingDown(false)
+{
+}
+
+WorkerHolderToken::~WorkerHolderToken()
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+bool
+WorkerHolderToken::Notify(Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+
+  // When the service worker thread is stopped we will get Terminating,
+  // but nothing higher than that.  We must shut things down at Terminating.
+  if (aStatus < mShutdownStatus || mShuttingDown) {
+    return true;
+  }
+
+  mShuttingDown = true;
+
+  // Start the asynchronous destruction of our actors.  These will call back
+  // into RemoveActor() once the actor is destroyed.
+  for (uint32_t i = 0; i < mListenerList.Length(); ++i) {
+    mListenerList[i]->WorkerShuttingDown();
+  }
+
+  return true;
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/WorkerHolderToken.h b/dom/workers/WorkerHolderToken.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_WorkerHolderToken_h
+#define mozilla_dom_workers_WorkerHolderToken_h
+
+#include "nsISupportsImpl.h"
+#include "nsTArray.h"
+#include "WorkerHolder.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+class WorkerPrivate;
+
+class WorkerHolderToken final : public WorkerHolder
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void
+    WorkerShuttingDown() = 0;
+  };
+
+  static already_AddRefed<WorkerHolderToken>
+  Create(workers::WorkerPrivate* aWorkerPrivate, Status aShutdownStatus);
+
+  void
+  AddListener(Listener* aListener);
+
+  void
+  RemoveListener(Listener* aListener);
+
+  bool
+  IsShuttingDown() const;
+
+private:
+  explicit WorkerHolderToken(Status aShutdownStatus);
+
+  ~WorkerHolderToken();
+
+  // WorkerHolder methods
+  virtual bool
+  Notify(workers::Status aStatus) override;
+
+  nsTArray<Listener*> mListenerList;
+  const Status mShutdownStatus;
+  bool mShuttingDown;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(WorkerHolderToken)
+};
+
+END_WORKERS_NAMESPACE
+
+#endif // mozilla_dom_workers_WorkerHolderToken_h
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -42,16 +42,18 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/ContentEvents.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/Likely.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/Move.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Console.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/ErrorEventBinding.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/MessageEvent.h"
@@ -577,16 +579,18 @@ private:
   // run we have not yet done our load so don't know things like our final
   // principal and whatnot.
 
   virtual bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
+    aWorkerPrivate->ReserveClient();
+
     ErrorResult rv;
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL, WorkerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
     // return false and don't SetWorkerScriptExecutedSuccessfully() in that
     // case, but don't throw anything on aCx.  The idea is to not dispatch error
     // events if our load is canceled with that error code.
     if (rv.ErrorCodeIs(NS_BINDING_ABORTED)) {
@@ -647,16 +651,18 @@ private:
 
     WorkerDebuggerGlobalScope* globalScope =
       aWorkerPrivate->CreateDebuggerGlobalScope(aCx);
     if (!globalScope) {
       NS_WARNING("Failed to make global!");
       return false;
     }
 
+    aWorkerPrivate->ReserveClient();
+
     JS::Rooted<JSObject*> global(aCx, globalScope->GetWrapper());
 
     ErrorResult rv;
     JSAutoCompartment ac(aCx, global);
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL,
                                  DebuggerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
@@ -4604,30 +4610,35 @@ WorkerPrivate::Constructor(JSContext* aC
   }
 
   // Only service and shared workers can have names.
   MOZ_ASSERT_IF(aWorkerType != WorkerTypeDedicated,
                 !aWorkerName.IsVoid());
   MOZ_ASSERT_IF(aWorkerType == WorkerTypeDedicated,
                 aWorkerName.IsEmpty());
 
+  NS_ConvertUTF16toUTF8 scriptURL(aScriptURL);
+
   Maybe<WorkerLoadInfo> stackLoadInfo;
   if (!aLoadInfo) {
     stackLoadInfo.emplace();
 
+    printf_stderr("### ### Calling GetLoadInfo() %s\n", scriptURL.get());
     nsresult rv = GetLoadInfo(aCx, nullptr, parent, aScriptURL,
                               aIsChromeWorker, InheritLoadGroup,
                               aWorkerType, stackLoadInfo.ptr());
     aRv.MightThrowJSException();
     if (NS_FAILED(rv)) {
       scriptloader::ReportLoadError(aRv, rv, aScriptURL);
       return nullptr;
     }
 
     aLoadInfo = stackLoadInfo.ptr();
+  } else {
+    printf_stderr("### ### Not calling GetLoadInfo() %s\n", scriptURL.get());
   }
 
   // NB: This has to be done before creating the WorkerPrivate, because it will
   // attempt to use static variables that are initialized in the RuntimeService
   // constructor.
   RuntimeService* runtimeService;
 
   if (!parent) {
@@ -4990,16 +5001,18 @@ WorkerPrivate::DoRunLoop(JSContext* aCx)
   MOZ_ASSERT(jsapi.cx() == aCx);
 
   EnableMemoryReporter();
 
   InitializeGCTimers();
 
   Maybe<JSAutoCompartment> workerCompartment;
 
+  // TODO: Set Client ExecutionReady
+
   for (;;) {
     Status currentStatus, previousStatus;
     bool debuggerRunnablesPending = false;
     bool normalRunnablesPending = false;
 
     {
       MutexAutoLock lock(mMutex);
       previousStatus = mStatus;
@@ -5043,16 +5056,18 @@ WorkerPrivate::DoRunLoop(JSContext* aCx)
       }
 
       // If we're supposed to die then we should exit the loop.
       if (currentStatus == Killing) {
         // Flush uncaught rejections immediately, without
         // waiting for a next tick.
         PromiseDebugging::FlushUncaughtRejections();
 
+        mClientSource = nullptr;
+
         ShutdownGCTimers();
 
         DisableMemoryReporter();
 
         {
           MutexAutoLock lock(mMutex);
 
           mStatus = Dead;
@@ -5203,16 +5218,65 @@ WorkerPrivate::DispatchToMainThread(alre
 
 nsIEventTarget*
 WorkerPrivate::ControlEventTarget()
 {
   return mWorkerControlEventTarget;
 }
 
 void
+WorkerPrivate::ReserveClient()
+{
+  AssertIsOnWorkerThread();
+  MOZ_ASSERT(!mClientSource);
+
+  ClientType type;
+  switch(Type()) {
+    case WorkerTypeDedicated:
+      type = ClientType::Worker;
+      break;
+    case WorkerTypeShared:
+      type = ClientType::Sharedworker;
+      break;
+    case WorkerTypeService:
+      type = ClientType::Serviceworker;
+      break;
+    default:
+      MOZ_CRASH("unknown worker type!");
+  }
+
+  mClientSource = ClientManager::CreateSource(type, GetPrincipalInfo());
+
+  // Shortly after the client is reserved we will try loading the main script
+  // for the worker.  This may get intercepted by the ServiceWorkerManager
+  // which will then try to create a ClientHandle.  Its actually possible for
+  // the main thread to create this ClientHandle before our IPC message creating
+  // the ClientSource completes.  To avoid this race we synchronously ping our
+  // parent Client actor here.  This ensure the worker Client is created in
+  // the parent before the main thread might try reaching it with a
+  // ClientHandle.
+  //
+  // An alternative solution would have been to handle the out-of-order operations
+  // on the parent side.  We could have created a small window where we allow
+  // ClientHandle objects to exist without a ClientSource.  We would then time
+  // out these handles if they stayed orphaned for too long.  This approach would
+  // be much more complex, but also avoid this extra bit of latency when starting
+  // workers.
+  mClientSource->WorkerSyncPing(this);
+}
+
+const ClientInfo&
+WorkerPrivate::GetClientInfo() const
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  return mClientSource->Info();
+}
+
+void
 WorkerPrivate::InitializeGCTimers()
 {
   AssertIsOnWorkerThread();
 
   // We need a timer for GC. The basic plan is to run a non-shrinking GC
   // periodically (PERIODIC_GC_TIMER_DELAY_SEC) while the worker is running.
   // Once the worker goes idle we set a short (IDLE_GC_TIMER_DELAY_SEC) timer to
   // run a shrinking GC. If the worker receives more messages then the short
@@ -5544,16 +5608,18 @@ WorkerPrivate::ClearDebuggerEventQueue()
 
 bool
 WorkerPrivate::FreezeInternal()
 {
   AssertIsOnWorkerThread();
 
   NS_ASSERTION(!mFrozen, "Already frozen!");
 
+  mClientSource->Freeze();
+
   mFrozen = true;
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Freeze(nullptr);
   }
 
   return true;
 }
@@ -5565,16 +5631,19 @@ WorkerPrivate::ThawInternal()
 
   NS_ASSERTION(mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Thaw(nullptr);
   }
 
   mFrozen = false;
+
+  mClientSource->Thaw();
+
   return true;
 }
 
 void
 WorkerPrivate::TraverseTimeouts(nsCycleCollectionTraversalCallback& cb)
 {
   for (uint32_t i = 0; i < mTimeouts.Length(); ++i) {
     TimeoutInfo* tmp = mTimeouts[i];
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -57,16 +57,17 @@ template<class T> class nsMainThreadPtrH
 
 namespace JS {
 struct RuntimeStats;
 } // namespace JS
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
+class ClientSource;
 class Function;
 class MessagePort;
 class MessagePortIdentifier;
 class PromiseNativeHandler;
 class StructuredCloneHolder;
 class WorkerDebuggerGlobalScope;
 class WorkerGlobalScope;
 } // namespace dom
@@ -1026,16 +1027,17 @@ class WorkerPrivate : public WorkerPriva
   // fired on the main thread if the worker script fails to load
   nsCOMPtr<nsIRunnable> mLoadFailedRunnable;
 
   JS::UniqueChars mDefaultLocale; // nulled during worker JSContext init
   TimeStamp mKillTime;
   uint32_t mErrorHandlerRecursionCount;
   uint32_t mNextTimeoutId;
   Status mStatus;
+  UniquePtr<ClientSource> mClientSource;
   bool mFrozen;
   bool mTimerRunning;
   bool mRunningExpiredTimeouts;
   bool mPendingEventQueueClearing;
   bool mCancelAllPendingRunnables;
   bool mPeriodicGCTimerRunning;
   bool mIdleGCTimerRunning;
   bool mWorkerScriptExecutedSuccessfully;
@@ -1450,16 +1452,22 @@ public:
                        uint32_t aFlags = NS_DISPATCH_NORMAL);
 
   // Get an event target that will dispatch runnables as control runnables on
   // the worker thread.  Implement nsICancelableRunnable if you wish to take
   // action on cancelation.
   nsIEventTarget*
   ControlEventTarget();
 
+  void
+  ReserveClient();
+
+  const ClientInfo&
+  GetClientInfo() const;
+
 private:
   WorkerPrivate(WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsACString& aSharedWorkerName,
                 WorkerLoadInfo& aLoadInfo);
 
   bool
   MayContinueRunning()
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -35,16 +35,17 @@ EXPORTS.mozilla.dom.workers += [
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
     'ServiceWorkerClient.h',
     'ServiceWorkerClients.h',
     'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
+    'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
     'nsIWorkerDebugger.idl',
     'nsIWorkerDebuggerManager.idl',
 ]
@@ -75,16 +76,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
+    'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
diff --git a/dom/xslt/base/moz.build b/dom/xslt/base/moz.build
--- a/dom/xslt/base/moz.build
+++ b/dom/xslt/base/moz.build
@@ -8,16 +8,18 @@ UNIFIED_SOURCES += [
     'txDouble.cpp',
     'txExpandedName.cpp',
     'txExpandedNameMap.cpp',
     'txList.cpp',
     'txNamespaceMap.cpp',
     'txURIUtils.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '..',
     '../xml',
     '../xpath',
     '../xslt',
 ]
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/xul/moz.build b/dom/xul/moz.build
--- a/dom/xul/moz.build
+++ b/dom/xul/moz.build
@@ -38,16 +38,18 @@ XPIDL_SOURCES += [
 ]
 
 XPIDL_MODULE = 'xul'
 
 UNIFIED_SOURCES += [
     'nsXULControllers.cpp',
 ]
 
+include('/ipc/chromium/chromium-config.mozbuild')
+
 LOCAL_INCLUDES += [
     '/docshell/base',
     '/dom/base',
     '/dom/html',
     '/dom/xbl',
     '/dom/xml',
     '/dom/xul/templates',
     '/layout/base',
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -10,16 +10,17 @@
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PFileSystemRequestChild.h"
 #include "mozilla/dom/FileSystemTaskBase.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
@@ -492,16 +493,28 @@ BackgroundChildImpl::AllocPGamepadTestCh
 bool
 BackgroundChildImpl::DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor)
 {
   MOZ_ASSERT(aActor);
   delete static_cast<dom::GamepadTestChannelChild*>(aActor);
   return true;
 }
 
+mozilla::dom::PClientManagerChild*
+BackgroundChildImpl::AllocPClientManagerChild()
+{
+  return mozilla::dom::AllocClientManagerChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPClientManagerChild(mozilla::dom::PClientManagerChild* aActor)
+{
+  return mozilla::dom::DeallocClientManagerChild(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 mozilla::ipc::IPCResult
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -173,16 +173,22 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelChild(PGamepadEventChannelChild* aActor) override;
 
   virtual PGamepadTestChannelChild*
   AllocPGamepadTestChannelChild() override;
 
   virtual bool
   DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor) override;
+
+  virtual PClientManagerChild*
+  AllocPClientManagerChild() override;
+
+  virtual bool
+  DeallocPClientManagerChild(PClientManagerChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -9,16 +9,17 @@
 #include "BroadcastChannelParent.h"
 #include "FileDescriptorSetParent.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasParent.h"
 #endif
 #include "mozilla/media/MediaParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/FileSystemBase.h"
 #include "mozilla/dom/FileSystemRequestParent.h"
 #include "mozilla/dom/GamepadEventChannelParent.h"
 #include "mozilla/dom/GamepadTestChannelParent.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/PGamepadEventChannelParent.h"
 #include "mozilla/dom/PGamepadTestChannelParent.h"
@@ -932,16 +933,28 @@ bool
 BackgroundParentImpl::DeallocPGamepadTestChannelParent(dom::PGamepadTestChannelParent *aActor)
 {
   MOZ_ASSERT(aActor);
   RefPtr<dom::GamepadTestChannelParent> parent =
     dont_AddRef(static_cast<dom::GamepadTestChannelParent*>(aActor));
   return true;
 }
 
+mozilla::dom::PClientManagerParent*
+BackgroundParentImpl::AllocPClientManagerParent()
+{
+  return mozilla::dom::AllocClientManagerParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPClientManagerParent(mozilla::dom::PClientManagerParent* aActor)
+{
+  return mozilla::dom::DeallocClientManagerParent(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -201,14 +201,20 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelParent(PGamepadEventChannelParent *aActor) override;
 
   virtual PGamepadTestChannelParent*
   AllocPGamepadTestChannelParent() override;
 
   virtual bool
   DeallocPGamepadTestChannelParent(PGamepadTestChannelParent* aActor) override;
+
+  virtual PClientManagerParent*
+  AllocPClientManagerParent() override;
+
+  virtual bool
+  DeallocPClientManagerParent(PClientManagerParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -6,16 +6,17 @@ include protocol PAsmJSCacheEntry;
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundIndexedDBUtils;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
+include protocol PClientManager;
 include protocol PFileDescriptorSet;
 include protocol PFileSystemRequest;
 include protocol PGamepadEventChannel;
 include protocol PGamepadTestChannel;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PQuota;
 include protocol PSendStream;
@@ -49,16 +50,17 @@ sync protocol PBackground
   manages PBackgroundIDBFactory;
   manages PBackgroundIndexedDBUtils;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
+  manages PClientManager;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
   manages PGamepadEventChannel;
   manages PGamepadTestChannel;
   manages PMessagePort;
   manages PCameras;
   manages PQuota;
   manages PSendStream;
@@ -103,16 +105,18 @@ parent:
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
   async PGamepadEventChannel();
 
   async PGamepadTestChannel();
 
+  async PClientManager();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
   async PFileDescriptorSet(FileDescriptor fd);
diff --git a/ipc/ipdl/sync-messages.ini b/ipc/ipdl/sync-messages.ini
--- a/ipc/ipdl/sync-messages.ini
+++ b/ipc/ipdl/sync-messages.ini
@@ -1004,8 +1004,10 @@ description =
 [PPrinting::SavePrintSettings]
 description =
 [PHandlerService::FillHandlerInfo]
 description =
 [PHandlerService::Exists]
 description =
 [PHandlerService::GetTypeFromExtension]
 description =
+[PClientSource::WorkerSyncPing]
+description = Synchronous ping allowing worker thread to confirm actor is created.  Necessary to avoid racing with ClientHandle actors on main thread.
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/LoadInfo.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozIThirdPartyUtil.h"
 #include "nsFrameLoader.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIDocShell.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIFrameLoader.h"
@@ -272,16 +273,17 @@ LoadInfo::LoadInfo(nsPIDOMWindowOuter* a
   mOriginAttributes.Inherit(attrs);
 }
 
 LoadInfo::LoadInfo(const LoadInfo& rhs)
   : mLoadingPrincipal(rhs.mLoadingPrincipal)
   , mTriggeringPrincipal(rhs.mTriggeringPrincipal)
   , mPrincipalToInherit(rhs.mPrincipalToInherit)
   , mSandboxedLoadingPrincipal(rhs.mSandboxedLoadingPrincipal)
+  // by default do not propagate the reserved Client
   , mLoadingContext(rhs.mLoadingContext)
   , mSecurityFlags(rhs.mSecurityFlags)
   , mInternalContentPolicyType(rhs.mInternalContentPolicyType)
   , mTainting(rhs.mTainting)
   , mUpgradeInsecureRequests(rhs.mUpgradeInsecureRequests)
   , mVerifySignedContent(rhs.mVerifySignedContent)
   , mEnforceSRI(rhs.mEnforceSRI)
   , mForceInheritPrincipalDropped(rhs.mForceInheritPrincipalDropped)
@@ -888,16 +890,42 @@ LoadInfo::SetIsPreflight()
 }
 
 void
 LoadInfo::SetUpgradeInsecureRequests()
 {
   mUpgradeInsecureRequests = true;
 }
 
+void
+LoadInfo::GiveReservedClient(UniquePtr<ClientSource>&& aClientSource)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aClientSource);
+  mReservedClient = Move(aClientSource);
+  SetReservedClientInfo(mReservedClient->Info());
+}
+
+UniquePtr<ClientSource>
+LoadInfo::TakeReservedClient()
+{
+  return Move(mReservedClient);
+}
+
+void
+LoadInfo::SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo)
+{
+  mReservedClientInfo.emplace(aClientInfo);
+}
+
+const Maybe<ClientInfo>&
+LoadInfo::GetReservedClientInfo() const
+{
+  return mReservedClientInfo;
+}
+
 NS_IMETHODIMP
 LoadInfo::GetIsPreflight(bool* aIsPreflight)
 {
   *aIsPreflight = mIsPreflight;
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -10,16 +10,17 @@
 #include "nsIContentPolicy.h"
 #include "nsILoadInfo.h"
 #include "nsIPrincipal.h"
 #include "nsIWeakReferenceUtils.h" // for nsWeakPtr
 #include "nsIURI.h"
 #include "nsTArray.h"
 
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 
 class nsINode;
 class nsPIDOMWindowOuter;
 
 namespace mozilla {
 
 namespace dom {
 class XMLHttpRequestMainThread;
@@ -70,16 +71,29 @@ public:
   // creates a copy of the loadinfo which is appropriate to use for a
   // separate request. I.e. not for a redirect or an inner channel, but
   // when a separate request is made with the same security properties.
   already_AddRefed<nsILoadInfo> CloneForNewRequest() const;
 
   void SetIsPreflight();
   void SetUpgradeInsecureRequests();
 
+  // c++ specific methods defined in nsILoadInfo
+  void
+  GiveReservedClient(mozilla::UniquePtr<mozilla::dom::ClientSource>&& aClientSource) override;
+
+  mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeReservedClient() override;
+
+  void
+  SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
+
+  const Maybe<mozilla::dom::ClientInfo>&
+  GetReservedClientInfo() const override;
+
 private:
   // private constructor that is only allowed to be called from within
   // HttpChannelParent and FTPChannelParent declared as friends undeneath.
   // In e10s we can not serialize nsINode, hence we store the innerWindowID.
   // Please note that aRedirectChain uses swapElements.
   LoadInfo(nsIPrincipal* aLoadingPrincipal,
            nsIPrincipal* aTriggeringPrincipal,
            nsIPrincipal* aPrincipalToInherit,
@@ -123,16 +137,18 @@ private:
   void SetIncludeCookiesSecFlag();
   friend class mozilla::dom::XMLHttpRequestMainThread;
 
   // if you add a member, please also update the copy constructor
   nsCOMPtr<nsIPrincipal>           mLoadingPrincipal;
   nsCOMPtr<nsIPrincipal>           mTriggeringPrincipal;
   nsCOMPtr<nsIPrincipal>           mPrincipalToInherit;
   nsCOMPtr<nsIPrincipal>           mSandboxedLoadingPrincipal;
+  UniquePtr<mozilla::dom::ClientSource> mReservedClient;
+  Maybe<mozilla::dom::ClientInfo>  mReservedClientInfo;
   nsWeakPtr                        mLoadingContext;
   nsSecurityFlags                  mSecurityFlags;
   nsContentPolicyType              mInternalContentPolicyType;
   LoadTainting                     mTainting;
   bool                             mUpgradeInsecureRequests;
   bool                             mVerifySignedContent;
   bool                             mEnforceSRI;
   bool                             mForceInheritPrincipalDropped;
diff --git a/netwerk/base/nsILoadInfo.idl b/netwerk/base/nsILoadInfo.idl
--- a/netwerk/base/nsILoadInfo.idl
+++ b/netwerk/base/nsILoadInfo.idl
@@ -10,18 +10,27 @@
 interface nsIDOMDocument;
 interface nsINode;
 interface nsIPrincipal;
 
 %{C++
 #include "nsTArray.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/LoadTainting.h"
+#include "mozilla/UniquePtr.h"
 
 class nsCString;
+
+namespace mozilla {
+namespace dom {
+class ClientInfo;
+class ClientSource;
+} // namespace dom
+} // namespace mozilla
+
 %}
 
 [ref] native const_nsIPrincipalArray(const nsTArray<nsCOMPtr<nsIPrincipal>>);
 native OriginAttributes(mozilla::OriginAttributes);
 [ref] native const_OriginAttributesRef(const mozilla::OriginAttributes);
 [ref] native StringArrayRef(const nsTArray<nsCString>);
 
 typedef unsigned long nsSecurityFlags;
@@ -749,9 +758,24 @@ interface nsILoadInfo : nsISupports
 
   /**
    * Returns the null principal of the resulting resource if the SEC_SANDBOXED
    * flag is set.  Otherwise returns null.  This is used by
    * GetChannelResultPrincipal() to ensure that the same null principal object
    * is returned every time.
    */
   [noscript] readonly attribute nsIPrincipal sandboxedLoadingPrincipal;
+
+%{ C++
+  // TODO: rename this to be clear its the window-only client source
+  virtual void
+  GiveReservedClient(mozilla::UniquePtr<mozilla::dom::ClientSource>&& aClientSource) = 0;
+
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeReservedClient() = 0;
+
+  virtual void
+  SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
+
+  virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
+  GetReservedClientInfo() const = 0;
+%}
 };
