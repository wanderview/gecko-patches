# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e4da5d17fc9c7752a58a8117f940f6426197e7dc

diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -39,17 +39,20 @@ function ReadableStream(underlyingSource
   // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
   // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
   // Step 11. ReturnIfAbrupt(startResult).
   let startResult = InvokeOrNoop(underlyingSource, "start",
     UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
   // Step 12. Resolve startResult as a promise:
-  GetPromiseCtor().resolve(startResult).then(() => {
+  DumpMessage('### ### calling Promise_static_resolve()');
+  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
+  DumpMessage('### ### calling Promise_then()');
+  callFunction(Promise_then, p, () => {
 this._log += 'resolved ' + startResult;
     // Set this@[[started]] to true.
     UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
     // Perform RequestReadableStreamPull(this).
     RequestReadableStreamPull(this);
   }, (r) => {
     // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
     if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
@@ -68,25 +71,25 @@ function ReadableStream_locked() {
 }
 
 // Streams spec, 3.2.4.2. cancel(reason)
 function ReadableStream_cancel(reason) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
   if (IsReadableStreamLocked(this)) {
     try {
       ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
 function ReadableStream_getReader() {
@@ -199,75 +202,76 @@ function ReadableStreamReader(stream) {
   switch (streamState) {
     case READABLESTREAM_READABLE_STATE:
       let deferred = CreateDeferred();
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
       break;
     case READABLESTREAM_CLOSED_STATE:
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-        GetPromiseCtor().resolve(undefined));
+        callFunction(Promise_static_resolve, GetPromiseCtor(), undefined));
       break;
     case READABLESTREAM_ERRORED_STATE:
       UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-        GetPromiseCtor().reject(UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
+        callFunction(Promise_static_reject, GetPromiseCtor(),
+                     UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
       break;
     default:
       ThrowSomething("Error", "Unexpected stream state");
       break;
   }
 }
 
 // Streams spec, 3.4.4.1. get closed
 function ReadableStreamReader_closed() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "closed", typeof this);
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
   return UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
 }
 
 // Streams spec, 3.4.4.2. cancel(reason)
 function ReadableStreamReader_cancel(reason) {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "cancel", typeof this);
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
   let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   if (ownerReadableStream === undefined) {
     try {
       ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
   return CancelReadableStream(ownerReadableStream, reason);
 }
 
 // Streams spec, 3.4.4.3. read()
 function ReadableStreamReader_read() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
     try {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "read", typeof this);
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
   let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   if (ownerReadableStream === undefined) {
     try {
       ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
     } catch (e) {
-      return GetPromiseCtor().reject(e);
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
   return ReadFromReadableStreamReader(this);
 }
 
 // Streams spec, 3.4.4.4. releaseLock()
 function ReadableStreamReader_releaseLock() {
   if (!IsObject(this) || !IsReadableStreamReader(this)) {
@@ -289,17 +293,17 @@ function ReadableStreamReader_releaseLoc
     releaseLockException = e;
   }
   if (ownerReadableStreamState === READABLESTREAM_READABLE_STATE) {
     let deferred = UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
     UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
     deferred.reject(releaseLockException);
   } else {
     UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
-      GetPromiseCtor().reject(releaseLockException));
+      callFunction(Promise_static_reject, GetPromiseCtor(), releaseLockException));
   }
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_READER_SLOT, undefined);
   UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, undefined);
 }
 
 
 // Streams spec, 3.5.1. AcquireReadableStreamReader ( stream )
 function AcquireReadableStreamReader(stream) {
@@ -307,20 +311,21 @@ function AcquireReadableStreamReader(str
   return new ReadableStreamReaderCtor(stream);
 }
 
 // Streams spec, 3.5.2. CancelReadableStream ( stream, reason )
 function CancelReadableStream(stream, reason) {
   UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
   let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
   if (streamState === READABLESTREAM_CLOSED_STATE) {
-    return GetPromiseCtor().resolve(undefined);
+    return callFunction(Promise_static_resolve, GetPromiseCtor(), undefined);
   }
   if (streamState === READABLESTREAM_ERRORED_STATE) {
-    return GetPromiseCtor().reject(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
+    return callFunction(Promise_static_reject, GetPromiseCtor(),
+      UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
   }
   UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
   FinishClosingReadableStream(stream);
   let sourceCancelPromise = PromiseInvokeOrNoop(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT), "cancel", reason);
   return sourceCancelPromise.then(() => undefined);
 }
 
 // Streams spec, 3.5.3. CloseReadableStream ( stream )
@@ -447,17 +452,18 @@ function ReadFromReadableStreamReader(re
   if (queue.length !== 0) {
     let chunk = DequeueValue(queue);
     if (UnsafeGetBooleanFromReservedSlot(ownerReadableStream, READABLESTREAM_CLOSE_REQUESTED_SLOT) &&
         queue.length === 0) {
       FinishClosingReadableStream(ownerReadableStream);
     } else {
       RequestReadableStreamPull(ownerReadableStream);
     }
-    return GetPromiseCtor().resolve(CreateIterResultObject(chunk, false));
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        CreateIterResultObject(chunk, false));
   } else {
     let readRequestDeferred = CreateDeferred();
     let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
     callFunction(std_Array_push, readRequests, readRequestDeferred);
     RequestReadableStreamPull(ownerReadableStream);
     return readRequestDeferred.promise;
   }
 }
@@ -472,17 +478,17 @@ function RequestReadableStreamPull(strea
     UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, true);
     return;
   }
   UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, true);
   let pullPromise = PromiseInvokeOrNoop(
     UnsafeGetReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT),
     "pull",
     UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT));
-  pullPromise.then(() => {
+  callFunction(Promise_then, pullPromise, () => {
     UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, false);
     if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT)) {
       UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, false);
       RequestReadableStreamPull(stream);
     }
   }, (e) => {
     if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
       ErrorReadableStream(stream, e);
@@ -555,19 +561,19 @@ function InvokeOrNoop(obj, methodName, a
   return callContentFunction(method, obj, arg);
 }
 
 // Streams spec, 6.4.6. PromiseInvokeOrNoop ( O, P, args )
 // FIXME per spec
 function PromiseInvokeOrNoop(obj, methodName, arg) {
   try {
     let result = InvokeOrNoop(obj, methodName, arg);
-    return GetPromiseCtor().resolve(result);
+    return callFunction(Promise_static_resolve, GetPromiseCtor(), result);
   } catch (e) {
-    return GetPromiseCtor().reject(e);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), e);
   }
 }
 
 // Streams spec, 6.4.7. ValidateAndNormalizeQueuingStrategy ( size, highWaterMark )
 function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
   if (size !== undefined && !IsCallable(size)) {
     ThrowTypeError(JSMSG_NOT_FUNCTION, DecompileArg(0, size));
   }
diff --git a/js/src/vm/Interpreter.cpp b/js/src/vm/Interpreter.cpp
--- a/js/src/vm/Interpreter.cpp
+++ b/js/src/vm/Interpreter.cpp
@@ -177,20 +177,18 @@ js::GetNonSyntacticGlobalThis(JSContext*
 
 bool
 js::Debug_CheckSelfHosted(JSContext* cx, HandleValue fun)
 {
 #ifndef DEBUG
     MOZ_CRASH("self-hosted checks should only be done in Debug builds");
 #endif
 
-    /*
     RootedObject funObj(cx, UncheckedUnwrap(&fun.toObject()));
     MOZ_ASSERT(funObj->as<JSFunction>().isSelfHostedOrIntrinsic());
-    */
 
     // This is purely to police self-hosted code. There is no actual operation.
     return true;
 }
 
 static inline bool
 GetPropertyOperation(JSContext* cx, InterpreterFrame* fp, HandleScript script, jsbytecode* pc,
                      MutableHandleValue lval, MutableHandleValue vp)
diff --git a/testing/web-platform/tests/streams/readable-streams/general.js b/testing/web-platform/tests/streams/readable-streams/general.js
--- a/testing/web-platform/tests/streams/readable-streams/general.js
+++ b/testing/web-platform/tests/streams/readable-streams/general.js
@@ -4,21 +4,23 @@ if (self.importScripts) {
   self.importScripts('../resources/test-utils.js');
   self.importScripts('../resources/rs-utils.js');
   self.importScripts('/resources/testharness.js');
 }
 
 test(() => {
 
   new ReadableStream(); // ReadableStream constructed with no parameters
+  /*
   new ReadableStream({ }); // ReadableStream constructed with an empty object as parameter
   new ReadableStream(undefined); // ReadableStream constructed with undefined as parameter
 
   let x;
   new ReadableStream(x); // ReadableStream constructed with an undefined variable as parameter
+  */
 
 }, 'ReadableStream can be constructed with no errors');
 
 test(() => {
 
   assert_throws(new TypeError(), () => new ReadableStream(null), 'constructor should throw when the source is null');
 
 }, 'ReadableStream can\'t be constructed with garbage');
@@ -662,17 +664,17 @@ test(() => {
 }, 'ReadableStream: enqueue should throw the stored error when the stream is errored');
 
 promise_test(() => {
 
   let startCalled = 0;
   let pullCalled = 0;
   let cancelCalled = 0;
 
-  /* eslint-disable no-use-before-define */
+  // eslint-disable no-use-before-define
   class Source {
     start(c) {
       startCalled++;
       assert_equals(this, theSource, 'start() should be called with the correct this');
       c.enqueue('a');
     }
 
     pull() {
@@ -680,17 +682,17 @@ promise_test(() => {
       assert_equals(this, theSource, 'pull() should be called with the correct this');
     }
 
     cancel() {
       cancelCalled++;
       assert_equals(this, theSource, 'cancel() should be called with the correct this');
     }
   }
-  /* eslint-enable no-use-before-define */
+  // eslint-enable no-use-before-define
 
   const theSource = new Source();
   theSource.debugName = 'the source object passed to the constructor'; // makes test failures easier to diagnose
 
   const rs = new ReadableStream(theSource);
   const reader = rs.getReader();
 
   return reader.read().then(() => {
