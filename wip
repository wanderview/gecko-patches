# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2b347cd70b1d6cce3fe057bbd084a9e6ae3b97e5

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -8750,24 +8750,28 @@ nsGlobalWindow::EnterModalState()
   nsIDocument* topDoc = topWin->GetExtantDoc();
   nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
   if (capturingContent && topDoc &&
       nsContentUtils::ContentIsCrossDocDescendantOf(capturingContent, topDoc)) {
     nsIPresShell::SetCapturingContent(nullptr, 0);
   }
 
   if (topWin->mModalStateDepth == 0) {
-    NS_ASSERTION(!topWin->mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
-
-    topWin->mSuspendedDoc = topDoc;
+    topWin->NewSuspend();
+
+    // NewSuspend() will suppress all events by default.  But modal state
+    // should only suppress animations.
     if (topDoc) {
+      MOZ_ASSERT(topWin->mSuspendedDoc == topDoc);
+      // So first, enable animation suppression.
       topDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly);
-    }
-
-    topWin->NewSuspend();
+      // Then undo the event suppression performed by NewSuspend().  We
+      // will put this back in LeaveModalState().
+      topDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+    }
   }
   topWin->mModalStateDepth++;
 }
 
 void
 nsGlobalWindow::LeaveModalState()
 {
   MOZ_ASSERT(IsOuterWindow(), "Modal state is maintained on outer windows");
@@ -8780,24 +8784,28 @@ nsGlobalWindow::LeaveModalState()
   }
 
   MOZ_ASSERT(topWin->mModalStateDepth != 0);
   MOZ_ASSERT(NewIsSuspended());
   MOZ_ASSERT(topWin->NewIsSuspended());
   topWin->mModalStateDepth--;
 
   if (topWin->mModalStateDepth == 0) {
-    topWin->NewResume();
-
     if (topWin->mSuspendedDoc) {
+      // Put make the event suppression initially set by NewSuspend() in
+      // EnterModalState().
+      topWin->mSuspendedDoc->SuppressEventHandling(nsIDocument::eEvents);
+
+      // Then reverse the animation suppression enabled in EnterModalState().
       nsCOMPtr<nsIDocument> currentDoc = topWin->GetExtantDoc();
       topWin->mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eAnimationsOnly,
                                                                   currentDoc == topWin->mSuspendedDoc);
-      topWin->mSuspendedDoc = nullptr;
-    }
+    }
+
+    topWin->NewResume();
   }
 
   // Remember the time of the last dialog quit.
   nsGlobalWindow *inner = topWin->GetCurrentInnerWindowInternal();
   if (inner)
     inner->mLastDialogQuitTime = TimeStamp::Now();
 
   if (topWin->mModalStateDepth == 0) {
@@ -11596,18 +11604,29 @@ nsGlobalWindow::CloneStorageEvent(const 
   return event.forget();
 }
 
 void
 nsGlobalWindow::NewSuspend()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewSuspend, ());
-
-  CallOnChildren(&nsGlobalWindow::NewSuspend);
+  if (mDoc) {
+    mSuspendedDoc = mDoc;
+    mDoc->SuppressEventHandling(nsIDocument::eEvents);
+  }
+  NewSuspendInternal();
+}
+
+void
+nsGlobalWindow::NewSuspendInternal()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  CallOnChildren(&nsGlobalWindow::NewSuspendInternal);
 
   mSuspendDepth += 1;
   if (mSuspendDepth != 1) {
     return;
   }
 
   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
   if (ac) {
@@ -11644,19 +11663,34 @@ nsGlobalWindow::NewSuspend()
   }
 }
 
 void
 nsGlobalWindow::NewResume()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewResume, ());
-
-  CallOnChildren(&nsGlobalWindow::NewResume);
-
+  NewResumeInternal();
+  if (mSuspendedDoc) {
+    mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents,
+                                                        mDoc == mSuspendedDoc);
+    if (!mSuspendedDoc->EventHandlingSuppressed()) {
+      mSuspendedDoc = nullptr;
+    }
+  }
+}
+
+void
+nsGlobalWindow::NewResumeInternal()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  CallOnChildren(&nsGlobalWindow::NewResumeInternal);
+
+  MOZ_ASSERT_IF(mDoc, mDoc->EventHandlingSuppressed());
   MOZ_ASSERT(mSuspendDepth != 0);
   mSuspendDepth -= 1;
   if (mSuspendDepth != 0) {
     return;
   }
 
   // We should not be able to resume a frozen window.  It must be Thaw()'d first.
   MOZ_ASSERT(mFreezeDepth == 0);
@@ -11850,42 +11884,52 @@ nsGlobalWindow::NewSyncSuspendAndFreezeS
 
   // Attempt to find our parent windows.
   nsCOMPtr<Element> frame = outer->GetFrameElementInternal();
   nsPIDOMWindowOuter* parentOuter = frame ? frame->OwnerDoc()->GetWindow()
                                           : nullptr;
   nsGlobalWindow* parentInner =
     parentOuter ? nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow())
                 : nullptr;
+  nsIDocument* parentDoc = parentInner ? parentInner->GetExtantDoc() : nullptr;
 
   // If our outer is in a modal state, but our parent is not in a modal
   // state, then we must apply the suspend directly.  If our parent is
   // in a modal state then we should get the suspend automatically
   // via the parentSuspendDepth application below.
   if ((!parentInner || !parentInner->IsInModalState()) && IsInModalState()) {
     NewSuspend();
   }
 
   uint32_t parentFreezeDepth = parentInner ? parentInner->mFreezeDepth : 0;
   uint32_t parentSuspendDepth = parentInner ? parentInner->mSuspendDepth : 0;
+  uint32_t parentSuppressDepth = parentDoc ? parentDoc->EventHandlingSuppressed()
+                                           : 0;
 
   // Since every Freeze() calls Suspend(), the suspend count must
   // be equal or greater to the freeze count.
   MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
 
   // First apply the Freeze() calls.
   for (uint32_t i = 0; i < parentFreezeDepth; ++i) {
     NewFreeze();
   }
 
   // Now apply only the number of Suspend() calls to reach the target
   // suspend count after applying the Freeze() calls.
   for (uint32_t i = 0; i < (parentSuspendDepth - parentFreezeDepth); ++i) {
     NewSuspend();
   }
+
+  if (mDoc) {
+    mSuspendedDoc = mDoc;
+    for (uint32_t i = 0; i < (parentSuppressDepth - parentSuspendDepth); ++i) {
+      mDoc->SuppressEventHandling(nsIDocument::eEvents);
+    }
+  }
 }
 
 template<typename Method>
 void
 nsGlobalWindow::CallOnChildren(Method aMethod)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1487,16 +1487,18 @@ private:
                         bool aNavigate,
                         nsIArray *argv,
                         nsISupports *aExtraArgument,
                         nsPIDOMWindowOuter **aReturn);
 
   template<typename Method>
   void CallOnChildren(Method aMethod);
 
+  void NewSuspendInternal();
+  void NewResumeInternal();
   void NewFreezeInternal();
   void NewThawInternal();
 
 public:
   // Timeout Functions
   // Language agnostic timeout function (all args passed).
   // |interval| is in milliseconds.
   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
