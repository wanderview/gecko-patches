# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c84c223be39363ec16c649ce2fc9bd6ee1873a4c

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3641,16 +3641,27 @@ nsGlobalWindow::DefineArgumentsProperty(
   return ctx->SetProperty(obj, "arguments", aArguments);
 }
 
 void
 nsGlobalWindow::MaybeApplyBackPressure()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
+  if (IsOuterWindow()) {
+    nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
+    if (!inner) {
+      return;
+    }
+    inner->MaybeApplyBackPressure();
+    return;
+  }
+
+  MOZ_ASSERT(IsInnerWindow());
+
   // If we are already suspended, then we don't need to apply back
   // pressure for ThrottledEventQueue reasons.  This also avoids repeatedly
   // calling SuspendTimeout() if this routine is executed many times
   // before dropping below the backpressure threshold.
   if (IsSuspended()) {
     return;
   }
 
@@ -3666,25 +3677,40 @@ nsGlobalWindow::MaybeApplyBackPressure()
   // the queue.
   static const uint32_t kThrottledEventQueueBackPressure = 5000;
   if (taskQueue->Length() < kThrottledEventQueueBackPressure) {
     return;
   }
 
   // First attempt to queue a runnable to resume running timeouts.  We do
   // this first in order to verify we can dispatch successfully.
-  nsCOMPtr<nsIRunnable> r = NewRunnableMethod(this, &nsGlobalWindow::Resume);
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod(this, &nsGlobalWindow::RemoveBackPressure);
   nsresult rv = taskQueue->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS_VOID(rv);
 
   // Since the resume is dispatched we can go ahead and suspend the window
   // now.  Once the task queue drains the resume will automatically get
   // executed balancing this suspend.
-  // TODO: Consider suppressing event handling as well.
   Suspend();
+
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->SuppressEventHandling(nsIDocument::eEvents);
+  }
+}
+
+void
+nsGlobalWindow::RemoveBackPressure()
+{
+  nsIDocument* doc = GetExtantDoc();
+  if (doc) {
+    doc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+  }
+  Resume();
 }
 
 //*****************************************************************************
 // nsGlobalWindow::nsIScriptObjectPrincipal
 //*****************************************************************************
 
 nsIPrincipal*
 nsGlobalWindow::GetPrincipal()
@@ -8561,16 +8587,23 @@ nsGlobalWindow::PostMessageMozOuter(JSCo
   JS::Rooted<JS::Value> message(aCx, aMessage);
   JS::Rooted<JS::Value> transfer(aCx, aTransfer);
 
   event->Write(aCx, message, transfer, JS::CloneDataPolicy(), aError);
   if (NS_WARN_IF(aError.Failed())) {
     return;
   }
 
+  nsCOMPtr<nsIEventTarget> teq = GetThrottledEventQueue();
+  if (teq) {
+    aError = teq->Dispatch(event.forget(), NS_DISPATCH_NORMAL);
+    MaybeApplyBackPressure();
+    return;
+  }
+
   aError = NS_DispatchToCurrentThread(event);
 }
 
 void
 nsGlobalWindow::PostMessageMoz(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                                const nsAString& aTargetOrigin,
                                JS::Handle<JS::Value> aTransfer,
                                nsIPrincipal& aSubjectPrincipal,
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1709,16 +1709,19 @@ private:
   friend class nsPIDOMWindow<nsISupports>;
 
   // Apply back pressure to the window if the TabGroup ThrottledEventQueue
   // exists and has too many runnables waiting to run.  For example, suspend
   // timers until we have a chance to catch up, etc.
   void
   MaybeApplyBackPressure();
 
+  void
+  RemoveBackPressure();
+
   mozilla::dom::TabGroup* TabGroupInner();
   mozilla::dom::TabGroup* TabGroupOuter();
 
 protected:
   // These members are only used on outer window objects. Make sure
   // you never set any of these on an inner object!
   bool                          mFullScreen : 1;
   bool                          mFullscreenMode : 1;
diff --git a/dom/broadcastchannel/BroadcastChannel.cpp b/dom/broadcastchannel/BroadcastChannel.cpp
--- a/dom/broadcastchannel/BroadcastChannel.cpp
+++ b/dom/broadcastchannel/BroadcastChannel.cpp
@@ -8,16 +8,17 @@
 #include "BroadcastChannelChild.h"
 #include "mozilla/dom/BroadcastChannelBinding.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/StructuredCloneHolder.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ThrottledEventQueue.h"
 #include "nsContentUtils.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
 #include "nsIBFCacheEntry.h"
 #include "nsIDocument.h"
 #include "nsISupportsPrimitives.h"
 
@@ -437,20 +438,20 @@ BroadcastChannel::PostMessageInternal(JS
 }
 
 void
 BroadcastChannel::PostMessageData(BroadcastChannelMessage* aData)
 {
   RemoveDocFromBFCache();
 
   if (mActor) {
-    RefPtr<BCPostMessageRunnable> runnable =
+    nsCOMPtr<nsIRunnable> runnable =
       new BCPostMessageRunnable(mActor, aData);
 
-    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+    if (NS_FAILED(DispatchToCurrentThread(runnable.forget()))) {
       NS_WARNING("Failed to dispatch to the current thread!");
     }
 
     return;
   }
 
   mPendingMessages.AppendElement(aData);
 }
@@ -463,19 +464,19 @@ BroadcastChannel::Close()
   }
 
   if (mPendingMessages.IsEmpty()) {
     // We cannot call Shutdown() immediatelly because we could have some
     // postMessage runnable already dispatched. Instead, we change the state to
     // StateClosed and we shutdown the actor asynchrounsly.
 
     mState = StateClosed;
-    RefPtr<CloseRunnable> runnable = new CloseRunnable(this);
+    nsCOMPtr<nsIRunnable> runnable = new CloseRunnable(this);
 
-    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+    if (NS_FAILED(DispatchToCurrentThread(runnable.forget()))) {
       NS_WARNING("Failed to dispatch to the current thread!");
     }
   } else {
     MOZ_ASSERT(!mActor);
     mState = StateClosing;
   }
 }
 
@@ -520,18 +521,18 @@ BroadcastChannel::Shutdown()
   mState = StateClosed;
 
   // The DTOR of this WorkerHolder will release the worker for us.
   mWorkerHolder = nullptr;
 
   if (mActor) {
     mActor->SetParent(nullptr);
 
-    RefPtr<TeardownRunnable> runnable = new TeardownRunnable(mActor);
-    NS_DispatchToCurrentThread(runnable);
+    nsCOMPtr<nsIRunnable> runnable = new TeardownRunnable(mActor);
+    DispatchToCurrentThread(runnable.forget());
 
     mActor = nullptr;
   }
 
   // If shutdown() is called we have to release the reference if we still keep
   // it.
   if (mIsKeptAlive) {
     mIsKeptAlive = false;
@@ -657,16 +658,27 @@ BroadcastChannel::RemoveDocFromBFCache()
   nsCOMPtr<nsIBFCacheEntry> bfCacheEntry = doc->GetBFCacheEntry();
   if (!bfCacheEntry) {
     return;
   }
 
   bfCacheEntry->RemoveFromBFCacheSync();
 }
 
+nsresult
+BroadcastChannel::DispatchToCurrentThread(already_AddRefed<nsIRunnable> aEvent)
+{
+  if (!NS_IsMainThread() || !GetOwner() || !GetOwner()->GetThrottledEventQueue()) {
+    return NS_DispatchToCurrentThread(Move(aEvent));
+  }
+
+  nsCOMPtr<nsIEventTarget> target = GetOwner()->GetThrottledEventQueue();
+  return target->Dispatch(Move(aEvent), NS_DISPATCH_NORMAL);
+}
+
 NS_IMPL_CYCLE_COLLECTION_CLASS(BroadcastChannel)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(BroadcastChannel,
                                                   DOMEventTargetHelper)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(BroadcastChannel,
                                                 DOMEventTargetHelper)
diff --git a/dom/broadcastchannel/BroadcastChannel.h b/dom/broadcastchannel/BroadcastChannel.h
--- a/dom/broadcastchannel/BroadcastChannel.h
+++ b/dom/broadcastchannel/BroadcastChannel.h
@@ -102,16 +102,19 @@ private:
 
   bool IsCertainlyAliveForCC() const override
   {
     return mIsKeptAlive;
   }
 
   void RemoveDocFromBFCache();
 
+  nsresult
+  DispatchToCurrentThread(already_AddRefed<nsIRunnable> aEvent);
+
   RefPtr<BroadcastChannelChild> mActor;
   nsTArray<RefPtr<BroadcastChannelMessage>> mPendingMessages;
 
   nsAutoPtr<workers::WorkerHolder> mWorkerHolder;
 
   nsAutoPtr<PrincipalInfo> mPrincipalInfo;
 
   nsCString mOrigin;
diff --git a/dom/tests/mochitest/bugs/test_bug440572.html b/dom/tests/mochitest/bugs/test_bug440572.html
--- a/dom/tests/mochitest/bugs/test_bug440572.html
+++ b/dom/tests/mochitest/bugs/test_bug440572.html
@@ -3,43 +3,56 @@
 <!--
 https://bugzilla.mozilla.org/show_bug.cgi?id=440572
 -->
 <head>
   <title>Test for Bug 440572</title>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>        
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
 </head>
-<body onload="runtests()">
+<body onload="load()">
 <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=440572">Mozilla Bug 440572</a>
 
 <script class="testbody" type="text/javascript">
 
 /** Test for Bug 440572 **/
 
 var messages = [];
 
 function receiveMessage(e)
 {
+  if (e.data === 'LOAD') {
+    runtests();
+    return;
+  }
+
   is(e.origin, "http://example.org", "wrong sender!");
   messages.push(e.data);
 }
 
 window.addEventListener("message", receiveMessage, false);
 
 function runtests()
 {
   is(messages.length, 3, "received the right number of messages.");
   is(messages[0], "success", "test in frame failed.");
   isnot(messages[1], "success", "parent[\"content\"] should be the WebIDL property of Window.");
   isnot(messages[2], "success", "parent[\"dump\"] should be the WebIDL property of Window.");
 
   SimpleTest.finish();
 }
 
+function load()
+{
+  // postMessage() events use a separate task source from the load event.  Post
+  // a new message to execute the test comparisons so that we can be sure the
+  // iframe messages have flushed through the queue.
+  postMessage('LOAD', '*');
+}
+
 SimpleTest.waitForExplicitFinish();
 </script>
 <br>
 <iframe name="test" src="http://example.org:80/tests/dom/tests/mochitest/bugs/iframe_bug440572.html"></iframe>
 <br>
 <iframe name="content" src="http://example.org:80/tests/dom/tests/mochitest/bugs/iframe_bug440572.html"></iframe>
 <br>
 <iframe name="dump" src="http://example.org:80/tests/dom/tests/mochitest/bugs/iframe_bug440572.html"></iframe>
