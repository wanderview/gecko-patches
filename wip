# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  69075e5c9a094e394a22e92cc7d8c50c5dd615a9

diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -39,17 +39,20 @@ function ReadableStream(underlyingSource
   // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
   UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
   // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
   // Step 11. ReturnIfAbrupt(startResult).
   let startResult = InvokeOrNoop(underlyingSource, "start",
     UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
   // Step 12. Resolve startResult as a promise:
-  GetPromiseCtor().resolve(startResult).then(() => {
+  DumpMessage('### ### calling Promise_static_resolve()');
+  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
+  DumpMessage('### ### calling Promise_then()');
+  callFunction(Promise_then, p, () => {
 this._log += 'resolved ' + startResult;
     // Set this@[[started]] to true.
     UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
     // Perform RequestReadableStreamPull(this).
     RequestReadableStreamPull(this);
   }, (r) => {
     // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
     if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
diff --git a/js/src/vm/Interpreter.cpp b/js/src/vm/Interpreter.cpp
--- a/js/src/vm/Interpreter.cpp
+++ b/js/src/vm/Interpreter.cpp
@@ -177,20 +177,18 @@ js::GetNonSyntacticGlobalThis(JSContext*
 
 bool
 js::Debug_CheckSelfHosted(JSContext* cx, HandleValue fun)
 {
 #ifndef DEBUG
     MOZ_CRASH("self-hosted checks should only be done in Debug builds");
 #endif
 
-    /*
     RootedObject funObj(cx, UncheckedUnwrap(&fun.toObject()));
     MOZ_ASSERT(funObj->as<JSFunction>().isSelfHostedOrIntrinsic());
-    */
 
     // This is purely to police self-hosted code. There is no actual operation.
     return true;
 }
 
 static inline bool
 GetPropertyOperation(JSContext* cx, InterpreterFrame* fp, HandleScript script, jsbytecode* pc,
                      MutableHandleValue lval, MutableHandleValue vp)
diff --git a/testing/web-platform/tests/streams/readable-streams/general.js b/testing/web-platform/tests/streams/readable-streams/general.js
--- a/testing/web-platform/tests/streams/readable-streams/general.js
+++ b/testing/web-platform/tests/streams/readable-streams/general.js
@@ -4,24 +4,27 @@ if (self.importScripts) {
   self.importScripts('../resources/test-utils.js');
   self.importScripts('../resources/rs-utils.js');
   self.importScripts('/resources/testharness.js');
 }
 
 test(() => {
 
   new ReadableStream(); // ReadableStream constructed with no parameters
+  /*
   new ReadableStream({ }); // ReadableStream constructed with an empty object as parameter
   new ReadableStream(undefined); // ReadableStream constructed with undefined as parameter
 
   let x;
   new ReadableStream(x); // ReadableStream constructed with an undefined variable as parameter
+  */
 
 }, 'ReadableStream can be constructed with no errors');
 
+/*
 test(() => {
 
   assert_throws(new TypeError(), () => new ReadableStream(null), 'constructor should throw when the source is null');
 
 }, 'ReadableStream can\'t be constructed with garbage');
 
 test(() => {
 
@@ -662,17 +665,17 @@ test(() => {
 }, 'ReadableStream: enqueue should throw the stored error when the stream is errored');
 
 promise_test(() => {
 
   let startCalled = 0;
   let pullCalled = 0;
   let cancelCalled = 0;
 
-  /* eslint-disable no-use-before-define */
+  // eslint-disable no-use-before-define
   class Source {
     start(c) {
       startCalled++;
       assert_equals(this, theSource, 'start() should be called with the correct this');
       c.enqueue('a');
     }
 
     pull() {
@@ -680,17 +683,17 @@ promise_test(() => {
       assert_equals(this, theSource, 'pull() should be called with the correct this');
     }
 
     cancel() {
       cancelCalled++;
       assert_equals(this, theSource, 'cancel() should be called with the correct this');
     }
   }
-  /* eslint-enable no-use-before-define */
+  // eslint-enable no-use-before-define
 
   const theSource = new Source();
   theSource.debugName = 'the source object passed to the constructor'; // makes test failures easier to diagnose
 
   const rs = new ReadableStream(theSource);
   const reader = rs.getReader();
 
   return reader.read().then(() => {
@@ -822,10 +825,11 @@ promise_test(() => {
   const rs = sequentialReadableStream(10, { async: true });
 
   return readableStreamToArray(rs).then(chunks => {
     assert_true(rs.source.closed, 'source should be closed after all chunks are read');
     assert_array_equals(chunks, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'the expected 10 chunks should be read');
   });
 
 }, 'ReadableStream integration test: adapting an async pull source');
+*/
 
 done();
