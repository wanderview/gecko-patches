# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d4d72e7b30da251ad3027e234444251adad5e335

diff --git a/dom/workers/PServiceWorkerManager.ipdl b/dom/workers/PServiceWorkerManager.ipdl
--- a/dom/workers/PServiceWorkerManager.ipdl
+++ b/dom/workers/PServiceWorkerManager.ipdl
@@ -2,44 +2,41 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 
 include PBackgroundSharedTypes;
 include ServiceWorkerRegistrarTypes;
 
-using mozilla::PrincipalOriginAttributes from "mozilla/ipc/BackgroundUtils.h";
-
 namespace mozilla {
 namespace dom {
 
 protocol PServiceWorkerManager
 {
   manager PBackground;
 
 parent:
   async Register(ServiceWorkerRegistrationData data);
 
-  async Unregister(PrincipalInfo principalInfo, nsString scope);
+  async Unregister(nsCString principalOrigin, nsString scope);
 
-  async PropagateSoftUpdate(PrincipalOriginAttributes originAttributes,
-                            nsString scope);
-  async PropagateUnregister(PrincipalInfo principalInfo, nsString scope);
+  async PropagateSoftUpdate(nsCString principalOrigin, nsString scope);
+  async PropagateUnregister(nsCString principalOrigin, nsString scope);
 
   async PropagateRemove(nsCString host);
 
   async PropagateRemoveAll();
 
   async Shutdown();
 
 child:
   async NotifyRegister(ServiceWorkerRegistrationData data);
-  async NotifySoftUpdate(PrincipalOriginAttributes originAttributes, nsString scope);
-  async NotifyUnregister(PrincipalInfo principalInfo, nsString scope);
+  async NotifySoftUpdate(nsCString principalOrigin, nsString scope);
+  async NotifyUnregister(nsCString principalOrigin, nsString scope);
   async NotifyRemove(nsCString host);
   async NotifyRemoveAll();
 
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -3798,33 +3798,27 @@ ServiceWorkerManager::NotifyServiceWorke
 
     if (utf8Scope.Equals(aRegistration->mScope)) {
       target->RegistrationRemoved();
     }
   }
 }
 
 void
-ServiceWorkerManager::SoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
+ServiceWorkerManager::SoftUpdate(const nsACString& aPrincipalOrigin,
                                  const nsACString& aScope)
 {
   AssertIsOnMainThread();
 
   if (mShuttingDown) {
     return;
   }
 
-  nsCOMPtr<nsIURI> scopeURI;
-  nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
   nsCOMPtr<nsIPrincipal> principal =
-    BasePrincipal::CreateCodebasePrincipal(scopeURI, aOriginAttributes);
+    BasePrincipal::CreateCodebasePrincipal(aPrincipalOrigin);
   if (NS_WARN_IF(!principal)) {
     return;
   }
 
   nsAutoCString scopeKey;
   aOriginAttributes.CreateSuffix(scopeKey);
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -5022,20 +5016,23 @@ ServiceWorkerManager::UpdateTimerFired(n
   if (!registration) {
     return;
   }
 
   if (!registration->CheckAndClearIfUpdateNeeded()) {
     return;
   }
 
-  PrincipalOriginAttributes attrs =
-    BasePrincipal::Cast(aPrincipal)->OriginAttributesRef();
-
-  SoftUpdate(attrs, aScope);
+  nsAutoCString principalOrigin;
+  rv = aPrincipal->GetOrigin(principalOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  SoftUpdate(principalOrigin, aScope);
 }
 
 NS_IMPL_ISUPPORTS(ServiceWorkerInfo, nsIServiceWorkerInfo)
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetScriptSpec(nsAString& aScriptSpec)
 {
   AssertIsOnMainThread();
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -383,17 +383,17 @@ public:
                      ErrorResult& aRv);
 
   void
   Update(nsIPrincipal* aPrincipal,
          const nsACString& aScope,
          ServiceWorkerUpdateFinishCallback* aCallback);
 
   void
-  SoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
+  SoftUpdate(const nsACString& aPrincipalOrigin,
              const nsACString& aScope);
 
   void
   PropagateSoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
                       const nsAString& aScope);
 
   void
   PropagateRemove(const nsACString& aHost);
diff --git a/dom/workers/ServiceWorkerManagerChild.cpp b/dom/workers/ServiceWorkerManagerChild.cpp
--- a/dom/workers/ServiceWorkerManagerChild.cpp
+++ b/dom/workers/ServiceWorkerManagerChild.cpp
@@ -27,42 +27,43 @@ ServiceWorkerManagerChild::RecvNotifyReg
   MOZ_ASSERT(swm);
 
   swm->LoadRegistration(aData);
   return true;
 }
 
 bool
 ServiceWorkerManagerChild::RecvNotifySoftUpdate(
-                                      const PrincipalOriginAttributes& aOriginAttributes,
+                                      const nsCString& aPrincipalOrigin,
                                       const nsString& aScope)
 {
   if (mShuttingDown) {
     return true;
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
-  swm->SoftUpdate(aOriginAttributes, NS_ConvertUTF16toUTF8(aScope));
+  swm->SoftUpdate(aPrincipalOrigin, NS_ConvertUTF16toUTF8(aScope));
   return true;
 }
 
 bool
-ServiceWorkerManagerChild::RecvNotifyUnregister(const PrincipalInfo& aPrincipalInfo,
+ServiceWorkerManagerChild::RecvNotifyUnregister(const nsCString& aPrincipalOrigin,
                                                 const nsString& aScope)
 {
   if (mShuttingDown) {
     return true;
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
-  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo);
+  nsCOMPtr<nsIPrincipal> principal =
+    BasePrincipal::CreateCodebasePrincipal(aPrincipalOrigin);
   if (NS_WARN_IF(!principal)) {
     return true;
   }
 
   nsresult rv = swm->Unregister(principal, nullptr, aScope);
   Unused << NS_WARN_IF(NS_FAILED(rv));
   return true;
 }
diff --git a/dom/workers/ServiceWorkerManagerChild.h b/dom/workers/ServiceWorkerManagerChild.h
--- a/dom/workers/ServiceWorkerManagerChild.h
+++ b/dom/workers/ServiceWorkerManagerChild.h
@@ -6,23 +6,16 @@
 
 #ifndef mozilla_dom_ServiceWorkerManagerChild_h
 #define mozilla_dom_ServiceWorkerManagerChild_h
 
 #include "mozilla/dom/PServiceWorkerManagerChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 
 namespace mozilla {
-
-class PrincipalOriginAttributes;
-
-namespace ipc {
-class BackgroundChildImpl;
-} // namespace ipc
-
 namespace dom {
 namespace workers {
 
 class ServiceWorkerManagerChild final : public PServiceWorkerManagerChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
 public:
@@ -31,20 +24,20 @@ public:
   void ManagerShuttingDown()
   {
     mShuttingDown = true;
   }
 
   virtual bool RecvNotifyRegister(const ServiceWorkerRegistrationData& aData)
                                                                        override;
 
-  virtual bool RecvNotifySoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
+  virtual bool RecvNotifySoftUpdate(const nsCString& aPrincipalOrigin,
                                     const nsString& aScope) override;
 
-  virtual bool RecvNotifyUnregister(const PrincipalInfo& aPrincipalInfo,
+  virtual bool RecvNotifyUnregister(const nsCString& aPrincipalOrigin,
                                     const nsString& aScope) override;
 
   virtual bool RecvNotifyRemove(const nsCString& aHost) override;
 
   virtual bool RecvNotifyRemoveAll() override;
 
 private:
   ServiceWorkerManagerChild()
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -67,85 +67,86 @@ public:
 private:
   ServiceWorkerRegistrationData mData;
   const uint64_t mParentID;
 };
 
 class UnregisterServiceWorkerCallback final : public nsRunnable
 {
 public:
-  UnregisterServiceWorkerCallback(const PrincipalInfo& aPrincipalInfo,
+  UnregisterServiceWorkerCallback(const nsACString& aPrincipalOrigin,
                                   const nsString& aScope)
-    : mPrincipalInfo(aPrincipalInfo)
+    : mPrincipalOrigin(aPrincipalOrigin)
     , mScope(aScope)
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
   }
 
   NS_IMETHODIMP
   Run()
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
 
     RefPtr<dom::ServiceWorkerRegistrar> service =
       dom::ServiceWorkerRegistrar::Get();
     MOZ_ASSERT(service);
 
-    service->UnregisterServiceWorker(mPrincipalInfo,
+    service->UnregisterServiceWorker(mPrincipalOrigin,
                                      NS_ConvertUTF16toUTF8(mScope));
     return NS_OK;
   }
 
 private:
-  const PrincipalInfo mPrincipalInfo;
+  const nsCString mPrincipalOrigin;
   nsString mScope;
 };
 
 class CheckPrincipalWithCallbackRunnable final : public nsRunnable
 {
 public:
   CheckPrincipalWithCallbackRunnable(already_AddRefed<ContentParent> aParent,
-                                     const PrincipalInfo& aPrincipalInfo,
+                                     const nsACString& aPrincipalOrigin,
                                      nsRunnable* aCallback)
     : mContentParent(aParent)
-    , mPrincipalInfo(aPrincipalInfo)
+    , mPrincipalOrigin(aPrincipalOrigin)
     , mCallback(aCallback)
     , mBackgroundThread(NS_GetCurrentThread())
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
 
     MOZ_ASSERT(mContentParent);
     MOZ_ASSERT(mCallback);
     MOZ_ASSERT(mBackgroundThread);
   }
 
   NS_IMETHODIMP Run()
   {
     if (NS_IsMainThread()) {
-      nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo);
+      nsCOMPtr<nsIPrincipal> principal =
+        BasePrincipal::CreateCodebasePrincipal(mPrincipalOrigin);
       AssertAppPrincipal(mContentParent, principal);
       mContentParent = nullptr;
 
       mBackgroundThread->Dispatch(this, NS_DISPATCH_NORMAL);
       return NS_OK;
     }
 
     AssertIsOnBackgroundThread();
     mCallback->Run();
     mCallback = nullptr;
 
     return NS_OK;
   }
 
 private:
   RefPtr<ContentParent> mContentParent;
-  PrincipalInfo mPrincipalInfo;
+  nsCString mPrincipalOrigin;
   RefPtr<nsRunnable> mCallback;
   nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
 } // namespace
 
 ServiceWorkerManagerParent::ServiceWorkerManagerParent()
   : mService(ServiceWorkerManagerService::GetOrCreate())
@@ -176,102 +177,105 @@ bool
 ServiceWorkerManagerParent::RecvRegister(
                                      const ServiceWorkerRegistrationData& aData)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   // Basic validation.
   if (aData.scope().IsEmpty() ||
-      aData.principal().type() == PrincipalInfo::TNullPrincipalInfo ||
-      aData.principal().type() == PrincipalInfo::TSystemPrincipalInfo) {
+      // TODO
+      //aData.principal().type() == PrincipalInfo::TNullPrincipalInfo ||
+      ////aData.principal().type() == PrincipalInfo::TSystemPrincipalInfo) {
     return false;
   }
 
   RefPtr<RegisterServiceWorkerCallback> callback =
     new RegisterServiceWorkerCallback(aData, mID);
 
   RefPtr<ContentParent> parent =
     BackgroundParent::GetContentParent(Manager());
 
   // If the ContentParent is null we are dealing with a same-process actor.
   if (!parent) {
     callback->Run();
     return true;
   }
 
   RefPtr<CheckPrincipalWithCallbackRunnable> runnable =
-    new CheckPrincipalWithCallbackRunnable(parent.forget(), aData.principal(),
+    new CheckPrincipalWithCallbackRunnable(parent.forget(),
+                                           aData.principalOrigin(),
                                            callback);
   nsresult rv = NS_DispatchToMainThread(runnable);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
 
   return true;
 }
 
 bool
-ServiceWorkerManagerParent::RecvUnregister(const PrincipalInfo& aPrincipalInfo,
+ServiceWorkerManagerParent::RecvUnregister(const nsCString& aPrincipalOrigin,
                                            const nsString& aScope)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   // Basic validation.
-  if (aScope.IsEmpty() ||
-      aPrincipalInfo.type() == PrincipalInfo::TNullPrincipalInfo ||
-      aPrincipalInfo.type() == PrincipalInfo::TSystemPrincipalInfo) {
+  if (aScope.IsEmpty()) {
+      // TODO
+      //aPrincipalInfo.type() == PrincipalInfo::TNullPrincipalInfo ||
+      //aPrincipalInfo.type() == PrincipalInfo::TSystemPrincipalInfo) {
     return false;
   }
 
   RefPtr<UnregisterServiceWorkerCallback> callback =
-    new UnregisterServiceWorkerCallback(aPrincipalInfo, aScope);
+    new UnregisterServiceWorkerCallback(aPrincipalOrigin, aScope);
 
   RefPtr<ContentParent> parent =
     BackgroundParent::GetContentParent(Manager());
 
   // If the ContentParent is null we are dealing with a same-process actor.
   if (!parent) {
     callback->Run();
     return true;
   }
 
   RefPtr<CheckPrincipalWithCallbackRunnable> runnable =
-    new CheckPrincipalWithCallbackRunnable(parent.forget(), aPrincipalInfo,
+    new CheckPrincipalWithCallbackRunnable(parent.forget(), aPrincipalOrigin,
                                            callback);
   nsresult rv = NS_DispatchToMainThread(runnable);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
 
   return true;
 }
 
 bool
-ServiceWorkerManagerParent::RecvPropagateSoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
+ServiceWorkerManagerParent::RecvPropagateSoftUpdate(const nsCString& aPrincipalOrigin,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
   if (NS_WARN_IF(!mService)) {
     return false;
   }
 
-  mService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
+  mService->PropagateSoftUpdate(mID, aPrincipalOrigin, aScope);
   return true;
 }
 
 bool
-ServiceWorkerManagerParent::RecvPropagateUnregister(const PrincipalInfo& aPrincipalInfo,
+ServiceWorkerManagerParent::RecvPropagateUnregister(const nsCString& aPrincipalOrigin,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
   if (NS_WARN_IF(!mService)) {
     return false;
   }
 
-  mService->PropagateUnregister(mID, aPrincipalInfo, aScope);
+  mService->PropagateUnregister(mID, aPrincipalOrigin, aScope);
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateRemove(const nsCString& aHost)
 {
   AssertIsOnBackgroundThread();
 
diff --git a/dom/workers/ServiceWorkerManagerParent.h b/dom/workers/ServiceWorkerManagerParent.h
--- a/dom/workers/ServiceWorkerManagerParent.h
+++ b/dom/workers/ServiceWorkerManagerParent.h
@@ -6,18 +6,16 @@
 
 #ifndef mozilla_dom_ServiceWorkerManagerParent_h
 #define mozilla_dom_ServiceWorkerManagerParent_h
 
 #include "mozilla/dom/PServiceWorkerManagerParent.h"
 
 namespace mozilla {
 
-class PrincipalOriginAttributes;
-
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
 
 namespace dom {
 namespace workers {
 
 class ServiceWorkerManagerService;
@@ -42,23 +40,23 @@ public:
   already_AddRefed<ContentParent> GetContentParent() const;
 private:
   ServiceWorkerManagerParent();
   ~ServiceWorkerManagerParent();
 
   virtual bool RecvRegister(
                            const ServiceWorkerRegistrationData& aData) override;
 
-  virtual bool RecvUnregister(const PrincipalInfo& aPrincipalInfo,
+  virtual bool RecvUnregister(const nsCString& aPrincipalOrigin,
                               const nsString& aScope) override;
 
-  virtual bool RecvPropagateSoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
+  virtual bool RecvPropagateSoftUpdate(const nsCString& aPrincipalOrigin,
                                        const nsString& aScope) override;
 
-  virtual bool RecvPropagateUnregister(const PrincipalInfo& aPrincipalInfo,
+  virtual bool RecvPropagateUnregister(const nsCString& aPrincipalOrigin,
                                        const nsString& aScope) override;
 
   virtual bool RecvPropagateRemove(const nsCString& aHost) override;
 
   virtual bool RecvPropagateRemoveAll() override;
 
   virtual bool RecvShutdown() override;
 
diff --git a/dom/workers/ServiceWorkerManagerService.cpp b/dom/workers/ServiceWorkerManagerService.cpp
--- a/dom/workers/ServiceWorkerManagerService.cpp
+++ b/dom/workers/ServiceWorkerManagerService.cpp
@@ -185,17 +185,17 @@ ServiceWorkerManagerService::PropagateRe
 #ifdef DEBUG
   MOZ_ASSERT(parentFound);
 #endif
 }
 
 void
 ServiceWorkerManagerService::PropagateSoftUpdate(
                                       uint64_t aParentID,
-                                      const PrincipalOriginAttributes& aOriginAttributes,
+                                      const nsACString& aPrincipalOrigin,
                                       const nsAString& aScope)
 {
   AssertIsOnBackgroundThread();
 
   nsAutoPtr<nsTArray<NotifySoftUpdateData>> notifySoftUpdateDataArray(
       new nsTArray<NotifySoftUpdateData>());
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
@@ -207,67 +207,67 @@ ServiceWorkerManagerService::PropagateSo
       parentFound = true;
     }
 #endif
 
     RefPtr<ContentParent> contentParent = parent->GetContentParent();
 
     // If the ContentParent is null we are dealing with a same-process actor.
     if (!contentParent) {
-      Unused << parent->SendNotifySoftUpdate(aOriginAttributes,
+      Unused << parent->SendNotifySoftUpdate(aPrincipalOrigin,
                                              nsString(aScope));
       continue;
     }
 
     NotifySoftUpdateData* data = notifySoftUpdateDataArray->AppendElement();
     data->mContentParent.swap(contentParent);
     data->mParent.swap(parent);
   }
 
   if (notifySoftUpdateDataArray->IsEmpty()) {
     return;
   }
 
   RefPtr<NotifySoftUpdateIfPrincipalOkRunnable> runnable =
     new NotifySoftUpdateIfPrincipalOkRunnable(notifySoftUpdateDataArray,
-                                              aOriginAttributes, aScope);
+                                              aPrincipalOrigin, aScope);
   MOZ_ASSERT(!notifySoftUpdateDataArray);
   nsresult rv = NS_DispatchToMainThread(runnable);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
 
 #ifdef DEBUG
   MOZ_ASSERT(parentFound);
 #endif
 }
 
 void
 ServiceWorkerManagerService::PropagateUnregister(
                                             uint64_t aParentID,
-                                            const PrincipalInfo& aPrincipalInfo,
+                                            const nsACString& aPrincipalOrigin,
                                             const nsAString& aScope)
 {
   AssertIsOnBackgroundThread();
 
   RefPtr<dom::ServiceWorkerRegistrar> service =
     dom::ServiceWorkerRegistrar::Get();
   MOZ_ASSERT(service);
 
   // It's possible that we don't have any ServiceWorkerManager managing this
   // scope but we still need to unregister it from the ServiceWorkerRegistrar.
-  service->UnregisterServiceWorker(aPrincipalInfo,
+  service->UnregisterServiceWorker(aPrincipalOrigin,
                                    NS_ConvertUTF16toUTF8(aScope));
 
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<ServiceWorkerManagerParent> parent = iter.Get()->GetKey();
     MOZ_ASSERT(parent);
 
     if (parent->ID() != aParentID) {
       nsString scope(aScope);
-      Unused << parent->SendNotifyUnregister(aPrincipalInfo, scope);
+      Unused << parent->SendNotifyUnregister(aPrincipalOrigin);
 #ifdef DEBUG
     } else {
       parentFound = true;
 #endif
     }
   }
 
 #ifdef DEBUG
diff --git a/dom/workers/ServiceWorkerManagerService.h b/dom/workers/ServiceWorkerManagerService.h
--- a/dom/workers/ServiceWorkerManagerService.h
+++ b/dom/workers/ServiceWorkerManagerService.h
@@ -7,23 +7,16 @@
 #ifndef mozilla_dom_ServiceWorkerManagerService_h
 #define mozilla_dom_ServiceWorkerManagerService_h
 
 #include "nsISupportsImpl.h"
 #include "nsHashKeys.h"
 #include "nsTHashtable.h"
 
 namespace mozilla {
-
-class PrincipalOriginAttributes;
-
-namespace ipc {
-class PrincipalInfo;
-} // namespace ipc
-
 namespace dom {
 
 class ServiceWorkerRegistrationData;
 
 namespace workers {
 
 class ServiceWorkerManagerParent;
 
@@ -37,21 +30,21 @@ public:
 
   void RegisterActor(ServiceWorkerManagerParent* aParent);
   void UnregisterActor(ServiceWorkerManagerParent* aParent);
 
   void PropagateRegistration(uint64_t aParentID,
                              ServiceWorkerRegistrationData& aData);
 
   void PropagateSoftUpdate(uint64_t aParentID,
-                           const PrincipalOriginAttributes& aOriginAttributes,
+                           const nsACString& aPrincipalOrigin,
                            const nsAString& aScope);
 
   void PropagateUnregister(uint64_t aParentID,
-                           const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
+                           const nsACString& aPrincipalOrigin,
                            const nsAString& aScope);
 
   void PropagateRemove(uint64_t aParentID, const nsACString& aHost);
 
   void PropagateRemoveAll(uint64_t aParentID);
 
 private:
   ServiceWorkerManagerService();
diff --git a/dom/workers/ServiceWorkerRegistrar.cpp b/dom/workers/ServiceWorkerRegistrar.cpp
--- a/dom/workers/ServiceWorkerRegistrar.cpp
+++ b/dom/workers/ServiceWorkerRegistrar.cpp
@@ -35,16 +35,17 @@ using namespace mozilla::ipc;
 
 namespace mozilla {
 namespace dom {
 
 namespace {
 
 static const char* gSupportedRegistrarVersions[] = {
   SERVICEWORKERREGISTRAR_VERSION,
+  "3",
   "2"
 };
 
 StaticRefPtr<ServiceWorkerRegistrar> gServiceWorkerRegistrar;
 
 } // namespace
 
 NS_IMPL_ISUPPORTS(ServiceWorkerRegistrar,
@@ -151,32 +152,20 @@ ServiceWorkerRegistrar::RegisterServiceW
     NS_WARNING("Failed to register a serviceWorker during shutting down.");
     return;
   }
 
   {
     MonitorAutoLock lock(mMonitor);
     MOZ_ASSERT(mDataLoaded);
 
-    const mozilla::ipc::PrincipalInfo& newPrincipalInfo = aData.principal();
-    MOZ_ASSERT(newPrincipalInfo.type() ==
-               mozilla::ipc::PrincipalInfo::TContentPrincipalInfo);
-
-    const mozilla::ipc::ContentPrincipalInfo& newContentPrincipalInfo =
-      newPrincipalInfo.get_ContentPrincipalInfo();
-
     bool found = false;
     for (uint32_t i = 0, len = mData.Length(); i < len; ++i) {
       if (mData[i].scope() == aData.scope()) {
-        const mozilla::ipc::PrincipalInfo& existingPrincipalInfo =
-          mData[i].principal();
-        const mozilla::ipc::ContentPrincipalInfo& existingContentPrincipalInfo =
-          existingPrincipalInfo.get_ContentPrincipalInfo();
-
-        if (newContentPrincipalInfo == existingContentPrincipalInfo) {
+        if (aData.principalOrigin() == mData[i].principalOrigin()) {
           mData[i] = aData;
           found = true;
           break;
         }
       }
     }
 
     if (!found) {
@@ -200,16 +189,17 @@ ServiceWorkerRegistrar::UnregisterServic
   }
 
   bool deleted = false;
 
   {
     MonitorAutoLock lock(mMonitor);
     MOZ_ASSERT(mDataLoaded);
 
+    // TODO: use principalOrigin
     for (uint32_t i = 0; i < mData.Length(); ++i) {
       if (mData[i].principal() == aPrincipalInfo &&
           mData[i].scope() == aScope) {
         mData.RemoveElementAt(i);
         deleted = true;
         break;
       }
     }
@@ -325,16 +315,25 @@ ServiceWorkerRegistrar::ReadData()
       return rv;                                      \
     }                                                 \
     if (NS_WARN_IF(!hasMoreLines)) {                  \
       return NS_ERROR_FAILURE;                        \
     }
 
     nsAutoCString line;
     if (version.EqualsLiteral(SERVICEWORKERREGISTRAR_VERSION)) {
+      GET_LINE(entry->principalOrigin());
+
+      GET_LINE(entry->scope());
+      GET_LINE(entry->currentWorkerURL());
+
+      nsAutoCString cacheName;
+      GET_LINE(cacheName);
+      CopyUTF8toUTF16(cacheName, entry->cacheName());
+    } else if (version.EqualsLiteral("3")) {
       nsAutoCString suffix;
       GET_LINE(suffix);
 
       PrincipalOriginAttributes attrs;
       if (!attrs.PopulateFromSuffix(suffix)) {
         return NS_ERROR_INVALID_ARG;
       }
 
@@ -592,31 +591,18 @@ ServiceWorkerRegistrar::WriteData()
     return rv;
   }
 
   if (count != buffer.Length()) {
     return NS_ERROR_UNEXPECTED;
   }
 
   for (uint32_t i = 0, len = data.Length(); i < len; ++i) {
-    const mozilla::ipc::PrincipalInfo& info = data[i].principal();
-
-    MOZ_ASSERT(info.type() == mozilla::ipc::PrincipalInfo::TContentPrincipalInfo);
-
-    const mozilla::ipc::ContentPrincipalInfo& cInfo =
-      info.get_ContentPrincipalInfo();
-
-    nsAutoCString suffix;
-    cInfo.attrs().CreateSuffix(suffix);
-
     buffer.Truncate();
-    buffer.Append(suffix.get());
-    buffer.Append('\n');
-
-    buffer.Append(cInfo.spec());
+    buffer.Append(data[i].principalOrigin());
     buffer.Append('\n');
 
     buffer.Append(data[i].scope());
     buffer.Append('\n');
 
     buffer.Append(data[i].currentWorkerURL());
     buffer.Append('\n');
 
diff --git a/dom/workers/ServiceWorkerRegistrar.h b/dom/workers/ServiceWorkerRegistrar.h
--- a/dom/workers/ServiceWorkerRegistrar.h
+++ b/dom/workers/ServiceWorkerRegistrar.h
@@ -11,29 +11,24 @@
 #include "mozilla/Telemetry.h"
 #include "nsClassHashtable.h"
 #include "nsIObserver.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 #define SERVICEWORKERREGISTRAR_FILE "serviceworker.txt"
-#define SERVICEWORKERREGISTRAR_VERSION "3"
+#define SERVICEWORKERREGISTRAR_VERSION "4"
 #define SERVICEWORKERREGISTRAR_TERMINATOR "#"
 #define SERVICEWORKERREGISTRAR_TRUE "true"
 #define SERVICEWORKERREGISTRAR_FALSE "false"
 
 class nsIFile;
 
 namespace mozilla {
-
-namespace ipc {
-class PrincipalInfo;
-} // namespace ipc
-
 namespace dom {
 
 class ServiceWorkerRegistrationData;
 
 class ServiceWorkerRegistrar : public nsIObserver
 {
   friend class ServiceWorkerRegistrarSaveDataRunnable;
 
@@ -47,17 +42,17 @@ public:
 
   void DataSaved();
 
   static already_AddRefed<ServiceWorkerRegistrar> Get();
 
   void GetRegistrations(nsTArray<ServiceWorkerRegistrationData>& aValues);
 
   void RegisterServiceWorker(const ServiceWorkerRegistrationData& aData);
-  void UnregisterServiceWorker(const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
+  void UnregisterServiceWorker(const nsACString& aPrincipalOrigin,
                                const nsACString& aScope);
   void RemoveAll();
 
 protected:
   // These methods are protected because we test this class using gTest
   // subclassing it.
   void LoadData();
   void SaveData();
diff --git a/dom/workers/ServiceWorkerRegistrarTypes.ipdlh b/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
--- a/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
+++ b/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
@@ -11,13 +11,14 @@ namespace dom {
 
 struct ServiceWorkerRegistrationData
 {
   nsCString scope;
   nsCString currentWorkerURL;
 
   nsString cacheName;
 
+  nsCString principalOrigin;
   PrincipalInfo principal;
 };
 
 } // namespace dom
 } // namespace mozilla
