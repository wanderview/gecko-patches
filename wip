# HG changeset patch
# Parent 75a5de26ba4c91346bae8e4b2876d7225b52e49a
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -56,16 +56,24 @@
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "BackgroundChild.h"
+
+// BackgroundChild.h indirectly brings in windows.h via the chromium ipc
+// headers.  This breaks things here due API macro collision.
+#ifdef XP_WIN
+#undef CreateFile
+#endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -368,16 +376,21 @@ LoadRuntimeAndContextOptions(const char*
                                                      contentContextOptions,
                                                      chromeContextOptions);
 
   if (rts) {
     rts->UpdateAllWorkerRuntimeAndContextOptions();
   }
 }
 
+static int gettid()
+{
+  return pthread_mach_thread_np(pthread_self());
+}
+
 #ifdef JS_GC_ZEAL
 void
 LoadGCZealOptions(const char* /* aPrefName */, void* /* aClosure */)
 {
   AssertIsOnMainThread();
 
   RuntimeService* rts = RuntimeService::GetService();
   if (!rts && !gRuntimeServiceDuringInit) {
@@ -1524,25 +1537,31 @@ RuntimeService::ScheduleWorker(JSContext
   int32_t priority = aWorkerPrivate->IsChromeWorker() ?
                      nsISupportsPriority::PRIORITY_NORMAL :
                      nsISupportsPriority::PRIORITY_LOW;
 
   if (NS_FAILED(thread->SetPriority(priority))) {
     NS_WARNING("Could not set the thread's priority!");
   }
 
+  // XXX Fire worker runnable to attach PBackground here. Execute
+  //     WorkerThreadPrimaryRunnable and SetAcceptingNonWorkerRunnables(false)
+  //     in PBackground callback.
+
   nsCOMPtr<nsIRunnable> runnable =
     new WorkerThreadPrimaryRunnable(aWorkerPrivate, thread, JS_GetParentRuntime(aCx));
   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
     UnregisterWorker(aCx, aWorkerPrivate);
     JS_ReportError(aCx, "Could not dispatch to thread!");
     return false;
   }
 
 #ifdef DEBUG
+  printf_stderr("### ### [%d][%p] RuntimeService::ScheduleWorker() calling SetAcceptingNonWorkerRunnables(false)\n",
+                gettid(), this);
   thread->SetAcceptingNonWorkerRunnables(false);
 #endif
 
   return true;
 }
 
 // static
 void
@@ -2186,16 +2205,18 @@ RuntimeService::ForgetSharedWorker(Worke
 
 void
 RuntimeService::NoteIdleThread(WorkerThread* aThread)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aThread);
 
 #ifdef DEBUG
+  printf_stderr("### ### [%d][%p] RuntimeService::NoteIdleThread() calling SetAcceptingNonWorkerRunnables(true)\n",
+                gettid(), this);
   aThread->SetAcceptingNonWorkerRunnables(true);
 #endif
 
   static TimeDuration timeout =
     TimeDuration::FromSeconds(IDLE_THREAD_TIMEOUT_SEC);
 
   TimeStamp expirationTime = TimeStamp::Now() + timeout;
 
@@ -2377,75 +2398,105 @@ void
 RuntimeService::WorkerThread::SetWorker(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(PR_GetCurrentThread() == mThread);
   MOZ_ASSERT_IF(aWorkerPrivate, !mWorkerPrivate);
   MOZ_ASSERT_IF(!aWorkerPrivate, mWorkerPrivate);
 
   // No need to lock here because mWorkerPrivate is only modified on mThread.
 
+  printf_stderr("### ### [%d][%p] WorkerThread::SetWorker() aWorkerPrivate=%p mWorkerPrivate=%p\n",
+                gettid(), this, aWorkerPrivate, mWorkerPrivate);
+
   if (mWorkerPrivate) {
     MOZ_ASSERT(mObserver);
 
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(RemoveObserver(mObserver)));
 
     mObserver = nullptr;
+    printf_stderr("### ### [%d][%p]  WorkerThread::SetWorker() calling SetThread(null) aWorkerPrivate=%p mWorkerPrivate=%p\n",
+                  gettid(), this, aWorkerPrivate, mWorkerPrivate);
     mWorkerPrivate->SetThread(nullptr);
   }
 
   mWorkerPrivate = aWorkerPrivate;
 
   if (mWorkerPrivate) {
+    printf_stderr("### ### [%d][%p] WorkerThread::SetWorker() calling SetThread(%p) aWorkerPrivate=%p mWorkerPrivate=%p\n",
+                  gettid(), this, this, aWorkerPrivate, mWorkerPrivate);
     mWorkerPrivate->SetThread(this);
 
     nsRefPtr<Observer> observer = new Observer(mWorkerPrivate);
 
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(AddObserver(observer)));
 
     mObserver.swap(observer);
   }
 }
 
 NS_IMPL_ISUPPORTS_INHERITED0(RuntimeService::WorkerThread, nsThread)
 
 NS_IMETHODIMP
 RuntimeService::WorkerThread::Dispatch(nsIRunnable* aRunnable, uint32_t aFlags)
 {
+  printf_stderr("### ### [%d][%p] WorkerThread::Dispatch()\n",
+                gettid(), this);
+
   // May be called on any thread!
 
 #ifdef DEBUG
   if (PR_GetCurrentThread() == mThread) {
+    printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() on worker thread, mWorkerPrivate:%p\n",
+                  gettid(), this, mWorkerPrivate);
+    if (!mWorkerPrivate) {
+      printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() skip mWorkerPrivate assert, mWorkerPrivate:%p\n",
+                    gettid(), this, mWorkerPrivate);
+    } else {
     MOZ_ASSERT(mWorkerPrivate);
     mWorkerPrivate->AssertIsOnWorkerThread();
+    }
   }
   else if (aRunnable && !IsAcceptingNonWorkerRunnables()) {
+    printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() not on worker thread and worker started\n",
+                  gettid(), this);
     // Only enforce cancelable runnables after we've started the worker loop.
     nsCOMPtr<nsICancelableRunnable> cancelable = do_QueryInterface(aRunnable);
+    if (!cancelable) {
+      printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() skip cancelable assert\n",
+                    gettid(), this);
+    } else {
     MOZ_ASSERT(cancelable,
                "Should have been wrapped by the worker's event target!");
+    }
   }
 #endif
 
   // Workers only support asynchronous dispatch for now.
   if (NS_WARN_IF(aFlags != NS_DISPATCH_NORMAL)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsIRunnable* runnableToDispatch;
   nsRefPtr<WorkerRunnable> workerRunnable;
 
   if (aRunnable && PR_GetCurrentThread() == mThread) {
+    printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() on worker thread and wrap runnable, mWorkerPrivate:%p\n",
+                  gettid(), this, mWorkerPrivate);
     // No need to lock here because mWorkerPrivate is only modified on mThread.
     workerRunnable = mWorkerPrivate->MaybeWrapAsWorkerRunnable(aRunnable);
     runnableToDispatch = workerRunnable;
   }
   else {
+    printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() not on worker thread and don't wrap runnable\n",
+                  gettid(), this);
     runnableToDispatch = aRunnable;
   }
 
+  printf_stderr("### ### [%d][%p] WorkerThread::Dispatch() calling nsThread::Dispatch\n",
+                gettid(), this);
   nsresult rv = nsThread::Dispatch(runnableToDispatch, NS_DISPATCH_NORMAL);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
@@ -2504,30 +2555,66 @@ LogViolationDetailsRunnable::Run()
   nsRefPtr<MainThreadStopSyncLoopRunnable> response =
     new MainThreadStopSyncLoopRunnable(mWorkerPrivate, mSyncLoopTarget.forget(),
                                        true);
   MOZ_ALWAYS_TRUE(response->Dispatch(nullptr));
 
   return NS_OK;
 }
 
+class WorkerBackgroundChildPrimer MOZ_FINAL :
+  public nsIIPCBackgroundChildCreateCallback
+{
+public:
+  WorkerBackgroundChildPrimer()
+  { }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~WorkerBackgroundChildPrimer()
+  { }
+
+  virtual void
+  ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
+  }
+
+  virtual void
+  ActorFailed() MOZ_OVERRIDE
+  {
+    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
+  }
+};
+
+NS_IMPL_ISUPPORTS(WorkerBackgroundChildPrimer, nsIIPCBackgroundChildCreateCallback)
+
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::Run()
 {
+  using mozilla::ipc::BackgroundChild;
+
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
 
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new WorkerBackgroundChildPrimer();
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Worker failed to create PBackgroundChild!");
+  }
+
   char stackBaseGuess;
 
   nsAutoCString threadName;
   threadName.AssignLiteral("WebWorker '");
   threadName.Append(NS_LossyConvertUTF16toASCII(mWorkerPrivate->ScriptURL()));
   threadName.Append('\'');
 
   profiler_register_thread(threadName.get(), &stackBaseGuess);
@@ -2567,16 +2654,19 @@ WorkerThreadPrimaryRunnable::Run()
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
+    // XXX Detach PBackground from thread here?
+    BackgroundChild::DetachFromCurrentThread();
+
     // Destroy the main context.  This will unroot the main worker global and
     // GC.  This is not the last JSContext (WorkerJSRuntime maintains an
     // internal JSContext).
     JS_DestroyContext(cx);
 
     // Now WorkerJSRuntime goes out of scope and its destructor will shut
     // down the cycle collector and destroy the final JSContext.  This
     // breaks any remaining cycles and collects the C++ and JS objects
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -76,39 +76,36 @@
 #include "Navigator.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "SharedWorker.h"
 #include "WorkerFeature.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
-#include "nsIIPCBackgroundChildCreateCallback.h"
-#include "BackgroundChild.h"
-
-// BackgroundChild.h indirectly brings in windows.h via the chromium ipc
-// headers.  This breaks things here due API macro collision.
-#ifdef XP_WIN
-#undef CreateFile
-#endif
 
 // JS_MaybeGC will run once every second during normal execution.
 #define PERIODIC_GC_TIMER_DELAY_SEC 1
 
 // A shrinking GC will run five seconds after the last event is processed.
 #define IDLE_GC_TIMER_DELAY_SEC 5
 
 #define PREF_WORKERS_ENABLED "dom.workers.enabled"
 
 #ifdef WORKER_LOGGING
 #define LOG(_args) do { printf _args ; fflush(stdout); } while (0)
 #else
 #define LOG(_args) do { } while (0)
 #endif
 
+static int gettid()
+{
+  return pthread_mach_thread_np(pthread_self());
+}
+
 using namespace mozilla;
 using namespace mozilla::dom;
 USING_WORKERS_NAMESPACE
 
 MOZ_DEFINE_MALLOC_SIZE_OF(JsWorkerMallocSizeOf)
 
 #ifdef DEBUG
 
@@ -2272,26 +2269,30 @@ WorkerPrivateParent<Derived>::MaybeWrapA
 {
   // May be called on any thread!
 
   MOZ_ASSERT(aRunnable);
 
   nsRefPtr<WorkerRunnable> workerRunnable =
     WorkerRunnable::FromRunnable(aRunnable);
   if (workerRunnable) {
+    printf_stderr("### ### [%d][%p] MaybeWrapAsWorkerRunnable() no need to wrap\n",
+                  gettid(), this);
     return workerRunnable.forget();
   }
 
   nsCOMPtr<nsICancelableRunnable> cancelable = do_QueryInterface(aRunnable);
   if (!cancelable) {
     MOZ_CRASH("All runnables destined for a worker thread must be cancelable!");
   }
 
   workerRunnable =
     new ExternalRunnableWrapper(ParentAsWorkerPrivate(), cancelable);
+  printf_stderr("### ### [%d][%p] MaybeWrapAsWorkerRunnable() create wrapper\n",
+                gettid(), this);
   return workerRunnable.forget();
 }
 
 template <class Derived>
 already_AddRefed<nsIEventTarget>
 WorkerPrivateParent<Derived>::GetEventTarget()
 {
   WorkerPrivate* self = ParentAsWorkerPrivate();
@@ -5641,49 +5642,19 @@ WorkerPrivate::CycleCollectInternal(JSCo
 
   if (aCollectChildren) {
     for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
       mChildWorkers[index]->CycleCollect(aCx, /* dummy = */ false);
     }
   }
 }
 
-class WorkerBackgroundChildPrimer MOZ_FINAL :
-  public nsIIPCBackgroundChildCreateCallback
-{
-public:
-  WorkerBackgroundChildPrimer()
-  { }
-
-  NS_DECL_ISUPPORTS
-
-private:
-  ~WorkerBackgroundChildPrimer()
-  { }
-
-  virtual void
-  ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE
-  {
-    MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
-  }
-
-  virtual void
-  ActorFailed() MOZ_OVERRIDE
-  {
-    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
-  }
-};
-
-NS_IMPL_ISUPPORTS(WorkerBackgroundChildPrimer, nsIIPCBackgroundChildCreateCallback)
-
 void
 WorkerPrivate::SetThread(nsIThread* aThread)
 {
-  using mozilla::ipc::BackgroundChild;
-
 #ifdef DEBUG
   if (aThread) {
     bool isOnCurrentThread;
     MOZ_ASSERT(NS_SUCCEEDED(aThread->IsOnCurrentThread(&isOnCurrentThread)));
     MOZ_ASSERT(isOnCurrentThread);
 
     MOZ_ASSERT(!mPRThread);
     mPRThread = PRThreadFromThread(aThread);
@@ -5700,34 +5671,27 @@ WorkerPrivate::SetThread(nsIThread* aThr
     MutexAutoLock lock(mMutex);
 
     if (aThread) {
       MOZ_ASSERT(!mThread);
       MOZ_ASSERT(mStatus == Pending);
 
       mThread = aThread;
 
-      nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
-        new WorkerBackgroundChildPrimer();
-      if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
-        MOZ_CRASH("Worker failed to create PBackgroundChild!");
-      }
-
       if (!mPreStartRunnables.IsEmpty()) {
         for (uint32_t index = 0; index < mPreStartRunnables.Length(); index++) {
           MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mThread->Dispatch(
                                                       mPreStartRunnables[index],
                                                       NS_DISPATCH_NORMAL)));
         }
         mPreStartRunnables.Clear();
       }
     }
     else {
       MOZ_ASSERT(mThread);
-      BackgroundChild::DetachFromCurrentThread();
       mThread.swap(doomedThread);
     }
   }
 }
 
 WorkerCrossThreadDispatcher*
 WorkerPrivate::GetCrossThreadDispatcher()
 {
diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -373,17 +373,17 @@ public:
   }
 
   ChildImpl()
   : mBoundThread(nullptr)
   {
     AssertIsOnMainThread();
   }
 
-  NS_INLINE_DECL_REFCOUNTING(ChildImpl)
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChildImpl)
 
 private:
   // Forwarded from BackgroundChild.
   static void
   Startup();
 
   // Forwarded from BackgroundChild.
   static PBackgroundChild*
