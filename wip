# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  458a6187de5d8058b8176bc9afa6228e8d144e4f

diff --git a/dom/serviceworkers/ServiceWorkerPrivate.cpp b/dom/serviceworkers/ServiceWorkerPrivate.cpp
--- a/dom/serviceworkers/ServiceWorkerPrivate.cpp
+++ b/dom/serviceworkers/ServiceWorkerPrivate.cpp
@@ -1731,21 +1731,17 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
     swm->GetRegistration(mInfo->Principal(), mInfo->Scope());
 
   // Its possible the registration is removed between starting the interception
   // and actually dispatching the fetch event.  In these cases we simply
   // want to restart the original network request.  Since this is a normal
   // condition we handle the reset here instead of returning an error which
   // would in turn trigger a console report.
   if (!registration) {
-    nsresult rv = aChannel->ResetInterception();
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to resume intercepted network request");
-      aChannel->CancelInterception(rv);
-    }
+    FailFetchEvent(aChannel);
     return NS_OK;
   }
 
   // Handle Fetch algorithm - step 16. If the service worker didn't register
   // any fetch event handlers, then abort the interception and maybe trigger
   // the soft update algorithm.
   if (!mInfo->HandlesFetch()) {
     FetchEventLikelyToSucceed(aChannel);
@@ -1760,19 +1756,21 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
     registration->MaybeScheduleTimeCheckAndUpdate();
 
     return NS_OK;
   }
 
   // if the ServiceWorker script fails to load for some reason, just resume
   // the original channel.
   nsCOMPtr<nsIRunnable> failRunnable =
-    NewRunnableMethod("nsIInterceptedChannel::ResetInterception",
-                      aChannel,
-                      &nsIInterceptedChannel::ResetInterception);
+    NewRunnableMethod<nsCOMPtr<nsIInterceptedChannel>>(
+      "ServiceWorkerPrivate::FailFetchEvent",
+      this,
+      &ServiceWorkerPrivate::FailFetchEvent,
+      aChannel);
 
   aChannel->SetLaunchServiceWorkerStart(TimeStamp::Now());
   aChannel->SetDispatchFetchEventStart(TimeStamp::Now());
 
   bool newWorkerCreated = false;
   nsresult rv = SpawnWorkerIfNeeded(FetchEvent,
                                     failRunnable,
                                     &newWorkerCreated,
@@ -2319,16 +2317,35 @@ ServiceWorkerPrivate::SetHandlesFetch(bo
   if (NS_WARN_IF(!mInfo)) {
     return;
   }
 
   mInfo->SetHandlesFetch(aValue);
 }
 
 void
+ServiceWorkerPrivate::FailFetchEvent(nsIInterceptedChannel* aChannel)
+{
+  nsCOMPtr<nsIChannel> internal;
+  Unused << aChannel->GetChannel(getter_AddRefs(internal));
+  if (internal && !nsContentUtils::IsNonSubresourceRequest(internal)) {
+    nsCOMPtr<nsILoadInfo> loadInfo = internal->GetLoadInfo();
+    if (loadInfo) {
+      loadInfo->ClearController();
+    }
+  }
+
+  nsresult rv = aChannel->ResetInterception();
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to resume intercepted network request");
+    aChannel->CancelInterception(rv);
+  }
+}
+
+void
 ServiceWorkerPrivate::FetchEventLikelyToSucceed(nsIInterceptedChannel* aChannel)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   NS_ENSURE_TRUE_VOID(swm);
 
   swm->FetchEventLikelyToSucceed(aChannel, mInfo->Descriptor());
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.h b/dom/serviceworkers/ServiceWorkerPrivate.h
--- a/dom/serviceworkers/ServiceWorkerPrivate.h
+++ b/dom/serviceworkers/ServiceWorkerPrivate.h
@@ -201,16 +201,19 @@ private:
                       bool* aNewWorkerCreated = nullptr,
                       nsILoadGroup* aLoadGroup = nullptr);
 
   ~ServiceWorkerPrivate();
 
   already_AddRefed<KeepAliveToken>
   CreateEventKeepAliveToken();
 
+  void
+  FailFetchEvent(nsIInterceptedChannel* aChannel);
+
   // The info object owns us. It is possible to outlive it for a brief period
   // of time if there are pending waitUntil promises, in which case it
   // will be null and |SpawnWorkerIfNeeded| will always fail.
   ServiceWorkerInfo* MOZ_NON_OWNING_REF mInfo;
 
   // The WorkerPrivate object can only be closed by this class or by the
   // RuntimeService class if gecko is shutting down. Closing the worker
   // multiple times is OK, since the second attempt will be a no-op.
