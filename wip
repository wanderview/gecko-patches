# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  18b5a7a5d833f09b1f1e5cc45f4c0ff6235a1d5e

diff --git a/dom/clients/ClientHandleChild.cpp b/dom/clients/ClientHandleChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientHandleChild.cpp
@@ -0,0 +1,20 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleChild.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+ClientHandleChild::ClientHandleChild(const ClientHandleConstructorArgs& aArgs)
+{
+  // TODO
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientHandleChild.h b/dom/clients/ClientHandleChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientHandleChild.h
@@ -0,0 +1,25 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleChild_h
+#define _mozilla_dom_ClientHandleChild_h
+
+#include "mozilla/dom/PClientHandleChild.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandleConstructorArgs;
+
+class ClientHandleChild final : public PClientHandleChild
+{
+public:
+  explicit ClientHandleChild(const ClientHandleConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleChild_h
diff --git a/dom/clients/ClientHandleParent.cpp b/dom/clients/ClientHandleParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientHandleParent.cpp
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientHandleParent.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+mozilla::ipc::IPCResult
+ClientHandleParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientHandleParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+ClientHandleParent::ClientHandleParent(const ClientHandleConstructorArgs& aArgs)
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientHandleParent.h b/dom/clients/ClientHandleParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientHandleParent.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientHandleParent_h
+#define _mozilla_dom_ClientHandleParent_h
+
+#include "mozilla/dom/PClientHandleParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientHandleConstructorArgs;
+
+class ClientHandleParent final : public PClientHandleParent
+{
+  // PClientHandleParent
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientHandleParent(const ClientHandleConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientHandleParent_h
diff --git a/dom/clients/ClientIPCTypes.ipdlh b/dom/clients/ClientIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientIPCTypes.ipdlh
@@ -0,0 +1,21 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+using ClientType from "mozilla/dom/ClientType.h";
+
+namespace mozilla {
+namespace dom {
+
+struct ClientHandleConstructorArgs
+{
+  bool todo;
+};
+
+struct ClientSourceConstructorArgs
+{
+  ClientType type;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientManager.cpp b/dom/clients/ClientManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManager.cpp
@@ -0,0 +1,226 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManager.h"
+
+#include "ClientManagerChild.h"
+#include "ClientSource.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "prthread.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::PBackgroundChild;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::Terminating;
+using mozilla::dom::workers::WorkerHolderToken;
+
+namespace {
+
+uint32_t kBadThreadLocalIndex = -1;
+uint32_t sClientManagerThreadLocalIndex = kBadThreadLocalIndex;
+
+} // anonymous namespace
+
+class ClientManager::PBackgroundCreateCallback final : public nsIIPCBackgroundChildCreateCallback
+{
+  RefPtr<ClientManager> mManager;
+
+  ~PBackgroundCreateCallback()
+  {
+  }
+
+public:
+  explicit PBackgroundCreateCallback(ClientManager* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(mManager);
+  }
+
+  void
+  ActorCreated(PBackgroundChild* aActor) override
+  {
+    mManager->PBackgroundActorCreated(aActor);
+    mManager = nullptr;
+  }
+
+  void
+  ActorFailed() override
+  {
+    mManager->Shutdown();
+    mManager = nullptr;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ClientManager::PBackgroundCreateCallback,
+                  nsIIPCBackgroundChildCreateCallback);
+
+ClientManager::ClientManager()
+  : mActor(nullptr)
+  , mShutdown(false)
+{
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    PBackgroundActorCreated(actor);
+    return;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+  RefPtr<PBackgroundCreateCallback> cb = new PBackgroundCreateCallback(this);
+  bool ok = BackgroundChild::GetOrCreateForCurrentThread(cb);
+  if (NS_WARN_IF(!ok)) {
+    Shutdown();
+  }
+}
+
+ClientManager::~ClientManager()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(mPendingSourceList.IsEmpty());
+
+  Shutdown();
+
+  MOZ_DIAGNOSTIC_ASSERT(this == PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+  PRStatus status =
+    PR_SetThreadPrivate(sClientManagerThreadLocalIndex, nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+}
+
+void
+ClientManager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (mShutdown) {
+    return;
+  }
+  mShutdown = true;
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Shutdown();
+  }
+
+  if (!mActor) {
+    return;
+  }
+  mActor->RevokeManager(this);
+  mActor->MaybeStartTeardown();
+  mActor = nullptr;
+}
+
+void
+ClientManager::RevokeActor(ClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(mActor);
+  MOZ_ASSERT(mActor == aActor);
+  mActor->RevokeManager(this);
+  mActor = nullptr;
+}
+
+void
+ClientManager::ForgetSource(ClientSource* aSource)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  mPendingSourceList.RemoveElement(aSource);
+}
+
+void
+ClientManager::PBackgroundActorCreated(PBackgroundChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_ASSERT(aActor);
+
+  if (mShutdown) {
+    return;
+  }
+
+  RefPtr<WorkerHolderToken> workerHolderToken;
+  if (!NS_IsMainThread()) {
+    workerHolderToken =
+      WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Terminating);
+    if (NS_WARN_IF(!workerHolderToken)) {
+      Shutdown();
+      return;
+    }
+  }
+
+  ClientManagerChild* actor = new ClientManagerChild(this, workerHolderToken);
+  PClientManagerChild *sentActor = aActor->SendPClientManagerConstructor(actor);
+  if (NS_WARN_IF(!sentActor)) {
+    Shutdown();
+    return;
+  }
+  MOZ_ASSERT(sentActor == actor);
+
+  mActor = static_cast<ClientManagerChild*>(actor);
+
+  nsTArray<ClientSource*> pendingSourceList;
+  mPendingSourceList.SwapElements(pendingSourceList);
+  for (ClientSource* source : pendingSourceList) {
+    source->Activate(mActor);
+  }
+}
+
+// static
+already_AddRefed<ClientManager>
+ClientManager::GetOrCreateCurrentThreadInstance()
+{
+  if (sClientManagerThreadLocalIndex == kBadThreadLocalIndex) {
+    MOZ_ASSERT(NS_IsMainThread());
+    PRStatus status =
+      PR_NewThreadPrivateIndex(&sClientManagerThreadLocalIndex, nullptr);
+    MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+  }
+
+  MOZ_ASSERT(sClientManagerThreadLocalIndex != kBadThreadLocalIndex);
+  RefPtr<ClientManager> cm =
+    static_cast<ClientManager*>(PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
+
+  if (!cm) {
+    cm = new ClientManager();
+
+    PRStatus status =
+      PR_SetThreadPrivate(sClientManagerThreadLocalIndex, cm.get());
+    MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+  }
+
+  MOZ_ASSERT(cm);
+  return cm.forget();
+}
+
+UniquePtr<ClientSource>
+ClientManager::CreateSource()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientManager);
+
+  if (mShutdown) {
+    return nullptr;
+  }
+
+  UniquePtr<ClientSource> source(new ClientSource(this));
+
+  if (mActor) {
+    source->Activate(mActor);
+  } else {
+    mPendingSourceList.AppendElement(source.get());
+  }
+
+  return Move(source);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientManager.h b/dom/clients/ClientManager.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManager.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManager_h
+#define _mozilla_dom_ClientManager_h
+
+#include "mozilla/dom/PClientManager.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace ipc {
+class PBackgroundChild;
+} // namespace ipc
+namespace dom {
+
+class ClientManagerChild;
+class ClientSource;
+
+class ClientManager final
+{
+  friend class ClientManagerChild;
+  friend class ClientSource;
+  class PBackgroundCreateCallback;
+
+  ClientManagerChild* mActor;
+  nsTArray<ClientSource*> mPendingSourceList;
+  bool mShutdown;
+
+  ClientManager();
+  ~ClientManager();
+
+  void
+  Shutdown();
+
+  void
+  PBackgroundActorCreated(mozilla::ipc::PBackgroundChild* aActor);
+
+  // Private methods called by ClientManagerChild
+  void
+  RevokeActor(ClientManagerChild* aActor);
+
+  // Private methods called by ClientSource
+  void
+  ForgetSource(ClientSource* aSource);
+
+public:
+  static already_AddRefed<ClientManager>
+  GetOrCreateCurrentThreadInstance();
+
+  UniquePtr<ClientSource>
+  CreateSource();
+
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/ClientManagerActors.cpp b/dom/clients/ClientManagerActors.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerActors.cpp
@@ -0,0 +1,41 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+#include "ClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+PClientManagerChild*
+AllocClientManagerChild()
+{
+  MOZ_ASSERT_UNREACHABLE("Default ClientManagerChild allocator should not be invoked");
+  return nullptr;
+}
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientManagerParent*
+AllocClientManagerParent()
+{
+  return new ClientManagerParent();
+}
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientManagerActors.h b/dom/clients/ClientManagerActors.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerActors.h
@@ -0,0 +1,31 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerActors_h
+#define _mozilla_dom_ClientManagerActors_h
+
+namespace mozilla {
+namespace dom {
+
+class PClientManagerChild;
+class PClientManagerParent;
+
+PClientManagerChild*
+AllocClientManagerChild();
+
+bool
+DeallocClientManagerChild(PClientManagerChild* aActor);
+
+PClientManagerParent*
+AllocClientManagerParent();
+
+bool
+DeallocClientManagerParent(PClientManagerParent* aActor);
+
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerActors_h
diff --git a/dom/clients/ClientManagerChild.cpp b/dom/clients/ClientManagerChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerChild.cpp
@@ -0,0 +1,98 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerChild.h"
+
+#include "ClientHandleChild.h"
+#include "ClientManager.h"
+#include "ClientSourceChild.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::WorkerHolderToken;
+
+void
+ClientManagerChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->RemoveListener(this);
+    mWorkerHolderToken = nullptr;
+
+  }
+
+  if (mManager) {
+    mManager->RevokeActor(this);
+    MOZ_ASSERT(!mManager);
+  }
+}
+
+PClientHandleChild*
+ClientManagerChild::AllocPClientHandleChild(const ClientHandleConstructorArgs& aArgs)
+{
+  return new ClientHandleChild(aArgs);
+}
+
+bool
+ClientManagerChild::DeallocPClientHandleChild(PClientHandleChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientSourceChild*
+ClientManagerChild::AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceChild(aArgs, mWorkerHolderToken);
+}
+
+bool
+ClientManagerChild::DeallocPClientSourceChild(PClientSourceChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+void
+ClientManagerChild::WorkerShuttingDown()
+{
+  MaybeStartTeardown();
+}
+
+ClientManagerChild::ClientManagerChild(ClientManager* aManager,
+                                       WorkerHolderToken* aWorkerHolderToken)
+  : mManager(aManager)
+  , mWorkerHolderToken(aWorkerHolderToken)
+  , mTeardownStarted(false)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolderToken);
+
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->AddListener(this);
+  }
+}
+
+void
+ClientManagerChild::RevokeManager(ClientManager* aManager)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mManager == aManager);
+  mManager = nullptr;
+}
+
+void
+ClientManagerChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientManagerChild.h b/dom/clients/ClientManagerChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerChild.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerChild_h
+#define _mozilla_dom_ClientManagerChild_h
+
+#include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerChild final : public PClientManagerChild
+                               , public mozilla::dom::workers::WorkerHolderToken::Listener
+{
+  // Weak reference.  The ClientManager will call RevokeManager() when
+  // it is destroyed.
+  ClientManager* mManager;
+
+  RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
+  bool mTeardownStarted;
+
+  // PClientManagerChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleChild*
+  AllocPClientHandleChild(const ClientHandleConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleChild(PClientHandleChild* aActor) override;
+
+  PClientSourceChild*
+  AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceChild(PClientSourceChild* aActor) override;
+
+  // WorkerHolderToken::Listener interface
+  void
+  WorkerShuttingDown() override;
+
+public:
+  ClientManagerChild(ClientManager* aManager,
+                     mozilla::dom::workers::WorkerHolderToken* aWorkerHolderToken);
+
+  void
+  RevokeManager(ClientManager* aManager);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerChild_h
diff --git a/dom/clients/ClientManagerParent.cpp b/dom/clients/ClientManagerParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerParent.cpp
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientManagerParent.h"
+
+#include "ClientHandleParent.h"
+#include "ClientSourceParent.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+IPCResult
+ClientManagerParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientManagerParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+PClientHandleParent*
+ClientManagerParent::AllocPClientHandleParent(const ClientHandleConstructorArgs& aArgs)
+{
+  return new ClientHandleParent(aArgs);
+}
+
+bool
+ClientManagerParent::DeallocPClientHandleParent(PClientHandleParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientSourceParent*
+ClientManagerParent::AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+{
+  return new ClientSourceParent(aArgs);
+}
+
+bool
+ClientManagerParent::DeallocPClientSourceParent(PClientSourceParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientManagerParent.h b/dom/clients/ClientManagerParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientManagerParent.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientManagerParent_h
+#define _mozilla_dom_ClientManagerParent_h
+
+#include "mozilla/dom/PClientManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientManagerParent final : public PClientManagerParent
+{
+private:
+  // PClientManagerParent interface
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  PClientHandleParent*
+  AllocPClientHandleParent(const ClientHandleConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientHandleParent(PClientHandleParent* aActor) override;
+
+  PClientSourceParent*
+  AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientSourceParent(PClientSourceParent* aActor) override;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientManagerParent_h
diff --git a/dom/clients/ClientSource.cpp b/dom/clients/ClientSource.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSource.cpp
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSource.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientSource::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (mShutdown) {
+    return;
+  }
+  mShutdown = true;
+
+  if (mActor) {
+    mActor->MaybeStartTeardown();
+  }
+}
+
+ClientSource::ClientSource(ClientManager* aManager)
+  : mManager(aManager)
+  , mActor(nullptr)
+{
+  MOZ_ASSERT(mManager);
+}
+
+void
+ClientSource::Activate(PClientManagerChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_ASSERT(!mActor);
+
+  if (mShutdown) {
+    return;
+  }
+
+  // TODO
+  ClientSourceConstructorArgs args;
+
+  PClientSourceChild* actor = aActor->SendPClientSourceConstructor(args);
+  if (!actor) {
+    Shutdown();
+    return;
+  }
+
+  mActor = static_cast<ClientSourceChild*>(actor);
+  mActor->SetSource(this);
+
+  // TODO: complete any pending operations
+}
+
+void
+ClientSource::RevokeActor(ClientSourceChild* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  MOZ_ASSERT(mActor);
+  mActor->RevokeSource(this);
+  mActor = nullptr;
+}
+
+ClientSource::~ClientSource()
+{
+  mManager->ForgetSource(this);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientSource.h b/dom/clients/ClientSource.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSource.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSource_h
+#define _mozilla_dom_ClientSource_h
+
+namespace mozilla {
+namespace dom {
+
+class ClientManager;
+class ClientSourceChild;
+class PClientManagerChild;
+
+class ClientSource final
+{
+  friend class ClientManager;
+  friend class ClientSourceChild;
+
+  NS_DECL_OWNINGTHREAD
+
+  RefPtr<ClientManager> mManager;
+  ClientSourceChild* mActor;
+  bool mShutdown;
+
+  void
+  Shutdown();
+
+  // Private methods called by ClientManager
+  explicit ClientSource(ClientManager* aManager);
+
+  void
+  Activate(PClientManagerChild* aActor);
+
+  // Private methods called by ClientSourceChild
+  void
+  RevokeActor(ClientSourceChild* aActor);
+
+public:
+  ~ClientSource();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSource_h
diff --git a/dom/clients/ClientSourceChild.cpp b/dom/clients/ClientSourceChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSourceChild.cpp
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceChild.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::dom::workers::WorkerHolderToken;
+
+void
+ClientSourceChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->RemoveListener(this);
+    mWorkerHolderToken = nullptr;
+  }
+
+  if (mSource) {
+    mSource->RevokeActor(this);
+    MOZ_ASSERT(!mSource);
+  }
+}
+
+void
+ClientSourceChild::WorkerShuttingDown()
+{
+  MaybeStartTeardown();
+}
+
+ClientSourceChild::ClientSourceChild(const ClientSourceConstructorArgs& aArgs,
+                                     WorkerHolderToken* aWorkerHolderToken)
+  : mWorkerHolderToken(aWorkerHolderToken)
+  , mSource(nullptr)
+  , mTeardownStarted(false)
+{
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolderToken);
+
+  if (mWorkerHolderToken) {
+    mWorkerHolderToken->AddListener(this);
+  }
+}
+
+void
+ClientSourceChild::SetSource(ClientSource* aSource)
+{
+  MOZ_ASSERT(!mSource);
+  mSource = aSource;
+  MOZ_ASSERT(mSource);
+}
+
+void
+ClientSourceChild::RevokeSource(ClientSource* aSource)
+{
+  MOZ_ASSERT(mSource);
+  MOZ_ASSERT(mSource == aSource);
+  mSource = nullptr;
+}
+
+void
+ClientSourceChild::MaybeStartTeardown()
+{
+  if (mTeardownStarted) {
+    return;
+  }
+  mTeardownStarted = true;
+  SendTeardown();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientSourceChild.h b/dom/clients/ClientSourceChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSourceChild.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceChild_h
+#define _mozilla_dom_ClientSourceChild_h
+
+#include "mozilla/dom/PClientSourceChild.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+class ClientSourceConstructorArgs;
+
+class ClientSourceChild final : public PClientSourceChild
+                              , public mozilla::dom::workers::WorkerHolderToken::Listener
+{
+  RefPtr<mozilla::dom::workers::WorkerHolderToken> mWorkerHolderToken;
+  ClientSource* mSource;
+  bool mTeardownStarted;
+
+  // PClientSourceChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  // WorkerHolderToken::Listener interface
+  void
+  WorkerShuttingDown() override;
+
+public:
+  ClientSourceChild(const ClientSourceConstructorArgs& aArgs,
+                    mozilla::dom::workers::WorkerHolderToken* aWorkerHolderToken);
+
+  void
+  SetSource(ClientSource* aSource);
+
+  void
+  RevokeSource(ClientSource* aSource);
+
+  void
+  MaybeStartTeardown();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceChild_h
diff --git a/dom/clients/ClientSourceParent.cpp b/dom/clients/ClientSourceParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSourceParent.cpp
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientSourceParent.h"
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
+
+namespace mozilla {
+namespace dom {
+
+mozilla::ipc::IPCResult
+ClientSourceParent::RecvTeardown()
+{
+  Unused << Send__delete__(this);
+  return IPC_OK();
+}
+
+void
+ClientSourceParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/ClientSourceParent.h b/dom/clients/ClientSourceParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientSourceParent.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientSourceParent_h
+#define _mozilla_dom_ClientSourceParent_h
+
+#include "mozilla/dom/PClientSourceParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSourceConstructorArgs;
+
+class ClientSourceParent final : public PClientSourceParent
+{
+  // PClientSourceParent
+  mozilla::ipc::IPCResult
+  RecvTeardown() override;
+
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  explicit ClientSourceParent(const ClientSourceConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientSourceParent_h
diff --git a/dom/clients/ClientType.h b/dom/clients/ClientType.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/ClientType.h
@@ -0,0 +1,34 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientType_h
+#define _mozilla_dom_ClientType_h
+
+#include "ipc/IPCMessageUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+enum class ClientType
+{
+  Window,
+  DedicatedWorker,
+  SharedWorker,
+  NumberOfTypes
+};
+
+} // namespace dom
+} // namespace mozilla
+
+namespace IPC {
+  template<>
+  struct ParamTraits<mozilla::dom::ClientType> :
+    public ContiguousEnumSerializer<mozilla::dom::ClientType,
+                                    mozilla::dom::ClientType::Window,
+                                    mozilla::dom::ClientType::NumberOfTypes>
+  {};
+} // namespace IPC
+
+#endif // _mozilla_dom_ClientType_h
diff --git a/dom/clients/PClientHandle.ipdl b/dom/clients/PClientHandle.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/PClientHandle.ipdl
@@ -0,0 +1,22 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientHandle
+{
+  manager PClientManager;
+
+parent:
+  async Teardown();
+
+child:
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/PClientManager.ipdl b/dom/clients/PClientManager.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/PClientManager.ipdl
@@ -0,0 +1,31 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PClientHandle;
+include protocol PClientSource;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientManager
+{
+  manager PBackground;
+
+  manages PClientHandle;
+  manages PClientSource;
+
+parent:
+  async Teardown();
+
+  async PClientHandle(ClientHandleConstructorArgs aArgs);
+  async PClientSource(ClientSourceConstructorArgs aArgs);
+
+child:
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/PClientSource.ipdl b/dom/clients/PClientSource.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/PClientSource.ipdl
@@ -0,0 +1,22 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientSource
+{
+  manager PClientManager;
+
+parent:
+  async Teardown();
+
+child:
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/moz.build b/dom/clients/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/clients/moz.build
@@ -0,0 +1,48 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+  'ClientManager.h',
+  'ClientManagerActors.h',
+  'ClientSource.h',
+  'ClientType.h',
+]
+
+UNIFIED_SOURCES += [
+  'ClientHandleChild.cpp',
+  'ClientHandleParent.cpp',
+  'ClientManager.cpp',
+  'ClientManagerActors.cpp',
+  'ClientManagerChild.cpp',
+  'ClientManagerParent.cpp',
+  'ClientSource.cpp',
+  'ClientSourceChild.cpp',
+  'ClientSourceParent.cpp',
+]
+
+IPDL_SOURCES += [
+  'ClientIPCTypes.ipdlh',
+  'PClientHandle.ipdl',
+  'PClientManager.ipdl',
+  'PClientSource.ipdl',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+    '../workers',
+]
+
+FINAL_LIBRARY = 'xul'
+
+MOCHITEST_MANIFESTS += [
+]
+
+BROWSER_CHROME_MANIFESTS += [
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+]
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -38,16 +38,17 @@ DIRS += [
     'animation',
     'base',
     'archivereader',
     'bindings',
     'battery',
     'browser-element',
     'cache',
     'canvas',
+    'clients',
     'crypto',
     'devicestorage',
     'encoding',
     'events',
     'fetch',
     'file',
     'filehandle',
     'filesystem',
diff --git a/dom/workers/WorkerHolderToken.cpp b/dom/workers/WorkerHolderToken.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.cpp
@@ -0,0 +1,99 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WorkerHolderToken.h"
+
+#include "WorkerPrivate.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+// static
+already_AddRefed<WorkerHolderToken>
+WorkerHolderToken::Create(WorkerPrivate* aWorkerPrivate, Status aShutdownStatus)
+{
+  MOZ_ASSERT(aWorkerPrivate);
+
+  RefPtr<WorkerHolderToken> workerHolder =
+    new WorkerHolderToken(aShutdownStatus);
+
+  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, aShutdownStatus))) {
+    return nullptr;
+  }
+
+  return workerHolder.forget();
+}
+
+void
+WorkerHolderToken::AddListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+
+  // Allow an actor to be added after we've entered the Notifying case.  We
+  // can't stop the actor creation from racing with out destruction of the
+  // other actors and we need to wait for this extra one to close as well.
+  // Signal it should destroy itself right away.
+  if (mShuttingDown) {
+    aListener->WorkerShuttingDown();
+  }
+}
+
+void
+WorkerHolderToken::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+
+  DebugOnly<bool> removed = mListenerList.RemoveElement(aListener);
+
+  MOZ_ASSERT(removed);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+}
+
+bool
+WorkerHolderToken::IsShuttingDown() const
+{
+  return mShuttingDown;
+}
+
+WorkerHolderToken::WorkerHolderToken(Status aShutdownStatus)
+  : mShutdownStatus(aShutdownStatus)
+  , mShuttingDown(false)
+{
+}
+
+WorkerHolderToken::~WorkerHolderToken()
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+bool
+WorkerHolderToken::Notify(Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+
+  // When the service worker thread is stopped we will get Terminating,
+  // but nothing higher than that.  We must shut things down at Terminating.
+  if (aStatus < mShutdownStatus || mShuttingDown) {
+    return true;
+  }
+
+  mShuttingDown = true;
+
+  // Start the asynchronous destruction of our actors.  These will call back
+  // into RemoveActor() once the actor is destroyed.
+  for (uint32_t i = 0; i < mListenerList.Length(); ++i) {
+    mListenerList[i]->WorkerShuttingDown();
+  }
+
+  return true;
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/WorkerHolderToken.h b/dom/workers/WorkerHolderToken.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_WorkerHolderToken_h
+#define mozilla_dom_workers_WorkerHolderToken_h
+
+#include "nsISupportsImpl.h"
+#include "nsTArray.h"
+#include "WorkerHolder.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+class WorkerPrivate;
+
+class WorkerHolderToken final : public WorkerHolder
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void
+    WorkerShuttingDown() = 0;
+  };
+
+  static already_AddRefed<WorkerHolderToken>
+  Create(workers::WorkerPrivate* aWorkerPrivate, Status aShutdownStatus);
+
+  void
+  AddListener(Listener* aListener);
+
+  void
+  RemoveListener(Listener* aListener);
+
+  bool
+  IsShuttingDown() const;
+
+private:
+  explicit WorkerHolderToken(Status aShutdownStatus);
+
+  ~WorkerHolderToken();
+
+  // WorkerHolder methods
+  virtual bool
+  Notify(workers::Status aStatus) override;
+
+  nsTArray<Listener*> mListenerList;
+  const Status mShutdownStatus;
+  bool mShuttingDown;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(WorkerHolderToken)
+};
+
+END_WORKERS_NAMESPACE
+
+#endif // mozilla_dom_workers_WorkerHolderToken_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -32,16 +32,17 @@ EXPORTS.mozilla.dom.workers += [
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
     'ServiceWorkerClient.h',
     'ServiceWorkerClients.h',
     'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
+    'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
     'nsIWorkerDebugger.idl',
     'nsIWorkerDebuggerManager.idl',
 ]
@@ -72,16 +73,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
+    'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -10,16 +10,17 @@
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PFileSystemRequestChild.h"
 #include "mozilla/dom/FileSystemTaskBase.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
@@ -502,16 +503,28 @@ BackgroundChildImpl::DeallocPGamepadTest
 {
 #ifdef MOZ_GAMEPAD
   MOZ_ASSERT(aActor);
   delete static_cast<dom::GamepadTestChannelChild*>(aActor);
 #endif
   return true;
 }
 
+mozilla::dom::PClientManagerChild*
+BackgroundChildImpl::AllocPClientManagerChild()
+{
+  return mozilla::dom::AllocClientManagerChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPClientManagerChild(mozilla::dom::PClientManagerChild* aActor)
+{
+  return mozilla::dom::DeallocClientManagerChild(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 mozilla::ipc::IPCResult
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -173,16 +173,22 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelChild(PGamepadEventChannelChild* aActor) override;
 
   virtual PGamepadTestChannelChild*
   AllocPGamepadTestChannelChild() override;
 
   virtual bool
   DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor) override;
+
+  virtual PClientManagerChild*
+  AllocPClientManagerChild() override;
+
+  virtual bool
+  DeallocPClientManagerChild(PClientManagerChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -9,16 +9,17 @@
 #include "BroadcastChannelParent.h"
 #include "FileDescriptorSetParent.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasParent.h"
 #endif
 #include "mozilla/media/MediaParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ClientManagerActors.h"
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/FileSystemBase.h"
 #include "mozilla/dom/FileSystemRequestParent.h"
 #ifdef MOZ_GAMEPAD
 #include "mozilla/dom/GamepadEventChannelParent.h"
 #include "mozilla/dom/GamepadTestChannelParent.h"
 #endif
 #include "mozilla/dom/PBlobParent.h"
@@ -946,16 +947,28 @@ BackgroundParentImpl::DeallocPGamepadTes
 #ifdef MOZ_GAMEPAD
   MOZ_ASSERT(aActor);
   RefPtr<dom::GamepadTestChannelParent> parent =
     dont_AddRef(static_cast<dom::GamepadTestChannelParent*>(aActor));
 #endif
   return true;
 }
 
+mozilla::dom::PClientManagerParent*
+BackgroundParentImpl::AllocPClientManagerParent()
+{
+  return mozilla::dom::AllocClientManagerParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPClientManagerParent(mozilla::dom::PClientManagerParent* aActor)
+{
+  return mozilla::dom::DeallocClientManagerParent(aActor);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -201,14 +201,20 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelParent(PGamepadEventChannelParent *aActor) override;
 
   virtual PGamepadTestChannelParent*
   AllocPGamepadTestChannelParent() override;
 
   virtual bool
   DeallocPGamepadTestChannelParent(PGamepadTestChannelParent* aActor) override;
+
+  virtual PClientManagerParent*
+  AllocPClientManagerParent() override;
+
+  virtual bool
+  DeallocPClientManagerParent(PClientManagerParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -6,16 +6,17 @@ include protocol PAsmJSCacheEntry;
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundIndexedDBUtils;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
+include protocol PClientManager;
 include protocol PFileDescriptorSet;
 include protocol PFileSystemRequest;
 include protocol PGamepadEventChannel;
 include protocol PGamepadTestChannel;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PQuota;
 include protocol PSendStream;
@@ -49,16 +50,17 @@ sync protocol PBackground
   manages PBackgroundIDBFactory;
   manages PBackgroundIndexedDBUtils;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
+  manages PClientManager;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
   manages PGamepadEventChannel;
   manages PGamepadTestChannel;
   manages PMessagePort;
   manages PCameras;
   manages PQuota;
   manages PSendStream;
@@ -103,16 +105,18 @@ parent:
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
   async PGamepadEventChannel();
 
   async PGamepadTestChannel();
 
+  async PClientManager();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
   async PFileDescriptorSet(FileDescriptor fd);
