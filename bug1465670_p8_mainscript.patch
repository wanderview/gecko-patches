# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d5b4e78c8ce8584168e1b56a90a16ef10f1d48de
Bug 1465670 P8 Convert WorkerPrivate::LoadScriptAsPartOfLoadingServiceWorkerScript() to simply IsLoadWorkerScript(). r=asuth

diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -726,17 +726,17 @@ ServiceWorkerRegistrationWorkerThread::U
   if (NS_WARN_IF(!workerRef)) {
     return ServiceWorkerRegistrationPromise::CreateAndReject(
       NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
   }
 
   // Avoid infinite update loops by ignoring update() calls during top
   // level script evaluation.  See:
   // https://github.com/slightlyoff/ServiceWorker/issues/800
-  if (workerRef->Private()->LoadScriptAsPartOfLoadingServiceWorkerScript()) {
+  if (workerRef->Private()->IsLoadingWorkerScript()) {
     return ServiceWorkerRegistrationPromise::CreateAndResolve(mDescriptor,
                                                               __func__);
   }
 
   // Eventually we need to support all workers, but for right now this
   // code assumes we're on a service worker global as self.registration.
   if (NS_WARN_IF(!workerRef->Private()->IsServiceWorker())) {
     return ServiceWorkerRegistrationPromise::CreateAndReject(
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -908,17 +908,17 @@ private:
     mCacheCreator = nullptr;
   }
 
   nsresult
   RunInternal()
   {
     AssertIsOnMainThread();
 
-    if (IsMainWorkerScript() && mWorkerPrivate->IsServiceWorker()) {
+    if (IsMainWorkerScript()) {
       mWorkerPrivate->SetLoadingWorkerScript(true);
     }
 
     if (!mWorkerPrivate->IsServiceWorker() || IsDebuggerScript()) {
       for (uint32_t index = 0, len = mLoadInfos.Length(); index < len;
            ++index) {
         nsresult rv = LoadScript(index);
         if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -2181,17 +2181,17 @@ ScriptExecutorRunnable::ShutdownScriptLo
                                              WorkerPrivate* aWorkerPrivate,
                                              bool aResult,
                                              bool aMutedError)
 {
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   MOZ_ASSERT(mLastIndex == mScriptLoader.mLoadInfos.Length() - 1);
 
-  if (mIsWorkerScript && aWorkerPrivate->IsServiceWorker()) {
+  if (mIsWorkerScript) {
     aWorkerPrivate->SetLoadingWorkerScript(false);
   }
 
   if (!aResult) {
     // At this point there are two possibilities:
     //
     // 1) mScriptLoader.mRv.Failed().  In that case we just want to leave it
     //    as-is, except if it has a JS exception and we need to mute JS
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1038,36 +1038,29 @@ public:
 
   // Determine if the SW testing per-window flag is set by devtools
   bool
   ServiceWorkersTestingInWindow() const
   {
     return mLoadInfo.mServiceWorkersTestingInWindow;
   }
 
-  // This is used to handle importScripts(). When the worker is first loaded
-  // and executed, it happens in a sync loop. At this point it sets
-  // mLoadingWorkerScript to true. importScripts() calls that occur during the
-  // execution run in nested sync loops and so this continues to return true,
-  // leading to these scripts being cached offline.
-  // mLoadingWorkerScript is set to false when the top level loop ends.
-  // importScripts() in function calls or event handlers are always fetched
-  // from the network.
+  // Determine if the worker is currently loading its top level script.
   bool
-  LoadScriptAsPartOfLoadingServiceWorkerScript()
+  IsLoadingWorkerScript() const
   {
-    MOZ_ASSERT(IsServiceWorker());
     return mLoadingWorkerScript;
   }
 
+  // Called by ScriptLoader to track when this worker is loading its
+  // top level script.
   void
   SetLoadingWorkerScript(bool aLoadingWorkerScript)
   {
     // any thread
-    MOZ_ASSERT(IsServiceWorker());
     mLoadingWorkerScript = aLoadingWorkerScript;
   }
 
   void
   QueueRunnable(nsIRunnable* aRunnable)
   {
     AssertIsOnParentThread();
     mQueuedRunnables.AppendElement(aRunnable);
