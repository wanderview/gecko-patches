# HG changeset patch
# Parent 4db7b028bf24010e99afef75d927b35048e55507
# User Ben Kelly <ben@wanderview.com>
Bug 1118845 P2 Handle nsILoadGroup callbacks correctly for SharedWorker.
* * *
Bug 1118845 P3 Force the creation of a new load group for SharedWorkers. r=sicking

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -2246,17 +2246,18 @@ RuntimeService::CreateSharedWorkerIntern
 
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal.GetAsSupports());
   MOZ_ASSERT(window);
 
   JSContext* cx = aGlobal.Context();
 
   WorkerPrivate::LoadInfo loadInfo;
   nsresult rv = WorkerPrivate::GetLoadInfo(cx, window, nullptr, aScriptURL,
-                                           false, &loadInfo);
+                                           false, WorkerPrivate::ForceNewLoadGroup,
+                                           &loadInfo);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return CreateSharedWorkerFromLoadInfo(cx, &loadInfo, aScriptURL, aName, aType,
                                         aSharedWorker);
 }
 
 nsresult
 RuntimeService::CreateSharedWorkerFromLoadInfo(JSContext* aCx,
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -10,21 +10,23 @@
 #include "nsIClassInfo.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIConsoleService.h"
 #include "nsIDOMDOMException.h"
 #include "nsIDOMEvent.h"
 #include "nsIDOMMessageEvent.h"
 #include "nsIDocument.h"
 #include "nsIDocShell.h"
+#include "nsIInterfaceRequestor.h"
 #include "nsIMemoryReporter.h"
 #include "nsIPermissionManager.h"
 #include "nsIScriptError.h"
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsITabChild.h"
 #include "nsITextToSubURI.h"
 #include "nsIThreadInternal.h"
 #include "nsITimer.h"
 #include "nsIURI.h"
 #include "nsIURL.h"
 #include "nsIWorkerDebugger.h"
 #include "nsIXPConnect.h"
 #include "nsPerformance.h"
@@ -1890,16 +1892,80 @@ PRThreadFromThread(nsIThread* aThread)
 
   PRThread* result;
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(aThread->GetPRThread(&result)));
   MOZ_ASSERT(result);
 
   return result;
 }
 
+class WorkerInterfaceRequestor MOZ_FINAL : public nsIInterfaceRequestor
+{
+public:
+  WorkerInterfaceRequestor(nsIPrincipal* aPrincipal, nsILoadGroup* aLoadGroup)
+  {
+    MOZ_ASSERT(aPrincipal);
+
+    nsCOMPtr<nsIInterfaceRequestor> callbacks;
+    if (aLoadGroup) {
+      aLoadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
+    }
+
+    // Create a load context, using the base context if present.
+    nsCOMPtr<nsILoadContext> baseContext;
+    if (callbacks) {
+      callbacks->GetInterface(NS_GET_IID(nsILoadContext),
+                              getter_AddRefs(baseContext));
+      // ok if we don't find the interface
+    }
+    mLoadContext = new LoadContext(aPrincipal, baseContext);
+
+    // Find the tab child if the load group has one.
+    if (callbacks) {
+      callbacks->GetInterface(NS_GET_IID(nsITabChild),
+                              getter_AddRefs(mTabChild));
+      // ok if we don't find the interface
+    }
+  }
+
+  NS_IMETHOD
+  GetInterface(const nsIID& aIID, void** aSink) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mLoadContext);
+
+    if(aIID.Equals(NS_GET_IID(nsITabChild))) {
+      if (!mTabChild) {
+        return NS_NOINTERFACE;
+      }
+      nsCOMPtr<nsITabChild> ref = mTabChild;
+      ref.forget(aSink);
+      return NS_OK;
+    }
+
+    if (aIID.Equals(NS_GET_IID(nsILoadContext))) {
+      nsCOMPtr<nsILoadContext> ref = mLoadContext;
+      ref.forget(aSink);
+      return NS_OK;
+    }
+
+    return NS_NOINTERFACE;
+  }
+
+private:
+  ~WorkerInterfaceRequestor() { }
+
+  nsCOMPtr<nsILoadContext> mLoadContext;
+  nsCOMPtr<nsITabChild> mTabChild;
+
+private:
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(WorkerInterfaceRequestor, nsIInterfaceRequestor);
+
 } /* anonymous namespace */
 
 NS_IMPL_ISUPPORTS_INHERITED0(MainThreadReleaseRunnable, nsRunnable)
 
 NS_IMPL_ISUPPORTS_INHERITED0(TopLevelWorkerFinishedRunnable, nsRunnable)
 
 NS_IMPL_ISUPPORTS(TimerThreadEventTarget, nsIEventTarget)
 
@@ -4057,17 +4123,18 @@ WorkerPrivate::Constructor(JSContext* aC
   MOZ_ASSERT_IF(aWorkerType == WorkerTypeDedicated,
                 aSharedWorkerName.IsEmpty());
 
   Maybe<LoadInfo> stackLoadInfo;
   if (!aLoadInfo) {
     stackLoadInfo.emplace();
 
     nsresult rv = GetLoadInfo(aCx, nullptr, parent, aScriptURL,
-                              aIsChromeWorker, stackLoadInfo.ptr());
+                              aIsChromeWorker, InheritLoadGroup,
+                              stackLoadInfo.ptr());
     if (NS_FAILED(rv)) {
       scriptloader::ReportLoadError(aCx, aScriptURL, rv, !parent);
       aRv.Throw(rv);
       return nullptr;
     }
 
     aLoadInfo = stackLoadInfo.ptr();
   }
@@ -4112,17 +4179,19 @@ WorkerPrivate::Constructor(JSContext* aC
 
   return worker.forget();
 }
 
 // static
 nsresult
 WorkerPrivate::GetLoadInfo(JSContext* aCx, nsPIDOMWindow* aWindow,
                            WorkerPrivate* aParent, const nsAString& aScriptURL,
-                           bool aIsChromeWorker, LoadInfo* aLoadInfo)
+                           bool aIsChromeWorker,
+                           LoadGroupBehavior aLoadGroupBehavior,
+                           LoadInfo* aLoadInfo)
 {
   using namespace mozilla::dom::workers::scriptloader;
   using mozilla::dom::indexedDB::IDBFactory;
 
   MOZ_ASSERT(aCx);
   MOZ_ASSERT_IF(NS_IsMainThread(), aCx == nsContentUtils::GetCurrentJSContext());
 
   if (aWindow) {
@@ -4345,20 +4414,27 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
       rv = loadInfo.mCSP->GetAllowsEval(&loadInfo.mReportCSPViolations,
                                         &loadInfo.mEvalAllowed);
       NS_ENSURE_SUCCESS(rv, rv);
     } else {
       loadInfo.mEvalAllowed = true;
       loadInfo.mReportCSPViolations = false;
     }
 
-    if (!loadInfo.mLoadGroup) {
-      rv = NS_NewLoadGroup(getter_AddRefs(loadInfo.mLoadGroup),
-                           loadInfo.mPrincipal);
+    if (!loadInfo.mLoadGroup || aLoadGroupBehavior == ForceNewLoadGroup) {
+      nsCOMPtr<nsIInterfaceRequestor> callbacks =
+        new WorkerInterfaceRequestor(loadInfo.mPrincipal, loadInfo.mLoadGroup);
+
+      nsCOMPtr<nsILoadGroup> loadGroup =
+        do_CreateInstance(NS_LOADGROUP_CONTRACTID);
+
+      rv = loadGroup->SetNotificationCallbacks(callbacks);
       NS_ENSURE_SUCCESS(rv, rv);
+
+      loadInfo.mLoadGroup = loadGroup.forget();
     }
     MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(loadInfo.mLoadGroup,
                                             loadInfo.mPrincipal));
 
     rv = ChannelFromScriptURLMainThread(loadInfo.mPrincipal, loadInfo.mBaseURI,
                                         document, loadInfo.mLoadGroup,
                                         aScriptURL,
                                         getter_AddRefs(loadInfo.mChannel));
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -916,20 +916,26 @@ public:
   static already_AddRefed<WorkerPrivate>
   Constructor(JSContext* aCx, const nsAString& aScriptURL, bool aIsChromeWorker,
               WorkerType aWorkerType, const nsACString& aSharedWorkerName,
               LoadInfo* aLoadInfo, ErrorResult& aRv);
 
   static bool
   WorkerAvailable(JSContext* /* unused */, JSObject* /* unused */);
 
+  enum LoadGroupBehavior
+  {
+    InheritLoadGroup,
+    ForceNewLoadGroup
+  };
+
   static nsresult
   GetLoadInfo(JSContext* aCx, nsPIDOMWindow* aWindow, WorkerPrivate* aParent,
               const nsAString& aScriptURL, bool aIsChromeWorker,
-              LoadInfo* aLoadInfo);
+              LoadGroupBehavior aLoadGroupBehavior, LoadInfo* aLoadInfo);
 
   WorkerDebugger*
   Debugger() const
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mDebugger);
     return mDebugger;
   }
