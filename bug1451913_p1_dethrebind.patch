# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  55d475f12da76450f85d37fd2b9e8baa9b1989b4
Bug 1451913 P1 Allow subclasses to override DOMEventTargetHelper::BindToOwner(nsIGlobalObject*). r=smaug

diff --git a/dom/events/DOMEventTargetHelper.cpp b/dom/events/DOMEventTargetHelper.cpp
--- a/dom/events/DOMEventTargetHelper.cpp
+++ b/dom/events/DOMEventTargetHelper.cpp
@@ -94,44 +94,35 @@ DOMEventTargetHelper::~DOMEventTargetHel
     mListenerManager->Disconnect();
   }
   ReleaseWrapper(this);
 }
 
 void
 DOMEventTargetHelper::BindToOwner(nsPIDOMWindowInner* aOwner)
 {
-  BindToOwner(aOwner ? aOwner->AsGlobal() : nullptr);
+  // Make sure to bind via BindToOwner(nsIGlobalObject*) so
+  // subclasses can override the method to perform additional
+  // actions.
+  nsIGlobalObject* global = aOwner ? aOwner->AsGlobal() : nullptr;
+  BindToOwner(global);
 }
 
 void
 DOMEventTargetHelper::BindToOwner(nsIGlobalObject* aOwner)
 {
-  if (mParentObject) {
-    mParentObject->RemoveEventTargetObject(this);
-    if (mOwnerWindow) {
-      mOwnerWindow = nullptr;
-    }
-    mParentObject = nullptr;
-    mHasOrHasHadOwnerWindow = false;
-  }
-  if (aOwner) {
-    mParentObject = aOwner;
-    aOwner->AddEventTargetObject(this);
-    // Let's cache the result of this QI for fast access and off main thread usage
-    mOwnerWindow = nsCOMPtr<nsPIDOMWindowInner>(do_QueryInterface(aOwner)).get();
-    if (mOwnerWindow) {
-      mHasOrHasHadOwnerWindow = true;
-    }
-  }
+  BindToOwnerInternal(aOwner);
 }
 
 void
 DOMEventTargetHelper::BindToOwner(DOMEventTargetHelper* aOther)
 {
+  // Make sure to bind via BindToOwner(nsIGlobalObject*) so
+  // subclasses can override the method to perform additional
+  // actions.
   if (!aOther) {
     BindToOwner(static_cast<nsIGlobalObject*>(nullptr));
     return;
   }
   BindToOwner(aOther->GetParentObject());
   mHasOrHasHadOwnerWindow = aOther->HasOrHasHadOwner();
 }
 
@@ -350,9 +341,31 @@ void
 DOMEventTargetHelper::MaybeDontKeepAlive()
 {
   if (mIsKeptAlive) {
     mIsKeptAlive = false;
     Release();
   }
 }
 
+void
+DOMEventTargetHelper::BindToOwnerInternal(nsIGlobalObject* aOwner)
+{
+  if (mParentObject) {
+    mParentObject->RemoveEventTargetObject(this);
+    if (mOwnerWindow) {
+      mOwnerWindow = nullptr;
+    }
+    mParentObject = nullptr;
+    mHasOrHasHadOwnerWindow = false;
+  }
+  if (aOwner) {
+    mParentObject = aOwner;
+    aOwner->AddEventTargetObject(this);
+    // Let's cache the result of this QI for fast access and off main thread usage
+    mOwnerWindow = nsCOMPtr<nsPIDOMWindowInner>(do_QueryInterface(aOwner)).get();
+    if (mOwnerWindow) {
+      mHasOrHasHadOwnerWindow = true;
+    }
+  }
+}
+
 } // namespace mozilla
diff --git a/dom/events/DOMEventTargetHelper.h b/dom/events/DOMEventTargetHelper.h
--- a/dom/events/DOMEventTargetHelper.h
+++ b/dom/events/DOMEventTargetHelper.h
@@ -41,33 +41,45 @@ public:
   {
   }
   explicit DOMEventTargetHelper(nsPIDOMWindowInner* aWindow)
     : mParentObject(nullptr)
     , mOwnerWindow(nullptr)
     , mHasOrHasHadOwnerWindow(false)
     , mIsKeptAlive(false)
   {
-    BindToOwner(aWindow);
+    // Be careful not to call the virtual BindToOwner() in a
+    // constructor.
+    nsIGlobalObject* global = aWindow ? aWindow->AsGlobal() : nullptr;
+    BindToOwnerInternal(global);
   }
   explicit DOMEventTargetHelper(nsIGlobalObject* aGlobalObject)
     : mParentObject(nullptr)
     , mOwnerWindow(nullptr)
     , mHasOrHasHadOwnerWindow(false)
     , mIsKeptAlive(false)
   {
-    BindToOwner(aGlobalObject);
+    // Be careful not to call the virtual BindToOwner() in a
+    // constructor.
+    BindToOwnerInternal(aGlobalObject);
   }
   explicit DOMEventTargetHelper(DOMEventTargetHelper* aOther)
     : mParentObject(nullptr)
     , mOwnerWindow(nullptr)
     , mHasOrHasHadOwnerWindow(false)
     , mIsKeptAlive(false)
   {
-    BindToOwner(aOther);
+    // Be careful not to call the virtual BindToOwner() in a
+    // constructor.
+    if (!aOther) {
+      BindToOwnerInternal(static_cast<nsIGlobalObject*>(nullptr));
+      return;
+    }
+    BindToOwnerInternal(aOther->GetParentObject());
+    mHasOrHasHadOwnerWindow = aOther->HasOrHasHadOwner();
   }
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS(DOMEventTargetHelper)
 
   NS_DECL_NSIDOMEVENTTARGET
 
   virtual EventListenerManager* GetExistingListenerManager() const override;
@@ -137,19 +149,30 @@ public:
 
   nsPIDOMWindowInner* GetOwner() const { return mOwnerWindow; }
   // Like GetOwner, but only returns non-null if the window being returned is
   // current (in the "current document" sense of the HTML spec).
   nsPIDOMWindowInner* GetWindowIfCurrent() const;
   // Returns the document associated with this event target, if that document is
   // the current document of its browsing context.  Will return null otherwise.
   nsIDocument* GetDocumentIfCurrent() const;
-  void BindToOwner(nsIGlobalObject* aOwner);
+
+  // DETH subclasses may override the BindToOwner(nsIGlobalObject*) method
+  // to take action when dynamically binding to a new global.  This is only
+  // called on rebind since virtual methods cannot be called from the
+  // constructor.  The other BindToOwner() methods will call into this
+  // method.
+  //
+  // NOTE: Any overrides of BindToOwner() *must* invoke
+  //       DOMEventTargetHelper::BindToOwner(aOwner).
+  virtual void BindToOwner(nsIGlobalObject* aOwner);
+
   void BindToOwner(nsPIDOMWindowInner* aOwner);
   void BindToOwner(DOMEventTargetHelper* aOther);
+
   virtual void DisconnectFromOwner();
   using EventTarget::GetParentObject;
   virtual nsIGlobalObject* GetOwnerGlobal() const override
   {
     return mParentObject;
   }
   bool HasOrHasHadOwner() { return mHasOrHasHadOwnerWindow; }
 
@@ -184,16 +207,18 @@ protected:
   virtual void LastRelease() {}
 
   void KeepAliveIfHasListenersFor(const nsAString& aType);
   void KeepAliveIfHasListenersFor(nsAtom* aType);
 
   void IgnoreKeepAliveIfHasListenersFor(const nsAString& aType);
   void IgnoreKeepAliveIfHasListenersFor(nsAtom* aType);
 
+  void BindToOwnerInternal(nsIGlobalObject* aOwner);
+
 private:
   // The parent global object.  The global will clear this when
   // it is destroyed by calling DisconnectFromOwner().
   nsIGlobalObject* MOZ_NON_OWNING_REF mParentObject;
   // mParentObject pre QI-ed and cached (inner window)
   // (it is needed for off main thread access)
   // It is obtained in BindToOwner and reset in DisconnectFromOwner.
   nsPIDOMWindowInner* MOZ_NON_OWNING_REF mOwnerWindow;
