# HG changeset patch
# Parent 7932929030149cd30bb2b60657dadab1721ad8d2
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -130,17 +130,17 @@ FileUtils::BodyStartWriteStream(const Qu
 
   nsRefPtr<SnappyCompressOutputStream> compressed =
     new SnappyCompressOutputStream(fileStream);
 
   rv = NS_AsyncCopy(aSource, compressed, NS_GetCurrentThread(),
                     NS_ASYNCCOPY_VIA_WRITESEGMENTS,
                     compressed->BlockSize(),
                     aCallback, aClosure,
-                    true, true, // close streams
+                    false, true, // close streams
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 void
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -513,24 +513,29 @@ public:
     MOZ_ASSERT(!mResolver);
     MOZ_ASSERT(!mDBDir);
     MOZ_ASSERT(!mConn);
 
     mResolver = aResolver;
     mDBDir = aDBDir;
     mConn = aConn;
 
+    printf_stderr("### ### [%p] CachePutAllAction::RunWithDBOnTarget()\n",
+                  this);
+
     if (mExpectedAsyncCopyCompletions < 1) {
       mExpectedAsyncCopyCompletions = 1;
       OnAsyncCopyComplete(NS_OK);
       return;
     }
 
     nsresult rv = NS_OK;
     for (uint32_t i = 0; i < mList.Length(); ++i) {
+      printf_stderr("### ### [%p] CachePutAllAction start copying for request %s\n",
+                    this, NS_ConvertUTF16toUTF8(mList[i].mRequest.url()).get());
       rv = StartStreamCopy(aQuotaInfo, mList[i].mRequestStream,
                            &mList[i].mRequestBodyId,
                            getter_AddRefs(mList[i].mRequestCopyContext));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         CancelAllStreamCopying();
         DoResolve(rv);
         return;
       }
@@ -548,16 +553,19 @@ public:
 
   void
   OnAsyncCopyComplete(nsresult aRv)
   {
     MOZ_ASSERT(mConn);
     MOZ_ASSERT(mResolver);
     MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
 
+    printf_stderr("### ### [%p] CachePutAllAction::OnAsyncComplete()\n",
+                  this);
+
     // When DoResolve() is called below the "this" object can get destructed
     // out from under us on the initiating thread.  Ensure that we cleanly
     // run to completion in this scope before destruction.
     nsRefPtr<Action> kungFuDeathGrip = this;
 
     if (NS_FAILED(aRv)) {
       DoResolve(aRv);
       return;
@@ -608,16 +616,19 @@ public:
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
 
+    printf_stderr("### ### [%p] CachePutAllAction::CompleteOnInitiatingThread()\n",
+                  this);
+
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mList[i].mRequestStream = nullptr;
       mList[i].mResponseStream = nullptr;
     }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -47,16 +47,17 @@ FetchDriver::FetchDriver(InternalRequest
 {
 }
 
 FetchDriver::~FetchDriver()
 {
   // We assert this since even on failures, we should call
   // FailWithNetworkError().
   MOZ_ASSERT(mResponseAvailableCalled);
+  printf_stderr("### ### [%p] ~FetchDriver()\n", this);
 }
 
 nsresult
 FetchDriver::Fetch(FetchDriverObserver* aObserver)
 {
   workers::AssertIsOnMainThread();
   mObserver = aObserver;
 
@@ -605,16 +606,17 @@ NS_IMPL_ISUPPORTS(FillResponseHeaders, n
 
 NS_IMETHODIMP
 FetchDriver::OnStartRequest(nsIRequest* aRequest,
                             nsISupports* aContext)
 {
   workers::AssertIsOnMainThread();
   MOZ_ASSERT(!mPipeOutputStream);
   MOZ_ASSERT(mObserver);
+  printf_stderr("### ### [%p] FetchDriver::OnStartRequest() request:%p\n", this, aRequest);
   nsresult rv;
   aRequest->GetStatus(&rv);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     FailWithNetworkError();
     return rv;
   }
 
   nsCOMPtr<nsIHttpChannel> channel = do_QueryInterface(aRequest);
@@ -683,29 +685,36 @@ FetchDriver::OnDataAvailable(nsIRequest*
                              nsIInputStream* aInputStream,
                              uint64_t aOffset,
                              uint32_t aCount)
 {
   uint32_t aRead;
   MOZ_ASSERT(mResponse);
   MOZ_ASSERT(mPipeOutputStream);
 
+  printf_stderr("### ### [%p] FetchDriver::OnDataAvailable() request:%p attempting to read %u\n",
+                this, aRequest, aCount);
   nsresult rv = aInputStream->ReadSegments(NS_CopySegmentToStream,
                                            mPipeOutputStream,
                                            aCount, &aRead);
+  printf_stderr("### ### [%p] FetchDriver::OnDataAvailable() request:%p read %u out of %u expected, result %x\n",
+                this, aRequest, aRead, aCount, rv);
   return rv;
 }
 
 NS_IMETHODIMP
 FetchDriver::OnStopRequest(nsIRequest* aRequest,
                            nsISupports* aContext,
                            nsresult aStatusCode)
 {
   workers::AssertIsOnMainThread();
+  printf_stderr("### ### [%p] FetchDriver::OnStopRequest() request:%p\n", this, aRequest);
   if (mPipeOutputStream) {
+    printf_stderr("### ### [%p] FetchDriver::OnStopRequest()  request:%p closing pipe stream\n",
+                  this, aRequest);
     mPipeOutputStream->Close();
   }
 
   if (NS_FAILED(aStatusCode)) {
     FailWithNetworkError();
     return aStatusCode;
   }
 
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -138,19 +138,22 @@ struct RespondWithClosure
   {
   }
 };
 
 void RespondWithCopyComplete(void* aClosure, nsresult aStatus)
 {
   nsAutoPtr<RespondWithClosure> data(static_cast<RespondWithClosure*>(aClosure));
   nsCOMPtr<nsIRunnable> event;
+  printf_stderr("### ### RespondWithCopyComplete()\n");
   if (NS_SUCCEEDED(aStatus)) {
+    printf_stderr("### ### RespondWithCopyComplete() create FinishResponse()\n");
     event = new FinishResponse(data->mInterceptedChannel);
   } else {
+    printf_stderr("### ### RespondWithCopyComplete() create CancelChannelRunnable()\n");
     event = new CancelChannelRunnable(data->mInterceptedChannel);
   }
   NS_DispatchToMainThread(event);
 }
 
 class MOZ_STACK_CLASS AutoCancel
 {
   nsRefPtr<RespondWithHandler> mOwner;
@@ -200,16 +203,17 @@ RespondWithHandler::ResolvedCallback(JSC
   }
 
   nsAutoPtr<RespondWithClosure> closure(new RespondWithClosure(mInterceptedChannel));
 
   nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_SOCKETTRANSPORTSERVICE_CONTRACTID, &rv);
   if (NS_WARN_IF(!stsThread)) {
     return;
   }
+  printf_stderr("### ### RespondWithHandler::ResolvedCallback() starting copy\n");
   rv = NS_AsyncCopy(body, responseBody, stsThread, NS_ASYNCCOPY_VIA_READSEGMENTS, 4096,
                     RespondWithCopyComplete, closure.forget());
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
   autoCancel.Reset();
 }
diff --git a/image/src/imgLoader.cpp b/image/src/imgLoader.cpp
--- a/image/src/imgLoader.cpp
+++ b/image/src/imgLoader.cpp
@@ -1904,16 +1904,18 @@ nsresult imgLoader::LoadImage(nsIURI *aU
                               nsLoadFlags aLoadFlags,
                               nsISupports *aCacheKey,
                               nsContentPolicyType aContentPolicyType,
                               const nsAString& initiatorType,
                               imgRequestProxy **_retval)
 {
   VerifyCacheSizes();
 
+  printf_stderr("### ### imgLoader::LoadImage()\n");
+
   NS_ASSERTION(aURI, "imgLoader::LoadImage -- NULL URI pointer");
 
   if (!aURI)
     return NS_ERROR_NULL_POINTER;
 
   nsAutoCString spec;
   aURI->GetSpec(spec);
   LOG_SCOPE_WITH_PARAM(GetImgLog(), "imgLoader::LoadImage", "aURI", spec.get());
diff --git a/netwerk/base/nsFileStreams.cpp b/netwerk/base/nsFileStreams.cpp
--- a/netwerk/base/nsFileStreams.cpp
+++ b/netwerk/base/nsFileStreams.cpp
@@ -346,16 +346,23 @@ nsFileStreamBase::DoOpen()
     } else
 #endif // XP_WIN
     {
       rv = mOpenParams.localFile->OpenNSPRFileDesc(mOpenParams.ioFlags,
                                                    mOpenParams.perm,
                                                    &fd);
     }
 
+    if (NS_FAILED(rv)) {
+        nsAutoCString path;
+        mOpenParams.localFile->GetNativePath(path);
+        printf_stderr("### ### nsFileStreamBase::DoOpen() failed with code %x for path %s\n",
+                      rv, path.get());
+    }
+
     CleanUpOpen();
     if (NS_FAILED(rv))
         return rv;
     mFD = fd;
 
     return NS_OK;
 }
 
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -133,16 +133,17 @@ InterceptedChannelChrome::SynthesizeHead
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::FinishSynthesizedResponse()
 {
+  printf_stderr("### ### InterceptedChannelChrome::FinishSynthesizedResponse\n");
   if (!mChannel) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   EnsureSynthesizedResponse();
 
   mChannel->MarkIntercepted();
 
@@ -243,16 +244,17 @@ InterceptedChannelContent::SynthesizeHea
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::FinishSynthesizedResponse()
 {
+  printf_stderr("### ### InterceptedChannelContent::FinishSynthesizedResponse\n");
   if (NS_WARN_IF(!mChannel)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   EnsureSynthesizedResponse();
 
   nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mStoragePump), mSynthesizedInput,
                                           int64_t(-1), int64_t(-1), 0, 0, true);
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -249,16 +249,18 @@ nsHttpChannel::nsHttpChannel()
     mChannelCreationTime = PR_Now();
     mChannelCreationTimestamp = TimeStamp::Now();
 }
 
 nsHttpChannel::~nsHttpChannel()
 {
     LOG(("Destroying nsHttpChannel [this=%p]\n", this));
 
+    printf_stderr("### ### [%p] ~nsHttpChannel()\n", this);
+
     if (mAuthProvider)
         mAuthProvider->Disconnect(NS_ERROR_ABORT);
 }
 
 nsresult
 nsHttpChannel::Init(nsIURI *uri,
                     uint32_t caps,
                     nsProxyInfo *proxyInfo,
@@ -359,17 +361,20 @@ nsHttpChannel::Connect()
         if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
             // If we have a fallback URI (and we're not already
             // falling back), process the fallback asynchronously.
             if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
                 return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
             }
             return NS_ERROR_DOCUMENT_NOT_CACHED;
         }
+        printf_stderr("### ### [%p] nsHttpChannel::Connect() failed to open cache entry\n", this);
         // otherwise, let's just proceed without using the cache.
+    } else {
+      printf_stderr("### ### [%p] nsHttpChannel::Connect() opened cache entry\n", this);
     }
 
     return ContinueConnect();
 }
 
 nsresult
 nsHttpChannel::ContinueConnect()
 {
@@ -931,16 +936,18 @@ nsHttpChannel::CallOnStartRequest()
           LOG(("  entry too big"));
         } else {
           NS_ENSURE_SUCCESS(rv, rv);
         }
     }
 
     LOG(("  calling mListener->OnStartRequest\n"));
     if (mListener) {
+        printf_stderr("### ### [%p] nsHttpChannel::CallOnStartRequest() calling listener %p OnStartRequest()\n",
+                      this, mListener.get());
         rv = mListener->OnStartRequest(this, mListenerContext);
         if (NS_FAILED(rv))
             return rv;
     } else {
         NS_WARNING("OnStartRequest skipped because of null listener");
     }
 
     // Install stream converter if required.
@@ -2907,16 +2914,19 @@ nsHttpChannel::CheckPartial(nsICacheEntr
 }
 
 NS_IMETHODIMP
 nsHttpChannel::OnCacheEntryCheck(nsICacheEntry* entry, nsIApplicationCache* appCache,
                                  uint32_t* aResult)
 {
     nsresult rv = NS_OK;
 
+    printf_stderr("### ### [%p] nsHttpChanne::OnCacheEntryCheck() entry:%p start\n",
+                  this, entry);
+
     LOG(("nsHttpChannel::OnCacheEntryCheck enter [channel=%p entry=%p]",
         this, entry));
 
     // Remember the request is a custom conditional request so that we can
     // process any 304 response correctly.
     mCustomConditionalRequest =
         mRequestHead.PeekHeader(nsHttp::If_Modified_Since) ||
         mRequestHead.PeekHeader(nsHttp::If_None_Match) ||
@@ -3266,16 +3276,19 @@ nsHttpChannel::OnCacheEntryCheck(nsICach
         *aResult = RECHECK_AFTER_WRITE_FINISHED;
     else
         *aResult = ENTRY_WANTED;
 
     if (mCachedContentIsValid) {
         entry->MaybeMarkValid();
     }
 
+    printf_stderr("### ### [%p] nsHttpChanne::OnCacheEntryCheck() entry:%p return %u\n",
+                  this, entry, rv);
+
     LOG(("nsHTTPChannel::OnCacheEntryCheck exit [this=%p doValidation=%d result=%d]\n",
          this, doValidation, *aResult));
     return rv;
 }
 
 NS_IMETHODIMP
 nsHttpChannel::OnCacheEntryAvailable(nsICacheEntry *entry,
                                      bool aNew,
@@ -4652,16 +4665,18 @@ NS_INTERFACE_MAP_END_INHERITING(HttpBase
 // nsHttpChannel::nsIRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 nsHttpChannel::Cancel(nsresult status)
 {
     MOZ_ASSERT(NS_IsMainThread());
 
+    printf_stderr("### ### nsHttpChannel::Cancel()\n");
+
     LOG(("nsHttpChannel::Cancel [this=%p status=%x]\n", this, status));
     if (mCanceled) {
         LOG(("  ignoring; already canceled\n"));
         return NS_OK;
     }
     if (mWaitingForRedirectCallback) {
         LOG(("channel canceled during wait for redirect callback"));
     }
@@ -4683,16 +4698,18 @@ nsHttpChannel::Cancel(nsresult status)
 
 NS_IMETHODIMP
 nsHttpChannel::Suspend()
 {
     NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);
 
     LOG(("nsHttpChannel::Suspend [this=%p]\n", this));
 
+    printf_stderr("### ### [%p] nsHttpChannel::Suspend()\n", this);
+
     ++mSuspendCount;
 
     nsresult rvTransaction = NS_OK;
     if (mTransactionPump) {
         rvTransaction = mTransactionPump->Suspend();
     }
     nsresult rvCache = NS_OK;
     if (mCachePump) {
@@ -4702,16 +4719,18 @@ nsHttpChannel::Suspend()
     return NS_FAILED(rvTransaction) ? rvTransaction : rvCache;
 }
 
 NS_IMETHODIMP
 nsHttpChannel::Resume()
 {
     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
 
+    printf_stderr("### ### [%p] nsHttpChannel::Resume()\n", this);
+
     LOG(("nsHttpChannel::Resume [this=%p]\n", this));
 
     if (--mSuspendCount == 0 && mCallOnResume) {
         nsresult rv = AsyncCall(mCallOnResume);
         mCallOnResume = nullptr;
         NS_ENSURE_SUCCESS(rv, rv);
     }
 
@@ -5666,16 +5685,19 @@ nsHttpChannel::OnDataAvailable(nsIReques
                                uint64_t offset, uint32_t count)
 {
     PROFILER_LABEL("nsHttpChannel", "OnDataAvailable",
         js::ProfileEntry::Category::NETWORK);
 
     LOG(("nsHttpChannel::OnDataAvailable [this=%p request=%p offset=%llu count=%u]\n",
         this, request, offset, count));
 
+    printf_stderr("### ### [%p] nsHttpChannel::OnDataAvailable() canceled:%s\n",
+                  this, (mCanceled ? "true" : "false"));
+
     // don't send out OnDataAvailable notifications if we've been canceled.
     if (mCanceled)
         return mStatus;
 
     MOZ_ASSERT(mResponseHead, "No response head in ODA!!");
 
     MOZ_ASSERT(!(mCachedContentIsPartial && (request == mTransactionPump)),
                "transaction pump not suspended");
@@ -5738,16 +5760,18 @@ nsHttpChannel::OnDataAvailable(nsIReques
             MOZ_EVENT_TRACER_EXEC(this, "net::http::channel");
 
         int64_t offsetBefore = 0;
         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(input);
         if (seekable && NS_FAILED(seekable->Tell(&offsetBefore))) {
             seekable = nullptr;
         }
 
+        printf_stderr("### ### [%p] nsHttpChannel::OnDataAvailable() calling listener %p OnDataAvailable()\n",
+                      this, mListener.get());
         nsresult rv =  mListener->OnDataAvailable(this,
                                                   mListenerContext,
                                                   input,
                                                   mLogicalOffset,
                                                   count);
         if (NS_SUCCEEDED(rv)) {
             // by contract mListener must read all of "count" bytes, but
             // nsInputStreamPump is tolerant to seekable streams that violate that
