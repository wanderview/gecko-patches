# HG changeset patch
# Parent df34c3471f50f51398d92070591fe78bae00867a
# User Ben Kelly <ben@wanderview.com>
debug

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -594,16 +594,18 @@ Context::ThreadsafeHandle::AllowToClose(
     NS_NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 Context::ThreadsafeHandle::InvalidateAndAllowToClose()
 {
+  printf_stderr("### ### Context::ThreadsafeHandle::InvalidateAndAllowToClose()\n");
+
   if (mOwningThread == NS_GetCurrentThread()) {
     InvalidateAndAllowToCloseOnOwningThread();
     return;
   }
 
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all Contexts have been destroyed.
   nsCOMPtr<nsIRunnable> runnable =
@@ -640,23 +642,25 @@ Context::ThreadsafeHandle::~ThreadsafeHa
 void
 Context::ThreadsafeHandle::AllowToCloseOnOwningThread()
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
   // A Context "closes" when its ref count drops to zero.  Dropping this
   // strong ref is necessary, but not sufficient for the close to occur.
   // Any outstanding IO will continue and keep the Context alive.  Once
   // the Context is idle, it will be destroyed.
+  printf_stderr("### ### Context::ThreadsafeHandle::AllowToCloseOnOwningThread()\n");
   mStrongRef = nullptr;
 }
 
 void
 Context::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  printf_stderr("### ### Context::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()\n");
   // Cancel the Context through the weak reference.  This means we can
   // allow the Context to close by dropping the strong ref, but then
   // still cancel ongoing IO if necessary.
   if (mWeakRef) {
     mWeakRef->Invalidate();
   }
   // We should synchronously have AllowToCloseOnOwningThread called when
   // the Context is canceled.
@@ -665,16 +669,17 @@ Context::ThreadsafeHandle::InvalidateAnd
 
 void
 Context::ThreadsafeHandle::ContextDestroyed(Context* aContext)
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
   MOZ_ASSERT(!mStrongRef);
   MOZ_ASSERT(mWeakRef);
   MOZ_ASSERT(mWeakRef == aContext);
+  printf_stderr("### ### ThreadsafeHandle::ContextDestroyed()\n");
   mWeakRef = nullptr;
 }
 
 // static
 already_AddRefed<Context>
 Context::Create(Manager* aManager, Action* aQuotaIOThreadAction)
 {
   nsRefPtr<Context> context = new Context(aManager);
@@ -733,16 +738,17 @@ Context::CancelAll()
   }
   AllowToClose();
 }
 
 void
 Context::Invalidate()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+  printf_stderr("### ### Context::Invalidate()\n");
   mManager->Invalidate();
   CancelAll();
 }
 
 void
 Context::AllowToClose()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1214,22 +1214,27 @@ public:
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     // Look for existing cache
     bool cacheFound;
     nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mArgs.key(),
                                               &cacheFound, &mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (cacheFound) {
+      printf_stderr("### ### [%p] StorageOpenAction() found cache:%ld for key:%s\n",
+                    mManager.get(), mCacheId, NS_ConvertUTF16toUTF8(mArgs.key()).get());
       return rv;
     }
 
     rv = DBSchema::CreateCache(aConn, &mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+    printf_stderr("### ### [%p] StorageOpenAction() created cache:%ld for key:%s\n",
+                  mManager.get(), mCacheId, NS_ConvertUTF16toUTF8(mArgs.key()).get());
+
     rv = DBSchema::StoragePutCache(aConn, mNamespace, mArgs.key(), mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
@@ -1286,16 +1291,18 @@ public:
     mCacheDeleted = true;
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) override
   {
     if (mCacheDeleted) {
+      printf_stderr("### ### [%p] StorageDeleteAction::Complete() calling SetCacheIdOrphaned() cache:%ld key:%s\n",
+                    mManager.get(), mCacheId, NS_ConvertUTF16toUTF8(mArgs.key()).get());
       // If content is referencing this cache, mark it orphaned to be
       // deleted later.
       if (!mManager->SetCacheIdOrphanedIfRefed(mCacheId)) {
 
         // no outstanding references, delete immediately
         nsRefPtr<Context> context = mManager->CurrentContext();
         context->CancelForCacheId(mCacheId);
         nsRefPtr<Action> action =
@@ -1432,16 +1439,17 @@ Manager::RemoveListener(Listener* aListe
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   // There may not be a listener here in the case where an actor is killed
   // before it can perform any actual async requests on Manager.
   mListeners.RemoveElement(aListener, ListenerEntryListenerComparator());
   MOZ_ASSERT(!mListeners.Contains(aListener,
                                   ListenerEntryListenerComparator()));
   if (mListeners.IsEmpty() && mContext) {
+    printf_stderr("### ### [%p] Manager::RemoveListener() calling Context::AllowToClose()\n", this);
     mContext->AllowToClose();
   }
 }
 
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
@@ -1455,16 +1463,17 @@ Manager::RemoveContext(Context* aContext
     Factory::Remove(this);
   }
 }
 
 void
 Manager::Invalidate()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+  printf_stderr("### ### [%p] Invalidate()\n", this);
   // QuotaManager can trigger this more than once.
   mValid = false;
 }
 
 bool
 Manager::IsValid() const
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
@@ -1472,33 +1481,41 @@ Manager::IsValid() const
 }
 
 void
 Manager::AddRefCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      printf_stderr("### ### [%p] AddRefCacheId() cache:%ld ref:%lu to %lu\n",
+                    this, aCacheId, mCacheIdRefs[i].mCount,
+                    (mCacheIdRefs[i].mCount + 1));
       mCacheIdRefs[i].mCount += 1;
       return;
     }
   }
+  printf_stderr("### ### [%p] AddRefCacheId() cache:%ld ref:0 to 1\n",
+                this, aCacheId);
   CacheIdRefCounter* entry = mCacheIdRefs.AppendElement();
   entry->mCacheId = aCacheId;
   entry->mCount = 1;
   entry->mOrphaned = false;
 }
 
 void
 Manager::ReleaseCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
+      printf_stderr("### ### [%p] ReleaseCacheId() cache:%ld ref:%lu to %lu\n",
+                    this, aCacheId, mCacheIdRefs[i].mCount,
+                    (mCacheIdRefs[i].mCount - 1));
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount == 0) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
         // TODO: note that we need to check this cache for staleness on startup (bug 1110446)
         if (orphaned && !mShuttingDown && mValid) {
           nsRefPtr<Context> context = CurrentContext();
@@ -1800,16 +1817,22 @@ Manager::GetListener(ListenerId aListene
 
 bool
 Manager::SetCacheIdOrphanedIfRefed(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
+      printf_stderr("### ### [%p] SetCacheIdOrphasedIfRefed() cache:%ld ref:%lu orphaned:%s\n",
+                    this, aCacheId, mCacheIdRefs[i].mCount,
+                    (mCacheIdRefs[i].mOrphaned ? "true" : "false"));
+      if (mCacheIdRefs[i].mOrphaned) {
+        printf_stderr("### ### [%p] SetCacheIdOrphanedIfRefed() cache:%ld\n", this, aCacheId);
+      }
       MOZ_ASSERT(!mCacheIdRefs[i].mOrphaned);
       mCacheIdRefs[i].mOrphaned = true;
       return true;
     }
   }
   return false;
 }
 
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
--- a/dom/cache/OfflineStorage.cpp
+++ b/dom/cache/OfflineStorage.cpp
@@ -122,14 +122,15 @@ OfflineStorage::Close()
   mContext->AllowToClose();
   return NS_OK;
 }
 
 NS_IMETHODIMP_(void)
 OfflineStorage::Invalidate()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### OfflineStorage::Invalidate()\n");
   mContext->InvalidateAndAllowToClose();
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/test/mochitest/driver.js b/dom/cache/test/mochitest/driver.js
--- a/dom/cache/test/mochitest/driver.js
+++ b/dom/cache/test/mochitest/driver.js
@@ -36,16 +36,17 @@ function runTests(testFile, order) {
       var principal = SpecialPowers.wrap(document).nodePrincipal;
       var appId, inBrowser;
       var nsIPrincipal = SpecialPowers.Components.interfaces.nsIPrincipal;
       if (principal.appId != nsIPrincipal.UNKNOWN_APP_ID &&
           principal.appId != nsIPrincipal.NO_APP_ID) {
         appId = principal.appId;
         inBrowser = principal.isInBrowserElement;
       }
+      dump("### ### CLEAR STORAGE\n");
       SpecialPowers.clearStorageForURI(document.documentURI, resolve, appId,
                                        inBrowser);
     });
   }
 
   function loadScript(script) {
     return new Promise(function(resolve, reject) {
       var s = document.createElement("script");
