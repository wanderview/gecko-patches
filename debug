# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b5e71e776aa795c3004716c56c99b561a262ba50

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -7,26 +7,58 @@
 #include "Timeout.h"
 
 #include "mozilla/dom/TimeoutManager.h"
 
 namespace mozilla {
 namespace dom {
 
 Timeout::Timeout()
-  : mTimeoutId(0),
+  : mTime(AsVariant(TimeStamp())),
+    mTimeoutId(0),
     mFiringId(TimeoutManager::InvalidFiringId),
     mPopupState(openAllowed),
     mReason(Reason::eTimeoutOrInterval),
     mNestingLevel(0),
     mCleared(false),
     mRunning(false),
     mIsInterval(false),
     mIsTracking(false)
 {
+  printf_stderr("### ### mTime %lu\n", sizeof(mTime));
+  printf_stderr("### ### mWindow %lu\n", sizeof(mWindow));
+  printf_stderr("### ### mScriptHandler %lu\n", sizeof(mScriptHandler));
+  printf_stderr("### ### mInterval %lu\n", sizeof(mInterval));
+  printf_stderr("### ### mTimeoutId %lu\n", sizeof(mTimeoutId));
+  printf_stderr("### ### mFiringId %lu\n", sizeof(mFiringId));
+  printf_stderr("### ### mPopupState %lu\n", sizeof(mPopupState));
+  printf_stderr("### ### mReason %lu\n", sizeof(mReason));
+  printf_stderr("### ### mNestingLevel %lu\n", sizeof(mNestingLevel));
+  printf_stderr("### ### mCleared %lu\n", sizeof(mCleared));
+  printf_stderr("### ### mRunning %lu\n", sizeof(mRunning));
+  printf_stderr("### ### mIsInterval %lu\n", sizeof(mIsInterval));
+  printf_stderr("### ### mIsTracking %lu\n", sizeof(mIsTracking));
+
+  printf_stderr("### ### theoretical total %lu\n",
+                sizeof(mTime) +
+                sizeof(mWindow) +
+                sizeof(mScriptHandler) +
+                sizeof(mInterval) +
+                sizeof(mTimeoutId) +
+                sizeof(mFiringId) +
+                sizeof(mPopupState) +
+                sizeof(mReason) +
+                sizeof(mNestingLevel) +
+                sizeof(mCleared) +
+                sizeof(mRunning) +
+                sizeof(mIsInterval) +
+                sizeof(mIsTracking));
+
+  printf_stderr("### ### actual total %lu\n", sizeof(Timeout));
+
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(Timeout)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mWindow)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mScriptHandler)
   tmp->remove();
@@ -41,45 +73,42 @@ NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(Tim
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(Timeout, Release)
 
 void
 Timeout::SetWhenOrTimeRemaining(const TimeStamp& aBaseTime,
                                 const TimeDuration& aDelay)
 {
   MOZ_DIAGNOSTIC_ASSERT(mWindow);
 
-  // If we are frozen simply set mTimeRemaining to be the "time remaining" in
-  // the timeout (i.e., the interval itself).  This will be used to create a
-  // new mWhen time when the window is thawed.  The end effect is that time does
-  // not appear to pass for frozen windows.
+  // If we are frozen simply set mTime to be the "time remaining" in the timeout
+  // (i.e., the interval itself).  This will be used to create a new TimeStamp
+  // when the window is thawed.  The end effect is that time does not appear to
+  // pass for frozen windows.
   if (mWindow->IsFrozen()) {
-    mWhen = TimeStamp();
-    mTimeRemaining = aDelay;
+    mTime = AsVariant(aDelay);
     return;
   }
 
-  // Since we are not frozen we must set a precise mWhen target wakeup
-  // time.  Even if we are suspended we want to use this target time so
-  // that it appears time passes while suspended.
-  mWhen = aBaseTime + aDelay;
-  mTimeRemaining = TimeDuration(0);
+  // Since we are not frozen we must set a precise TimeStamp wakeup time.  Even
+  // if we are suspended we want to use this target time so that it appears time
+  // passes while suspended.
+  mTime = AsVariant(aBaseTime + aDelay);
 }
 
 const TimeStamp&
 Timeout::When() const
 {
-  MOZ_DIAGNOSTIC_ASSERT(!mWhen.IsNull());
+  MOZ_DIAGNOSTIC_ASSERT(!mTime.as<TimeStamp>().IsNull());
   // Note, mWindow->IsFrozen() can be true here.  The Freeze() method calls
-  // When() to calculate the delay to populate mTimeRemaining.
-  return mWhen;
+  // When() to calculate the delay to populate mTime as a TimeDuration.
+  return mTime.as<TimeStamp>();
 }
 
 const TimeDuration&
 Timeout::TimeRemaining() const
 {
-  MOZ_DIAGNOSTIC_ASSERT(mWhen.IsNull());
   // Note, mWindow->IsFrozen() can be false here.  The Thaw() method calls
   // TimeRemaining() to calculate the new When() value.
-  return mTimeRemaining;
+  return mTime.as<TimeDuration>();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -46,24 +46,22 @@ public:
 
   // Can only be called when not frozen.
   const TimeStamp& When() const;
 
   // Can only be called when frozen.
   const TimeDuration& TimeRemaining() const;
 
 private:
-  // mWhen and mTimeRemaining can't be in a union, sadly, because they
-  // have constructors.
-  // Nominal time to run this timeout.  Use only when timeouts are not
-  // frozen.
-  TimeStamp mWhen;
-
-  // Remaining time to wait.  Used only when timeouts are frozen.
-  TimeDuration mTimeRemaining;
+  // The mTime represents either:
+  // * Precise TimeStamp when to next run this Timeout.
+  // * TimeDuration delay for recalculating a precise Timeout when the
+  //   window is thawed.  This should only be set when the window is
+  //   frozen.
+  Variant<TimeStamp, TimeDuration> mTime;
 
   ~Timeout() = default;
 
 public:
   // Public member variables in this section.  Please don't add to this list
   // or mix methods with these.  The interleaving public/private sections
   // is necessary as we migrate members to private while still trying to
   // keep decent binary packing.
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -539,16 +539,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   // code can handle. (Note: we already forced |interval| to be non-negative,
   // so the uint32_t cast (to avoid compiler warnings) is ok.)
   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
   if (static_cast<uint32_t>(interval) > maxTimeoutMs) {
     interval = maxTimeoutMs;
   }
 
   RefPtr<Timeout> timeout = new Timeout();
+  printf_stderr("### ### Timeout size %lu\n", sizeof(Timeout));
   timeout->mWindow = &mWindow;
   timeout->mIsInterval = aIsInterval;
   timeout->mInterval = TimeDuration::FromMilliseconds(interval);
   timeout->mScriptHandler = aHandler;
   timeout->mReason = aReason;
 
   // No popups from timeouts by default
   timeout->mPopupState = openAbused;
