# HG changeset patch
# Parent 338e36ac64e0f986c7b68ce7517ff81699448f82
# User Ben Kelly <ben@wanderview.com>
debug

diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -34,30 +34,33 @@ DeallocPCacheParent(PCacheParent* aActor
 }
 
 CacheParent::CacheParent(cache::Manager* aManager, CacheId aCacheId)
   : mManager(aManager)
   , mCacheId(aCacheId)
 {
   MOZ_COUNT_CTOR(cache::CacheParent);
   MOZ_ASSERT(mManager);
+  printf_stderr("### ### [%p] CacheParent()\n", this);
   mManager->AddRefCacheId(mCacheId);
 }
 
 CacheParent::~CacheParent()
 {
   MOZ_COUNT_DTOR(cache::CacheParent);
   MOZ_ASSERT(!mManager);
   MOZ_ASSERT(mFetchPutList.IsEmpty());
+  printf_stderr("### ### [%p] ~CacheParent()\n", this);
 }
 
 void
 CacheParent::ActorDestroy(ActorDestroyReason aReason)
 {
   MOZ_ASSERT(mManager);
+  printf_stderr("### ### [%p] CacheParent::ActorDestroy()\n", this);
   for (uint32_t i = 0; i < mFetchPutList.Length(); ++i) {
     mFetchPutList[i]->ClearListener();
   }
   mFetchPutList.Clear();
   mManager->RemoveListener(this);
   mManager->ReleaseCacheId(mCacheId);
   mManager = nullptr;
 }
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -50,32 +50,37 @@ CacheStorageParent::CacheStorageParent(P
                                        Namespace aNamespace,
                                        const PrincipalInfo& aPrincipalInfo)
   : mNamespace(aNamespace)
   , mVerifiedStatus(NS_OK)
 {
   MOZ_COUNT_CTOR(cache::CacheStorageParent);
   MOZ_ASSERT(aManagingActor);
 
+  printf_stderr("### ### [%p] CacheStorageParent()\n", this);
+
   // Start the async principal verification process immediately.
   mVerifier = PrincipalVerifier::CreateAndDispatch(this, aManagingActor,
                                                    aPrincipalInfo);
   MOZ_ASSERT(mVerifier);
 }
 
 CacheStorageParent::~CacheStorageParent()
 {
   MOZ_COUNT_DTOR(cache::CacheStorageParent);
   MOZ_ASSERT(!mVerifier);
   MOZ_ASSERT(!mManager);
+  printf_stderr("### ### [%p] ~CacheStorageParent()\n", this);
 }
 
 void
 CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  printf_stderr("### ### [%p] CacheStorageParent::ActorDestroy()\n", this);
+
   if (mVerifier) {
     mVerifier->ClearListener();
     mVerifier = nullptr;
   }
 
   if (mManager) {
     MOZ_ASSERT(!mActiveRequests.IsEmpty());
     mManager->RemoveListener(this);
@@ -411,16 +416,17 @@ CacheStorageParent::RetryPendingRequests
 
 nsresult
 CacheStorageParent::RequestManager(RequestId aRequestId,
                                    cache::Manager** aManagerOut)
 {
   MOZ_ASSERT(!mActiveRequests.Contains(aRequestId));
   nsRefPtr<cache::Manager> ref = mManager;
   if (!ref) {
+    printf_stderr("### ### [%p] CacheStorageParent::RequestManager() new manager\n", this);
     MOZ_ASSERT(mActiveRequests.IsEmpty());
     nsresult rv = cache::Manager::GetOrCreate(mManagerId, getter_AddRefs(ref));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     mManager = ref;
   }
   mActiveRequests.AppendElement(aRequestId);
   ref.forget(aManagerOut);
   return NS_OK;
@@ -435,16 +441,17 @@ CacheStorageParent::ReleaseManager(Reque
   // Therefore ReleaseManager() should never be called after ActorDestroy()
   // runs.
   MOZ_ASSERT(mManager);
   MOZ_ASSERT(!mActiveRequests.IsEmpty());
 
   MOZ_ALWAYS_TRUE(mActiveRequests.RemoveElement(aRequestId));
 
   if (mActiveRequests.IsEmpty()) {
+    printf_stderr("### ### [%p] CacheStorageParent::ReleaseManager() forget manager\n", this);
     mManager->RemoveListener(this);
     mManager = nullptr;
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -620,16 +620,17 @@ Context::Create(Manager* aManager, Actio
   return context.forget();
 }
 
 Context::Context(Manager* aManager)
   : mManager(aManager)
   , mState(STATE_CONTEXT_INIT)
 {
   MOZ_ASSERT(mManager);
+  printf_stderr("### ### [%p] Context::Context() manager %p\n", this, aManager);
 }
 
 void
 Context::Dispatch(nsIEventTarget* aTarget, Action* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(aTarget);
   MOZ_ASSERT(aAction);
@@ -646,39 +647,42 @@ Context::Dispatch(nsIEventTarget* aTarge
   MOZ_ASSERT(STATE_CONTEXT_READY);
   DispatchAction(aTarget, aAction);
 }
 
 void
 Context::CancelAll()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+  printf_stderr("### ### [%p] Context()::CancelAll() manager %p\n", this, mManager.get());
   mState = STATE_CONTEXT_CANCELED;
   mPendingActions.Clear();
   {
     ActivityList::ForwardIterator iter(mActivityList);
     while (iter.HasMore()) {
       iter.GetNext()->Cancel();
     }
   }
   AllowToClose();
 }
 
 void
 Context::Invalidate()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+  printf_stderr("### ### [%p] Context()::Invalidate() manager %p\n", this, mManager.get());
   mManager->Invalidate();
   CancelAll();
 }
 
 void
 Context::AllowToClose()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+  printf_stderr("### ### [%p] Context()::AllowToClose() manager %p\n", this, mManager.get());
   if (mThreadsafeHandle) {
     mThreadsafeHandle->AllowToClose();
   }
 }
 
 void
 Context::CancelForCacheId(CacheId aCacheId)
 {
@@ -701,16 +705,18 @@ Context::CancelForCacheId(CacheId aCache
   }
 }
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mManager);
 
+  printf_stderr("### ### [%p] ~Context() manager %p\n", this, mManager.get());
+
   if (mThreadsafeHandle) {
     mThreadsafeHandle->ContextDestroyed(this);
   }
 
   mManager->RemoveContext(this);
 }
 
 void
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1087,16 +1087,17 @@ public:
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     mStreamList->Activate(mCacheId);
     aListener->OnCacheKeys(mRequestId, aRv, mSavedRequests, mStreamList);
+    // TODO: should we clear streamlist first?  can OnCacheKeys() trigger self-destruction?
     mStreamList = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
@@ -1426,16 +1427,17 @@ Manager::RemoveContext(Context* aContext
     Factory::Remove(this);
   }
 }
 
 void
 Manager::Invalidate()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+  printf_stderr("### ### [%p] Manager::Invalidate()\n", this);
   // QuotaManager can trigger this more than once.
   mValid = false;
 }
 
 bool
 Manager::IsValid() const
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
@@ -1746,22 +1748,24 @@ Manager::Manager(ManagerId* aManagerId, 
   : mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
   , mShuttingDown(false)
   , mValid(true)
 {
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
+  printf_stderr("### ### [%p] Manager()\n", this);
 }
 
 Manager::~Manager()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(!mContext);
+  printf_stderr("### ### [%p] ~Manager()\n", this);
   Shutdown();
 
   nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
 
   // Don't spin the event loop in the destructor waiting for the thread to
   // shutdown.  Defer this to the main thread, instead.
   nsCOMPtr<nsIRunnable> runnable =
@@ -1769,16 +1773,18 @@ Manager::~Manager()
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(runnable)));
 }
 
 void
 Manager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
+  printf_stderr("### ### [%p] Manager::Shutdown()\n", this);
+
   // Ignore duplicate attempts to shutdown.  This can occur when we start
   // a browser initiated shutdown and then run ~Manager() which also
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
 
   // Set a flag to prevent any new requests from coming in and creating
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
--- a/dom/cache/OfflineStorage.cpp
+++ b/dom/cache/OfflineStorage.cpp
@@ -37,16 +37,18 @@ OfflineStorage::Register(Context::Thread
 
   nsRefPtr<OfflineStorage> storage =
     new OfflineStorage(aContext, aQuotaInfo, client);
 
   if (NS_WARN_IF(!qm->RegisterStorage(storage))) {
     return nullptr;
   }
 
+  printf_stderr("### ### OfflineStorage::Register() registered %p\n", storage.get());
+
   return storage.forget();
 }
 
 void
 OfflineStorage::AddDestroyCallback(nsIRunnable* aCallback)
 {
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(!mDestroyCallbacks.Contains(aCallback));
@@ -58,23 +60,26 @@ OfflineStorage::OfflineStorage(Context::
                                Client* aClient)
   : mContext(aContext)
   , mQuotaInfo(aQuotaInfo)
   , mClient(aClient)
 {
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mClient);
 
+  printf_stderr("### ### [%p] OfflineStorage()\n", this);
+
   mPersistenceType = PERSISTENCE_TYPE_DEFAULT;
   mGroup = mQuotaInfo.mGroup;
 }
 
 OfflineStorage::~OfflineStorage()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### [%p] ~OfflineStorage()\n", this);
   QuotaManager* qm = QuotaManager::Get();
   MOZ_ASSERT(qm);
   qm->UnregisterStorage(this);
   for (uint32_t i = 0; i < mDestroyCallbacks.Length(); ++i) {
     mDestroyCallbacks[i]->Run();
   }
 }
 
@@ -91,16 +96,17 @@ OfflineStorage::GetClient()
   MOZ_ASSERT(NS_IsMainThread());
   return mClient;
 }
 
 NS_IMETHODIMP_(bool)
 OfflineStorage::IsOwnedByProcess(ContentParent* aOwner)
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### [%p] OfflineStorage::IsOwnedByProcess()\n", this);
   // The Cache and Context can be shared by multiple client processes.  They
   // are not exclusively owned by a single process.
   //
   // As far as I can tell this is used by QuotaManager to shutdown storages
   // when a particular process goes away.  We definitely don't want this
   // since we are shared.  Also, the Cache actor code already properly
   // handles asynchronous actor destruction when the child process dies.
   //
@@ -114,22 +120,24 @@ OfflineStorage::Origin()
   MOZ_ASSERT(NS_IsMainThread());
   return mQuotaInfo.mOrigin;
 }
 
 NS_IMETHODIMP_(nsresult)
 OfflineStorage::Close()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### [%p] OfflineStorage::Close()\n", this);
   mContext->AllowToClose();
   return NS_OK;
 }
 
 NS_IMETHODIMP_(void)
 OfflineStorage::Invalidate()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### [%p] OfflineStorage::Invalidate()\n", this);
   mContext->InvalidateAndAllowToClose();
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/quota/QuotaManager.cpp b/dom/quota/QuotaManager.cpp
--- a/dom/quota/QuotaManager.cpp
+++ b/dom/quota/QuotaManager.cpp
@@ -1264,22 +1264,24 @@ QuotaManager::QuotaManager()
   mQuotaMutex("QuotaManager.mQuotaMutex"),
   mTemporaryStorageLimit(0),
   mTemporaryStorageUsage(0),
   mTemporaryStorageInitialized(false),
   mStorageAreaInitialized(false)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   NS_ASSERTION(!gInstance, "More than one instance!");
+  printf_stderr("### ### [%p] QuotaManager()\n", this);
 }
 
 QuotaManager::~QuotaManager()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   NS_ASSERTION(!gInstance || gInstance == this, "Different instances!");
+  printf_stderr("### ### [%p] ~QuotaManager()\n", this);
   gInstance = nullptr;
 }
 
 // static
 QuotaManager*
 QuotaManager::GetOrCreate()
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
