# HG changeset patch
# Parent 1493ae3be1df6d143d391396364fdfef7506b27f
# User Ben Kelly <ben@wanderview.com>
Debug intermittent

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -265,16 +265,20 @@ AutoChildRequestResponse::Add(InternalRe
   mTypeUtils->ToPCacheRequest(mRequestResponse.request(), aRequest, aBodyAction,
                               aReferrerAction, aSchemeAction, aRv);
 }
 
 void
 AutoChildRequestResponse::Add(Response& aResponse, ErrorResult& aRv)
 {
   MOZ_ASSERT(!mSent);
+  nsCOMPtr<nsIInputStream> body;
+  aResponse.GetBody(getter_AddRefs(body));
+  printf_stderr("### ### [%p] AutoChildRequestResponse::Add() response body %p\n",
+                this, body.get());
   mTypeUtils->ToPCacheResponse(mRequestResponse.response(), aResponse, aRv);
 }
 
 const CacheRequestResponse&
 AutoChildRequestResponse::SendAsRequestResponse()
 {
   MOZ_ASSERT(!mSent);
   mSent = true;
diff --git a/dom/cache/CachePushStreamChild.cpp b/dom/cache/CachePushStreamChild.cpp
--- a/dom/cache/CachePushStreamChild.cpp
+++ b/dom/cache/CachePushStreamChild.cpp
@@ -114,24 +114,27 @@ CachePushStreamChild::Start()
 {
   DoRead();
 }
 
 void
 CachePushStreamChild::StartDestroy()
 {
   // called if we are running on a Worker and the thread gets shutdown
+  printf_stderr("### ### [%p] CachePushStreamChild::StartDestroy()\n", this);
   OnEnd(NS_ERROR_ABORT);
 }
 
 void
 CachePushStreamChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CachePushStreamChild);
 
+  printf_stderr("### ### [%p] CachePushStreamChild::ActorDestroy()\n", this);
+
   // If the parent side runs into a problem then the actor will be destroyed.
   // In this case we have not run OnEnd(), so still need to close the input
   // stream.
   if (!mClosed) {
     mStream->CloseWithStatus(NS_ERROR_ABORT);
     mClosed = true;
   }
 
@@ -177,61 +180,70 @@ CachePushStreamChild::DoRead()
       return;
     }
 
     uint32_t expectedBytes =
       static_cast<uint32_t>(std::min(available, kMaxBytesPerMessage));
 
     buffer.SetLength(expectedBytes);
 
+    printf_stderr("### ### [%p] CachePushStreamChild::DoRead() trying to read %u bytes\n",
+                  this, expectedBytes);
+
     uint32_t bytesRead = 0;
     rv = mStream->Read(buffer.BeginWriting(), buffer.Length(), &bytesRead);
     buffer.SetLength(bytesRead);
 
     // If we read any data from the stream, send it across.
     if (!buffer.IsEmpty()) {
+      printf_stderr("### ### [%p] CachePushStreamChild::DoRead() sending %u bytes\n",
+                    this, buffer.Length());
       unused << SendBuffer(buffer);
     }
 
     if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
       Wait();
       return;
     }
 
     // Any other error or zero-byte read indicates end-of-stream
     if (NS_FAILED(rv) || buffer.IsEmpty()) {
       OnEnd(rv);
       return;
     }
   }
+  printf_stderr("### ### [%p] CachePushStreamChild::DoRead() unexpected end to loop\n", this);
 }
 
 void
 CachePushStreamChild::Wait()
 {
   NS_ASSERT_OWNINGTHREAD(CachePushStreamChild);
   MOZ_ASSERT(!mClosed);
   MOZ_ASSERT(!mCallback);
 
+  printf_stderr("### ### [%p] CachePushStreamChild::Wait()\n", this);
+
   // Set mCallback immediately instead of waiting for success.  Its possible
   // AsyncWait() will callback synchronously.
   mCallback = new Callback(this);
   nsresult rv = mStream->AsyncWait(mCallback, 0, 0, nullptr);
   if (NS_FAILED(rv)) {
     OnEnd(rv);
     return;
   }
 }
 
 void
 CachePushStreamChild::OnStreamReady(Callback* aCallback)
 {
   NS_ASSERT_OWNINGTHREAD(CachePushStreamChild);
   MOZ_ASSERT(mCallback);
   MOZ_ASSERT(aCallback == mCallback);
+  printf_stderr("### ### [%p] CachePushStreamChild::OnStreamReady()\n", this);
   mCallback->ClearActor();
   mCallback = nullptr;
   DoRead();
 }
 
 void
 CachePushStreamChild::OnEnd(nsresult aRv)
 {
@@ -239,16 +251,18 @@ CachePushStreamChild::OnEnd(nsresult aRv
   MOZ_ASSERT(aRv != NS_BASE_STREAM_WOULD_BLOCK);
 
   if (mClosed) {
     return;
   }
 
   mClosed = true;
 
+  printf_stderr("### ### [%p] CachePushStreamChild::OnEnd() rv:%x\n", this, aRv);
+
   mStream->CloseWithStatus(aRv);
 
   if (aRv == NS_BASE_STREAM_CLOSED) {
     aRv = NS_OK;
   }
 
   // This will trigger an ActorDestroy() from the parent side
   unused << SendClose(aRv);
diff --git a/dom/cache/CachePushStreamParent.cpp b/dom/cache/CachePushStreamParent.cpp
--- a/dom/cache/CachePushStreamParent.cpp
+++ b/dom/cache/CachePushStreamParent.cpp
@@ -49,40 +49,50 @@ CachePushStreamParent::TakeReader()
 {
   MOZ_ASSERT(mReader);
   return mReader.forget();
 }
 
 void
 CachePushStreamParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  printf_stderr("### ### [%p] CachePushStreamParent::ActorDestroy()\n", this);
   // If we were gracefully closed we should have gotten RecvClose().  In
   // that case, the writer will already be closed and this will have no
   // effect.  This just aborts the writer in the case where the child process
   // crashes.
   mWriter->CloseWithStatus(NS_ERROR_ABORT);
 }
 
 bool
 CachePushStreamParent::RecvBuffer(const nsCString& aBuffer)
 {
   uint32_t numWritten = 0;
 
+  printf_stderr("### ### [%p] CachePushStreamParent::RecvBuffer() got %u bytes\n",
+                this, aBuffer.Length());
+
   // This should only fail if we hit an OOM condition.
   nsresult rv = mWriter->Write(aBuffer.get(), aBuffer.Length(), &numWritten);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     RecvClose(rv);
   }
 
+  printf_stderr("### ### [%p] CachePushStreamParent::RecvBuffer() wrote %u bytes\n",
+                this, numWritten);
+
   return true;
 }
 
 bool
 CachePushStreamParent::RecvClose(const nsresult& aRv)
 {
+  printf_stderr("### ### [%p] CachePushStreamParent::RecvClose() rv:%x\n",
+                this, aRv);
+
   mWriter->CloseWithStatus(aRv);
   unused << Send__delete__(this);
   return true;
 }
 
 CachePushStreamParent::CachePushStreamParent(nsIAsyncInputStream* aReader,
                                              nsIAsyncOutputStream* aWriter)
   : mReader(aReader)
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -728,16 +728,18 @@ private:
     if (NS_SUCCEEDED(aRv) && IsCanceled()) {
       aRv = NS_ERROR_ABORT;
     }
 
     // If any of the async copies fail, we need to still wait for them all to
     // complete.  Cancel any other streams still working and remember the
     // error.  All canceled streams will call OnAsyncCopyComplete().
     if (NS_FAILED(aRv) && NS_SUCCEEDED(mAsyncResult)) {
+      printf_stderr("### ### [%p] CachePutAllAction::OnAsyncCopyComplete() error %x\n",
+                    this, aRv);
       CancelAllStreamCopying();
       mAsyncResult = aRv;
     }
 
     // Check to see if async copying is still on-going.  If so, then simply
     // return for now.  We must wait for a later OnAsyncCopyComplete() call.
     mExpectedAsyncCopyCompletions -= 1;
     if (mExpectedAsyncCopyCompletions > 0) {
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -444,35 +444,38 @@ TypeUtils::SerializeCacheStream(nsIInput
   *aStreamOut = void_t();
   if (!aStream) {
     return;
   }
 
   // Option 1: Send a cache-specific ReadStream if we can.
   nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
   if (controlled) {
+    printf_stderr("### ### TypeUtils::SerializeCacheStream() controlled read stream %p\n", aStream);
     controlled->Serialize(aStreamOut);
     return;
   }
 
   PCacheReadStream readStream;
   readStream.controlChild() = nullptr;
   readStream.controlParent() = nullptr;
   readStream.pushStreamChild() = nullptr;
   readStream.pushStreamParent() = nullptr;
 
   // Option 2: Do normal stream serialization if its supported.
   nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
   if (serial) {
+    printf_stderr("### ### TypeUtils::SerializeCacheStream() normal stream %p\n", aStream);
     SerializeNormalStream(aStream, readStream);
 
   // Option 3: As a last resort push data across manually.  Should only be
   //           needed for nsPipe input stream.  Only works for async,
   //           non-blocking streams.
   } else {
+    printf_stderr("### ### TypeUtils::SerializeCacheStream() push stream %p\n", aStream);
     SerializePushStream(aStream, readStream, aRv);
     if (NS_WARN_IF(aRv.Failed())) { return; }
   }
 
   *aStreamOut = readStream;
 }
 
 void
diff --git a/dom/fetch/InternalResponse.cpp b/dom/fetch/InternalResponse.cpp
--- a/dom/fetch/InternalResponse.cpp
+++ b/dom/fetch/InternalResponse.cpp
@@ -31,31 +31,34 @@ InternalResponse::Clone()
   clone->mHeaders = new InternalHeaders(*mHeaders);
   if (mWrappedResponse) {
     clone->mWrappedResponse = mWrappedResponse->Clone();
     MOZ_ASSERT(!mBody);
     return clone.forget();
   }
 
   if (!mBody) {
+    printf_stderr("### ### [%p] InternalResponse::Clone() null body\n", this);
     return clone.forget();
   }
 
   nsCOMPtr<nsIInputStream> clonedBody;
   nsCOMPtr<nsIInputStream> replacementBody;
 
   nsresult rv = NS_CloneInputStream(mBody, getter_AddRefs(clonedBody),
                                     getter_AddRefs(replacementBody));
   if (NS_WARN_IF(NS_FAILED(rv))) { return nullptr; }
 
   clone->mBody.swap(clonedBody);
   if (replacementBody) {
     mBody.swap(replacementBody);
   }
 
+  MOZ_ASSERT(clone->mBody);
+
   return clone.forget();
 }
 
 already_AddRefed<InternalResponse>
 InternalResponse::BasicResponse()
 {
   MOZ_ASSERT(!mWrappedResponse, "Can't BasicResponse a already wrapped response");
   nsRefPtr<InternalResponse> basic = CreateIncompleteCopy();
diff --git a/dom/fetch/InternalResponse.h b/dom/fetch/InternalResponse.h
--- a/dom/fetch/InternalResponse.h
+++ b/dom/fetch/InternalResponse.h
@@ -124,17 +124,17 @@ public:
     if (mWrappedResponse) {
       return mWrappedResponse->Headers();
     };
 
     return Headers();
   }
 
   void
-  GetBody(nsIInputStream** aStream)
+  GetBody(nsIInputStream** aStream) const
   {
     if (Type() == ResponseType::Opaque) {
       *aStream = nullptr;
       return;
     }
 
     if (mWrappedResponse) {
       MOZ_ASSERT(!mBody);
diff --git a/dom/fetch/Response.cpp b/dom/fetch/Response.cpp
--- a/dom/fetch/Response.cpp
+++ b/dom/fetch/Response.cpp
@@ -195,18 +195,30 @@ Response::Constructor(const GlobalObject
 already_AddRefed<Response>
 Response::Clone(ErrorResult& aRv) const
 {
   if (BodyUsed()) {
     aRv.ThrowTypeError(MSG_FETCH_BODY_CONSUMED_ERROR);
     return nullptr;
   }
 
+  nsCOMPtr<nsIInputStream> originalBody;
+  GetBody(getter_AddRefs(originalBody));
+
   nsRefPtr<InternalResponse> ir = mInternalResponse->Clone();
   nsRefPtr<Response> response = new Response(mOwner, ir);
+
+  nsCOMPtr<nsIInputStream> cloneBody;
+  response->GetBody(getter_AddRefs(cloneBody));
+
+  if (originalBody && !cloneBody) {
+    printf_stderr("### ### [%p] Response::Clone() bodies original:%p clone:%p\n",
+                  this, originalBody.get(), cloneBody.get());
+  }
+
   return response.forget();
 }
 
 void
 Response::SetBody(nsIInputStream* aBody)
 {
   MOZ_ASSERT(!BodyUsed());
   mInternalResponse->SetBody(aBody);
diff --git a/dom/fetch/Response.h b/dom/fetch/Response.h
--- a/dom/fetch/Response.h
+++ b/dom/fetch/Response.h
@@ -88,17 +88,17 @@ public:
   GetInternalHeaders() const
   {
     return mInternalResponse->Headers();
   }
 
   Headers* Headers_();
 
   void
-  GetBody(nsIInputStream** aStream) { return mInternalResponse->GetBody(aStream); }
+  GetBody(nsIInputStream** aStream) const { return mInternalResponse->GetBody(aStream); }
 
   static already_AddRefed<Response>
   Error(const GlobalObject& aGlobal);
 
   static already_AddRefed<Response>
   Redirect(const GlobalObject& aGlobal, const nsAString& aUrl, uint16_t aStatus, ErrorResult& aRv);
 
   static already_AddRefed<Response>
