# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fd945a774baf143684cd60e68843f7b1b649070b

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -690,16 +690,17 @@ class MessageEventRunnable final : publi
 {
 public:
   MessageEventRunnable(WorkerPrivate* aWorkerPrivate,
                        TargetAndBusyBehavior aBehavior)
   : WorkerRunnable(aWorkerPrivate, aBehavior)
   , StructuredCloneHolder(CloningSupported, TransferringSupported,
                           StructuredCloneScope::SameProcessDifferentThread)
   {
+    printf_stderr("### ### MessageEventRunnable()\n");
   }
 
   bool
   DispatchDOMEvent(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
                    DOMEventTargetHelper* aTarget, bool aIsMainThread)
   {
     nsCOMPtr<nsIGlobalObject> parent = do_QueryInterface(aTarget->GetParentObject());
 
@@ -775,16 +776,17 @@ public:
 
     return true;
   }
 
 private:
   virtual bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
+    printf_stderr("### ### MessageEventRunnable::WorkerRun()\n");
     if (mBehavior == ParentThreadUnchangedBusyCount) {
       // Don't fire this event if the JS object has been disconnected from the
       // private object.
       if (!aWorkerPrivate->IsAcceptingEvents()) {
         return true;
       }
 
       if (aWorkerPrivate->IsFrozen() ||
@@ -797,16 +799,20 @@ private:
       aWorkerPrivate->AssertInnerWindowIsCorrect();
 
       return DispatchDOMEvent(aCx, aWorkerPrivate, aWorkerPrivate,
                               !aWorkerPrivate->GetParent());
     }
 
     MOZ_ASSERT(aWorkerPrivate == GetWorkerPrivateFromContext(aCx));
 
+    if (!aWorkerPrivate->IsAcceptingEventsOnWorkerThread()) {
+      return true;
+    }
+
     return DispatchDOMEvent(aCx, aWorkerPrivate, aWorkerPrivate->GlobalScope(),
                             false);
   }
 };
 
 class DebuggerMessageEventRunnable : public WorkerDebuggerRunnable {
   nsString mMessage;
 
@@ -3417,17 +3423,20 @@ WorkerPrivateParent<Derived>::PostMessag
     timelines->AddMarkerForAllObservedDocShells(end);
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   if (!runnable->Dispatch()) {
+    printf_stderr("### ### PostMessageInternal() dispatch failed\n");
     aRv.Throw(NS_ERROR_FAILURE);
+  } else {
+    printf_stderr("### ### PostMessageInternal() dispatch succeeded\n");
   }
 }
 
 template <class Derived>
 void
 WorkerPrivateParent<Derived>::PostMessage(
                              JSContext* aCx, JS::Handle<JS::Value> aMessage,
                              const Sequence<JSObject*>& aTransferable,
@@ -6249,16 +6258,18 @@ WorkerPrivate::NotifyInternal(JSContext*
 
     if (mStatus >= aStatus) {
       MOZ_ASSERT(!mEventTarget);
       return true;
     }
 
     previousStatus = mStatus;
     mStatus = aStatus;
+    printf_stderr("### ### NotifyInternal() status %u to %u\n",
+                  (uint32_t)previousStatus, (uint32_t)mStatus);
 
     mEventTarget.swap(eventTarget);
   }
 
   // Now that mStatus > Running, no-one can create a new WorkerEventTarget or
   // WorkerCrossThreadDispatcher if we don't already have one.
   if (eventTarget) {
     // Since we'll no longer process events, make sure we no longer allow anyone
@@ -6282,32 +6293,36 @@ WorkerPrivate::NotifyInternal(JSContext*
 
   // Let all our holders know the new status.
   NotifyHolders(aCx, aStatus);
   MOZ_ASSERT(!JS_IsExceptionPending(aCx));
 
   // If this is the first time our status has changed then we need to clear the
   // main event queue.
   if (previousStatus == Running) {
+    printf_stderr("### ### NotifyInternal() previous state running\n");
     // NB: If we're in a sync loop, we can't clear the queue immediately,
     // because this is the wrong queue. So we have to defer it until later.
     if (!mSyncLoopStack.IsEmpty()) {
+      printf_stderr("### ### NotifyInternal() sync loop delays event queue clearing\n");
       mPendingEventQueueClearing = true;
     } else {
+      printf_stderr("### ### NotifyInternal() clear event queue\n");
       ClearMainEventQueue(WorkerRan);
     }
   }
 
   // If the worker script never ran, or failed to compile, we don't need to do
   // anything else.
   if (!GlobalScope()) {
     return true;
   }
 
   if (aStatus == Closing) {
+    printf_stderr("### ### NotifyInternal() disable CloseRunnable\n");
     // Notify parent to stop sending us messages and balance our busy count.
     RefPtr<CloseRunnable> runnable = new CloseRunnable(this);
     if (!runnable->Dispatch()) {
       return false;
     }
 
     // Don't abort the script.
     return true;
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -470,17 +470,17 @@ public:
 
   bool
   IsAcceptingEvents()
   {
     AssertIsOnParentThread();
 
     MutexAutoLock lock(mMutex);
     return mParentStatus < Terminating;
-    }
+  }
 
   Status
   ParentStatus() const
   {
     mMutex.AssertCurrentThreadOwns();
     return mParentStatus;
   }
 
@@ -1482,16 +1482,25 @@ public:
   GetClientInfo() const;
 
   void
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   void
   ExecutionReady();
 
+  bool
+  IsAcceptingEventsOnWorkerThread()
+  {
+    AssertIsOnWorkerThread();
+
+    MutexAutoLock lock(mMutex);
+    return mStatus < Closing;
+  }
+
 private:
   WorkerPrivate(WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsACString& aSharedWorkerName,
                 WorkerLoadInfo& aLoadInfo);
 
   bool
   MayContinueRunning()
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -538,16 +538,17 @@ DedicatedWorkerGlobalScope::PostMessage(
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
   mWorkerPrivate->PostMessageToParent(aCx, aMessage, aTransferable, aRv);
 }
 
 void
 DedicatedWorkerGlobalScope::Close(JSContext* aCx)
 {
+  printf_stderr("### ### DedicatedWorkerGlobalScope::Close()\n");
   mWorkerPrivate->AssertIsOnWorkerThread();
   mWorkerPrivate->CloseInternal(aCx);
 }
 
 SharedWorkerGlobalScope::SharedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate,
                                                  const nsCString& aName)
 : WorkerGlobalScope(aWorkerPrivate), mName(aName)
 {
diff --git a/testing/web-platform/tests/workers/support/WorkerClose.js b/testing/web-platform/tests/workers/support/WorkerClose.js
--- a/testing/web-platform/tests/workers/support/WorkerClose.js
+++ b/testing/web-platform/tests/workers/support/WorkerClose.js
@@ -1,5 +1,7 @@
 onmessage = function(evt)
 {
+    dump('### ### WorkerClose.js got message\n');
     postMessage(evt.data);
+    dump('### ### WorkerClose.js calling close()\n');
     self.close();
-}
\ No newline at end of file
+}
