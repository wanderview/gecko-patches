# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  263509d6c9a209a2fbb077e8ce25d717fe2aef83

diff --git a/devtools/client/aboutdebugging/components/workers/ServiceWorkerTarget.js b/devtools/client/aboutdebugging/components/workers/ServiceWorkerTarget.js
--- a/devtools/client/aboutdebugging/components/workers/ServiceWorkerTarget.js
+++ b/devtools/client/aboutdebugging/components/workers/ServiceWorkerTarget.js
@@ -55,25 +55,27 @@ class ServiceWorkerTarget extends Compon
     this.getServiceWorkerStatus = this.getServiceWorkerStatus.bind(this);
     this.renderButtons = this.renderButtons.bind(this);
     this.renderUnregisterLink = this.renderUnregisterLink.bind(this);
   }
 
   componentDidMount() {
     let { client } = this.props;
     client.addListener("push-subscription-modified", this.onPushSubscriptionModified);
+    dump('### ### componentDidMount() calling updatePushSubscription\n');
     this.updatePushSubscription();
   }
 
   componentDidUpdate(oldProps, oldState) {
     let wasActive = oldProps.target.active;
     if (!wasActive && this.isActive()) {
       // While the service worker isn't active, any calls to `updatePushSubscription`
       // won't succeed. If we just became active, make sure we didn't miss a push
       // subscription change by updating it now.
+      dump('### ### componentDidUpdate() calling updatePushSubscription\n');
       this.updatePushSubscription();
     }
   }
 
   componentWillUnmount() {
     let { client } = this.props;
     client.removeListener("push-subscription-modified", this.onPushSubscriptionModified);
   }
@@ -120,33 +122,37 @@ class ServiceWorkerTarget extends Compon
     let { client, target } = this.props;
     client.request({
       to: target.registrationActor,
       type: "unregister"
     });
   }
 
   onPushSubscriptionModified(type, data) {
+    dump('### ### OnPushSubscriptionModified()\n');
     let { target } = this.props;
     if (data.from === target.registrationActor) {
+      dump('### ### updatePushSubscription() calling updatePushSubscription\n');
       this.updatePushSubscription();
     }
   }
 
   updatePushSubscription() {
+    dump('### ### updatePushSubscription()\n');
     if (!this.props.target.registrationActor) {
       // A valid registrationActor is needed to retrieve the push subscription.
       return;
     }
 
     let { client, target } = this.props;
     client.request({
       to: target.registrationActor,
       type: "getPushSubscription"
     }, ({ subscription }) => {
+      dump('### ### updatePushSubscription() call setState with subscription ' + subscription + '\n');
       this.setState({ pushSubscription: subscription });
     });
   }
 
   isRunning() {
     // We know the target is running if it has a worker actor.
     return !!this.props.target.workerActor;
   }
@@ -208,16 +214,18 @@ class ServiceWorkerTarget extends Compon
     }, Strings.GetStringFromName("unregister"));
   }
 
   render() {
     let { target } = this.props;
     let { pushSubscription } = this.state;
     let status = this.getServiceWorkerStatus();
 
+    dump('### ### render() ' + pushSubscription + '\n');
+
     let fetch = target.fetch ? Strings.GetStringFromName("listeningForFetchEvents") :
       Strings.GetStringFromName("notListeningForFetchEvents");
 
     return dom.div({ className: "target-container" },
       dom.img({
         className: "target-icon",
         role: "presentation",
         src: target.icon
diff --git a/devtools/client/aboutdebugging/test/browser_service_workers_push_service.js b/devtools/client/aboutdebugging/test/browser_service_workers_push_service.js
--- a/devtools/client/aboutdebugging/test/browser_service_workers_push_service.js
+++ b/devtools/client/aboutdebugging/test/browser_service_workers_push_service.js
@@ -21,34 +21,38 @@ add_task(function* () {
   yield enableServiceWorkerDebugging();
   // Enable the push service.
   yield pushPref("dom.push.connection.enabled", true);
 
   info("Mock the push service");
   PushService.service = {
     _registrations: new Map(),
     _notify(scope) {
+      dump('### ### PushService mock _notify\n');
       Services.obs.notifyObservers(
         null,
         PushService.subscriptionModifiedTopic,
         scope);
     },
     init() {},
     register(pageRecord) {
+      dump('### ### PushService mock register()\n');
       let registration = {
         endpoint: FAKE_ENDPOINT
       };
       this._registrations.set(pageRecord.scope, registration);
       this._notify(pageRecord.scope);
       return Promise.resolve(registration);
     },
     registration(pageRecord) {
+      dump('### ### PushService mock registration() ' + pageRecord.scope + '\n');
       return Promise.resolve(this._registrations.get(pageRecord.scope));
     },
     unregister(pageRecord) {
+      dump('### ### PushService mock unregister()\n');
       let deleted = this._registrations.delete(pageRecord.scope);
       if (deleted) {
         this._notify(pageRecord.scope);
       }
       return Promise.resolve(deleted);
     },
   };
 
diff --git a/devtools/client/aboutdebugging/test/service-workers/push-sw.js b/devtools/client/aboutdebugging/test/service-workers/push-sw.js
--- a/devtools/client/aboutdebugging/test/service-workers/push-sw.js
+++ b/devtools/client/aboutdebugging/test/service-workers/push-sw.js
@@ -1,33 +1,38 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 /* eslint-env worker */
 /* global clients */
 
 "use strict";
 
+dump('### ### SW eval\n');
+
 // Send a message to all controlled windows.
 function postMessage(message) {
   return clients.matchAll().then(function (clientlist) {
     clientlist.forEach(function (client) {
+      dump('### ### SW post message to ' + client.url + '\n');
       client.postMessage(message);
     });
   });
 }
 
 // Don't wait for the next page load to become the active service worker.
 self.addEventListener("install", function (event) {
   event.waitUntil(self.skipWaiting());
 });
 
 // Claim control over the currently open test page when activating.
 self.addEventListener("activate", function (event) {
+  dump('### ### SW activate calling claim\n');
   event.waitUntil(self.clients.claim().then(function () {
+    dump('### ### SW claim complete\n');
     return postMessage("sw-claimed");
   }));
 });
 
 // Forward all "push" events to the controlled window.
 self.addEventListener("push", function (event) {
   event.waitUntil(postMessage("sw-pushed"));
 });
diff --git a/devtools/server/actors/worker.js b/devtools/server/actors/worker.js
--- a/devtools/server/actors/worker.js
+++ b/devtools/server/actors/worker.js
@@ -189,35 +189,38 @@ let WorkerActor = protocol.ActorClassWit
     this._attached = false;
   }
 });
 
 exports.WorkerActor = WorkerActor;
 
 let PushSubscriptionActor = protocol.ActorClassWithSpec(pushSubscriptionSpec, {
   initialize(conn, subscription) {
+    dump('### ### PushSubscriptionActor.initialize()\n');
     protocol.Actor.prototype.initialize.call(this, conn);
     this._subscription = subscription;
   },
 
   form(detail) {
+    dump('### ### PushSubscriptionActor.form()\n');
     if (detail === "actorid") {
       return this.actorID;
     }
     let subscription = this._subscription;
     return {
       actor: this.actorID,
       endpoint: subscription.endpoint,
       pushCount: subscription.pushCount,
       lastPush: subscription.lastPush,
       quota: subscription.quota
     };
   },
 
   destroy() {
+    dump('### ### PushSubscriptionActor.destroy()\n');
     protocol.Actor.prototype.destroy.call(this);
     this._subscription = null;
   },
 });
 
 let ServiceWorkerActor = protocol.ActorClassWithSpec(serviceWorkerSpec, {
   initialize(conn, worker) {
     protocol.Actor.prototype.initialize.call(this, conn);
@@ -384,32 +387,38 @@ protocol.ActorClassWithSpec(serviceWorke
         [Ci.nsIServiceWorkerUnregisterCallback])
     };
     swm.propagateUnregister(principal, unregisterCallback, scope);
 
     return { type: "unregistered" };
   },
 
   getPushSubscription() {
+    dump('### ### getPushSubscription()\n');
     let registration = this._registration;
     let pushSubscriptionActor = this._pushSubscriptionActor;
     if (pushSubscriptionActor) {
+      dump('### ### getPushSubscription() resolve existing ' + pushSubscriptionActor + '\n');
       return Promise.resolve(pushSubscriptionActor);
     }
     return new Promise((resolve, reject) => {
+      dump('### ### getPushSubscription() calling getSubscription with scope ' + registration.scope + '\n');
       PushService.getSubscription(
         registration.scope,
         registration.principal,
         (result, subscription) => {
           if (!subscription) {
+            dump('### ### getPushSubscription() no subscription\n');
+            dump('### ### getPushSubscription() resolving null\n');
             resolve(null);
             return;
           }
           pushSubscriptionActor = new PushSubscriptionActor(this._conn, subscription);
           this._pushSubscriptionActor = pushSubscriptionActor;
+          dump('### ### getPushSubscription() resolving ' + pushSubscriptionActor + '\n');
           resolve(pushSubscriptionActor);
         }
       );
     });
   },
 });
 
 exports.ServiceWorkerRegistrationActor = ServiceWorkerRegistrationActor;
diff --git a/devtools/shared/specs/worker.js b/devtools/shared/specs/worker.js
--- a/devtools/shared/specs/worker.js
+++ b/devtools/shared/specs/worker.js
@@ -57,17 +57,20 @@ const serviceWorkerRegistrationSpec = ge
     },
     unregister: {
       request: {},
       response: RetVal("json")
     },
     getPushSubscription: {
       request: {},
       response: {
-        subscription: RetVal("nullable:pushSubscription")
+        subscription: function() {
+          dump('### ### dummy subscription\n');
+          return RetVal("nullable:pushSubscription")();
+        }
       }
     },
   },
 });
 
 exports.serviceWorkerRegistrationSpec = serviceWorkerRegistrationSpec;
 
 const serviceWorkerSpec = generateActorSpec({
