# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fcd35e10fa17d9fd11d92be48ae9698c2a900f1c

diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/performance-timeline-worker.js b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/performance-timeline-worker.js
--- a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/performance-timeline-worker.js
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/performance-timeline-worker.js
@@ -1,17 +1,25 @@
 importScripts('/resources/testharness.js');
 
 promise_test(function(test) {
     var durationMsec = 100;
+    var perfStart;
+    var dateStart;
     return new Promise(function(resolve) {
+        perfStart = performance.now();
+        dateStart = Date.now();
         performance.mark('startMark');
         setTimeout(resolve, durationMsec);
       }).then(function() {
           performance.mark('endMark');
+          var perfEnd = performance.now();
+          var dateEnd = Date.now();
+          dump('### ### performance.now() ' + perfEnd + ' - ' + perfStart + ' = ' + (perfEnd - perfStart) + '\n');
+          dump('### ### Date.now() ' + dateEnd + ' - ' + dateStart + ' = ' + (dateEnd - dateStart) + '\n');
           performance.measure('measure', 'startMark', 'endMark');
           var startMark = performance.getEntriesByName('startMark')[0];
           var endMark = performance.getEntriesByName('endMark')[0];
           var measure = performance.getEntriesByType('measure')[0];
           assert_equals(measure.startTime, startMark.startTime);
           assert_approx_equals(endMark.startTime - startMark.startTime,
                                measure.duration, 0.001);
           //XXXnsm: Timers aren't always precise. on treeherder sometimes the
diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -435,16 +435,19 @@ TimerThread::Run()
   MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution - 1) == 0);
   MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution) == 1);
 
   // Half of the amount of microseconds needed to get positive PRIntervalTime.
   // We use this to decide how to round our wait times later
   int32_t halfMicrosecondsIntervalResolution = usIntervalResolution / 2;
   bool forceRunNextTimer = false;
 
+  printf_stderr("### ### halfMicrosecondsIntervalResolution %d\n",
+                halfMicrosecondsIntervalResolution);
+
   while (!mShutdown) {
     // Have to use PRIntervalTime here, since PR_WaitCondVar takes it
     PRIntervalTime waitFor;
     bool forceRunThisTimer = forceRunNextTimer;
     forceRunNextTimer = false;
 
     if (mSleeping
 #ifdef MOZ_NUWA_PROCESS
