# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7c8216f48c38a8498f251fe044509b930af44de6

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -12238,16 +12238,23 @@ nsGlobalWindow::SetTimeoutOrInterval(JSC
   aError = SetTimeoutOrInterval(handler, aTimeout, aIsInterval, &result);
   return result;
 }
 
 bool
 nsGlobalWindow::RunTimeoutHandler(nsTimeout* aTimeout,
                                   nsIScriptContext* aScx)
 {
+  nsAutoCString spec;
+  nsIURI* uri = GetDocumentURI();
+  if (uri) {
+    uri->GetSpec(spec);
+  }
+  printf_stderr("### ### [%p] RunTimeoutHandler() %s running %p\n", this, spec.get(), aTimeout);
+
   // Hold on to the timeout in case mExpr or mFunObj releases its
   // doc.
   RefPtr<nsTimeout> timeout = aTimeout;
   nsTimeout* last_running_timeout = mRunningTimeout;
   mRunningTimeout = timeout;
   timeout->mRunning = true;
 
   // Push this timeout's popup control state, which should only be
@@ -12596,16 +12603,22 @@ nsGlobalWindow::ClearTimeoutOrInterval(i
 {
   MOZ_RELEASE_ASSERT(IsInnerWindow());
 
   uint32_t public_id = (uint32_t)aTimerID;
   nsTimeout *timeout;
 
   for (timeout = mTimeouts.getFirst(); timeout; timeout = timeout->getNext()) {
     if (timeout->mPublicId == public_id) {
+      nsAutoCString spec;
+      nsIURI* uri = GetDocumentURI();
+      if (uri) {
+        uri->GetSpec(spec);
+      }
+      printf_stderr("### ### [%p] ClearTimeoutOrInterval() %s clearing %p\n", this, spec.get(), timeout);
       if (timeout->mRunning) {
         /* We're running from inside the timeout. Mark this
            timeout for deferred deletion by the code in
            RunTimeout() */
         timeout->mIsInterval = false;
       }
       else {
         /* Delete the timeout from the pending timeout list */
@@ -12716,27 +12729,36 @@ nsresult nsGlobalWindow::ResetTimersForN
   return NS_OK;
 }
 
 void
 nsGlobalWindow::ClearAllTimeouts()
 {
   nsTimeout *timeout, *nextTimeout;
 
+  nsAutoCString spec;
+  nsIURI* uri = GetDocumentURI();
+  if (uri) {
+    uri->GetSpec(spec);
+  }
+  printf_stderr("### ### [%p] ClearAllTimeouts() %s\n", this, spec.get());
+
   for (timeout = mTimeouts.getFirst(); timeout; timeout = nextTimeout) {
     /* If RunTimeout() is higher up on the stack for this
        window, e.g. as a result of document.write from a timeout,
        then we need to reset the list insertion point for
        newly-created timeouts in case the user adds a timeout,
        before we pop the stack back to RunTimeout. */
     if (mRunningTimeout == timeout)
       mTimeoutInsertionPoint = nullptr;
 
     nextTimeout = timeout->getNext();
 
+    printf_stderr("### ### [%p] ClearAllTimeouts() clearing %p\n", this, timeout);
+
     if (timeout->mTimer) {
       timeout->mTimer->Cancel();
       timeout->mTimer = nullptr;
 
       // Drop the count since the timer isn't going to hold on
       // anymore.
       timeout->Release();
     }
diff --git a/testing/specialpowers/content/specialpowersAPI.js b/testing/specialpowers/content/specialpowersAPI.js
--- a/testing/specialpowers/content/specialpowersAPI.js
+++ b/testing/specialpowers/content/specialpowersAPI.js
@@ -1103,36 +1103,48 @@ SpecialPowersAPI.prototype = {
         this._applyPrefs();
       } else {
         this._setTimeout(done);
       }
     });
   },
 
   popPrefEnv: function(callback = null) {
+    let now = Date.now();
+    dump(`### ### popPrefEnv() start ${now}\n`);
     return new Promise(resolve => {
-      let done = this._resolveAndCallOptionalCallback.bind(this, resolve, callback);
+      //let done = this._resolveAndCallOptionalCallback.bind(this, resolve, callback);
+      let done = _ => {
+        dump(`### ### popPrefEnv() done ${now}\n`);
+        this._resolveAndCallOptionalCallback(resolve, callback);
+      }
       if (this._prefEnvUndoStack.length > 0) {
         // See pushPrefEnv comment regarding delay.
         let cb = this._delayCallbackTwice(done);
         /* Each pop will have a valid block of preferences */
         this._pendingPrefs.push([this._prefEnvUndoStack.pop(), cb]);
         this._applyPrefs();
       } else {
         this._setTimeout(done);
       }
     });
   },
 
   flushPrefEnv: function(callback = null) {
+    let now = Date.now();
+    dump(`### ### flushPrefEnv() start ${now}\n`);
     while (this._prefEnvUndoStack.length > 1)
       this.popPrefEnv(null);
 
     return new Promise(resolve => {
-      let done = this._resolveAndCallOptionalCallback.bind(this, resolve, callback);
+      //let done = this._resolveAndCallOptionalCallback.bind(this, resolve, callback);
+      let done = _ => {
+        dump(`### ### flushPrefEnv() done ${now}\n`);
+        this._resolveAndCallOptionalCallback(resolve, callback);
+      }
       this.popPrefEnv(done);
     });
   },
 
   /*
     Iterate through one atomic set of pref actions and perform sets/clears as appropriate.
     All actions performed must modify the relevant pref.
   */
