# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  98776a7500ebd4ac78381bd92b4fa66bd194135e
Debug

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1315,17 +1315,20 @@ public:
   {
     AssertIsOnMainThread();
   }
 
   void
   Cancel() override
   {
     AssertIsOnMainThread();
+    printf_stderr("### ### [%p] RegisterJob::Cancel()\n", this);
     if (mCompareHandle) {
+      printf_stderr("### ### [%p] RegisterJob::Cancel() aborting compare handle %p\n", this,
+                    mCompareHandle.get());
       mCompareHandle->Abort();
       mCompareHandle = nullptr;
     }
     ServiceWorkerJobBase::Cancel();
   }
 
   void
   Start() override
@@ -4789,20 +4792,25 @@ ServiceWorkerManager::Observe(nsISupport
     }
 
     nsCOMPtr<nsIThread> currentThread = NS_GetCurrentThread();
     MOZ_ASSERT(currentThread);
 
     // Block shutdown until all of our cancelled, but still running jobs actually
     // complete.  Without this we can leak the entire network stack on shutdown.
     while (!runningJobs.IsEmpty()) {
+      printf_stderr("### ### Spinning event loop for %lu jobs\n", runningJobs.Length());
       for (int32_t i = runningJobs.Length() - 1; i >= 0; --i) {
+        printf_stderr("### ### Checking job - register or install: %s\n",
+                      (runningJobs[i]->IsRegisterOrInstallJob() ? "true" : "false"));
         if (!runningJobs[i]->IsDone()) {
+          printf_stderr("### ### Job not complete\n");
           break;
         }
+        printf_stderr("### ### Job complete, removing\n");
         runningJobs.RemoveElementAt(i);
       }
 
       MOZ_ALWAYS_TRUE(NS_ProcessNextEvent(currentThread));
     }
 
     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
     if (obs) {
diff --git a/dom/workers/ServiceWorkerScriptCache.cpp b/dom/workers/ServiceWorkerScriptCache.cpp
--- a/dom/workers/ServiceWorkerScriptCache.cpp
+++ b/dom/workers/ServiceWorkerScriptCache.cpp
@@ -95,16 +95,17 @@ public:
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL, nsILoadGroup* aLoadGroup);
 
   void
   Abort()
   {
     AssertIsOnMainThread();
+    printf_stderr("### ### [%p] CompareNetwork::Abort()\n", this);
 
     MOZ_ASSERT(mChannel);
     mChannel->Cancel(NS_BINDING_ABORTED);
     mChannel = nullptr;
   }
 
   const nsString& Buffer() const
   {
@@ -248,16 +249,18 @@ public:
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL,
              const nsAString& aCacheName, nsILoadGroup* aLoadGroup)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aPrincipal);
 
+    printf_stderr("### ### [%p] CompareManager::Initialize()\n", this);
+
     mURL = aURL;
 
     // Always create a CacheStorage since we want to write the network entry to
     // the cache even if there isn't an existing one.
     AutoJSAPI jsapi;
     jsapi.Init();
     ErrorResult result;
     mSandbox.init(jsapi.cx());
@@ -280,16 +283,18 @@ public:
       rv = mCC->Initialize(aPrincipal, aURL, aCacheName);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         mCN->Abort();
         Cleanup();
         return rv;
       }
     }
 
+    printf_stderr("### ### [%p] CompareManager::Initialize() succeeded\n", this);
+
     return NS_OK;
   }
 
   const nsAString&
   URL() const
   {
     AssertIsOnMainThread();
     return mURL;
@@ -309,16 +314,18 @@ public:
     return copy.forget();
   }
 
   void
   NetworkFinished(nsresult aStatus)
   {
     AssertIsOnMainThread();
 
+    printf_stderr("### ### [%p] CompareManager::NetworkFinished() %u CompareNetwork:%p\n",
+                  this, aStatus, mCN.get());
     mNetworkFinished = true;
 
     if (NS_WARN_IF(NS_FAILED(aStatus))) {
       if (mCC) {
         mCC->Abort();
       }
 
       ComparisonFinished(aStatus, false);
@@ -328,16 +335,18 @@ public:
     MaybeCompare();
   }
 
   void
   CacheFinished(nsresult aStatus, bool aInCache)
   {
     AssertIsOnMainThread();
 
+    printf_stderr("### ### [%p] CompareManager::CacheFinished() %u CompareCache:%p\n",
+                  this, aStatus, mCC.get());
     mCacheFinished = true;
     mInCache = aInCache;
 
     if (NS_WARN_IF(NS_FAILED(aStatus))) {
       if (mCN) {
         mCN->Abort();
       }
 
@@ -453,16 +462,18 @@ public:
     return NS_OK;
   }
 
   void
   Abort()
   {
     AssertIsOnMainThread();
 
+    printf_stderr("### ### [%p] CompareManager::Abort()\n", this);
+
     // Do nothing if the manager has already been cleaned up.
     if (!mCallback) {
       return;
     }
 
     // otherwise abort all current operations
     if (mCN) {
       mCN->Abort();
@@ -483,16 +494,25 @@ private:
     MOZ_ASSERT(!mCC);
     MOZ_ASSERT(!mCN);
   }
 
   void
   Fail(nsresult aStatus)
   {
     AssertIsOnMainThread();
+
+    printf_stderr("### ### [%p] CompareManager::Fail() %u\n",
+                  this, aStatus);
+
+    // In some failure paths we can get called multiple times.
+    if (!mCallback) {
+      return;
+    }
+
     mCallback->ComparisonResult(aStatus, false /* aIsEqual */,
                                 EmptyString(), EmptyCString());
     Cleanup();
   }
 
   void
   Cleanup()
   {
@@ -502,23 +522,27 @@ private:
     mCN = nullptr;
     mCC = nullptr;
   }
 
   void
   ComparisonFinished(nsresult aStatus, bool aIsEqual)
   {
     AssertIsOnMainThread();
-    MOZ_ASSERT(mCallback);
+
+    printf_stderr("### ### [%p] CompareManager::ComparisonFinished() %u\n",
+                  this, aStatus);
 
     if (NS_WARN_IF(NS_FAILED(aStatus))) {
       Fail(aStatus);
       return;
     }
 
+    MOZ_ASSERT(mCallback);
+
     if (aIsEqual) {
       mCallback->ComparisonResult(aStatus, aIsEqual, EmptyString(), mMaxScope);
       Cleanup();
       return;
     }
 
     // Write to Cache so ScriptLoader reads succeed.
     WriteNetworkBufferToNewCache();
@@ -625,16 +649,18 @@ private:
 NS_IMPL_ISUPPORTS0(CompareManager)
 
 nsresult
 CompareNetwork::Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL, nsILoadGroup* aLoadGroup)
 {
   MOZ_ASSERT(aPrincipal);
   AssertIsOnMainThread();
 
+  printf_stderr("### ### [%p] CompareNetwork::Initialize()\n", this);
+
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   nsCOMPtr<nsILoadGroup> loadGroup;
   rv = NS_NewLoadGroup(getter_AddRefs(loadGroup), aPrincipal);
@@ -687,18 +713,21 @@ CompareNetwork::Initialize(nsIPrincipal*
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CompareNetwork::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
   AssertIsOnMainThread();
 
+  printf_stderr("### ### [%p] CompareNetwork::OnStartRequest()\n", this);
+
   // If no channel, Abort() has been called.
   if (!mChannel) {
+    printf_stderr("### ### [%p] CompareNetwork::OnStartRequest(), but null channel\n", this);
     return NS_OK;
   }
 
 #ifdef DEBUG
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
   MOZ_ASSERT(channel == mChannel);
 #endif
 
@@ -710,29 +739,39 @@ CompareNetwork::OnStartRequest(nsIReques
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CompareNetwork::OnStopRequest(nsIRequest* aRequest, nsISupports* aContext,
                               nsresult aStatusCode)
 {
-  // Nothing to do here!
+  printf_stderr("### ### [%p] CompareNetwork::OnStopRequest() %u\n", this, aStatusCode);
+
+  if (NS_WARN_IF(NS_FAILED(aStatusCode))) {
+    printf_stderr("### ### [%p] CompareNetwork::OnStopRequest() %u\n", this, aStatusCode);
+    mManager->NetworkFinished(aStatusCode);
+    return aStatusCode;
+  }
+  // Nothing to do here on success.
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CompareNetwork::OnStreamComplete(nsIStreamLoader* aLoader, nsISupports* aContext,
                                  nsresult aStatus, uint32_t aLen,
                                  const uint8_t* aString)
 {
   AssertIsOnMainThread();
 
+  printf_stderr("### ### [%p] CompareNetwork::OnStreamComplete() %u\n", this, aStatus);
+
   // If no channel, Abort() has been called.
   if (!mChannel) {
+    printf_stderr("### ### [%p] CompareNetwork::OnStreamComplete(), but null channel\n", this);
     return NS_OK;
   }
 
   if (NS_WARN_IF(NS_FAILED(aStatus))) {
     if (aStatus == NS_ERROR_REDIRECT_LOOP) {
       mManager->NetworkFinished(NS_ERROR_DOM_SECURITY_ERR);
     } else {
       mManager->NetworkFinished(aStatus);
