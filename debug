# HG changeset patch
# Parent c3031ab691c710e1fe0a3c972327e5bf9b5dee9e
# User Ben Kelly <ben@wanderview.com>

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -1973,16 +1973,18 @@ IncrementalVacuum(mozIStorageConnection*
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t freePages = 0;
   rv = state->GetInt32(0, &freePages);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  printf_stderr("### ### free pages %d\n", freePages);
+
   // We have a relatively small page size, so we want to be careful to avoid
   // fragmentation.  We already use a growth incremental which will cause
   // sqlite to allocate and release multiple pages at the same time.  We can
   // further reduce fragmentation by making our allocated chunks a bit
   // "sticky".  This is done by creating some hysteresis where we allocate
   // pages/chunks as soon as we need them, but we only release pages/chunks
   // when we have a large amount of free space.  This helps with the case
   // where a page is adding and remove resources causing it to dip back and
@@ -1993,16 +1995,18 @@ IncrementalVacuum(mozIStorageConnection*
   if (freePages <= kMaxFreePages) {
     return NS_OK;
   }
 
   // Release the excess pages back to the sqlite VFS.  This may also release
   // chunks of multiple pages back to the OS.
   int32_t pagesToRelease = freePages - kMaxFreePages;
 
+  printf_stderr("### ### releasing %d pages\n", pagesToRelease);
+
   rv = aConn->ExecuteSimpleSQL(nsPrintfCString(
     "PRAGMA incremental_vacuum(%d);", pagesToRelease
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Verify that our incremental vacuum actually did something
 #ifdef DEBUG
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -51,16 +51,23 @@ GetBodyUsage(nsIFile* aDir, UsageInfo* a
       continue;
     }
 
     int64_t fileSize;
     rv = file->GetFileSize(&fileSize);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     MOZ_ASSERT(fileSize >= 0);
 
+    nsAutoString leafName;
+    rv = file->GetLeafName(leafName);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    printf_stderr("### ### QuotaClient::GetBodyUsage() file:%s size:%d\n",
+                  NS_ConvertUTF16toUTF8(leafName).get(), (int32_t)fileSize);
+
     aUsageInfo->AppendToFileUsage(fileSize);
   }
 
   return NS_OK;
 }
 
 class StoragesDestroyedRunnable final : public nsRunnable
 {
@@ -178,16 +185,19 @@ public:
 
       if (leafName.EqualsLiteral("caches.sqlite") ||
           leafName.EqualsLiteral("caches.sqlite-wal")) {
         int64_t fileSize;
         rv = file->GetFileSize(&fileSize);
         if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
         MOZ_ASSERT(fileSize >= 0);
 
+        printf_stderr("### ### QuotaClient::GetUsageForOrigin() file:%s size:%d\n",
+                      NS_ConvertUTF16toUTF8(leafName).get(), (int32_t)fileSize);
+
         aUsageInfo->AppendToDatabaseUsage(fileSize);
         continue;
       }
 
       NS_WARNING("Unknown Cache file found!");
     }
 
     return NS_OK;
