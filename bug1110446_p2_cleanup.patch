# HG changeset patch
# Parent 0b146f95dfad80a8bc446676a9efaf25181ea6bf
# User Ben Kelly <ben@wanderview.com>
Bug 1110446 P2 Cleanup stale caches/bodies if last session didn't shutdown cleanly. r=ehsan

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -181,22 +181,24 @@ static nsresult InsertEntry(mozIStorageC
                             const nsID* aRequestBodyId,
                             const CacheResponse& aResponse,
                             const nsID* aResponseBodyId);
 static nsresult ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
                              SavedResponse* aSavedResponseOut);
 static nsresult ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
                             SavedRequest* aSavedRequestOut);
 
-static void AppendListParamsToQuery(nsACString& aQuery,
-                                    const nsTArray<EntryId>& aEntryIdList,
-                                    uint32_t aPos, int32_t aLen);
+static void AppendListParamsToQuery(nsACString& aQuery, uint32_t aPos,
+                                    int32_t aLen);
 static nsresult BindListParamsToQuery(mozIStorageStatement* aState,
                                       const nsTArray<EntryId>& aEntryIdList,
                                       uint32_t aPos, int32_t aLen);
+static nsresult BindListParamsToQuery(mozIStorageStatement* aState,
+                                      const nsTArray<nsID>& aBodyIdList,
+                                      uint32_t aPos, int32_t aLen);
 static nsresult BindId(mozIStorageStatement* aState, const nsACString& aName,
                        const nsID* aId);
 static nsresult ExtractId(mozIStorageStatement* aState, uint32_t aPos,
                           nsID* aIdOut);
 static nsresult CreateAndBindKeyStatement(mozIStorageConnection* aConn,
                                           const char* aQueryFormat,
                                           const nsAString& aKey,
                                           mozIStorageStatement** aStateOut);
@@ -531,16 +533,116 @@ IsCacheOrphaned(mozIStorageConnection* a
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   *aOrphanedOut = refCount == 0;
 
   return rv;
 }
 
 nsresult
+FindOrphanedCacheIds(mozIStorageConnection* aConn,
+                     nsTArray<CacheId>& aOrphanedListOut)
+{
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id FROM caches "
+    "WHERE id NOT IN (SELECT cache_id from storage);"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    CacheId cacheId = INVALID_CACHE_ID;
+    rv = state->GetInt64(0, &cacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    aOrphanedListOut.AppendElement(cacheId);
+  }
+
+  return rv;
+}
+
+namespace {
+
+nsresult
+FindOrphanedBodyIdsByColumnName(mozIStorageConnection* aConn,
+                                const nsTArray<nsID>& aBodyFileIdList,
+                                const nsACString& aColumnName,
+                                nsTArray<nsID>& aOrphanedListOut)
+{
+  nsAutoCString query("SELECT ");
+  query.Append(aColumnName);
+  query.AppendLiteral(" FROM entries WHERE ");
+  query.Append(aColumnName);
+  query.AppendLiteral(" NOT IN (");
+
+  // Sqlite limits how many parameters may be bound in a statement.  This
+  // means we can only filter out the first kMaxEntriesPerStatement bodies
+  // using the sql query.
+  int32_t numToBind = std::min(static_cast<int32_t>(aBodyFileIdList.Length()),
+                               kMaxEntriesPerStatement);
+
+  AppendListParamsToQuery(query, 0, numToBind);
+
+  query.AppendLiteral(");");
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindListParamsToQuery(state, aBodyFileIdList, 0, numToBind);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsID id;
+    rv = ExtractId(state, 0, &id);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool orphaned = true;
+
+    // If there are more than kMaxEntriesPerStatement, then our SQL query
+    // may return body IDs that are not orphaned.  We must iterate over
+    // the remaining body IDs in memory to find a match.
+    for (uint32_t i = numToBind; i < aBodyFileIdList.Length(); ++i) {
+      if (id.Equals(aBodyFileIdList[i])) {
+        orphaned = false;
+        break;
+      }
+    }
+
+    if (orphaned) {
+      aOrphanedListOut.AppendElement(id);
+    }
+  }
+
+  return rv;
+}
+
+} // anonymous namespace
+
+nsresult
+FindOrphanedBodyIds(mozIStorageConnection* aConn,
+                    const nsTArray<nsID>& aBodyFileIdList,
+                    nsTArray<nsID>& aOrphanedListOut)
+{
+  nsresult rv =
+    FindOrphanedBodyIdsByColumnName(aConn, aBodyFileIdList,
+                                    NS_LITERAL_CSTRING("request_body_id"),
+                                    aOrphanedListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = FindOrphanedBodyIdsByColumnName(aConn, aBodyFileIdList,
+                                       NS_LITERAL_CSTRING("response_body_id"),
+                                       aOrphanedListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
 CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
            const CacheRequest& aRequest,
            const CacheQueryParams& aParams,
            bool* aFoundResponseOut,
            SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
@@ -1177,17 +1279,17 @@ DeleteEntries(mozIStorageConnection* aCo
     return NS_OK;
   }
 
   nsCOMPtr<mozIStorageStatement> state;
   nsAutoCString query(
     "SELECT request_body_id, response_body_id, response_security_info_id "
     "FROM entries WHERE id IN ("
   );
-  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  AppendListParamsToQuery(query, aPos, aLen);
   query.AppendLiteral(")");
 
   nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1236,17 +1338,17 @@ DeleteEntries(mozIStorageConnection* aCo
     }
   }
 
   // Dependent records removed via ON DELETE CASCADE
 
   query = NS_LITERAL_CSTRING(
     "DELETE FROM entries WHERE id IN ("
   );
-  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  AppendListParamsToQuery(query, aPos, aLen);
   query.AppendLiteral(")");
 
   rv = aConn->CreateStatement(query, getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1886,22 +1988,19 @@ ReadRequest(mozIStorageConnection* aConn
 
     aSavedRequestOut->mValue.headers().AppendElement(header);
   }
 
   return rv;
 }
 
 void
-AppendListParamsToQuery(nsACString& aQuery,
-                        const nsTArray<EntryId>& aEntryIdList,
-                        uint32_t aPos, int32_t aLen)
+AppendListParamsToQuery(nsACString& aQuery, uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
   for (int32_t i = aPos; i < aLen; ++i) {
     if (i == 0) {
       aQuery.AppendLiteral("?");
     } else {
       aQuery.AppendLiteral(",?");
     }
   }
 }
@@ -1916,16 +2015,32 @@ BindListParamsToQuery(mozIStorageStateme
   for (int32_t i = aPos; i < aLen; ++i) {
     nsresult rv = aState->BindInt32ByIndex(i, aEntryIdList[i]);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
 }
 
 nsresult
+BindListParamsToQuery(mozIStorageStatement* aState,
+                      const nsTArray<nsID>& aBodyIdList,
+                      uint32_t aPos, int32_t aLen)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT((aPos + aLen) <= aBodyIdList.Length());
+  for (int32_t i = aPos; i < aLen; ++i) {
+    char idBuf[NSID_LENGTH];
+    aBodyIdList[i].ToProvidedString(idBuf);
+    nsresult rv = aState->BindUTF8StringByIndex(i, nsAutoCString(idBuf));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+  return NS_OK;
+}
+
+nsresult
 BindId(mozIStorageStatement* aState, const nsACString& aName, const nsID* aId)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aState);
   nsresult rv;
 
   if (!aId) {
     rv = aState->BindNullByName(aName);
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -44,16 +44,25 @@ DeleteCacheId(mozIStorageConnection* aCo
               nsTArray<nsID>& aDeletedBodyIdListOut);
 
 // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code. (bug 1110446)
 nsresult
 IsCacheOrphaned(mozIStorageConnection* aConn, CacheId aCacheId,
                 bool* aOrphanedOut);
 
 nsresult
+FindOrphanedCacheIds(mozIStorageConnection* aConn,
+                     nsTArray<CacheId>& aOrphanedListOut);
+
+nsresult
+FindOrphanedBodyIds(mozIStorageConnection* aConn,
+                    const nsTArray<nsID>& aBodyFileIdList,
+                    nsTArray<nsID>& aOrphanedListOut);
+
+nsresult
 CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
            const CacheRequest& aRequest, const CacheQueryParams& aParams,
            bool* aFoundResponseOut, SavedResponse* aSavedResponseOut);
 
 nsresult
 CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
               const CacheRequestOrVoid& aRequestOrVoid,
               const CacheQueryParams& aParams,
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -315,16 +315,103 @@ BodyIdToFile(nsIFile* aBaseDir, const ns
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 } // anonymous namespace
 
 nsresult
+BodyGetFileIdList(nsIFile* aBaseDir, nsTArray<nsID>& aIdListOut)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  // body files are stored in a directory structure like:
+  //
+  //  /morgue/01/{01fdddb2-884d-4c3d-95ba-0c8062f6c325}.final
+  //  /morgue/02/{02fdddb2-884d-4c3d-95ba-0c8062f6c325}.tmp
+
+  nsCOMPtr<nsIFile> dir;
+  nsresult rv = aBaseDir->Clone(getter_AddRefs(dir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Add the root morgue directory
+  rv = dir->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsISimpleEnumerator> entries;
+  rv = dir->GetDirectoryEntries(getter_AddRefs(entries));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Iterate over all the intermediate morgue subdirs
+  bool hasMore;
+  while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore) {
+    nsCOMPtr<nsISupports> entry;
+    rv = entries->GetNext(getter_AddRefs(entry));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsIFile> subdir = do_QueryInterface(entry);
+
+    bool isDir;
+    rv = subdir->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // If a file got in here somehow, just ignore it
+    if (!isDir) {
+      continue;
+    }
+
+    nsCOMPtr<nsISimpleEnumerator> subEntries;
+    rv = subdir->GetDirectoryEntries(getter_AddRefs(subEntries));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // Now iterate over all the files in the subdir
+    bool subHasMore;
+    while(NS_SUCCEEDED(rv = subEntries->HasMoreElements(&subHasMore)) &&
+          subHasMore) {
+      nsCOMPtr<nsISupports> subEntry;
+      rv = subEntries->GetNext(getter_AddRefs(subEntry));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+
+      nsAutoCString leafName;
+      rv = file->GetNativeLeafName(leafName);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      // Body files end in either .tmp or .final.
+      nsCString suffix;
+      if (StringEndsWith(leafName, NS_LITERAL_CSTRING(".final"))) {
+        suffix = NS_LITERAL_CSTRING(".final");
+      } else if (StringEndsWith(leafName, NS_LITERAL_CSTRING(".tmp"))) {
+        suffix = NS_LITERAL_CSTRING(".tmp");
+      }
+
+      // If the file doesn't have the right suffix or if the length of
+      // file name does not match a uuid, then ignore it.
+      if (suffix.IsEmpty() ||
+          leafName.Length() != NSID_LENGTH + suffix.Length()) {
+        continue;
+      }
+
+      // Finally, parse the uuid out of the name.  If its fails to parse,
+      // the ignore the file.
+      nsID id;
+      if (!id.Parse(leafName.BeginReading())) {
+        continue;
+      }
+
+      aIdListOut.AppendElement(id);
+    }
+  }
+
+  return NS_OK;
+}
+
+nsresult
 CreateMarkerFile(const QuotaInfo& aQuotaInfo)
 {
   nsCOMPtr<nsIFile> marker;
   nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(marker));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = marker->Append(NS_LITERAL_STRING("cache"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -368,11 +455,31 @@ DeleteMarkerFile(const QuotaInfo& aQuota
   // Again, no fsync is necessary.  If the OS crashes before the file
   // removal is flushed, then the Cache will search for stale data on
   // startup.  This will cause the next Cache access to be a bit slow, but
   // it seems appropriate after an OS crash.
 
   return NS_OK;
 }
 
+bool
+MarkerFileExists(const QuotaInfo& aQuotaInfo)
+{
+  nsCOMPtr<nsIFile> marker;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(marker));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  rv = marker->Append(NS_LITERAL_STRING("cache"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  rv = marker->Append(NS_LITERAL_STRING("context_open.marker"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  bool exists = false;
+  rv = marker->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  return exists;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -46,18 +46,24 @@ BodyFinalizeWrite(nsIFile* aBaseDir, con
 nsresult
 BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
          nsIInputStream** aStreamOut);
 
 nsresult
 BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
 
 nsresult
+BodyGetFileIdList(nsIFile* aBaseDir, nsTArray<nsID>& aIdListOut);
+
+nsresult
 CreateMarkerFile(const QuotaInfo& aQuotaInfo);
 
 nsresult
 DeleteMarkerFile(const QuotaInfo& aQuotaInfo);
 
+bool
+MarkerFileExists(const QuotaInfo& aQuotaInfo);
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_FileUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -25,57 +25,92 @@
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
 #include "nsTObserverArray.h"
 
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
 namespace {
 
-using mozilla::unused;
-using mozilla::dom::cache::Action;
-using mozilla::dom::cache::BodyCreateDir;
-using mozilla::dom::cache::BodyDeleteFiles;
-using mozilla::dom::cache::QuotaInfo;
-using mozilla::dom::cache::SyncDBAction;
-using mozilla::dom::cache::db::CreateSchema;
-
 // An Action that is executed when a Context is first created.  It ensures that
 // the directory and database are setup properly.  This lets other actions
 // not worry about these details.
 class SetupAction final : public SyncDBAction
 {
 public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) override
   {
-    // TODO: init maintainance marker (bug 1110446)
-    // TODO: perform maintainance if necessary (bug 1110446)
-    // TODO: find orphaned caches in database (bug 1110446)
-    // TODO: have Context create/delete marker files in constructor/destructor
-    //       and only do expensive maintenance if that marker is present (bug 1110446)
-
     nsresult rv = BodyCreateDir(aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    mozStorageTransaction trans(aConn, false,
-                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+    {
+      mozStorageTransaction trans(aConn, false,
+                                  mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    rv = CreateSchema(aConn);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      rv = db::CreateSchema(aConn);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = trans.Commit();
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      rv = trans.Commit();
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    }
+
+    // If the Context marker file exists, then the last session was
+    // not cleanly shutdown.  In these cases sqlite will ensure that
+    // the database is valid, but we might still orphan data.  Both
+    // Cache objects and body files can be referenced by DOM objects
+    // after they are "removed" from their parent.  So we need to
+    // look and see if any of these late access objects have been
+    // orphaned.
+    //
+    // Note, this must be done after any schema version updates to
+    // ensure our DBSchema methods work correctly.
+    if (MarkerFileExists(aQuotaInfo)) {
+      NS_WARNING("Cache not shutdown cleanly! Cleaning up stale data...");
+      mozStorageTransaction trans(aConn, false,
+                                  mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+      // Clean up orphaned Cache objects
+      nsAutoTArray<CacheId, 8> orphanedCacheIdList;
+      nsresult rv = db::FindOrphanedCacheIds(aConn, orphanedCacheIdList);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      for (uint32_t i = 0; i < orphanedCacheIdList.Length(); ++i) {
+        nsAutoTArray<nsID, 16> deletedBodyIdList;
+        rv = db::DeleteCacheId(aConn, orphanedCacheIdList[i], deletedBodyIdList);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+        rv = BodyDeleteFiles(aDBDir, deletedBodyIdList);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      }
+
+      // Clean up orphaned body objects
+      nsAutoTArray<nsID, 64> bodyFileIdList;
+      rv = BodyGetFileIdList(aDBDir, bodyFileIdList);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      nsAutoTArray<nsID, 64> orphanedBodyIdList;
+      rv = db::FindOrphanedBodyIds(aConn, bodyFileIdList, orphanedBodyIdList);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      rv = BodyDeleteFiles(aDBDir, orphanedBodyIdList);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    }
 
     return rv;
   }
 };
 
 // ----------------------------------------------------------------------------
 
 // Action that is executed when we determine that content has stopped using
@@ -119,24 +154,16 @@ public:
 
     aResolver->Resolve(rv);
   }
 
 private:
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
-} // anonymous namespace
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-namespace {
-
 bool IsHeadRequest(CacheRequest aRequest, CacheQueryParams aParams)
 {
   return !aParams.ignoreMethod() && aRequest.method().LowerCaseEqualsLiteral("head");
 }
 
 bool IsHeadRequest(CacheRequestOrVoid aRequest, CacheQueryParams aParams)
 {
   if (aRequest.type() == CacheRequestOrVoid::TCacheRequest) {
