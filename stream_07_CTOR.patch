# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  536b25ca491615aed02360cf557e253cb005e0b9
Bug 1128959 - Implement the WHATWG Streams spec - part 7 - Response.body, r=bkelly

diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -740,17 +740,18 @@ DOMInterfaces = {
         'headers': 'headers_',
         'referrerPolicy': 'referrerPolicy_'
     },
     'implicitJSContext': [ 'arrayBuffer', 'blob', 'formData', 'json', 'text' ],
 },
 
 'Response': {
     'binaryNames': { 'headers': 'headers_' },
-    'implicitJSContext': [ 'arrayBuffer', 'blob', 'formData', 'json', 'text' ],
+    'implicitJSContext': [ 'arrayBuffer', 'blob', 'formData', 'json', 'text',
+                           'clone', 'cloneUnfiltered' ],
 },
 
 'RGBColor': {
     'nativeType': 'nsDOMCSSRGBColor',
 },
 
 'Screen': {
     'nativeType': 'nsScreen',
diff --git a/dom/fetch/BodyExtractor.cpp b/dom/fetch/BodyExtractor.cpp
--- a/dom/fetch/BodyExtractor.cpp
+++ b/dom/fetch/BodyExtractor.cpp
@@ -8,16 +8,17 @@
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/FormData.h"
 #include "mozilla/dom/TypedArray.h"
 #include "mozilla/dom/URLSearchParams.h"
 #include "mozilla/dom/XMLHttpRequest.h"
 #include "nsContentUtils.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMSerializer.h"
+#include "nsIGlobalObject.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsIStorageStream.h"
 #include "nsStringStream.h"
 
 namespace mozilla {
 namespace dom {
 
diff --git a/dom/fetch/BodyExtractor.h b/dom/fetch/BodyExtractor.h
--- a/dom/fetch/BodyExtractor.h
+++ b/dom/fetch/BodyExtractor.h
@@ -2,35 +2,37 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BodyExtractor_h
 #define mozilla_dom_BodyExtractor_h
 
+#include "jsapi.h"
 #include "nsString.h"
 
 class nsIInputStream;
+class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
 class BodyExtractorBase
 {
 public:
   virtual nsresult GetAsStream(nsIInputStream** aResult,
                                uint64_t* aContentLength,
                                nsACString& aContentTypeWithCharset,
                                nsACString& aCharset) const = 0;
 };
 
 // The implementation versions of this template are:
 // ArrayBuffer, ArrayBufferView, nsIXHRSendable (Blob, FormData,
-// URLSearchParams), nsAString, nsIDocument, nsIInputStream
+// URLSearchParams), nsAString, nsIDocument, nsIInputStream.
 template<typename Type>
 class BodyExtractor final : public BodyExtractorBase
 {
   Type* mBody;
 public:
   explicit BodyExtractor(Type* aBody) : mBody(aBody)
   {}
 
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -834,16 +834,72 @@ ExtractByteStreamFromBody(const fetch::B
     return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
                             charset);
   }
 
   NS_NOTREACHED("Should never reach here");
   return NS_ERROR_FAILURE;
 }
 
+nsresult
+ExtractByteStreamFromBody(const fetch::ResponseBodyInit& aBodyInit,
+                          nsIInputStream** aStream,
+                          nsCString& aContentTypeWithCharset,
+                          uint64_t& aContentLength)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(!*aStream);
+
+  // ReadableStreams should be handled by
+  // BodyExtractorReadableStream::GetAsStream.
+  MOZ_ASSERT(!aBodyInit.IsReadableStream());
+
+  nsAutoCString charset;
+  aContentTypeWithCharset.SetIsVoid(true);
+
+  if (aBodyInit.IsArrayBuffer()) {
+    BodyExtractor<const ArrayBuffer> body(&aBodyInit.GetAsArrayBuffer());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  if (aBodyInit.IsArrayBufferView()) {
+    BodyExtractor<const ArrayBufferView> body(&aBodyInit.GetAsArrayBufferView());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  if (aBodyInit.IsBlob()) {
+    BodyExtractor<nsIXHRSendable> body(&aBodyInit.GetAsBlob());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  if (aBodyInit.IsFormData()) {
+    BodyExtractor<nsIXHRSendable> body(&aBodyInit.GetAsFormData());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  if (aBodyInit.IsUSVString()) {
+    BodyExtractor<const nsAString> body(&aBodyInit.GetAsUSVString());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  if (aBodyInit.IsURLSearchParams()) {
+    BodyExtractor<nsIXHRSendable> body(&aBodyInit.GetAsURLSearchParams());
+    return body.GetAsStream(aStream, &aContentLength, aContentTypeWithCharset,
+                            charset);
+  }
+
+  NS_NOTREACHED("Should never reach here");
+  return NS_ERROR_FAILURE;
+}
+
 template <class Derived>
 FetchBody<Derived>::FetchBody(nsIGlobalObject* aOwner)
   : mOwner(aOwner)
   , mWorkerPrivate(nullptr)
   , mReadableStreamBody(nullptr)
   , mBodyUsed(false)
 {
   MOZ_ASSERT(aOwner);
@@ -884,17 +940,18 @@ FetchBody<Derived>::BodyUsed() const
     if (!jsapi.Init(mOwner)) {
       return true;
     }
 
     JSContext* cx = jsapi.cx();
 
     JS::Rooted<JSObject*> body(cx, mReadableStreamBody);
     if (JS::ReadableStreamIsDisturbed(body) ||
-        JS::ReadableStreamIsLocked(body)) {
+        JS::ReadableStreamIsLocked(body) ||
+        !JS::ReadableStreamIsReadable(body)) {
       return true;
     }
   }
 
   return false;
 }
 
 template
@@ -912,24 +969,28 @@ FetchBody<Derived>::ConsumeBody(JSContex
 {
   if (BodyUsed()) {
     aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
     return nullptr;
   }
 
   SetBodyUsed();
 
-  nsCOMPtr<nsIGlobalObject> global = DerivedClass()->GetParentObject();
-
-  // If we already created a ReadableStreamBody we have to close it now.
+  // If we already created a ReadableStreamBody we have to lock it now because
+  // it can have been shared with other objects.
   if (mReadableStreamBody) {
     JS::Rooted<JSObject*> body(aCx, mReadableStreamBody);
-    JS::ReadableStreamClose(aCx, body);
+    LockStream(aCx, body, aRv);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
   }
 
+  nsCOMPtr<nsIGlobalObject> global = DerivedClass()->GetParentObject();
+
   RefPtr<Promise> promise =
     FetchBodyConsumer<Derived>::Create(global, mMainThreadEventTarget, this,
                                        aType, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return promise.forget();
@@ -970,44 +1031,64 @@ void
 FetchBody<Request>::SetMimeType();
 
 template
 void
 FetchBody<Response>::SetMimeType();
 
 template <class Derived>
 void
+FetchBody<Derived>::SetReadableStreamBody(JSObject* aBody)
+{
+  MOZ_ASSERT(!mReadableStreamBody);
+  MOZ_ASSERT(aBody);
+  mReadableStreamBody = aBody;
+}
+
+template
+void
+FetchBody<Request>::SetReadableStreamBody(JSObject* aBody);
+
+template
+void
+FetchBody<Response>::SetReadableStreamBody(JSObject* aBody);
+
+template <class Derived>
+void
 FetchBody<Derived>::GetBody(JSContext* aCx,
                             JS::MutableHandle<JSObject*> aBodyOut,
                             ErrorResult& aRv)
 {
   nsCOMPtr<nsIInputStream> inputStream;
   DerivedClass()->GetBody(getter_AddRefs(inputStream));
 
   if (!inputStream) {
     aBodyOut.set(nullptr);
     return;
   }
 
   if (!mReadableStreamBody) {
     JS::Rooted<JSObject*> body(aCx,
                                FetchStream::Create(aCx,
+                                                   this,
                                                    DerivedClass()->GetParentObject(),
                                                    inputStream,
                                                    aRv));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
 
     MOZ_ASSERT(body);
 
     // If the body has been already consumed, we close the stream.
-    if (BodyUsed() && !JS::ReadableStreamClose(aCx, body)) {
-      aRv.StealExceptionFromJSContext(aCx);
-      return;
+    if (BodyUsed()) {
+      LockStream(aCx, body, aRv);
+      if (NS_WARN_IF(aRv.Failed())) {
+        return;
+      }
     }
 
     mReadableStreamBody = body;
   }
 
   aBodyOut.set(mReadableStreamBody);
 }
 
@@ -1018,11 +1099,77 @@ FetchBody<Request>::GetBody(JSContext* a
                             ErrorResult& aRv);
 
 template
 void
 FetchBody<Response>::GetBody(JSContext* aCx,
                              JS::MutableHandle<JSObject*> aMessage,
                              ErrorResult& aRv);
 
+template <class Derived>
+void
+FetchBody<Derived>::LockStream(JSContext* aCx,
+                               JS::HandleObject aStream,
+                               ErrorResult& aRv)
+{
+  // TODO: next patch.
+}
+
+template
+void
+FetchBody<Request>::LockStream(JSContext* aCx,
+                               JS::HandleObject aStream,
+                               ErrorResult& aRv);
+
+template
+void
+FetchBody<Response>::LockStream(JSContext* aCx,
+                                JS::HandleObject aStream,
+                                ErrorResult& aRv);
+
+template <class Derived>
+void
+FetchBody<Derived>::MaybeTeeReadableStreamBody(JSContext* aCx,
+                                               JS::MutableHandle<JSObject*> aBodyOut,
+                                               ErrorResult& aRv)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!BodyUsed());
+
+  if (!mReadableStreamBody) {
+    return;
+  }
+
+  JS::Rooted<JSObject*> stream(aCx, mReadableStreamBody);
+
+  // If this is a ReadableStream with an external source, this has been
+  // generated by a Fetch. In this case, Fetch will be able to recreate it
+  // again when GetBody() is called.
+  if (JS::ReadableStreamGetMode(stream) == JS::ReadableStreamMode::ExternalSource) {
+    aBodyOut.set(nullptr);
+    return;
+  }
+
+  JS::Rooted<JSObject*> branch1(aCx);
+  JS::Rooted<JSObject*> branch2(aCx);
+
+  if (!JS::ReadableStreamTee(aCx, stream, &branch1, &branch2)) {
+    aRv.StealExceptionFromJSContext(aCx);
+    return;
+  }
+
+  mReadableStreamBody = branch1;
+  aBodyOut.set(branch2);
+}
+
+template
+void
+FetchBody<Request>::MaybeTeeReadableStreamBody(JSContext* aCx,
+                                               JS::MutableHandle<JSObject*> aMessage,
+                                               ErrorResult& aRv);
+
+template
+void
+FetchBody<Response>::MaybeTeeReadableStreamBody(JSContext* aCx,
+                                                JS::MutableHandle<JSObject*> aMessage,
+                                                ErrorResult& aRv);
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -22,19 +22,21 @@
 
 class nsIGlobalObject;
 class nsIEventTarget;
 
 namespace mozilla {
 namespace dom {
 
 class BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString;
+class BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrReadableStreamOrUSVString;
 class BlobImpl;
 class InternalRequest;
 class OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString;
+struct  ReadableStream;
 class RequestOrUSVString;
 enum class CallerType : uint32_t;
 
 namespace workers {
 class WorkerPrivate;
 } // namespace workers
 
 already_AddRefed<Promise>
@@ -42,16 +44,17 @@ FetchRequest(nsIGlobalObject* aGlobal, c
              const RequestInit& aInit, CallerType aCallerType,
              ErrorResult& aRv);
 
 nsresult
 UpdateRequestReferrer(nsIGlobalObject* aGlobal, InternalRequest* aRequest);
 
 namespace fetch {
 typedef BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString BodyInit;
+typedef BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrReadableStreamOrUSVString ResponseBodyInit;
 typedef OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString OwningBodyInit;
 };
 
 /*
  * Creates an nsIInputStream based on the fetch specifications 'extract a byte
  * stream algorithm' - http://fetch.spec.whatwg.org/#concept-bodyinit-extract.
  * Stores content type in out param aContentType.
  */
@@ -65,27 +68,46 @@ ExtractByteStreamFromBody(const fetch::O
  * Non-owning version.
  */
 nsresult
 ExtractByteStreamFromBody(const fetch::BodyInit& aBodyInit,
                           nsIInputStream** aStream,
                           nsCString& aContentType,
                           uint64_t& aContentLength);
 
+/*
+ * Non-owning version. This method should go away when BodyInit will contain
+ * ReadableStream.
+ */
+nsresult
+ExtractByteStreamFromBody(const fetch::ResponseBodyInit& aBodyInit,
+                          nsIInputStream** aStream,
+                          nsCString& aContentType,
+                          uint64_t& aContentLength);
+
 template <class Derived> class FetchBodyConsumer;
 
 enum FetchConsumeType
 {
   CONSUME_ARRAYBUFFER,
   CONSUME_BLOB,
   CONSUME_FORMDATA,
   CONSUME_JSON,
   CONSUME_TEXT,
 };
 
+class FetchStreamHolder
+{
+public:
+  NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
+
+  virtual void
+  NullifyStream() = 0;
+};
+
 /*
  * FetchBody's body consumption uses nsIInputStreamPump to read from the
  * underlying stream to a block of memory, which is then adopted by
  * ContinueConsumeBody() and converted to the right type based on the JS
  * function called.
  *
  * Use of the nsIInputStreamPump complicates things on the worker thread.
  * The solution used here is similar to WebSockets.
@@ -110,23 +132,21 @@ enum FetchConsumeType
  *    ensure that mFetchBody remains alive (since mConsumeBodyPump is strongly
  *    held by it) until pump->Cancel() is called. OnStreamComplete() will not
  *    do anything if the error code is NS_BINDING_ABORTED, so we don't have to
  *    worry about keeping anything alive.
  *
  * The pump is always released on the main thread.
  */
 template <class Derived>
-class FetchBody
+class FetchBody : public FetchStreamHolder
 {
 public:
   friend class FetchBodyConsumer<Derived>;
 
-  NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
-
   bool
   BodyUsed() const;
 
   already_AddRefed<Promise>
   ArrayBuffer(JSContext* aCx, ErrorResult& aRv)
   {
     return ConsumeBody(aCx, CONSUME_ARRAYBUFFER, aRv);
   }
@@ -155,30 +175,43 @@ public:
     return ConsumeBody(aCx, CONSUME_TEXT, aRv);
   }
 
   void
   GetBody(JSContext* aCx,
           JS::MutableHandle<JSObject*> aBodyOut,
           ErrorResult& aRv);
 
+  // If the body contains a ReadableStream body object, this method produces a
+  // tee() of it.
+  void
+  MaybeTeeReadableStreamBody(JSContext* aCx,
+                             JS::MutableHandle<JSObject*> aBodyOut,
+                             ErrorResult& aRv);
+
   // Utility public methods accessed by various runnables.
 
   void
   SetBodyUsed()
   {
     mBodyUsed = true;
   }
 
   const nsCString&
   MimeType() const
   {
     return mMimeType;
   }
 
+  void
+  NullifyStream() override
+  {
+    mReadableStreamBody = nullptr;
+  }
+
 protected:
   nsCOMPtr<nsIGlobalObject> mOwner;
 
   // Always set whenever the FetchBody is created on the worker thread.
   workers::WorkerPrivate* mWorkerPrivate;
 
   // This is the ReadableStream exposed to content. It's underlying source is a
   // FetchStream object.
@@ -186,26 +219,32 @@ protected:
 
   explicit FetchBody(nsIGlobalObject* aOwner);
 
   virtual ~FetchBody();
 
   void
   SetMimeType();
 
+  void
+  SetReadableStreamBody(JSObject* aBody);
+
 private:
   Derived*
   DerivedClass() const
   {
     return static_cast<Derived*>(const_cast<FetchBody*>(this));
   }
 
   already_AddRefed<Promise>
   ConsumeBody(JSContext* aCx, FetchConsumeType aType, ErrorResult& aRv);
 
+  void
+  LockStream(JSContext* aCx, JS::HandleObject aStream, ErrorResult& aRv);
+
   bool
   IsOnTargetThread()
   {
     return NS_IsMainThread() == !mWorkerPrivate;
   }
 
   void
   AssertIsOnTargetThread()
diff --git a/dom/fetch/FetchStream.cpp b/dom/fetch/FetchStream.cpp
--- a/dom/fetch/FetchStream.cpp
+++ b/dom/fetch/FetchStream.cpp
@@ -52,48 +52,71 @@ private:
   bool mWasNotified;
 };
 
 class FetchStreamWorkerHolderShutdown final : public WorkerControlRunnable
 {
 public:
   FetchStreamWorkerHolderShutdown(WorkerPrivate* aWorkerPrivate,
                                   UniquePtr<WorkerHolder>&& aHolder,
-                                  nsCOMPtr<nsIGlobalObject>&& aGlobal)
-    : WorkerControlRunnable(aWorkerPrivate)
+                                  nsCOMPtr<nsIGlobalObject>&& aGlobal,
+                                  RefPtr<FetchStreamHolder>&& aStreamHolder)
+    : WorkerControlRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
     , mHolder(Move(aHolder))
     , mGlobal(Move(aGlobal))
+    , mStreamHolder(Move(aStreamHolder))
   {}
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     mHolder = nullptr;
     mGlobal = nullptr;
+
+    mStreamHolder->NullifyStream();
+    mStreamHolder = nullptr;
+
     return true;
   }
 
+  // This runnable starts from a JS Thread. We need to disable a couple of
+  // assertions overring the following methods.
+
+  bool
+  PreDispatch(WorkerPrivate* aWorkerPrivate) override
+  {
+    return true;
+  }
+
+  void
+  PostDispatch(WorkerPrivate* aWorkerPrivate, bool aDispatchResult) override
+  {}
+
 private:
   UniquePtr<WorkerHolder> mHolder;
   nsCOMPtr<nsIGlobalObject> mGlobal;
+  RefPtr<FetchStreamHolder> mStreamHolder;
 };
 
 } // anonymous
 
 NS_IMPL_ISUPPORTS(FetchStream, nsIInputStreamCallback, nsIObserver,
                   nsISupportsWeakReference)
 
 /* static */ JSObject*
-FetchStream::Create(JSContext* aCx, nsIGlobalObject* aGlobal,
-                    nsIInputStream* aInputStream, ErrorResult& aRv)
+FetchStream::Create(JSContext* aCx, FetchStreamHolder* aStreamHolder,
+                    nsIGlobalObject* aGlobal, nsIInputStream* aInputStream,
+                    ErrorResult& aRv)
 {
   MOZ_DIAGNOSTIC_ASSERT(aCx);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamHolder);
   MOZ_DIAGNOSTIC_ASSERT(aInputStream);
 
-  RefPtr<FetchStream> stream = new FetchStream(aGlobal, aInputStream);
+  RefPtr<FetchStream> stream =
+    new FetchStream(aGlobal, aStreamHolder, aInputStream);
 
   if (NS_IsMainThread()) {
     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     if (NS_WARN_IF(!os)) {
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
 
@@ -219,17 +242,17 @@ FetchStream::RequestDataCallback(JSConte
     stream->mOriginalInputStream = nullptr;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(stream->mInputStream);
   MOZ_DIAGNOSTIC_ASSERT(!stream->mOriginalInputStream);
 
   nsresult rv =
     stream->mInputStream->AsyncWait(stream, 0, 0,
-                                    stream->mGlobal->EventTargetFor(TaskCategory::Other));
+                                    stream->mOwningEventTarget);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     stream->ErrorPropagation(aCx, aStream, rv);
     return;
   }
 
   // All good.
 }
 
@@ -257,23 +280,22 @@ FetchStream::WriteIntoReadRequestCallbac
   if (NS_WARN_IF(NS_FAILED(rv))) {
     stream->ErrorPropagation(aCx, aStream, rv);
     return;
   }
 
   *aByteWritten = written;
 
   if (written == 0) {
-    stream->mState = eClosed;
-    JS::ReadableStreamClose(aCx, aStream);
+    stream->CloseAndReleaseObjects(aCx, aStream);
     return;
   }
 
   rv = stream->mInputStream->AsyncWait(stream, 0, 0,
-                                       stream->mGlobal->EventTargetFor(TaskCategory::Other));
+                                       stream->mOwningEventTarget);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     stream->ErrorPropagation(aCx, aStream, rv);
     return;
   }
 
   // All good.
 }
 
@@ -286,18 +308,17 @@ FetchStream::CancelCallback(JSContext* a
   MOZ_DIAGNOSTIC_ASSERT(aFlags == FETCH_STREAM_FLAG);
 
   RefPtr<FetchStream> stream = static_cast<FetchStream*>(aUnderlyingSource);
 
   if (stream->mInputStream) {
     stream->mInputStream->CloseWithStatus(NS_BASE_STREAM_CLOSED);
   }
 
-  stream->mState = eClosed;
-
+  stream->ReleaseObjects();
   return JS::UndefinedValue();
 }
 
 /* static */ void
 FetchStream::ClosedCallback(JSContext* aCx, JS::HandleObject aStream,
                             void* aUnderlyingSource, uint8_t aFlags)
 {
   MOZ_DIAGNOSTIC_ASSERT(aUnderlyingSource);
@@ -319,65 +340,63 @@ FetchStream::FinalizeCallback(void* aUnd
   MOZ_DIAGNOSTIC_ASSERT(aUnderlyingSource);
   MOZ_DIAGNOSTIC_ASSERT(aFlags == FETCH_STREAM_FLAG);
 
   // This can be called in any thread.
 
   RefPtr<FetchStream> stream =
     dont_AddRef(static_cast<FetchStream*>(aUnderlyingSource));
 
-  if (stream->mState == eClosed) {
-    return;
-  }
-
-  stream->CloseAndReleaseObjects();
+  stream->ReleaseObjects();
 }
 
 FetchStream::FetchStream(nsIGlobalObject* aGlobal,
+                         FetchStreamHolder* aStreamHolder,
                          nsIInputStream* aInputStream)
   : mState(eWaiting)
   , mGlobal(aGlobal)
+  , mStreamHolder(aStreamHolder)
+  , mOwningEventTarget(aGlobal->EventTargetFor(TaskCategory::Other))
   , mOriginalInputStream(aInputStream)
-  , mOwningEventTarget(mGlobal->EventTargetFor(TaskCategory::Other))
   , mReadableStream(nullptr)
 {
   MOZ_DIAGNOSTIC_ASSERT(aInputStream);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamHolder);
 }
 
 FetchStream::~FetchStream()
 {
 }
 
 void
 FetchStream::ErrorPropagation(JSContext* aCx, JS::HandleObject aStream,
                               nsresult aError)
 {
   // Nothing to do.
   if (mState == eClosed) {
     return;
   }
 
-  // We cannot continue with any other operation.
-  mState = eClosed;
-
   // Let's close the stream.
   if (aError == NS_BASE_STREAM_CLOSED) {
-    JS::ReadableStreamClose(aCx, aStream);
+    CloseAndReleaseObjects(aCx, aStream);
     return;
   }
 
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
 
   // Let's use a generic error.
   RefPtr<DOMError> error = new DOMError(window, NS_ERROR_DOM_TYPE_ERR);
 
   JS::Rooted<JS::Value> errorValue(aCx);
   if (ToJSValue(aCx, error, &errorValue)) {
     JS::ReadableStreamError(aCx, aStream, errorValue);
   }
+
+  ReleaseObjects();
 }
 
 NS_IMETHODIMP
 FetchStream::OnInputStreamReady(nsIAsyncInputStream* aStream)
 {
   MOZ_DIAGNOSTIC_ASSERT(aStream);
 
   // Already closed. We have nothing else to do here.
@@ -422,61 +441,98 @@ FetchStream::OnInputStreamReady(nsIAsync
   JS::ReadableStreamUpdateDataAvailableFromSource(cx, stream, size);
 
   // The WriteInto callback changes mState to eChecking.
   MOZ_DIAGNOSTIC_ASSERT(mState == eChecking);
 
   return NS_OK;
 }
 
+/* static */ nsresult
+FetchStream::RetrieveInputStream(void* aUnderlyingReadableStreamSource,
+                                 nsIInputStream** aInputStream)
+{
+  MOZ_ASSERT(aUnderlyingReadableStreamSource);
+  MOZ_ASSERT(aInputStream);
+
+  RefPtr<FetchStream> stream =
+    static_cast<FetchStream*>(aUnderlyingReadableStreamSource);
+
+  // if mOriginalInputStream is null, the reading already started. We don't want
+  // to expose the internal inputStream.
+  if (NS_WARN_IF(!stream->mOriginalInputStream)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  nsCOMPtr<nsIInputStream> inputStream = stream->mOriginalInputStream;
+  inputStream.forget(aInputStream);
+  return NS_OK;
+}
+
 void
 FetchStream::Close()
 {
   if (mState == eClosed) {
     return;
   }
 
   AutoJSAPI jsapi;
   if (NS_WARN_IF(!jsapi.Init(mGlobal))) {
+    ReleaseObjects();
     return;
   }
 
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> stream(cx, mReadableStream);
-  JS::ReadableStreamClose(cx, stream);
-
-  CloseAndReleaseObjects();
+  CloseAndReleaseObjects(cx, stream);
 }
 
 void
-FetchStream::CloseAndReleaseObjects()
+FetchStream::CloseAndReleaseObjects(JSContext* aCx, JS::HandleObject aStream)
 {
   MOZ_DIAGNOSTIC_ASSERT(mState != eClosed);
+
+  ReleaseObjects();
+
+  if (JS::ReadableStreamIsReadable(aStream)) {
+    JS::ReadableStreamClose(aCx, aStream);
+  }
+}
+
+void
+FetchStream::ReleaseObjects()
+{
+  if (mState == eClosed) {
+    return;
+  }
+
   mState = eClosed;
 
   if (mWorkerHolder) {
     RefPtr<FetchStreamWorkerHolderShutdown> r =
       new FetchStreamWorkerHolderShutdown(
         static_cast<FetchStreamWorkerHolder*>(mWorkerHolder.get())->GetWorkerPrivate(),
-        Move(mWorkerHolder), Move(mGlobal));
+        Move(mWorkerHolder), Move(mGlobal), Move(mStreamHolder));
     r->Dispatch();
   } else {
     RefPtr<FetchStream> self = this;
     RefPtr<Runnable> r = NS_NewRunnableFunction(
-      "FetchStream::Finalize",
+      "FetchStream::ReleaseObjects",
       [self] () {
-        nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
-        if (os) {
-          os->RemoveObserver(self, DOM_WINDOW_DESTROYED_TOPIC);
+        nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+        if (obs) {
+          obs->RemoveObserver(self, DOM_WINDOW_DESTROYED_TOPIC);
         }
         self->mGlobal = nullptr;
+
+        self->mStreamHolder->NullifyStream();
+        self->mStreamHolder = nullptr;
       });
 
-    mGlobal->Dispatch("FetchStream::FinalizeCallback",
-                      TaskCategory::Other, r.forget());
+    mOwningEventTarget->Dispatch(r.forget());
   }
 }
 
 // nsIObserver
 // -----------
 
 NS_IMETHODIMP
 FetchStream::Observe(nsISupports* aSubject, const char* aTopic,
diff --git a/dom/fetch/FetchStream.h b/dom/fetch/FetchStream.h
--- a/dom/fetch/FetchStream.h
+++ b/dom/fetch/FetchStream.h
@@ -20,34 +20,42 @@ class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 
 namespace workers {
 class WorkerHolder;
 }
 
+class FetchStreamHolder;
+
 class FetchStream final : public nsIInputStreamCallback
                         , public nsIObserver
                         , public nsSupportsWeakReference
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAMCALLBACK
   NS_DECL_NSIOBSERVER
 
   static JSObject*
-  Create(JSContext* aCx, nsIGlobalObject* aGlobal,
-         nsIInputStream* aInputStream, ErrorResult& aRv);
+  Create(JSContext* aCx, FetchStreamHolder* aStreamHolder,
+         nsIGlobalObject* aGlobal, nsIInputStream* aInputStream,
+         ErrorResult& aRv);
 
   void
   Close();
 
+  static nsresult
+  RetrieveInputStream(void* aUnderlyingReadableStreamSource,
+                      nsIInputStream** aInputStream);
+
 private:
-  FetchStream(nsIGlobalObject* aGlobal, nsIInputStream* aInputStream);
+  FetchStream(nsIGlobalObject* aGlobal, FetchStreamHolder* aStreamHolder,
+              nsIInputStream* aInputStream);
   ~FetchStream();
 
   static void
   RequestDataCallback(JSContext* aCx, JS::HandleObject aStream,
                       void* aUnderlyingSource, uint8_t aFlags,
                       size_t aDesiredSize);
 
   static void
@@ -72,17 +80,20 @@ private:
 
   static void
   FinalizeCallback(void* aUnderlyingSource, uint8_t aFlags);
 
   void
   ErrorPropagation(JSContext* aCx, JS::HandleObject aStream, nsresult aRv);
 
   void
-  CloseAndReleaseObjects();
+  CloseAndReleaseObjects(JSContext* aCx, JS::HandleObject aSteam);
+
+  void
+  ReleaseObjects();
 
   // Common methods
 
   enum State {
     // RequestDataCallback has not been called yet. We haven't started to read
     // data from the stream yet.
     eWaiting,
 
@@ -100,25 +111,25 @@ private:
     // Operation completed.
     eClosed,
   };
 
   // Touched only on the target thread.
   State mState;
 
   nsCOMPtr<nsIGlobalObject> mGlobal;
+  RefPtr<FetchStreamHolder> mStreamHolder;
+  nsCOMPtr<nsIEventTarget> mOwningEventTarget;
 
   // This is the original inputStream received during the CTOR. It will be
   // converted into an nsIAsyncInputStream and stored into mInputStream at the
   // first use.
   nsCOMPtr<nsIInputStream> mOriginalInputStream;
   nsCOMPtr<nsIAsyncInputStream> mInputStream;
 
-  nsCOMPtr<nsIEventTarget> mOwningEventTarget;
-
   UniquePtr<workers::WorkerHolder> mWorkerHolder;
 
   JS::Heap<JSObject*> mReadableStream;
 };
 
 } // dom namespace
 } // mozilla namespace
 
diff --git a/dom/fetch/InternalResponse.h b/dom/fetch/InternalResponse.h
--- a/dom/fetch/InternalResponse.h
+++ b/dom/fetch/InternalResponse.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_InternalResponse_h
 #define mozilla_dom_InternalResponse_h
 
 #include "nsIInputStream.h"
 #include "nsISupportsImpl.h"
 
+#include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/ResponseBinding.h"
 #include "mozilla/dom/ChannelInfo.h"
 #include "mozilla/UniquePtr.h"
 
 namespace mozilla {
 namespace ipc {
 class PrincipalInfo;
 class AutoIPCStream;
diff --git a/dom/fetch/Response.cpp b/dom/fetch/Response.cpp
--- a/dom/fetch/Response.cpp
+++ b/dom/fetch/Response.cpp
@@ -3,26 +3,30 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Response.h"
 
 #include "nsISupportsImpl.h"
 #include "nsIURI.h"
+#include "nsNetUtil.h"
 #include "nsPIDOMWindow.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/FetchBinding.h"
+#include "mozilla/dom/ResponseBinding.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/URL.h"
 
 #include "nsDOMString.h"
 
+#include "BodyExtractor.h"
+#include "FetchStream.h"
 #include "InternalResponse.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(Response)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(Response)
@@ -121,17 +125,17 @@ Response::Redirect(const GlobalObject& a
     return nullptr;
   }
 
   if (aStatus != 301 && aStatus != 302 && aStatus != 303 && aStatus != 307 && aStatus != 308) {
     aRv.ThrowRangeError<MSG_INVALID_REDIRECT_STATUSCODE_ERROR>();
     return nullptr;
   }
 
-  Optional<fetch::BodyInit> body;
+  Optional<fetch::ResponseBodyInit> body;
   ResponseInit init;
   init.mStatus = aStatus;
   RefPtr<Response> r = Response::Constructor(aGlobal, body, init, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   r->GetInternalHeaders()->Set(NS_LITERAL_CSTRING("Location"),
@@ -142,17 +146,17 @@ Response::Redirect(const GlobalObject& a
   r->GetInternalHeaders()->SetGuard(HeadersGuardEnum::Immutable, aRv);
   MOZ_ASSERT(!aRv.Failed());
 
   return r.forget();
 }
 
 /*static*/ already_AddRefed<Response>
 Response::Constructor(const GlobalObject& aGlobal,
-                      const Optional<fetch::BodyInit>& aBody,
+                      const Optional<fetch::ResponseBodyInit>& aBody,
                       const ResponseInit& aInit, ErrorResult& aRv)
 {
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
 
   if (aInit.mStatus < 200 || aInit.mStatus > 599) {
     aRv.ThrowRangeError<MSG_INVALID_RESPONSE_STATUSCODE_ERROR>();
     return nullptr;
   }
@@ -214,26 +218,70 @@ Response::Constructor(const GlobalObject
   }
 
   if (aBody.WasPassed()) {
     if (aInit.mStatus == 204 || aInit.mStatus == 205 || aInit.mStatus == 304) {
       aRv.ThrowTypeError<MSG_RESPONSE_NULL_STATUS_WITH_BODY>();
       return nullptr;
     }
 
+    nsCString contentTypeWithCharset;
     nsCOMPtr<nsIInputStream> bodyStream;
-    nsCString contentTypeWithCharset;
     uint64_t bodySize = 0;
-    aRv = ExtractByteStreamFromBody(aBody.Value(),
-                                    getter_AddRefs(bodyStream),
-                                    contentTypeWithCharset,
-                                    bodySize);
-    if (NS_WARN_IF(aRv.Failed())) {
-      return nullptr;
+
+    if (aBody.Value().IsReadableStream()) {
+      const ReadableStream& readableStream =
+        aBody.Value().GetAsReadableStream();
+
+      JS::Rooted<JSObject*> readableStreamObj(aGlobal.Context(),
+                                              readableStream.Obj());
+
+      if (JS::ReadableStreamIsDisturbed(readableStreamObj) ||
+          JS::ReadableStreamIsLocked(readableStreamObj) ||
+          !JS::ReadableStreamIsReadable(readableStreamObj)) {
+        aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
+        return nullptr;
+      }
+
+      r->SetReadableStreamBody(readableStreamObj);
+
+      // TODO: see next patches
+      MOZ_ASSERT(JS::ReadableStreamGetMode(readableStreamObj) !=
+                   JS::ReadableStreamMode::ExternalSource);
+
+      void* underlyingSource = nullptr;
+      if (!JS::ReadableStreamGetExternalUnderlyingSource(aGlobal.Context(),
+                                                         readableStreamObj,
+                                                         &underlyingSource)) {
+        aRv.StealExceptionFromJSContext(aGlobal.Context());
+        return nullptr;
+      }
+
+      bodySize = InternalResponse::UNKNOWN_BODY_SIZE;
+
+      MOZ_ASSERT(underlyingSource);
+      aRv = FetchStream::RetrieveInputStream(underlyingSource,
+                                             getter_AddRefs(bodyStream));
+
+      // The releasing of the external source is needed in order to avoid an extra
+      // stream lock.
+      JS::ReadableStreamReleaseExternalUnderlyingSource(readableStreamObj);
+      if (NS_WARN_IF(aRv.Failed())) {
+        return nullptr;
+      }
+    } else {
+      aRv = ExtractByteStreamFromBody(aBody.Value(),
+                                      getter_AddRefs(bodyStream),
+                                      contentTypeWithCharset,
+                                      bodySize);
+      if (NS_WARN_IF(aRv.Failed())) {
+        return nullptr;
+      }
     }
+
     internalResponse->SetBody(bodyStream, bodySize);
 
     if (!contentTypeWithCharset.IsVoid() &&
         !internalResponse->Headers()->Has(NS_LITERAL_CSTRING("Content-Type"),
                                           aRv)) {
       // Ignore Append() failing here.
       ErrorResult error;
       internalResponse->Headers()->Append(NS_LITERAL_CSTRING("Content-Type"),
@@ -246,39 +294,69 @@ Response::Constructor(const GlobalObject
     }
   }
 
   r->SetMimeType();
   return r.forget();
 }
 
 already_AddRefed<Response>
-Response::Clone(ErrorResult& aRv) const
+Response::Clone(JSContext* aCx, ErrorResult& aRv)
 {
   if (BodyUsed()) {
     aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
     return nullptr;
   }
 
   RefPtr<InternalResponse> ir = mInternalResponse->Clone();
   RefPtr<Response> response = new Response(mOwner, ir);
+
+  JS::Rooted<JSObject*> body(aCx);
+  MaybeTeeReadableStreamBody(aCx, &body, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
+
+  if (body) {
+    // Maybe we have a body, but we receive null from MaybeTeeReadableStreamBody
+    // if this body is a native stream.   In this case the InternalResponse will
+    // have a clone of the native body and the ReadableStream will be created
+    // lazily if needed.
+    response->SetReadableStreamBody(body);
+  }
+
   return response.forget();
 }
 
 already_AddRefed<Response>
-Response::CloneUnfiltered(ErrorResult& aRv) const
+Response::CloneUnfiltered(JSContext* aCx, ErrorResult& aRv)
 {
   if (BodyUsed()) {
     aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
     return nullptr;
   }
 
   RefPtr<InternalResponse> clone = mInternalResponse->Clone();
   RefPtr<InternalResponse> ir = clone->Unfiltered();
   RefPtr<Response> ref = new Response(mOwner, ir);
+
+  JS::Rooted<JSObject*> body(aCx);
+  MaybeTeeReadableStreamBody(aCx, &body, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
+
+  if (body) {
+    // Maybe we have a body, but we receive null from MaybeTeeReadableStreamBody
+    // if this body is a native stream.   In this case the InternalResponse will
+    // have a clone of the native body and the ReadableStream will be created
+    // lazily if needed.
+    ref->SetReadableStreamBody(body);
+  }
+
   return ref.forget();
 }
 
 void
 Response::SetBody(nsIInputStream* aBody, int64_t aBodySize)
 {
   MOZ_ASSERT(!BodyUsed());
   mInternalResponse->SetBody(aBody, aBodySize);
diff --git a/dom/fetch/Response.h b/dom/fetch/Response.h
--- a/dom/fetch/Response.h
+++ b/dom/fetch/Response.h
@@ -111,29 +111,29 @@ public:
   static already_AddRefed<Response>
   Error(const GlobalObject& aGlobal);
 
   static already_AddRefed<Response>
   Redirect(const GlobalObject& aGlobal, const nsAString& aUrl, uint16_t aStatus, ErrorResult& aRv);
 
   static already_AddRefed<Response>
   Constructor(const GlobalObject& aGlobal,
-              const Optional<fetch::BodyInit>& aBody,
+              const Optional<fetch::ResponseBodyInit>& aBody,
               const ResponseInit& aInit, ErrorResult& rv);
 
   nsIGlobalObject* GetParentObject() const
   {
     return mOwner;
   }
 
   already_AddRefed<Response>
-  Clone(ErrorResult& aRv) const;
+  Clone(JSContext* aCx, ErrorResult& aRv);
 
   already_AddRefed<Response>
-  CloneUnfiltered(ErrorResult& aRv) const;
+  CloneUnfiltered(JSContext* aCx, ErrorResult& aRv);
 
   void
   SetBody(nsIInputStream* aBody, int64_t aBodySize);
 
   already_AddRefed<InternalResponse>
   GetInternalResponse() const;
 
 private:
diff --git a/dom/webidl/Response.webidl b/dom/webidl/Response.webidl
--- a/dom/webidl/Response.webidl
+++ b/dom/webidl/Response.webidl
@@ -2,17 +2,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * The origin of this IDL file is
  * https://fetch.spec.whatwg.org/#response-class
  */
 
-[Constructor(optional BodyInit body, optional ResponseInit init),
+// This should be Constructor(optional BodyInit... but BodyInit doesn't include
+// ReadableStream yet because we don't want to expose Streams API to Request.
+[Constructor(optional (Blob or BufferSource or FormData or URLSearchParams or ReadableStream or USVString) body, optional ResponseInit init),
  Exposed=(Window,Worker)]
 interface Response {
   [NewObject] static Response error();
   [Throws,
    NewObject] static Response redirect(USVString url, optional unsigned short status = 302);
 
   readonly attribute ResponseType type;
 
