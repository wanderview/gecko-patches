# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ea258a601bb7bb4ab0b069ada4343570554a7df5
Bug 1436812 P4 Remove stale service worker ready promise code. r=asuth

diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -139,22 +139,16 @@ interface nsIServiceWorkerManager : nsIS
                   in DOMString aScope);
 
   // Returns a Promise
   nsISupports getRegistrations(in mozIDOMWindow aWindow);
 
   // Returns a Promise
   nsISupports getRegistration(in mozIDOMWindow aWindow, in DOMString aScope);
 
-  // Returns a Promise
-  nsISupports getReadyPromise(in mozIDOMWindow aWindow);
-
-  // Remove ready pending Promise
-  void removeReadyPromise(in mozIDOMWindow aWindow);
-
   nsIServiceWorkerRegistrationInfo getRegistrationByPrincipal(in nsIPrincipal aPrincipal,
                                                               in DOMString aScope);
 
   [notxpcom, nostdcall] bool StartControlling(in const_ClientInfoRef aClientInfo,
                                               in const_ServiceWorkerDescriptorRef aServiceWorker);
 
   /*
    * Clears ServiceWorker registrations from memory and disk for the specified
diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -100,26 +100,16 @@ ServiceWorkerContainer::ControllerChange
 
 void
 ServiceWorkerContainer::RemoveReadyPromise()
 {
   mReadyPromiseHolder.DisconnectIfExists();
   if (mReadyPromise) {
     mReadyPromise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
   }
-  if (nsCOMPtr<nsPIDOMWindowInner> window = GetOwner()) {
-    nsCOMPtr<nsIServiceWorkerManager> swm =
-      mozilla::services::GetServiceWorkerManager();
-    if (!swm) {
-      // If the browser is shutting down, we don't need to remove the promise.
-      return;
-    }
-
-    swm->RemoveReadyPromise(window);
-  }
 }
 
 JSObject*
 ServiceWorkerContainer::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return ServiceWorkerContainerBinding::Wrap(aCx, this, aGivenProto);
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -1201,57 +1201,16 @@ ServiceWorkerManager::GetRegistration(mo
   }
 
   nsCOMPtr<nsIRunnable> runnable =
     new GetRegistrationRunnable(window, promise, aDocumentURL);
   promise.forget(aPromise);
   return NS_DispatchToCurrentThread(runnable);
 }
 
-class GetReadyPromiseRunnable final : public Runnable
-{
-  nsCOMPtr<nsPIDOMWindowInner> mWindow;
-  RefPtr<Promise> mPromise;
-
-public:
-  GetReadyPromiseRunnable(nsPIDOMWindowInner* aWindow, Promise* aPromise)
-    : Runnable("dom::ServiceWorkerManager::GetReadyPromiseRunnable")
-    , mWindow(aWindow)
-    , mPromise(aPromise)
-  {}
-
-  NS_IMETHOD
-  Run() override
-  {
-    RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    if (!swm) {
-      mPromise->MaybeReject(NS_ERROR_UNEXPECTED);
-      return NS_OK;
-    }
-
-    nsIDocument* doc = mWindow->GetExtantDoc();
-    if (!doc) {
-      mPromise->MaybeReject(NS_ERROR_UNEXPECTED);
-      return NS_OK;
-    }
-
-    nsCOMPtr<nsIURI> docURI = doc->GetDocumentURI();
-    if (!docURI) {
-      mPromise->MaybeReject(NS_ERROR_UNEXPECTED);
-      return NS_OK;
-    }
-
-    if (!swm->CheckReadyPromise(mWindow, docURI, mPromise)) {
-      swm->StorePendingReadyPromise(mWindow, docURI, mPromise);
-    }
-
-    return NS_OK;
-  }
-};
-
 NS_IMETHODIMP
 ServiceWorkerManager::SendPushEvent(const nsACString& aOriginAttributes,
                                     const nsACString& aScope,
                                     uint32_t aDataLength,
                                     uint8_t* aDataBytes,
                                     uint8_t optional_argc)
 {
   if (optional_argc == 2) {
@@ -1367,79 +1326,16 @@ ServiceWorkerManager::SendNotificationCl
                                                  const nsAString& aData,
                                                  const nsAString& aBehavior)
 {
   return SendNotificationEvent(NS_LITERAL_STRING(NOTIFICATION_CLOSE_EVENT_NAME),
                                aOriginSuffix, aScope, aID, aTitle, aDir, aLang,
                                aBody, aTag, aIcon, aData, aBehavior);
 }
 
-NS_IMETHODIMP
-ServiceWorkerManager::GetReadyPromise(mozIDOMWindow* aWindow,
-                                      nsISupports** aPromise)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-
-  if (NS_WARN_IF(!aWindow)) {
-    return NS_ERROR_DOM_INVALID_STATE_ERR;
-  }
-
-  auto* window = nsPIDOMWindowInner::From(aWindow);
-
-  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
-  if (NS_WARN_IF(!doc)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Don't allow service workers to register when the *document* is chrome for
-  // now.
-  MOZ_ASSERT(!nsContentUtils::IsSystemPrincipal(doc->NodePrincipal()));
-
-  MOZ_ASSERT(!mPendingReadyPromises.Contains(window));
-
-  ErrorResult result;
-  RefPtr<Promise> promise = Promise::Create(window->AsGlobal(), result);
-  if (result.Failed()) {
-    return result.StealNSResult();
-  }
-
-  nsCOMPtr<nsIRunnable> runnable =
-    new GetReadyPromiseRunnable(window, promise);
-  promise.forget(aPromise);
-  return NS_DispatchToCurrentThread(runnable);
-}
-
-NS_IMETHODIMP
-ServiceWorkerManager::RemoveReadyPromise(mozIDOMWindow* aWindow)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aWindow);
-
-  if (!aWindow) {
-    return NS_ERROR_FAILURE;
-  }
-
-  mPendingReadyPromises.Remove(aWindow);
-  return NS_OK;
-}
-
-void
-ServiceWorkerManager::StorePendingReadyPromise(nsPIDOMWindowInner* aWindow,
-                                               nsIURI* aURI,
-                                               Promise* aPromise)
-{
-  PendingReadyPromise* data;
-
-  // We should not have 2 pending promises for the same window.
-  MOZ_ASSERT(!mPendingReadyPromises.Get(aWindow, &data));
-
-  data = new PendingReadyPromise(aURI, aPromise);
-  mPendingReadyPromises.Put(aWindow, data);
-}
-
 RefPtr<ServiceWorkerRegistrationPromise>
 ServiceWorkerManager::OnReady(const ClientInfo& aClientInfo)
 {
   AssertIsOnMainThread();
 
   for (auto &prd : mPendingReadyList) {
     if (prd->mClientHandle->Info().Id() == aClientInfo.Id() &&
         prd->mClientHandle->Info().PrincipalInfo() == aClientInfo.PrincipalInfo()) {
@@ -1467,69 +1363,32 @@ ServiceWorkerManager::OnReady(const Clie
     });
 
   return mPendingReadyList.LastElement()->mPromise;
 }
 
 void
 ServiceWorkerManager::CheckPendingReadyPromises()
 {
-  for (auto iter = mPendingReadyPromises.Iter(); !iter.Done(); iter.Next()) {
-    nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(iter.Key());
-    MOZ_ASSERT(window);
-
-    nsAutoPtr<PendingReadyPromise>& pendingReadyPromise = iter.Data();
-    if (CheckReadyPromise(window, pendingReadyPromise->mURI,
-                          pendingReadyPromise->mPromise)) {
-      iter.Remove();
-    }
-  }
-
   nsTArray<UniquePtr<PendingReadyData>> pendingReadyList;
   mPendingReadyList.SwapElements(pendingReadyList);
   for (uint32_t i = 0; i < pendingReadyList.Length(); ++i) {
     UniquePtr<PendingReadyData> prd(Move(pendingReadyList[i]));
 
     RefPtr<ServiceWorkerRegistrationInfo> reg =
       GetServiceWorkerRegistrationInfo(prd->mClientHandle->Info());
 
     if (reg && reg->GetActive()) {
       prd->mPromise->Resolve(reg->Descriptor(), __func__);
     } else {
       mPendingReadyList.AppendElement(Move(prd));
     }
   }
 }
 
-bool
-ServiceWorkerManager::CheckReadyPromise(nsPIDOMWindowInner* aWindow,
-                                        nsIURI* aURI, Promise* aPromise)
-{
-  MOZ_ASSERT(aWindow);
-  MOZ_ASSERT(aURI);
-
-  nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  MOZ_ASSERT(doc);
-
-  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
-  MOZ_ASSERT(principal);
-
-  RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(principal, aURI);
-
-  if (registration && registration->GetActive()) {
-    RefPtr<ServiceWorkerRegistration> swr =
-      aWindow->AsGlobal()->GetOrCreateServiceWorkerRegistration(registration->Descriptor());
-    aPromise->MaybeResolve(swr);
-    return true;
-  }
-
-  return false;
-}
-
 void
 ServiceWorkerManager::RemovePendingReadyPromise(const ClientInfo& aClientInfo)
 {
   nsTArray<UniquePtr<PendingReadyData>> pendingReadyList;
   mPendingReadyList.SwapElements(pendingReadyList);
   for (uint32_t i = 0; i < pendingReadyList.Length(); ++i) {
     UniquePtr<PendingReadyData> prd(Move(pendingReadyList[i]));
 
diff --git a/dom/serviceworkers/ServiceWorkerManager.h b/dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h
+++ b/dom/serviceworkers/ServiceWorkerManager.h
@@ -81,17 +81,16 @@ public:
  * The ServiceWorkerManager is a per-process global that deals with the
  * installation, querying and event dispatch of ServiceWorkers for all the
  * origins in the process.
  */
 class ServiceWorkerManager final
   : public nsIServiceWorkerManager
   , public nsIObserver
 {
-  friend class GetReadyPromiseRunnable;
   friend class GetRegistrationsRunnable;
   friend class GetRegistrationRunnable;
   friend class ServiceWorkerJob;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerUnregisterJob;
   friend class ServiceWorkerUpdateJob;
   friend class UpdateTimerCallback;
 
@@ -434,36 +433,16 @@ private:
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  StorePendingReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
-                           Promise* aPromise);
-
-  bool
-  CheckReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
-                    Promise* aPromise);
-
-  struct PendingReadyPromise final
-  {
-    PendingReadyPromise(nsIURI* aURI, Promise* aPromise)
-      : mURI(aURI), mPromise(aPromise)
-    {}
-
-    nsCOMPtr<nsIURI> mURI;
-    RefPtr<Promise> mPromise;
-  };
-
-  nsClassHashtable<nsISupportsHashKey, PendingReadyPromise> mPendingReadyPromises;
-
-  void
   MaybeRemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   // Removes all service worker registrations that matches the given pattern.
   void
   RemoveAllRegistrations(OriginAttributesPattern* aPattern);
 
   RefPtr<ServiceWorkerManagerChild> mActor;
 
