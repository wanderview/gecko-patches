# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c70100bd03d26a819afdd64db98f372f5301e679
Bug 1293277 P7 Make ServiceWorkerManager use ClientHandle::Control() for claiming and ClientSource::SetController() fire the controller change event. r=baku

diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -356,16 +356,33 @@ ClientSource::SetController(const Servic
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   if (mController.isSome() && mController.ref() == aServiceWorker) {
     return;
   }
 
   mController.reset();
   mController.emplace(aServiceWorker);
+
+  RefPtr<ServiceWorkerContainer> swc;
+  nsPIDOMWindowInner* window = GetInnerWindow();
+  if (window) {
+    RefPtr<Navigator> navigator =
+      static_cast<Navigator*>(window->GetNavigator());
+    if (navigator) {
+      swc = navigator->ServiceWorker();
+    }
+  }
+
+  // TODO: Also self.navigator.serviceWorker on workers when its exposed there
+
+  if (swc && nsContentUtils::IsSafeToRunScript()) {
+    IgnoredErrorResult ignored;
+    swc->ControllerChanged(ignored);
+  }
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
@@ -550,21 +567,49 @@ ClientSource::PostMessage(const ClientPo
 
   ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
   return ref.forget();
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::Claim(const ClientClaimArgs& aArgs)
 {
-  SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
+  RefPtr<ClientOpPromise> ref;
+
+  ServiceWorkerDescriptor swd(aArgs.serviceWorker());
 
-  RefPtr<ClientOpPromise> ref =
-    ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  // Today the ServiceWorkerManager maintains its own list of
+  // nsIDocument objects controlled by each service worker.  We
+  // need to try to update that data structure for now.  If we
+  // can't, however, then simply mark the Client as controlled.
+  // In the future this will be enough for the SWM as well since
+  // it will eventually hold ClientHandle objects instead of
+  // nsIDocuments.
+  nsPIDOMWindowInner* innerWindow = GetInnerWindow();
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+  RefPtr<ServiceWorkerManager> swm = doc ? ServiceWorkerManager::GetInstance()
+                                         : nullptr;
+  if (!swm || !doc) {
+    SetController(swd);
+    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    return ref.forget();
+  }
 
+  RefPtr<ClientOpPromise::Private> outerPromise =
+    new ClientOpPromise::Private(__func__);
+
+  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
+  p->Then(mEventTarget, __func__,
+    [outerPromise] (bool aResult) {
+      outerPromise->Resolve(NS_OK, __func__);
+    }, [outerPromise] (nsresult aResult) {
+      outerPromise->Reject(aResult, __func__);
+    });
+
+  ref = outerPromise;
   return ref.forget();
 }
 
 RefPtr<ClientOpPromise>
 ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2833,32 +2833,52 @@ ServiceWorkerManager::GetDocumentRegistr
 NS_IMETHODIMP
 ServiceWorkerManager::GetDocumentController(nsPIDOMWindowInner* aWindow,
                                             nsISupports** aServiceWorker)
 {
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
+  Maybe<ServiceWorkerDescriptor> controller = aWindow->GetController();
+  if (controller.isNothing()) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  if (!doc) {
+  if (NS_WARN_IF(!doc)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
-  RefPtr<ServiceWorkerRegistrationInfo> registration;
-  nsresult rv = GetDocumentRegistration(doc, getter_AddRefs(registration));
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (NS_WARN_IF(!principal)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  nsAutoCString scopeKey;
+  nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  MOZ_ASSERT(registration->GetActive());
-  RefPtr<ServiceWorker> serviceWorker =
-    registration->GetActive()->GetOrCreateInstance(aWindow);
-
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(scopeKey, controller.ref().Scope());
+  if (NS_WARN_IF(!registration)) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorkerInfo> active = registration->GetActive();
+  if (NS_WARN_IF(!active) ||
+      NS_WARN_IF(active->Descriptor().Id() != controller.ref().Id())) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  RefPtr<ServiceWorker> serviceWorker = active->GetOrCreateInstance(aWindow);
   serviceWorker.forget(aServiceWorker);
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetInstalling(nsPIDOMWindowInner* aWindow,
                                     const nsAString& aScope,
                                     nsISupports** aServiceWorker)
 {
@@ -3153,77 +3173,75 @@ ServiceWorkerManager::UpdateInternal(nsI
                                registration->GetUpdateViaCache());
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);
 
   queue->ScheduleJob(job);
 }
 
-namespace {
-
-static void
-FireControllerChangeOnDocument(nsIDocument* aDocument)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDocument);
-
-  nsCOMPtr<nsPIDOMWindowInner> w = aDocument->GetInnerWindow();
-  if (!w) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-    return;
-  }
-
-  auto* window = nsGlobalWindowInner::Cast(w.get());
-  dom::Navigator* navigator = window->Navigator();
-  if (!navigator) {
-    return;
-  }
-
-  RefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
-  ErrorResult result;
-  container->ControllerChanged(result);
-  if (result.Failed()) {
-    NS_WARNING("Failed to dispatch controllerchange event");
-  }
-}
-
-} // anonymous namespace
-
-void
+already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
                                        ServiceWorkerRegistrationInfo* aWorkerRegistration)
 {
   MOZ_ASSERT(aWorkerRegistration);
   MOZ_ASSERT(aWorkerRegistration->GetActive());
 
+  RefPtr<GenericPromise> ref;
+
   // Same origin check
   if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
-    return;
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_SECURITY_ERR, __func__);
+    return ref.forget();
   }
 
   // The registration that should be controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
     GetServiceWorkerRegistrationInfo(aDocument);
 
   // The registration currently controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> controllingRegistration;
   GetDocumentRegistration(aDocument, getter_AddRefs(controllingRegistration));
 
   if (aWorkerRegistration != matchingRegistration ||
-        aWorkerRegistration == controllingRegistration) {
-    return;
+      aWorkerRegistration == controllingRegistration) {
+    ref = GenericPromise::CreateAndResolve(true, __func__);
+    return ref.forget();
   }
 
   if (controllingRegistration) {
     StopControllingADocument(controllingRegistration);
   }
 
-  StartControllingADocument(aWorkerRegistration, aDocument);
-  FireControllerChangeOnDocument(aDocument);
+  ref = StartControllingADocument(aWorkerRegistration, aDocument);
+  return ref.forget();
+}
+
+already_AddRefed<GenericPromise>
+ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
+                                       const ServiceWorkerDescriptor& aServiceWorker)
+{
+  RefPtr<GenericPromise> ref;
+
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
+  if (!principal) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(principal, aServiceWorker.Scope());
+  if (!registration) {
+    ref = GenericPromise::CreateAndResolve(false, __func__);
+    return ref.forget();
+  }
+
+  ref = MaybeClaimClient(aDoc, registration);
+  return ref.forget();
 }
 
 void
 ServiceWorkerManager::SetSkipWaitingFlag(nsIPrincipal* aPrincipal,
                                          const nsCString& aScope,
                                          uint64_t aServiceWorkerID)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -3242,38 +3260,52 @@ ServiceWorkerManager::SetSkipWaitingFlag
   worker->SetSkipWaitingFlag();
 
   if (worker->State() == ServiceWorkerState::Installed) {
     registration->TryToActivateAsync();
   }
 }
 
 void
-ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration)
 {
   AssertIsOnMainThread();
 
-  AutoTArray<nsCOMPtr<nsIDocument>, 16> documents;
+  RefPtr<ServiceWorkerInfo> activeWorker = aRegistration->GetActive();
+  MOZ_DIAGNOSTIC_ASSERT(activeWorker);
+
+  AutoTArray<nsCOMPtr<nsPIDOMWindowInner>, 16> innerWindows;
   for (auto iter = mControlledDocuments.Iter(); !iter.Done(); iter.Next()) {
     if (iter.UserData() != aRegistration) {
       continue;
     }
 
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(iter.Key());
     if (NS_WARN_IF(!doc)) {
       continue;
     }
 
-    documents.AppendElement(doc);
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      continue;
+    }
+
+    innerWindows.AppendElement(innerWindow);
   }
 
   // Fire event after iterating mControlledDocuments is done to prevent
   // modification by reentering from the event handlers during iteration.
-  for (auto& doc : documents) {
-    FireControllerChangeOnDocument(doc);
+  for (auto& innerWindow : innerWindows) {
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    if (clientInfo.isSome()) {
+      RefPtr<ClientHandle> clientHandle =
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    innerWindow->EventTargetFor(TaskCategory::Other));
+      clientHandle->Control(activeWorker->Descriptor());
+    }
   }
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
                                       const nsACString& aScope) const
 {
   MOZ_ASSERT(aPrincipal);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -266,20 +266,24 @@ public:
               const nsString& aMessage,
               const nsString& aFilename,
               const nsString& aLine,
               uint32_t aLineNumber,
               uint32_t aColumnNumber,
               uint32_t aFlags,
               JSExnType aExnType);
 
-  void
+  already_AddRefed<GenericPromise>
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
+  already_AddRefed<GenericPromise>
+  MaybeClaimClient(nsIDocument* aDoc,
+                   const ServiceWorkerDescriptor& aServiceWorker);
+
   void
   SetSkipWaitingFlag(nsIPrincipal* aPrincipal, const nsCString& aScope,
                      uint64_t aServiceWorkerID);
 
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
   void
@@ -418,17 +422,17 @@ private:
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
   FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration);
+  UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   StorePendingReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                            Promise* aPromise);
 
   bool
   CheckReadyPromise(nsPIDOMWindowInner* aWindow, nsIURI* aURI,
                     Promise* aPromise);
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -269,23 +269,18 @@ ServiceWorkerRegistrationInfo::Activate(
     return;
   }
 
   TransitionWaitingToActive();
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   // "Queue a task to fire a simple event named controllerchange..."
-  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
-    NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      "dom::workers::ServiceWorkerManager::FireControllerChange",
-      swm,
-      &ServiceWorkerManager::FireControllerChange,
-      this);
-  NS_DispatchToMainThread(controllerChangeRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mActiveWorker);
+  swm->UpdateClientControllers(this);
 
   nsCOMPtr<nsIRunnable> failRunnable = NewRunnableMethod<bool>(
     "dom::workers::ServiceWorkerRegistrationInfo::FinishActivate",
     this,
     &ServiceWorkerRegistrationInfo::FinishActivate,
     false /* success */);
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
