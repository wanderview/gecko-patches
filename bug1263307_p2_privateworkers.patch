# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9ce2e04f18ccc576484419f8d9b82c87ef556ecc
Bug 1263307 P2 Make ServiceWorkerRegistrationInfo worker members private. r=jdm

diff --git a/dom/notification/Notification.cpp b/dom/notification/Notification.cpp
--- a/dom/notification/Notification.cpp
+++ b/dom/notification/Notification.cpp
@@ -2570,18 +2570,18 @@ public:
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     RefPtr<ServiceWorkerRegistrationInfo> registration =
       swm->GetRegistration(principal, mScope);
 
     // This is coming from a ServiceWorkerRegistrationWorkerThread.
     MOZ_ASSERT(registration);
 
-    if (!registration->mActiveWorker ||
-        registration->mActiveWorker->ID() != mWorkerPrivate->ServiceWorkerID()) {
+    if (!registration->GetActive() ||
+        registration->GetActive()->ID() != mWorkerPrivate->ServiceWorkerID()) {
       mRv = NS_ERROR_NOT_AVAILABLE;
     }
 
     return true;
   }
 
   nsresult
   Result()
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -177,19 +177,19 @@ PopulateRegistrationData(nsIPrincipal* a
 
   aData.scope() = aRegistration->mScope;
 
   RefPtr<ServiceWorkerInfo> newest = aRegistration->Newest();
   if (NS_WARN_IF(!newest)) {
     return NS_ERROR_FAILURE;
   }
 
-  if (aRegistration->mActiveWorker) {
-    aData.currentWorkerURL() = aRegistration->mActiveWorker->ScriptSpec();
-    aData.cacheName() = aRegistration->mActiveWorker->CacheName();
+  if (aRegistration->GetActive()) {
+    aData.currentWorkerURL() = aRegistration->GetActive()->ScriptSpec();
+    aData.cacheName() = aRegistration->GetActive()->CacheName();
   }
 
   return NS_OK;
 }
 
 class TeardownRunnable final : public nsRunnable
 {
 public:
@@ -1176,17 +1176,17 @@ ServiceWorkerManager::CheckReadyPromise(
   MOZ_ASSERT(doc);
 
   nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
   MOZ_ASSERT(principal);
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(principal, aURI);
 
-  if (registration && registration->mActiveWorker) {
+  if (registration && registration->GetActive()) {
     NS_ConvertUTF8toUTF16 scope(registration->mScope);
     RefPtr<ServiceWorkerRegistrationMainThread> swr =
       aWindow->GetServiceWorkerRegistration(scope);
     aPromise->MaybeResolve(swr);
     return true;
   }
 
   return false;
@@ -1206,32 +1206,32 @@ ServiceWorkerManager::GetActiveWorkerInf
   nsCOMPtr<nsIPrincipal> principal =
     BasePrincipal::CreateCodebasePrincipal(scopeURI, aOriginAttributes);
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(principal, scopeURI);
   if (!registration) {
     return nullptr;
   }
 
-  return registration->mActiveWorker;
+  return registration->GetActive();
 }
 
 ServiceWorkerInfo*
 ServiceWorkerManager::GetActiveWorkerInfoForDocument(nsIDocument* aDocument)
 {
   AssertIsOnMainThread();
 
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   GetDocumentRegistration(aDocument, getter_AddRefs(registration));
 
   if (!registration) {
     return nullptr;
   }
 
-  return registration->mActiveWorker;
+  return registration->GetActive();
 }
 
 namespace {
 
 class UnregisterJobCallback final : public ServiceWorkerJob::Callback
 {
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
 
@@ -1596,29 +1596,29 @@ ServiceWorkerManager::LoadRegistration(
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(principal, aRegistration.scope());
   if (!registration) {
     registration = CreateNewRegistration(aRegistration.scope(), principal);
   } else {
     // If active worker script matches our expectations for a "current worker",
     // then we are done.
-    if (registration->mActiveWorker &&
-        registration->mActiveWorker->ScriptSpec() == aRegistration.currentWorkerURL()) {
+    if (registration->GetActive() &&
+        registration->GetActive()->ScriptSpec() == aRegistration.currentWorkerURL()) {
       // No needs for updates.
       return;
     }
   }
 
   const nsCString& currentWorkerURL = aRegistration.currentWorkerURL();
   if (!currentWorkerURL.IsEmpty()) {
-    registration->mActiveWorker =
+    registration->SetActive(
       new ServiceWorkerInfo(registration->mPrincipal, registration->mScope,
-                            currentWorkerURL, aRegistration.cacheName());
-    registration->mActiveWorker->SetActivateStateUncheckedWithoutEvent(ServiceWorkerState::Activated);
+                            currentWorkerURL, aRegistration.cacheName()));
+    registration->GetActive()->SetActivateStateUncheckedWithoutEvent(ServiceWorkerState::Activated);
   }
 }
 
 void
 ServiceWorkerManager::LoadRegistrations(
                   const nsTArray<ServiceWorkerRegistrationData>& aRegistrations)
 {
   AssertIsOnMainThread();
@@ -2018,19 +2018,19 @@ ServiceWorkerManager::StopControllingADo
 {
   aRegistration->StopControllingADocument();
   if (!aRegistration->IsControllingDocuments()) {
     if (aRegistration->mPendingUninstall) {
       RemoveRegistration(aRegistration);
     } else {
       // If the registration has an active worker that is running
       // this might be a good time to stop it.
-      if (aRegistration->mActiveWorker) {
+      if (aRegistration->GetActive()) {
         ServiceWorkerPrivate* serviceWorkerPrivate =
-          aRegistration->mActiveWorker->WorkerPrivate();
+          aRegistration->GetActive()->WorkerPrivate();
         serviceWorkerPrivate->NoteStoppedControllingDocuments();
       }
       aRegistration->TryToActivateAsync();
     }
   }
 }
 
 NS_IMETHODIMP
@@ -2153,21 +2153,21 @@ ServiceWorkerManager::GetServiceWorkerFo
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(documentPrincipal, scope);
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_FAILURE;
   }
 
   RefPtr<ServiceWorkerInfo> info;
   if (aWhichWorker == WhichServiceWorker::INSTALLING_WORKER) {
-    info = registration->mInstallingWorker;
+    info = registration->GetInstalling();
   } else if (aWhichWorker == WhichServiceWorker::WAITING_WORKER) {
-    info = registration->mWaitingWorker;
+    info = registration->GetWaiting();
   } else if (aWhichWorker == WhichServiceWorker::ACTIVE_WORKER) {
-    info = registration->mActiveWorker;
+    info = registration->GetActive();
   } else {
     MOZ_CRASH("Invalid worker type");
   }
 
   if (NS_WARN_IF(!info)) {
     return NS_ERROR_DOM_NOT_FOUND_ERR;
   }
 
@@ -2296,18 +2296,18 @@ ServiceWorkerManager::DispatchFetchEvent
       GetServiceWorkerRegistrationInfo(principal, uri);
     if (!registration) {
       NS_WARNING("No registration found when dispatching the fetch event");
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     // This should only happen if IsAvailable() returned true.
-    MOZ_ASSERT(registration->mActiveWorker);
-    serviceWorker = registration->mActiveWorker;
+    MOZ_ASSERT(registration->GetActive());
+    serviceWorker = registration->GetActive();
 
     AddNavigationInterception(serviceWorker->Scope(), aChannel);
   }
 
   if (NS_WARN_IF(aRv.Failed()) || !serviceWorker) {
     return;
   }
 
@@ -2338,17 +2338,17 @@ bool
 ServiceWorkerManager::IsAvailable(nsIPrincipal* aPrincipal,
                                   nsIURI* aURI)
 {
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(aURI);
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetServiceWorkerRegistrationInfo(aPrincipal, aURI);
-  return registration && registration->mActiveWorker;
+  return registration && registration->GetActive();
 }
 
 bool
 ServiceWorkerManager::IsControlled(nsIDocument* aDoc, ErrorResult& aRv)
 {
   MOZ_ASSERT(aDoc);
 
   if (nsContentUtils::IsInPrivateBrowsing(aDoc)) {
@@ -2373,17 +2373,17 @@ ServiceWorkerManager::GetDocumentRegistr
                                               ServiceWorkerRegistrationInfo** aRegistrationInfo)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   if (!mControlledDocuments.Get(aDoc, getter_AddRefs(registration))) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // If the document is controlled, the current worker MUST be non-null.
-  if (!registration->mActiveWorker) {
+  if (!registration->GetActive()) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   registration.forget(aRegistrationInfo);
   return NS_OK;
 }
 
 /*
@@ -2401,19 +2401,19 @@ ServiceWorkerManager::GetDocumentControl
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   nsresult rv = GetDocumentRegistration(doc, getter_AddRefs(registration));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  MOZ_ASSERT(registration->mActiveWorker);
+  MOZ_ASSERT(registration->GetActive());
   RefPtr<ServiceWorker> serviceWorker =
-    registration->mActiveWorker->GetOrCreateInstance(aWindow);
+    registration->GetActive()->GetOrCreateInstance(aWindow);
 
   serviceWorker.forget(aServiceWorker);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetInstalling(nsPIDOMWindowInner* aWindow,
                                     const nsAString& aScope,
@@ -2518,17 +2518,17 @@ ServiceWorkerManager::SoftUpdate(const P
   }
 
   // "If registration's uninstalling flag is set, abort these steps."
   if (registration->mPendingUninstall) {
     return;
   }
 
   // "If registration's installing worker is not null, abort these steps."
-  if (registration->mInstallingWorker) {
+  if (registration->GetInstalling()) {
     return;
   }
 
   // "Let newestWorker be the result of running Get Newest Worker algorithm
   // passing registration as its argument.
   // If newestWorker is null, abort these steps."
   RefPtr<ServiceWorkerInfo> newest = registration->Newest();
   if (!newest) {
@@ -2789,17 +2789,17 @@ ServiceWorkerManager::GetAllClients(nsIP
   }
 }
 
 void
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDocument,
                                        ServiceWorkerRegistrationInfo* aWorkerRegistration)
 {
   MOZ_ASSERT(aWorkerRegistration);
-  MOZ_ASSERT(aWorkerRegistration->mActiveWorker);
+  MOZ_ASSERT(aWorkerRegistration->GetActive());
 
   // Same origin check
   if (!aWorkerRegistration->mPrincipal->Equals(aDocument->NodePrincipal())) {
     return;
   }
 
   // The registration that should be controlling the client
   RefPtr<ServiceWorkerRegistrationInfo> matchingRegistration =
@@ -2824,18 +2824,18 @@ ServiceWorkerManager::MaybeClaimClient(n
 
 nsresult
 ServiceWorkerManager::ClaimClients(nsIPrincipal* aPrincipal,
                                    const nsCString& aScope, uint64_t aId)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aPrincipal, aScope);
 
-  if (!registration || !registration->mActiveWorker ||
-      !(registration->mActiveWorker->ID() == aId)) {
+  if (!registration || !registration->GetActive() ||
+      !(registration->GetActive()->ID() == aId)) {
     // The worker is not active.
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   for (auto iter = mAllDocuments.Iter(); !iter.Done(); iter.Next()) {
     nsCOMPtr<nsIDocument> document = do_QueryInterface(iter.Get()->GetKey());
     swm->MaybeClaimClient(document, registration);
@@ -2850,23 +2850,23 @@ ServiceWorkerManager::SetSkipWaitingFlag
                                          uint64_t aServiceWorkerID)
 {
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     GetRegistration(aPrincipal, aScope);
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_FAILURE;
   }
 
-  if (registration->mInstallingWorker &&
-      (registration->mInstallingWorker->ID() == aServiceWorkerID)) {
-    registration->mInstallingWorker->SetSkipWaitingFlag();
-  } else if (registration->mWaitingWorker &&
-             (registration->mWaitingWorker->ID() == aServiceWorkerID)) {
-    registration->mWaitingWorker->SetSkipWaitingFlag();
-    if (registration->mWaitingWorker->State() == ServiceWorkerState::Installed) {
+  if (registration->GetInstalling() &&
+      (registration->GetInstalling()->ID() == aServiceWorkerID)) {
+    registration->GetInstalling()->SetSkipWaitingFlag();
+  } else if (registration->GetWaiting() &&
+             (registration->GetWaiting()->ID() == aServiceWorkerID)) {
+    registration->GetWaiting()->SetSkipWaitingFlag();
+    if (registration->GetWaiting()->State() == ServiceWorkerState::Installed) {
       registration->TryToActivateAsync();
     }
   } else {
     NS_WARNING("Failed to set skipWaiting flag, no matching worker.");
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -362,9 +362,51 @@ ServiceWorkerRegistrationInfo::CheckAndC
                (mUpdateState == NeedTimeCheckAndUpdate &&
                 IsLastUpdateCheckTimeOverOneDay());
 
   mUpdateState = NoUpdate;
 
   return result;
 }
 
+ServiceWorkerInfo*
+ServiceWorkerRegistrationInfo::GetInstalling() const
+{
+  AssertIsOnMainThread();
+  return mInstallingWorker;
+}
+
+ServiceWorkerInfo*
+ServiceWorkerRegistrationInfo::GetWaiting() const
+{
+  AssertIsOnMainThread();
+  return mWaitingWorker;
+}
+
+ServiceWorkerInfo*
+ServiceWorkerRegistrationInfo::GetActive() const
+{
+  AssertIsOnMainThread();
+  return mActiveWorker;
+}
+
+void
+ServiceWorkerRegistrationInfo::SetInstalling(ServiceWorkerInfo* aServiceWorker)
+{
+  AssertIsOnMainThread();
+  mInstallingWorker = aServiceWorker;
+}
+
+void
+ServiceWorkerRegistrationInfo::SetWaiting(ServiceWorkerInfo* aServiceWorker)
+{
+  AssertIsOnMainThread();
+  mWaitingWorker = aServiceWorker;
+}
+
+void
+ServiceWorkerRegistrationInfo::SetActive(ServiceWorkerInfo* aServiceWorker)
+{
+  AssertIsOnMainThread();
+  mActiveWorker = aServiceWorker;
+}
+
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.h b/dom/workers/ServiceWorkerRegistrationInfo.h
--- a/dom/workers/ServiceWorkerRegistrationInfo.h
+++ b/dom/workers/ServiceWorkerRegistrationInfo.h
@@ -22,30 +22,30 @@ class ServiceWorkerRegistrationInfo fina
   {
     NoUpdate,
     NeedTimeCheckAndUpdate,
     NeedUpdate
   } mUpdateState;
 
   uint64_t mLastUpdateCheckTime;
 
+  RefPtr<ServiceWorkerInfo> mActiveWorker;
+  RefPtr<ServiceWorkerInfo> mWaitingWorker;
+  RefPtr<ServiceWorkerInfo> mInstallingWorker;
+
   virtual ~ServiceWorkerRegistrationInfo();
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
 
   const nsCString mScope;
 
   nsCOMPtr<nsIPrincipal> mPrincipal;
 
-  RefPtr<ServiceWorkerInfo> mActiveWorker;
-  RefPtr<ServiceWorkerInfo> mWaitingWorker;
-  RefPtr<ServiceWorkerInfo> mInstallingWorker;
-
   nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
 
   // When unregister() is called on a registration, it is not immediately
   // removed since documents may be controlled. It is marked as
   // pendingUninstall and when all controlling documents go away, removed.
   bool mPendingUninstall;
 
   ServiceWorkerRegistrationInfo(const nsACString& aScope,
@@ -118,15 +118,33 @@ public:
   void
   MaybeScheduleTimeCheckAndUpdate();
 
   void
   MaybeScheduleUpdate();
 
   bool
   CheckAndClearIfUpdateNeeded();
+
+  ServiceWorkerInfo*
+  GetInstalling() const;
+
+  ServiceWorkerInfo*
+  GetWaiting() const;
+
+  ServiceWorkerInfo*
+  GetActive() const;
+
+  void
+  SetInstalling(ServiceWorkerInfo* aServiceWorker);
+
+  void
+  SetWaiting(ServiceWorkerInfo* aServiceWorker);
+
+  void
+  SetActive(ServiceWorkerInfo* aServiceWorker);
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkerregistrationinfo_h
diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
--- a/dom/workers/ServiceWorkerUpdateJob.cpp
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -147,21 +147,21 @@ ServiceWorkerUpdateJob::FailUpdateJob(Er
     if (mServiceWorker) {
       mServiceWorker->UpdateState(ServiceWorkerState::Redundant);
       serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
                                            mServiceWorker->CacheName());
     }
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
-    if (mRegistration->mInstallingWorker) {
-      mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
+    if (mRegistration->GetInstalling()) {
+      mRegistration->GetInstalling()->UpdateState(ServiceWorkerState::Redundant);
       serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
-                                           mRegistration->mInstallingWorker->CacheName());
-      mRegistration->mInstallingWorker = nullptr;
+                                           mRegistration->GetInstalling()->CacheName());
+      mRegistration->SetInstalling(nullptr);
       if (swm) {
         swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                        WhichServiceWorker::INSTALLING_WORKER);
       }
     }
 
     if (swm) {
       swm->MaybeRemoveRegistration(mRegistration);
@@ -237,17 +237,17 @@ ServiceWorkerUpdateJob::SetRegistration(
 void
 ServiceWorkerUpdateJob::Update()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!Canceled());
 
   // SetRegistration() must be called before Update().
   MOZ_ASSERT(mRegistration);
-  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+  MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin the script download and comparison steps starting at step 5
   // of the Update algorithm.
 
   RefPtr<ServiceWorkerInfo> workerInfo = mRegistration->Newest();
   nsAutoString cacheName;
 
   // If the script has not changed, we need to perform a byte-for-byte
@@ -408,25 +408,26 @@ ServiceWorkerUpdateJob::ContinueUpdateAf
 }
 
 void
 ServiceWorkerUpdateJob::Install()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!Canceled());
 
-  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+  MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin step 2 of the Install algorithm.
   //
   //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
 
   MOZ_ASSERT(mServiceWorker);
-  mRegistration->mInstallingWorker = mServiceWorker.forget();
-  mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
+  mRegistration->SetInstalling(mServiceWorker);
+  mServiceWorker = nullptr;
+  mRegistration->GetInstalling()->UpdateState(ServiceWorkerState::Installing);
   mRegistration->NotifyListenersOnChange();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                  WhichServiceWorker::INSTALLING_WORKER);
 
   // Step 6 of the Install algorithm resolving the job promise.
   InvokeResultCallbacks(NS_OK);
@@ -448,54 +449,55 @@ ServiceWorkerUpdateJob::Install()
     (this, &ServiceWorkerUpdateJob::ContinueAfterInstallEvent, false);
 
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
     new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
 
   // Send the install event to the worker thread
   ServiceWorkerPrivate* workerPrivate =
-    mRegistration->mInstallingWorker->WorkerPrivate();
+    mRegistration->GetInstalling()->WorkerPrivate();
   nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("install"),
                                                   callback, failRunnable);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ContinueAfterInstallEvent(false /* aSuccess */);
   }
 }
 
 void
 ServiceWorkerUpdateJob::ContinueAfterInstallEvent(bool aInstallEventSuccess)
 {
   if (Canceled()) {
     return FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
   }
 
-  MOZ_ASSERT(mRegistration->mInstallingWorker);
+  MOZ_ASSERT(mRegistration->GetInstalling());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
   // Continue executing the Install algorithm at step 12.
 
   // "If installFailed is true"
   if (NS_WARN_IF(!aInstallEventSuccess)) {
     // The installing worker is cleaned up by FailUpdateJob().
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // "If registration's waiting worker is not null"
-  if (mRegistration->mWaitingWorker) {
-    mRegistration->mWaitingWorker->WorkerPrivate()->TerminateWorker();
-    mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
+  if (mRegistration->GetWaiting()) {
+    mRegistration->GetWaiting()->WorkerPrivate()->TerminateWorker();
+    mRegistration->GetWaiting()->UpdateState(ServiceWorkerState::Redundant);
     serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
-                                         mRegistration->mWaitingWorker->CacheName());
+                                         mRegistration->GetWaiting()->CacheName());
   }
 
-  mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
-  mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
+  mRegistration->SetWaiting(mRegistration->GetInstalling());
+  mRegistration->SetInstalling(nullptr);
+  mRegistration->GetWaiting()->UpdateState(ServiceWorkerState::Installed);
   mRegistration->NotifyListenersOnChange();
   swm->StoreRegistration(mPrincipal, mRegistration);
   swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                  WhichServiceWorker::INSTALLING_WORKER |
                                                  WhichServiceWorker::WAITING_WORKER);
 
   Finish(NS_OK);
 
