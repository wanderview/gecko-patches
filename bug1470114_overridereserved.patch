# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  261bb5fc1cdad6c702a424d87b2560778f8ef76e
Bug 1470114 Make parent-side of redirect override the reserved ClientInfo to handle some corner cases. r=valentin

diff --git a/ipc/glue/BackgroundUtils.cpp b/ipc/glue/BackgroundUtils.cpp
--- a/ipc/glue/BackgroundUtils.cpp
+++ b/ipc/glue/BackgroundUtils.cpp
@@ -710,17 +710,21 @@ MergeChildLoadInfoForwarder(const ChildL
   if (NS_WARN_IF(reservedClientInfo.isNothing() &&
                  initialClientInfo.isNothing() &&
                  (aLoadInfo->GetReservedClientInfo().isSome() ||
                   aLoadInfo->GetInitialClientInfo().isSome()))) {
     return NS_ERROR_FAILURE;
   }
 
   if (reservedClientInfo.isSome()) {
-    aLoadInfo->SetReservedClientInfo(reservedClientInfo.ref());
+    // We need to override here instead of simply set the value.  This
+    // allows us to change the reserved client.  This is necessary when
+    // the ClientChannelHelper created a new reserved client in the
+    // child-side of the redirect.
+    aLoadInfo->OverrideReservedClientInfoInParent(reservedClientInfo.ref());
   } else if (initialClientInfo.isSome()) {
     aLoadInfo->SetInitialClientInfo(initialClientInfo.ref());
   }
 
   aLoadInfo->ClearController();
   auto& controller = aForwarderArgs.controller();
   if (controller.type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     aLoadInfo->SetController(
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -1321,16 +1321,27 @@ LoadInfo::SetReservedClientInfo(const Cl
   // Treat assignments of the same value as a no-op.  The emplace below
   // will normally assert when overwriting an existing value.
   if (mReservedClientInfo.isSome() && mReservedClientInfo.ref() == aClientInfo) {
     return;
   }
   mReservedClientInfo.emplace(aClientInfo);
 }
 
+void
+LoadInfo::OverrideReservedClientInfoInParent(const ClientInfo& aClientInfo)
+{
+  // This should only be called to handle redirects in the parent process.
+  MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
+
+  mInitialClientInfo.reset();
+  mReservedClientInfo.reset();
+  mReservedClientInfo.emplace(aClientInfo);
+}
+
 const Maybe<ClientInfo>&
 LoadInfo::GetReservedClientInfo()
 {
   return mReservedClientInfo;
 }
 
 void
 LoadInfo::SetInitialClientInfo(const ClientInfo& aClientInfo)
diff --git a/netwerk/base/nsILoadInfo.idl b/netwerk/base/nsILoadInfo.idl
--- a/netwerk/base/nsILoadInfo.idl
+++ b/netwerk/base/nsILoadInfo.idl
@@ -925,16 +925,32 @@ interface nsILoadInfo : nsISupports
    * For example, web workers do not call give their ClientSource to
    * the nsILoadInfo, but must still call this method to indicate the
    * reserved client for their main script load.
    */
   [noscript, nostdcall, notxpcom]
   void SetReservedClientInfo(in const_ClientInfoRef aClientInfo);
 
   /**
+   * This will clear any existing reserved or initial client and override
+   * it with the given reserved client.  This is similar to calling
+   * TakeReservedClientSource() and then GiveReservedClientSource() with
+   * a new client as ClientChannelHelper does.  This method is needed,
+   * though, to perform this operation in the parent process where
+   * the LoadInfo does not have direct access to a ClientSource.
+   *
+   * If in doubt, do not call this method.  Its really only needed for
+   * a specific redirect case where the child has created a new client on
+   * redirect and we need to override the parent side's reserved client
+   * to match.
+   */
+  [noscript, nostdcall, notxpcom]
+  void OverrideReservedClientInfoInParent(in const_ClientInfoRef aClientInfo);
+
+  /**
    * Return the reserved ClientInfo for this load, if one has been set.
    */
   [noscript, nostdcall, notxpcom]
   const_MaybeClientInfoRef GetReservedClientInfo();
 
   /**
    * Note that this non-subresource network request will result in
    * re-using an existing "initial" active client.  This mainly only
