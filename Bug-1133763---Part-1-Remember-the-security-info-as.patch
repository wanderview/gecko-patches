# HG changeset patch
# User Ehsan Akhgari <ehsan@mozilla.com>

Bug 1133763 - Part 1: Remember the security info associated with HTTP fetches and record it inside InternalResponse; r=nsm

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
index 4e7f142..d669b5f 100644
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -640,16 +640,22 @@ FetchDriver::OnStartRequest(nsIRequest* aRequest,
   nsRefPtr<FillResponseHeaders> visitor = new FillResponseHeaders(response);
   rv = channel->VisitResponseHeaders(visitor);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     NS_WARNING("Failed to visit all headers.");
   }
 
   mResponse = BeginAndGetFilteredResponse(response);
 
+  nsCOMPtr<nsISupports> securityInfo;
+  rv = channel->GetSecurityInfo(getter_AddRefs(securityInfo));
+  if (securityInfo) {
+    mResponse->SetSecurityInfo(securityInfo);
+  }
+
   // We open a pipe so that we can immediately set the pipe's read end as the
   // response's body. Setting the segment size to UINT32_MAX means that the
   // pipe has infinite space. The nsIChannel will continue to buffer data in
   // xpcom events even if we block on a fixed size pipe.  It might be possible
   // to suspend the channel and then resume when there is space available, but
   // for now use an infinite pipe to avoid blocking.
   nsCOMPtr<nsIInputStream> pipeInputStream;
   rv = NS_NewPipe(getter_AddRefs(pipeInputStream),
diff --git a/dom/fetch/InternalResponse.cpp b/dom/fetch/InternalResponse.cpp
index 1441501..ca30d99 100644
--- a/dom/fetch/InternalResponse.cpp
+++ b/dom/fetch/InternalResponse.cpp
@@ -4,16 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InternalResponse.h"
 
 #include "nsIDOMFile.h"
 
 #include "mozilla/dom/InternalHeaders.h"
 #include "nsStreamUtils.h"
+#include "nsSerializationHelper.h"
 
 namespace mozilla {
 namespace dom {
 
 InternalResponse::InternalResponse(uint16_t aStatus, const nsACString& aStatusText)
   : mType(ResponseType::Default)
   , mFinalURL(false)
   , mStatus(aStatus)
@@ -79,10 +80,29 @@ InternalResponse::CORSResponse(InternalResponse* aInner)
   MOZ_ASSERT(aInner);
   nsRefPtr<InternalResponse> cors = new InternalResponse(*aInner);
   cors->mType = ResponseType::Cors;
   cors->mHeaders = InternalHeaders::CORSHeaders(aInner->mHeaders);
   cors->mBody.swap(aInner->mBody);
   return cors.forget();
 }
 
+void
+InternalResponse::SetSecurityInfo(nsISupports* aSecurityInfo)
+{
+  MOZ_ASSERT(mSecurityInfo.IsEmpty(), "security info should only be set once");
+  nsCOMPtr<nsISerializable> serializable = do_QueryInterface(aSecurityInfo);
+  if (!serializable) {
+    NS_WARNING("A non-serializable object was passed to InternalResponse::SetSecurityInfo");
+    return;
+  }
+  NS_SerializeToString(serializable, mSecurityInfo);
+}
+
+void
+InternalResponse::SetSecurityInfo(const nsCString& aSecurityInfo)
+{
+  MOZ_ASSERT(mSecurityInfo.IsEmpty(), "security info should only be set once");
+  mSecurityInfo = aSecurityInfo;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/InternalResponse.h b/dom/fetch/InternalResponse.h
index 3d47394..8cc78b0 100644
--- a/dom/fetch/InternalResponse.h
+++ b/dom/fetch/InternalResponse.h
@@ -118,16 +118,28 @@ public:
   void
   SetBody(nsIInputStream* aBody)
   {
     // A request's body may not be reset once set.
     MOZ_ASSERT(!mBody);
     mBody = aBody;
   }
 
+  const nsCString&
+  GetSecurityInfo() const
+  {
+    return mSecurityInfo;
+  }
+
+  void
+  SetSecurityInfo(nsISupports* aSecurityInfo);
+
+  void
+  SetSecurityInfo(const nsCString& aSecurityInfo);
+
 private:
   ~InternalResponse()
   { }
 
   // Used to create filtered and cloned responses.
   // Does not copy headers or body stream.
   explicit InternalResponse(const InternalResponse& aOther);
 
@@ -135,14 +147,15 @@ private:
   nsCString mTerminationReason;
   nsCString mURL;
   bool mFinalURL;
   const uint16_t mStatus;
   const nsCString mStatusText;
   nsRefPtr<InternalHeaders> mHeaders;
   nsCOMPtr<nsIInputStream> mBody;
   nsCString mContentType;
+  nsCString mSecurityInfo;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_InternalResponse_h
diff --git a/netwerk/base/moz.build b/netwerk/base/moz.build
index 877365b..15890be 100644
--- a/netwerk/base/moz.build
+++ b/netwerk/base/moz.build
@@ -141,16 +141,17 @@ XPIDL_MODULE = 'necko'
 EXPORTS += [
     'netCore.h',
     'nsASocketHandler.h',
     'nsAsyncRedirectVerifyHelper.h',
     'nsFileStreams.h',
     'nsMIMEInputStream.h',
     'nsNetUtil.h',
     'nsReadLine.h',
+    'nsSerializationHelper.h',
     'nsStreamListenerWrapper.h',
     'nsTemporaryFileInputStream.h',
     'nsURIHashKey.h',
     'nsURLHelper.h',
     'nsURLParsers.h',
 ]
 
 EXPORTS.mozilla += [
