# HG changeset patch
# Parent  ee2e50b9beeccdc331055ee7f92e42ced6f89008

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Client.h"
 
 #include "mozilla/dom/ClientBinding.h"
 #include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "nsIGlobalObject.h"
 
 namespace mozilla {
 namespace dom {
@@ -34,17 +35,17 @@ Client::~Client()
 {
 }
 
 void
 Client::EnsureHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Client);
   if (!mHandle) {
-    mHandle = ClientManager::CreateHandle(mData.info());
+    mHandle = ClientManager::CreateHandle(mData->info());
   }
 }
 
 // TODO: unify this with code in Clients
 nsresult
 Client::GetEndPoint(ClientEndPoint& aEndPointOut)
 {
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
@@ -68,78 +69,78 @@ Client::GetEndPoint(ClientEndPoint& aEnd
     }
   }
 
   return NS_ERROR_DOM_INVALID_STATE_ERR;
 }
 
 Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
   : mGlobal(aGlobal)
-  , mData(aData)
+  , mData(new ClientInfoAndState(aData))
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
 }
 
 TimeStamp
 Client::CreationTime() const
 {
-  return mData.info().creationTime();
+  return mData->info().creationTime();
 }
 
 TimeStamp
 Client::LastFocusTime() const
 {
-  if (mData.info().type() != ClientType::Window) {
+  if (mData->info().type() != ClientType::Window) {
     return TimeStamp();
   }
-  return mData.state().get_ClientWindowState().lastFocusTime();
+  return mData->state().get_ClientWindowState().lastFocusTime();
 }
 
 JSObject*
 Client::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
-  if (mData.info().type() == ClientType::Window) {
+  if (mData->info().type() == ClientType::Window) {
     return WindowClientBinding::Wrap(aCx, this, aGivenProto);
   }
   return ClientBinding::Wrap(aCx, this, aGivenProto);
 }
 
 nsIGlobalObject*
 Client::GetParentObject() const
 {
   return mGlobal;
 }
 
 void
 Client::GetUrl(nsAString& aUrlOut) const
 {
-  CopyUTF8toUTF16(mData.info().url(), aUrlOut);
+  CopyUTF8toUTF16(mData->info().url(), aUrlOut);
 }
 
 void
 Client::GetId(nsAString& aIdOut) const
 {
   char buf[NSID_LENGTH];
-  mData.info().id().ToProvidedString(buf);
+  mData->info().id().ToProvidedString(buf);
   NS_ConvertASCIItoUTF16 uuid(buf);
 
   // Remove {} and the null terminator
   aIdOut.Assign(Substring(uuid, 1, NSID_LENGTH - 3));
 }
 
 ClientType
 Client::Type() const
 {
-  return mData.info().type();
+  return mData->info().type();
 }
 
 FrameType
 Client::GetFrameType() const
 {
-  return mData.info().frameType();
+  return mData->info().frameType();
 }
 
 void
 Client::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                     const Sequence<JSObject*>& aTransferable,
                     ErrorResult& aRv)
 {
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
@@ -163,23 +164,23 @@ Client::PostMessage(JSContext* aCx, JS::
 
   EnsureHandle();
   RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
 }
 
 VisibilityState
 Client::GetVisibilityState() const
 {
-  return mData.state().get_ClientWindowState().visibilityState();
+  return mData->state().get_ClientWindowState().visibilityState();
 }
 
 bool
 Client::Focused() const
 {
-  return mData.state().get_ClientWindowState().focused();
+  return mData->state().get_ClientWindowState().focused();
 }
 
 already_AddRefed<Promise>
 Client::Focus(ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
@@ -210,17 +211,17 @@ Client::Focus(ErrorResult& aRv)
   EnsureHandle();
 
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
-        new Client(self->mGlobal, ClientInfoAndState(self->mData.info(), aResult));
+        new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult));
       outerPromise->MaybeResolve(newClient);
     }, [self, outerPromise] (nsresult aResult) {
       outerPromise->MaybeReject(aResult);
     });
 
   return outerPromise.forget();
 }
 
@@ -244,17 +245,17 @@ Client::Navigate(const nsAString& aURL, 
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       baseURL = workerPrivate->GetLocationInfo().mHref;
     }
   }
 
   RefPtr<Client> self = this;
 
-  ClientNavigateArgs args(mData.info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+  ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
 
   RefPtr<ClientOpPromise> innerPromise = ClientManager::Navigate(args);
 
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
--- a/dom/clients/api/Client.h
+++ b/dom/clients/api/Client.h
@@ -1,38 +1,40 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_Client_h
 #define _mozilla_dom_Client_h
 
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientBinding.h"
 #include "nsCOMPtr.h"
 #include "nsISupports.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
+class ClientEndPoint;
 class ClientHandle;
+class ClientInfoAndState;
 class Promise;
 template <typename t> class Sequence;
 
 class Client final : public nsISupports
                    , public nsWrapperCache
 {
   nsCOMPtr<nsIGlobalObject> mGlobal;
-  const ClientInfoAndState mData;
+  UniquePtr<ClientInfoAndState> mData;
   RefPtr<ClientHandle> mHandle;
 
   ~Client();
 
   void
   EnsureHandle();
 
   nsresult
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -7,16 +7,20 @@
 #define _mozilla_dom_ClientHandle_h
 
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/MozPromise.h"
 #include "nsTArray.h"
 
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
 namespace mozilla {
 
 namespace dom {
 
 class ClientManager;
 class ClientHandleChild;
 class PClientManagerChild;
 class ServiceWorkerDescriptor;
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -7,16 +7,20 @@
 #define _mozilla_dom_ClientSource_h
 
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/Variant.h"
 #include "ClientOpPromise.h"
 
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class ClientManager;
 class ClientSourceChild;
 class ClientSourceExecutionReadyArgs;
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -8,17 +8,16 @@
 #define mozilla_dom_workers_serviceworkerevents_h__
 
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/ExtendableEventBinding.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Promise.h"
-#include "mozilla/dom/Response.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
 #include "mozilla/dom/workers/Workers.h"
 
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_workers_serviceworkerinfo_h
 #define mozilla_dom_workers_serviceworkerinfo_h
 
 #include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState
+#include "mozilla/dom/ServiceWorkerDescriptor.h" // For ServiceWorkerState
 #include "mozilla/dom/workers/Workers.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
 class ServiceWorker;
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -19,16 +19,17 @@
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/Client.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
@@ -1762,20 +1763,20 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   info.mResolvedScriptURI = info.mBaseURI;
   MOZ_ASSERT(!mInfo->CacheName().IsEmpty());
   info.mServiceWorkerCacheName = mInfo->CacheName();
 
   PrincipalInfo principalInfo;
   rv = PrincipalToPrincipalInfo(mInfo->Principal(), &principalInfo);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  info.mServiceWorkerDescriptor.emplace(ServiceWorkerDescriptor(mInfo->ID(),
-                                                                principalInfo,
-                                                                mInfo->Scope(),
-                                                                mInfo->State()));
+  info.mServiceWorkerDescriptor = MakeUnique<ServiceWorkerDescriptor>(mInfo->ID(),
+                                                                      principalInfo,
+                                                                      mInfo->Scope(),
+                                                                      mInfo->State());
 
   info.mLoadGroup = aLoadGroup;
   info.mLoadFailedAsyncRunnable = aLoadFailedRunnable;
 
   // If we are loading a script for a ServiceWorker then we must not
   // try to intercept it.  If the interception matches the current
   // ServiceWorker's scope then we could deadlock the load.
   info.mLoadFlags = mInfo->GetLoadFlags() |
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -63,16 +63,17 @@
 #include "mozilla/dom/nsCSPUtils.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/PMessagePort.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseDebugging.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/SimpleGlobalObject.h"
 #include "mozilla/dom/ScriptSettings.h"
+#include "mozilla/dom/ServiceWorkerBinding.h"
 #include "mozilla/dom/StructuredCloneHolder.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/WorkerBinding.h"
 #include "mozilla/dom/WorkerDebuggerGlobalScopeBinding.h"
 #include "mozilla/dom/WorkerGlobalScopeBinding.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/SizePrintfMacros.h"
 #include "mozilla/ThrottledEventQueue.h"
@@ -1808,17 +1809,17 @@ WorkerLoadInfo::StealFrom(WorkerLoadInfo
   aOther.mInterfaceRequestor.swap(mInterfaceRequestor);
 
   MOZ_ASSERT(!mPrincipalInfo);
   mPrincipalInfo = aOther.mPrincipalInfo.forget();
 
   mDomain = aOther.mDomain;
   mOrigin = aOther.mOrigin;
   mServiceWorkerCacheName = aOther.mServiceWorkerCacheName;
-  mServiceWorkerDescriptor = aOther.mServiceWorkerDescriptor;
+  mServiceWorkerDescriptor = Move(aOther.mServiceWorkerDescriptor);
   mLoadFlags = aOther.mLoadFlags;
   mWindowID = aOther.mWindowID;
   mReferrerPolicy = aOther.mReferrerPolicy;
   mFromWindow = aOther.mFromWindow;
   mEvalAllowed = aOther.mEvalAllowed;
   mReportCSPViolations = aOther.mReportCSPViolations;
   mXHRParamsAllowed = aOther.mXHRParamsAllowed;
   mPrincipalIsSystem = aOther.mPrincipalIsSystem;
@@ -7178,16 +7179,39 @@ EventTarget::IsOnCurrentThread(bool* aIs
   nsresult rv = mWorkerPrivate->IsOnCurrentThread(aIsOnCurrentThread);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
+template <class Derived>
+uint64_t
+WorkerPrivateParent<Derived>::ServiceWorkerID() const
+{
+  return GetServiceWorkerDescriptor().id();
+}
+
+template <class Derived>
+const nsCString&
+WorkerPrivateParent<Derived>::ServiceWorkerScope() const
+{
+  return GetServiceWorkerDescriptor().scope();
+}
+
+template <class Derived>
+void
+WorkerPrivateParent<Derived>::UpdateServiceWorkerState(ServiceWorkerState aState)
+{
+  MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+  MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor);
+  mLoadInfo.mServiceWorkerDescriptor->state() = aState;
+}
+
 BEGIN_WORKERS_NAMESPACE
 
 WorkerCrossThreadDispatcher*
 GetWorkerCrossThreadDispatcher(JSContext* aCx, const JS::Value& aWorker)
 {
   if (!aWorker.isObject()) {
     return nullptr;
   }
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -66,16 +66,17 @@ class ClientInfo;
 class ClientSource;
 class Function;
 class MessagePort;
 class MessagePortIdentifier;
 class PromiseNativeHandler;
 class StructuredCloneHolder;
 class WorkerDebuggerGlobalScope;
 class WorkerGlobalScope;
+enum class ServiceWorkerState : uint8_t;
 } // namespace dom
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
 } // namespace mozilla
 
 struct PRThread;
 
@@ -517,26 +518,20 @@ public:
 
   uint64_t
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
   uint64_t
-  ServiceWorkerID() const
-  {
-    return GetServiceWorkerDescriptor().id();
-  }
+  ServiceWorkerID() const;
 
   const nsCString&
-  ServiceWorkerScope() const
-  {
-    return GetServiceWorkerDescriptor().scope();
-  }
+  ServiceWorkerScope() const;
 
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
 
@@ -557,27 +552,22 @@ public:
     AssertIsOnMainThread();
     return mLoadInfo.mServiceWorkerCacheName;
   }
 
   const ServiceWorkerDescriptor&
   GetServiceWorkerDescriptor() const
   {
     MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
-    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
-    return mLoadInfo.mServiceWorkerDescriptor.ref();
+    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor);
+    return *mLoadInfo.mServiceWorkerDescriptor;
   }
 
   void
-  UpdateServiceWorkerState(ServiceWorkerState aState)
-  {
-    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
-    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
-    mLoadInfo.mServiceWorkerDescriptor.ref().state() = aState;
-  }
+  UpdateServiceWorkerState(ServiceWorkerState aState);
 
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mLoadInfo.mChannelInfo;
   }
 
   void
diff --git a/dom/workers/Workers.h b/dom/workers/Workers.h
--- a/dom/workers/Workers.h
+++ b/dom/workers/Workers.h
@@ -16,17 +16,16 @@
 #include "nsDebug.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 #include "nsILoadContext.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsIInterfaceRequestor.h"
 #include "mozilla/dom/ChannelInfo.h"
-#include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/net/ReferrerPolicy.h"
 
 #define BEGIN_WORKERS_NAMESPACE \
   namespace mozilla { namespace dom { namespace workers {
 #define END_WORKERS_NAMESPACE \
   } /* namespace workers */ } /* namespace dom */ } /* namespace mozilla */
 #define USING_WORKERS_NAMESPACE \
   using namespace mozilla::dom::workers;
@@ -54,16 +53,18 @@ namespace dom {
 // be updated too.
 enum WorkerType
 {
   WorkerTypeDedicated,
   WorkerTypeShared,
   WorkerTypeService
 };
 
+class ServiceWorkerDescriptor;
+
 } // namespace dom
 } // namespace mozilla
 
 BEGIN_WORKERS_NAMESPACE
 
 class WorkerPrivate;
 
 struct PrivatizableBase
@@ -253,17 +254,17 @@ struct WorkerLoadInfo
   // Only set if we have a custom overriden load group
   RefPtr<InterfaceRequestor> mInterfaceRequestor;
 
   nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
   nsCString mDomain;
   nsString mOrigin; // Derived from mPrincipal; can be used on worker thread.
 
   nsString mServiceWorkerCacheName;
-  Maybe<ServiceWorkerDescriptor> mServiceWorkerDescriptor;
+  UniquePtr<ServiceWorkerDescriptor> mServiceWorkerDescriptor;
 
   ChannelInfo mChannelInfo;
   nsLoadFlags mLoadFlags;
 
   uint64_t mWindowID;
 
   net::ReferrerPolicy mReferrerPolicy;
   bool mFromWindow;
