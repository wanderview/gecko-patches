# HG changeset patch
# Parent  b681bc44bffcdb763bfd87fe02fcbc7960af6b33

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -402,36 +402,35 @@ TimerThread::Run()
 
   size_t usIntervalResolution;
   BinarySearchIf(MicrosecondsToInterval(), 0, usForPosInterval, IntervalComparator(), &usIntervalResolution);
   MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution - 1) == 0);
   MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution) == 1);
 
   // Half of the amount of microseconds needed to get positive PRIntervalTime.
   // We use this to decide how to round our wait times later
-  TimeDuration halfIntervalResolution(
-    TimeDuration::FromMicroseconds(usIntervalResolution / 2));
+  int32_t halfMicrosecondsIntervalResolution = usIntervalResolution / 2;
   bool forceRunNextTimer = false;
 
   mEarlyFiringDuration = TimeDuration::FromMicroseconds(usIntervalResolution / 2);
 
   while (!mShutdown) {
-    TimeDuration waitFor(TimeDuration::Forever());
+    PRIntervalTime waitFor = PR_INTERVAL_NO_TIMEOUT;
     bool forceRunThisTimer = forceRunNextTimer;
     forceRunNextTimer = false;
 
     if (mSleeping) {
       // Sleep for 0.1 seconds while not firing timers.
       uint32_t milliseconds = 100;
       if (ChaosMode::isActive(ChaosFeature::TimerScheduling)) {
         milliseconds = ChaosMode::randomUint32LessThan(200);
       }
-      waitFor = TimeDuration::FromMilliseconds(milliseconds);
+      waitFor = PR_MillisecondsToInterval(milliseconds);
     } else {
-      waitFor = TimeDuration::Forever();
+      waitFor = PR_INTERVAL_NO_TIMEOUT;
       TimeStamp now = TimeStamp::Now();
 
       RemoveLeadingCanceledTimersInternal();
 
       if (!mTimers.IsEmpty()) {
         if (now >= mTimers[0]->Value()->mTimeout || forceRunThisTimer) {
     next:
           // NB: AddRef before the Release under RemoveTimerInternal to avoid
@@ -487,55 +486,50 @@ TimerThread::Run()
 
       if (!mTimers.IsEmpty()) {
         TimeStamp timeout = mTimers[0]->Value()->mTimeout;
 
         // Note that we can only sleep for integer values of a certain
         // resolution. We use halfIntervalResolution, calculated
         // before, to do the optimal rounding (i.e., of how to decide what
         // interval is so small we should not wait at all).
-        TimeDuration delay = timeout - now;
+        double microseconds = (timeout - now).ToMicroseconds();
 
         if (ChaosMode::isActive(ChaosFeature::TimerScheduling)) {
           // The mean value of sFractions must be 1 to ensure that
           // the average of a long sequence of timeouts converges to the
           // actual sum of their times.
           static const float sFractions[] = {
             0.0f, 0.25f, 0.5f, 0.75f, 1.0f, 1.75f, 2.75f
           };
-          delay = delay.MultDouble(
-            sFractions[ChaosMode::randomUint32LessThan(ArrayLength(sFractions))]);
+          microseconds *=
+            sFractions[ChaosMode::randomUint32LessThan(ArrayLength(sFractions))];
           forceRunNextTimer = true;
         }
 
         // If the delay is less than the actual measurable resolution on
         // this platform then fire the timer immediately.
-        if (delay < halfIntervalResolution) {
+        if (microseconds < halfMicrosecondsIntervalResolution) {
           forceRunNextTimer = false;
           goto next; // round down; execute event now
         }
 
-        if (delay != TimeDuration::Forever()) {
-          PRIntervalTime interval = PR_MicrosecondsToInterval(delay.ToMicroseconds());
-          if (interval < 1) {
-            interval = 1;
-          }
-          delay = TimeDuration::FromMicroseconds(PR_IntervalToMicroseconds(interval));
+        waitFor = PR_MicrosecondsToInterval(static_cast<uint32_t>(microseconds));
+        if (waitFor == 0) {
+          waitFor = 1;
         }
-
-        waitFor = delay;
       }
 
       if (MOZ_LOG_TEST(GetTimerLog(), LogLevel::Debug)) {
-        if (waitFor == TimeDuration::Forever())
+        if (waitFor == PR_INTERVAL_NO_TIMEOUT)
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
                  ("waiting for forever\n"));
         else
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
-                 ("waiting for %0.3f\n", waitFor.ToMilliseconds()));
+                 ("waiting for %u\n", PR_IntervalToMilliseconds(waitFor)));
       }
     }
 
     mWaiting = true;
     mNotified = false;
     mMonitor.Wait(waitFor);
     if (mNotified) {
       forceRunNextTimer = false;
