# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0c01f86d262ba4b5add52a826e607515c599dbd3

diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -31,26 +31,27 @@ NS_IMPL_CYCLE_COLLECTION_INHERITED(Servi
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorkerRegistration)
   NS_INTERFACE_MAP_ENTRY(ServiceWorkerRegistration)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 namespace {
-const uint64_t kNoInstallingWorkerId = 0;
+const uint64_t kInvalidUpdateFoundId = 0;
 } // anonymous namespace
 
 ServiceWorkerRegistration::ServiceWorkerRegistration(nsIGlobalObject* aGlobal,
                                                      const ServiceWorkerRegistrationDescriptor& aDescriptor,
                                                      ServiceWorkerRegistration::Inner* aInner)
   : DOMEventTargetHelper(aGlobal)
   , mDescriptor(aDescriptor)
   , mInner(aInner)
-  , mInstallingWorkerId(kNoInstallingWorkerId)
+  , mScheduledUpdateFoundId(kInvalidUpdateFoundId)
+  , mDispatchedUpdateFoundId(kInvalidUpdateFoundId)
 {
   MOZ_DIAGNOSTIC_ASSERT(mInner);
 
   KeepAliveIfHasListenersFor(NS_LITERAL_STRING("updatefound"));
 
   UpdateState(mDescriptor);
   mInner->SetServiceWorkerRegistration(this);
 }
@@ -336,49 +337,72 @@ ServiceWorkerRegistration::Descriptor() 
   return mDescriptor;
 }
 
 void
 ServiceWorkerRegistration::MaybeScheduleUpdateFound(const Maybe<ServiceWorkerDescriptor>& aInstallingDescriptor)
 {
   uint64_t newId = aInstallingDescriptor.isSome()
                  ? aInstallingDescriptor.ref().Id()
-                 : kNoInstallingWorkerId;
+                 : kInvalidUpdateFoundId;
 
-  bool updateFound = newId != kNoInstallingWorkerId &&
-                     mInstallingWorkerId != newId;
-  mInstallingWorkerId = newId;
+  if (mScheduledUpdateFoundId != kInvalidUpdateFoundId) {
+    if (mScheduledUpdateFoundId == newId) {
+      return;
+    }
+    MaybeDispatchUpdateFound();
+    MOZ_DIAGNOSTIC_ASSERT(mScheduledUpdateFoundId == kInvalidUpdateFoundId);
+  }
+
+  bool updateFound = newId != kInvalidUpdateFoundId &&
+                     mDispatchedUpdateFoundId != newId;
 
   if (!updateFound) {
     return;
   }
 
+  mScheduledUpdateFoundId = newId;
+
   nsIGlobalObject* global = GetParentObject();
   NS_ENSURE_TRUE_VOID(global);
 
   nsCOMPtr<nsIRunnable> r = NewCancelableRunnableMethod(
-    "ServiceWorkerRegistration::UpdateState",
+    "ServiceWorkerRegistration::MaybeDispatchUpdateFound",
     this,
-    &ServiceWorkerRegistration::DispatchUpdateFound);
+    &ServiceWorkerRegistration::MaybeDispatchUpdateFound);
 
   Unused << global->EventTargetFor(TaskCategory::Other)->Dispatch(
     r.forget(), NS_DISPATCH_NORMAL);
 }
 
 void
-ServiceWorkerRegistration::DispatchUpdateFound()
+ServiceWorkerRegistration::MaybeDispatchUpdateFound()
 {
+  uint64_t scheduledId = mScheduledUpdateFoundId;
+  mScheduledUpdateFoundId = kInvalidUpdateFoundId;
+
+  if (scheduledId == kInvalidUpdateFoundId ||
+      scheduledId == mDispatchedUpdateFoundId) {
+    return;
+  }
+
+  mDispatchedUpdateFoundId = scheduledId;
   DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
 }
 
 void
 ServiceWorkerRegistration::UpdateStateInternal(const Maybe<ServiceWorkerDescriptor>& aInstalling,
                                                const Maybe<ServiceWorkerDescriptor>& aWaiting,
                                                const Maybe<ServiceWorkerDescriptor>& aActive)
 {
+  // Do this immediately as it may flush an already pending updatefound
+  // event.  In that case we want to fire the pending event before
+  // modifying any of the registration properties.
+  MaybeScheduleUpdateFound(aInstalling);
+
   // Move the currently exposed workers into a separate list
   // of "old" workers.  We will then potentially add them
   // back to the registration properties below based on the
   // given descriptor.  Any that are not restored will need
   // to be moved to the redundant state.
   AutoTArray<RefPtr<ServiceWorker>, 3> oldWorkerList;
   oldWorkerList.AppendElement(mInstallingWorker.forget());
   oldWorkerList.AppendElement(mWaitingWorker.forget());
@@ -421,18 +445,16 @@ ServiceWorkerRegistration::UpdateStateIn
       if (!oldWorker) {
         continue;
       }
 
       oldWorker->MaybeDispatchStateChangeEvent();
     }
   });
 
-  MaybeScheduleUpdateFound(mDescriptor.GetInstalling());
-
   // Clear all workers if the registration has been detached from the global.
   // Also, we cannot expose ServiceWorker objects on worker threads yet, so
   // do the same on when off-main-thread.  This main thread check should be
   // removed as part of bug 1113522.
   nsCOMPtr<nsIGlobalObject> global = GetParentObject();
   if (!global || !NS_IsMainThread()) {
     return;
   }
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -130,27 +130,28 @@ private:
   UpdateStateInternal(const Maybe<ServiceWorkerDescriptor>& aInstalling,
                       const Maybe<ServiceWorkerDescriptor>& aWaiting,
                       const Maybe<ServiceWorkerDescriptor>& aActive);
 
   void
   MaybeScheduleUpdateFound(const Maybe<ServiceWorkerDescriptor>& aInstallingDescriptor);
 
   void
-  DispatchUpdateFound();
+  MaybeDispatchUpdateFound();
 
   ServiceWorkerRegistrationDescriptor mDescriptor;
   RefPtr<Inner> mInner;
 
   RefPtr<ServiceWorker> mInstallingWorker;
   RefPtr<ServiceWorker> mWaitingWorker;
   RefPtr<ServiceWorker> mActiveWorker;
   RefPtr<PushManager> mPushManager;
 
-  uint64_t mInstallingWorkerId;
+  uint64_t mScheduledUpdateFoundId;
+  uint64_t mDispatchedUpdateFoundId;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ServiceWorkerRegistration, NS_DOM_SERVICEWORKERREGISTRATION_IID)
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_ServiceWorkerRegistration_h */
