# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  702b7c4d3ffb50ed9f954f388f5279093b5f54e9
Bug 1436812 P4 Add the ServiceWorkerContainer::GetBaseURIFromGlobal() method. r=baku

diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -104,16 +104,47 @@ ServiceWorkerContainer::ControllerChange
 }
 
 JSObject*
 ServiceWorkerContainer::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return ServiceWorkerContainerBinding::Wrap(aCx, this, aGivenProto);
 }
 
+namespace {
+
+already_AddRefed<nsIURI>
+GetBaseURIFromGlobal(nsIGlobalObject* aGlobal, ErrorResult& aRv)
+{
+  // It would be nice not to require a window here, but right
+  // now we don't have a great way to get the base URL just
+  // from the nsIGlobalObject.
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  if (!window) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  nsIDocument* doc = window->GetExtantDoc();
+  if (!doc) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  nsCOMPtr<nsIURI> baseURI = doc->GetDocBaseURI();
+  if (!baseURI) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  return baseURI.forget();
+}
+
+} // anonymous namespace
+
 static nsresult
 CheckForSlashEscapedCharsInPath(nsIURI* aURI)
 {
   MOZ_ASSERT(aURI);
 
   // A URL that can't be downcast to a standard URL is an invalid URL and should
   // be treated as such and fail with SecurityError.
   nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
@@ -287,64 +318,48 @@ ServiceWorkerContainer::GetRegistration(
                                     NS_LITERAL_CSTRING("Service Workers"), aDoc,
                                     nsContentUtils::eDOM_PROPERTIES,
                                     "ServiceWorkerGetRegistrationStorageError");
   });
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(global);
-  if (!window) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  // It would be nice not to require a window here, but right
-  // now we don't have a great way to get the base URL just
-  // from the nsIGlobalObject.
-  Maybe<ClientInfo> clientInfo = window->GetClientInfo();
+  Maybe<ClientInfo> clientInfo = global->GetClientInfo();
   if (clientInfo.isNothing()) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  nsIDocument* doc = window->GetExtantDoc();
-  if (!doc) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return nullptr;
-  }
-
-  nsCOMPtr<nsIURI> baseURI = doc->GetDocBaseURI();
-  if (!baseURI) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+  nsCOMPtr<nsIURI> baseURI = GetBaseURIFromGlobal(global, aRv);
+  if (aRv.Failed()) {
     return nullptr;
   }
 
   nsCOMPtr<nsIURI> uri;
   aRv = NS_NewURI(getter_AddRefs(uri), aURL, nullptr, baseURI);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   nsCString spec;
   aRv = uri->GetSpec(spec);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  RefPtr<Promise> outer = Promise::Create(window->AsGlobal(), aRv);
+  RefPtr<Promise> outer = Promise::Create(global, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   RefPtr<ServiceWorkerContainer> self = this;
 
   mInner->GetRegistration(clientInfo.ref(), spec)->Then(
-    window->EventTargetFor(TaskCategory::Other), __func__,
+    global->EventTargetFor(TaskCategory::Other), __func__,
     [self, outer] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
       ErrorResult rv;
       nsIGlobalObject* global = self->GetGlobalIfValid(rv);
       if (rv.Failed()) {
         outer->MaybeReject(rv);
         return;
       }
       RefPtr<ServiceWorkerRegistration> reg =
