# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0e0b84ea5cf2d8307110dffa79794e4aabde9d59
Bug 1425965 P4 Remove mControlledDocument, mRegisteringDocuments, and mNavigationIntercepts from ServiceWorkerManager. r=asuth

diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -5054,34 +5054,29 @@ nsDocument::SetScriptGlobalObject(nsIScr
     // Also make sure to remove our onload blocker now if we haven't done it yet
     if (mOnloadBlockCount != 0) {
       nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
       if (loadGroup) {
         loadGroup->RemoveRequest(mOnloadBlocker, nullptr, NS_OK);
       }
     }
 
-    using mozilla::dom::workers::ServiceWorkerManager;
-    RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    if (swm) {
-      ErrorResult error;
-      if (GetController().isSome()) {
-        imgLoader* loader = nsContentUtils::GetImgLoaderForDocument(this);
-        if (loader) {
-          loader->ClearCacheForControlledDocument(this);
-        }
-
-        // We may become controlled again if this document comes back out
-        // of bfcache.  Clear our state to allow that to happen.  Only
-        // clear this flag if we are actually controlled, though, so pages
-        // that were force reloaded don't become controlled when they
-        // come out of bfcache.
-        mMaybeServiceWorkerControlled = false;
-      }
-      swm->MaybeStopControlling(this);
+    ErrorResult error;
+    if (GetController().isSome()) {
+      imgLoader* loader = nsContentUtils::GetImgLoaderForDocument(this);
+      if (loader) {
+        loader->ClearCacheForControlledDocument(this);
+      }
+
+      // We may become controlled again if this document comes back out
+      // of bfcache.  Clear our state to allow that to happen.  Only
+      // clear this flag if we are actually controlled, though, so pages
+      // that were force reloaded don't become controlled when they
+      // come out of bfcache.
+      mMaybeServiceWorkerControlled = false;
     }
   }
 
   // BlockOnload() might be called before mScriptGlobalObject is set.
   // We may need to add the blocker once mScriptGlobalObject is set.
   bool needOnloadBlocker = !mScriptGlobalObject && aScriptGlobalObject;
 
   mScriptGlobalObject = aScriptGlobalObject;
@@ -5191,21 +5186,17 @@ nsDocument::SetScriptGlobalObject(nsIScr
     docShell->GetLoadType(&loadType);
 
     // If we are shift-reloaded, don't associate with a ServiceWorker.
     if (IsForceReloadType(loadType)) {
       NS_WARNING("Page was shift reloaded, skipping ServiceWorker control");
       return;
     }
 
-    nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
-    if (swm) {
-      swm->MaybeStartControlling(this);
-      mMaybeServiceWorkerControlled = true;
-    }
+    mMaybeServiceWorkerControlled = true;
   }
 }
 
 nsIScriptGlobalObject*
 nsDocument::GetScriptHandlingObjectInternal() const
 {
   MOZ_ASSERT(!mScriptGlobalObject,
              "Do not call this when mScriptGlobalObject is set!");
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -148,34 +148,19 @@ interface nsIServiceWorkerManager : nsIS
   nsISupports getReadyPromise(in mozIDOMWindow aWindow);
 
   // Remove ready pending Promise
   void removeReadyPromise(in mozIDOMWindow aWindow);
 
   nsIServiceWorkerRegistrationInfo getRegistrationByPrincipal(in nsIPrincipal aPrincipal,
                                                               in DOMString aScope);
 
-  /**
-   * Call this to request that document `aDoc` be controlled by a ServiceWorker
-   * if a registration exists for it's scope.
-   *
-   * This MUST only be called once per document!
-   */
-  [notxpcom,nostdcall] void MaybeStartControlling(in nsIDocument aDoc);
-
   [notxpcom, nostdcall] bool StartControlling(in const_ClientInfoRef aClientInfo,
                                               in const_ServiceWorkerDescriptorRef aServiceWorker);
 
-  /**
-   * Documents that have called MaybeStartControlling() should call this when
-   * they are destroyed. This function may be called multiple times, and is
-   * idempotent.
-   */
-  [notxpcom,nostdcall] void MaybeStopControlling(in nsIDocument aDoc);
-
   /*
    * Returns a ServiceWorker.
    * window is the window of the caller. scope is the registration's scope and must be
    * a valid entry that window is allowed to load, otherwise this will return nullptr.
    * These are only meant to be called from ServiceWorkerRegistration instances.
    */
   [noscript] nsISupports GetInstalling(in nsPIDOMWindowInner aWindow, in DOMString aScope);
   [noscript] nsISupports GetWaiting(in nsPIDOMWindowInner aWindow, in DOMString aScope);
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -905,17 +905,16 @@ ServiceWorkerManager::Register(mozIDOMWi
 
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(documentPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   window->NoteCalledRegisterForServiceWorkerScope(cleanedScope);
-  AddRegisteringDocument(cleanedScope, doc);
 
   RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey,
                                                             cleanedScope);
 
   RefPtr<ServiceWorkerResolveWindowPromiseOnRegisterCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnRegisterCallback(window, promise);
 
   nsCOMPtr<nsILoadGroup> docLoadGroup = doc->GetDocumentLoadGroup();
@@ -2130,28 +2129,16 @@ ServiceWorkerManager::RemoveScopeAndRegi
         reg->mPrincipal->Equals(aRegistration->mPrincipal)) {
       MOZ_DIAGNOSTIC_ASSERT(false,
                             "controlled client when removing registration");
       iter.Remove();
       break;
     }
   }
 
-  // Registration lifecycle is managed via mControlledClients now.  Do not
-  // assert on on mControlledDocuments as races may cause this to still be
-  // set when the registration is destroyed.
-  for (auto iter = swm->mControlledDocuments.Iter(); !iter.Done(); iter.Next()) {
-    ServiceWorkerRegistrationInfo* reg = iter.UserData();
-    if (reg->mScope.Equals(aRegistration->mScope) &&
-        reg->mPrincipal->Equals(aRegistration->mPrincipal)) {
-      iter.Remove();
-      break;
-    }
-  }
-
   RefPtr<ServiceWorkerRegistrationInfo> info;
   data->mInfos.Remove(aRegistration->mScope, getter_AddRefs(info));
   data->mOrderedScopes.RemoveElement(aRegistration->mScope);
   swm->NotifyListenersOnUnregister(info);
 
   swm->MaybeRemoveRegistrationInfo(scopeKey);
   swm->NotifyServiceWorkerRegistrationRemoved(aRegistration);
 }
@@ -2162,30 +2149,16 @@ ServiceWorkerManager::MaybeRemoveRegistr
   if (auto entry = mRegistrationInfos.Lookup(aScopeKey)) {
     if (entry.Data()->mOrderedScopes.IsEmpty() &&
         entry.Data()->mJobQueues.Count() == 0) {
       entry.Remove();
     }
   }
 }
 
-void
-ServiceWorkerManager::MaybeStartControlling(nsIDocument* aDoc)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDoc);
-  RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(aDoc);
-  if (registration && registration->GetActive() &&
-      aDoc->GetSandboxFlags() == 0) {
-    MOZ_ASSERT(!mControlledDocuments.Contains(aDoc));
-    StartControllingADocument(registration, aDoc);
-  }
-}
-
 bool
 ServiceWorkerManager::StartControlling(const ClientInfo& aClientInfo,
                                        const ServiceWorkerDescriptor& aServiceWorker)
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIPrincipal> principal =
     PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
@@ -2201,24 +2174,16 @@ ServiceWorkerManager::StartControlling(c
   NS_ENSURE_TRUE(registration, false);
 
   StartControllingClient(aClientInfo, registration);
 
   return true;
 }
 
 void
-ServiceWorkerManager::MaybeStopControlling(nsIDocument* aDoc)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aDoc);
-  mControlledDocuments.Remove(aDoc);
-}
-
-void
 ServiceWorkerManager::MaybeCheckNavigationUpdate(const ClientInfo& aClientInfo)
 {
   AssertIsOnMainThread();
   // We perform these success path navigation update steps when the
   // document tells us its more or less done loading.  This avoids
   // slowing down page load and also lets pages consistently get
   // updatefound events when they fire.
   //
@@ -2228,26 +2193,16 @@ ServiceWorkerManager::MaybeCheckNavigati
   //    algorithm.
   ControlledClientData* data = mControlledClients.Get(aClientInfo.Id());
   if (data && data->mRegistrationInfo) {
     data->mRegistrationInfo->MaybeScheduleUpdate();
   }
 }
 
 void
-ServiceWorkerManager::StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
-                                                nsIDocument* aDoc)
-{
-  MOZ_ASSERT(aRegistration);
-  MOZ_ASSERT(aDoc);
-
-  mControlledDocuments.Put(aDoc, aRegistration);
-}
-
-void
 ServiceWorkerManager::StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   aRegistration->StopControllingClient();
   if (aRegistration->IsControllingClients() || !aRegistration->IsIdle()) {
     return;
   }
 
   if (aRegistration->mPendingUninstall) {
@@ -2580,18 +2535,16 @@ ServiceWorkerManager::DispatchFetchEvent
       }
 
       // But we also note the reserved state on the LoadInfo.  This allows the
       // ClientSource to be updated immediately after the nsIChannel starts.
       // This is necessary to have the correct controller in place for immediate
       // follow-on requests.
       loadInfo->SetController(serviceWorker->Descriptor());
     }
-
-    AddNavigationInterception(serviceWorker->Scope(), aChannel);
   }
 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_DIAGNOSTIC_ASSERT(serviceWorker);
 
@@ -3042,17 +2995,16 @@ ServiceWorkerManager::MaybeClaimClient(n
                         getter_AddRefs(controllingRegistration));
 
   if (aWorkerRegistration != matchingRegistration ||
       aWorkerRegistration == controllingRegistration) {
     ref = GenericPromise::CreateAndResolve(true, __func__);
     return ref.forget();
   }
 
-  StartControllingADocument(aWorkerRegistration, aDocument);
   ref = StartControllingClient(clientInfo.ref(), aWorkerRegistration);
   return ref.forget();
 }
 
 already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
                                        const ServiceWorkerDescriptor& aServiceWorker)
 {
@@ -3558,112 +3510,16 @@ ServiceWorkerManager::NotifyListenersOnU
                                         nsIServiceWorkerRegistrationInfo* aInfo)
 {
   nsTArray<nsCOMPtr<nsIServiceWorkerManagerListener>> listeners(mListeners);
   for (size_t index = 0; index < listeners.Length(); ++index) {
     listeners[index]->OnUnregister(aInfo);
   }
 }
 
-void
-ServiceWorkerManager::AddRegisteringDocument(const nsACString& aScope,
-                                             nsIDocument* aDoc)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(!aScope.IsEmpty());
-  MOZ_ASSERT(aDoc);
-
-  WeakDocumentList* list = mRegisteringDocuments.LookupOrAdd(aScope);
-  MOZ_ASSERT(list);
-
-  for (int32_t i = list->Length() - 1; i >= 0; --i) {
-    nsCOMPtr<nsIDocument> existing = do_QueryReferent(list->ElementAt(i));
-    if (!existing) {
-      list->RemoveElementAt(i);
-      continue;
-    }
-    if (existing == aDoc) {
-      return;
-    }
-  }
-
-  list->AppendElement(do_GetWeakReference(aDoc));
-}
-
-class ServiceWorkerManager::InterceptionReleaseHandle final : public nsISupports
-{
-  const nsCString mScope;
-
-  // Weak reference to channel is safe, because the channel holds a
-  // reference to this object.  Also, the pointer is only used for
-  // comparison purposes.
-  nsIInterceptedChannel* mChannel;
-
-  ~InterceptionReleaseHandle()
-  {
-    RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    if (swm) {
-      swm->RemoveNavigationInterception(mScope, mChannel);
-    }
-  }
-
-public:
-  InterceptionReleaseHandle(const nsACString& aScope,
-                            nsIInterceptedChannel* aChannel)
-    : mScope(aScope)
-    , mChannel(aChannel)
-  {
-    AssertIsOnMainThread();
-    MOZ_ASSERT(!aScope.IsEmpty());
-    MOZ_ASSERT(mChannel);
-  }
-
-  NS_DECL_ISUPPORTS
-};
-
-NS_IMPL_ISUPPORTS0(ServiceWorkerManager::InterceptionReleaseHandle);
-
-void
-ServiceWorkerManager::AddNavigationInterception(const nsACString& aScope,
-                                                nsIInterceptedChannel* aChannel)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(!aScope.IsEmpty());
-  MOZ_ASSERT(aChannel);
-
-  InterceptionList* list =
-    mNavigationInterceptions.LookupOrAdd(aScope);
-  MOZ_ASSERT(list);
-  MOZ_ASSERT(!list->Contains(aChannel));
-
-  nsCOMPtr<nsISupports> releaseHandle =
-    new InterceptionReleaseHandle(aScope, aChannel);
-  aChannel->SetReleaseHandle(releaseHandle);
-
-  list->AppendElement(aChannel);
-}
-
-void
-ServiceWorkerManager::RemoveNavigationInterception(const nsACString& aScope,
-                                                   nsIInterceptedChannel* aChannel)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aChannel);
-  InterceptionList* list =
-    mNavigationInterceptions.Get(aScope);
-  if (list) {
-    MOZ_ALWAYS_TRUE(list->RemoveElement(aChannel));
-    MOZ_ASSERT(!list->Contains(aChannel));
-    if (list->IsEmpty()) {
-      list = nullptr;
-      mNavigationInterceptions.Remove(aScope);
-    }
-  }
-}
-
 class UpdateTimerCallback final : public nsITimerCallback
                                 , public nsINamed
 {
   nsCOMPtr<nsIPrincipal> mPrincipal;
   const nsCString mScope;
 
   ~UpdateTimerCallback()
   {
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -99,50 +99,31 @@ public:
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIOBSERVER
 
   struct RegistrationDataPerPrincipal;
   nsClassHashtable<nsCStringHashKey, RegistrationDataPerPrincipal> mRegistrationInfos;
 
   nsTObserverArray<ServiceWorkerRegistrationListener*> mServiceWorkerRegistrationListeners;
 
-  nsRefPtrHashtable<nsISupportsHashKey, ServiceWorkerRegistrationInfo> mControlledDocuments;
-
   struct ControlledClientData
   {
     RefPtr<ClientHandle> mClientHandle;
     RefPtr<ServiceWorkerRegistrationInfo> mRegistrationInfo;
 
     ControlledClientData(ClientHandle* aClientHandle,
                          ServiceWorkerRegistrationInfo* aRegistrationInfo)
       : mClientHandle(aClientHandle)
       , mRegistrationInfo(aRegistrationInfo)
     {
     }
   };
 
   nsClassHashtable<nsIDHashKey, ControlledClientData> mControlledClients;
 
-  // Track all documents that have attempted to register a service worker for a
-  // given scope.
-  typedef nsTArray<nsCOMPtr<nsIWeakReference>> WeakDocumentList;
-  nsClassHashtable<nsCStringHashKey, WeakDocumentList> mRegisteringDocuments;
-
-  // Track all intercepted navigation channels for a given scope.  Channels are
-  // placed in the appropriate list before dispatch the FetchEvent to the worker
-  // thread and removed once FetchEvent processing dispatches back to the main
-  // thread.
-  //
-  // Note: Its safe to use weak references here because a RAII-style callback
-  //       is registered with the channel before its added to this list.  We
-  //       are guaranteed the callback will fire before and remove the ref
-  //       from this list before the channel is destroyed.
-  typedef nsTArray<nsIInterceptedChannel*> InterceptionList;
-  nsClassHashtable<nsCStringHashKey, InterceptionList> mNavigationInterceptions;
-
   bool
   IsAvailable(nsIPrincipal* aPrincipal, nsIURI* aURI);
 
   // Return true if the given content process could potentially be executing
   // service worker code with the given principal.  At the current time, this
   // just means that we have any registration for the origin, regardless of
   // scope.  This is a very weak guarantee but is the best we can do when push
   // notifications can currently spin up a service worker in content processes
@@ -394,20 +375,16 @@ private:
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
   NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
-                            nsIDocument* aDoc);
-
-  void
   StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
 
@@ -484,29 +461,16 @@ private:
 
   void
   NotifyListenersOnRegister(nsIServiceWorkerRegistrationInfo* aRegistration);
 
   void
   NotifyListenersOnUnregister(nsIServiceWorkerRegistrationInfo* aRegistration);
 
   void
-  AddRegisteringDocument(const nsACString& aScope, nsIDocument* aDoc);
-
-  class InterceptionReleaseHandle;
-
-  void
-  AddNavigationInterception(const nsACString& aScope,
-                            nsIInterceptedChannel* aChannel);
-
-  void
-  RemoveNavigationInterception(const nsACString& aScope,
-                               nsIInterceptedChannel* aChannel);
-
-  void
   ScheduleUpdateTimer(nsIPrincipal* aPrincipal, const nsACString& aScope);
 
   void
   UpdateTimerFired(nsIPrincipal* aPrincipal, const nsACString& aScope);
 
   void
   MaybeSendUnregister(nsIPrincipal* aPrincipal, const nsACString& aScope);
 
