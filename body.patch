# HG changeset patch
# Parent 291bfc0aaad05892bd5ac124f847b49da9afd622
# User Ben Kelly <ben@wanderview.com>
Implement cache body reading and writing.

diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -4,16 +4,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
+// TODO: remove testing only headers
+#include "nsStringStream.h"
+
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 
 CacheParent::CacheParent(const nsACString& aOrigin,
@@ -72,17 +75,36 @@ CacheParent::RecvAddAll(const RequestId&
   return false;
 }
 
 bool
 CacheParent::RecvPut(const RequestId& aRequestId, const PCacheRequest& aRequest,
                      const PCacheResponse& aResponse)
 {
   MOZ_ASSERT(mManager);
-  mManager->CachePut(this, aRequestId, mCacheId, aRequest, aResponse);
+
+  // TODO: remove stream test code
+  nsCOMPtr<nsIInputStream> requestStream;
+  nsresult rv = NS_NewCStringInputStream(getter_AddRefs(requestStream),
+                NS_LITERAL_CSTRING("request body stream beep beep boop!"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    OnCachePut(aRequestId, rv, PCacheResponseOrVoid(void_t()));
+    return true;
+  }
+
+  nsCOMPtr<nsIInputStream> responseStream;
+  rv = NS_NewCStringInputStream(getter_AddRefs(responseStream),
+                NS_LITERAL_CSTRING("response body stream hooray!"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    OnCachePut(aRequestId, rv, PCacheResponseOrVoid(void_t()));
+    return true;
+  }
+
+  mManager->CachePut(this, aRequestId, mCacheId,
+                     aRequest, requestStream, aResponse, responseStream);
   return true;
 }
 
 bool
 CacheParent::RecvDelete(const RequestId& aRequestId,
                         const PCacheRequest& aRequest,
                         const PCacheQueryParams& aParams)
 {
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -43,16 +43,17 @@ DBAction::RunOnTarget(Resolver* aResolve
 
   nsCOMPtr<mozIStorageConnection> conn;
   rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
   MOZ_ASSERT(conn);
+
   RunWithDBOnTarget(aResolver, aQuotaDir, conn);
 }
 
 nsresult
 DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
 {
   MOZ_ASSERT(aDBDir);
   MOZ_ASSERT(aConnOut);
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -24,16 +24,19 @@ protected:
   {
     Existing,
     Create
   };
 
   DBAction(Mode aMode, const nsACString& aOrigin,
            const nsACString& aBaseDomain);
 
+  // Just as the resolver must be ref'd until cancel or resolve, you may also
+  // ref the DB connection.  The connection can only be referenced from the
+  // target thread and must be released upon cancel or resolve.
   virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
                                  mozIStorageConnection* aConn)=0;
 
   virtual
   void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
 
   virtual ~DBAction() { }
 
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.cpp
@@ -0,0 +1,210 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FileUtils.h"
+#include "mozilla/dom/quota/FileStreams.h"
+#include "nsIFile.h"
+#include "nsIUUIDGenerator.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::FileOutputStream;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+
+// static
+nsresult
+FileUtils::BodyCreateDir(nsIFile* aBaseDir)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> aBodyDir;
+  nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aBodyDir->Append(NS_LITERAL_STRING("body"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = aBodyDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = aBodyDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    bool isDir;
+    rv = aBodyDir->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+                        nsIFile** aBodyFileOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aBodyFileOut);
+
+  nsresult rv = aBaseDir->Clone(aBodyFileOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = (*aBodyFileOut)->Append(NS_LITERAL_STRING("body"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = (*aBodyFileOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  bool isDir;
+  rv = (*aBodyFileOut)->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  char idString[NSID_LENGTH];
+  aId.ToProvidedString(idString);
+
+  NS_ConvertUTF8toUTF16 fileName(idString);
+
+  if (aType == BODY_FILE_FINAL) {
+    fileName.Append(NS_LITERAL_STRING(".final"));
+  } else {
+    fileName.Append(NS_LITERAL_STRING(".tmp"));
+  }
+
+  rv = (*aBodyFileOut)->Append(fileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyStartWriteStream(const nsACString& aOrigin,
+                                const nsACString& aBaseDomain,
+                                nsIFile* aBaseDir, nsIInputStream* aSource,
+                                void* aClosure,
+                                nsAsyncCopyCallbackFun aCallback,
+                                nsID* aIdOut, nsISupports** aCopyContextOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aClosure);
+  MOZ_ASSERT(aCallback);
+  MOZ_ASSERT(aIdOut);
+  MOZ_ASSERT(aCopyContextOut);
+
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> idGen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = idGen->GenerateUUIDInPlace(aIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (exists) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_TMP, getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (exists) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIOutputStream> fileStream =
+    FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
+                             aBaseDomain, aOrigin, tmpFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_READSEGMENTS,
+                    4096, // chunk size
+                    aCallback, aClosure,
+                    true, true, // close streams
+                    aCopyContextOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+void
+FileUtils::BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
+                           nsISupports* aCopyContext)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aCopyContext);
+
+  nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
+  NS_WARN_IF(NS_FAILED(rv));
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = tmpFile->Remove(false);
+  NS_WARN_IF(NS_FAILED(rv));
+}
+
+// static
+nsresult
+FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> tmpFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP,
+                             getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL, getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> finalDir;
+  rv = finalFile->GetParent(getter_AddRefs(finalDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsAutoString finalFileName;
+  rv = finalFile->GetLeafName(finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->RenameTo(finalDir, finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FileUtils_h
+#define mozilla_dom_cache_FileUtils_h
+
+#include "mozilla/Attributes.h"
+#include "nsStreamUtils.h"
+
+struct nsID;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FileUtils MOZ_FINAL
+{
+public:
+  enum BodyFileType
+  {
+    BODY_FILE_FINAL,
+    BODY_FILE_TMP
+  };
+
+  static nsresult BodyCreateDir(nsIFile* aBaseDir);
+
+  static nsresult
+  BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+               nsIFile** aBodyFileOut);
+
+  static nsresult
+  BodyStartWriteStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                       nsIFile* aBaseDir, nsIInputStream* aSource,
+                       void* aClosure, nsAsyncCopyCallbackFun aCallback,
+                       nsID* aIdOut, nsISupports** aCopyContextOut);
+
+  static void
+  BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
+                  nsISupports* aCopyContext);
+
+  static nsresult
+  BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
+
+private:
+  FileUtils() MOZ_DELETE;
+  ~FileUtils() MOZ_DELETE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FileUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -3,29 +3,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/PCacheQueryParams.h"
 #include "mozilla/dom/cache/PCacheRequest.h"
 #include "mozilla/dom/cache/PCacheResponse.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
+#include "nsIInputStream.h"
+#include "nsID.h"
+#include "nsIFile.h"
 #include "nsIThread.h"
-#include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::dom::cache::DBSchema;
+using mozilla::dom::cache::FileUtils;
 using mozilla::dom::cache::SyncDBAction;
 
 class SetupAction MOZ_FINAL : public SyncDBAction
 {
 public:
   SetupAction(const nsACString& aOrigin, const nsACString& aBaseDomain)
     : SyncDBAction(DBAction::Create, aOrigin, aBaseDomain)
   { }
@@ -34,20 +38,23 @@ public:
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     // TODO: create body directory structure
     // TODO: init maintainance marker
     // TODO: perform maintainance if necessary
     // TODO: find orphaned caches in database
 
+    nsresult rv = FileUtils::BodyCreateDir(aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsresult rv = DBSchema::CreateSchema(aConn);
+    rv = DBSchema::CreateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
@@ -224,17 +231,17 @@ public:
 
 private:
   virtual ~CheckCacheOrphanedAction() { }
   nsRefPtr<Manager> mManager;
   const CacheId mCacheId;
   bool mOrphaned;
 };
 
-class Manager::CacheMatchAction : public Manager::BaseAction
+class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
@@ -260,17 +267,17 @@ public:
 protected:
   virtual ~CacheMatchAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   PCacheResponseOrVoid mResponseOrVoid;
 };
 
-class Manager::CacheMatchAllAction : public Manager::BaseAction
+class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, CacheId aCacheId,
                       const PCacheRequestOrVoid& aRequestOrVoid,
                       const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
@@ -295,63 +302,249 @@ public:
 protected:
   virtual ~CacheMatchAllAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
   nsTArray<PCacheResponse> mResponses;
 };
 
-class Manager::CachePutAction : public Manager::BaseAction
+class Manager::CachePutAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAction(Manager* aManager, ListenerId aListenerId,
                  RequestId aRequestId, CacheId aCacheId,
-                 const PCacheRequest& aRequest, const PCacheResponse& aResponse)
-    : BaseAction(aManager, aListenerId, aRequestId)
+                 const PCacheRequest& aRequest,
+                 nsIInputStream* aRequestBodyStream,
+                 const PCacheResponse& aResponse,
+                 nsIInputStream* aResponseBodyStream)
+    : DBAction(DBAction::Existing, aManager->Origin(), aManager->BaseDomain())
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
+    , mRequestBodyStream(aRequestBodyStream)
     , mResponse(aResponse)
+    , mResponseBodyStream(aResponseBodyStream)
     , mResponseOrVoid(void_t())
+    , mExpectedAsyncCopyCompletions(0)
   { }
 
-  virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
-                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
+                    mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    mozStorageTransaction trans(aConn, false,
+    MOZ_ASSERT(aResolver);
+    MOZ_ASSERT(aDBDir);
+    MOZ_ASSERT(aConn);
+    MOZ_ASSERT(!mResolver);
+    MOZ_ASSERT(!mDBDir);
+    MOZ_ASSERT(!mConn);
+
+    mResolver = aResolver;
+    mDBDir = aDBDir;
+    mConn = aConn;
+
+    mExpectedAsyncCopyCompletions = mRequestBodyStream ? 1 : 0;
+    mExpectedAsyncCopyCompletions += mResponseBodyStream ? 1 : 0;
+
+    if (mExpectedAsyncCopyCompletions < 1) {
+      mExpectedAsyncCopyCompletions = 1;
+      OnAsyncCopyComplete(NS_OK);
+      return;
+    }
+
+    nsresult rv = StartStreamCopy(mRequestBodyStream, &mRequestBodyId,
+                                  getter_AddRefs(mRequestBodyCopyContext));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+    MOZ_ASSERT(mRequestBodyCopyContext);
+
+    rv = StartStreamCopy(mResponseBodyStream, &mResponseBodyId,
+                         getter_AddRefs(mResponseBodyCopyContext));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                       mRequestBodyId);
+      mRequestBodyCopyContext = nullptr;
+      DoResolve(rv);
+      return;
+    }
+  }
+
+  void
+  OnAsyncCopyComplete(nsresult aRv)
+  {
+    MOZ_ASSERT(mConn);
+    MOZ_ASSERT(mResolver);
+    MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
+
+    if (NS_FAILED(aRv)) {
+      DoResolve(aRv);
+      return;
+    }
+
+    mExpectedAsyncCopyCompletions -= 1;
+    if (mExpectedAsyncCopyCompletions > 0) {
+      return;
+    }
+
+    mRequestBodyCopyContext = nullptr;
+    mResponseBodyCopyContext = nullptr;
+
+    nsresult rv = NS_OK;
+
+    if (mRequestBodyStream) {
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mRequestBodyId);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        DoResolve(rv);
+        return;
+      }
+    }
+
+    if (mResponseBodyStream) {
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mResponseBodyId);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        DoResolve(rv);
+        return;
+      }
+    }
+
+    mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsresult rv = DBSchema::CachePut(aConn, mCacheId, mRequest, mResponse);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    // TODO: persist body IDs to DB
+
+    rv = DBSchema::CachePut(mConn, mCacheId, mRequest, mResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
 
     rv = trans.Commit();
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
 
     // TODO: replace this with a read stream of the written files
+    //       or hopefully spec drops need to return response
     mResponseOrVoid = mResponse;
 
+    DoResolve(rv);
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(Action);
+    Listener* listener = mManager->GetListener(mListenerId);
+    if (!listener) {
+      return;
+    }
+    listener->OnCachePut(mRequestId, aRv, mResponseOrVoid);
+  }
+
+  virtual void
+  CancelOnTarget() MOZ_OVERRIDE
+  {
+    CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                     mRequestBodyId);
+    mRequestBodyCopyContext = nullptr;
+    CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
+                     mResponseBodyId);
+    mResponseBodyCopyContext = nullptr;
+    mConn = nullptr;
+    mResolver = nullptr;
+  }
+
+private:
+  virtual ~CachePutAction() { }
+
+  nsresult
+  StartStreamCopy(nsIInputStream* aSource, nsID* aIdOut,
+                  nsISupports** aCopyContextOut)
+  {
+    MOZ_ASSERT(aIdOut);
+    MOZ_ASSERT(aCopyContextOut);
+    MOZ_ASSERT(mDBDir);
+
+    if (!aSource) {
+      return NS_OK;
+    }
+
+    nsresult rv = FileUtils::BodyStartWriteStream(mManager->Origin(),
+                                                  mManager->BaseDomain(),
+                                                  mDBDir,
+                                                  aSource,
+                                                  this,
+                                                  AsyncCopyCompleteFunc,
+                                                  aIdOut,
+                                                  aCopyContextOut);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
     return rv;
   }
 
-  virtual void
-  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  void
+  CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
+                   const nsID& aId)
   {
-    aListener->OnCachePut(mRequestId, aRv, mResponseOrVoid);
+    if (!aSource || !aCopyContext) {
+      return;
+    }
+    FileUtils::BodyCancelWrite(mDBDir, aId, aCopyContext);
   }
 
-protected:
-  virtual ~CachePutAction() { }
+  static void
+  AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
+  {
+    MOZ_ASSERT(aClosure);
+    CachePutAction* action = static_cast<CachePutAction*>(aClosure);
+    action->OnAsyncCopyComplete(aRv);
+  }
+
+  void
+  DoResolve(nsresult aRv)
+  {
+    if (NS_FAILED(aRv)) {
+      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                       mRequestBodyId);
+      CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
+                       mResponseBodyId);
+    }
+    mConn = nullptr;
+    if (mResolver) {
+      mResolver->Resolve(aRv);
+      mResolver = nullptr;
+    }
+  }
+
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
   const CacheId mCacheId;
   const PCacheRequest mRequest;
+  nsCOMPtr<nsIInputStream> mRequestBodyStream;
   const PCacheResponse mResponse;
+  nsCOMPtr<nsIInputStream> mResponseBodyStream;
   PCacheResponseOrVoid mResponseOrVoid;
+  nsRefPtr<Resolver> mResolver;
+  nsCOMPtr<nsIFile> mDBDir;
+  nsCOMPtr<mozIStorageConnection> mConn;
+  uint32_t mExpectedAsyncCopyCompletions;
+  nsID mRequestBodyId;
+  nsCOMPtr<nsISupports> mRequestBodyCopyContext;
+  nsID mResponseBodyId;
+  nsCOMPtr<nsISupports> mResponseBodyCopyContext;
 };
 
-class Manager::CacheDeleteAction : public Manager::BaseAction
+class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
@@ -651,23 +844,27 @@ Manager::CacheMatchAll(Listener* aListen
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
                                                     aCacheId, aRequest, aParams);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
-                  const PCacheResponse& aResponse)
+                  nsIInputStream* aRequestBodyStream,
+                  const PCacheResponse& aResponse,
+                  nsIInputStream* aResponseBodyStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
-                                               aCacheId, aRequest, aResponse);
+                                               aCacheId,
+                                               aRequest, aRequestBodyStream,
+                                               aResponse, aResponseBodyStream);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheDelete(Listener* aListener, const RequestId& aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -9,16 +9,17 @@
 
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
+class nsIInputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheQueryParams;
 class PCacheRequest;
@@ -65,17 +66,20 @@ public:
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
   void CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
-                const PCacheRequest& aRequest, const PCacheResponse& aResponse);
+                const PCacheRequest& aRequest,
+                nsIInputStream* aRequestBodyStream,
+                const PCacheResponse& aResponse,
+                nsIInputStream* aResponseBodyStream);
   void CacheDelete(Listener* aListener, const RequestId& aRequestId,
                    CacheId aCacheId, const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams);
 
   void StorageGet(Listener* aListener, RequestId aRequestId,
                   Namespace aNamespace, const nsAString& aKey);
   void StorageHas(Listener* aListener, RequestId aRequestId,
                   Namespace aNamespace, const nsAString& aKey);
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -13,16 +13,17 @@ EXPORTS.mozilla.dom.cache += [
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
+    'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'Types.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
@@ -30,16 +31,17 @@ SOURCES += [
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
+    'FileUtils.cpp',
     'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
