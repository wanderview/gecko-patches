# HG changeset patch
# Parent a040c47e5db9b2948abb9856a35b7c465c9a62b1
# User Ben Kelly <ben@wanderview.com>
Implement cache body reading and writing.

diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -2,18 +2,23 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/SavedTypes.h"
 #include "nsCOMPtr.h"
 
+// TODO: remove testing only headers
+#include "../../dom/filehandle/MemoryStreams.h"
+#include "nsStringStream.h"
+
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 
 CacheParent::CacheParent(const nsACString& aOrigin,
@@ -72,17 +77,36 @@ CacheParent::RecvAddAll(const RequestId&
   return false;
 }
 
 bool
 CacheParent::RecvPut(const RequestId& aRequestId, const PCacheRequest& aRequest,
                      const PCacheResponse& aResponse)
 {
   MOZ_ASSERT(mManager);
-  mManager->CachePut(this, aRequestId, mCacheId, aRequest, aResponse);
+
+  // TODO: remove stream test code
+  nsCOMPtr<nsIInputStream> requestStream;
+  nsresult rv = NS_NewCStringInputStream(getter_AddRefs(requestStream),
+                NS_LITERAL_CSTRING("request body stream beep beep boop!"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    OnCachePut(aRequestId, rv, nullptr);
+    return true;
+  }
+
+  nsCOMPtr<nsIInputStream> responseStream;
+  rv = NS_NewCStringInputStream(getter_AddRefs(responseStream),
+                NS_LITERAL_CSTRING("response body stream hooray!"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    OnCachePut(aRequestId, rv, nullptr);
+    return true;
+  }
+
+  mManager->CachePut(this, aRequestId, mCacheId,
+                     aRequest, requestStream, aResponse, responseStream);
   return true;
 }
 
 bool
 CacheParent::RecvDelete(const RequestId& aRequestId,
                         const PCacheRequest& aRequest,
                         const PCacheQueryParams& aParams)
 {
@@ -96,33 +120,90 @@ CacheParent::RecvKeys(const RequestId& a
                       const PCacheRequestOrVoid& aRequest,
                       const PCacheQueryParams& aParams)
 {
   return false;
 }
 
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                          const PCacheResponseOrVoid& aResponse)
+                          const SavedResponse* aSavedResponse)
 {
-  unused << SendMatchResponse(aRequestId, aRv, aResponse);
+  PCacheResponseOrVoid responseOrVoid;
+
+  // no match
+  if (NS_FAILED(aRv) || !aSavedResponse) {
+    responseOrVoid = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // match without body data to stream
+  if (!aSavedResponse->mHasBodyId) {
+    responseOrVoid = aSavedResponse->mValue;
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // TODO: remove stream test code
+  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+
+  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
+  responseOrVoid = aSavedResponse->mValue;
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<PCacheResponse>& aResponses)
+                             const nsTArray<SavedResponse>& aSavedResponses)
 {
-  unused << SendMatchAllResponse(aRequestId, aRv, aResponses);
+  nsTArray<PCacheResponse> responses;
+  nsTArray<nsCOMPtr<nsIOutputStream>> responseStreams;
+  for (uint32_t i = 0; i < aSavedResponses.Length(); ++i) {
+    responses.AppendElement(aSavedResponses[i].mValue);
+
+    if (!aSavedResponses[i].mHasBodyId) {
+      responseStreams.AppendElement(nullptr);
+    } else {
+      // TODO: remove stream test code
+      responseStreams.AppendElement(MemoryOutputStream::Create(4096));
+      mManager->CacheReadBody(mCacheId, aSavedResponses[i].mBodyId,
+                              responseStreams[i]);
+    }
+  }
+
+  unused << SendMatchAllResponse(aRequestId, aRv, responses);
 }
 
 void
 CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv,
-                        const PCacheResponseOrVoid& aResponseOrVoid)
+                        const SavedResponse* aSavedResponse)
 {
-  unused << SendPutResponse(aRequestId, aRv, aResponseOrVoid);
+  PCacheResponseOrVoid responseOrVoid;
+
+  // no match
+  if (NS_FAILED(aRv) || !aSavedResponse) {
+    responseOrVoid = void_t();
+    unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // match without body data to stream
+  if (!aSavedResponse->mHasBodyId) {
+    responseOrVoid = aSavedResponse->mValue;
+    unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
+    return;
+  }
+
+  // TODO: remove stream test code
+  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+
+  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
+  responseOrVoid = aSavedResponse->mValue;
+  unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheParent::OnCacheDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
 }
 
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -14,16 +14,18 @@
 struct nsID;
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheDBConnection;
+struct SavedResponse;
+struct StreamHolder;
 
 class CacheParent MOZ_FINAL : public PCacheParent
                             , public Manager::Listener
 {
 public:
   CacheParent(const nsACString& aOrigin, const nsACString& aBaseDomain,
               CacheId aCacheId);
   virtual ~CacheParent();
@@ -49,21 +51,21 @@ public:
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                            const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+                            const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+                   const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
-                      const PCacheResponseOrVoid& aResponseOrVoid) MOZ_OVERRIDE;
+                          const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
 
 private:
   const CacheId mCacheId;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -453,18 +453,21 @@ Context::CancelAll()
     mActionRunnables[i]->Cancel();
   }
 }
 
 void
 Context::CancelForCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  mState = STATE_CONTEXT_CANCELED;
-  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
+      mPendingActions.RemoveElementAt(i);
+    }
+  }
   for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
     if (mActionRunnables[i]->MatchesCacheId(aCacheId)) {
       mActionRunnables[i]->Cancel();
     }
   }
 }
 
 Context::~Context()
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -43,16 +43,17 @@ DBAction::RunOnTarget(Resolver* aResolve
 
   nsCOMPtr<mozIStorageConnection> conn;
   rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
   MOZ_ASSERT(conn);
+
   RunWithDBOnTarget(aResolver, aQuotaDir, conn);
 }
 
 nsresult
 DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
 {
   MOZ_ASSERT(aDBDir);
   MOZ_ASSERT(aConnOut);
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -24,16 +24,19 @@ protected:
   {
     Existing,
     Create
   };
 
   DBAction(Mode aMode, const nsACString& aOrigin,
            const nsACString& aBaseDomain);
 
+  // Just as the resolver must be ref'd until cancel or resolve, you may also
+  // ref the DB connection.  The connection can only be referenced from the
+  // target thread and must be released upon cancel or resolve.
   virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
                                  mozIStorageConnection* aConn)=0;
 
   virtual
   void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
 
   virtual ~DBAction() { }
 
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBSchema.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/dom/cache/PCacheQueryParams.h"
 #include "mozilla/dom/cache/PCacheRequest.h"
 #include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/SavedTypes.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
@@ -63,21 +64,21 @@ DBSchema::CreateSchema(mozIStorageConnec
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE entries ("
         "id INTEGER NOT NULL PRIMARY KEY, "
         "request_method TEXT NOT NULL, "
         "request_url TEXT NOT NULL, "
         "request_url_no_query TEXT NOT NULL, "
         "request_mode INTEGER NOT NULL, "
         "request_credentials INTEGER NOT NULL, "
-        //"request_body_file TEXT NOT NULL, "
+        "request_body_id TEXT NULL, "
         "response_type INTEGER NOT NULL, "
         "response_status INTEGER NOT NULL, "
         "response_status_text TEXT NOT NULL, "
-        //"response_body_file TEXT NOT NULL "
+        "response_body_id TEXT NOT NULL, "
         "cache_id INTEGER NOT NULL REFERENCES caches(id) ON DELETE CASCADE"
       ");"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE INDEX entries_request_url_index "
                 "ON entries (request_url);"
@@ -170,17 +171,18 @@ DBSchema::CreateCache(mozIStorageConnect
 }
 
 // static
 nsresult
 DBSchema::DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId)
 {
   MOZ_ASSERT(aConn);
 
-  // Dependent data removed by ON DELETE CASCADE in schema definition.
+  // Dependent data removed via ON DELETE CASCADE. Associated body files
+  // should be removed in bulk for the cache.
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "DELETE FROM caches WHERE id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aCacheId);
@@ -226,109 +228,118 @@ DBSchema::IsCacheOrphaned(mozIStorageCon
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
                      const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams,
-                     PCacheResponseOrVoid* aResponseOrVoidOut)
+                     bool* aFoundResponseOut,
+                     SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aResponseOrVoidOut);
+  MOZ_ASSERT(aFoundResponseOut);
+  MOZ_ASSERT(aSavedResponseOut);
 
   nsTArray<EntryId> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (matches.Length() < 1) {
-    *aResponseOrVoidOut = void_t();
+    *aFoundResponseOut = false;
     return rv;
   }
 
-  PCacheResponse response;
-  rv = ReadResponse(aConn, matches[0], response);
+  rv = ReadResponse(aConn, matches[0], aSavedResponseOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  *aResponseOrVoidOut = response;
+  *aFoundResponseOut = true;
+
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
                         const PCacheRequestOrVoid& aRequestOrVoid,
                         const PCacheQueryParams& aParams,
-                        nsTArray<PCacheResponse>& aResponsesOut)
+                        nsTArray<SavedResponse>& aSavedResponsesOut)
 {
   MOZ_ASSERT(aConn);
   nsresult rv;
 
   nsTArray<EntryId> matches;
   if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   // TODO: replace this with a bulk load using SQL IN clause
   for (uint32_t i = 0; i < matches.Length(); ++i) {
-    PCacheResponse *response = aResponsesOut.AppendElement();
-    rv = ReadResponse(aConn, matches[i], *response);
+    SavedResponse *savedResponse = aSavedResponsesOut.AppendElement();
+    rv = ReadResponse(aConn, matches[i], savedResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
                    const PCacheRequest& aRequest,
-                   const PCacheResponse& aResponse)
+                   const nsID* aRequestBodyId,
+                   const PCacheResponse& aResponse,
+                   const nsID* aResponseBodyId,
+                   nsTArray<nsID>& aDeletedBodyIdListOut,
+                   SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedResponseOut);
 
   PCacheQueryParams params(false, false, false, false, false,
                            NS_LITERAL_STRING(""));
   nsTArray<EntryId> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, params, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = DeleteEntries(aConn, matches);
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = InsertEntry(aConn, aCacheId, aRequest, aResponse);
+  rv = InsertEntry(aConn, aCacheId, aRequest, aRequestBodyId, aResponse,
+                   aResponseBodyId, aSavedResponseOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
                       const PCacheRequest& aRequest,
-                      const PCacheQueryParams& aParams, bool* aSuccessOut)
+                      const PCacheQueryParams& aParams,
+                      nsTArray<nsID>& aDeletedBodyIdListOut, bool* aSuccessOut)
 {
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aSuccessOut);
 
   nsTArray<EntryId> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (matches.Length() < 1) {
     *aSuccessOut = false;
     return rv;
   }
 
-  rv = DeleteEntries(aConn, matches);
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   *aSuccessOut = true;
 
   return rv;
 }
 
 // static
@@ -648,16 +659,17 @@ DBSchema::MatchByVaryHeader(mozIStorageC
   *aSuccessOut = true;
   return rv;
 }
 
 // static
 nsresult
 DBSchema::DeleteEntries(mozIStorageConnection* aConn,
                         const nsTArray<EntryId>& aEntryIdList,
+                        nsTArray<nsID>& aDeletedBodyIdListOut,
                         uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT(aConn);
 
   if (aEntryIdList.Length() < 1) {
     return NS_OK;
   }
 
@@ -670,67 +682,103 @@ DBSchema::DeleteEntries(mozIStorageConne
   // Sqlite limits the number of entries allowed for an IN clause,
   // so split up larger operations.
   if (aLen > kMaxEntriesPerStatement) {
     uint32_t curPos = aPos;
     int32_t remaining = aLen;
     while (remaining > 0) {
       int32_t max = kMaxEntriesPerStatement;
       int32_t curLen = std::min(max, remaining);
-      nsresult rv = DeleteEntries(aConn, aEntryIdList, curPos, curLen);
+      nsresult rv = DeleteEntries(aConn, aEntryIdList, aDeletedBodyIdListOut,
+                                  curPos, curLen);
       if (NS_FAILED(rv)) { return rv; }
 
       curPos += curLen;
       remaining -= curLen;
     }
     return NS_OK;
   }
 
+  nsCOMPtr<mozIStorageStatement> state;
+  nsAutoCString query(
+    "SELECT request_body_id, response_body_id FROM entries WHERE id IN ("
+  );
+  AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
+  query.Append(NS_LITERAL_CSTRING(")"));
+
+  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    // extract 0 to 2 nsID structs per row
+    for (uint32_t i = 0; i < 2; ++i) {
+      bool isNull;
+
+      rv = state->GetIsNull(i, &isNull);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      if (!isNull) {
+        nsID* id = aDeletedBodyIdListOut.AppendElement();
+        rv = ExtractId(state, i, id);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      }
+    }
+  }
+
   // Dependent records removed via ON DELETE CASCADE
 
-  nsCOMPtr<mozIStorageStatement> state;
-  nsAutoCString query(
+  query = NS_LITERAL_CSTRING(
     "DELETE FROM entries WHERE id IN ("
   );
   AppendListParamsToQuery(query, aEntryIdList, aPos, aLen);
   query.Append(NS_LITERAL_CSTRING(")"));
 
-  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  rv = aConn->CreateStatement(query, getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return NS_OK;
 }
 
 // static
 nsresult
 DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
                       const PCacheRequest& aRequest,
-                      const PCacheResponse& aResponse)
+                      const nsID* aRequestBodyId,
+                      const PCacheResponse& aResponse,
+                      const nsID* aResponseBodyId,
+                      SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedResponseOut);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO entries ("
       "request_method, "
       "request_url, "
       "request_url_no_query, "
       "request_mode, "
       "request_credentials, "
+      "request_body_id, "
       "response_type, "
       "response_status, "
       "response_status_text, "
+      "response_body_id, "
       "cache_id "
-    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"
+    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringParameter(0, aRequest.method());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindStringParameter(1, aRequest.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -740,26 +788,32 @@ DBSchema::InsertEntry(mozIStorageConnect
 
   rv = state->BindInt32Parameter(3, static_cast<int32_t>(aRequest.mode()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(4,
     static_cast<int32_t>(aRequest.credentials()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(5, static_cast<int32_t>(aResponse.type()));
+  rv = BindId(state, 5, aRequestBodyId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(6, aResponse.status());
+  rv = state->BindInt32Parameter(6, static_cast<int32_t>(aResponse.type()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindUTF8StringParameter(7, aResponse.statusText());
+  rv = state->BindInt32Parameter(7, aResponse.status());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(8, aCacheId);
+  rv = state->BindUTF8StringParameter(8, aResponse.statusText());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = BindId(state, 9, aResponseBodyId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(10, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT last_insert_rowid()"
   ), getter_AddRefs(state));
@@ -816,70 +870,86 @@ DBSchema::InsertEntry(mozIStorageConnect
 
     rv = state->BindInt32Parameter(2, entryId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->Execute();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
+  rv = ReadResponse(aConn, entryId, aSavedResponseOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
   return NS_OK;
 }
 
 // static
 nsresult
-DBSchema::ReadResponse(mozIStorageConnection* aConn,
-                       EntryId aEntryId, PCacheResponse& aResponseOut)
+DBSchema::ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
+                       SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedResponseOut);
+
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "response_type, "
       "response_status, "
-      "response_status_text "
+      "response_status_text, "
+      "response_body_id "
     "FROM entries "
     "WHERE id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t type;
   rv = state->GetInt32(0, &type);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  aResponseOut.type() = static_cast<ResponseType>(type);
+  aSavedResponseOut->mValue.type() = static_cast<ResponseType>(type);
 
   int32_t status;
   rv = state->GetInt32(1, &status);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  aResponseOut.status() = status;
+  aSavedResponseOut->mValue.status() = status;
 
-  rv = state->GetUTF8String(2, aResponseOut.statusText());
+  rv = state->GetUTF8String(2, aSavedResponseOut->mValue.statusText());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  bool nullBody;
+  rv = state->GetIsNull(3, &nullBody);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mHasBodyId = !nullBody;
+
+  if (aSavedResponseOut->mHasBodyId) {
+    rv = ExtractId(state, 3, &aSavedResponseOut->mBodyId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "name, "
       "value "
     "FROM response_headers "
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    PHeadersEntry* header = aResponseOut.headers().AppendElement();
+    PHeadersEntry* header = aSavedResponseOut->mValue.headers().AppendElement();
 
     rv = state->GetUTF8String(0, header->name());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->GetUTF8String(1, header->value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
@@ -911,11 +981,49 @@ DBSchema::BindListParamsToQuery(mozIStor
   MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
   for (int32_t i = aPos; i < aLen; ++i) {
     nsresult rv = aState->BindInt32Parameter(i, aEntryIdList[i]);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
 }
 
+// static
+nsresult
+DBSchema::BindId(mozIStorageStatement* aState, uint32_t aPos, const nsID* aId)
+{
+  MOZ_ASSERT(aState);
+  nsresult rv;
+
+  if (!aId) {
+    rv = aState->BindNullParameter(aPos);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    return rv;
+  }
+
+  char idBuf[NSID_LENGTH];
+  aId->ToProvidedString(idBuf);
+  rv = aState->BindUTF8StringParameter(aPos, nsAutoCString(idBuf));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::ExtractId(mozIStorageStatement* aState, uint32_t aPos, nsID* aIdOut)
+{
+  MOZ_ASSERT(aState);
+  MOZ_ASSERT(aIdOut);
+
+  nsAutoCString idString;
+  nsresult rv = aState->GetUTF8String(aPos, idString);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool success = aIdOut->Parse(idString.get());
+  if (NS_WARN_IF(!success)) { return NS_ERROR_UNEXPECTED; }
+
+  return rv;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -9,27 +9,29 @@
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 class mozIStorageStatement;
+struct nsID;
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheResponseOrVoid;
+struct SavedResponse;
 
 class DBSchema MOZ_FINAL
 {
 public:
   static nsresult CreateSchema(mozIStorageConnection* aConn);
 
   static nsresult CreateCache(mozIStorageConnection* aConn,
                               CacheId* aCacheIdOut);
@@ -37,27 +39,33 @@ public:
   static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId);
 
   static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
                                   CacheId aCacheId, bool* aOrphanedOut);
 
   static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
                              const PCacheRequest& aRequest,
                              const PCacheQueryParams& aParams,
-                             PCacheResponseOrVoid* aResponseOrVoidOut);
+                             bool* aFoundResponseOut,
+                             SavedResponse* aSavedResponseOut);
   static nsresult CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
                                 const PCacheRequestOrVoid& aRequestOrVoid,
                                 const PCacheQueryParams& aParams,
-                                nsTArray<PCacheResponse>& aResponsesOut);
+                                nsTArray<SavedResponse>& aSavedResponsesOut);
   static nsresult CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
                            const PCacheRequest& aRequest,
-                           const PCacheResponse& aResponse);
+                           const nsID* aRequestBodyId,
+                           const PCacheResponse& aResponse,
+                           const nsID* aResponseBodyId,
+                           nsTArray<nsID>& aDeletedBodyIdListOut,
+                           SavedResponse* aSavedResponseOut);
   static nsresult CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
                               const PCacheRequest& aRequest,
                               const PCacheQueryParams& aParams,
+                              nsTArray<nsID>& aDeletedBodyIdListOut,
                               bool* aSuccessOut);
 
   static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
                                     Namespace aNamespace, const nsAString& aKey,
                                     bool* aFoundCacheOut, CacheId* aCacheIdOut);
   static nsresult StoragePutCache(mozIStorageConnection* aConn,
                                   Namespace aNamespace, const nsAString& aKey,
                                   CacheId aCacheId);
@@ -77,29 +85,37 @@ private:
                              const PCacheRequest& aRequest,
                              const PCacheQueryParams& aParams,
                              nsTArray<EntryId>& aEntryIdListOut);
   static nsresult MatchByVaryHeader(mozIStorageConnection* aConn,
                                     const PCacheRequest& aRequest,
                                     EntryId entryId, bool* aSuccessOut);
   static nsresult DeleteEntries(mozIStorageConnection* aConn,
                                 const nsTArray<EntryId>& aEntryIdList,
+                                nsTArray<nsID>& aDeletedBodyIdListOut,
                                 uint32_t aPos=0, int32_t aLen=-1);
   static nsresult InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
                               const PCacheRequest& aRequest,
-                              const PCacheResponse& aResponse);
-  static nsresult ReadResponse(mozIStorageConnection* aConn,
-                               EntryId aEntryId, PCacheResponse& aResponseOut);
+                              const nsID* aRequestBodyId,
+                              const PCacheResponse& aResponse,
+                              const nsID* aResponseBodyId,
+                              SavedResponse* aSavedResponseOut);
+  static nsresult ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
+                               SavedResponse* aSavedResponseOut);
 
   static void AppendListParamsToQuery(nsACString& aQuery,
                                       const nsTArray<EntryId>& aEntryIdList,
                                       uint32_t aPos, int32_t aLen);
   static nsresult BindListParamsToQuery(mozIStorageStatement* aState,
                                         const nsTArray<EntryId>& aEntryIdList,
                                         uint32_t aPos, int32_t aLen);
+  static nsresult BindId(mozIStorageStatement* aState, uint32_t aPos,
+                         const nsID* aId);
+  static nsresult ExtractId(mozIStorageStatement* aState, uint32_t aPos,
+                            nsID* aIdOut);
 
   DBSchema() MOZ_DELETE;
   ~DBSchema() MOZ_DELETE;
 
   static const int32_t kLatestSchemaVersion;
   static const int32_t kMaxEntriesPerStatement;
 };
 
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.cpp
@@ -0,0 +1,382 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FileUtils.h"
+#include "mozilla/dom/quota/FileStreams.h"
+#include "nsIFile.h"
+#include "nsIUUIDGenerator.h"
+#include "nsServiceManagerUtils.h"
+#include "nsString.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::FileInputStream;
+using mozilla::dom::quota::FileOutputStream;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+
+// static
+nsresult
+FileUtils::BodyCreateDir(nsIFile* aBaseDir)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> aBodyDir;
+  nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = aBodyDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = aBodyDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    bool isDir;
+    rv = aBodyDir->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, CacheId aCacheId,
+                           nsIFile** aCacheDirOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aCacheDirOut);
+
+  nsresult rv = aBaseDir->Clone(aCacheDirOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = (*aCacheDirOut)->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = (*aCacheDirOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  bool isDir;
+  rv = (*aCacheDirOut)->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  nsAutoString cacheDirName;
+  cacheDirName.AppendInt(aCacheId);
+  rv = (*aCacheDirOut)->Append(cacheDirName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = (*aCacheDirOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = (*aCacheDirOut)->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = (*aCacheDirOut)->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyDeleteCacheDir(nsIFile* aBaseDir, CacheId aCacheId)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> cacheDir;
+  nsresult rv = aBaseDir->Clone(getter_AddRefs(cacheDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = cacheDir->Append(NS_LITERAL_STRING("morgue"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = cacheDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  nsAutoString cacheDirName;
+  cacheDirName.AppendInt(aCacheId);
+  rv = cacheDir->Append(cacheDirName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = cacheDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Already in desired state where cache dir does not exist.
+  if (!exists) {
+    return rv;
+  }
+
+  bool isDir;
+  rv = cacheDir->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  rv = cacheDir->Remove(true /* recursive */);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyIdToFile(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                        BodyFileType aType, nsIFile** aBodyFileOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aBodyFileOut);
+
+  nsresult rv = BodyGetCacheDir(aBaseDir, aCacheId, aBodyFileOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = (*aBodyFileOut)->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (!exists) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  bool isDir;
+  rv = (*aBodyFileOut)->IsDirectory(&isDir);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
+
+  char idString[NSID_LENGTH];
+  aId.ToProvidedString(idString);
+
+  NS_ConvertUTF8toUTF16 fileName(idString);
+
+  if (aType == BODY_FILE_FINAL) {
+    fileName.Append(NS_LITERAL_STRING(".final"));
+  } else {
+    fileName.Append(NS_LITERAL_STRING(".tmp"));
+  }
+
+  rv = (*aBodyFileOut)->Append(fileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyStartWriteStream(const nsACString& aOrigin,
+                                const nsACString& aBaseDomain,
+                                nsIFile* aBaseDir, CacheId aCacheId,
+                                nsIInputStream* aSource, void* aClosure,
+                                nsAsyncCopyCallbackFun aCallback,
+                                nsID* aIdOut, nsISupports** aCopyContextOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aSource);
+  MOZ_ASSERT(aClosure);
+  MOZ_ASSERT(aCallback);
+  MOZ_ASSERT(aIdOut);
+  MOZ_ASSERT(aCopyContextOut);
+
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> idGen =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = idGen->GenerateUUIDInPlace(aIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, aCacheId, *aIdOut, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, aCacheId, *aIdOut, BODY_FILE_TMP,
+                    getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIOutputStream> fileStream =
+    FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
+                             aBaseDomain, aOrigin, tmpFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_READSEGMENTS,
+                    4096, // chunk size
+                    aCallback, aClosure,
+                    true, true, // close streams
+                    aCopyContextOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    fileStream->Close();
+    return rv;
+  }
+
+  return rv;
+}
+
+// static
+void
+FileUtils::BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                           nsISupports* aCopyContext)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aCopyContext);
+
+  nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
+  NS_WARN_IF(NS_FAILED(rv));
+
+  nsCOMPtr<nsIFile> tmpFile;
+  rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_TMP,
+                    getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = tmpFile->Remove(false /* recursive */);
+  NS_WARN_IF(NS_FAILED(rv));
+}
+
+// static
+nsresult
+FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId)
+{
+  MOZ_ASSERT(aBaseDir);
+
+  nsCOMPtr<nsIFile> tmpFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_TMP,
+                             getter_AddRefs(tmpFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = tmpFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIFile> finalFile;
+  rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
+
+  nsCOMPtr<nsIFile> finalDir;
+  rv = finalFile->GetParent(getter_AddRefs(finalDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsAutoString finalFileName;
+  rv = finalFile->GetLeafName(finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = tmpFile->RenameTo(finalDir, finalFileName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::BodyStartReadStream(const nsACString& aOrigin,
+                               const nsACString& aBaseDomain,
+                               nsIFile* aBaseDir, CacheId aCacheId,
+                               const nsID& aId, nsIOutputStream* aDest,
+                               void* aClosure,
+                               nsAsyncCopyCallbackFun aCallback,
+                               nsISupports** aCopyContextOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aDest);
+  MOZ_ASSERT(aClosure);
+  MOZ_ASSERT(aCallback);
+  MOZ_ASSERT(aCopyContextOut);
+
+  nsCOMPtr<nsIFile> finalFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIInputStream> fileStream =
+    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aBaseDomain, aOrigin,
+                            finalFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = NS_AsyncCopy(fileStream, aDest, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_READSEGMENTS,
+                    4096, // chunk size
+                    aCallback, aClosure,
+                    true, true, // close streams
+                    aCopyContextOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    fileStream->Close();
+    return rv;
+  }
+
+  return rv;
+}
+
+// static
+void
+FileUtils::BodyCancelRead(nsISupports* aCopyContext)
+{
+  MOZ_ASSERT(aCopyContext);
+  nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
+  NS_WARN_IF(NS_FAILED(rv));
+}
+
+// static
+nsresult
+FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, CacheId aCacheId,
+                           const nsTArray<nsID>& aIdList)
+{
+  nsresult rv = NS_OK;
+
+  for (uint32_t i = 0; i < aIdList.Length(); ++i) {
+    nsCOMPtr<nsIFile> finalFile;
+    rv = BodyIdToFile(aBaseDir, aCacheId, aIdList[i], BODY_FILE_FINAL,
+                      getter_AddRefs(finalFile));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool exists;
+    rv = finalFile->Exists(&exists);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (NS_WARN_IF(!exists)) {
+      continue;
+    }
+
+    rv = finalFile->Remove(false /* recursive */);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FileUtils.h
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FileUtils_h
+#define mozilla_dom_cache_FileUtils_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsStreamUtils.h"
+
+struct nsID;
+class nsIFile;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FileUtils MOZ_FINAL
+{
+public:
+  enum BodyFileType
+  {
+    BODY_FILE_FINAL,
+    BODY_FILE_TMP
+  };
+
+  static nsresult BodyCreateDir(nsIFile* aBaseDir);
+  static nsresult BodyGetCacheDir(nsIFile* aBaseDir, CacheId aCacheId,
+                                  nsIFile** aCacheDirOut);
+  static nsresult BodyDeleteCacheDir(nsIFile* aBaseDir, CacheId aCacheId);
+
+  static nsresult
+  BodyIdToFile(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+               BodyFileType aType, nsIFile** aBodyFileOut);
+
+  static nsresult
+  BodyStartWriteStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                       nsIFile* aBaseDir, CacheId aCacheId,
+                       nsIInputStream* aSource, void* aClosure,
+                       nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                       nsISupports** aCopyContextOut);
+
+  static void
+  BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                  nsISupports* aCopyContext);
+
+  static nsresult
+  BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId);
+
+  static nsresult
+  BodyStartReadStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                      nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                      nsIOutputStream* aDest, void* aClosure,
+                      nsAsyncCopyCallbackFun aCallback,
+                      nsISupports** aCopyContextOut);
+
+  static void BodyCancelRead(nsISupports* aCopyContext);
+
+  static nsresult
+  BodyDeleteFiles(nsIFile* aBaseDir, CacheId aCacheId,
+                  const nsTArray<nsID>& aIdList);
+
+private:
+  FileUtils() MOZ_DELETE;
+  ~FileUtils() MOZ_DELETE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FileUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -3,29 +3,34 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/PCacheQueryParams.h"
 #include "mozilla/dom/cache/PCacheRequest.h"
 #include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
+#include "nsIInputStream.h"
+#include "nsID.h"
+#include "nsIFile.h"
 #include "nsIThread.h"
-#include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::dom::cache::DBSchema;
+using mozilla::dom::cache::FileUtils;
 using mozilla::dom::cache::SyncDBAction;
 
 class SetupAction MOZ_FINAL : public SyncDBAction
 {
 public:
   SetupAction(const nsACString& aOrigin, const nsACString& aBaseDomain)
     : SyncDBAction(DBAction::Create, aOrigin, aBaseDomain)
   { }
@@ -34,20 +39,23 @@ public:
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     // TODO: create body directory structure
     // TODO: init maintainance marker
     // TODO: perform maintainance if necessary
     // TODO: find orphaned caches in database
 
+    nsresult rv = FileUtils::BodyCreateDir(aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsresult rv = DBSchema::CreateSchema(aConn);
+    rv = DBSchema::CreateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
@@ -136,16 +144,17 @@ protected:
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     Listener* listener = mManager->GetListener(mListenerId);
     if (!listener) {
       return;
     }
     Complete(listener, aRv);
+    mManager = nullptr;
   }
 
   virtual ~BaseAction() { }
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
 };
 
@@ -161,26 +170,25 @@ public:
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    // TODO: get body data file names
+    nsresult rv =  DBSchema::DeleteCache(aConn, mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    nsresult rv =  DBSchema::DeleteCache(aConn, mCacheId);
+    rv = FileUtils::BodyDeleteCacheDir(aDBDir, mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    // TODO: delete body data files
-
     return rv;
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE { }
 
 private:
   virtual ~DeleteOrphanedCacheAction() { }
@@ -224,53 +232,63 @@ public:
 
 private:
   virtual ~CheckCacheOrphanedAction() { }
   nsRefPtr<Manager> mManager;
   const CacheId mCacheId;
   bool mOrphaned;
 };
 
-class Manager::CacheMatchAction : public Manager::BaseAction
+class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
-    , mResponseOrVoid(void_t())
+    , mFoundResponse(false)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     return DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
-                                &mResponseOrVoid);
+                                &mFoundResponse, &mResponse);
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    aListener->OnCacheMatch(mRequestId, aRv, mResponseOrVoid);
+    if (!mFoundResponse) {
+      aListener->OnCacheMatch(mRequestId, aRv, nullptr);
+    } else {
+      aListener->OnCacheMatch(mRequestId, aRv, &mResponse);
+    }
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
-  PCacheResponseOrVoid mResponseOrVoid;
+  bool mFoundResponse;
+  SavedResponse mResponse;
 };
 
-class Manager::CacheMatchAllAction : public Manager::BaseAction
+class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, CacheId aCacheId,
                       const PCacheRequestOrVoid& aRequestOrVoid,
                       const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
@@ -278,80 +296,299 @@ public:
     , mParams(aParams)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     return DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid, mParams,
-                                   mResponses);
+                                   mSavedResponses);
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    aListener->OnCacheMatchAll(mRequestId, aRv, mResponses);
+    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses);
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAllAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
-  nsTArray<PCacheResponse> mResponses;
+  nsTArray<SavedResponse> mSavedResponses;
 };
 
-class Manager::CachePutAction : public Manager::BaseAction
+class Manager::CachePutAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAction(Manager* aManager, ListenerId aListenerId,
                  RequestId aRequestId, CacheId aCacheId,
-                 const PCacheRequest& aRequest, const PCacheResponse& aResponse)
-    : BaseAction(aManager, aListenerId, aRequestId)
+                 const PCacheRequest& aRequest,
+                 nsIInputStream* aRequestBodyStream,
+                 const PCacheResponse& aResponse,
+                 nsIInputStream* aResponseBodyStream)
+    : DBAction(DBAction::Existing, aManager->Origin(), aManager->BaseDomain())
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
+    , mRequestBodyStream(aRequestBodyStream)
     , mResponse(aResponse)
-    , mResponseOrVoid(void_t())
+    , mResponseBodyStream(aResponseBodyStream)
+    , mExpectedAsyncCopyCompletions(0)
   { }
 
-  virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
-                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
+                    mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    mozStorageTransaction trans(aConn, false,
+    MOZ_ASSERT(aResolver);
+    MOZ_ASSERT(aDBDir);
+    MOZ_ASSERT(aConn);
+    MOZ_ASSERT(!mResolver);
+    MOZ_ASSERT(!mDBDir);
+    MOZ_ASSERT(!mConn);
+
+    mResolver = aResolver;
+    mDBDir = aDBDir;
+    mConn = aConn;
+
+    mExpectedAsyncCopyCompletions = mRequestBodyStream ? 1 : 0;
+    mExpectedAsyncCopyCompletions += mResponseBodyStream ? 1 : 0;
+
+    if (mExpectedAsyncCopyCompletions < 1) {
+      mExpectedAsyncCopyCompletions = 1;
+      OnAsyncCopyComplete(NS_OK);
+      return;
+    }
+
+    nsresult rv = StartStreamCopy(mRequestBodyStream, &mRequestBodyId,
+                                  getter_AddRefs(mRequestBodyCopyContext));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+    MOZ_ASSERT(mRequestBodyCopyContext);
+
+    rv = StartStreamCopy(mResponseBodyStream, &mResponseBodyId,
+                         getter_AddRefs(mResponseBodyCopyContext));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                       mRequestBodyId);
+      mRequestBodyCopyContext = nullptr;
+      DoResolve(rv);
+      return;
+    }
+  }
+
+  void
+  OnAsyncCopyComplete(nsresult aRv)
+  {
+    MOZ_ASSERT(mConn);
+    MOZ_ASSERT(mResolver);
+    MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
+
+    // When DoResolve() is called below the "this" object can get destructed
+    // out from under us on the initiating thread.  Ensure that we cleanly
+    // run to completion in this scope before destruction.
+    nsRefPtr<Action> kungFuDeathGrip = this;
+
+    if (NS_FAILED(aRv)) {
+      DoResolve(aRv);
+      return;
+    }
+
+    mExpectedAsyncCopyCompletions -= 1;
+    if (mExpectedAsyncCopyCompletions > 0) {
+      return;
+    }
+
+    mRequestBodyCopyContext = nullptr;
+    mResponseBodyCopyContext = nullptr;
+
+    nsresult rv = NS_OK;
+
+    if (mRequestBodyStream) {
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mCacheId, mRequestBodyId);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        DoResolve(rv);
+        return;
+      }
+    }
+
+    if (mResponseBodyStream) {
+      rv = FileUtils::BodyFinalizeWrite(mDBDir, mCacheId, mResponseBodyId);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        DoResolve(rv);
+        return;
+      }
+    }
+
+    mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsresult rv = DBSchema::CachePut(aConn, mCacheId, mRequest, mResponse);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    nsTArray<nsID> deletedBodyIdList;
+    rv = DBSchema::CachePut(mConn, mCacheId, mRequest,
+                            mRequestBodyStream ? &mRequestBodyId : nullptr,
+                            mResponse,
+                            mResponseBodyStream ? &mResponseBodyId : nullptr,
+                            deletedBodyIdList, &mSavedResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+
+    rv = FileUtils::BodyDeleteFiles(mDBDir, mCacheId, deletedBodyIdList);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
 
     rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+
+    DoResolve(rv);
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(Action);
+    Listener* listener = mManager->GetListener(mListenerId);
+    mManager = nullptr;
+    if (!listener) {
+      return;
+    }
+    if (NS_FAILED(aRv)) {
+      listener->OnCachePut(mRequestId, aRv, nullptr);
+    } else {
+      listener->OnCachePut(mRequestId, aRv, &mSavedResponse);
+    }
+  }
+
+  virtual void
+  CancelOnTarget() MOZ_OVERRIDE
+  {
+    CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                     mRequestBodyId);
+    mRequestBodyCopyContext = nullptr;
+    CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
+                     mResponseBodyId);
+    mResponseBodyCopyContext = nullptr;
+    mConn = nullptr;
+    mResolver = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+private:
+  virtual ~CachePutAction() { }
+
+  nsresult
+  StartStreamCopy(nsIInputStream* aSource, nsID* aIdOut,
+                  nsISupports** aCopyContextOut)
+  {
+    MOZ_ASSERT(aIdOut);
+    MOZ_ASSERT(aCopyContextOut);
+    MOZ_ASSERT(mDBDir);
+
+    if (!aSource) {
+      return NS_OK;
+    }
+
+    nsresult rv = FileUtils::BodyStartWriteStream(mManager->Origin(),
+                                                  mManager->BaseDomain(),
+                                                  mDBDir,
+                                                  mCacheId,
+                                                  aSource,
+                                                  this,
+                                                  AsyncCopyCompleteFunc,
+                                                  aIdOut,
+                                                  aCopyContextOut);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    // TODO: replace this with a read stream of the written files
-    mResponseOrVoid = mResponse;
-
     return rv;
   }
 
-  virtual void
-  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  void
+  CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
+                   const nsID& aId)
   {
-    aListener->OnCachePut(mRequestId, aRv, mResponseOrVoid);
+    if (!aSource || !aCopyContext) {
+      return;
+    }
+    FileUtils::BodyCancelWrite(mDBDir, mCacheId, aId, aCopyContext);
   }
 
-protected:
-  virtual ~CachePutAction() { }
+  static void
+  AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
+  {
+    MOZ_ASSERT(aClosure);
+    CachePutAction* action = static_cast<CachePutAction*>(aClosure);
+    action->OnAsyncCopyComplete(aRv);
+  }
+
+  void
+  DoResolve(nsresult aRv)
+  {
+    if (NS_FAILED(aRv)) {
+      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
+                       mRequestBodyId);
+      CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
+                       mResponseBodyId);
+    }
+
+    mConn = nullptr;
+    mRequestBodyCopyContext = nullptr;
+    mResponseBodyCopyContext = nullptr;
+
+    nsRefPtr<Resolver> resolver;
+    mResolver.swap(resolver);
+
+    if (resolver) {
+      // This can trigger self desctruction if a self-ref is not held by the
+      // caller.
+      resolver->Resolve(aRv);
+    }
+  }
+
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
   const CacheId mCacheId;
   const PCacheRequest mRequest;
+  nsCOMPtr<nsIInputStream> mRequestBodyStream;
   const PCacheResponse mResponse;
-  PCacheResponseOrVoid mResponseOrVoid;
+  nsCOMPtr<nsIInputStream> mResponseBodyStream;
+  nsRefPtr<Resolver> mResolver;
+  nsCOMPtr<nsIFile> mDBDir;
+  nsCOMPtr<mozIStorageConnection> mConn;
+  uint32_t mExpectedAsyncCopyCompletions;
+  nsID mRequestBodyId;
+  nsCOMPtr<nsISupports> mRequestBodyCopyContext;
+  nsID mResponseBodyId;
+  nsCOMPtr<nsISupports> mResponseBodyCopyContext;
+  SavedResponse mSavedResponse;
 };
 
-class Manager::CacheDeleteAction : public Manager::BaseAction
+class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
@@ -362,18 +599,22 @@ public:
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
+    nsTArray<nsID> deletedBodyIdList;
     nsresult rv = DBSchema::CacheDelete(aConn, mCacheId, mRequest, mParams,
-                                        &mSuccess);
+                                        deletedBodyIdList, &mSuccess);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = FileUtils::BodyDeleteFiles(aDBDir, mCacheId, deletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mSuccess = false;
       return rv;
     }
 
@@ -381,24 +622,141 @@ public:
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     aListener->OnCacheDelete(mRequestId, aRv, mSuccess);
   }
 
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
 protected:
   virtual ~CacheDeleteAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   bool mSuccess;
 };
 
+class Manager::CacheReadBodyAction MOZ_FINAL : public Action
+{
+public:
+  CacheReadBodyAction(Manager* aManager, CacheId aCacheId,
+                      const nsID& aBodyId,
+                      nsIOutputStream* aStream)
+    : mManager(aManager)
+    , mCacheId(aCacheId)
+    , mBodyId(aBodyId)
+    , mStream(aStream)
+  { }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, nsIFile* aBaseDir) MOZ_OVERRIDE
+  {
+    mResolver = aResolver;
+
+    nsresult rv = aBaseDir->Append(NS_LITERAL_STRING("cache"));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+
+    rv = FileUtils::BodyStartReadStream(mManager->Origin(),
+                                        mManager->BaseDomain(),
+                                        aBaseDir, mCacheId, mBodyId,
+                                        mStream, this,
+                                        AsyncCopyCompleteFunc,
+                                        getter_AddRefs(mCopyContext));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+
+  }
+
+  void
+  OnAsyncCopyComplete(nsresult aRv)
+  {
+    MOZ_ASSERT(mResolver);
+
+    // When DoResolve() is called below the "this" object can get destructed
+    // out from under us on the initiating thread.  Ensure that we cleanly
+    // run to completion in this scope before destruction.
+    nsRefPtr<Action> kungFuDeathGrip = this;
+
+    DoResolve(aRv);
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(Action);
+    mManager = nullptr;
+  }
+
+  virtual void
+  CancelOnTarget() MOZ_OVERRIDE
+  {
+    if (mCopyContext) {
+      FileUtils::BodyCancelRead(mCopyContext);
+      mCopyContext = nullptr;
+      mStream->Close();
+    }
+    mResolver = nullptr;
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+private:
+  virtual ~CacheReadBodyAction() { }
+
+  static void
+  AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
+  {
+    MOZ_ASSERT(aClosure);
+    CacheReadBodyAction* action = static_cast<CacheReadBodyAction*>(aClosure);
+    action->OnAsyncCopyComplete(aRv);
+  }
+
+  void
+  DoResolve(nsresult aRv)
+  {
+    if (NS_FAILED(aRv)) {
+      if (mCopyContext) {
+        FileUtils::BodyCancelRead(mCopyContext);
+        mCopyContext = nullptr;
+        mStream->Close();
+      }
+    }
+
+    nsRefPtr<Resolver> resolver;
+    mResolver.swap(resolver);
+
+    if (resolver) {
+      // This can trigger self desctruction if a self-ref is not held by the
+      // caller.
+      resolver->Resolve(aRv);
+    }
+  }
+
+  nsRefPtr<Manager> mManager;
+  const CacheId mCacheId;
+  const nsID mBodyId;
+  nsCOMPtr<nsIOutputStream> mStream;
+  nsRefPtr<Resolver> mResolver;
+  nsCOMPtr<nsISupports> mCopyContext;
+};
+
 class Manager::StorageGetAction : public Manager::BaseAction
 {
 public:
   StorageGetAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, Namespace aNamespace,
                    const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
@@ -497,29 +855,29 @@ class Manager::StorageDeleteAction MOZ_F
 public:
   StorageDeleteAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, Namespace aNamespace,
                       const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mKey(aKey)
     , mCacheDeleted(false)
+    , mCacheId(0)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     bool exists;
-    CacheId cacheId;
     nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey, &exists,
-                                              &cacheId);
+                                              &mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!exists) {
       mCacheDeleted = false;
       return NS_OK;
     }
 
     rv = DBSchema::StorageForgetCache(aConn, mNamespace, mKey);
@@ -530,25 +888,38 @@ public:
 
     mCacheDeleted = true;
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    // TODO: check for Cache ref and remove orphan
+    if (mCacheDeleted) {
+      // If nothing is actively referencing this cache, then delete it
+      // completely from the database and filesystem.
+      uint32_t cacheRefCount = mManager->GetCacheIdRefCount(mCacheId);
+      printf_stderr("### ### storage forget cache:%d refcount:%u\n", mCacheId, cacheRefCount);
+      if (cacheRefCount < 1) {
+        mManager->CurrentContext()->CancelForCacheId(mCacheId);
+        nsRefPtr<Action> action =
+          new DeleteOrphanedCacheAction(mManager, mCacheId);
+        mManager->CurrentContext()->Dispatch(mManager->mIOThread, action);
+      }
+    }
+
     aListener->OnStorageDelete(mRequestId, aRv, mCacheDeleted);
   }
 
 private:
   virtual ~StorageDeleteAction() { }
   const Namespace mNamespace;
   const nsString mKey;
   bool mCacheDeleted;
+  CacheId mCacheId;
 };
 
 class Manager::StorageKeysAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageKeysAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, Namespace aNamespace)
     : BaseAction(aManager, aListenerId, aRequestId)
@@ -622,16 +993,29 @@ Manager::ReleaseCacheId(CacheId aCacheId
         CurrentContext()->Dispatch(mIOThread, action);
       }
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release CacheId that is not referenced!");
 }
 
+uint32_t
+Manager::GetCacheIdRefCount(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
+      return mCacheIdRefs[i].mCount;
+    }
+  }
+  return 0;
+}
+
 void
 Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
@@ -651,40 +1035,55 @@ Manager::CacheMatchAll(Listener* aListen
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
                                                     aCacheId, aRequest, aParams);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
-                  const PCacheResponse& aResponse)
+                  nsIInputStream* aRequestBodyStream,
+                  const PCacheResponse& aResponse,
+                  nsIInputStream* aResponseBodyStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
-                                               aCacheId, aRequest, aResponse);
+                                               aCacheId,
+                                               aRequest, aRequestBodyStream,
+                                               aResponse, aResponseBodyStream);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
-Manager::CacheDelete(Listener* aListener, const RequestId& aRequestId,
+Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheDeleteAction(this, listenerId, aRequestId,
                                                   aCacheId, aRequest, aParams);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
+Manager::CacheReadBody(CacheId aCacheId, const nsID& aBodyId,
+                       nsIOutputStream* aStream)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aStream);
+  nsRefPtr<Action> action = new CacheReadBodyAction(this, aCacheId, aBodyId,
+                                                    aStream);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
 Manager::StorageGet(Listener* aListener, RequestId aRequestId,
                     Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageGetAction(this, listenerId, aRequestId,
                                                  aNamespace, aKey);
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -4,47 +4,48 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
+class nsIInputStream;
+class nsIOutputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheQueryParams;
-class PCacheRequest;
-class PCacheRequestOrVoid;
-class PCacheResponse;
-class PCacheResponseOrVoid;
+struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
 {
 public:
   class Listener
   {
   public:
     virtual ~Listener() { }
 
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                              const PCacheResponseOrVoid& aResponseOrVoid) { }
+                              const SavedResponse* aResponse) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                                 const nsTArray<PCacheResponse>& aResponses) { }
+                             const nsTArray<SavedResponse>& aSavedResponses) { }
     virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
-                            const PCacheResponseOrVoid& aResponseOrVoid) { }
+                            const SavedResponse* aSavedResponse) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
 
     virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound, CacheId aCacheId) { }
     virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound) { }
     virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
@@ -56,29 +57,35 @@ public:
   };
 
   static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
                                              const nsACString& aBaseDomain);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
+  uint32_t GetCacheIdRefCount(CacheId aCacheId);
 
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
   void CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
-                const PCacheRequest& aRequest, const PCacheResponse& aResponse);
-  void CacheDelete(Listener* aListener, const RequestId& aRequestId,
+                const PCacheRequest& aRequest,
+                nsIInputStream* aRequestBodyStream,
+                const PCacheResponse& aResponse,
+                nsIInputStream* aResponseBodyStream);
+  void CacheDelete(Listener* aListener, RequestId aRequestId,
                    CacheId aCacheId, const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams);
+  void CacheReadBody(CacheId aCacheId, const nsID& aBodyId,
+                     nsIOutputStream* aStream);
 
   void StorageGet(Listener* aListener, RequestId aRequestId,
                   Namespace aNamespace, const nsAString& aKey);
   void StorageHas(Listener* aListener, RequestId aRequestId,
                   Namespace aNamespace, const nsAString& aKey);
   void StorageCreate(Listener* aListener, RequestId aRequestId,
                      Namespace aNamespace, const nsAString& aKey);
   void StorageDelete(Listener* aListener, RequestId aRequestId,
@@ -97,16 +104,17 @@ private:
   class BaseAction;
   class CheckCacheOrphanedAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAction;
   class CacheDeleteAction;
+  class CacheReadBodyAction;
 
   class StorageGetAction;
   class StorageHasAction;
   class StorageCreateAction;
   class StorageDeleteAction;
   class StorageKeysAction;
 
   typedef uintptr_t ListenerId;
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/SavedTypes.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_SavedTypes_h
+#define mozilla_dom_cache_SavedTypes_h
+
+// NOTE: This cannot be rolled into Types.h because the IPC dependency.
+//       breaks webidl unified builds.
+
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIOutputStream.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+struct StreamHolder
+{
+  nsCOMPtr<nsIOutputStream> mValue;
+};
+
+struct SavedRequest
+{
+  SavedRequest() : mHasBodyId(false) { }
+  PCacheRequest mValue;
+  bool mHasBodyId;
+  nsID mBodyId;
+};
+
+struct SavedResponse
+{
+  SavedResponse() : mHasBodyId(false) { }
+  PCacheResponse mValue;
+  bool mHasBodyId;
+  nsID mBodyId;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_SavedTypes_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -13,33 +13,36 @@ EXPORTS.mozilla.dom.cache += [
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
+    'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'SavedTypes.h',
     'Types.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
+    'FileUtils.cpp',
     'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
