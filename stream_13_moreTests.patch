# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  ddc79d1330145c0cd8af3d24024a41ab3e2f11fe
Bug 1128959 - Implement the WHATWG Streams spec - part 13 - testing ReadableStream with more than 1mb of data, r?bkelly

diff --git a/dom/tests/mochitest/fetch/common_readableStreams.js b/dom/tests/mochitest/fetch/common_readableStreams.js
--- a/dom/tests/mochitest/fetch/common_readableStreams.js
+++ b/dom/tests/mochitest/fetch/common_readableStreams.js
@@ -1,8 +1,22 @@
+const BIG_BUFFER_SIZE = 1000000;
+
+function makeBuffer(size) {
+  let buffer = new Uint8Array(size);
+  buffer.fill(42);
+
+  let value = 0;
+  for (let i = 0; i < 1000000; i+= 1000) {
+    buffer.set([++value % 255], i);
+  }
+
+  return buffer;
+}
+
 function test_nativeStream() {
   info("test_nativeStream");
 
   fetch('/').then(r => {
     ok(r.body instanceof ReadableStream, "We have a ReadableStream");
 
     let a = r.clone();
     ok(a.body instanceof ReadableStream, "We have a ReadableStream");
@@ -20,18 +34,21 @@ function test_nativeStream() {
       ok(b instanceof Blob, "We have a blob");
     }).then(next);
   });
 }
 
 function test_nonNativeStream() {
   info("test_nonNativeStream");
 
+  let buffer = makeBuffer(BIG_BUFFER_SIZE);
+  info("Buffer size: " + buffer.byteLength);
+
   let r = new Response(new ReadableStream({start : controller => {
-    controller.enqueue(new Uint8Array([0x01, 0x00, 0x01]));
+    controller.enqueue(buffer);
     controller.close();
   }}));
 
   ok(r.body instanceof ReadableStream, "We have a ReadableStream");
 
   let a = r.clone();
   ok(a.body instanceof ReadableStream, "We have a ReadableStream");
 
@@ -41,16 +58,17 @@ function test_nonNativeStream() {
   r.blob().then(b => {
     ok(b instanceof Blob, "We have a blob");
     return a.body.getReader().read();
   }).then(d => {
     ok(!d.done, "We have read something!");
     return b.blob();
   }).then(b => {
     ok(b instanceof Blob, "We have a blob");
+    is(b.size, buffer.byteLength, "Blob size matches");
   }).then(next);
 }
 
 function test_noUint8Array() {
   info("test_noUint8Array");
 
   let r = new Response(new ReadableStream({start : controller => {
     controller.enqueue('hello world!');
@@ -63,17 +81,17 @@ function test_noUint8Array() {
     ok(false, "We cannot have a blob here!");
   }, () => {
     ok(true, "We cannot have a blob here!");
   }).then(next);
 }
 
 function test_pendingStream() {
   var r = new Response(new ReadableStream({start : controller => {
-    controller.enqueue(new Uint8Array([0x01, 0x00, 0x01]));
+    controller.enqueue(makeBuffer(BIG_BUFFER_SIZE));
     // Let's keep this controler open.
     self.ccc = controller;
   }}));
 
   r.body.getReader().read().then(d => {
     ok(!d.done, "We have read something!");
     close();
     next();
@@ -105,37 +123,40 @@ async function test_nativeStream_cache()
 };
 
 async function test_nonNativeStream_cache() {
   info("test_nonNativeStream_cache");
 
   let url = '/nonNativeStream';
 
   let cache = await caches.open('nonNativeStream');
+  let buffer = makeBuffer(BIG_BUFFER_SIZE);
+  info("Buffer size: " + buffer.byteLength);
 
   info("Storing a body as a string");
   let r = new Response(new ReadableStream({start : controller => {
-    controller.enqueue(new Uint8Array([0x01, 0x02, 0x03]));
+    controller.enqueue(buffer);
     controller.close();
   }}));
 
   await cache.put(url, r);
 
   info("Retrieving the stored value");
   let cacheResponse = await cache.match(url);
 
   info("Converting the response to text");
   let cacheBody = await cacheResponse.arrayBuffer();
 
   ok(cacheBody instanceof ArrayBuffer, "Body is an array buffer");
-  is(cacheBody.byteLength, 3, "Body length is correct");
+  is(cacheBody.byteLength, BIG_BUFFER_SIZE, "Body length is correct");
 
-  is(new Uint8Array(cacheBody)[0], 0x01, "First byte is correct");
-  is(new Uint8Array(cacheBody)[1], 0x02, "Second byte is correct");
-  is(new Uint8Array(cacheBody)[2], 0x03, "Third byte is correct");
+  let value = 0;
+  for (let i = 0; i < 1000000; i+= 1000) {
+    is(new Uint8Array(cacheBody)[i], ++value % 255, "byte in position " + i + " is correct");
+  }
 
   await caches.delete('nonNativeStream');
 
   next();
 };
 
 function workify(func) {
   info("Workifing " + func);
