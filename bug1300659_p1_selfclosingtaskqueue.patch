# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0a7af8d577e6fa125d870fc59644bbbdadd512c7
Bug 1300659 P1 Add a TaskQueue wrapper that automatically shuts down when appropriate. r=froydnj

diff --git a/xpcom/threads/SelfClosingTaskQueueTarget.cpp b/xpcom/threads/SelfClosingTaskQueueTarget.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/threads/SelfClosingTaskQueueTarget.cpp
@@ -0,0 +1,231 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SelfClosingTaskQueueTarget.h"
+
+#include "mozilla/Atomics.h"
+#include "mozilla/ClearOnShutdown.h"
+
+namespace mozilla {
+
+using mozilla::services::GetObserverService;
+
+namespace {
+
+static const char* kShutdownTopic = "xpcom-shutdown";
+
+} // anonymous namespace
+
+class SelfClosingTaskQueueTarget::Inner final : public nsIObserver
+{
+  // Written on the main thread, read from any thread
+  nsCOMPtr<nsIEventTarget> mBaseTarget;
+  RefPtr<TaskQueue> mTaskQueue;
+  nsCOMPtr<nsIEventTarget> mTaskQueueTarget;
+
+  // Written and read from any thread
+  Atomic<bool> mShutdownStarted;
+
+  Inner(nsIEventTarget* aBaseTarget, TaskQueue* aTaskQueue)
+    : mBaseTarget(aBaseTarget)
+    , mTaskQueue(aTaskQueue)
+    , mTaskQueueTarget(mTaskQueue->WrapAsEventTarget())
+    , mShutdownStarted(false)
+  {
+    MOZ_ASSERT(mTaskQueue);
+  }
+
+  ~Inner()
+  {
+    // We cannot call MaybeBeginShutdown() here because it AddRef's this.
+  }
+
+public:
+  static already_AddRefed<Inner>
+  Create(nsIEventTarget* aBaseTarget)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    if (ClearOnShutdown_Internal::sCurrentShutdownPhase != ShutdownPhase::NotInShutdown) {
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIObserverService> obs = GetObserverService();
+    if (NS_WARN_IF(!obs)) {
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIEventTarget> target(aBaseTarget);
+    RefPtr<TaskQueue> taskQueue =
+      new TaskQueue(target.forget(), false /* tail dispatch */);
+
+    RefPtr<Inner> ref = new Inner(aBaseTarget, taskQueue);
+
+    nsresult rv = obs->AddObserver(ref, kShutdownTopic, false /* weak ref */);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      taskQueue->BeginShutdown();
+      MOZ_ASSERT(taskQueue->IsEmpty());
+      return nullptr;
+    }
+
+    return ref.forget();
+  }
+
+  NS_IMETHOD
+  Observe(nsISupports*, const char* aTopic, const char16_t*) override
+  {
+    MOZ_ASSERT(!strcmp(aTopic, kShutdownTopic));
+
+    MaybeStartShutdown();
+
+    while (!mTaskQueue->IsEmpty()) {
+      MOZ_ALWAYS_TRUE(NS_ProcessNextEvent());
+    }
+
+    return NS_OK;
+  }
+
+  void
+  MaybeStartShutdown()
+  {
+    if (mShutdownStarted) {
+      return;
+    }
+
+    mShutdownStarted = true;
+
+    mTaskQueue->BeginShutdown()->Then(
+      AbstractThread::MainThread(), __func__, this,
+      &Inner::ShutdownComplete,
+      &Inner::ShutdownComplete
+    );
+  }
+
+  void
+  ShutdownComplete(bool)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(mTaskQueue->IsEmpty());
+
+    nsCOMPtr<nsIObserverService> obs = GetObserverService();
+
+    // This may cause immediate destruction of `this`.
+    obs->RemoveObserver(this, kShutdownTopic);
+  }
+
+  bool
+  IsEmpty() const
+  {
+    return mTaskQueue->IsEmpty();
+  }
+
+  uint32_t
+  ImpreciseLengthForHeuristics() const
+  {
+    return mTaskQueue->ImpreciseLengthForHeuristics();
+  }
+
+  nsresult
+  DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
+  {
+    nsIEventTarget* target = mShutdownStarted ? mBaseTarget : mTaskQueueTarget;
+    return target->DispatchFromScript(aEvent, aFlags);
+  }
+
+  nsresult
+  Dispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aFlags)
+  {
+    nsIEventTarget* target = mShutdownStarted ? mBaseTarget : mTaskQueueTarget;
+    return target->Dispatch(Move(aEvent), aFlags);
+  }
+
+  nsresult
+  DelayedDispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aFlags)
+  {
+    nsIEventTarget* target = mShutdownStarted ? mBaseTarget : mTaskQueueTarget;
+    return target->DelayedDispatch(Move(aEvent), aFlags);
+  }
+
+  nsresult
+  IsOnCurrentThread(bool* aResult)
+  {
+    nsIEventTarget* target = mShutdownStarted ? mBaseTarget : mTaskQueueTarget;
+    return target->IsOnCurrentThread(aResult);
+  }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(SelfClosingTaskQueueTarget::Inner, nsIObserver);
+
+NS_IMPL_ISUPPORTS(SelfClosingTaskQueueTarget, nsIEventTarget);
+
+SelfClosingTaskQueueTarget::SelfClosingTaskQueueTarget(already_AddRefed<Inner> aInner)
+  : mInner(aInner)
+{
+  MOZ_ASSERT(mInner);
+}
+
+SelfClosingTaskQueueTarget::~SelfClosingTaskQueueTarget()
+{
+  mInner->MaybeStartShutdown();
+}
+
+already_AddRefed<SelfClosingTaskQueueTarget>
+SelfClosingTaskQueueTarget::Create(nsIEventTarget* aBaseTarget)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(aBaseTarget);
+
+  RefPtr<Inner> inner = Inner::Create(aBaseTarget);
+  if (NS_WARN_IF(!inner)) {
+    return nullptr;
+  }
+
+  RefPtr<SelfClosingTaskQueueTarget> ref =
+    new SelfClosingTaskQueueTarget(inner.forget());
+  return ref.forget();
+}
+
+bool
+SelfClosingTaskQueueTarget::IsEmpty() const
+{
+  return mInner->IsEmpty();
+}
+
+uint32_t
+SelfClosingTaskQueueTarget::ImpreciseLengthForHeuristics() const
+{
+  return mInner->ImpreciseLengthForHeuristics();
+}
+
+NS_IMETHODIMP
+SelfClosingTaskQueueTarget::DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
+{
+  return mInner->DispatchFromScript(aEvent, aFlags);
+}
+
+NS_IMETHODIMP
+SelfClosingTaskQueueTarget::Dispatch(already_AddRefed<nsIRunnable> aEvent,
+                                     uint32_t aFlags)
+{
+  return mInner->Dispatch(Move(aEvent), aFlags);
+}
+
+NS_IMETHODIMP
+SelfClosingTaskQueueTarget::DelayedDispatch(already_AddRefed<nsIRunnable> aEvent,
+                                            uint32_t aFlags)
+{
+  return mInner->DelayedDispatch(Move(aEvent), aFlags);
+}
+
+NS_IMETHODIMP
+SelfClosingTaskQueueTarget::IsOnCurrentThread(bool* aResult)
+{
+  return mInner->IsOnCurrentThread(aResult);
+}
+
+} // namespace mozilla
diff --git a/xpcom/threads/SelfClosingTaskQueueTarget.h b/xpcom/threads/SelfClosingTaskQueueTarget.h
new file mode 100644
--- /dev/null
+++ b/xpcom/threads/SelfClosingTaskQueueTarget.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_SelfClosingTaskQueueTarget_h
+#define mozilla_SelfClosingTaskQueueTarget_h
+
+#include "nsIEventTarget.h"
+
+namespace mozilla {
+
+class TaskQueue;
+
+// An event target that implements TaskQueue semantics internally, but
+// automatically closes when necessary.  The TaskQueue will close if
+// this wrapper object is no longer referenced.  It will also close
+// if xpcom shutdown occurs.  In the shutdown case runnables will
+// be dispatched to the originl base target instead.
+class SelfClosingTaskQueueTarget final : public nsIEventTarget
+{
+  class Inner;
+  RefPtr<Inner> mInner;
+
+  explicit SelfClosingTaskQueueTarget(already_AddRefed<Inner> aInner);
+  ~SelfClosingTaskQueueTarget();
+
+public:
+  static already_AddRefed<SelfClosingTaskQueueTarget>
+  Create(nsIEventTarget* aBaseTarget);
+
+  bool
+  IsEmpty() const;
+
+  uint32_t
+  ImpreciseLengthForHeuristics() const;
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIEVENTTARGET
+};
+
+} // namespace mozilla
+
+#endif // mozilla_SelfClosingTaskQueueTarget_h
diff --git a/xpcom/threads/moz.build b/xpcom/threads/moz.build
--- a/xpcom/threads/moz.build
+++ b/xpcom/threads/moz.build
@@ -29,16 +29,17 @@ EXPORTS += [
 
 EXPORTS.mozilla += [
     'AbstractThread.h',
     'BackgroundHangMonitor.h',
     'HangAnnotations.h',
     'HangMonitor.h',
     'LazyIdleThread.h',
     'MozPromise.h',
+    'SelfClosingTaskQueueTarget.h',
     'SharedThreadPool.h',
     'StateMirroring.h',
     'StateWatching.h',
     'SyncRunnable.h',
     'TaskDispatcher.h',
     'TaskQueue.h',
 ]
 
@@ -51,16 +52,17 @@ UNIFIED_SOURCES += [
     'nsEnvironment.cpp',
     'nsEventQueue.cpp',
     'nsMemoryPressure.cpp',
     'nsProcessCommon.cpp',
     'nsThread.cpp',
     'nsThreadManager.cpp',
     'nsThreadPool.cpp',
     'nsTimerImpl.cpp',
+    'SelfClosingTaskQueueTarget.cpp',
     'SharedThreadPool.cpp',
     'TaskQueue.cpp',
     'ThreadStackHelper.cpp',
     'TimerThread.cpp',
 ]
 
 LOCAL_INCLUDES += [
     '../build',
