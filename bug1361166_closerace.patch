# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b205d4d208446612b1e4f6128bc0706e99e95dcf
Bug 1361166 Update mParentStatus synchronously when closing worker thread. r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -889,31 +889,16 @@ private:
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     bool ok = aWorkerPrivate->NotifyInternal(aCx, mStatus);
     MOZ_ASSERT(!JS_IsExceptionPending(aCx));
     return ok;
   }
 };
 
-class CloseRunnable final : public WorkerControlRunnable
-{
-public:
-  explicit CloseRunnable(WorkerPrivate* aWorkerPrivate)
-  : WorkerControlRunnable(aWorkerPrivate, ParentThreadUnchangedBusyCount)
-  { }
-
-private:
-  virtual bool
-  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
-  {
-    return aWorkerPrivate->Close();
-  }
-};
-
 class FreezeRunnable final : public WorkerControlRunnable
 {
 public:
   explicit FreezeRunnable(WorkerPrivate* aWorkerPrivate)
   : WorkerControlRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
   { }
 
 private:
@@ -3291,24 +3276,20 @@ WorkerPrivateParent<Derived>::ParentWind
     }
   }
 }
 
 template <class Derived>
 bool
 WorkerPrivateParent<Derived>::Close()
 {
-  AssertIsOnParentThread();
-
-  {
-    MutexAutoLock lock(mMutex);
-
-    if (mParentStatus < Closing) {
-      mParentStatus = Closing;
-    }
+  mMutex.AssertCurrentThreadOwns();
+
+  if (mParentStatus < Closing) {
+    mParentStatus = Closing;
   }
 
   return true;
 }
 
 template <class Derived>
 bool
 WorkerPrivateParent<Derived>::ModifyBusyCount(bool aIncrease)
@@ -6160,16 +6141,22 @@ WorkerPrivate::NotifyInternal(JSContext*
     if (mStatus >= aStatus) {
       MOZ_ASSERT(!mEventTarget);
       return true;
     }
 
     previousStatus = mStatus;
     mStatus = aStatus;
 
+    // Mark parent status as closing immediately to avoid new events being
+    // dispatched after we clear the queue below.
+    if (aStatus == Closing) {
+      Close();
+    }
+
     mEventTarget.swap(eventTarget);
   }
 
   // Now that mStatus > Running, no-one can create a new WorkerEventTarget or
   // WorkerCrossThreadDispatcher if we don't already have one.
   if (eventTarget) {
     // Since we'll no longer process events, make sure we no longer allow anyone
     // to post them. We have to do this without mMutex held, since our mutex
@@ -6207,24 +6194,18 @@ WorkerPrivate::NotifyInternal(JSContext*
   }
 
   // If the worker script never ran, or failed to compile, we don't need to do
   // anything else.
   if (!GlobalScope()) {
     return true;
   }
 
+  // Don't abort the script.
   if (aStatus == Closing) {
-    // Notify parent to stop sending us messages and balance our busy count.
-    RefPtr<CloseRunnable> runnable = new CloseRunnable(this);
-    if (!runnable->Dispatch()) {
-      return false;
-    }
-
-    // Don't abort the script.
     return true;
   }
 
   MOZ_ASSERT(aStatus == Terminating ||
              aStatus == Canceling ||
              aStatus == Killing);
 
   // Always abort the script.
