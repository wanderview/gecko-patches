# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  826891a1b2a5a26b0d2d5641eb97658a589b758e
Bug 1204254 P1 Add an nsIInterceptedChannel::StartSynthesizedResponse() method. r=asuth

diff --git a/netwerk/base/nsINetworkInterceptController.idl b/netwerk/base/nsINetworkInterceptController.idl
--- a/netwerk/base/nsINetworkInterceptController.idl
+++ b/netwerk/base/nsINetworkInterceptController.idl
@@ -49,16 +49,18 @@ interface nsIInterceptedChannel : nsISup
     void synthesizeStatus(in uint16_t status, in ACString reason);
 
     /**
      * Attach a header name/value pair to the forthcoming synthesized response.
      * Overwrites any existing header value.
      */
     void synthesizeHeader(in ACString name, in ACString value);
 
+    void startSynthesizedResponse(in ACString finalURLSpec);
+
     /**
      * Instruct a channel that has been intercepted that a response has been
      * synthesized and can now be read. No further header modification is allowed
      * after this point. The caller may optionally pass a spec for a URL that
      * this response originates from; an empty string will cause the original
      * intercepted request's URL to be used instead.
      */
     void finishSynthesizedResponse(in ACString finalURLSpec);
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -278,29 +278,22 @@ InterceptedChannelContent::SynthesizeHea
   if (!mResponseBody) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
-InterceptedChannelContent::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedChannelContent::StartSynthesizedResponse(const nsACString& aFinalURLSpec)
 {
   if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // Make sure the body output stream is always closed.  If the channel was
-  // intercepted with a null-body response then its possible the synthesis
-  // completed without a stream copy operation.
-  mResponseBody->Close();
-
-  mReportCollector->FlushConsoleReports(mChannel);
-
   EnsureSynthesizedResponse();
 
   nsCOMPtr<nsIURI> originalURI;
   mChannel->GetURI(getter_AddRefs(originalURI));
 
   nsCOMPtr<nsIURI> responseURI;
   if (!aFinalURLSpec.IsEmpty()) {
     nsresult rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
@@ -319,16 +312,36 @@ InterceptedChannelContent::FinishSynthes
     mChannel->ForceIntercepted(mSynthesizedInput);
     mChannel->BeginNonIPCRedirect(responseURI, *mSynthesizedResponseHead.ptr());
   } else {
     mChannel->OverrideWithSynthesizedResponse(mSynthesizedResponseHead.ref(),
                                               mSynthesizedInput,
                                               mStreamListener);
   }
 
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+InterceptedChannelContent::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+{
+  if (NS_WARN_IF(mClosed)) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  // Make sure the body output stream is always closed.  If the channel was
+  // intercepted with a null-body response then its possible the synthesis
+  // completed without a stream copy operation.
+  mResponseBody->Close();
+
+  mReportCollector->FlushConsoleReports(mChannel);
+
+  nsresult rv = StartSynthesizedResponse(aFinalURLSpec);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   mResponseBody = nullptr;
   mStreamListener = nullptr;
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -182,16 +182,17 @@ class InterceptedChannelContent : public
   bool mSecureUpgrade;
 public:
   InterceptedChannelContent(HttpChannelChild* aChannel,
                             nsINetworkInterceptController* aController,
                             InterceptStreamListener* aListener,
                             bool aSecureUpgrade);
 
   NS_IMETHOD ResetInterception() override;
+  NS_IMETHOD StartSynthesizedResponse(const nsACString& aFinalURLSpec) override;
   NS_IMETHOD FinishSynthesizedResponse(const nsACString& aFinalURLSpec) override;
   NS_IMETHOD GetChannel(nsIChannel** aChannel) override;
   NS_IMETHOD GetSecureUpgradedChannelURI(nsIURI** aURI) override;
   NS_IMETHOD SynthesizeStatus(uint16_t aStatus, const nsACString& aReason) override;
   NS_IMETHOD SynthesizeHeader(const nsACString& aName, const nsACString& aValue) override;
   NS_IMETHOD CancelInterception(nsresult aStatus) override;
   NS_IMETHOD SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo) override;
   NS_IMETHOD GetInternalContentPolicyType(nsContentPolicyType *aInternalContentPolicyType) override;
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -545,26 +545,22 @@ InterceptedHttpChannel::SynthesizeHeader
   nsAutoCString header = aName + NS_LITERAL_CSTRING(": ") + aValue;
   // Overwrite any existing header.
   nsresult rv = mSynthesizedResponseHead->ParseHeaderLine(header);
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 NS_IMETHODIMP
-InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedHttpChannel::StartSynthesizedResponse(const nsACString& aFinalURLSpec)
 {
   if (mCanceled) {
     return mStatus;
   }
 
-  if (mBodyWriter) {
-    mBodyWriter->Close();
-  }
-
   if (!mSynthesizedResponseHead) {
     mSynthesizedResponseHead.reset(new nsHttpResponseHead());
   }
 
   mResponseHead = mSynthesizedResponseHead.release();
 
   if (ShouldRedirect()) {
     return FollowSyntheticRedirect();
@@ -591,16 +587,30 @@ InterceptedHttpChannel::FinishSynthesize
   if (!equal) {
     return RedirectForOpaqueResponse(responseURI);
   }
 
   return StartPump();
 }
 
 NS_IMETHODIMP
+InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+{
+  if (mCanceled) {
+    return mStatus;
+  }
+
+  if (mBodyWriter) {
+    mBodyWriter->Close();
+  }
+
+  return StartSynthesizedResponse(aFinalURLSpec);
+}
+
+NS_IMETHODIMP
 InterceptedHttpChannel::CancelInterception(nsresult aStatus)
 {
   if (mCanceled) {
     return NS_OK;
   }
   mCanceled = true;
 
   MOZ_DIAGNOSTIC_ASSERT(NS_FAILED(aStatus));
