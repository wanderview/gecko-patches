# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fbd279d827a355adab09f2f860e6fdf46be6415c

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -92,17 +92,17 @@ TimeoutExecutor::ScheduleDelayed(const T
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
 {
   TimeStamp now(TimeStamp::Now());
 
   // Schedule an immediate runnable if the desired deadline has passed
   // or is slightly in the future.  This is similar to how nsITimer will
   // fire timers early based on the interval resolution.
-  if (aDeadline <= now) {
+  if (aDeadline <= (now + nsITimer::EarlyFiringDuration())) {
     return ScheduleImmediate(aDeadline, now);
   }
 
   return ScheduleDelayed(aDeadline, now);
 }
 
 nsresult
 TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
@@ -135,18 +135,19 @@ TimeoutExecutor::MaybeExecute()
 
   TimeStamp deadline(mDeadline);
 
   // Sometimes nsITimer or canceled timers will fire too early.  If this
   // happens then just cap our deadline to our maximum time in the future
   // and proceed.  If there are no timers ready we will get rescheduled
   // by TimeoutManager.
   TimeStamp now(TimeStamp::Now());
-  if (deadline > now) {
-    deadline = now;
+  TimeStamp limit = now + nsITimer::EarlyFiringDuration();
+  if (deadline > limit) {
+    deadline = limit;
   }
 
   Cancel();
 
   mOwner->RunTimeout(now, deadline);
 }
 
 TimeoutExecutor::TimeoutExecutor(TimeoutManager* aOwner)
diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -406,16 +406,18 @@ TimerThread::Run()
   MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution) == 1);
 
   // Half of the amount of microseconds needed to get positive PRIntervalTime.
   // We use this to decide how to round our wait times later
   TimeDuration halfIntervalResolution(
     TimeDuration::FromMicroseconds(usIntervalResolution / 2));
   bool forceRunNextTimer = false;
 
+  mEarlyFiringDuration = TimeDuration::FromMicroseconds(usIntervalResolution / 2);
+
   while (!mShutdown) {
     TimeDuration waitFor(TimeDuration::Forever());
     bool forceRunThisTimer = forceRunNextTimer;
     forceRunNextTimer = false;
 
     if (mSleeping) {
       // Sleep for 0.1 seconds while not firing timers.
       uint32_t milliseconds = 100;
@@ -757,8 +759,14 @@ TimerThread::Observe(nsISupports* /* aSu
     DoBeforeSleep();
   } else if (strcmp(aTopic, "wake_notification") == 0 ||
              strcmp(aTopic, "resume_process_notification") == 0) {
     DoAfterSleep();
   }
 
   return NS_OK;
 }
+
+const TimeDuration&
+TimerThread::EarlyFiringDuration() const
+{
+  return mEarlyFiringDuration;
+}
diff --git a/xpcom/threads/TimerThread.h b/xpcom/threads/TimerThread.h
--- a/xpcom/threads/TimerThread.h
+++ b/xpcom/threads/TimerThread.h
@@ -50,16 +50,19 @@ public:
   void DoBeforeSleep();
   void DoAfterSleep();
 
   bool IsOnTimerThread() const
   {
     return mThread == NS_GetCurrentThread();
   }
 
+  const TimeDuration&
+  EarlyFiringDuration() const;
+
 private:
   ~TimerThread();
 
   bool    mInitialized;
 
   // These internal helper methods must be called while mMonitor is held.
   // AddTimerInternal returns false if the insertion failed.
   bool    AddTimerInternal(nsTimerImpl* aTimer);
@@ -110,16 +113,17 @@ private:
     {
       // This is reversed because std::push_heap() sorts the "largest" to
       // the front of the heap.  We want that to be the earliest timer.
       return aRight->mTimeout < aLeft->mTimeout;
     }
   };
 
   nsTArray<UniquePtr<Entry>> mTimers;
+  TimeDuration mEarlyFiringDuration;
 };
 
 struct TimerAdditionComparator
 {
   TimerAdditionComparator(const mozilla::TimeStamp& aNow,
                           nsTimerImpl* aTimerToInsert) :
     now(aNow)
 #ifdef DEBUG
diff --git a/xpcom/threads/nsITimer.idl b/xpcom/threads/nsITimer.idl
--- a/xpcom/threads/nsITimer.idl
+++ b/xpcom/threads/nsITimer.idl
@@ -246,16 +246,18 @@ interface nsITimer : nsISupports
    * target may only be set before the call to one of the init methods above.
    *
    * By default the target is the thread that created the timer.
    */
   attribute nsIEventTarget target;
 
 %{C++
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const = 0;
+
+  static mozilla::TimeDuration EarlyFiringDuration();
 %}
 };
 
 %{C++
 #define NS_TIMER_CONTRACTID "@mozilla.org/timer;1"
 #define NS_TIMER_CALLBACK_TOPIC "timer-callback"
 %}
 
diff --git a/xpcom/threads/nsTimerImpl.cpp b/xpcom/threads/nsTimerImpl.cpp
--- a/xpcom/threads/nsTimerImpl.cpp
+++ b/xpcom/threads/nsTimerImpl.cpp
@@ -727,8 +727,17 @@ nsTimerImpl::GetTLSTraceInfo()
 TracedTaskCommon
 nsTimerImpl::GetTracedTask()
 {
   return mTracedTask;
 }
 
 #endif
 
+/* static */
+TimeDuration
+nsITimer::EarlyFiringDuration()
+{
+  if (!gThread) {
+    return TimeDuration(0);
+  }
+  return gThread->EarlyFiringDuration();
+}
