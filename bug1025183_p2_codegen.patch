# HG changeset patch
# Parent b02854a7c0f035dc3f36436fccef3c5c0f7160ec
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/BindingUtils.h b/dom/bindings/BindingUtils.h
--- a/dom/bindings/BindingUtils.h
+++ b/dom/bindings/BindingUtils.h
@@ -23,16 +23,17 @@
 #include "mozilla/dom/workers/Workers.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Likely.h"
 #include "mozilla/MemoryReporting.h"
 #include "nsCycleCollector.h"
 #include "nsIXPConnect.h"
 #include "MainThreadUtils.h"
 #include "nsISupportsImpl.h"
+#include "nsUTF8Utils.h"
 #include "qsObjectHelper.h"
 #include "xpcpublic.h"
 #include "nsIVariant.h"
 #include "pldhash.h" // For PLDHashOperator
 
 #include "nsWrapperCacheInlines.h"
 
 class nsIJSID;
@@ -1763,31 +1764,125 @@ private:
                     "Offset of mLength should match");
       static_assert(offsetof(FakeDependentString, mFlags) ==
                       offsetof(DepedentStringAsserter, mFlags),
                     "Offset of mFlags should match");
     }
   };
 };
 
+struct ScalarValueString {
+  ScalarValueString()
+  : mConverted(false)
+  {
+  }
+
+  void Truncate() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.Truncate();
+  }
+
+  void SetNull() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.SetNull();
+  }
+
+  void SetData(const nsDependentString::char_type* aData,
+               nsDependentString::size_type aLength)
+  {
+    const nsDependentString::char_type* nextChar = aData;
+    const nsDependentString::char_type* end = aData + aLength;
+    const nsDependentString::char_type* lastChar;
+    uint32_t enumerated;
+
+    // Begin scanning string to see if any conversion is needed
+    do {
+      lastChar = nextChar;
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+    } while(enumerated && enumerated != REPLACEMENT_CHAR);
+
+    // If no conversion is needed, then just store a ref in our fake string
+    if (enumerated != REPLACEMENT_CHAR) {
+      mFakeDependentString.SetData(aData, aLength);
+      return;
+    }
+
+    mConvertedString.SetCapacity(aLength);
+
+    // Copy in the section of the string we already scanned that did
+    // not need fixing.
+    mConvertedString.Append(aData, end - lastChar);
+
+    // Copy in the last char which needed conversion
+    mConvertedString.Append(enumerated);
+
+    // Complete scanning the string for further conversions
+    do {
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+      mConvertedString.Append(enumerated);
+    } while(enumerated);
+
+    mConverted = true;
+  }
+
+  const nsDependentString::char_type* Data() const
+  {
+    if (mConverted) {
+      return mConvertedString.get();
+    }
+    return mFakeDependentString.Data();
+  }
+
+  nsDependentString::size_type Length() const
+  {
+    if (mConverted) {
+      return mConvertedString.Length();
+    }
+    return mFakeDependentString.Length();
+  }
+
+  const nsAString* ToAStringPtr() const {
+    if (mConverted) {
+      return &mConvertedString;
+    }
+    return mFakeDependentString.ToAStringPtr();
+  }
+
+  operator const nsAString& () const {
+    if (mConverted) {
+      return mConvertedString;
+    }
+    return mFakeDependentString;
+  }
+
+  static const char16_t REPLACEMENT_CHAR = 0xFFFD;
+
+  bool mConverted;
+  binding_detail::FakeDependentString mFakeDependentString;
+  nsString mConvertedString;
+};
+
 } // namespace binding_detail
 
 enum StringificationBehavior {
   eStringify,
   eEmpty,
   eNull
 };
 
 // pval must not be null and must point to a rooted JS::Value
+template <typename StringType>
 static inline bool
 ConvertJSValueToString(JSContext* cx, JS::Handle<JS::Value> v,
                        JS::MutableHandle<JS::Value> pval,
                        StringificationBehavior nullBehavior,
                        StringificationBehavior undefinedBehavior,
-                       binding_detail::FakeDependentString& result)
+                       StringType& result)
 {
   JSString *s;
   if (v.isString()) {
     s = v.toString();
   } else {
     StringificationBehavior behavior;
     if (v.isNull()) {
       behavior = nullBehavior;
diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4470,16 +4470,79 @@ def getJSToNativeConversionInfo(type, de
         # ByteString arguments cannot have a default value.
         assert defaultValue is None
 
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric("nsCString"),
             dealWithOptional=isOptional)
 
+    if type.isScalarValueString():
+        assert not isEnforceRange and not isClamp
+
+        nullable = toStringBool(type.nullable())
+
+        def getConversionCode(varName):
+            conversionCode = (
+                "if (!ConvertJSValueToString(cx, ${val}, ${mutableVal}, %s, %s, %s)) {\n"
+                "%s"
+                "}\n" % ("eStringify", "eStringify", varName, exceptionCodeIndented.define()))
+
+            if defaultValue is None:
+                return conversionCode
+
+            if isinstance(defaultValue, IDLNullValue):
+                assert(type.nullable())
+                defaultCode = "%s.SetNull()" % varName
+            else:
+                defaultCode = handleDefaultStringValue(defaultValue,
+                                                       "%s.SetData" % varName)
+            return handleDefault(conversionCode, defaultCode + ";\n")
+
+        if isMember:
+            # We have to make a copy, except in the variadic case, because our
+            # jsval may well not live as long as our string needs to.
+            declType = CGGeneric("nsString")
+            if isMember == "Variadic":
+                # The string is kept alive by the argument, so we can just
+                # depend on it.
+                assignString = "${declName}.Rebind(str.Data(), str.Length());\n"
+            else:
+                assignString = "${declName} = str;\n"
+            return JSToNativeConversionInfo(
+                fill(
+                    """
+                    {
+                      binding_detail::ScalarValueString str;
+                      $*{convert}
+                      $*{assign}
+                    }
+                    """,
+                    convert=getConversionCode("str"),
+                    assign=assignString),
+                declType=declType,
+                dealWithOptional=isOptional)
+
+        if isOptional:
+            declType = "Optional<nsAString>"
+            holderType = CGGeneric("binding_detail::ScalarValueString")
+            conversionCode = ("%s"
+                              "${declName} = ${holderName}.ToAStringPtr();\n" %
+                              getConversionCode("${holderName}"))
+        else:
+            declType = "binding_detail::ScalarValueString"
+            holderType = None
+            conversionCode = getConversionCode("${declName}")
+
+        # No need to deal with optional here; we handled it already
+        return JSToNativeConversionInfo(
+            conversionCode,
+            declType=CGGeneric(declType),
+            holderType=holderType)
+
     if type.isEnum():
         assert not isEnforceRange and not isClamp
 
         enumName = type.unroll().inner.identifier.name
         declType = CGGeneric(enumName)
         if type.nullable():
             declType = CGTemplatedType("Nullable", declType)
             declType = declType.define()
@@ -5345,16 +5408,22 @@ def getWrapTemplateForType(type, descrip
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("NonVoidByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
+    if type.isScalarValueString():
+        if type.nullable():
+            return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+        else:
+            return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+
     if type.isEnum():
         if type.nullable():
             resultLoc = "%s.Value()" % result
         else:
             resultLoc = result
         conversion = fill(
             """
             {
@@ -5611,16 +5680,18 @@ def getRetvalDeclarationForType(returnTy
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isDOMString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
+    if returnType.isScalarValueString():
+        return CGGeneric("DOMString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isGeckoInterface():
         result = CGGeneric(descriptorProvider.getDescriptor(
             returnType.unroll().inner.identifier.name).nativeType)
@@ -7980,16 +8051,19 @@ def getUnionAccessorSignatureType(type, 
         return CGWrapper(typeName, post="&")
 
     if type.isDOMString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
+    if type.isScalarValueString():
+        return CGGeneric("const nsAString&")
+
     if type.isEnum():
         if type.nullable():
             raise TypeError("We don't support nullable enumerated arguments or "
                             "union members yet")
         return CGGeneric(type.inner.identifier.name)
 
     if type.isCallback():
         if type.nullable():
@@ -11549,16 +11623,22 @@ class CGNativeMember(ClassMethod):
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsCString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
+        if type.isScalarValueString():
+            if isMember:
+                # No need for a third element in the isMember case
+                return "nsString", None, None
+            # Outparam
+            return "void", "", "aRetVal = ${declName};\n"
         if type.isEnum():
             enumName = type.unroll().inner.identifier.name
             if type.nullable():
                 enumName = CGTemplatedType("Nullable",
                                            CGGeneric(enumName)).define()
                 defaultValue = "%s()" % enumName
             else:
                 defaultValue = "%s(0)" % enumName
@@ -11661,16 +11741,18 @@ class CGNativeMember(ClassMethod):
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
         if returnType.isDOMString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
+        elif returnType.isScalarValueString():
+            args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
             elementDecl = self.getReturnType(returnType.inner, True)
             type = CGTemplatedType("nsTArray", CGGeneric(elementDecl))
             if nullable:
@@ -11794,16 +11876,23 @@ class CGNativeMember(ClassMethod):
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
             return declType, True, False
 
+        if type.isScalarValueString():
+            if isMember:
+                declType = "nsString"
+            else:
+                declType = "nsAString"
+            return declType, True, False
+
         if type.isEnum():
             return type.unroll().inner.identifier.name, False, True
 
         if type.isCallback() or type.isCallbackInterface():
             forceOwningType = optional or isMember
             if type.nullable():
                 if forceOwningType:
                     declType = "nsRefPtr<%s>"
@@ -13572,17 +13661,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -13732,16 +13821,18 @@ class CGEventClass(CGBindingImplClass):
                     nativeType = m.type.unroll().inner.identifier.name
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable",
                                                      CGGeneric(nativeType)).define()
                 elif m.type.isDOMString():
                     nativeType = "nsString"
                 elif m.type.isByteString():
                     nativeType = "nsCString"
+                elif m.type.isScalarValueString():
+                    nativeType = "nsString"
                 elif m.type.isGeckoInterface():
                     iface = m.type.unroll().inner
                     nativeType = self.descriptor.getDescriptor(
                         iface.identifier.name).nativeType
                     # Now trim off unnecessary namespaces
                     nativeType = nativeType.split("::")
                     if nativeType[0] == "mozilla":
                         nativeType.pop(0)
diff --git a/dom/bindings/parser/WebIDL.py b/dom/bindings/parser/WebIDL.py
--- a/dom/bindings/parser/WebIDL.py
+++ b/dom/bindings/parser/WebIDL.py
@@ -2622,16 +2622,18 @@ class IDLValue(IDLObject):
             return self
         elif self.type.isFloat() and type.isFloat():
             if (not type.isUnrestricted() and
                 (self.value == float("inf") or self.value == float("-inf") or
                  math.isnan(self.value))):
                 raise WebIDLError("Trying to convert unrestricted value %s to non-unrestricted"
                                   % self.value, [location]);
             return self
+        elif self.type.isString() and type.isString():
+            return self
         raise WebIDLError("Cannot coerce type %s to type %s." %
                           (self.type, type), [location])
 
     def _getDependentObjects(self):
         return set()
 
 class IDLNullValue(IDLObject):
     def __init__(self, location):
diff --git a/dom/bindings/test/TestBindingHeader.h b/dom/bindings/test/TestBindingHeader.h
--- a/dom/bindings/test/TestBindingHeader.h
+++ b/dom/bindings/test/TestBindingHeader.h
@@ -454,24 +454,35 @@ public:
   // DOMString types
   void PassString(const nsAString&);
   void PassNullableString(const nsAString&);
   void PassOptionalString(const Optional<nsAString>&);
   void PassOptionalStringWithDefaultValue(const nsAString&);
   void PassOptionalNullableString(const Optional<nsAString>&);
   void PassOptionalNullableStringWithDefaultValue(const nsAString&);
   void PassVariadicString(const Sequence<nsString>&);
+  void ReceiveString(DOMString&);
 
   // ByteString types
   void PassByteString(const nsCString&);
   void PassNullableByteString(const nsCString&);
   void PassOptionalByteString(const Optional<nsCString>&);
   void PassOptionalNullableByteString(const Optional<nsCString>&);
   void PassVariadicByteString(const Sequence<nsCString>&);
 
+  // ScalarValueString types
+  void PassSVS(const nsAString&);
+  void PassNullableSVS(const nsAString&);
+  void PassOptionalSVS(const Optional<nsAString>&);
+  void PassOptionalSVSWithDefaultValue(const nsAString&);
+  void PassOptionalNullableSVS(const Optional<nsAString>&);
+  void PassOptionalNullableSVSWithDefaultValue(const nsAString&);
+  void PassVariadicSVS(const Sequence<nsString>&);
+  void ReceiveSVS(DOMString&);
+
   // Enumerated types
   void PassEnum(TestEnum);
   void PassNullableEnum(const Nullable<TestEnum>&);
   void PassOptionalEnum(const Optional<TestEnum>&);
   void PassEnumWithDefault(TestEnum);
   void PassOptionalNullableEnum(const Optional<Nullable<TestEnum> >&);
   void PassOptionalNullableEnumWithDefaultValue(const Nullable<TestEnum>&);
   void PassOptionalNullableEnumWithDefaultValue2(const Nullable<TestEnum>&);
diff --git a/dom/bindings/test/TestCodeGen.webidl b/dom/bindings/test/TestCodeGen.webidl
--- a/dom/bindings/test/TestCodeGen.webidl
+++ b/dom/bindings/test/TestCodeGen.webidl
@@ -415,24 +415,35 @@ interface TestInterface {
   // DOMString types
   void passString(DOMString arg);
   void passNullableString(DOMString? arg);
   void passOptionalString(optional DOMString arg);
   void passOptionalStringWithDefaultValue(optional DOMString arg = "abc");
   void passOptionalNullableString(optional DOMString? arg);
   void passOptionalNullableStringWithDefaultValue(optional DOMString? arg = null);
   void passVariadicString(DOMString... arg);
+  DOMString receiveString();
 
   // ByteString types
   void passByteString(ByteString arg);
   void passNullableByteString(ByteString? arg);
   void passOptionalByteString(optional ByteString arg);
   void passOptionalNullableByteString(optional ByteString? arg);
   void passVariadicByteString(ByteString... arg);
 
+  // ScalarValueString types
+  void passSVS(ScalarValueString arg);
+  void passNullableSVS(ScalarValueString? arg);
+  void passOptionalSVS(optional ScalarValueString arg);
+  void passOptionalSVSWithDefaultValue(optional ScalarValueString arg = "abc");
+  void passOptionalNullableSVS(optional ScalarValueString? arg);
+  void passOptionalNullableSVSWithDefaultValue(optional ScalarValueString? arg = null);
+  void passVariadicSVS(ScalarValueString... arg);
+  ScalarValueString receiveSVS();
+
   // Enumerated types
   void passEnum(TestEnum arg);
   void passNullableEnum(TestEnum? arg);
   void passOptionalEnum(optional TestEnum arg);
   void passEnumWithDefault(optional TestEnum arg = "a");
   void passOptionalNullableEnum(optional TestEnum? arg);
   void passOptionalNullableEnumWithDefaultValue(optional TestEnum? arg = null);
   void passOptionalNullableEnumWithDefaultValue2(optional TestEnum? arg = "a");
