# HG changeset patch
# Parent 315fdebd893dddc484c0d7301373a39fc0252153
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4472,16 +4472,79 @@ def getJSToNativeConversionInfo(type, de
         # ByteString arguments cannot have a default value.
         assert defaultValue is None
 
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric("nsCString"),
             dealWithOptional=isOptional)
 
+    if type.isScalarValueString():
+        assert not isEnforceRange and not isClamp
+
+        nullable = toStringBool(type.nullable())
+
+        def getConversionCode(varName):
+            conversionCode = (
+                "if (!ConvertJSValueToScalarValueString(cx, ${val}, ${mutableVal}, %s, ${declName})) {\n"
+                "%s"
+                "}\n" % (nullable, exceptionCodeIndented.define()))
+
+            if defaultValue is None:
+                return conversionCode
+
+            if isinstance(defaultValue, IDLNullValue):
+                assert(type.nullable())
+                defaultCode = "%s.SetNull()" % varName
+            else:
+                defaultCode = handleDefaultStringValue(defaultValue,
+                                                       "%s.SetData" % varName)
+            return handleDefault(conversionCode, defaultCode + ";\n")
+
+        if isMember:
+            # We have to make a copy, except in the variadic case, because our
+            # jsval may well not live as long as our string needs to.
+            declType = CGGeneric("nsString")
+            if isMember == "Variadic":
+                # The string is kept alive by the argument, so we can just
+                # depend on it.
+                assignString = "${declName}.Rebind(str.Data(), str.Length());\n"
+            else:
+                assignString = "${declName} = str;\n"
+            return JSToNativeConversionInfo(
+                fill(
+                    """
+                    {
+                      binding_detail::FakeDependentString str;
+                      $*{convert}
+                      $*{assign}
+                    }
+                    """,
+                    convert=getConversionCode("str"),
+                    assign=assignString),
+                declType=declType,
+                dealWithOptional=isOptional)
+
+        if isOptional:
+            declType = "Optional<nsAString>"
+            holderType = CGGeneric("binding_detail::FakeDependentString")
+            conversionCode = ("%s"
+                              "${declName} = &${holderName};\n" %
+                              getConversionCode("${holderName}"))
+        else:
+            declType = "binding_detail::FakeDependentString"
+            holderType = None
+            conversionCode = getConversionCode("${declName}")
+
+        # No need to deal with optional here; we handled it already
+        return JSToNativeConversionInfo(
+            conversionCode,
+            declType=CGGeneric(declType),
+            holderType=holderType)
+
     if type.isEnum():
         assert not isEnforceRange and not isClamp
 
         enumName = type.unroll().inner.identifier.name
         declType = CGGeneric(enumName)
         if type.nullable():
             declType = CGTemplatedType("Nullable", declType)
             declType = declType.define()
@@ -5347,16 +5410,22 @@ def getWrapTemplateForType(type, descrip
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("NonVoidByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
+    if type.isScalarValueString():
+        if type.nullable():
+            return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+        else:
+            return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+
     if type.isEnum():
         if type.nullable():
             resultLoc = "%s.Value()" % result
         else:
             resultLoc = result
         conversion = fill(
             """
             {
@@ -5613,16 +5682,18 @@ def getRetvalDeclarationForType(returnTy
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isDOMString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
+    if returnType.isScalarValueString():
+        return CGGeneric("DOMString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isGeckoInterface():
         result = CGGeneric(descriptorProvider.getDescriptor(
             returnType.unroll().inner.identifier.name).nativeType)
@@ -7982,16 +8053,19 @@ def getUnionAccessorSignatureType(type, 
         return CGWrapper(typeName, post="&")
 
     if type.isDOMString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
+    if type.isScalarValueString():
+        return CGGeneric("const nsAString&")
+
     if type.isEnum():
         if type.nullable():
             raise TypeError("We don't support nullable enumerated arguments or "
                             "union members yet")
         return CGGeneric(type.inner.identifier.name)
 
     if type.isCallback():
         if type.nullable():
@@ -11545,16 +11619,22 @@ class CGNativeMember(ClassMethod):
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsCString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
+        if type.isScalarValueString():
+            if isMember:
+                # No need for a third element in the isMember case
+                return "nsString", None, None
+            # Outparam
+            return "void", "", "aRetVal = ${declName};\n"
         if type.isEnum():
             enumName = type.unroll().inner.identifier.name
             if type.nullable():
                 enumName = CGTemplatedType("Nullable",
                                            CGGeneric(enumName)).define()
                 defaultValue = "%s()" % enumName
             else:
                 defaultValue = "%s(0)" % enumName
@@ -11657,16 +11737,18 @@ class CGNativeMember(ClassMethod):
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
         if returnType.isDOMString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
+        elif returnType.isScalarValueString():
+            args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
             elementDecl = self.getReturnType(returnType.inner, True)
             type = CGTemplatedType("nsTArray", CGGeneric(elementDecl))
             if nullable:
@@ -11790,16 +11872,23 @@ class CGNativeMember(ClassMethod):
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
             return declType, True, False
 
+        if type.isScalarValueString():
+            if isMember:
+                declType = "nsString"
+            else:
+                declType = "nsAString"
+            return declType, True, False
+
         if type.isEnum():
             return type.unroll().inner.identifier.name, False, True
 
         if type.isCallback() or type.isCallbackInterface():
             forceOwningType = optional or isMember
             if type.nullable():
                 if forceOwningType:
                     declType = "nsRefPtr<%s>"
@@ -13568,17 +13657,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -13728,16 +13817,18 @@ class CGEventClass(CGBindingImplClass):
                     nativeType = m.type.unroll().inner.identifier.name
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable",
                                                      CGGeneric(nativeType)).define()
                 elif m.type.isDOMString():
                     nativeType = "nsString"
                 elif m.type.isByteString():
                     nativeType = "nsCString"
+                elif m.type.isScalarValueString():
+                    nativeType = "nsString"
                 elif m.type.isGeckoInterface():
                     iface = m.type.unroll().inner
                     nativeType = self.descriptor.getDescriptor(
                         iface.identifier.name).nativeType
                     # Now trim off unnecessary namespaces
                     nativeType = nativeType.split("::")
                     if nativeType[0] == "mozilla":
                         nativeType.pop(0)
