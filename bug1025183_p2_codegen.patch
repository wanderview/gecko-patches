# HG changeset patch
# Parent 6eaee9ac31f36422f194574aea427387e218711e
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/BindingUtils.cpp b/dom/bindings/BindingUtils.cpp
--- a/dom/bindings/BindingUtils.cpp
+++ b/dom/bindings/BindingUtils.cpp
@@ -36,16 +36,17 @@
 #include "mozilla/dom/DOMError.h"
 #include "mozilla/dom/DOMErrorBinding.h"
 #include "mozilla/dom/HTMLObjectElement.h"
 #include "mozilla/dom/HTMLObjectElementBinding.h"
 #include "mozilla/dom/HTMLSharedObjectElement.h"
 #include "mozilla/dom/HTMLEmbedElementBinding.h"
 #include "mozilla/dom/HTMLAppletElementBinding.h"
 #include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ScalarValueString.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 
 JSErrorFormatString ErrorFormatString[] = {
 #define MSG_DEF(_name, _argc, _str) \
   { _str, _argc, JSEXN_TYPEERR },
diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4472,16 +4472,79 @@ def getJSToNativeConversionInfo(type, de
         # ByteString arguments cannot have a default value.
         assert defaultValue is None
 
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric("nsCString"),
             dealWithOptional=isOptional)
 
+    if type.isScalarValueString():
+        assert not isEnforceRange and not isClamp
+
+        nullable = toStringBool(type.nullable())
+
+        def getConversionCode(varName):
+            conversionCode = (
+                "if (!ConvertJSValueToString(cx, ${val}, ${mutableVal}, %s, %s, %s)) {\n"
+                "%s"
+                "}\n" % ("eStringify", "eStringify", varName, exceptionCodeIndented.define()))
+
+            if defaultValue is None:
+                return conversionCode
+
+            if isinstance(defaultValue, IDLNullValue):
+                assert(type.nullable())
+                defaultCode = "%s.SetNull()" % varName
+            else:
+                defaultCode = handleDefaultStringValue(defaultValue,
+                                                       "%s.SetData" % varName)
+            return handleDefault(conversionCode, defaultCode + ";\n")
+
+        if isMember:
+            # We have to make a copy, except in the variadic case, because our
+            # jsval may well not live as long as our string needs to.
+            declType = CGGeneric("nsString")
+            if isMember == "Variadic":
+                # The string is kept alive by the argument, so we can just
+                # depend on it.
+                assignString = "${declName}.Rebind(str.Data(), str.Length());\n"
+            else:
+                assignString = "${declName} = str;\n"
+            return JSToNativeConversionInfo(
+                fill(
+                    """
+                    {
+                      binding_detail::FakeDependentString str;
+                      $*{convert}
+                      $*{assign}
+                    }
+                    """,
+                    convert=getConversionCode("str"),
+                    assign=assignString),
+                declType=declType,
+                dealWithOptional=isOptional)
+
+        if isOptional:
+            declType = "Optional<nsAString>"
+            holderType = CGGeneric("binding_detail::FakeDependentString")
+            conversionCode = ("%s"
+                              "${declName} = &${holderName};\n" %
+                              getConversionCode("${holderName}"))
+        else:
+            declType = "binding_detail::FakeDependentString"
+            holderType = None
+            conversionCode = getConversionCode("${declName}")
+
+        # No need to deal with optional here; we handled it already
+        return JSToNativeConversionInfo(
+            conversionCode,
+            declType=CGGeneric(declType),
+            holderType=holderType)
+
     if type.isEnum():
         assert not isEnforceRange and not isClamp
 
         enumName = type.unroll().inner.identifier.name
         declType = CGGeneric(enumName)
         if type.nullable():
             declType = CGTemplatedType("Nullable", declType)
             declType = declType.define()
@@ -5347,16 +5410,22 @@ def getWrapTemplateForType(type, descrip
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("NonVoidByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
+    if type.isScalarValueString():
+        if type.nullable():
+            return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+        else:
+            return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
+
     if type.isEnum():
         if type.nullable():
             resultLoc = "%s.Value()" % result
         else:
             resultLoc = result
         conversion = fill(
             """
             {
@@ -5613,16 +5682,18 @@ def getRetvalDeclarationForType(returnTy
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isDOMString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
+    if returnType.isScalarValueString():
+        return CGGeneric("DOMString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
     if returnType.isGeckoInterface():
         result = CGGeneric(descriptorProvider.getDescriptor(
             returnType.unroll().inner.identifier.name).nativeType)
@@ -7982,16 +8053,19 @@ def getUnionAccessorSignatureType(type, 
         return CGWrapper(typeName, post="&")
 
     if type.isDOMString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
+    if type.isScalarValueString():
+        return CGGeneric("const nsAString&")
+
     if type.isEnum():
         if type.nullable():
             raise TypeError("We don't support nullable enumerated arguments or "
                             "union members yet")
         return CGGeneric(type.inner.identifier.name)
 
     if type.isCallback():
         if type.nullable():
@@ -11551,16 +11625,22 @@ class CGNativeMember(ClassMethod):
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsCString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
+        if type.isScalarValueString():
+            if isMember:
+                # No need for a third element in the isMember case
+                return "nsString", None, None
+            # Outparam
+            return "void", "", "aRetVal = ${declName};\n"
         if type.isEnum():
             enumName = type.unroll().inner.identifier.name
             if type.nullable():
                 enumName = CGTemplatedType("Nullable",
                                            CGGeneric(enumName)).define()
                 defaultValue = "%s()" % enumName
             else:
                 defaultValue = "%s(0)" % enumName
@@ -11663,16 +11743,18 @@ class CGNativeMember(ClassMethod):
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
         if returnType.isDOMString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
+        elif returnType.isScalarValueString():
+            args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
             elementDecl = self.getReturnType(returnType.inner, True)
             type = CGTemplatedType("nsTArray", CGGeneric(elementDecl))
             if nullable:
@@ -11796,16 +11878,23 @@ class CGNativeMember(ClassMethod):
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
             return declType, True, False
 
+        if type.isScalarValueString():
+            if isMember:
+                declType = "nsString"
+            else:
+                declType = "nsAString"
+            return declType, True, False
+
         if type.isEnum():
             return type.unroll().inner.identifier.name, False, True
 
         if type.isCallback() or type.isCallbackInterface():
             forceOwningType = optional or isMember
             if type.nullable():
                 if forceOwningType:
                     declType = "nsRefPtr<%s>"
@@ -13574,17 +13663,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -13734,16 +13823,18 @@ class CGEventClass(CGBindingImplClass):
                     nativeType = m.type.unroll().inner.identifier.name
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable",
                                                      CGGeneric(nativeType)).define()
                 elif m.type.isDOMString():
                     nativeType = "nsString"
                 elif m.type.isByteString():
                     nativeType = "nsCString"
+                elif m.type.isScalarValueString():
+                    nativeType = "nsString"
                 elif m.type.isGeckoInterface():
                     iface = m.type.unroll().inner
                     nativeType = self.descriptor.getDescriptor(
                         iface.identifier.name).nativeType
                     # Now trim off unnecessary namespaces
                     nativeType = nativeType.split("::")
                     if nativeType[0] == "mozilla":
                         nativeType.pop(0)
diff --git a/dom/bindings/ScalarValueString.h b/dom/bindings/ScalarValueString.h
new file mode 100644
--- /dev/null
+++ b/dom/bindings/ScalarValueString.h
@@ -0,0 +1,19 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ScalarValueString_h
+#define mozilla_dom_ScalarValueString_h
+
+namespace mozilla {
+namespace dom {
+
+class MOZ_STACK_CLASS ScalarValueString {
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ScalarValueString_h
diff --git a/dom/bindings/moz.build b/dom/bindings/moz.build
--- a/dom/bindings/moz.build
+++ b/dom/bindings/moz.build
@@ -25,16 +25,17 @@ EXPORTS.mozilla.dom += [
     'Exceptions.h',
     'JSSlots.h',
     'MozMap.h',
     'NonRefcountedDOMObject.h',
     'Nullable.h',
     'OwningNonNull.h',
     'PrimitiveConversions.h',
     'RootedDictionary.h',
+    'ScalarValueString.h',
     'ToJSValue.h',
     'TypedArray.h',
     'UnionMember.h',
 ]
 
 FAIL_ON_WARNINGS = True
 
 MSVC_ENABLE_PGO = True
