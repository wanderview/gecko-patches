# HG changeset patch
# Parent b02854a7c0f035dc3f36436fccef3c5c0f7160ec
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/BindingDeclarations.h b/dom/bindings/BindingDeclarations.h
--- a/dom/bindings/BindingDeclarations.h
+++ b/dom/bindings/BindingDeclarations.h
@@ -296,25 +296,16 @@ public:
   // And we have to override the non-const one too, since we're
   // shadowing the one on the superclass.
   OwningNonNull<T>& Value()
   {
     return this->mImpl.ref();
   }
 };
 
-// Specialization for strings.
-// XXXbz we can't pull in FakeDependentString here, because it depends on
-// internal strings.  So we just have to forward-declare it and reimplement its
-// ToAStringPtr.
-
-namespace binding_detail {
-struct FakeDependentString;
-} // namespace binding_detail
-
 template<>
 class Optional<nsAString>
 {
 public:
   Optional() : mPassed(false) {}
 
   bool WasPassed() const
   {
@@ -323,25 +314,16 @@ public:
 
   void operator=(const nsAString* str)
   {
     MOZ_ASSERT(str);
     mStr = str;
     mPassed = true;
   }
 
-  // If this code ever goes away, remove the comment pointing to it in the
-  // FakeDependentString class in BindingUtils.h.
-  void operator=(const binding_detail::FakeDependentString* str)
-  {
-    MOZ_ASSERT(str);
-    mStr = reinterpret_cast<const nsDependentString*>(str);
-    mPassed = true;
-  }
-
   const nsAString& Value() const
   {
     MOZ_ASSERT(WasPassed());
     return *mStr;
   }
 
 private:
   // Forbid copy-construction and assignment
diff --git a/dom/bindings/BindingUtils.h b/dom/bindings/BindingUtils.h
--- a/dom/bindings/BindingUtils.h
+++ b/dom/bindings/BindingUtils.h
@@ -23,16 +23,17 @@
 #include "mozilla/dom/workers/Workers.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Likely.h"
 #include "mozilla/MemoryReporting.h"
 #include "nsCycleCollector.h"
 #include "nsIXPConnect.h"
 #include "MainThreadUtils.h"
 #include "nsISupportsImpl.h"
+#include "nsUTF8Utils.h"
 #include "qsObjectHelper.h"
 #include "xpcpublic.h"
 #include "nsIVariant.h"
 #include "pldhash.h" // For PLDHashOperator
 
 #include "nsWrapperCacheInlines.h"
 
 class nsIJSID;
@@ -1721,18 +1722,16 @@ struct FakeDependentString {
     return mData;
   }
 
   nsDependentString::size_type Length() const
   {
     return mLength;
   }
 
-  // If this ever changes, change the corresponding code in the
-  // Optional<nsAString> specialization as well.
   const nsAString* ToAStringPtr() const {
     return reinterpret_cast<const nsDependentString*>(this);
   }
 
   nsAString* ToAStringPtr() {
     return reinterpret_cast<nsDependentString*>(this);
   }
 
@@ -1763,31 +1762,125 @@ private:
                     "Offset of mLength should match");
       static_assert(offsetof(FakeDependentString, mFlags) ==
                       offsetof(DepedentStringAsserter, mFlags),
                     "Offset of mFlags should match");
     }
   };
 };
 
+struct ScalarValueString {
+  ScalarValueString()
+  : mConverted(false)
+  {
+  }
+
+  void Truncate() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.Truncate();
+  }
+
+  void SetNull() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.SetNull();
+  }
+
+  void SetData(const nsDependentString::char_type* aData,
+               nsDependentString::size_type aLength)
+  {
+    const nsDependentString::char_type* nextChar = aData;
+    const nsDependentString::char_type* end = aData + aLength;
+    const nsDependentString::char_type* lastChar;
+    uint32_t enumerated;
+
+    // Begin scanning string to see if any conversion is needed
+    do {
+      lastChar = nextChar;
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+    } while(enumerated && enumerated != REPLACEMENT_CHAR);
+
+    // If no conversion is needed, then just store a ref in our fake string
+    if (enumerated != REPLACEMENT_CHAR) {
+      mFakeDependentString.SetData(aData, aLength);
+      return;
+    }
+
+    mConvertedString.SetCapacity(aLength);
+
+    // Copy in the section of the string we already scanned that did
+    // not need fixing.
+    mConvertedString.Append(aData, end - lastChar);
+
+    // Copy in the last char which needed conversion
+    mConvertedString.Append(enumerated);
+
+    // Complete scanning the string for further conversions
+    do {
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+      mConvertedString.Append(enumerated);
+    } while(enumerated);
+
+    mConverted = true;
+  }
+
+  const nsDependentString::char_type* Data() const
+  {
+    if (mConverted) {
+      return mConvertedString.get();
+    }
+    return mFakeDependentString.Data();
+  }
+
+  nsDependentString::size_type Length() const
+  {
+    if (mConverted) {
+      return mConvertedString.Length();
+    }
+    return mFakeDependentString.Length();
+  }
+
+  const nsAString* ToAStringPtr() const {
+    if (mConverted) {
+      return &mConvertedString;
+    }
+    return mFakeDependentString.ToAStringPtr();
+  }
+
+  operator const nsAString& () const {
+    if (mConverted) {
+      return mConvertedString;
+    }
+    return mFakeDependentString;
+  }
+
+  static const char16_t REPLACEMENT_CHAR = 0xFFFD;
+
+  bool mConverted;
+  binding_detail::FakeDependentString mFakeDependentString;
+  nsString mConvertedString;
+};
+
 } // namespace binding_detail
 
 enum StringificationBehavior {
   eStringify,
   eEmpty,
   eNull
 };
 
 // pval must not be null and must point to a rooted JS::Value
+template <typename StringType>
 static inline bool
 ConvertJSValueToString(JSContext* cx, JS::Handle<JS::Value> v,
                        JS::MutableHandle<JS::Value> pval,
                        StringificationBehavior nullBehavior,
                        StringificationBehavior undefinedBehavior,
-                       binding_detail::FakeDependentString& result)
+                       StringType& result)
 {
   JSString *s;
   if (v.isString()) {
     s = v.toString();
   } else {
     StringificationBehavior behavior;
     if (v.isNull()) {
       behavior = nullBehavior;
diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4378,17 +4378,17 @@ def getJSToNativeConversionInfo(type, de
             declArgs = None
         return JSToNativeConversionInfo(template,
                                         declType=declType,
                                         holderType=holderType,
                                         dealWithOptional=isOptional,
                                         declArgs=declArgs,
                                         holderArgs=holderArgs)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         assert not isEnforceRange and not isClamp
 
         treatAs = {
             "Default": "eStringify",
             "EmptyString": "eEmpty",
             "Null": "eNull",
         }
         if type.nullable():
@@ -4412,48 +4412,53 @@ def getJSToNativeConversionInfo(type, de
             if isinstance(defaultValue, IDLNullValue):
                 assert(type.nullable())
                 defaultCode = "%s.SetNull()" % varName
             else:
                 defaultCode = handleDefaultStringValue(defaultValue,
                                                        "%s.SetData" % varName)
             return handleDefault(conversionCode, defaultCode + ";\n")
 
+        if type.isScalarValueString():
+            holderTypeString = "binding_detail::ScalarValueString";
+        else:
+            holderTypeString = "binding_detail::FakeDependentString";
+
         if isMember:
             # We have to make a copy, except in the variadic case, because our
             # jsval may well not live as long as our string needs to.
             declType = CGGeneric("nsString")
             if isMember == "Variadic":
                 # The string is kept alive by the argument, so we can just
                 # depend on it.
                 assignString = "${declName}.Rebind(str.Data(), str.Length());\n"
             else:
                 assignString = "${declName} = str;\n"
             return JSToNativeConversionInfo(
                 fill(
                     """
                     {
-                      binding_detail::FakeDependentString str;
+                      %s str;
                       $*{convert}
                       $*{assign}
                     }
-                    """,
+                    """ % holderTypeString,
                     convert=getConversionCode("str"),
                     assign=assignString),
                 declType=declType,
                 dealWithOptional=isOptional)
 
         if isOptional:
             declType = "Optional<nsAString>"
-            holderType = CGGeneric("binding_detail::FakeDependentString")
+            holderType = CGGeneric(holderTypeString);
             conversionCode = ("%s"
-                              "${declName} = &${holderName};\n" %
+                              "${declName} = ${holderName}.ToAStringPtr();\n" %
                               getConversionCode("${holderName}"))
         else:
-            declType = "binding_detail::FakeDependentString"
+            declType = holderTypeString;
             holderType = None
             conversionCode = getConversionCode("${declName}")
 
         # No need to deal with optional here; we handled it already
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric(declType),
             holderType=holderType)
@@ -5333,17 +5338,17 @@ def getWrapTemplateForType(type, descrip
             else:
                 getIID = ""
             wrap = "WrapObject(cx, %s, %s${jsvalHandle})" % (result, getIID)
             failed = None
 
         wrappingCode += wrapAndSetPtr(wrap, failed)
         return (wrappingCode, False)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         if type.nullable():
             return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
@@ -5605,17 +5610,17 @@ def getRetvalDeclarationForType(returnTy
     if returnType is None or returnType.isVoid():
         # Nothing to declare
         return None, None, None, None
     if returnType.isPrimitive() and returnType.tag() in builtinNames:
         result = CGGeneric(builtinNames[returnType.tag()])
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
-    if returnType.isDOMString():
+    if returnType.isDOMString() or returnType.isScalarValueString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
@@ -7974,17 +7979,17 @@ def getUnionAccessorSignatureType(type, 
         return typeName
 
     if type.isSpiderMonkeyInterface():
         typeName = CGGeneric(type.name)
         if type.nullable():
             typeName = CGTemplatedType("Nullable", typeName)
         return CGWrapper(typeName, post="&")
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
     if type.isEnum():
         if type.nullable():
             raise TypeError("We don't support nullable enumerated arguments or "
@@ -11537,17 +11542,17 @@ class CGNativeMember(ClassMethod):
             result = CGGeneric(builtinNames[type.tag()])
             defaultReturnArg = "0"
             if type.nullable():
                 result = CGTemplatedType("Nullable", result)
                 defaultReturnArg = ""
             return (result.define(),
                     "%s(%s)" % (result.define(), defaultReturnArg),
                     "return ${declName};\n")
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
@@ -11657,17 +11662,17 @@ class CGNativeMember(ClassMethod):
             return "void", "", ""
 
         raise TypeError("Don't know how to declare return value for %s" %
                         type)
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
-        if returnType.isDOMString():
+        if returnType.isDOMString() or returnType.isScalarValueString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
@@ -11783,17 +11788,17 @@ class CGNativeMember(ClassMethod):
                     False, False)
 
         if type.isSpiderMonkeyInterface():
             if self.jsObjectsArePtr:
                 return "JSObject*", False, False
 
             return type.name, True, True
 
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 declType = "nsString"
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
@@ -13572,17 +13577,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -13728,17 +13733,17 @@ class CGEventClass(CGBindingImplClass):
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable", nativeType)
                     nativeType = nativeType.define()
                 elif m.type.isEnum():
                     nativeType = m.type.unroll().inner.identifier.name
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable",
                                                      CGGeneric(nativeType)).define()
-                elif m.type.isDOMString():
+                elif m.type.isDOMString() or m.type.isScalarValueString():
                     nativeType = "nsString"
                 elif m.type.isByteString():
                     nativeType = "nsCString"
                 elif m.type.isGeckoInterface():
                     iface = m.type.unroll().inner
                     nativeType = self.descriptor.getDescriptor(
                         iface.identifier.name).nativeType
                     # Now trim off unnecessary namespaces
diff --git a/dom/bindings/parser/WebIDL.py b/dom/bindings/parser/WebIDL.py
--- a/dom/bindings/parser/WebIDL.py
+++ b/dom/bindings/parser/WebIDL.py
@@ -2622,16 +2622,18 @@ class IDLValue(IDLObject):
             return self
         elif self.type.isFloat() and type.isFloat():
             if (not type.isUnrestricted() and
                 (self.value == float("inf") or self.value == float("-inf") or
                  math.isnan(self.value))):
                 raise WebIDLError("Trying to convert unrestricted value %s to non-unrestricted"
                                   % self.value, [location]);
             return self
+        elif self.type.isString() and type.isString():
+            return self
         raise WebIDLError("Cannot coerce type %s to type %s." %
                           (self.type, type), [location])
 
     def _getDependentObjects(self):
         return set()
 
 class IDLNullValue(IDLObject):
     def __init__(self, location):
diff --git a/dom/bindings/test/TestBindingHeader.h b/dom/bindings/test/TestBindingHeader.h
--- a/dom/bindings/test/TestBindingHeader.h
+++ b/dom/bindings/test/TestBindingHeader.h
@@ -454,24 +454,35 @@ public:
   // DOMString types
   void PassString(const nsAString&);
   void PassNullableString(const nsAString&);
   void PassOptionalString(const Optional<nsAString>&);
   void PassOptionalStringWithDefaultValue(const nsAString&);
   void PassOptionalNullableString(const Optional<nsAString>&);
   void PassOptionalNullableStringWithDefaultValue(const nsAString&);
   void PassVariadicString(const Sequence<nsString>&);
+  void ReceiveString(DOMString&);
 
   // ByteString types
   void PassByteString(const nsCString&);
   void PassNullableByteString(const nsCString&);
   void PassOptionalByteString(const Optional<nsCString>&);
   void PassOptionalNullableByteString(const Optional<nsCString>&);
   void PassVariadicByteString(const Sequence<nsCString>&);
 
+  // ScalarValueString types
+  void PassSVS(const nsAString&);
+  void PassNullableSVS(const nsAString&);
+  void PassOptionalSVS(const Optional<nsAString>&);
+  void PassOptionalSVSWithDefaultValue(const nsAString&);
+  void PassOptionalNullableSVS(const Optional<nsAString>&);
+  void PassOptionalNullableSVSWithDefaultValue(const nsAString&);
+  void PassVariadicSVS(const Sequence<nsString>&);
+  void ReceiveSVS(DOMString&);
+
   // Enumerated types
   void PassEnum(TestEnum);
   void PassNullableEnum(const Nullable<TestEnum>&);
   void PassOptionalEnum(const Optional<TestEnum>&);
   void PassEnumWithDefault(TestEnum);
   void PassOptionalNullableEnum(const Optional<Nullable<TestEnum> >&);
   void PassOptionalNullableEnumWithDefaultValue(const Nullable<TestEnum>&);
   void PassOptionalNullableEnumWithDefaultValue2(const Nullable<TestEnum>&);
@@ -568,16 +579,17 @@ public:
   void PassUnion9(JSContext*, const ObjectOrStringOrLongOrBoolean& arg);
   void PassUnion10(const EventInitOrLong& arg);
   void PassUnion11(JSContext*, const CustomEventInitOrLong& arg);
   void PassUnion12(const EventInitOrLong& arg);
   void PassUnion13(JSContext*, const ObjectOrLongOrNull& arg);
   void PassUnion14(JSContext*, const ObjectOrLongOrNull& arg);
   void PassUnionWithCallback(const EventHandlerNonNullOrNullOrLong& arg);
   void PassUnionWithByteString(const ByteStringOrLong&);
+  void PassUnionWithSVS(const ScalarValueStringOrLong&);
 #endif
   void PassNullableUnion(JSContext*, const Nullable<ObjectOrLong>&);
   void PassOptionalUnion(JSContext*, const Optional<ObjectOrLong>&);
   void PassOptionalNullableUnion(JSContext*, const Optional<Nullable<ObjectOrLong> >&);
   void PassOptionalNullableUnionWithDefaultValue(JSContext*, const Nullable<ObjectOrLong>&);
   //void PassUnionWithInterfaces(const TestInterfaceOrTestExternalInterface& arg);
   //void PassUnionWithInterfacesAndNullable(const TestInterfaceOrNullOrTestExternalInterface& arg);
   void PassUnionWithArrayBuffer(const ArrayBufferOrLong&);
diff --git a/dom/bindings/test/TestCodeGen.webidl b/dom/bindings/test/TestCodeGen.webidl
--- a/dom/bindings/test/TestCodeGen.webidl
+++ b/dom/bindings/test/TestCodeGen.webidl
@@ -415,24 +415,35 @@ interface TestInterface {
   // DOMString types
   void passString(DOMString arg);
   void passNullableString(DOMString? arg);
   void passOptionalString(optional DOMString arg);
   void passOptionalStringWithDefaultValue(optional DOMString arg = "abc");
   void passOptionalNullableString(optional DOMString? arg);
   void passOptionalNullableStringWithDefaultValue(optional DOMString? arg = null);
   void passVariadicString(DOMString... arg);
+  DOMString receiveString();
 
   // ByteString types
   void passByteString(ByteString arg);
   void passNullableByteString(ByteString? arg);
   void passOptionalByteString(optional ByteString arg);
   void passOptionalNullableByteString(optional ByteString? arg);
   void passVariadicByteString(ByteString... arg);
 
+  // ScalarValueString types
+  void passSVS(ScalarValueString arg);
+  void passNullableSVS(ScalarValueString? arg);
+  void passOptionalSVS(optional ScalarValueString arg);
+  void passOptionalSVSWithDefaultValue(optional ScalarValueString arg = "abc");
+  void passOptionalNullableSVS(optional ScalarValueString? arg);
+  void passOptionalNullableSVSWithDefaultValue(optional ScalarValueString? arg = null);
+  void passVariadicSVS(ScalarValueString... arg);
+  ScalarValueString receiveSVS();
+
   // Enumerated types
   void passEnum(TestEnum arg);
   void passNullableEnum(TestEnum? arg);
   void passOptionalEnum(optional TestEnum arg);
   void passEnumWithDefault(optional TestEnum arg = "a");
   void passOptionalNullableEnum(optional TestEnum? arg);
   void passOptionalNullableEnumWithDefaultValue(optional TestEnum? arg = null);
   void passOptionalNullableEnumWithDefaultValue2(optional TestEnum? arg = "a");
@@ -514,16 +525,17 @@ interface TestInterface {
   void passUnion9((object or DOMString or long or boolean) arg);
   void passUnion10(optional (EventInit or long) arg);
   void passUnion11(optional (CustomEventInit or long) arg);
   void passUnion12(optional (EventInit or long) arg = 5);
   void passUnion13(optional (object or long?) arg = null);
   void passUnion14(optional (object or long?) arg = 5);
   void passUnionWithCallback((EventHandler or long) arg);
   void passUnionWithByteString((ByteString or long) arg);
+  void passUnionWithSVS((ScalarValueString or long) arg);
 #endif
   void passUnionWithNullable((object? or long) arg);
   void passNullableUnion((object or long)? arg);
   void passOptionalUnion(optional (object or long) arg);
   void passOptionalNullableUnion(optional (object or long)? arg);
   void passOptionalNullableUnionWithDefaultValue(optional (object or long)? arg = null);
   //void passUnionWithInterfaces((TestInterface or TestExternalInterface) arg);
   //void passUnionWithInterfacesAndNullable((TestInterface? or TestExternalInterface) arg);
