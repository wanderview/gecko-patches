# HG changeset patch
# Parent 0f09657769234c9dd559a7677b24b3358e4daa73
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/BindingDeclarations.h b/dom/bindings/BindingDeclarations.h
--- a/dom/bindings/BindingDeclarations.h
+++ b/dom/bindings/BindingDeclarations.h
@@ -296,25 +296,16 @@ public:
   // And we have to override the non-const one too, since we're
   // shadowing the one on the superclass.
   OwningNonNull<T>& Value()
   {
     return this->mImpl.ref();
   }
 };
 
-// Specialization for strings.
-// XXXbz we can't pull in FakeString here, because it depends on internal
-// strings.  So we just have to forward-declare it and reimplement its
-// ToAStringPtr.
-
-namespace binding_detail {
-struct FakeString;
-} // namespace binding_detail
-
 template<>
 class Optional<nsAString>
 {
 public:
   Optional() : mPassed(false) {}
 
   bool WasPassed() const
   {
@@ -323,25 +314,16 @@ public:
 
   void operator=(const nsAString* str)
   {
     MOZ_ASSERT(str);
     mStr = str;
     mPassed = true;
   }
 
-  // If this code ever goes away, remove the comment pointing to it in the
-  // FakeString class in BindingUtils.h.
-  void operator=(const binding_detail::FakeString* str)
-  {
-    MOZ_ASSERT(str);
-    mStr = reinterpret_cast<const nsString*>(str);
-    mPassed = true;
-  }
-
   const nsAString& Value() const
   {
     MOZ_ASSERT(WasPassed());
     return *mStr;
   }
 
 private:
   // Forbid copy-construction and assignment
diff --git a/dom/bindings/BindingUtils.h b/dom/bindings/BindingUtils.h
--- a/dom/bindings/BindingUtils.h
+++ b/dom/bindings/BindingUtils.h
@@ -25,16 +25,17 @@
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Likely.h"
 #include "mozilla/MemoryReporting.h"
 #include "nsCycleCollector.h"
 #include "nsIXPConnect.h"
 #include "nsJSUtils.h"
 #include "MainThreadUtils.h"
 #include "nsISupportsImpl.h"
+#include "nsUTF8Utils.h"
 #include "qsObjectHelper.h"
 #include "xpcpublic.h"
 #include "nsIVariant.h"
 #include "pldhash.h" // For PLDHashOperator
 
 #include "nsWrapperCacheInlines.h"
 
 class nsIJSID;
@@ -1795,18 +1796,16 @@ struct FakeString {
       SetData(static_cast<nsString::char_type*>(buf->Data()));
       mFlags = nsString::F_SHARED | nsString::F_TERMINATED;
     }
     mLength = aLength;
     mData[mLength] = char16_t(0);
     return true;
   }
 
-  // If this ever changes, change the corresponding code in the
-  // Optional<nsAString> specialization as well.
   const nsAString* ToAStringPtr() const {
     return reinterpret_cast<const nsString*>(this);
   }
 
   nsAString* ToAStringPtr() {
     return reinterpret_cast<nsString*>(this);
   }
 
@@ -1849,16 +1848,111 @@ private:
                     "Offset of mLength should match");
       static_assert(offsetof(FakeString, mFlags) ==
                       offsetof(StringAsserter, mFlags),
                     "Offset of mFlags should match");
     }
   };
 };
 
+struct ScalarValueString {
+  ScalarValueString()
+  : mConverted(false)
+  {
+  }
+
+  void Truncate() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeString.Truncate();
+  }
+
+  void SetData(const nsDependentString::char_type* aData,
+               nsDependentString::size_type aLength)
+  {
+    const nsDependentString::char_type* nextChar = aData;
+    const nsDependentString::char_type* end = aData + aLength;
+    const nsDependentString::char_type* lastChar;
+    uint32_t enumerated;
+
+    // Begin scanning string to see if any conversion is needed
+    do {
+      lastChar = nextChar;
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+    } while(enumerated && enumerated != REPLACEMENT_CHAR);
+
+    // If no conversion is needed, then just store a ref in our fake string
+    if (enumerated != REPLACEMENT_CHAR) {
+      mFakeString.SetData(aData, aLength);
+      return;
+    }
+
+    mConvertedString.SetCapacity(aLength);
+
+    // Copy in the section of the string we already scanned that did
+    // not need fixing.
+    mConvertedString.Append(aData, end - lastChar);
+
+    // Copy in the last char which needed conversion
+    mConvertedString.Append(enumerated);
+
+    // Complete scanning the string for further conversions
+    do {
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+      mConvertedString.Append(enumerated);
+    } while(enumerated);
+
+    mConverted = true;
+  }
+
+  const nsString::char_type* Data() const
+  {
+    if (mConverted) {
+      return mConvertedString.get();
+    }
+    return mFakeString.Data();
+  }
+
+  nsString::char_type* BeginWriting()
+  {
+    if (mConverted) {
+      return mConvertedString.BeginWriting();
+    }
+    return mFakeString.BeginWriting();
+  }
+
+  nsString::size_type Length() const
+  {
+    if (mConverted) {
+      return mConvertedString.Length();
+    }
+    return mFakeString.Length();
+  }
+
+  const nsAString* ToAStringPtr() const {
+    if (mConverted) {
+      return &mConvertedString;
+    }
+    return mFakeString.ToAStringPtr();
+  }
+
+  operator const nsAString& () const {
+    if (mConverted) {
+      return mConvertedString;
+    }
+    return mFakeString;
+  }
+
+  static const char16_t REPLACEMENT_CHAR = 0xFFFD;
+
+  bool mConverted;
+  binding_detail::FakeString mFakeString;
+  nsString mConvertedString;
+};
+
 } // namespace binding_detail
 
 enum StringificationBehavior {
   eStringify,
   eEmpty,
   eNull
 };
 
diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4481,17 +4481,17 @@ def getJSToNativeConversionInfo(type, de
             declArgs = None
         return JSToNativeConversionInfo(template,
                                         declType=declType,
                                         holderType=holderType,
                                         dealWithOptional=isOptional,
                                         declArgs=declArgs,
                                         holderArgs=holderArgs)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         assert not isEnforceRange and not isClamp
 
         treatAs = {
             "Default": "eStringify",
             "EmptyString": "eEmpty",
             "Null": "eNull",
         }
         if type.nullable():
@@ -4515,32 +4515,37 @@ def getJSToNativeConversionInfo(type, de
             if isinstance(defaultValue, IDLNullValue):
                 assert(type.nullable())
                 defaultCode = "%s.SetIsVoid(true)" % varName
             else:
                 defaultCode = handleDefaultStringValue(defaultValue,
                                                        "%s.Rebind" % varName)
             return handleDefault(conversionCode, defaultCode + ";\n")
 
+        if type.isScalarValueString():
+            holderTypeString = "binding_detail::ScalarValueString";
+        else:
+            holderTypeString = "binding_detail::FakeDependentString";
+
         if isMember:
             # Convert directly into the nsString member we have.
             declType = CGGeneric("nsString")
             return JSToNativeConversionInfo(
                 getConversionCode("${declName}"),
                 declType=declType,
                 dealWithOptional=isOptional)
 
         if isOptional:
             declType = "Optional<nsAString>"
-            holderType = CGGeneric("binding_detail::FakeString")
+            holderType = CGGeneric(holderTypeString)
             conversionCode = ("%s"
-                              "${declName} = &${holderName};\n" %
+                              "${declName} = ${holderName}.ToAStringPtr();\n" %
                               getConversionCode("${holderName}"))
         else:
-            declType = "binding_detail::FakeString"
+            declType = holderTypeString
             holderType = None
             conversionCode = getConversionCode("${declName}")
 
         # No need to deal with optional here; we handled it already
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric(declType),
             holderType=holderType)
@@ -5418,17 +5423,17 @@ def getWrapTemplateForType(type, descrip
             else:
                 getIID = ""
             wrap = "WrapObject(cx, %s, %s${jsvalHandle})" % (result, getIID)
             failed = None
 
         wrappingCode += wrapAndSetPtr(wrap, failed)
         return (wrappingCode, False)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         if type.nullable():
             return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
@@ -5690,17 +5695,17 @@ def getRetvalDeclarationForType(returnTy
     if returnType is None or returnType.isVoid():
         # Nothing to declare
         return None, None, None, None
     if returnType.isPrimitive() and returnType.tag() in builtinNames:
         result = CGGeneric(builtinNames[returnType.tag()])
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
-    if returnType.isDOMString():
+    if returnType.isDOMString() or returnType.isScalarValueString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
@@ -8080,17 +8085,17 @@ def getUnionAccessorSignatureType(type, 
         else:
             typeName = CGWrapper(typeName, post="&")
         return typeName
 
     if type.isSpiderMonkeyInterface():
         typeName = CGGeneric(type.name)
         return CGWrapper(typeName, post=" const &")
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
     if type.isEnum():
         return CGGeneric(type.inner.identifier.name)
 
@@ -11684,17 +11689,17 @@ class CGNativeMember(ClassMethod):
             result = CGGeneric(builtinNames[type.tag()])
             defaultReturnArg = "0"
             if type.nullable():
                 result = CGTemplatedType("Nullable", result)
                 defaultReturnArg = ""
             return (result.define(),
                     "%s(%s)" % (result.define(), defaultReturnArg),
                     "return ${declName};\n")
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
@@ -11804,17 +11809,17 @@ class CGNativeMember(ClassMethod):
             return "void", "", ""
 
         raise TypeError("Don't know how to declare return value for %s" %
                         type)
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
-        if returnType.isDOMString():
+        if returnType.isDOMString() or returnType.isScalarValueString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
@@ -11930,17 +11935,17 @@ class CGNativeMember(ClassMethod):
                     False, False)
 
         if type.isSpiderMonkeyInterface():
             if self.jsObjectsArePtr:
                 return "JSObject*", False, False
 
             return type.name, True, True
 
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 declType = "nsString"
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
@@ -13733,17 +13738,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -14107,17 +14112,17 @@ class CGEventClass(CGBindingImplClass):
         if type.isPrimitive() and type.tag() in builtinNames:
             nativeType = CGGeneric(builtinNames[type.tag()])
             if type.nullable():
                 nativeType = CGTemplatedType("Nullable", nativeType)
         elif type.isEnum():
             nativeType = CGGeneric(type.unroll().inner.identifier.name)
             if type.nullable():
                 nativeType = CGTemplatedType("Nullable", nativeType)
-        elif type.isDOMString():
+        elif type.isDOMString() or type.isScalarValueString():
             nativeType = CGGeneric("nsString")
         elif type.isByteString():
             nativeType = CGGeneric("nsCString")
         elif type.isGeckoInterface():
             iface = type.unroll().inner
             nativeType = self.descriptor.getDescriptor(
                 iface.identifier.name).nativeType
             # Now trim off unnecessary namespaces
