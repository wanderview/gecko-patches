# HG changeset patch
# Parent b4cb758f26b4d21277542618357187bfd6a68f47
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P2 Add ScalarValueString to webidl Codegen.py

diff --git a/dom/bindings/BindingDeclarations.h b/dom/bindings/BindingDeclarations.h
--- a/dom/bindings/BindingDeclarations.h
+++ b/dom/bindings/BindingDeclarations.h
@@ -296,25 +296,16 @@ public:
   // And we have to override the non-const one too, since we're
   // shadowing the one on the superclass.
   OwningNonNull<T>& Value()
   {
     return this->mImpl.ref();
   }
 };
 
-// Specialization for strings.
-// XXXbz we can't pull in FakeDependentString here, because it depends on
-// internal strings.  So we just have to forward-declare it and reimplement its
-// ToAStringPtr.
-
-namespace binding_detail {
-struct FakeDependentString;
-} // namespace binding_detail
-
 template<>
 class Optional<nsAString>
 {
 public:
   Optional() : mPassed(false) {}
 
   bool WasPassed() const
   {
@@ -323,25 +314,16 @@ public:
 
   void operator=(const nsAString* str)
   {
     MOZ_ASSERT(str);
     mStr = str;
     mPassed = true;
   }
 
-  // If this code ever goes away, remove the comment pointing to it in the
-  // FakeDependentString class in BindingUtils.h.
-  void operator=(const binding_detail::FakeDependentString* str)
-  {
-    MOZ_ASSERT(str);
-    mStr = reinterpret_cast<const nsDependentString*>(str);
-    mPassed = true;
-  }
-
   const nsAString& Value() const
   {
     MOZ_ASSERT(WasPassed());
     return *mStr;
   }
 
 private:
   // Forbid copy-construction and assignment
diff --git a/dom/bindings/BindingUtils.h b/dom/bindings/BindingUtils.h
--- a/dom/bindings/BindingUtils.h
+++ b/dom/bindings/BindingUtils.h
@@ -23,16 +23,17 @@
 #include "mozilla/dom/workers/Workers.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Likely.h"
 #include "mozilla/MemoryReporting.h"
 #include "nsCycleCollector.h"
 #include "nsIXPConnect.h"
 #include "MainThreadUtils.h"
 #include "nsISupportsImpl.h"
+#include "nsUTF8Utils.h"
 #include "qsObjectHelper.h"
 #include "xpcpublic.h"
 #include "nsIVariant.h"
 #include "pldhash.h" // For PLDHashOperator
 
 #include "nsWrapperCacheInlines.h"
 
 class nsIJSID;
@@ -1721,18 +1722,16 @@ struct FakeDependentString {
     return mData;
   }
 
   nsDependentString::size_type Length() const
   {
     return mLength;
   }
 
-  // If this ever changes, change the corresponding code in the
-  // Optional<nsAString> specialization as well.
   const nsAString* ToAStringPtr() const {
     return reinterpret_cast<const nsDependentString*>(this);
   }
 
   nsAString* ToAStringPtr() {
     return reinterpret_cast<nsDependentString*>(this);
   }
 
@@ -1763,31 +1762,125 @@ private:
                     "Offset of mLength should match");
       static_assert(offsetof(FakeDependentString, mFlags) ==
                       offsetof(DepedentStringAsserter, mFlags),
                     "Offset of mFlags should match");
     }
   };
 };
 
+struct ScalarValueString {
+  ScalarValueString()
+  : mConverted(false)
+  {
+  }
+
+  void Truncate() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.Truncate();
+  }
+
+  void SetNull() {
+    mConvertedString.Truncate();
+    mConverted = false;
+    mFakeDependentString.SetNull();
+  }
+
+  void SetData(const nsDependentString::char_type* aData,
+               nsDependentString::size_type aLength)
+  {
+    const nsDependentString::char_type* nextChar = aData;
+    const nsDependentString::char_type* end = aData + aLength;
+    const nsDependentString::char_type* lastChar;
+    uint32_t enumerated;
+
+    // Begin scanning string to see if any conversion is needed
+    do {
+      lastChar = nextChar;
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+    } while(enumerated && enumerated != REPLACEMENT_CHAR);
+
+    // If no conversion is needed, then just store a ref in our fake string
+    if (enumerated != REPLACEMENT_CHAR) {
+      mFakeDependentString.SetData(aData, aLength);
+      return;
+    }
+
+    mConvertedString.SetCapacity(aLength);
+
+    // Copy in the section of the string we already scanned that did
+    // not need fixing.
+    mConvertedString.Append(aData, end - lastChar);
+
+    // Copy in the last char which needed conversion
+    mConvertedString.Append(enumerated);
+
+    // Complete scanning the string for further conversions
+    do {
+      enumerated = UTF16CharEnumerator::NextChar(&nextChar, end);
+      mConvertedString.Append(enumerated);
+    } while(enumerated);
+
+    mConverted = true;
+  }
+
+  const nsDependentString::char_type* Data() const
+  {
+    if (mConverted) {
+      return mConvertedString.get();
+    }
+    return mFakeDependentString.Data();
+  }
+
+  nsDependentString::size_type Length() const
+  {
+    if (mConverted) {
+      return mConvertedString.Length();
+    }
+    return mFakeDependentString.Length();
+  }
+
+  const nsAString* ToAStringPtr() const {
+    if (mConverted) {
+      return &mConvertedString;
+    }
+    return mFakeDependentString.ToAStringPtr();
+  }
+
+  operator const nsAString& () const {
+    if (mConverted) {
+      return mConvertedString;
+    }
+    return mFakeDependentString;
+  }
+
+  static const char16_t REPLACEMENT_CHAR = 0xFFFD;
+
+  bool mConverted;
+  binding_detail::FakeDependentString mFakeDependentString;
+  nsString mConvertedString;
+};
+
 } // namespace binding_detail
 
 enum StringificationBehavior {
   eStringify,
   eEmpty,
   eNull
 };
 
 // pval must not be null and must point to a rooted JS::Value
+template <typename StringType>
 static inline bool
 ConvertJSValueToString(JSContext* cx, JS::Handle<JS::Value> v,
                        JS::MutableHandle<JS::Value> pval,
                        StringificationBehavior nullBehavior,
                        StringificationBehavior undefinedBehavior,
-                       binding_detail::FakeDependentString& result)
+                       StringType& result)
 {
   JSString *s;
   if (v.isString()) {
     s = v.toString();
   } else {
     StringificationBehavior behavior;
     if (v.isNull()) {
       behavior = nullBehavior;
diff --git a/dom/bindings/Codegen.py b/dom/bindings/Codegen.py
--- a/dom/bindings/Codegen.py
+++ b/dom/bindings/Codegen.py
@@ -4378,17 +4378,17 @@ def getJSToNativeConversionInfo(type, de
             declArgs = None
         return JSToNativeConversionInfo(template,
                                         declType=declType,
                                         holderType=holderType,
                                         dealWithOptional=isOptional,
                                         declArgs=declArgs,
                                         holderArgs=holderArgs)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         assert not isEnforceRange and not isClamp
 
         treatAs = {
             "Default": "eStringify",
             "EmptyString": "eEmpty",
             "Null": "eNull",
         }
         if type.nullable():
@@ -4412,48 +4412,53 @@ def getJSToNativeConversionInfo(type, de
             if isinstance(defaultValue, IDLNullValue):
                 assert(type.nullable())
                 defaultCode = "%s.SetNull()" % varName
             else:
                 defaultCode = handleDefaultStringValue(defaultValue,
                                                        "%s.SetData" % varName)
             return handleDefault(conversionCode, defaultCode + ";\n")
 
+        if type.isScalarValueString():
+            holderTypeString = "binding_detail::ScalarValueString";
+        else:
+            holderTypeString = "binding_detail::FakeDependentString";
+
         if isMember:
             # We have to make a copy, except in the variadic case, because our
             # jsval may well not live as long as our string needs to.
             declType = CGGeneric("nsString")
             if isMember == "Variadic":
                 # The string is kept alive by the argument, so we can just
                 # depend on it.
                 assignString = "${declName}.Rebind(str.Data(), str.Length());\n"
             else:
                 assignString = "${declName} = str;\n"
             return JSToNativeConversionInfo(
                 fill(
                     """
                     {
-                      binding_detail::FakeDependentString str;
+                      %s str;
                       $*{convert}
                       $*{assign}
                     }
-                    """,
+                    """ % holderTypeString,
                     convert=getConversionCode("str"),
                     assign=assignString),
                 declType=declType,
                 dealWithOptional=isOptional)
 
         if isOptional:
             declType = "Optional<nsAString>"
-            holderType = CGGeneric("binding_detail::FakeDependentString")
+            holderType = CGGeneric(holderTypeString);
             conversionCode = ("%s"
-                              "${declName} = &${holderName};\n" %
+                              "${declName} = ${holderName}.ToAStringPtr();\n" %
                               getConversionCode("${holderName}"))
         else:
-            declType = "binding_detail::FakeDependentString"
+            declType = holderTypeString;
             holderType = None
             conversionCode = getConversionCode("${declName}")
 
         # No need to deal with optional here; we handled it already
         return JSToNativeConversionInfo(
             conversionCode,
             declType=CGGeneric(declType),
             holderType=holderType)
@@ -5333,17 +5338,17 @@ def getWrapTemplateForType(type, descrip
             else:
                 getIID = ""
             wrap = "WrapObject(cx, %s, %s${jsvalHandle})" % (result, getIID)
             failed = None
 
         wrappingCode += wrapAndSetPtr(wrap, failed)
         return (wrappingCode, False)
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         if type.nullable():
             return (wrapAndSetPtr("xpc::StringToJsval(cx, %s, ${jsvalHandle})" % result), False)
         else:
             return (wrapAndSetPtr("xpc::NonVoidStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
 
     if type.isByteString():
         if type.nullable():
             return (wrapAndSetPtr("ByteStringToJsval(cx, %s, ${jsvalHandle})" % result), False)
@@ -5605,17 +5610,17 @@ def getRetvalDeclarationForType(returnTy
     if returnType is None or returnType.isVoid():
         # Nothing to declare
         return None, None, None, None
     if returnType.isPrimitive() and returnType.tag() in builtinNames:
         result = CGGeneric(builtinNames[returnType.tag()])
         if returnType.nullable():
             result = CGTemplatedType("Nullable", result)
         return result, None, None, None
-    if returnType.isDOMString():
+    if returnType.isDOMString() or returnType.isScalarValueString():
         if isMember:
             return CGGeneric("nsString"), "ref", None, None
         return CGGeneric("DOMString"), "ref", None, None
     if returnType.isByteString():
         return CGGeneric("nsCString"), "ref", None, None
     if returnType.isEnum():
         result = CGGeneric(returnType.unroll().inner.identifier.name)
         if returnType.nullable():
@@ -7974,17 +7979,17 @@ def getUnionAccessorSignatureType(type, 
         return typeName
 
     if type.isSpiderMonkeyInterface():
         typeName = CGGeneric(type.name)
         if type.nullable():
             typeName = CGTemplatedType("Nullable", typeName)
         return CGWrapper(typeName, post="&")
 
-    if type.isDOMString():
+    if type.isDOMString() or type.isScalarValueString():
         return CGGeneric("const nsAString&")
 
     if type.isByteString():
         return CGGeneric("const nsCString&")
 
     if type.isEnum():
         if type.nullable():
             raise TypeError("We don't support nullable enumerated arguments or "
@@ -11537,17 +11542,17 @@ class CGNativeMember(ClassMethod):
             result = CGGeneric(builtinNames[type.tag()])
             defaultReturnArg = "0"
             if type.nullable():
                 result = CGTemplatedType("Nullable", result)
                 defaultReturnArg = ""
             return (result.define(),
                     "%s(%s)" % (result.define(), defaultReturnArg),
                     "return ${declName};\n")
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 # No need for a third element in the isMember case
                 return "nsString", None, None
             # Outparam
             return "void", "", "aRetVal = ${declName};\n"
         if type.isByteString():
             if isMember:
                 # No need for a third element in the isMember case
@@ -11657,17 +11662,17 @@ class CGNativeMember(ClassMethod):
             return "void", "", ""
 
         raise TypeError("Don't know how to declare return value for %s" %
                         type)
 
     def getArgs(self, returnType, argList):
         args = [self.getArg(arg) for arg in argList]
         # Now the outparams
-        if returnType.isDOMString():
+        if returnType.isDOMString() or returnType.isScalarValueString():
             args.append(Argument("nsString&", "aRetVal"))
         elif returnType.isByteString():
             args.append(Argument("nsCString&", "aRetVal"))
         elif returnType.isSequence():
             nullable = returnType.nullable()
             if nullable:
                 returnType = returnType.inner
             # And now the actual underlying type
@@ -11783,17 +11788,17 @@ class CGNativeMember(ClassMethod):
                     False, False)
 
         if type.isSpiderMonkeyInterface():
             if self.jsObjectsArePtr:
                 return "JSObject*", False, False
 
             return type.name, True, True
 
-        if type.isDOMString():
+        if type.isDOMString() or type.isScalarValueString():
             if isMember:
                 declType = "nsString"
             else:
                 declType = "nsAString"
             return declType, True, False
 
         if type.isByteString():
             declType = "nsCString"
@@ -13554,17 +13559,17 @@ class CGEventGetter(CGNativeMember):
             raise TypeError("Event code generators does not support static attributes")
         return CGNativeMember.getArgs(self, returnType, argList)
 
     def getMethodBody(self):
         type = self.member.type
         memberName = CGDictionary.makeMemberName(self.member.identifier.name)
         if (type.isPrimitive() and type.tag() in builtinNames) or type.isEnum() or type.isGeckoInterface():
             return "return " + memberName + ";\n"
-        if type.isDOMString() or type.isByteString():
+        if type.isDOMString() or type.isByteString() or type.isScalarValueString():
             return "aRetVal = " + memberName + ";\n"
         if type.isSpiderMonkeyInterface() or type.isObject():
             return fill(
                 """
                 if (${memberName}) {
                   JS::ExposeObjectToActiveJS(${memberName});
                 }
                 aRetVal.set(${memberName});
@@ -13710,17 +13715,17 @@ class CGEventClass(CGBindingImplClass):
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable", nativeType)
                     nativeType = nativeType.define()
                 elif m.type.isEnum():
                     nativeType = m.type.unroll().inner.identifier.name
                     if m.type.nullable():
                         nativeType = CGTemplatedType("Nullable",
                                                      CGGeneric(nativeType)).define()
-                elif m.type.isDOMString():
+                elif m.type.isDOMString() or m.type.isScalarValueString():
                     nativeType = "nsString"
                 elif m.type.isByteString():
                     nativeType = "nsCString"
                 elif m.type.isGeckoInterface():
                     iface = m.type.unroll().inner
                     nativeType = self.descriptor.getDescriptor(
                         iface.identifier.name).nativeType
                     # Now trim off unnecessary namespaces
