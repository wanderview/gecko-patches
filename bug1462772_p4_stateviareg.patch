# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  805123a4bb94d8c23708e194b9869b59229ba043
Bug 1462772 P4 Route ServiceWorker state changes through the ServiceWorkerRegistration. r=mrbkap

diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -7,16 +7,17 @@
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
 #include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerImpl.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
+#include "ServiceWorkerRegistration.h"
 
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/WorkerPrivate.h"
 
@@ -69,16 +70,17 @@ ServiceWorker::Create(nsIGlobalObject* a
 }
 
 ServiceWorker::ServiceWorker(nsIGlobalObject* aGlobal,
                              const ServiceWorkerDescriptor& aDescriptor,
                              ServiceWorker::Inner* aInner)
   : DOMEventTargetHelper(aGlobal)
   , mDescriptor(aDescriptor)
   , mInner(aInner)
+  , mLastNotifiedState(ServiceWorkerState::Installing)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(aGlobal);
   MOZ_DIAGNOSTIC_ASSERT(mInner);
 
   KeepAliveIfHasListenersFor(NS_LITERAL_STRING("statechange"));
 
   // The error event handler is required by the spec currently, but is not used
@@ -142,28 +144,34 @@ ServiceWorkerState
 ServiceWorker::State() const
 {
   return mDescriptor.State();
 }
 
 void
 ServiceWorker::SetState(ServiceWorkerState aState)
 {
-  ServiceWorkerState oldState = mDescriptor.State();
+  NS_ENSURE_TRUE_VOID(aState >= mDescriptor.State());
   mDescriptor.SetState(aState);
-  if (oldState == aState) {
+}
+
+void
+ServiceWorker::MaybeDispatchStateChangeEvent()
+{
+  if (mDescriptor.State() <= mLastNotifiedState || !GetParentObject()) {
     return;
   }
+  mLastNotifiedState = mDescriptor.State();
 
   DOMEventTargetHelper::DispatchTrustedEvent(NS_LITERAL_STRING("statechange"));
 
   // Once we have transitioned to the redundant state then no
   // more statechange events will occur.  We can allow the DOM
   // object to GC if script is not holding it alive.
-  if (mDescriptor.State() == ServiceWorkerState::Redundant) {
+  if (mLastNotifiedState == ServiceWorkerState::Redundant) {
     IgnoreKeepAliveIfHasListenersFor(NS_LITERAL_STRING("statechange"));
   }
 }
 
 void
 ServiceWorker::GetScriptURL(nsString& aURL) const
 {
   CopyUTF8toUTF16(mDescriptor.ScriptURL(), aURL);
@@ -231,13 +239,21 @@ ServiceWorker::DisconnectFromOwner()
 }
 
 void
 ServiceWorker::MaybeAttachToRegistration(ServiceWorkerRegistration* aRegistration)
 {
   MOZ_DIAGNOSTIC_ASSERT(aRegistration);
   MOZ_DIAGNOSTIC_ASSERT(!mRegistration);
 
+  // If the registration no longer actually references this ServiceWorker
+  // then we must be in the redundant state.
+  if (!aRegistration->Descriptor().HasWorker(mDescriptor)) {
+    SetState(ServiceWorkerState::Redundant);
+    MaybeDispatchStateChangeEvent();
+    return;
+  }
+
   mRegistration = aRegistration;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -84,16 +84,19 @@ public:
 
   ServiceWorkerState
   State() const;
 
   void
   SetState(ServiceWorkerState aState);
 
   void
+  MaybeDispatchStateChangeEvent();
+
+  void
   GetScriptURL(nsString& aURL) const;
 
   void
   PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
               const Sequence<JSObject*>& aTransferable, ErrorResult& aRv);
 
   const ServiceWorkerDescriptor&
   Descriptor() const;
@@ -111,16 +114,17 @@ private:
 
   void
   MaybeAttachToRegistration(ServiceWorkerRegistration* aRegistration);
 
   ServiceWorkerDescriptor mDescriptor;
 
   RefPtr<Inner> mInner;
   RefPtr<ServiceWorkerRegistration> mRegistration;
+  ServiceWorkerState mLastNotifiedState;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ServiceWorker, NS_DOM_SERVICEWORKER_IID)
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_serviceworker_h__
diff --git a/dom/serviceworkers/ServiceWorkerImpl.cpp b/dom/serviceworkers/ServiceWorkerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerImpl.cpp
@@ -7,30 +7,24 @@
 #include "ServiceWorkerImpl.h"
 
 namespace mozilla {
 namespace dom {
 
 ServiceWorkerImpl::~ServiceWorkerImpl()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mOuter);
-  mInfo->RemoveListener(this);
 }
 
 void
 ServiceWorkerImpl::AddServiceWorker(ServiceWorker* aWorker)
 {
   MOZ_DIAGNOSTIC_ASSERT(!mOuter);
   MOZ_DIAGNOSTIC_ASSERT(aWorker);
   mOuter = aWorker;
-
-  // Wait to attach to the info as a listener until we have the outer
-  // set.  This is important because the info will try to set the
-  // state immediately.
-  mInfo->AddListener(this);
 }
 
 void
 ServiceWorkerImpl::RemoveServiceWorker(ServiceWorker* aWorker)
 {
   MOZ_DIAGNOSTIC_ASSERT(mOuter);
   MOZ_DIAGNOSTIC_ASSERT(mOuter == aWorker);
   mOuter = nullptr;
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -135,44 +135,80 @@ void
 ServiceWorkerRegistration::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
   MOZ_DIAGNOSTIC_ASSERT(MatchesDescriptor(aDescriptor));
 
   mDescriptor = aDescriptor;
 
   nsCOMPtr<nsIGlobalObject> global = GetParentObject();
 
+  AutoTArray<RefPtr<ServiceWorker>, 3> oldWorkerList;
+  oldWorkerList.AppendElement(mInstallingWorker.forget());
+  oldWorkerList.AppendElement(mWaitingWorker.forget());
+  oldWorkerList.AppendElement(mActiveWorker.forget());
+
+  auto scopeExit = MakeScopeExit([&] {
+    for (auto& oldWorker : oldWorkerList) {
+      if (!oldWorker ||
+           oldWorker == mInstallingWorker ||
+           oldWorker == mWaitingWorker ||
+           oldWorker == mActiveWorker) {
+        continue;
+      }
+
+      oldWorker->SetState(ServiceWorkerState::Redundant);
+    }
+
+    if (mInstallingWorker) {
+      mInstallingWorker->MaybeDispatchStateChangeEvent();
+    }
+    if (mWaitingWorker) {
+      mWaitingWorker->MaybeDispatchStateChangeEvent();
+    }
+    if (mActiveWorker) {
+      mActiveWorker->MaybeDispatchStateChangeEvent();
+    }
+
+    for (auto& oldWorker : oldWorkerList) {
+      if (!oldWorker) {
+        continue;
+      }
+
+      oldWorker->MaybeDispatchStateChangeEvent();
+    }
+  });
+
   // Clear all workers if the registration has been detached from the global.
   // Also, we cannot expose ServiceWorker objects on worker threads yet, so
   // do the same on when off-main-thread.  This main thread check should be
   // removed as part of bug 1113522.
   if (!global || !NS_IsMainThread()) {
-    mInstallingWorker = nullptr;
-    mWaitingWorker = nullptr;
-    mActiveWorker = nullptr;
     return;
   }
 
   Maybe<ServiceWorkerDescriptor> active = aDescriptor.GetActive();
   if (active.isSome()) {
     mActiveWorker = global->GetOrCreateServiceWorker(active.ref());
+    mActiveWorker->SetState(active.ref().State());
   } else {
     mActiveWorker = nullptr;
   }
 
   Maybe<ServiceWorkerDescriptor> waiting = aDescriptor.GetWaiting();
   if (waiting.isSome()) {
     mWaitingWorker = global->GetOrCreateServiceWorker(waiting.ref());
+    mWaitingWorker->SetState(waiting.ref().State());
   } else {
     mWaitingWorker = nullptr;
   }
 
   Maybe<ServiceWorkerDescriptor> installing = aDescriptor.GetInstalling();
   if (installing.isSome()) {
     mInstallingWorker = global->GetOrCreateServiceWorker(installing.ref());
+    mInstallingWorker->SetState(installing.ref().State());
   } else {
     mInstallingWorker = nullptr;
   }
 }
 
 bool
 ServiceWorkerRegistration::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) const
 {
@@ -340,10 +376,16 @@ ServiceWorkerRegistration::GetNotificati
     return Notification::Get(window, aOptions, scope, aRv);
   }
 
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   worker->AssertIsOnWorkerThread();
   return Notification::WorkerGet(worker, aOptions, scope, aRv);
 }
 
+const ServiceWorkerRegistrationDescriptor&
+ServiceWorkerRegistration::Descriptor() const
+{
+  return mDescriptor;
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -111,16 +111,19 @@ public:
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv);
 
+  const ServiceWorkerRegistrationDescriptor&
+  Descriptor() const;
+
 private:
   ServiceWorkerRegistration(nsIGlobalObject* aGlobal,
                             const ServiceWorkerRegistrationDescriptor& aDescriptor,
                             Inner* aInner);
 
   ~ServiceWorkerRegistration();
 
   ServiceWorkerRegistrationDescriptor mDescriptor;
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
@@ -192,16 +192,27 @@ ServiceWorkerRegistrationDescriptor::New
   Maybe<ServiceWorkerDescriptor> result;
   Maybe<IPCServiceWorkerDescriptor> newest(NewestInternal());
   if (newest.isSome()) {
     result.emplace(ServiceWorkerDescriptor(newest.ref()));
   }
   return result;
 }
 
+bool
+ServiceWorkerRegistrationDescriptor::HasWorker(const ServiceWorkerDescriptor& aDescriptor) const
+{
+  Maybe<ServiceWorkerDescriptor> installing = GetInstalling();
+  Maybe<ServiceWorkerDescriptor> waiting = GetWaiting();
+  Maybe<ServiceWorkerDescriptor> active = GetActive();
+  return (installing.isSome() && installing.ref().Matches(aDescriptor)) ||
+         (waiting.isSome() && waiting.ref().Matches(aDescriptor)) ||
+         (active.isSome() && active.ref().Matches(aDescriptor));
+}
+
 namespace {
 
 bool
 IsValidWorker(const OptionalIPCServiceWorkerDescriptor& aWorker,
               const nsACString& aScope,
               const mozilla::ipc::ContentPrincipalInfo& aContentPrincipal)
 {
   if (aWorker.type() == OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
@@ -87,16 +87,19 @@ public:
 
   Maybe<ServiceWorkerDescriptor>
   GetActive() const;
 
   Maybe<ServiceWorkerDescriptor>
   Newest() const;
 
   bool
+  HasWorker(const ServiceWorkerDescriptor& aDescriptor) const;
+
+  bool
   IsValid() const;
 
   void
   SetUpdateViaCache(ServiceWorkerUpdateViaCache aUpdateViaCache);
 
   void
   SetWorkers(ServiceWorkerInfo* aInstalling,
              ServiceWorkerInfo* aWaiting,
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -100,18 +100,33 @@ void
 ServiceWorkerRegistrationMainThread::UpdateFound()
 {
   mOuter->DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
 }
 
 void
 ServiceWorkerRegistrationMainThread::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  mDescriptor = aDescriptor;
-  mOuter->UpdateState(aDescriptor);
+  NS_ENSURE_TRUE_VOID(mOuter);
+
+  nsIGlobalObject* global = mOuter->GetParentObject();
+  NS_ENSURE_TRUE_VOID(global);
+
+  RefPtr<ServiceWorkerRegistrationMainThread> self = this;
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
+    "ServiceWorkerRegistrationMainThread::UpdateState",
+    [self, desc = std::move(aDescriptor)] () mutable {
+      self->mDescriptor = std::move(desc);
+      NS_ENSURE_TRUE_VOID(self->mOuter);
+      self->mOuter->UpdateState(self->mDescriptor);
+    });
+
+  Unused <<
+    global->EventTargetFor(TaskCategory::Other)->Dispatch(r.forget(),
+                                                          NS_DISPATCH_NORMAL);
 }
 
 void
 ServiceWorkerRegistrationMainThread::RegistrationRemoved()
 {
   // Queue a runnable to clean up the registration.  This is necessary
   // because there may be runnables in the event queue already to
   // update the registration state.  We want to let those run
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -51,18 +51,16 @@ ServiceWorkerRegistrationInfo::Clear()
   if (mEvaluatingWorker) {
     mEvaluatingWorker = nullptr;
   }
 
   RefPtr<ServiceWorkerInfo> installing = mInstallingWorker.forget();
   RefPtr<ServiceWorkerInfo> waiting = mWaitingWorker.forget();
   RefPtr<ServiceWorkerInfo> active = mActiveWorker.forget();
 
-  UpdateRegistrationState();
-
   if (installing) {
     installing->UpdateState(ServiceWorkerState::Redundant);
     installing->UpdateRedundantTime();
     installing->WorkerPrivate()->NoteDeadServiceWorkerInfo();
     // FIXME(nsm): Abort any inflight requests from installing worker.
   }
 
   if (waiting) {
@@ -72,16 +70,17 @@ ServiceWorkerRegistrationInfo::Clear()
   }
 
   if (active) {
     active->UpdateState(ServiceWorkerState::Redundant);
     active->UpdateRedundantTime();
     active->WorkerPrivate()->NoteDeadServiceWorkerInfo();
   }
 
+  UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::ClearAsCorrupt()
 {
   mCorrupt = true;
   Clear();
@@ -361,16 +360,17 @@ ServiceWorkerRegistrationInfo::FinishAct
   }
 
   // Activation never fails, so aSuccess is ignored.
   mActiveWorker->UpdateState(ServiceWorkerState::Activated);
   mActiveWorker->UpdateActivatedTime();
 
   mDescriptor.SetWorkers(mInstallingWorker, mWaitingWorker, mActiveWorker);
 
+  UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // browser shutdown started during async activation completion step
     return;
   }
   swm->StoreRegistration(mPrincipal, this);
@@ -413,26 +413,20 @@ ServiceWorkerRegistrationInfo::IsLastUpd
 
 void
 ServiceWorkerRegistrationInfo::UpdateRegistrationState()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   mDescriptor.SetWorkers(mInstallingWorker, mWaitingWorker, mActiveWorker);
 
-  RefPtr<ServiceWorkerRegistrationInfo> self(this);
-  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
-    "ServiceWorkerRegistrationInfo::UpdateRegistrationState",
-    [self = std::move(self)] {
-      RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-      if (swm) {
-        swm->UpdateRegistrationListeners(self);
-      }
-    });
-  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  NS_ENSURE_TRUE_VOID(swm);
+
+  swm->UpdateRegistrationListeners(this);
 }
 
 void
 ServiceWorkerRegistrationInfo::NotifyChromeRegistrationListeners()
 {
   nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> listeners(mListeners);
   for (size_t index = 0; index < listeners.Length(); ++index) {
     listeners[index]->OnChange();
@@ -566,60 +560,54 @@ ServiceWorkerRegistrationInfo::ClearInst
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!mInstallingWorker) {
     return;
   }
 
   RefPtr<ServiceWorkerInfo> installing = mInstallingWorker.forget();
-
-  UpdateRegistrationState();
-
   installing->UpdateState(ServiceWorkerState::Redundant);
   installing->UpdateRedundantTime();
 
+  UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionEvaluatingToInstalling()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mEvaluatingWorker);
   MOZ_ASSERT(!mInstallingWorker);
 
   mInstallingWorker = mEvaluatingWorker.forget();
+  mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
 
   UpdateRegistrationState();
-
-  mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
-
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionInstallingToWaiting()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mInstallingWorker);
 
   if (mWaitingWorker) {
     MOZ_ASSERT(mInstallingWorker->CacheName() != mWaitingWorker->CacheName());
     mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
     mWaitingWorker->UpdateRedundantTime();
   }
 
   mWaitingWorker = mInstallingWorker.forget();
-
-  UpdateRegistrationState();
-
   mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
   mWaitingWorker->UpdateInstalledTime();
 
+  UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 
   // TODO: When bug 1426401 is implemented we will need to call
   //       StoreRegistration() here to persist the waiting worker.
 }
 
 void
 ServiceWorkerRegistrationInfo::SetActive(ServiceWorkerInfo* aServiceWorker)
@@ -645,17 +633,16 @@ ServiceWorkerRegistrationInfo::SetActive
   // another process activating a worker.  Move straight to the
   // Activated state.
   mActiveWorker = aServiceWorker;
   mActiveWorker->SetActivateStateUncheckedWithoutEvent(ServiceWorkerState::Activated);
 
   // We don't need to update activated time when we load registration from
   // registrar.
   UpdateRegistrationState();
-
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionWaitingToActive()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mWaitingWorker);
@@ -664,31 +651,29 @@ ServiceWorkerRegistrationInfo::Transitio
     MOZ_ASSERT(mWaitingWorker->CacheName() != mActiveWorker->CacheName());
     mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
     mActiveWorker->UpdateRedundantTime();
   }
 
   // We are transitioning from waiting to active normally, so go to
   // the activating state.
   mActiveWorker = mWaitingWorker.forget();
-
-  UpdateRegistrationState();
-
   mActiveWorker->UpdateState(ServiceWorkerState::Activating);
 
   nsCOMPtr<nsIRunnable> r =
     NS_NewRunnableFunction("ServiceWorkerRegistrationInfo::TransitionWaitingToActive",
     [] {
       RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
       if (swm) {
         swm->CheckPendingReadyPromises();
       }
     });
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 
+  UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 }
 
 bool
 ServiceWorkerRegistrationInfo::IsIdle() const
 {
   return !mActiveWorker || mActiveWorker->WorkerPrivate()->IsIdle();
 }
