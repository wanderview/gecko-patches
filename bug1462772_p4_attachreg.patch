# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1c560bb6d7b54b2d081ee8eb0531daf8b30cbcf9
Bug 1462772 P4 Make ServiceWorker objects add themselves to the ServiceWorkerRegistration as a weak point back reference. r=baku

diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -89,47 +89,58 @@ ServiceWorker::ServiceWorker(nsIGlobalOb
   // The error event handler is required by the spec currently, but is not used
   // anywhere.  Don't keep the object alive in that case.
 
   // This will update our state too.
   mInner->AddServiceWorker(this);
 
   // Attempt to get an existing binding object for the registration
   // associated with this ServiceWorker.
-  mRegistration = aGlobal->GetServiceWorkerRegistration(
+  RefPtr<ServiceWorkerRegistration> reg = aGlobal->GetServiceWorkerRegistration(
     ServiceWorkerRegistrationDescriptor(mDescriptor.RegistrationId(),
                                         mDescriptor.PrincipalInfo(),
                                         mDescriptor.Scope(),
                                         ServiceWorkerUpdateViaCache::Imports));
-  if (!mRegistration) {
+  if (reg) {
+    AttachToRegistration(Move(reg));
+  } else {
     RefPtr<ServiceWorker> self = this;
 
     mInner->GetRegistration()->Then(
       aGlobal->EventTargetFor(TaskCategory::Other), __func__,
       [self] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
         self->mRegistrationPromiseHolder.Complete();
         nsIGlobalObject* global = self->GetParentObject();
-        self->mRegistration =
+        RefPtr<ServiceWorkerRegistration> reg =
           global->GetOrCreateServiceWorkerRegistration(aDescriptor);
+        self->AttachToRegistration(Move(reg));
       }, [self] (const CopyableErrorResult& aRv) {
         self->mRegistrationPromiseHolder.Complete();
         // do nothing
       })->Track(mRegistrationPromiseHolder);
   }
 }
 
 ServiceWorker::~ServiceWorker()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  MaybeDetachFromRegistration();
   mInner->RemoveServiceWorker(this);
 }
 
-NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorker,
-                                   DOMEventTargetHelper,
-                                   mRegistration);
+NS_IMPL_CYCLE_COLLECTION_CLASS(ServiceWorker)
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(ServiceWorker, DOMEventTargetHelper)
+  // We must call mRegistration->RemoveWorker() before we drop our reference.
+  tmp->MaybeDetachFromRegistration();
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(ServiceWorker, DOMEventTargetHelper)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRegistration)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorker, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorker, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorker)
   NS_INTERFACE_MAP_ENTRY(ServiceWorker)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
@@ -229,10 +240,28 @@ ServiceWorker::Descriptor() const
 
 void
 ServiceWorker::DisconnectFromOwner()
 {
   mRegistrationPromiseHolder.DisconnectIfExists();
   DOMEventTargetHelper::DisconnectFromOwner();
 }
 
+void
+ServiceWorker::AttachToRegistration(RefPtr<ServiceWorkerRegistration>&& aRegistration)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aRegistration);
+  MOZ_DIAGNOSTIC_ASSERT(!mRegistration);
+  mRegistration = Move(aRegistration);
+  mRegistration->AddWorker(this);
+}
+
+void
+ServiceWorker::MaybeDetachFromRegistration()
+{
+  if (mRegistration) {
+    mRegistration->RemoveWorker(this);
+    mRegistration = nullptr;
+  }
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -103,16 +103,22 @@ public:
 private:
   ServiceWorker(nsIGlobalObject* aWindow,
                 const ServiceWorkerDescriptor& aDescriptor,
                 Inner* aInner);
 
   // This class is reference-counted and will be destroyed from Release().
   ~ServiceWorker();
 
+  void
+  AttachToRegistration(RefPtr<ServiceWorkerRegistration>&& aRegistration);
+
+  void
+  MaybeDetachFromRegistration();
+
   ServiceWorkerDescriptor mDescriptor;
 
   RefPtr<Inner> mInner;
   RefPtr<ServiceWorkerRegistration> mRegistration;
   MozPromiseRequestHolder<ServiceWorkerRegistrationPromise> mRegistrationPromiseHolder;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ServiceWorker, NS_DOM_SERVICEWORKER_IID)
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -363,10 +363,26 @@ ServiceWorkerRegistration::GetNotificati
     return Notification::Get(window, aOptions, scope, aRv);
   }
 
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   worker->AssertIsOnWorkerThread();
   return Notification::WorkerGet(worker, aOptions, scope, aRv);
 }
 
+void
+ServiceWorkerRegistration::AddWorker(ServiceWorker* aWorker)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWorker);
+  MOZ_ASSERT(!mWorkerList.Contains(aWorker));
+  mWorkerList.AppendElement(aWorker);
+}
+
+void
+ServiceWorkerRegistration::RemoveWorker(ServiceWorker* aWorker)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWorker);
+  DebugOnly<bool> removed = mWorkerList.RemoveElement(aWorker);
+  MOZ_ASSERT(removed);
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -4,24 +4,22 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerRegistration_h
 #define mozilla_dom_ServiceWorkerRegistration_h
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/DOMPrefs.h"
+#include "mozilla/dom/NotificationBinding.h"
 #include "mozilla/dom/ServiceWorkerBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationDescriptor.h"
 #include "mozilla/dom/ServiceWorkerUtils.h"
 
-// Support for Notification API extension.
-#include "mozilla/dom/NotificationBinding.h"
-
 class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 class PushManager;
 class WorkerPrivate;
@@ -109,30 +107,38 @@ public:
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv);
 
+  void
+  AddWorker(ServiceWorker* aWorker);
+
+  void
+  RemoveWorker(ServiceWorker* aWorker);
+
 private:
   ServiceWorkerRegistration(nsIGlobalObject* aGlobal,
                             const ServiceWorkerRegistrationDescriptor& aDescriptor,
                             Inner* aInner);
 
   ~ServiceWorkerRegistration();
 
   ServiceWorkerRegistrationDescriptor mDescriptor;
   RefPtr<Inner> mInner;
 
   RefPtr<ServiceWorker> mInstallingWorker;
   RefPtr<ServiceWorker> mWaitingWorker;
   RefPtr<ServiceWorker> mActiveWorker;
   RefPtr<PushManager> mPushManager;
+
+  nsTArray<ServiceWorker*> mWorkerList;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ServiceWorkerRegistration, NS_DOM_SERVICEWORKERREGISTRATION_IID)
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_ServiceWorkerRegistration_h */
