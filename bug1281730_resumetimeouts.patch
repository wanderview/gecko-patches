# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  82e1f1b9c0559f38a8460e2f2f3044de4c7712d6
Bug 1281730 Restore timeouts before thawing workers to avoid running script on frozen timers. r=khuey

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13073,23 +13073,16 @@ nsGlobalWindow::ResumeTimeouts(bool aTha
     EnableGamepadUpdates();
 
     // Resume all of the AudioContexts for this window
     for (uint32_t i = 0; i < mAudioContexts.Length(); ++i) {
       ErrorResult dummy;
       RefPtr<Promise> d = mAudioContexts[i]->Resume(dummy);
     }
 
-    // Thaw or resume all of the workers for this window.
-    if (aThawWorkers) {
-      mozilla::dom::workers::ThawWorkersForWindow(AsInner());
-    } else {
-      mozilla::dom::workers::ResumeWorkersForWindow(AsInner());
-    }
-
     // Restore all of the timeouts, using the stored time remaining
     // (stored in timeout->mTimeRemaining).
 
     TimeStamp now = TimeStamp::Now();
 
 #ifdef DEBUG
     bool _seenDummyTimeout = false;
 #endif
@@ -13124,16 +13117,25 @@ nsGlobalWindow::ResumeTimeouts(bool aTha
       if (NS_FAILED(rv)) {
         t->mTimer = nullptr;
         return rv;
       }
 
       // Add a reference for the new timer's closure.
       t->AddRef();
     }
+
+    // Thaw or resume all of the workers for this window.  We must do this
+    // after timeouts since workers may have queued events that can trigger
+    // a setTimeout().
+    if (aThawWorkers) {
+      mozilla::dom::workers::ThawWorkersForWindow(AsInner());
+    } else {
+      mozilla::dom::workers::ResumeWorkersForWindow(AsInner());
+    }
   }
 
   // Resume our children as well.
   nsCOMPtr<nsIDocShell> docShell = GetDocShell();
   if (docShell) {
     int32_t childCount = 0;
     docShell->GetChildCount(&childCount);
 
