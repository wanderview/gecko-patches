# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d224fc999cb6accb208af0a105f14433375e2e77
Bug 1287906 Deduplicate serialized principal strings in SessionHistory.jsm. r=smaug

diff --git a/browser/components/sessionstore/SessionHistory.jsm b/browser/components/sessionstore/SessionHistory.jsm
--- a/browser/components/sessionstore/SessionHistory.jsm
+++ b/browser/components/sessionstore/SessionHistory.jsm
@@ -214,21 +214,31 @@ var SessionHistoryInternal = {
         entry.children = children;
       }
     }
 
     return entry;
   },
 
   /**
-   * Serialize owner data contained in the given session history entry.
+   * An array of nsIWeakReferences to { value: <b64string> } objects kept
+   * in LRU order.
+   */
+  _ownerB64Cache: [],
+
+  /**
+   * Serialize owner data contained in the given session history entry. The
+   * result is an object like { value: <b64string> }.  If you save a reference
+   * to the result please retain the entire object and not just the string.
+   * This allows our de-duping code to function properly.
    *
    * @param shEntry
    *        The session history entry.
-   * @return The base64 encoded owner data.
+   * @return The base64 encoded owner data wrapped in an object like
+   *         { value: <b64string> }.
    */
   serializeOwner: function (shEntry) {
     if (!shEntry.owner) {
       return null;
     }
 
     let binaryStream = Cc["@mozilla.org/binaryoutputstream;1"].
                        createInstance(Ci.nsIObjectOutputStream);
@@ -243,17 +253,78 @@ var SessionHistoryInternal = {
                            createInstance(Ci.nsIBinaryInputStream);
     scriptableStream.setInputStream(pipe.inputStream);
     let ownerBytes =
       scriptableStream.readByteArray(scriptableStream.available());
 
     // We can stop doing base64 encoding once our serialization into JSON
     // is guaranteed to handle all chars in strings, including embedded
     // nulls.
-    return btoa(String.fromCharCode.apply(null, ownerBytes));
+    let result = btoa(String.fromCharCode.apply(null, ownerBytes));
+
+    // Note, we can end up with many duplicate base64 strings here.  Sites
+    // like twitter create a lot of iframes owned by the same principal.
+    // To avoid many large, duplicate strings we use a cache of objects
+    // containing base64 strings we have seen recently.
+
+    // First, check to see if this owner base64 string matches our most
+    // recently returned value.  We optimize for this since its a common
+    // case.
+    let mostRecent = this._ownerB64Cache.length - 1;
+    if (mostRecent >== 0 &&
+        this._ownerB64Cache[mostRecent].get() &&
+        this._ownerB64Cache[mostRecent].get().value === result) {
+
+      return this._ownerB64Cache[mostRecent].get();
+    }
+
+    // Next, iterate over the entire cache looking for a matching string.
+    // While doing this we also remove any stale weak references we find.
+    let cached = null;
+    let oldCache = this._ownerB64Cache;
+    this._ownerB64Cache = [];
+    for (let i = 0; i < oldCache.length; ++i) {
+      let c = oldCache[i].get();
+      if (!c) {
+        // This is a stale reference, so don't include it in the new
+        // cache array.
+        continue;
+      }
+      if (c.value === result) {
+        // This is a matching value.  Remember it, but don't add it
+        // to the new cache array yet.  We will add it after the loop
+        // so that the most recent value is always at the end.
+        cached = c;
+        continue;
+      }
+      // We have a live, but non-matching value.  Simply remember
+      // it in out new cache array.
+      this._ownerB64Cache.push(c);
+    }
+
+    // If we found a matching value then append it to the end of the
+    // new cache array.  This maintains the LRU ordering.  Also return
+    // the cached string as our result.
+    if (cached) {
+      this._ownerB64Cache.push(cached);
+      return cached;
+    }
+
+    // Otherwise we need to extend the array with a new value.  Before
+    // doing this truncate the cache array to a reasonable length.  This
+    // should allow us to cache owning principals for the majority of
+    // sites while avoiding pathological algorithmic behavior here.
+    while (this._ownerB64Cache.length >= 20) {
+      this._ownerB64Cache.unshift();
+    }
+
+    // Finally, append the new result to our cache and return it.
+    result = { value: result };
+    this._ownerB64Cache.push(Cu.getWeakReference(result));
+    return result;
   },
 
   /**
    * Restores session history data for a given docShell.
    *
    * @param docShell
    *        The docShell that owns the session history.
    * @param tabData
@@ -377,17 +448,17 @@ var SessionHistoryInternal = {
         shEntry.adoptBFCacheEntry(matchingEntry.shEntry);
         childDocIdents = matchingEntry.childDocIdents;
       }
     }
 
     if (entry.owner_b64) {
       var ownerInput = Cc["@mozilla.org/io/string-input-stream;1"].
                        createInstance(Ci.nsIStringInputStream);
-      var binaryData = atob(entry.owner_b64);
+      var binaryData = atob(entry.owner_b64.value);
       ownerInput.setData(binaryData, binaryData.length);
       var binaryStream = Cc["@mozilla.org/binaryinputstream;1"].
                          createInstance(Ci.nsIObjectInputStream);
       binaryStream.setInputStream(ownerInput);
       try { // Catch possible deserialization exceptions
         shEntry.owner = binaryStream.readObject(true);
       } catch (ex) { debug(ex); }
     }
