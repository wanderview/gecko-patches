# HG changeset patch
# User Andrew Sutherland <asutherland@asutherland.org>
# Date 1511908804 18000
#      Tue Nov 28 17:40:04 2017 -0500
# Node ID 22b439b0c37cf9557f484c1022c1de2744428cda
# Parent  2ff08db67b917fba1558986f3f2f796260f970f8
Bug 1418795 - Test cancellation of diverted client-intercepted streams. r=bkelly

diff --git a/dom/workers/test/serviceworkers/browser.ini b/dom/workers/test/serviceworkers/browser.ini
--- a/dom/workers/test/serviceworkers/browser.ini
+++ b/dom/workers/test/serviceworkers/browser.ini
@@ -1,20 +1,24 @@
 [DEFAULT]
 support-files =
   browser_base_force_refresh.html
   browser_cached_force_refresh.html
   download/window.html
   download/worker.js
+  download_canceled/page_download_canceled.html
+  download_canceled/server-stream-download.sjs
+  download_canceled/sw_download_canceled.js
   fetch.js
   file_multie10s_update.html
   file_userContextId_openWindow.js
   force_refresh_browser_worker.js
   empty.html
   server_multie10s_update.sjs
 
 [browser_devtools_serviceworker_interception.js]
 [browser_force_refresh.js]
 [browser_download.js]
+[browser_download_canceled.js]
 [browser_multie10s_update.js]
 skip-if = !e10s || os != "win" # Bug 1404914
 [browser_userContextId_openWindow.js]
 skip-if = !e10s
diff --git a/dom/workers/test/serviceworkers/browser_download_canceled.js b/dom/workers/test/serviceworkers/browser_download_canceled.js
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/browser_download_canceled.js
@@ -0,0 +1,136 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+/*
+ * Test cancellation of a download in order to test edge-cases related to
+ * channel diversion.  Channel diversion occurs in cases of file (and PSM cert)
+ * downloads where we realize in the child that we really want to consume the
+ * channel data in the parent.  For data "sourced" by the parent, like network
+ * data, data streaming to the child is suspended and the parent waits for the
+ * child to send back the data it already received, then the channel is resumed.
+ * For data generated by the child, such as (the current, to be mooted by
+ * parent-intercept) child-side intercept, the data (currently) stream is
+ * continually pumped up to the parent.
+ *
+ * In particular, we want to reproduce the circumstances of Bug 1418795 where
+ * the child-side input-stream pump attempts to send data to the parent process
+ * but the parent has canceled the channel and so the IPC Actor has been torn
+ * down.  Diversion begins once the nsURILoader receives the OnStartRequest
+ * notification with the headers, so there are two ways to produce
+ */
+
+Cu.import('resource://gre/modules/Services.jsm');
+const { Downloads } = Cu.import("resource://gre/modules/Downloads.jsm", {});
+
+/**
+ * Clear the downloads list so other tests don't see our byproducts.
+ */
+async function clearDownloads() {
+  const downloads = await Downloads.getList(Downloads.ALL);
+  downloads.removeFinished();
+}
+
+/**
+ * Returns a Promise that will be resolved once the download dialog shows up and
+ * we have clicked the given button.
+ *
+ * Derived from browser/components/downloads/test/browser/head.js's
+ * self-contained promiseAlertDialogOpen helper, but modified to work on the
+ * download dialog instead of commonDialog.xul.
+ */
+function promiseClickDownloadDialogButton(buttonAction) {
+  return new Promise(resolve => {
+    Services.ww.registerNotification(function onOpen(win, topic, data) {
+      if (topic === "domwindowopened" && win instanceof Ci.nsIDOMWindow) {
+        // The test listens for the "load" event which guarantees that the alert
+        // class has already been added (it is added when "DOMContentLoaded" is
+        // fired).
+        win.addEventListener("load", function() {
+          info(`found window of type: ${win.document.documentURI}`);
+          if (win.document.documentURI ===
+                "chrome://mozapps/content/downloads/unknownContentType.xul") {
+            Services.ww.unregisterNotification(onOpen);
+
+            const button = win.document.documentElement.getButton(buttonAction);
+            button.disabled = false;
+            info(`clicking ${buttonAction} button`);
+            button.click();
+            resolve();
+          }
+        }, {once: true});
+      }
+    });
+  });
+}
+
+async function performCanceledDownload(tab, path) {
+  // Start waiting for the download dialog before triggering the download.
+  info("watching for download popup");
+  const cancelDownload = promiseClickDownloadDialogButton("cancel");
+
+  // Trigger the download.
+  info(`triggering download of "${path}"`);
+  await ContentTask.spawn(
+    tab.linkedBrowser,
+    path,
+    function(path) {
+      const link = content.document.createElement('a');
+      link.href = path;
+      link.download = path;
+      content.document.body.appendChild(link);
+      link.click();
+    });
+
+  // Wait for the cancelation to have been triggered.
+  info("waiting for download popup");
+  await cancelDownload;
+}
+
+const gTestRoot = getRootDirectory(gTestPath)
+  .replace("chrome://mochitests/content/", "http://mochi.test:8888/");
+
+
+const PAGE_URL = `${gTestRoot}download_canceled/page_download_canceled.html`;
+
+add_task(async function interruptedDownloads() {
+  await SpecialPowers.pushPrefEnv({'set': [
+    ['dom.serviceWorkers.enabled', true],
+    ['dom.serviceWorkers.exemptFromPerDomainMax', true],
+    ['dom.serviceWorkers.testing.enabled', true],
+    ["javascript.options.streams", true],
+    ["dom.streams.enabled", true],
+  ]});
+
+  // Open the tab
+  const tab = await BrowserTestUtils.openNewForegroundTab({
+    gBrowser,
+    opening: PAGE_URL
+  });
+
+  // Wait for it to become controlled.  Check that it was a promise that
+  // resolved as expected rather than undefined by checking the return value.
+  const controlled = await ContentTask.spawn(
+    tab.linkedBrowser,
+    null,
+    function() {
+      // This is a promise set up by the page during load, and we are post-load.
+      return content.wrappedJSObject.controlled;
+    });
+  is(controlled, "controlled", "page became controlled");
+
+  // Download a pass-through fetch stream.
+  await performCanceledDownload(tab, "sw-passthrough-download");
+
+  // Download a SW-generated stream
+  await performCanceledDownload(tab, "sw-stream-download");
+
+  // Cleanup
+  await ContentTask.spawn(
+    tab.linkedBrowser,
+    null,
+    function() {
+      return content.wrappedJSObject.registration.unregister();
+    });
+  await BrowserTestUtils.removeTab(tab);
+  await clearDownloads();
+});
\ No newline at end of file
diff --git a/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html b/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html
@@ -0,0 +1,34 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <meta charset="utf-8">
+</head>
+<body>
+
+<script type="text/javascript">
+function wait_until_controlled() {
+  return new Promise(function(resolve) {
+    if (navigator.serviceWorker.controller) {
+      return resolve('controlled');
+    }
+    navigator.serviceWorker.addEventListener('controllerchange', function onController() {
+      if (navigator.serviceWorker.controller) {
+        navigator.serviceWorker.removeEventListener('controllerchange', onController);
+        return resolve('controlled');
+      }
+    });
+  });
+}
+addEventListener('load', async function(event) {
+  window.controlled = wait_until_controlled();
+  window.registration =
+    await navigator.serviceWorker.register('sw_download_canceled.js');
+});
+</script>
+
+</body>
+</html>
diff --git a/dom/workers/test/serviceworkers/download_canceled/server-stream-download.sjs b/dom/workers/test/serviceworkers/download_canceled/server-stream-download.sjs
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/download_canceled/server-stream-download.sjs
@@ -0,0 +1,45 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+const { classes: Cc, interfaces: Ci, utils: Cu, results: Cr } = Components;
+
+Cu.import("resource://gre/modules/Timer.jsm");
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+/**
+ * Provide search suggestions in the OpenSearch JSON format.
+ */
+const MAX_COUNT = 3000;
+function handleRequest(request, response) {
+  const name = "server-stream-download";
+
+  // Create some payload to send.
+  let strChunk =
+    'Static routes are the future of ServiceWorkers! So say we all!\n';
+  while (strChunk.length < 1024) {
+    strChunk += strChunk;
+  }
+
+  response.setHeader("Content-Disposition", `attachment; filename="${name}"`);
+  response.setHeader("Content-Type", `application/octet-stream; name="${name}"`);
+  response.setHeader("Content-Length", `${strChunk.length * MAX_COUNT}`);
+
+  response.processAsync();
+  response.write(strChunk);
+
+  let count = 0;
+  let intervalId;
+  function tick() {
+    try {
+      // bound worst-case behavior.
+      if (count++ > MAX_COUNT) {
+        clearInterval(intervalId);
+        response.finish();
+      }
+      response.write(strChunk);
+    } catch(e) {
+      response.finish();
+    }
+  }
+  intervalId = setInterval(tick, 1);
+}
\ No newline at end of file
diff --git a/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
new file mode 100644
--- /dev/null
+++ b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
@@ -0,0 +1,73 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+// This file is derived from :bkelly's https://glitch.com/edit/#!/html-sw-stream
+
+addEventListener('install', evt => {
+  evt.waitUntil(self.skipWaiting());
+});
+
+addEventListener('activate', function(evt) {
+  evt.waitUntil(clients.claim());
+});
+
+/**
+ * Generate a continuous stream of data at a sufficiently high frequency that a
+ * there's a good chance of racing channel cancellation.
+ */
+function handleStream(evt, filename) {
+  // Create some payload to send.
+  const encoder = new TextEncoder();
+  let strChunk =
+    'Static routes are the future of ServiceWorkers! So say we all!\n';
+  while (strChunk.length < 1024) {
+    strChunk += strChunk;
+  }
+  const dataChunk = encoder.encode(strChunk);
+
+  evt.waitUntil(new Promise(resolve => {
+    let body = new ReadableStream({
+      start: controller => {
+        controller.enqueue(dataChunk);
+        let count = 0;
+        let intervalId;
+        function tick() {
+          try {
+            // bound worst-case behavior.
+            if (count++ > 3000) {
+              clearInterval(intervalId);
+              resolve();
+            }
+            controller.enqueue(dataChunk);
+          } catch(e) {
+            resolve();
+          }
+        }
+        intervalId = setInterval(tick, 1);
+      },
+    });
+    evt.respondWith(new Response(body, {
+      headers: {
+        'Content-Disposition': `attachment; filename="${filename}"`,
+        'Content-Type': 'application/octet-stream'
+      }
+    }));
+  }));
+}
+
+function handlePassThrough(evt) {
+  evt.respondWith(fetch('server-stream-download.sjs').then(response => {
+    console.log("server-stream-download.sjs Response received, propagating");
+    return response;
+  }));
+}
+
+addEventListener('fetch', evt => {
+  console.log(`SW processing fetch of ${evt.request.url}`);
+  if (evt.request.url.indexOf('sw-stream-download') >= 0) {
+    return handleStream(evt, 'sw-stream-download');
+  }
+  if (evt.request.url.indexOf('sw-passthrough-download') >= 0) {
+    return handlePassThrough(evt);
+  }
+})
\ No newline at end of file
