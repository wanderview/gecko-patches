# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  241a2d8c97d354afb295cd582da19c9ff4fc2174
Bug 1231211 P7 Pass the nsIChannel to ShouldPrepareForIntercept(). r=asuth

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -14245,26 +14245,26 @@ nsDocShell::MaybeNotifyKeywordSearchLoad
         obsSvc->NotifyObservers(searchEngine, "keyword-search", aKeyword.get());
       }
     }
   }
 #endif
 }
 
 NS_IMETHODIMP
-nsDocShell::ShouldPrepareForIntercept(nsIURI* aURI, bool aIsNonSubresourceRequest,
+nsDocShell::ShouldPrepareForIntercept(nsIURI* aURI, nsIChannel* aChannel,
                                       bool* aShouldIntercept)
 {
   *aShouldIntercept = false;
 
   // For subresource requests we base our decision solely on the client's
   // controller value.  Any settings that would have blocked service worker
   // access should have been set before the initial navigation created the
   // window.
-  if (!aIsNonSubresourceRequest) {
+  if (!nsContentUtils::IsNonSubresourceRequest(aChannel)) {
     nsCOMPtr<nsIDocument> doc = GetDocument();
     if (!doc) {
       return NS_ERROR_NOT_AVAILABLE;
     }
 
     ErrorResult rv;
     *aShouldIntercept = doc->GetController().isSome();
     if (NS_WARN_IF(rv.Failed())) {
diff --git a/netwerk/base/nsINetworkInterceptController.idl b/netwerk/base/nsINetworkInterceptController.idl
--- a/netwerk/base/nsINetworkInterceptController.idl
+++ b/netwerk/base/nsINetworkInterceptController.idl
@@ -242,20 +242,22 @@ interface nsIInterceptedChannel : nsISup
 
 [scriptable, uuid(70d2b4fe-a552-48cd-8d93-1d8437a56b53)]
 interface nsINetworkInterceptController : nsISupports
 {
     /**
      * Returns true if a channel should avoid initiating any network
      * requests until specifically instructed to do so.
      *
-     * @param aURI the URI being requested by a channel
-     * @param aIsNavigate True if the request is for a navigation, false for a fetch.
+     * @param aURI The URI to be loaded.  Note, this may differ from
+     *             the channel's current URL in some cases.
+     * @param aChannel The channel that may be intercepted.  It will
+     *                 be in the state prior to calling OnStartRequest().
      */
-    bool shouldPrepareForIntercept(in nsIURI aURI, in bool aIsNonSubresourceRequest);
+    bool shouldPrepareForIntercept(in nsIURI aURI, in nsIChannel aChannel);
 
     /**
      * Notification when a given intercepted channel is prepared to accept a synthesized
      * response via the provided stream.
      *
      * @param aChannel the controlling interface for a channel that has been intercepted
      */
     void channelIntercepted(in nsIInterceptedChannel aChannel);
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -3072,17 +3072,17 @@ HttpBaseChannel::ShouldIntercept(nsIURI*
   // Note, HSTS upgrade redirects are often treated the same as internal
   // redirects.  In this case, however, we intentionally allow interception
   // of HSTS upgrade redirects.  This matches the expected spec behavior and
   // does not run the risk of infinite loops as described above.
   bool internalRedirect = mLastRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL;
 
   if (controller && mLoadInfo && !BypassServiceWorker() && !internalRedirect) {
     nsresult rv = controller->ShouldPrepareForIntercept(aURI ? aURI : mURI.get(),
-                                                        nsContentUtils::IsNonSubresourceRequest(this),
+                                                        this,
                                                         &shouldIntercept);
     if (NS_FAILED(rv)) {
       return false;
     }
   }
   return shouldIntercept;
 }
 
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -270,17 +270,17 @@ HttpChannelParentListener::OnRedirectRes
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelParentListener::nsINetworkInterceptController
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParentListener::ShouldPrepareForIntercept(nsIURI* aURI,
-                                                     bool aIsNonSubresourceRequest,
+                                                     nsIChannel* aChannel,
                                                      bool* aShouldIntercept)
 {
   *aShouldIntercept = mShouldIntercept;
   return NS_OK;
 }
 
 class HeaderVisitor final : public nsIHttpHeaderVisitor
 {
