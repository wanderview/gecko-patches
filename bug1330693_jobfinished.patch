# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9a82aa9968fc0a973820d8f392ef1d22d73cd163
Bug 1330693 Try to handle SW job double-completion better. r=ehsan

diff --git a/dom/workers/ServiceWorkerJob.cpp b/dom/workers/ServiceWorkerJob.cpp
--- a/dom/workers/ServiceWorkerJob.cpp
+++ b/dom/workers/ServiceWorkerJob.cpp
@@ -48,21 +48,21 @@ ServiceWorkerJob::IsEquivalentTo(Service
          mScriptSpec.Equals(aJob->mScriptSpec) &&
          mPrincipal->Equals(aJob->mPrincipal);
 }
 
 void
 ServiceWorkerJob::AppendResultCallback(Callback* aCallback)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(mState != State::Finished);
-  MOZ_ASSERT(aCallback);
-  MOZ_ASSERT(mFinalCallback != aCallback);
+  MOZ_DIAGNOSTIC_ASSERT(mState != State::Finished);
+  MOZ_DIAGNOSTIC_ASSERT(aCallback);
+  MOZ_DIAGNOSTIC_ASSERT(mFinalCallback != aCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aCallback));
-  MOZ_ASSERT(!mResultCallbacksInvoked);
+  MOZ_DIAGNOSTIC_ASSERT(!mResultCallbacksInvoked);
   mResultCallbackList.AppendElement(aCallback);
 }
 
 void
 ServiceWorkerJob::StealResultCallbacksFrom(ServiceWorkerJob* aJob)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
@@ -79,24 +79,24 @@ ServiceWorkerJob::StealResultCallbacksFr
     AppendResultCallback(callback);
   }
 }
 
 void
 ServiceWorkerJob::Start(Callback* aFinalCallback)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(!mCanceled);
+  MOZ_DIAGNOSTIC_ASSERT(!mCanceled);
 
-  MOZ_ASSERT(aFinalCallback);
-  MOZ_ASSERT(!mFinalCallback);
+  MOZ_DIAGNOSTIC_ASSERT(aFinalCallback);
+  MOZ_DIAGNOSTIC_ASSERT(!mFinalCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aFinalCallback));
   mFinalCallback = aFinalCallback;
 
-  MOZ_ASSERT(mState == State::Initial);
+  MOZ_DIAGNOSTIC_ASSERT(mState == State::Initial);
   mState = State::Started;
 
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod(this, &ServiceWorkerJob::AsyncExecute);
 
   // We may have to wait for the PBackground actor to be initialized
   // before proceeding.  We should always be able to get a ServiceWorkerManager,
   // however, since Start() should not be called during shutdown.
@@ -145,19 +145,19 @@ ServiceWorkerJob::~ServiceWorkerJob()
   MOZ_ASSERT(mState != State::Started);
   MOZ_ASSERT_IF(mState == State::Finished, mResultCallbacksInvoked);
 }
 
 void
 ServiceWorkerJob::InvokeResultCallbacks(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(mState == State::Started);
+  MOZ_DIAGNOSTIC_ASSERT(mState == State::Started);
 
-  MOZ_ASSERT(!mResultCallbacksInvoked);
+  MOZ_DIAGNOSTIC_ASSERT(!mResultCallbacksInvoked);
   mResultCallbacksInvoked = true;
 
   nsTArray<RefPtr<Callback>> callbackList;
   callbackList.SwapElements(mResultCallbackList);
 
   for (RefPtr<Callback>& callback : callbackList) {
     // The callback might consume an exception on the ErrorResult, so we need
     // to clone in order to maintain the error for the next callback.
@@ -177,17 +177,24 @@ ServiceWorkerJob::InvokeResultCallbacks(
   ErrorResult converted(aRv);
   InvokeResultCallbacks(converted);
 }
 
 void
 ServiceWorkerJob::Finish(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(mState == State::Started);
+
+  // Avoid double-completion because it can result on operating on cleaned
+  // up data.  This should not happen, though, so also assert to try to
+  // narrow down the causes.
+  MOZ_DIAGNOSTIC_ASSERT(mState == State::Started);
+  if (mState != State::Started) {
+    return;
+  }
 
   // Ensure that we only surface SecurityErr, TypeErr or InvalidStateErr to script.
   if (aRv.Failed() && !aRv.ErrorCodeIs(NS_ERROR_DOM_SECURITY_ERR) &&
                       !aRv.ErrorCodeIs(NS_ERROR_DOM_TYPE_ERR) &&
                       !aRv.ErrorCodeIs(NS_ERROR_DOM_INVALID_STATE_ERR)) {
 
     // Remove the old error code so we can replace it with a TypeError.
     aRv.SuppressException();
@@ -203,18 +210,21 @@ ServiceWorkerJob::Finish(ErrorResult& aR
   RefPtr<ServiceWorkerJob> kungFuDeathGrip = this;
 
   if (!mResultCallbacksInvoked) {
     InvokeResultCallbacks(aRv);
   }
 
   mState = State::Finished;
 
-  mFinalCallback->JobFinished(this, aRv);
-  mFinalCallback = nullptr;
+  MOZ_DIAGNOSTIC_ASSERT(mFinalCallback);
+  if (mFinalCallback) {
+    mFinalCallback->JobFinished(this, aRv);
+    mFinalCallback = nullptr;
+  }
 
   // The callback might not consume the error.
   aRv.SuppressException();
 
   // Async release this object to ensure that our caller methods complete
   // as well.
   NS_ReleaseOnMainThread(kungFuDeathGrip.forget(), true /* always proxy */);
 }
