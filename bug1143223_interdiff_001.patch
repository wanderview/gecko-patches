# HG changeset patch
# Parent 02bf32736877a7c18328ad3946b6da49a9d33f38
# User Ben Kelly <ben@wanderview.com>
Bug 1143223 interdiff 001 address review feedback


diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -126,24 +126,17 @@ ReadStream::Create(const PCacheReadStrea
   MOZ_ASSERT(stream);
 
   // Currently we expect all cache read streams to be blocking file streams.
 #ifdef DEBUG
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
   MOZ_ASSERT(!asyncStream);
 #endif
 
-  nsRefPtr<ReadStream> ref;
-
-  if (aReadStream.controlChild()) {
-    ref = new ReadStream(control, aReadStream.id(), stream);
-  } else {
-    ref = new ReadStream(control, aReadStream.id(), stream);
-  }
-
+  nsRefPtr<ReadStream> ref = new ReadStream(control, aReadStream.id(), stream);
   return ref.forget();
 }
 
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
                    nsIInputStream* aStream)
 {
@@ -208,114 +201,120 @@ ReadStream::ReadStream(StreamControl* aC
   , mId(aId)
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mOwningThread(NS_GetCurrentThread())
   , mClosed(false)
 {
   MOZ_ASSERT(mStream);
   mControl->SetReadStream(this);
+  printf_stderr("### ### [%p] ReadStream()\n", this);
 }
 
 ReadStream::~ReadStream()
 {
   // Any thread
   MOZ_ASSERT(mClosed);
 
+  printf_stderr("### ### [%p] ~ReadStream()\n", this);
+
   if (NS_GetCurrentThread() == mOwningThread) {
     return;
   }
 
   nsCOMPtr<nsIRunnable> runnable =
     NS_NewNonOwningRunnableMethod(mControl.forget().take(), &StreamControl::Release);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::NoteClosed()
 {
-  if (mClosed) {
-    return;
-  }
-
-  mClosed = true;
-
-  if (NS_GetCurrentThread() == mOwningThread) {
+  if (false && NS_GetCurrentThread() == mOwningThread) {
     NoteClosedOnOwningThread();
     return;
   }
 
   nsCOMPtr<nsIRunnable> runnable = new NoteClosedRunnable(this);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::Forget()
 {
-  if (mClosed) {
-    return;
-  }
-
-  mClosed = true;
-
   if (NS_GetCurrentThread() == mOwningThread) {
     ForgetOnOwningThread();
     return;
   }
 
   nsCOMPtr<nsIRunnable> runnable = new ForgetRunnable(this);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::NoteClosedOnOwningThread()
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
   mControl->NoteClosed(mId);
 }
 
 void
 ReadStream::ForgetOnOwningThread()
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
   mControl->ForgetReadStream();
 }
 
 NS_IMETHODIMP
 ReadStream::Close()
 {
+  printf_stderr("### ### [%p] ReadStream::Close()\n", this);
   nsresult rv = mStream->Close();
   NoteClosed();
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::Available(uint64_t* aNumAvailableOut)
 {
   nsresult rv = mSnappyStream->Available(aNumAvailableOut);
 
   if (NS_FAILED(rv)) {
+    printf_stderr("### ### [%p] ReadStream::Available() close\n", this);
     Close();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
 {
   MOZ_ASSERT(aNumReadOut);
 
   nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
 
   if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
       *aNumReadOut == 0) {
+    printf_stderr("### ### [%p] ReadStream::Read() close\n", this);
     Close();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
@@ -323,16 +322,17 @@ ReadStream::ReadSegments(nsWriteSegmentF
 {
   MOZ_ASSERT(aNumReadOut);
 
   nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
                                             aNumReadOut);
 
   if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
                         rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    printf_stderr("### ### [%p] ReadStream::ReadSegments() close\n", this);
     Close();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::IsNonBlocking(bool* aNonBlockingOut)
@@ -348,25 +348,26 @@ NS_IMPL_QUERY_INTERFACE(cache::ReadStrea
 // to perform this operation, so the object must not be completely
 // destroyed yet.  Therefore, we hold a ref-cycle and perform a Close()
 // when the ref count drops to 1.
 NS_IMETHODIMP_(MozExternalRefCountType)
 ReadStream::Release()
 {
   MOZ_ASSERT(int32_t(mRefCnt) > 0, "dup release");
   nsrefcnt count = --mRefCnt;
-  NS_LOG_RELEASE(this, count, "nsPipe");
+  NS_LOG_RELEASE(this, count, "cache::ReadStream");
   if (count == 0) {
+    mRefCnt = 1; /* stabilize */
     delete (this);
     return 0;
   }
   // Automatically close if the only thing keeping us alive is our
   // ref-cycle with StreamControl.
-  if (!mClosed && count == 1) {
+  if (count == 1 && !mClosed) {
+    printf_stderr("### ### [%p] ReadStream::Release() implicit close\n", this);
     Close();
-    return 1;
   }
   return count;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
