# HG changeset patch
# Parent ff3198de424cb454662168bcf031b4f680d491de
# User Ben Kelly <ben@wanderview.com>
Bug 1143223 interdiff 001 address review feedback


diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -81,26 +81,33 @@ private:
 
   void
   NoteClosedOnOwningThread();
 
   void
   ForgetOnOwningThread();
 
   // Weak ref to the stream control actor.  The actor will always call either
-  // CloseStream() or CloseStreamWithoutReporting() before its destroyed.  The
+  // CloseStream() or CloseStreamWithoutReporting() before it's destroyed.  The
   // weak ref is cleared in the resulting NoteClosedOnOwningThread() or
   // ForgetOnOwningThread() method call.
   StreamControl* mControl;
 
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
   nsCOMPtr<nsIInputStream> mSnappyStream;
   nsCOMPtr<nsIThread> mOwningThread;
-  Atomic<bool> mClosed;
+
+  enum State
+  {
+    Open,
+    Closed,
+    NumStates
+  };
+  Atomic<State> mState;
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::ReadStream::Inner)
 };
 
 // ----------------------------------------------------------------------------
 
 // Runnable to notify actors that the ReadStream has closed.  This must
 // be done on the thread associated with the PBackground actor.  Must be
@@ -173,17 +180,17 @@ private:
 
 ReadStream::Inner::Inner(StreamControl* aControl, const nsID& aId,
                          nsIInputStream* aStream)
   : mControl(aControl)
   , mId(aId)
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mOwningThread(NS_GetCurrentThread())
-  , mClosed(false)
+  , mState(Open)
 {
   MOZ_ASSERT(mStream);
   MOZ_ASSERT(mControl);
   mControl->AddReadStream(this);
 }
 
 void
 ReadStream::Inner::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
@@ -195,17 +202,17 @@ ReadStream::Inner::Serialize(PCacheReadS
   *aReadStreamOut = stream;
 }
 
 void
 ReadStream::Inner::Serialize(PCacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
-  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(mState == Open);
   MOZ_ASSERT(mControl);
 
   aReadStreamOut->id() = mId;
   mControl->SerializeControl(aReadStreamOut);
 
   nsAutoTArray<FileDescriptor, 4> fds;
   SerializeInputStream(mStream, aReadStreamOut->params(), fds);
 
@@ -298,25 +305,25 @@ ReadStream::Inner::IsNonBlocking(bool* a
 {
   // stream ops can happen on any thread
   return mSnappyStream->IsNonBlocking(aNonBlockingOut);
 }
 
 ReadStream::Inner::~Inner()
 {
   // Any thread
-  MOZ_ASSERT(mClosed);
+  MOZ_ASSERT(mState == Closed);
   MOZ_ASSERT(!mControl);
 }
 
 void
 ReadStream::Inner::NoteClosed()
 {
   // Any thread
-  if (mClosed) {
+  if (mState == Closed) {
     return;
   }
 
   if (NS_GetCurrentThread() == mOwningThread) {
     NoteClosedOnOwningThread();
     return;
   }
 
@@ -324,17 +331,17 @@ ReadStream::Inner::NoteClosed()
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::Inner::Forget()
 {
   // Any thread
-  if (mClosed) {
+  if (mState == Closed) {
     return;
   }
 
   if (NS_GetCurrentThread() == mOwningThread) {
     ForgetOnOwningThread();
     return;
   }
 
@@ -343,36 +350,36 @@ ReadStream::Inner::Forget()
     mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::Inner::NoteClosedOnOwningThread()
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
 
-  if (mClosed) {
+  // Mark closed and do nothing if we were already closed
+  if (!mState.compareExchange(Open, Closed)) {
     return;
   }
 
-  mClosed = true;
   MOZ_ASSERT(mControl);
   mControl->NoteClosed(this, mId);
   mControl = nullptr;
 }
 
 void
 ReadStream::Inner::ForgetOnOwningThread()
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
 
-  if (mClosed) {
+  // Mark closed and do nothing if we were already closed
+  if (!mState.compareExchange(Open, Closed)) {
     return;
   }
 
-  mClosed = true;
   MOZ_ASSERT(mControl);
   mControl->ForgetReadStream(this);
   mControl = nullptr;
 }
 
 // ----------------------------------------------------------------------------
 
 NS_IMPL_ISUPPORTS(cache::ReadStream, nsIInputStream, ReadStream);
diff --git a/dom/cache/StreamControl.cpp b/dom/cache/StreamControl.cpp
--- a/dom/cache/StreamControl.cpp
+++ b/dom/cache/StreamControl.cpp
@@ -47,16 +47,17 @@ StreamControl::CloseReadStreams(const ns
   AssertOwningThread();
   DebugOnly<uint32_t> closedCount = 0;
 
   ReadStreamList::ForwardIterator iter(mReadStreamList);
   while (iter.HasMore()) {
     nsRefPtr<ReadStream::Controllable> stream = iter.GetNext();
     if (stream->MatchId(aId)) {
       stream->CloseStream();
+      closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 }
 
 void
 StreamControl::CloseAllReadStreams()
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -32,18 +32,17 @@ EXPORTS.mozilla.dom.cache += [
     'SavedTypes.h',
     'StreamControl.h',
     'StreamList.h',
     'StreamUtils.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
-#UNIFIED_SOURCES += [
-SOURCES += [
+UNIFIED_SOURCES += [
     'Action.cpp',
     'ActorChild.cpp',
     'AutoUtils.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
