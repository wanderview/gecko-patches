# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5ebc4e2fb88bab2645a6466ba8e7925850b79aba

diff --git a/dom/workers/test/serviceworkers/browser.ini b/dom/workers/test/serviceworkers/browser.ini
--- a/dom/workers/test/serviceworkers/browser.ini
+++ b/dom/workers/test/serviceworkers/browser.ini
@@ -8,16 +8,17 @@ support-files =
   download_canceled/server-stream-download.sjs
   download_canceled/sw_download_canceled.js
   fetch.js
   file_multie10s_update.html
   file_userContextId_openWindow.js
   force_refresh_browser_worker.js
   empty.html
   server_multie10s_update.sjs
+  utils.js
 
 [browser_devtools_serviceworker_interception.js]
 [browser_force_refresh.js]
 [browser_download.js]
 [browser_download_canceled.js]
 [browser_multie10s_update.js]
 skip-if = !e10s || os != "win" # Bug 1404914
 [browser_userContextId_openWindow.js]
diff --git a/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html b/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html
--- a/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html
+++ b/dom/workers/test/serviceworkers/download_canceled/page_download_canceled.html
@@ -4,16 +4,17 @@
 -->
 <!DOCTYPE HTML>
 <html>
 <head>
   <meta charset="utf-8">
 </head>
 <body>
 
+<script src="../utils.js"></script>
 <script type="text/javascript">
 function wait_until_controlled() {
   return new Promise(function(resolve) {
     if (navigator.serviceWorker.controller) {
       return resolve('controlled');
     }
     navigator.serviceWorker.addEventListener('controllerchange', function onController() {
       if (navigator.serviceWorker.controller) {
@@ -22,16 +23,20 @@ function wait_until_controlled() {
       }
     });
   });
 }
 addEventListener('load', async function(event) {
   window.controlled = wait_until_controlled();
   window.registration =
     await navigator.serviceWorker.register('sw_download_canceled.js');
+  let sw = registration.installing || registration.waiting ||
+           registration.active;
+  await waitForState(sw, 'activated');
+  sw.postMessage('claim');
 });
 
 // Place to hold promises for stream closures reported by the SW.
 window.streamClosed = {};
 
 // The ServiceWorker will postMessage to this BroadcastChannel when the streams
 // are closed.  (Alternately, the SW could have used the clients API to post at
 // us, but the mechanism by which that operates would be different when this
diff --git a/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
--- a/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
+++ b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
@@ -2,20 +2,16 @@
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // This file is derived from :bkelly's https://glitch.com/edit/#!/html-sw-stream
 
 addEventListener("install", evt => {
   evt.waitUntil(self.skipWaiting());
 });
 
-addEventListener("activate", function(evt) {
-  evt.waitUntil(clients.claim());
-});
-
 // Create a BroadcastChannel to notify when we have closed our streams.
 const channel = new BroadcastChannel("stream-closed");
 
 const MAX_TICK_COUNT = 3000;
 const TICK_INTERVAL = 4;
 /**
  * Generate a continuous stream of data at a sufficiently high frequency that a
  * there"s a good chance of racing channel cancellation.
@@ -120,9 +116,15 @@ function handlePassThrough(evt, filename
 addEventListener("fetch", evt => {
   console.log(`SW processing fetch of ${evt.request.url}`);
   if (evt.request.url.indexOf("sw-stream-download") >= 0) {
     return handleStream(evt, "sw-stream-download");
   }
   if (evt.request.url.indexOf("sw-passthrough-download") >= 0) {
     return handlePassThrough(evt, "sw-passthrough-download");
   }
-})
\ No newline at end of file
+})
+
+addEventListener("message", evt => {
+  if (evt.data === "claim") {
+    evt.waitUntil(clients.claim());
+  }
+});
