# HG changeset patch
# Parent b832b8aa5a9c3bf4f663a44eefde69f0bab49628
# User Ben Kelly <ben@wanderview.com>
Bug 1032011 Handle async actor Close() by blocking until ActorDestroy.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -2745,17 +2745,17 @@ WorkerThreadPrimaryRunnable::Synchronous
   nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
     new WorkerBackgroundChildCallback(&done);
 
   if (NS_WARN_IF(!BackgroundChild::GetOrCreateForCurrentThread(callback))) {
     return NS_ERROR_FAILURE;
   }
 
   while (!done) {
-    if (NS_WARN_IF(!NS_ProcessNextEvent(mThread, true /* aMayWay */))) {
+    if (NS_WARN_IF(!NS_ProcessNextEvent(mThread, true /* aMayWait */))) {
       return NS_ERROR_FAILURE;
     }
   }
 
   if (NS_WARN_IF(!BackgroundChild::GetForCurrentThread())) {
     return NS_ERROR_FAILURE;
   }
 
diff --git a/ipc/glue/MessagePump.cpp b/ipc/glue/MessagePump.cpp
--- a/ipc/glue/MessagePump.cpp
+++ b/ipc/glue/MessagePump.cpp
@@ -43,34 +43,32 @@ namespace mozilla {
 namespace ipc {
 
 class DoWorkRunnable MOZ_FINAL : public nsICancelableRunnable,
                                  public nsITimerCallback
 {
 public:
   DoWorkRunnable(MessagePump* aPump)
   : mPump(aPump)
-  , mCanceled(false)
-  , mCallingRunWhileCanceled(false)
   {
     MOZ_ASSERT(aPump);
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICANCELABLERUNNABLE
 
 private:
   ~DoWorkRunnable()
   { }
 
   MessagePump* mPump;
-  bool mCanceled;
-  bool mCallingRunWhileCanceled;
+  // DoWorkRunnable is designed as a stateless singleton.  Do not add stateful
+  // members here!
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
 MessagePump::MessagePump()
 : mThread(nullptr)
 {
@@ -219,21 +217,16 @@ MessagePump::DoDelayedWork(base::Message
 }
 
 NS_IMPL_ISUPPORTS(DoWorkRunnable, nsIRunnable, nsITimerCallback,
                                   nsICancelableRunnable)
 
 NS_IMETHODIMP
 DoWorkRunnable::Run()
 {
-  MOZ_ASSERT(!mCanceled || mCallingRunWhileCanceled);
-  if (mCanceled && !mCallingRunWhileCanceled) {
-    return NS_OK;
-  }
-
   MessageLoop* loop = MessageLoop::current();
   MOZ_ASSERT(loop);
 
   bool nestableTasksAllowed = loop->NestableTasksAllowed();
 
   // MessageLoop::RunTask() disallows nesting, but our Frankenventloop will
   // always dispatch DoWork() below from what looks to MessageLoop like a nested
   // context.  So we unconditionally allow nesting here.
@@ -253,27 +246,24 @@ DoWorkRunnable::Notify(nsITimer* aTimer)
   mPump->DoDelayedWork(loop);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DoWorkRunnable::Cancel()
 {
-  MOZ_ASSERT(!mCanceled);
-  MOZ_ASSERT(!mCallingRunWhileCanceled);
-
   // Workers require cancelable runnables, but we can't really cancel cleanly
-  // here.  If we don't process all of these then we will leave something
-  // unprocessed in the chromium queue.  Therefore, eagerly complete our work
-  // instead by immediately calling Run().
-  mCanceled = true;
-  mozilla::AutoRestore<bool> guard(mCallingRunWhileCanceled);
-  mCallingRunWhileCanceled = true;
-  Run();
+  // here.  If we don't process this runnable then we will leave something
+  // unprocessed in the message_loop.  Therefore, eagerly complete our work
+  // instead by immediately calling Run().  Run() should be called separately
+  // after this.  Unfortunately we cannot use flags to verify this because
+  // DoWorkRunnable is a stateless singleton that can be in the event queue
+  // multiple times simultaneously.
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(Run()));
   return NS_OK;
 }
 
 void
 MessagePumpForChildProcess::Run(base::MessagePump::Delegate* aDelegate)
 {
   if (mFirstRun) {
     MOZ_ASSERT(aDelegate && !gFirstDelegate);
