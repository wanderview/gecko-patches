# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c044437e5842d0f8d5c34e39ccfad0a81d7762aa
Bug 1300659 P2 Expose a main thread TaskQueue on nsGlobalWindow. r=bz

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -71,16 +71,17 @@
 #include "mozilla/dom/ToJSValue.h"
 #include "nsJSPrincipals.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/Debug.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/EventStates.h"
 #include "mozilla/MouseEvents.h"
 #include "mozilla/ProcessHangMonitor.h"
+#include "mozilla/SelfClosingTaskQueueTarget.h"
 #include "AudioChannelService.h"
 #include "nsAboutProtocolUtils.h"
 #include "nsCharTraits.h" // NS_IS_HIGH/LOW_SURROGATE
 #include "PostMessageEvent.h"
 
 // Interfaces Needed
 #include "nsIFrame.h"
 #include "nsCanvasFrame.h"
@@ -3024,16 +3025,18 @@ nsGlobalWindow::SetDocShell(nsIDocShell*
   MOZ_ASSERT(aDocShell);
 
   if (aDocShell == mDocShell) {
     return;
   }
 
   mDocShell = aDocShell; // Weak Reference
 
+  MaybeCreateMainThreadTaskQueue();
+
   NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
 
   if (mFrames) {
     mFrames->SetDocShell(aDocShell);
   }
 
   // Get our enclosing chrome shell and retrieve its global window impl, so
   // that we can do some forwarding to the chrome document.
@@ -3578,16 +3581,60 @@ nsGlobalWindow::GetPrincipal()
 
   if (objPrincipal) {
     return objPrincipal->GetPrincipal();
   }
 
   return nullptr;
 }
 
+void
+nsGlobalWindow::MaybeCreateMainThreadTaskQueue()
+{
+  MOZ_ASSERT(IsOuterWindow());
+  MOZ_ASSERT(!mMainThreadTaskQueue);
+
+  // Do not throttle runnables from chrome windows.  This is partially because
+  // we want to prioritize chrome windows and partially because a number of
+  // tests fail with this kind of throttling.  Specifically, browser chrome and
+  // devtools tests seem to expect precise setTimeout() ordering today.
+  if (IsChromeWindow()) {
+    mMainThreadTaskQueue = nullptr;
+    return;
+  }
+
+  // Attempt to use the task queue already present in our constellation.
+  nsCOMPtr<nsPIDOMWindowOuter> parent = GetParent();
+  if (parent && parent->GetMainThreadTaskQueue()) {
+    mMainThreadTaskQueue = parent->GetMainThreadTaskQueue();
+    return;
+  }
+
+  nsCOMPtr<nsPIDOMWindowOuter> opener = GetOpener();
+  if (opener && opener->GetMainThreadTaskQueue()) {
+    mMainThreadTaskQueue = opener->GetMainThreadTaskQueue();
+    return;
+  }
+
+  nsCOMPtr<nsIThread> mainThread;
+  NS_GetMainThread(getter_AddRefs(mainThread));
+  MOZ_DIAGNOSTIC_ASSERT(mainThread);
+
+  // This may return nullptr during xpcom shutdown.  This is ok as we
+  // do not guarantee a task queue will be present.
+  mMainThreadTaskQueue = SelfClosingTaskQueueTarget::Create(mainThread);
+}
+
+SelfClosingTaskQueueTarget*
+nsGlobalWindow::GetMainThreadTaskQueue()
+{
+  FORWARD_TO_OUTER(GetMainThreadTaskQueue, (), nullptr);
+  return mMainThreadTaskQueue;
+}
+
 //*****************************************************************************
 // nsGlobalWindow::nsIDOMWindow
 //*****************************************************************************
 
 template <class T>
 nsIURI*
 nsPIDOMWindow<T>::GetDocumentURI() const
 {
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -492,16 +492,19 @@ public:
                            nsIWidget* aWidget, nsIScreen* aScreen);
   bool FullScreen() const;
 
   // Inner windows only.
   virtual void SetHasGamepadEventListener(bool aHasGamepad = true) override;
   void NotifyVREventListenerAdded();
   virtual void EventListenerAdded(nsIAtom* aType) override;
 
+  virtual mozilla::SelfClosingTaskQueueTarget*
+  GetMainThreadTaskQueue() override;
+
   // nsIInterfaceRequestor
   NS_DECL_NSIINTERFACEREQUESTOR
 
   // WebIDL interface.
   already_AddRefed<nsPIDOMWindowOuter> IndexedGetterOuter(uint32_t aIndex);
   already_AddRefed<nsPIDOMWindowOuter> IndexedGetter(uint32_t aIndex);
 
   static bool IsPrivilegedChromeWindow(JSContext* /* unused */, JSObject* aObj);
@@ -1704,16 +1707,24 @@ private:
   void FireOnNewGlobalObject();
 
   void DisconnectEventTargetObjects();
 
   // Called only on outer windows to compute the value that will be returned by
   // IsSecureContext() for the inner window that corresponds to aDocument.
   bool ComputeIsSecureContext(nsIDocument* aDocument);
 
+  // Maybe create a TaskQueue for dispatching runnables to the main thread
+  // from this window.  This TaskQueue will throttle these runnables and
+  // prevent the window content from significantly impacting main thread
+  // responsiveness.  Certain situations will result in a nullptr task
+  // queue even after calling this method.
+  void
+  MaybeCreateMainThreadTaskQueue();
+
 protected:
   // This member is also used on both inner and outer windows, but
   // for slightly different purposes. On inner windows it means the
   // inner window is held onto by session history and should not
   // change. On outer windows it means that the window is in a state
   // where we don't want to force creation of a new inner window since
   // we're in the middle of doing just that.
   bool                          mIsFrozen : 1;
@@ -1884,16 +1895,18 @@ protected:
   // responsible for unsuspending events on the document. If we don't (for
   // example, if the outer window is closed before the LeaveModalState call),
   // then the inner window whose mDoc is our mSuspendedDoc is responsible for
   // unsuspending it.
   nsCOMPtr<nsIDocument> mSuspendedDoc;
 
   RefPtr<mozilla::dom::IDBFactory> mIndexedDB;
 
+  RefPtr<mozilla::SelfClosingTaskQueueTarget> mMainThreadTaskQueue;
+
   // This counts the number of windows that have been opened in rapid succession
   // (i.e. within dom.successive_dialog_time_limit of each other). It is reset
   // to 0 once a dialog is opened after dom.successive_dialog_time_limit seconds
   // have elapsed without any other dialogs.
   uint32_t                      mDialogAbuseCount;
 
   // This holds the time when the last modal dialog was shown. If more than
   // MAX_DIALOG_LIMIT dialogs are shown within the time span defined by
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -34,16 +34,17 @@ class nsPIDOMWindowInner;
 class nsPIDOMWindowOuter;
 class nsPIWindowRoot;
 class nsXBLPrototypeHandler;
 struct nsTimeout;
 
 typedef uint32_t SuspendTypes;
 
 namespace mozilla {
+class SelfClosingTaskQueueTarget;
 namespace dom {
 class AudioContext;
 class Element;
 class Performance;
 class ServiceWorkerRegistration;
 class CustomElementsRegistry;
 } // namespace dom
 } // namespace mozilla
@@ -173,16 +174,19 @@ public:
     if (!mDoc) {
       MaybeCreateDoc();
     }
     return mDoc;
   }
 
   virtual bool IsRunningTimeout() = 0;
 
+  virtual mozilla::SelfClosingTaskQueueTarget*
+  GetMainThreadTaskQueue() = 0;
+
 protected:
   // Lazily instantiate an about:blank document if necessary, and if
   // we have what it takes to do so.
   void MaybeCreateDoc();
 
 public:
   inline bool IsLoadingOrRunningTimeout() const;
 
