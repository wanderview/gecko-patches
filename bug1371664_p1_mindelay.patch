# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1742b1bdadd13a02df95ca690bea9cc42ff40c91
Bug 1371664 P1 Add a minimum delay argument to TimeoutExecutor::MaybeSchedule(). r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -35,21 +35,23 @@ TimeoutExecutor::ScheduleImmediate(const
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
-                                 const TimeStamp& aNow)
+                                 const TimeStamp& aNow,
+                                 const TimeDuration& aMinDelay)
 {
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
-  MOZ_DIAGNOSTIC_ASSERT(aDeadline > (aNow + mAllowedEarlyFiringTime));
+  MOZ_DIAGNOSTIC_ASSERT(!aMinDelay.IsZero() ||
+                        aDeadline > (aNow + mAllowedEarlyFiringTime));
 
   nsresult rv = NS_OK;
 
   if (!mTimer) {
     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     uint32_t earlyMicros = 0;
@@ -60,16 +62,25 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // Calculate the delay based on the deadline and current time.  If we have
+  // a minimum delay set then clamp to that value.
+  //
+  // Note, we don't actually adjust our mDeadline for the minimum delay, just
+  // the nsITimer value.  This is necessary to avoid lots of needless
+  // rescheduling if more deadlines come in between now and the minimum delay
+  // firing time.
+  TimeDuration delay = TimeDuration::Max(aMinDelay, aDeadline - aNow);
+
   // Note, we cannot use the normal nsITimer init methods that take
   // integer milliseconds.  We need higher precision.  Consider this
   // situation:
   //
   // 1. setTimeout(f, 1);
   // 2. do some work for 500us
   // 3. setTimeout(g, 1);
   //
@@ -78,43 +89,45 @@ TimeoutExecutor::ScheduleDelayed(const T
   // In the past worked because each setTimeout() got its own nsITimer.  The 1ms
   // was preserved and passed through to nsITimer which converted it to a
   // TimeStamp, etc.
   //
   // Now, however, there is only one nsITimer.  We fire f() and then try to
   // schedule a new nsITimer for g().  Its only 500us in the future, though.  We
   // must be able to pass this fractional value to nsITimer in order to get an
   // accurate wakeup time.
-  rv = mTimer->InitHighResolutionWithCallback(this, aDeadline - aNow,
+  rv = mTimer->InitHighResolutionWithCallback(this, delay,
                                               nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
-TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
+TimeoutExecutor::Schedule(const TimeStamp& aDeadline,
+                          const TimeDuration& aMinDelay)
 {
   TimeStamp now(TimeStamp::Now());
 
   // Schedule an immediate runnable if the desired deadline has passed
   // or is slightly in the future.  This is similar to how nsITimer will
   // fire timers early based on the interval resolution.
-  if (aDeadline <= (now + mAllowedEarlyFiringTime)) {
+  if (aMinDelay.IsZero() && aDeadline <= (now + mAllowedEarlyFiringTime)) {
     return ScheduleImmediate(aDeadline, now);
   }
 
-  return ScheduleDelayed(aDeadline, now);
+  return ScheduleDelayed(aDeadline, now, aMinDelay);
 }
 
 nsresult
-TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline,
+                                 const TimeDuration& aMinDelay)
 {
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Immediate ||
                         mMode == Mode::Delayed);
 
   if (aDeadline >= mDeadline) {
     return NS_OK;
   }
@@ -122,17 +135,17 @@ TimeoutExecutor::MaybeReschedule(const T
   if (mMode == Mode::Immediate) {
     // Don't reduce the deadline here as we want to execute the
     // timer we originally scheduled even if its a few microseconds
     // in the future.
     return NS_OK;
   }
 
   Cancel();
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aMinDelay);
 }
 
 void
 TimeoutExecutor::MaybeExecute()
 {
   MOZ_DIAGNOSTIC_ASSERT(mMode != Mode::Shutdown && mMode != Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(mOwner);
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
@@ -171,29 +184,30 @@ TimeoutExecutor::Shutdown()
     mTimer = nullptr;
   }
 
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
-TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline,
+                               const TimeDuration& aMinDelay)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
 
   if (mMode == Mode::Shutdown) {
     return NS_OK;
   }
 
   if (mMode == Mode::Immediate || mMode == Mode::Delayed) {
-    return MaybeReschedule(aDeadline);
+    return MaybeReschedule(aDeadline, aMinDelay);
   }
 
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aMinDelay);
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
--- a/dom/base/TimeoutExecutor.h
+++ b/dom/base/TimeoutExecutor.h
@@ -51,35 +51,37 @@ class TimeoutExecutor final : public nsI
   Mode mMode;
 
   ~TimeoutExecutor();
 
   nsresult
   ScheduleImmediate(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   nsresult
-  ScheduleDelayed(const TimeStamp& aDeadline, const TimeStamp& aNow);
+  ScheduleDelayed(const TimeStamp& aDeadline, const TimeStamp& aNow,
+                  const TimeDuration& aMinDelay);
 
   nsresult
-  Schedule(const TimeStamp& aDeadline);
+  Schedule(const TimeStamp& aDeadline, const TimeDuration& aMinDelay);
 
   nsresult
-  MaybeReschedule(const TimeStamp& aDeadline);
+  MaybeReschedule(const TimeStamp& aDeadline, const TimeDuration& aMinDelay);
 
   void
   MaybeExecute();
 
 public:
   explicit TimeoutExecutor(TimeoutManager* aOwner);
 
   void
   Shutdown();
 
   nsresult
-  MaybeSchedule(const TimeStamp& aDeadline);
+  MaybeSchedule(const TimeStamp& aDeadline,
+                const TimeDuration& aMinDelay = TimeDuration());
 
   void
   Cancel();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSINAMED
