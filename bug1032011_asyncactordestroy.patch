# HG changeset patch
# Parent 91a55429c78b098926c8f23cacce69beede00178
# User Ben Kelly <ben@wanderview.com>
Bug 1032011 Handle async actor Close() by blocking until ActorDestroy.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -982,16 +982,19 @@ public:
 
 private:
   ~WorkerThreadPrimaryRunnable()
   { }
 
   nsresult
   SynchronouslyCreatePBackground();
 
+  void
+  SynchronouslyClosePBackground();
+
   NS_DECL_NSIRUNNABLE
 };
 
 class WorkerTaskRunnable MOZ_FINAL : public WorkerRunnable
 {
   nsRefPtr<WorkerTask> mTask;
 
 public:
@@ -1047,16 +1050,18 @@ class RuntimeService::WorkerThread MOZ_F
       mWorkerPrivate->AssertIsOnWorkerThread();
     }
 
     NS_DECL_NSITHREADOBSERVER
   };
 
   WorkerPrivate* mWorkerPrivate;
   nsRefPtr<Observer> mObserver;
+  // Only touched from worker thread
+  bool mClosingPBackground;
 
 #ifdef DEBUG
   // Protected by nsThread::mLock.
   bool mAcceptingNonWorkerRunnables;
 #endif
 
 public:
   static already_AddRefed<WorkerThread>
@@ -1065,16 +1070,27 @@ public:
   void
   SetWorker(WorkerPrivate* aWorkerPrivate);
 
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_IMETHOD
   Dispatch(nsIRunnable* aRunnable, uint32_t aFlags) MOZ_OVERRIDE;
 
+  void
+  SetClosingPBackground(bool aClosingPBackground)
+  {
+#ifdef DEBUG
+    bool current = false;
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(IsOnCurrentThread(&current)));
+    MOZ_ASSERT(current);
+#endif
+    mClosingPBackground = aClosingPBackground;
+  }
+
 #ifdef DEBUG
   bool
   IsAcceptingNonWorkerRunnables()
   {
     MutexAutoLock lock(mLock);
     return mAcceptingNonWorkerRunnables;
   }
 
@@ -1106,17 +1122,18 @@ public:
       MOZ_RELEASE_ASSERT(ok);
     }
   }
 #endif // #ENABLE_TESTS
 
 private:
   WorkerThread()
   : nsThread(nsThread::NOT_MAIN_THREAD, WORKER_STACK_SIZE),
-    mWorkerPrivate(nullptr)
+    mWorkerPrivate(nullptr),
+    mClosingPBackground(false)
 #ifdef DEBUG
     , mAcceptingNonWorkerRunnables(true)
 #endif
   { }
 
   ~WorkerThread()
   { }
 };
@@ -2555,17 +2572,17 @@ RuntimeService::WorkerThread::Dispatch(n
   // Workers only support asynchronous dispatch for now.
   if (NS_WARN_IF(aFlags != NS_DISPATCH_NORMAL)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsIRunnable* runnableToDispatch;
   nsRefPtr<WorkerRunnable> workerRunnable;
 
-  if (aRunnable && PR_GetCurrentThread() == mThread) {
+  if (aRunnable && PR_GetCurrentThread() == mThread && !mClosingPBackground) {
     // No need to lock here because mWorkerPrivate is only modified on mThread.
     workerRunnable = mWorkerPrivate->MaybeWrapAsWorkerRunnable(aRunnable);
     runnableToDispatch = workerRunnable;
   }
   else {
     runnableToDispatch = aRunnable;
   }
 
@@ -2591,23 +2608,22 @@ RuntimeService::WorkerThread::Observer::
                                                nsIThreadInternal* /* aThread */,
                                                bool aMayWait,
                                                uint32_t aRecursionDepth)
 {
   using mozilla::ipc::BackgroundChild;
 
   mWorkerPrivate->AssertIsOnWorkerThread();
 
-  // If the PBackground child is not created yet, then we must permit
-  // blocking event processing to support SynchronouslyCreatePBackground().
-  // If this occurs then we are spinning on the event queue at the start of
-  // PrimaryWorkerRunnable::Run() and don't want to process the event in
-  // mWorkerPrivate yet.
+  // We must support blocking event processing in order to support creating
+  // and closing the PBackground actor.  In both cases the
+  // GetForCurrentThread() should return null.  During creation we have a
+  // recursion of 2 and during closing a recursion of 1.
   if (aMayWait) {
-    MOZ_ASSERT(aRecursionDepth == 2);
+    MOZ_ASSERT(aRecursionDepth <= 2);
     MOZ_ASSERT(!BackgroundChild::GetForCurrentThread());
     return NS_OK;
   }
 
   mWorkerPrivate->OnProcessNextEvent(aRecursionDepth);
   return NS_OK;
 }
 
@@ -2651,18 +2667,16 @@ LogViolationDetailsRunnable::Run()
 
 NS_IMPL_ISUPPORTS(WorkerBackgroundChildCallback, nsIIPCBackgroundChildCreateCallback)
 
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::Run()
 {
-  using mozilla::ipc::BackgroundChild;
-
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
@@ -2721,17 +2735,17 @@ WorkerThreadPrimaryRunnable::Run()
 
         JS_ReportPendingException(cx);
       }
 
 #ifdef ENABLE_TESTS
       mThread->TestPBackground();
 #endif
 
-      BackgroundChild::CloseForCurrentThread();
+      SynchronouslyClosePBackground();
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
@@ -2777,32 +2791,47 @@ WorkerThreadPrimaryRunnable::Synchronous
   nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
     new WorkerBackgroundChildCallback(&done);
 
   if (NS_WARN_IF(!BackgroundChild::GetOrCreateForCurrentThread(callback))) {
     return NS_ERROR_FAILURE;
   }
 
   while (!done) {
-    if (NS_WARN_IF(!NS_ProcessNextEvent(mThread, true /* aMayWay */))) {
+    if (NS_WARN_IF(!NS_ProcessNextEvent(mThread, true /* aMayWait */))) {
       return NS_ERROR_FAILURE;
     }
   }
 
   if (NS_WARN_IF(!BackgroundChild::GetForCurrentThread())) {
     return NS_ERROR_FAILURE;
   }
 
 #ifdef DEBUG
   mThread->SetAcceptingNonWorkerRunnables(false);
 #endif
 
   return NS_OK;
 }
 
+void
+WorkerThreadPrimaryRunnable::SynchronouslyClosePBackground()
+{
+  using mozilla::ipc::BackgroundChild;
+
+  // Closing the PBackground actor is synchronous, but will need to
+  // dispatch some runnables on the current thread to properly cleanup.
+  // Set a flag to avoid wrapping these runnables in WorkerThread::Dispatch.
+  // The worker is in a partially torn down state, so wrapping the runnables
+  // does not work correctly.
+  mThread->SetClosingPBackground(true);
+  BackgroundChild::CloseForCurrentThread();
+  mThread->SetClosingPBackground(false);
+}
+
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable::FinishedRunnable,
                              nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::FinishedRunnable::Run()
 {
   AssertIsOnMainThread();
 
diff --git a/ipc/glue/BackgroundChild.h b/ipc/glue/BackgroundChild.h
--- a/ipc/glue/BackgroundChild.h
+++ b/ipc/glue/BackgroundChild.h
@@ -32,17 +32,18 @@ class PBackgroundChild;
 //
 // Creation of PBackground is asynchronous. GetForCurrentThread() will return
 // null until the sequence is complete. GetOrCreateForCurrentThread() will start
 // the creation sequence and will call back via the
 // nsIIPCBackgroundChildCreateCallback interface when completed. Thereafter
 // (assuming success) GetForCurrentThread() will return the same actor every
 // time.
 //
-// CloseForCurrentThread() will close the current PBackground actor.  Subsequent
+// CloseForCurrentThread() will close the current PBackground actor.  This will
+// block if necessary to ensure the actor is completely closed.  Subsequent
 // calls to GetForCurrentThread will return null.  CloseForCurrentThread() may
 // only be called exactly once per thread.  Currently it is illegal to call this
 // before the PBackground actor has been created.
 //
 // The PBackgroundChild actor and all its sub-protocol actors will be
 // automatically destroyed when its designated thread completes.
 class BackgroundChild MOZ_FINAL
 {
diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -345,17 +345,17 @@ class ChildImpl MOZ_FINAL : public Backg
   static bool sShutdownHasStarted;
 
 #ifdef RELEASE_BUILD
   DebugOnly<nsIThread*> mBoundThread;
 #else
   nsIThread* mBoundThread;
 #endif
 
-  DebugOnly<bool> mActorDestroyed;
+  bool mActorDestroyed;
 
 public:
   static bool
   OpenProtocolOnMainThread(nsIEventTarget* aEventTarget);
 
   static void
   Shutdown();
 
@@ -369,22 +369,16 @@ public:
 #else
     bool current;
 #endif
     THREADSAFETY_ASSERT(
       NS_SUCCEEDED(mBoundThread->IsOnCurrentThread(&current)));
     THREADSAFETY_ASSERT(current);
   }
 
-  void
-  AssertActorDestroyed()
-  {
-    MOZ_ASSERT(mActorDestroyed, "ChildImpl::ActorDestroy not called in time");
-  }
-
   ChildImpl()
   : mBoundThread(nullptr)
   , mActorDestroyed(false)
   {
     AssertIsOnMainThread();
   }
 
   NS_INLINE_DECL_REFCOUNTING(ChildImpl)
@@ -417,17 +411,29 @@ private:
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
     if (threadLocalInfo) {
       if (threadLocalInfo->mActor) {
         threadLocalInfo->mActor->Close();
-        threadLocalInfo->mActor->AssertActorDestroyed();
+
+        // The actor Close() call is normally synch, but can be async if the
+        // channel is not connected.  There are a number of races involved with
+        // properly handling the async actor.  To make sure we deal with them
+        // all, spin the event loop here until the actor has been destroyed.
+        nsIThread* currentThread = NS_GetCurrentThread();
+        MOZ_ASSERT(currentThread);
+        while (!threadLocalInfo->mActor->mActorDestroyed) {
+          NS_ProcessNextEvent(currentThread, true /* aMayWait */);
+        }
+
+        MOZ_ASSERT(threadLocalInfo->mActor->mActorDestroyed);
+
         // Since the actor is created on the main thread it must only
         // be released on the main thread as well.
         if (!NS_IsMainThread()) {
           ChildImpl* actor;
           threadLocalInfo->mActor.forget(&actor);
 
           nsCOMPtr<nsIRunnable> releaser =
             NS_NewNonOwningRunnableMethod(actor, &ChildImpl::Release);
@@ -439,17 +445,17 @@ private:
   }
 
   static void
   DispatchFailureCallback(nsIEventTarget* aEventTarget);
 
   // This class is reference counted.
   ~ChildImpl()
   {
-    AssertActorDestroyed();
+    MOZ_ASSERT(mActorDestroyed);
   }
 
   void
   SetBoundThread()
   {
     THREADSAFETY_ASSERT(!mBoundThread);
 
 #if defined(DEBUG) || !defined(RELEASE_BUILD)
diff --git a/ipc/glue/MessagePump.cpp b/ipc/glue/MessagePump.cpp
--- a/ipc/glue/MessagePump.cpp
+++ b/ipc/glue/MessagePump.cpp
@@ -43,34 +43,32 @@ namespace mozilla {
 namespace ipc {
 
 class DoWorkRunnable MOZ_FINAL : public nsICancelableRunnable,
                                  public nsITimerCallback
 {
 public:
   DoWorkRunnable(MessagePump* aPump)
   : mPump(aPump)
-  , mCanceled(false)
-  , mCallingRunWhileCanceled(false)
   {
     MOZ_ASSERT(aPump);
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICANCELABLERUNNABLE
 
 private:
   ~DoWorkRunnable()
   { }
 
   MessagePump* mPump;
-  bool mCanceled;
-  bool mCallingRunWhileCanceled;
+  // DoWorkRunnable is designed as a stateless singleton.  Do not add stateful
+  // members here!
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
 MessagePump::MessagePump()
 : mThread(nullptr)
 {
@@ -219,21 +217,16 @@ MessagePump::DoDelayedWork(base::Message
 }
 
 NS_IMPL_ISUPPORTS(DoWorkRunnable, nsIRunnable, nsITimerCallback,
                                   nsICancelableRunnable)
 
 NS_IMETHODIMP
 DoWorkRunnable::Run()
 {
-  MOZ_ASSERT(!mCanceled || mCallingRunWhileCanceled);
-  if (mCanceled && !mCallingRunWhileCanceled) {
-    return NS_OK;
-  }
-
   MessageLoop* loop = MessageLoop::current();
   MOZ_ASSERT(loop);
 
   bool nestableTasksAllowed = loop->NestableTasksAllowed();
 
   // MessageLoop::RunTask() disallows nesting, but our Frankenventloop will
   // always dispatch DoWork() below from what looks to MessageLoop like a nested
   // context.  So we unconditionally allow nesting here.
@@ -253,27 +246,24 @@ DoWorkRunnable::Notify(nsITimer* aTimer)
   mPump->DoDelayedWork(loop);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DoWorkRunnable::Cancel()
 {
-  MOZ_ASSERT(!mCanceled);
-  MOZ_ASSERT(!mCallingRunWhileCanceled);
-
   // Workers require cancelable runnables, but we can't really cancel cleanly
-  // here.  If we don't process all of these then we will leave something
-  // unprocessed in the chromium queue.  Therefore, eagerly complete our work
-  // instead by immediately calling Run().
-  mCanceled = true;
-  mozilla::AutoRestore<bool> guard(mCallingRunWhileCanceled);
-  mCallingRunWhileCanceled = true;
-  Run();
+  // here.  If we don't process this runnable then we will leave something
+  // unprocessed in the message_loop.  Therefore, eagerly complete our work
+  // instead by immediately calling Run().  Run() should be called separately
+  // after this.  Unfortunately we cannot use flags to verify this because
+  // DoWorkRunnable is a stateless singleton that can be in the event queue
+  // multiple times simultaneously.
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(Run()));
   return NS_OK;
 }
 
 void
 MessagePumpForChildProcess::Run(base::MessagePump::Delegate* aDelegate)
 {
   if (mFirstRun) {
     MOZ_ASSERT(aDelegate && !gFirstDelegate);
