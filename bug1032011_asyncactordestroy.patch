# HG changeset patch
# Parent 606848e8adfc4993ee9ed70bee27a439ad556561
# User Ben Kelly <ben@wanderview.com>
Bug 1032011 Handle async ActorDestroy() callback when closing PBackground.

diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -345,17 +345,18 @@ class ChildImpl MOZ_FINAL : public Backg
   static bool sShutdownHasStarted;
 
 #ifdef RELEASE_BUILD
   DebugOnly<nsIThread*> mBoundThread;
 #else
   nsIThread* mBoundThread;
 #endif
 
-  DebugOnly<bool> mActorDestroyed;
+  bool mActorDestroyed;
+  bool mReleaseOnActorDestroy;
 
 public:
   static bool
   OpenProtocolOnMainThread(nsIEventTarget* aEventTarget);
 
   static void
   Shutdown();
 
@@ -369,25 +370,20 @@ public:
 #else
     bool current;
 #endif
     THREADSAFETY_ASSERT(
       NS_SUCCEEDED(mBoundThread->IsOnCurrentThread(&current)));
     THREADSAFETY_ASSERT(current);
   }
 
-  void
-  AssertActorDestroyed()
-  {
-    MOZ_ASSERT(mActorDestroyed, "ChildImpl::ActorDestroy not called in time");
-  }
-
   ChildImpl()
   : mBoundThread(nullptr)
   , mActorDestroyed(false)
+  , mReleaseOnActorDestroy(false)
   {
     AssertIsOnMainThread();
   }
 
   NS_INLINE_DECL_REFCOUNTING(ChildImpl)
 
 private:
   // Forwarded from BackgroundChild.
@@ -409,47 +405,56 @@ private:
   // Forwarded from BackgroundChild.
   static void
   CloseForCurrentThread();
 
   // Forwarded from BackgroundChildImpl.
   static BackgroundChildImpl::ThreadLocal*
   GetThreadLocalForCurrentThread();
 
+  void
+  DoRelease()
+  {
+    nsCOMPtr<nsIRunnable> releaser =
+      NS_NewNonOwningRunnableMethod(this, &ChildImpl::Release);
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(releaser)));
+  }
+
+  void
+  ReleaseOnActorDestroy()
+  {
+    if (mActorDestroyed) {
+      DoRelease();
+      return;
+    }
+    mReleaseOnActorDestroy = true;
+  }
+
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
     if (threadLocalInfo) {
       if (threadLocalInfo->mActor) {
         threadLocalInfo->mActor->Close();
-        threadLocalInfo->mActor->AssertActorDestroyed();
-        // Since the actor is created on the main thread it must only
-        // be released on the main thread as well.
-        if (!NS_IsMainThread()) {
-          ChildImpl* actor;
-          threadLocalInfo->mActor.forget(&actor);
-
-          nsCOMPtr<nsIRunnable> releaser =
-            NS_NewNonOwningRunnableMethod(actor, &ChildImpl::Release);
-          MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(releaser)));
-        }
+        ChildImpl* actor;
+        threadLocalInfo->mActor.forget(&actor);
+        actor->ReleaseOnActorDestroy();
       }
       delete threadLocalInfo;
     }
   }
 
   static void
   DispatchFailureCallback(nsIEventTarget* aEventTarget);
 
   // This class is reference counted.
   ~ChildImpl()
   {
-    AssertActorDestroyed();
   }
 
   void
   SetBoundThread()
   {
     THREADSAFETY_ASSERT(!mBoundThread);
 
 #if defined(DEBUG) || !defined(RELEASE_BUILD)
@@ -2003,18 +2008,21 @@ ChildImpl::DispatchFailureCallback(nsIEv
   }
 }
 
 void
 ChildImpl::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBoundThread();
 
+  BackgroundChildImpl::ActorDestroy(aWhy);
   mActorDestroyed = true;
-  BackgroundChildImpl::ActorDestroy(aWhy);
+  if (mReleaseOnActorDestroy) {
+    DoRelease();
+  }
 }
 
 NS_IMPL_ISUPPORTS(ChildImpl::ShutdownObserver, nsIObserver)
 
 NS_IMETHODIMP
 ChildImpl::ShutdownObserver::Observe(nsISupports* aSubject,
                                      const char* aTopic,
                                      const char16_t* aData)
diff --git a/ipc/glue/MessagePump.cpp b/ipc/glue/MessagePump.cpp
--- a/ipc/glue/MessagePump.cpp
+++ b/ipc/glue/MessagePump.cpp
@@ -54,16 +54,24 @@ public:
     MOZ_ASSERT(aPump);
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICANCELABLERUNNABLE
 
+  // The pump reuses the same DoWorkRunnable object, so allow
+  // the cancel to be cleared before rescheduling.
+  void ClearCancel()
+  {
+    MOZ_ASSERT(!mCallingRunWhileCanceled);
+    mCanceled = false;
+  }
+
 private:
   ~DoWorkRunnable()
   { }
 
   MessagePump* mPump;
   bool mCanceled;
   bool mCallingRunWhileCanceled;
 };
@@ -151,16 +159,17 @@ if (did_work && delayed_work_time_.is_nu
   keep_running_ = true;
 }
 
 void
 MessagePump::ScheduleWork()
 {
   // Make sure the event loop wakes up.
   if (mThread) {
+    mDoWorkEvent->ClearCancel();
     mThread->Dispatch(mDoWorkEvent, NS_DISPATCH_NORMAL);
   }
   else {
     // Some things (like xpcshell) don't use the app shell and so Run hasn't
     // been called. We still need to wake up the main thread.
     NS_DispatchToMainThread(mDoWorkEvent);
   }
   event_.Signal();
