# HG changeset patch
# Parent 91a55429c78b098926c8f23cacce69beede00178
# User Ben Kelly <ben@wanderview.com>
Bug 1032011 Handle async ActorDestroy() callback when closing PBackground.

diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -345,17 +345,18 @@ class ChildImpl MOZ_FINAL : public Backg
   static bool sShutdownHasStarted;
 
 #ifdef RELEASE_BUILD
   DebugOnly<nsIThread*> mBoundThread;
 #else
   nsIThread* mBoundThread;
 #endif
 
-  DebugOnly<bool> mActorDestroyed;
+  bool mActorDestroyed;
+  nsRefPtr<ChildImpl> mSelfRefWhileWaitingForActorDestroy;
 
 public:
   static bool
   OpenProtocolOnMainThread(nsIEventTarget* aEventTarget);
 
   static void
   Shutdown();
 
@@ -369,22 +370,16 @@ public:
 #else
     bool current;
 #endif
     THREADSAFETY_ASSERT(
       NS_SUCCEEDED(mBoundThread->IsOnCurrentThread(&current)));
     THREADSAFETY_ASSERT(current);
   }
 
-  void
-  AssertActorDestroyed()
-  {
-    MOZ_ASSERT(mActorDestroyed, "ChildImpl::ActorDestroy not called in time");
-  }
-
   ChildImpl()
   : mBoundThread(nullptr)
   , mActorDestroyed(false)
   {
     AssertIsOnMainThread();
   }
 
   NS_INLINE_DECL_REFCOUNTING(ChildImpl)
@@ -409,47 +404,56 @@ private:
   // Forwarded from BackgroundChild.
   static void
   CloseForCurrentThread();
 
   // Forwarded from BackgroundChildImpl.
   static BackgroundChildImpl::ThreadLocal*
   GetThreadLocalForCurrentThread();
 
+  void
+  ProxyReleaseToMainThread()
+  {
+    // ChildImpl uses non-threadsafe ref counts, so we must release on
+    // the same thread where it was created; the main thread.
+    ChildImpl* actor;
+    mSelfRefWhileWaitingForActorDestroy.forget(&actor);
+    nsCOMPtr<nsIRunnable> releaser =
+      NS_NewNonOwningRunnableMethod(actor, &ChildImpl::Release);
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(releaser)));
+  }
+
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
     if (threadLocalInfo) {
       if (threadLocalInfo->mActor) {
-        threadLocalInfo->mActor->Close();
-        threadLocalInfo->mActor->AssertActorDestroyed();
-        // Since the actor is created on the main thread it must only
-        // be released on the main thread as well.
-        if (!NS_IsMainThread()) {
-          ChildImpl* actor;
-          threadLocalInfo->mActor.forget(&actor);
-
-          nsCOMPtr<nsIRunnable> releaser =
-            NS_NewNonOwningRunnableMethod(actor, &ChildImpl::Release);
-          MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(releaser)));
-        }
+        // Close() can call ActorDestroy() either sync or async, so we must
+        // handle both.  Set a self-reference on actor which will then be
+        // released automatically when ActorDestroy() is called; either
+        // immediately or later.
+        ChildImpl* actor;
+        threadLocalInfo->mActor.forget(&actor);
+        MOZ_ASSERT(!actor->mSelfRefWhileWaitingForActorDestroy);
+        actor->mSelfRefWhileWaitingForActorDestroy = dont_AddRef(actor);
+        actor->Close();
       }
       delete threadLocalInfo;
     }
   }
 
   static void
   DispatchFailureCallback(nsIEventTarget* aEventTarget);
 
   // This class is reference counted.
   ~ChildImpl()
   {
-    AssertActorDestroyed();
+    MOZ_ASSERT(mActorDestroyed);
   }
 
   void
   SetBoundThread()
   {
     THREADSAFETY_ASSERT(!mBoundThread);
 
 #if defined(DEBUG) || !defined(RELEASE_BUILD)
@@ -2005,16 +2009,19 @@ ChildImpl::DispatchFailureCallback(nsIEv
 
 void
 ChildImpl::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBoundThread();
 
   mActorDestroyed = true;
   BackgroundChildImpl::ActorDestroy(aWhy);
+  if (mSelfRefWhileWaitingForActorDestroy) {
+    ProxyReleaseToMainThread();
+  }
 }
 
 NS_IMPL_ISUPPORTS(ChildImpl::ShutdownObserver, nsIObserver)
 
 NS_IMETHODIMP
 ChildImpl::ShutdownObserver::Observe(nsISupports* aSubject,
                                      const char* aTopic,
                                      const char16_t* aData)
diff --git a/ipc/glue/MessagePump.cpp b/ipc/glue/MessagePump.cpp
--- a/ipc/glue/MessagePump.cpp
+++ b/ipc/glue/MessagePump.cpp
@@ -43,34 +43,32 @@ namespace mozilla {
 namespace ipc {
 
 class DoWorkRunnable MOZ_FINAL : public nsICancelableRunnable,
                                  public nsITimerCallback
 {
 public:
   DoWorkRunnable(MessagePump* aPump)
   : mPump(aPump)
-  , mCanceled(false)
-  , mCallingRunWhileCanceled(false)
   {
     MOZ_ASSERT(aPump);
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSICANCELABLERUNNABLE
 
 private:
   ~DoWorkRunnable()
   { }
 
   MessagePump* mPump;
-  bool mCanceled;
-  bool mCallingRunWhileCanceled;
+  // DoWorkRunnable is designed as a stateless singleton.  Don't add stateful
+  // members here!
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
 MessagePump::MessagePump()
 : mThread(nullptr)
 {
@@ -219,21 +217,16 @@ MessagePump::DoDelayedWork(base::Message
 }
 
 NS_IMPL_ISUPPORTS(DoWorkRunnable, nsIRunnable, nsITimerCallback,
                                   nsICancelableRunnable)
 
 NS_IMETHODIMP
 DoWorkRunnable::Run()
 {
-  MOZ_ASSERT(!mCanceled || mCallingRunWhileCanceled);
-  if (mCanceled && !mCallingRunWhileCanceled) {
-    return NS_OK;
-  }
-
   MessageLoop* loop = MessageLoop::current();
   MOZ_ASSERT(loop);
 
   bool nestableTasksAllowed = loop->NestableTasksAllowed();
 
   // MessageLoop::RunTask() disallows nesting, but our Frankenventloop will
   // always dispatch DoWork() below from what looks to MessageLoop like a nested
   // context.  So we unconditionally allow nesting here.
@@ -253,26 +246,23 @@ DoWorkRunnable::Notify(nsITimer* aTimer)
   mPump->DoDelayedWork(loop);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DoWorkRunnable::Cancel()
 {
-  MOZ_ASSERT(!mCanceled);
-  MOZ_ASSERT(!mCallingRunWhileCanceled);
-
   // Workers require cancelable runnables, but we can't really cancel cleanly
-  // here.  If we don't process all of these then we will leave something
-  // unprocessed in the chromium queue.  Therefore, eagerly complete our work
-  // instead by immediately calling Run().
-  mCanceled = true;
-  mozilla::AutoRestore<bool> guard(mCallingRunWhileCanceled);
-  mCallingRunWhileCanceled = true;
+  // here.  If we don't process this runnable then we will leave something
+  // unprocessed in the message_loop.  Therefore, eagerly complete our work
+  // instead by immediately calling Run().  Run() should not be called
+  // separately after this.  Unfortunately we cannot use flags to verify this
+  // because DoWorkRunnable is a stateless singleton that can be in the event
+  // queue multiple times simultaneously.
   Run();
   return NS_OK;
 }
 
 void
 MessagePumpForChildProcess::Run(base::MessagePump::Delegate* aDelegate)
 {
   if (mFirstRun) {
