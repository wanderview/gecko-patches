# HG changeset patch
# Parent 10863af00e7ec20043a72bd8a0fe937d6e325633
# User Ben Kelly <ben@wanderview.com>
Update TODO comments in preparation for exporting patches to mozilla-central.


diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -85,17 +85,17 @@ DBAction::OpenConnection(const QuotaInfo
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = dbFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
   //      but this is what IDB does to access mozIStorageConnection so
   //      it seems at least this corner case mostly works.
-  // TODO: move this to main thread where GetInfoFromPrincipal() is executed
+  // TODO: move this to main thread where GetInfoFromPrincipal() is executed (bug 1110485)
   nsCOMPtr<nsIURI> uri;
   rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
   if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
 
   nsAutoCString type;
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -284,17 +284,17 @@ DBSchema::CacheMatchAll(mozIStorageConne
   if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
-  // TODO: replace this with a bulk load using SQL IN clause
+  // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
   for (uint32_t i = 0; i < matches.Length(); ++i) {
     SavedResponse *savedResponse = aSavedResponsesOut.AppendElement();
     rv = ReadResponse(aConn, matches[i], savedResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     savedResponse->mCacheId = aCacheId;
   }
 
   return rv;
@@ -368,17 +368,17 @@ DBSchema::CacheKeys(mozIStorageConnectio
   if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
-  // TODO: replace this with a bulk load using SQL IN clause
+  // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
   for (uint32_t i = 0; i < matches.Length(); ++i) {
     SavedRequest *savedRequest = aSavedRequestsOut.AppendElement();
     rv = ReadRequest(aConn, matches[i], savedRequest);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     savedRequest->mCacheId = aCacheId;
   }
 
   return rv;
@@ -602,19 +602,16 @@ DBSchema::QueryCache(mozIStorageConnecti
                      const PCacheQueryParams& aParams,
                      nsTArray<EntryId>& aEntryIdListOut)
 {
   MOZ_ASSERT(aConn);
 
   nsTArray<PCacheRequest> requestArray;
   nsTArray<PCacheResponse> responseArray;
 
-  // TODO: throw if new Request() would have failed:
-  // TODO:    - throw if aRequest is no CORS and method is not simple method
-
   if (!aParams.ignoreMethod() && !aRequest.method().LowerCaseEqualsLiteral("get")
                               && !aRequest.method().LowerCaseEqualsLiteral("head"))
   {
     return NS_OK;
   }
 
   nsAutoCString query(
     "SELECT id, COUNT(response_headers.name) AS vary_count "
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -31,21 +31,21 @@ struct SavedResponse;
 
 class DBSchema MOZ_FINAL
 {
 public:
   static nsresult CreateSchema(mozIStorageConnection* aConn);
 
   static nsresult CreateCache(mozIStorageConnection* aConn,
                               CacheId* aCacheIdOut);
-  // TODO: improve naming (confusing with CacheDelete)
+  // TODO: improve naming (confusing with CacheDelete) (bug 1110485)
   static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
                               nsTArray<nsID>& aDeletedBodyIdListOut);
 
-  // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code.
+  // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code. (bug 1110446)
   static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
                                   CacheId aCacheId, bool* aOrphanedOut);
 
   static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
                              const PCacheRequest& aRequest,
                              const PCacheQueryParams& aParams,
                              bool* aFoundResponseOut,
                              SavedResponse* aSavedResponseOut);
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
--- a/dom/cache/FetchPut.cpp
+++ b/dom/cache/FetchPut.cpp
@@ -338,39 +338,47 @@ FetchPut::MatchInPutList(const PCacheReq
     }
 
     nsRefPtr<InternalHeaders> cachedRequestHeaders =
       new InternalHeaders(cachedRequest.headers());
 
     nsRefPtr<InternalHeaders> cachedResponseHeaders =
       new InternalHeaders(cachedResponse.headers());
 
-    // TODO: headers Has/Get/GetAll should not take an ErrorResult
+    nsTArray<nsCString> varyHeaders;
     ErrorResult rv;
-
-    nsTArray<nsCString> varyHeaders;
-    cachedResponseHeaders->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders,
-                                       rv);
-    MOZ_ASSERT(!rv.Failed());
+    cachedResponseHeaders->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders, rv);
+    MOZ_ALWAYS_TRUE(!rv.Failed());
 
     // Assume the vary headers match until we find a conflict
     bool varyHeadersMatch = true;
 
     for (uint32_t j = 0; j < varyHeaders.Length(); ++j) {
       if (varyHeaders[i].EqualsLiteral("*")) {
         continue;
       }
 
+      // The VARY header could in theory contain an illegal header name.  So
+      // we need to detect the error in the Get() calls below.  Treat these
+      // as not matching.
+      ErrorResult headerRv;
+
       nsAutoCString value;
       requestHeaders->Get(varyHeaders[j], value, rv);
-      MOZ_ASSERT(!rv.Failed());
+      if (NS_WARN_IF(rv.Failed())) {
+        varyHeadersMatch = false;
+        break;
+      }
 
       nsAutoCString cachedValue;
       cachedRequestHeaders->Get(varyHeaders[j], value, rv);
-      MOZ_ASSERT(!rv.Failed());
+      if (NS_WARN_IF(rv.Failed())) {
+        varyHeadersMatch = false;
+        break;
+      }
 
       if (value != cachedValue) {
         varyHeadersMatch = false;
         break;
       }
     }
 
     // URL was equal and all vary headers match!
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -35,21 +35,21 @@ public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    // TODO: init maintainance marker
-    // TODO: perform maintainance if necessary
-    // TODO: find orphaned caches in database
+    // TODO: init maintainance marker (bug 1110446)
+    // TODO: perform maintainance if necessary (bug 1110446)
+    // TODO: find orphaned caches in database (bug 1110446)
     // TODO: have Context create/delete marker files in constructor/destructor
-    //       and only do expensive maintenance if that marker is present
+    //       and only do expensive maintenance if that marker is present (bug 1110446)
 
     nsresult rv = FileUtils::BodyCreateDir(aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     rv = DBSchema::CreateSchema(aConn);
@@ -1205,17 +1205,17 @@ Manager::ReleaseCacheId(CacheId aCacheId
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount < 1) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
-        // TODO: note that we need to check this cache for staleness on startup
+        // TODO: note that we need to check this cache for staleness on startup (bug 1110446)
         if (orphaned && !mShuttingDown) {
           CurrentContext()->CancelForCacheId(aCacheId);
           nsRefPtr<Action> action = new DeleteOrphanedCacheAction(this,
                                                                   aCacheId);
           CurrentContext()->Dispatch(mIOThread, action);
         }
       }
       return;
@@ -1573,30 +1573,29 @@ Manager::ReleaseBodyId(const nsID& aBody
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
       DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
       mBodyIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
       if (mBodyIdRefs[i].mCount < 1) {
         bool orphaned = mBodyIdRefs[i].mOrphaned;
         mBodyIdRefs.RemoveElementAt(i);
-        // TODO: note that we need to check this body for staleness on startup
+        // TODO: note that we need to check this body for staleness on startup (bug 1110446)
         if (orphaned && !mShuttingDown) {
           nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
           CurrentContext()->Dispatch(mIOThread, action);
         }
       }
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release BodyId that is not referenced!");
 }
 
-// TODO: provide way to set body non-orphaned if its added back to a cache
-//       once same-origin de-duplication is implemented
+// TODO: provide way to set body non-orphaned if its added back to a cache (bug 1110479)
 
 bool
 Manager::SetBodyIdOrphanedIfRefed(const nsID& aBodyId)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
       MOZ_ASSERT(mBodyIdRefs[i].mCount > 0);
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -122,17 +122,17 @@ public:
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
   void Shutdown();
   already_AddRefed<ManagerId> GetManagerId() const;
 
-  // TODO: consider moving CacheId up in the argument lists below
+  // TODO: consider moving CacheId up in the argument lists below (bug 1110485)
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
   void CachePutAll(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                    const nsTArray<CacheRequestResponse>& aPutList,
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -63,16 +63,17 @@ namespace cache {
 using mozilla::dom::quota::Client;
 using mozilla::dom::quota::PersistenceType;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::UsageInfo;
 
 Client*
 QuotaClient::Create()
 {
+  // TODO: implement nsIOfflineStorage interface (bug 1110487)
   return new QuotaClient();
 }
 
 Client::Type
 QuotaClient::GetType()
 {
   return DOMCACHE;
 }
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -69,17 +69,17 @@ ProcessURL(nsAString& aUrl, bool* aSchem
                             nullptr, nullptr,               // ignore filepath
                             &queryPos, &queryLen,
                             &refPos, &refLen);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aRv.Throw(rv);
     return;
   }
 
-  // TODO: Remove this once Request/Response properly strip the fragment
+  // TODO: Remove this once Request/Response properly strip the fragment (bug 1110476)
   if (refLen >= 0) {
     // ParsePath gives us ref position relative to the start of the path
     refPos += pathPos;
 
     aUrl = Substring(aUrl, 0, refPos - 1);
   }
 
   if (!aUrlWithoutQueryOut) {
@@ -175,17 +175,17 @@ TypeUtils::ToPCacheRequest(PCacheRequest
   aIn.GetMethod(aOut.method());
   aIn.GetUrl(aOut.url());
 
   bool schemeValid;
   ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
   if (aRv.Failed()) {
     return;
   }
-  // TODO: wrong scheme should trigger different behavior in Match vs Put, etc.
+  // TODO: wrong scheme should trigger different behavior in Match vs Put, etc. (bug 1110462)
   if (!schemeValid) {
     NS_NAMED_LITERAL_STRING(label, "Request");
     aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
     return;
   }
 
   nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
 
@@ -306,17 +306,17 @@ TypeUtils::ToPCacheResponseWithoutBody(P
   aOut.url() = NS_ConvertUTF8toUTF16(url);
 
   if (aOut.url() != EmptyString()) {
     bool schemeValid;
     ProcessURL(aOut.url(), &schemeValid, nullptr, aRv);
     if (aRv.Failed()) {
       return;
     }
-    // TODO: wrong scheme should trigger different behavior in Match vs Put, etc.
+    // TODO: wrong scheme should trigger different behavior in Match vs Put, etc. (bug 1110462)
     if (!schemeValid) {
       NS_NAMED_LITERAL_STRING(label, "Response");
       aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
       return;
     }
   }
 
   aOut.status() = aIn.GetStatus();
@@ -420,18 +420,17 @@ TypeUtils::ToResponse(const PCacheRespon
   return ref.forget();
 }
 
 already_AddRefed<InternalRequest>
 TypeUtils::ToInternalRequest(const PCacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
-  // TODO: Is this valid if DOM object has a system principal with
-  //       an origin of "[System Principal]"?
+  // TODO: Should not set origin on Request as it won't be valid for SystemPrincipal (bug 1110475)
   internalRequest->SetOrigin(Origin());
 
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
   internalRequest->SetContext(aIn.context());
