# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  30d94141bfaa1567318c3ae79e33748d7b054189
Bug 1231211 P13 Make worker ScriptLoader pass ClientInfo and ServiceWorkerDescriptor to NS_NewChannel() where appropriate. r=asuth

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -108,16 +108,18 @@ GetBaseURI(bool aIsMainScript, WorkerPri
 nsresult
 ChannelFromScriptURL(nsIPrincipal* principal,
                      nsIURI* baseURI,
                      nsIDocument* parentDoc,
                      nsILoadGroup* loadGroup,
                      nsIIOService* ios,
                      nsIScriptSecurityManager* secMan,
                      const nsAString& aScriptURL,
+                     const Maybe<ClientInfo>& aClientInfo,
+                     const Maybe<ServiceWorkerDescriptor>& aController,
                      bool aIsMainScript,
                      WorkerScriptType aWorkerScriptType,
                      nsContentPolicyType aMainScriptContentPolicyType,
                      nsLoadFlags aLoadFlags,
                      bool aDefaultURIEncoding,
                      nsIChannel** aChannel)
 {
   AssertIsOnMainThread();
@@ -192,25 +194,42 @@ ChannelFromScriptURL(nsIPrincipal* princ
                        aLoadFlags,
                        ios);
   } else {
     // We must have a loadGroup with a load context for the principal to
     // traverse the channel correctly.
     MOZ_ASSERT(loadGroup);
     MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(loadGroup, principal));
 
-    rv = NS_NewChannel(getter_AddRefs(channel),
-                       uri,
-                       principal,
-                       secFlags,
-                       contentPolicyType,
-                       loadGroup,
-                       nullptr, // aCallbacks
-                       aLoadFlags,
-                       ios);
+    if (aClientInfo.isSome()) {
+#ifdef MOZ_DIAGNOSTIC_ASSERT_ENABLED
+      nsCOMPtr<nsIPrincipal> clientPrincipal(aClientInfo.ref().GetPrincipal());
+      MOZ_DIAGNOSTIC_ASSERT(principal->Equals(clientPrincipal));
+#endif
+      rv = NS_NewChannel(getter_AddRefs(channel),
+                         uri,
+                         aClientInfo.ref(),
+                         aController,
+                         secFlags,
+                         contentPolicyType,
+                         loadGroup,
+                         nullptr, // aCallbacks
+                         aLoadFlags,
+                         ios);
+    } else {
+      rv = NS_NewChannel(getter_AddRefs(channel),
+                         uri,
+                         principal,
+                         secFlags,
+                         contentPolicyType,
+                         loadGroup,
+                         nullptr, // aCallbacks
+                         aLoadFlags,
+                         ios);
+    }
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel)) {
     mozilla::net::ReferrerPolicy referrerPolicy = parentDoc ?
       parentDoc->GetReferrerPolicy() : mozilla::net::RP_Unset;
     rv = nsContentUtils::SetFetchReferrerURIWithPolicy(principal, parentDoc,
@@ -565,33 +584,37 @@ class ScriptLoaderRunnable final : publi
   friend class CachePromiseHandler;
   friend class CacheScriptLoader;
   friend class LoaderListener;
 
   WorkerPrivate* mWorkerPrivate;
   nsCOMPtr<nsIEventTarget> mSyncLoopTarget;
   nsTArray<ScriptLoadInfo> mLoadInfos;
   RefPtr<CacheCreator> mCacheCreator;
+  Maybe<ClientInfo> mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
   bool mIsMainScript;
   WorkerScriptType mWorkerScriptType;
   bool mCanceled;
   bool mCanceledMainThread;
   ErrorResult& mRv;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
   ScriptLoaderRunnable(WorkerPrivate* aWorkerPrivate,
                        nsIEventTarget* aSyncLoopTarget,
                        nsTArray<ScriptLoadInfo>& aLoadInfos,
+                       const Maybe<ClientInfo>& aClientInfo,
+                       const Maybe<ServiceWorkerDescriptor>& aController,
                        bool aIsMainScript,
                        WorkerScriptType aWorkerScriptType,
                        ErrorResult& aRv)
   : mWorkerPrivate(aWorkerPrivate), mSyncLoopTarget(aSyncLoopTarget),
+    mClientInfo(aClientInfo), mController(aController),
     mIsMainScript(aIsMainScript), mWorkerScriptType(aWorkerScriptType),
     mCanceled(false), mCanceledMainThread(false), mRv(aRv)
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
     MOZ_ASSERT(aSyncLoopTarget);
     MOZ_ASSERT_IF(aIsMainScript, aLoadInfos.Length() == 1);
 
     mLoadInfos.SwapElements(aLoadInfos);
@@ -966,17 +989,19 @@ private:
       }
     }
 
     if (!channel) {
       // Only top level workers' main script use the document charset for the
       // script uri encoding. Otherwise, default encoding (UTF-8) is applied.
       bool useDefaultEncoding = !(!parentWorker && IsMainWorkerScript());
       rv = ChannelFromScriptURL(principal, baseURI, parentDoc, loadGroup, ios,
-                                secMan, loadInfo.mURL, IsMainWorkerScript(),
+                                secMan, loadInfo.mURL,
+                                mClientInfo, mController,
+                                IsMainWorkerScript(),
                                 mWorkerScriptType,
                                 mWorkerPrivate->ContentPolicyType(), loadFlags,
                                 useDefaultEncoding,
                                 getter_AddRefs(channel));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     }
@@ -1824,26 +1849,28 @@ CacheScriptLoader::OnStreamComplete(nsIS
                                    mCSPReportOnlyHeaderValue,
                                    mReferrerPolicyHeaderValue);
   return NS_OK;
 }
 
 class ChannelGetterRunnable final : public WorkerMainThreadRunnable
 {
   const nsAString& mScriptURL;
+  const ClientInfo mClientInfo;
   WorkerLoadInfo& mLoadInfo;
   nsresult mResult;
 
 public:
   ChannelGetterRunnable(WorkerPrivate* aParentWorker,
                         const nsAString& aScriptURL,
                         WorkerLoadInfo& aLoadInfo)
     : WorkerMainThreadRunnable(aParentWorker,
                                NS_LITERAL_CSTRING("ScriptLoader :: ChannelGetter"))
     , mScriptURL(aScriptURL)
+    , mClientInfo(aParentWorker->GetClientInfo())
     , mLoadInfo(aLoadInfo)
     , mResult(NS_ERROR_FAILURE)
   {
     MOZ_ASSERT(aParentWorker);
     aParentWorker->AssertIsOnWorkerThread();
   }
 
   virtual bool
@@ -1864,22 +1891,26 @@ public:
     nsCOMPtr<nsIURI> baseURI = mWorkerPrivate->GetBaseURI();
     MOZ_ASSERT(baseURI);
 
     // May be null.
     nsCOMPtr<nsIDocument> parentDoc = mWorkerPrivate->GetDocument();
 
     mLoadInfo.mLoadGroup = mWorkerPrivate->GetLoadGroup();
 
+    Maybe<ClientInfo> clientInfo;
+    clientInfo.emplace(mClientInfo);
+
     nsCOMPtr<nsIChannel> channel;
     mResult =
       scriptloader::ChannelFromScriptURLMainThread(mLoadInfo.mLoadingPrincipal,
                                                    baseURI, parentDoc,
                                                    mLoadInfo.mLoadGroup,
                                                    mScriptURL,
+                                                   clientInfo,
                                                    // Nested workers are always dedicated.
                                                    nsIContentPolicy::TYPE_INTERNAL_WORKER,
                                                    // Nested workers use default uri encoding.
                                                    true,
                                                    getter_AddRefs(channel));
     NS_ENSURE_SUCCESS(mResult, true);
 
     mResult = mLoadInfo.SetPrincipalFromChannel(channel);
@@ -2166,18 +2197,26 @@ LoadAllScripts(WorkerPrivate* aWorkerPri
 
   AutoSyncLoopHolder syncLoop(aWorkerPrivate, Terminating);
   nsCOMPtr<nsIEventTarget> syncLoopTarget = syncLoop.GetEventTarget();
   if (!syncLoopTarget) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
+  Maybe<ClientInfo> clientInfo;
+  Maybe<ServiceWorkerDescriptor> controller;
+  if (!aIsMainScript) {
+    clientInfo.emplace(aWorkerPrivate->GetClientInfo());
+    controller = aWorkerPrivate->GetController();
+  }
+
   RefPtr<ScriptLoaderRunnable> loader =
     new ScriptLoaderRunnable(aWorkerPrivate, syncLoopTarget, aLoadInfos,
+                             clientInfo, controller,
                              aIsMainScript, aWorkerScriptType, aRv);
 
   NS_ASSERTION(aLoadInfos.IsEmpty(), "Should have swapped!");
 
   ScriptLoaderHolder workerHolder(loader);
 
   if (NS_WARN_IF(!workerHolder.HoldWorker(aWorkerPrivate, Terminating))) {
     aRv.Throw(NS_ERROR_FAILURE);
@@ -2200,30 +2239,32 @@ BEGIN_WORKERS_NAMESPACE
 namespace scriptloader {
 
 nsresult
 ChannelFromScriptURLMainThread(nsIPrincipal* aPrincipal,
                                nsIURI* aBaseURI,
                                nsIDocument* aParentDoc,
                                nsILoadGroup* aLoadGroup,
                                const nsAString& aScriptURL,
+                               const Maybe<ClientInfo>& aClientInfo,
                                nsContentPolicyType aMainScriptContentPolicyType,
                                bool aDefaultURIEncoding,
                                nsIChannel** aChannel)
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIIOService> ios(do_GetIOService());
 
   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
   NS_ASSERTION(secMan, "This should never be null!");
 
   return ChannelFromScriptURL(aPrincipal, aBaseURI, aParentDoc, aLoadGroup,
-                              ios, secMan, aScriptURL, true, WorkerScript,
-                              aMainScriptContentPolicyType,
+                              ios, secMan, aScriptURL, aClientInfo,
+                              Maybe<ServiceWorkerDescriptor>(),
+                              true, WorkerScript, aMainScriptContentPolicyType,
                               nsIRequest::LOAD_NORMAL, aDefaultURIEncoding,
                               aChannel);
 }
 
 nsresult
 ChannelFromScriptURLWorkerThread(JSContext* aCx,
                                  WorkerPrivate* aParent,
                                  const nsAString& aScriptURL,
diff --git a/dom/workers/ScriptLoader.h b/dom/workers/ScriptLoader.h
--- a/dom/workers/ScriptLoader.h
+++ b/dom/workers/ScriptLoader.h
@@ -33,16 +33,17 @@ enum WorkerScriptType {
 namespace scriptloader {
 
 nsresult
 ChannelFromScriptURLMainThread(nsIPrincipal* aPrincipal,
                                nsIURI* aBaseURI,
                                nsIDocument* aParentDoc,
                                nsILoadGroup* aLoadGroup,
                                const nsAString& aScriptURL,
+                               const Maybe<ClientInfo>& aClientInfo,
                                nsContentPolicyType aContentPolicyType,
                                bool aDefaultURIEncoding,
                                nsIChannel** aChannel);
 
 nsresult
 ChannelFromScriptURLWorkerThread(JSContext* aCx,
                                  WorkerPrivate* aParent,
                                  const nsAString& aScriptURL,
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -4825,16 +4825,17 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
         nsJSUtils::GetStaticScriptGlobal(JS::CurrentGlobalOrNull(aCx));
       if (scriptGlobal) {
         globalWindow = do_QueryInterface(scriptGlobal);
         MOZ_ASSERT(globalWindow);
       }
     }
 
     nsCOMPtr<nsIDocument> document;
+    Maybe<ClientInfo> clientInfo;
 
     if (globalWindow) {
       // Only use the current inner window, and only use it if the caller can
       // access it.
       if (nsPIDOMWindowOuter* outerWindow = globalWindow->GetOuterWindow()) {
         loadInfo.mWindow = outerWindow->GetCurrentInnerWindow();
         // TODO: fix this for SharedWorkers with multiple documents (bug 1177935)
         loadInfo.mServiceWorkersTestingInWindow =
@@ -4857,16 +4858,18 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
       // from the document.
       document = loadInfo.mWindow->GetExtantDoc();
       NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
 
       loadInfo.mBaseURI = document->GetDocBaseURI();
       loadInfo.mLoadGroup = document->GetDocumentLoadGroup();
       NS_ENSURE_TRUE(loadInfo.mLoadGroup, NS_ERROR_FAILURE);
 
+      clientInfo = globalWindow->GetClientInfo();
+
       // Use the document's NodePrincipal as loading principal if we're not being
       // called from chrome.
       if (!loadInfo.mLoadingPrincipal) {
         loadInfo.mLoadingPrincipal = document->NodePrincipal();
         NS_ENSURE_TRUE(loadInfo.mLoadingPrincipal, NS_ERROR_FAILURE);
 
         // We use the document's base domain to limit the number of workers
         // each domain can create. For sandboxed documents, we use the domain
@@ -4972,16 +4975,17 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
 
     // Top level workers' main script use the document charset for the script
     // uri encoding.
     bool useDefaultEncoding = false;
     rv = ChannelFromScriptURLMainThread(loadInfo.mLoadingPrincipal,
                                         loadInfo.mBaseURI,
                                         document, loadInfo.mLoadGroup,
                                         aScriptURL,
+                                        clientInfo,
                                         ContentPolicyType(aWorkerType),
                                         useDefaultEncoding,
                                         getter_AddRefs(loadInfo.mChannel));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = NS_GetFinalChannelURI(loadInfo.mChannel,
                                getter_AddRefs(loadInfo.mResolvedScriptURI));
     NS_ENSURE_SUCCESS(rv, rv);
