# HG changeset patch
# Parent e965a1a534ecb6635975fae33a929dc6c06bcb50
# User Ben Kelly <ben@wanderview.com>
Bug 1143223 Teach Cache ReadStream not to AddRef() in its destructor.


diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
-#include "mozilla/dom/cache/ReadStream.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // declared in ActorUtils.h
 PCacheStreamControlChild*
@@ -38,26 +37,26 @@ CacheStreamControlChild::CacheStreamCont
 
 CacheStreamControlChild::~CacheStreamControlChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_COUNT_DTOR(cache::CacheStreamControlChild);
 }
 
 void
-CacheStreamControlChild::AddListener(ReadStream* aListener)
+CacheStreamControlChild::AddListener(ReadStream::Controllable* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(!mListeners.Contains(aListener));
   mListeners.AppendElement(aListener);
 }
 
 void
-CacheStreamControlChild::RemoveListener(ReadStream* aListener)
+CacheStreamControlChild::RemoveListener(ReadStream::Controllable* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_ASSERT(aListener);
   MOZ_ALWAYS_TRUE(mListeners.RemoveElement(aListener));
 }
 
 void
 CacheStreamControlChild::NoteClosed(const nsID& aId)
@@ -86,33 +85,32 @@ CacheStreamControlChild::StartDestroy()
 void
 CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   // Note, we cannot trigger IPC traffic here.  So use
   // CloseStreamWithoutReporting().
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStreamWithoutReporting();
+    iter.GetNext()->CloseStreamWithoutReporting();;
   }
   mListeners.Clear();
 
   RemoveFeature();
 }
 
 bool
 CacheStreamControlChild::RecvClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   DebugOnly<uint32_t> closedCount = 0;
 
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
+    ReadStream::Controllable* stream = iter.GetNext();
     // note, multiple streams may exist for same ID
     if (stream->MatchId(aId)) {
       stream->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
@@ -121,17 +119,16 @@ CacheStreamControlChild::RecvClose(const
 }
 
 bool
 CacheStreamControlChild::RecvCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStream();
+    iter.GetNext()->CloseStream();
   }
   return true;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -4,46 +4,45 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStreamControlChild_h
 #define mozilla_dom_cache_CacheStreamControlChild_h
 
 #include "mozilla/dom/cache/ActorChild.h"
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class ReadStream;
-
 class CacheStreamControlChild MOZ_FINAL : public PCacheStreamControlChild
                                         , public ActorChild
 {
 public:
   CacheStreamControlChild();
   ~CacheStreamControlChild();
 
-  void AddListener(ReadStream* aListener);
-  void RemoveListener(ReadStream* aListener);
+  void AddListener(ReadStream::Controllable* aListener);
+  void RemoveListener(ReadStream::Controllable* aListener);
 
   void NoteClosed(const nsID& aId);
 
   // ActorChild methods
   virtual void StartDestroy() MOZ_OVERRIDE;
 
 private:
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
-  typedef nsTObserverArray<ReadStream*> ReadStreamList;
+  typedef nsTObserverArray<ReadStream::Controllable*> ReadStreamList;
   ReadStreamList mListeners;
 
   bool mDestroyStarted;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -3,17 +3,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
-#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // declared in ActorUtils.h
@@ -31,42 +30,41 @@ CacheStreamControlParent::CacheStreamCon
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(!mStreamList);
   MOZ_COUNT_DTOR(cache::CacheStreamControlParent);
 }
 
 void
-CacheStreamControlParent::AddListener(ReadStream* aListener)
+CacheStreamControlParent::AddListener(ReadStream::Controllable* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(!mListeners.Contains(aListener));
   mListeners.AppendElement(aListener);
 }
 
 void
-CacheStreamControlParent::RemoveListener(ReadStream* aListener)
+CacheStreamControlParent::RemoveListener(ReadStream::Controllable* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(aListener);
   DebugOnly<bool> removed = mListeners.RemoveElement(aListener);
   MOZ_ASSERT(removed);
 }
 
 void
 CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(mStreamList);
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStreamWithoutReporting();
+    iter.GetNext()->CloseStreamWithoutReporting();
   }
   mStreamList->RemoveStreamControl(this);
   mStreamList->NoteClosedAll();
   mStreamList = nullptr;
 }
 
 bool
 CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
@@ -115,33 +113,32 @@ CacheStreamControlParent::Shutdown()
 void
 CacheStreamControlParent::NotifyClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   DebugOnly<uint32_t> closedCount = 0;
 
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
+    ReadStream::Controllable* stream = iter.GetNext();
     // note, multiple streams may exist for same ID
     if (stream->MatchId(aId)) {
       stream->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 }
 
 void
 CacheStreamControlParent::NotifyCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStream();
+    iter.GetNext()->CloseStream();
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -3,33 +3,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStreamControlParent_h
 #define mozilla_dom_cache_CacheStreamControlParent_h
 
 #include "mozilla/dom/cache/PCacheStreamControlParent.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class ReadStream;
 class StreamList;
 
 class CacheStreamControlParent : public PCacheStreamControlParent
 {
 public:
   CacheStreamControlParent();
   ~CacheStreamControlParent();
 
-  void AddListener(ReadStream* aListener);
-  void RemoveListener(ReadStream* aListener);
+  void AddListener(ReadStream::Controllable* aListener);
+  void RemoveListener(ReadStream::Controllable* aListener);
 
   void SetStreamList(StreamList* aStreamList);
   void Close(const nsID& aId);
   void CloseAll();
   void Shutdown();
 
   // PCacheStreamControlParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
@@ -39,17 +39,17 @@ private:
   void NotifyClose(const nsID& aId);
   void NotifyCloseAll();
 
   // Cycle with StreamList via a weak-ref to us.  Cleanup occurs when the actor
   // is deleted by the PBackground manager.  ActorDestroy() then calls
   // StreamList::RemoveStreamControl() to clear the weak ref.
   nsRefPtr<StreamList> mStreamList;
 
-  typedef nsTObserverArray<ReadStream*> ReadStreamList;
+  typedef nsTObserverArray<ReadStream::Controllable*> ReadStreamList;
   ReadStreamList mListeners;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -51,49 +51,50 @@ class ReadStreamChild MOZ_FINAL : public
 {
 public:
   ReadStreamChild(PCacheStreamControlChild* aControl, const nsID& aId,
                   nsIInputStream* aStream)
     : ReadStream(aId, aStream)
     , mControl(static_cast<CacheStreamControlChild*>(aControl))
   {
     MOZ_ASSERT(mControl);
-    mControl->AddListener(this);
+    //mControl->AddListener(this);
   }
 
   virtual ~ReadStreamChild()
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
-    NoteClosed();
+    // TODO
+    //NoteClosed();
   }
 
   virtual void NoteClosedOnOwningThread() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
     if (mClosed) {
       return;
     }
 
     mClosed = true;
-    mControl->RemoveListener(this);
+    //mControl->RemoveListener(this);
     mControl->NoteClosed(mId);
   }
 
   virtual void ForgetOnOwningThread() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
     if (mClosed) {
       return;
     }
 
     mClosed = true;
-    mControl->RemoveListener(this);
+    //mControl->RemoveListener(this);
   }
 
   virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aReadStreamOut);
     MOZ_ASSERT(!mClosed);
     aReadStreamOut->controlParent() = nullptr;
     aReadStreamOut->controlChild() = mControl;
@@ -129,52 +130,53 @@ class ReadStreamParent MOZ_FINAL : publi
 {
 public:
   ReadStreamParent(PCacheStreamControlParent* aControl, const nsID& aId,
                   nsIInputStream* aStream)
     : ReadStream(aId, aStream)
     , mControl(static_cast<CacheStreamControlParent*>(aControl))
   {
     MOZ_ASSERT(mControl);
-    mControl->AddListener(this);
+    //mControl->AddListener(this);
   }
 
   virtual ~ReadStreamParent()
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
-    NoteClosed();
+    // TODO
+    // NoteClosed();
   }
 
   virtual void NoteClosedOnOwningThread() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
     if (mClosed) {
       return;
     }
 
     mClosed = true;
-    mControl->RemoveListener(this);
+    //mControl->RemoveListener(this);
     // This can cause mControl to be destructed
     mControl->RecvNoteClosed(mId);
     mControl = nullptr;
   }
 
   virtual void ForgetOnOwningThread() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(ReadStream);
 
     if (mClosed) {
       return;
     }
 
     mClosed = true;
     // This can cause mControl to be destroyed
-    mControl->RemoveListener(this);
+    //mControl->RemoveListener(this);
     mControl = nullptr;
   }
 
   virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aReadStreamOut);
     MOZ_ASSERT(!mClosed);
     MOZ_ASSERT(mControl);
@@ -218,16 +220,321 @@ namespace cache {
 using mozilla::unused;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::FileDescriptorSetParent;
 using mozilla::ipc::InputStreamParams;
 using mozilla::ipc::OptionalFileDescriptorSet;
 using mozilla::ipc::PFileDescriptorSetChild;
 
+class ReadStream::InnerStream : public nsIInputStream
+                              , public ReadStream::Controllable
+{
+public:
+  InnerStream(const nsID& aId, nsIInputStream* aStream);
+
+  void
+  Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
+
+  void
+  Serialize(PCacheReadStream* aReadStreamOut);
+
+  virtual void
+  CloseStream() MOZ_OVERRIDE;
+
+  virtual void
+  CloseStreamWithoutReporting() MOZ_OVERRIDE;
+
+  virtual bool
+  MatchId(const nsID& aId) const MOZ_OVERRIDE;
+
+protected:
+  ~InnerStream();
+
+  virtual void
+  NoteClosedOnOwningThread() = 0;
+
+  virtual void
+  ForgetOnOwningThread() = 0;
+
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) = 0;
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& fds) = 0;
+
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  nsCOMPtr<nsIInputStream> mSnappyStream;
+  bool mClosed;
+
+  NS_DECL_NSIINPUTSTREAM
+};
+
+ReadStream::InnerStream::InnerStream(const nsID& aId, nsIInputStream* aStream)
+  : mId(aId)
+  , mStream(aStream)
+  , mSnappyStream(new SnappyUncompressInputStream(aStream))
+  , mClosed(false)
+{
+  MOZ_ASSERT(mStream);
+}
+
+ReadStream::InnerStream::~InnerStream()
+{
+  // TODO
+  // NS_ASSERT_OWNINGTHREAD(ReadStream::InnerStream);
+
+  // We cannot directly call NoteClosed() here.  The concrete subclasses
+  // destructors must do this because it takes code paths through virtual
+  // methods.  We don't want to execute these while partially destroyed.
+  MOZ_ASSERT(mClosed);
+}
+
+NS_IMETHODIMP
+ReadStream::InnerStream::Close()
+{
+  nsresult rv = mStream->Close();
+  // TODO
+  //NoteClosed();
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::InnerStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mSnappyStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    Close();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::InnerStream::Read(char* aBuf, uint32_t aCount,
+                              uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    Close();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::InnerStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                                      uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
+                                            aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    Close();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::InnerStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mSnappyStream->IsNonBlocking(aNonBlockingOut);
+}
+
+// ----------------------------------------------------------------------------
+
+class ReadStream::InnerStreamChild MOZ_FINAL : public ReadStream::InnerStream
+{
+public:
+  InnerStreamChild(PCacheStreamControlChild* aControl, const nsID& aId,
+                   nsIInputStream* aStream)
+    : InnerStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlChild*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual void
+  NoteClosedOnOwningThread() MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+    mControl->NoteClosed(mId);
+  }
+
+  virtual void
+  ForgetOnOwningThread() MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+  }
+
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    MOZ_ASSERT(!mClosed);
+    aReadStreamOut->controlParent() = nullptr;
+    aReadStreamOut->controlChild() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(!mClosed);
+    PFileDescriptorSetChild* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  ~InnerStreamChild()
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    // TODO
+    // NoteClosed();
+  }
+
+  CacheStreamControlChild* mControl;
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ReadStream::InnerStreamChild, nsIInputStream);
+
+// ----------------------------------------------------------------------------
+
+class ReadStream::InnerStreamParent MOZ_FINAL : public InnerStream
+{
+public:
+  InnerStreamParent(PCacheStreamControlParent* aControl, const nsID& aId,
+                    nsIInputStream* aStream)
+    : InnerStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlParent*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual void
+  NoteClosedOnOwningThread() MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+    // This can cause mControl to be destructed
+    mControl->RecvNoteClosed(mId);
+    mControl = nullptr;
+  }
+
+  virtual void
+  ForgetOnOwningThread() MOZ_OVERRIDE
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    // This can cause mControl to be destroyed
+    mControl->RemoveListener(this);
+    mControl = nullptr;
+  }
+
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    MOZ_ASSERT(!mClosed);
+    MOZ_ASSERT(mControl);
+    aReadStreamOut->controlChild() = nullptr;
+    aReadStreamOut->controlParent() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(!mClosed);
+    MOZ_ASSERT(mControl);
+    PFileDescriptorSetParent* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  ~InnerStreamParent()
+  {
+    NS_ASSERT_OWNINGTHREAD(ReadStream);
+
+    // TODO
+    // NoteClosed();
+  }
+
+  CacheStreamControlParent* mControl;
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(ReadStream::InnerStreamParent, nsIInputStream);
+
+// ----------------------------------------------------------------------------
+
 // Runnable to notify actors that the ReadStream has closed.  This must
 // be done on the thread associated with the PBackground actor.  Must be
 // cancelable to execute on Worker threads (which can occur when the
 // ReadStream is constructed on a child process Worker thread).
 class ReadStream::NoteClosedRunnable MOZ_FINAL : public nsCancelableRunnable
 {
 public:
   explicit NoteClosedRunnable(ReadStream* aStream)
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -38,16 +38,24 @@ class PCacheStreamControlParent;
 // The ReadStream class also provides us with a convenient QI'able
 // interface that we can use to pass additional meta-data with the
 // stream channel.  For example, Cache.put() can detect that the content
 // script is passing a Cache-originated-stream back into the Cache
 // again.  This enables certain optimizations.
 class ReadStream : public nsIInputStream
 {
 public:
+  class Controllable
+  {
+  public:
+    virtual void CloseStream() = 0;
+    virtual void CloseStreamWithoutReporting() = 0;
+    virtual bool MatchId(const nsID& aId) const = 0;
+  };
+
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
 
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStream& aReadStream);
 
   static already_AddRefed<ReadStream>
   Create(PCacheStreamControlParent* aControl, const nsID& aId,
@@ -56,16 +64,23 @@ public:
   void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
   void Serialize(PCacheReadStream* aReadStreamOut);
 
   // methods called from the child and parent CacheStreamControl actors
   void CloseStream();
   void CloseStreamWithoutReporting();
   bool MatchId(const nsID& aId) const;
 
+private:
+  class InnerStream;
+  class InnerStreamChild;
+  class InnerStreamParent;
+
+  nsRefPtr<InnerStream> mInner;
+
 protected:
   class NoteClosedRunnable;
   class ForgetRunnable;
 
   ReadStream(const nsID& aId, nsIInputStream* aStream);
   virtual ~ReadStream();
 
   void NoteClosed();
