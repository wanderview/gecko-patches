# HG changeset patch
# Parent 41a61514461e055808ebaab3dbd2c1121e96bd15
# User Ben Kelly <ben@wanderview.com>
Bug 1143223 Teach Cache ReadStream not to AddRef() itself in its destructor. r=ehsan

diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -4,23 +4,32 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::OptionalFileDescriptorSet;
+using mozilla::ipc::PFileDescriptorSetChild;
+
 // declared in ActorUtils.h
 PCacheStreamControlChild*
 AllocPCacheStreamControlChild()
 {
   return new CacheStreamControlChild();
 }
 
 // declared in ActorUtils.h
@@ -37,31 +46,70 @@ CacheStreamControlChild::CacheStreamCont
 }
 
 CacheStreamControlChild::~CacheStreamControlChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_COUNT_DTOR(cache::CacheStreamControlChild);
 }
 
-void
-CacheStreamControlChild::AddListener(ReadStream* aListener)
+already_AddRefed<StreamControl>
+CacheStreamControlChild::CreateStreamControl()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  MOZ_ASSERT(aListener);
-  MOZ_ASSERT(!mListeners.Contains(aListener));
-  mListeners.AppendElement(aListener);
+  nsRefPtr<StreamControl> ref = new StreamControl(this);
+  mControlList.AppendElement(ref);
+  return ref.forget();
 }
 
 void
-CacheStreamControlChild::RemoveListener(ReadStream* aListener)
+CacheStreamControlChild::SerializeControl(PCacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  MOZ_ASSERT(aListener);
-  MOZ_ALWAYS_TRUE(mListeners.RemoveElement(aListener));
+  aReadStreamOut->controlParent() = nullptr;
+  aReadStreamOut->controlChild() = this;
+}
+
+void
+CacheStreamControlChild::SerializeFds(PCacheReadStream* aReadStreamOut,
+                                      const nsTArray<FileDescriptor>& aFds)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  PFileDescriptorSetChild* fdSet = nullptr;
+  if (!aFds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(aFds[0]);
+    for (uint32_t i = 1; i < aFds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(aFds[i]);
+    }
+  }
+
+  if (fdSet) {
+    aReadStreamOut->fds() = fdSet;
+  } else {
+    aReadStreamOut->fds() = void_t();
+  }
+}
+
+void
+CacheStreamControlChild::DeserializeFds(const PCacheReadStream& aReadStream,
+                                        nsTArray<FileDescriptor>& aFdsOut)
+{
+  if (aReadStream.fds().type() !=
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+    return;
+  }
+
+  auto fdSetActor = static_cast<FileDescriptorSetChild*>(
+    aReadStream.fds().get_PFileDescriptorSetChild());
+  MOZ_ASSERT(fdSetActor);
+
+  fdSetActor->ForgetFileDescriptors(aFdsOut);
+  MOZ_ASSERT(!aFdsOut.IsEmpty());
+
+  unused << fdSetActor->Send__delete__(fdSetActor);
 }
 
 void
 CacheStreamControlChild::NoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   unused << SendNoteClosed(aId);
 }
@@ -84,54 +132,48 @@ CacheStreamControlChild::StartDestroy()
 }
 
 void
 CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   // Note, we cannot trigger IPC traffic here.  So use
   // CloseStreamWithoutReporting().
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStreamWithoutReporting();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    mControlList[i]->CloseStreamWithoutReporting();
+    mControlList[i]->RemoveActor(this);
   }
-  mListeners.Clear();
+  mControlList.Clear();
 
   RemoveFeature();
 }
 
 bool
 CacheStreamControlChild::RecvClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   DebugOnly<uint32_t> closedCount = 0;
 
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    // note, multiple streams may exist for same ID
-    if (stream->MatchId(aId)) {
-      stream->CloseStream();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    if (mControlList[i]->MatchId(aId)) {
+      mControlList[i]->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 
   return true;
 }
 
 bool
 CacheStreamControlChild::RecvCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStream();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    mControlList[i]->CloseStream();
   }
   return true;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -4,47 +4,61 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStreamControlChild_h
 #define mozilla_dom_cache_CacheStreamControlChild_h
 
 #include "mozilla/dom/cache/ActorChild.h"
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "mozilla/dom/cache/StreamControl.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ReadStream;
 
 class CacheStreamControlChild MOZ_FINAL : public PCacheStreamControlChild
+                                        , public StreamControl::Actor
                                         , public ActorChild
 {
 public:
   CacheStreamControlChild();
   ~CacheStreamControlChild();
 
-  void AddListener(ReadStream* aListener);
-  void RemoveListener(ReadStream* aListener);
+  already_AddRefed<StreamControl>
+  CreateStreamControl();
 
-  void NoteClosed(const nsID& aId);
+  // StreamControl::Actor methods
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE;
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& aFds) MOZ_OVERRIDE;
+
+  virtual void
+  DeserializeFds(const PCacheReadStream& aReadStream,
+                 nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) MOZ_OVERRIDE;
+
+  virtual void
+  NoteClosed(const nsID& aId) MOZ_OVERRIDE;
 
   // ActorChild methods
   virtual void StartDestroy() MOZ_OVERRIDE;
 
 private:
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
-  typedef nsTObserverArray<ReadStream*> ReadStreamList;
-  ReadStreamList mListeners;
+  nsTArray<nsRefPtr<StreamControl>> mControlList;
 
   bool mDestroyStarted;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -3,24 +3,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/StreamList.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetParent;
+using mozilla::ipc::OptionalFileDescriptorSet;
+using mozilla::ipc::PFileDescriptorSetParent;
+
 // declared in ActorUtils.h
 void
 DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
 {
   delete aActor;
 }
 
 CacheStreamControlParent::CacheStreamControlParent()
@@ -30,55 +39,101 @@ CacheStreamControlParent::CacheStreamCon
 
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(!mStreamList);
   MOZ_COUNT_DTOR(cache::CacheStreamControlParent);
 }
 
-void
-CacheStreamControlParent::AddListener(ReadStream* aListener)
+already_AddRefed<StreamControl>
+CacheStreamControlParent::CreateStreamControl()
 {
-  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(aListener);
-  MOZ_ASSERT(!mListeners.Contains(aListener));
-  mListeners.AppendElement(aListener);
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  nsRefPtr<StreamControl> ref = new StreamControl(this);
+  mControlList.AppendElement(ref);
+  return ref.forget();
 }
 
 void
-CacheStreamControlParent::RemoveListener(ReadStream* aListener)
+CacheStreamControlParent::SerializeControl(PCacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(aListener);
-  DebugOnly<bool> removed = mListeners.RemoveElement(aListener);
-  MOZ_ASSERT(removed);
+  aReadStreamOut->controlChild() = nullptr;
+  aReadStreamOut->controlParent() = this;
+}
+
+void
+CacheStreamControlParent::SerializeFds(PCacheReadStream* aReadStreamOut,
+                                       const nsTArray<FileDescriptor>& aFds)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
+  PFileDescriptorSetParent* fdSet = nullptr;
+  if (!aFds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(aFds[0]);
+    for (uint32_t i = 1; i < aFds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(aFds[i]);
+    }
+  }
+
+  if (fdSet) {
+    aReadStreamOut->fds() = fdSet;
+  } else {
+    aReadStreamOut->fds() = void_t();
+  }
+}
+
+void
+CacheStreamControlParent::DeserializeFds(const PCacheReadStream& aReadStream,
+                                         nsTArray<FileDescriptor>& aFdsOut)
+{
+  if (aReadStream.fds().type() !=
+      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+    return;
+  }
+
+  FileDescriptorSetParent* fdSetActor =
+    static_cast<FileDescriptorSetParent*>(aReadStream.fds().get_PFileDescriptorSetParent());
+  MOZ_ASSERT(fdSetActor);
+
+  fdSetActor->ForgetFileDescriptors(aFdsOut);
+  MOZ_ASSERT(!aFdsOut.IsEmpty());
+
+  if (!fdSetActor->Send__delete__(fdSetActor)) {
+    // child process is gone, warn and allow actor to clean up normally
+    NS_WARNING("Cache failed to delete fd set actor.");
+  }
+}
+
+void
+CacheStreamControlParent::NoteClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
+  MOZ_ASSERT(mStreamList);
+  mStreamList->NoteClosed(aId);
 }
 
 void
 CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(mStreamList);
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStreamWithoutReporting();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    mControlList[i]->CloseStreamWithoutReporting();
+    mControlList[i]->RemoveActor(this);
   }
   mStreamList->RemoveStreamControl(this);
   mStreamList->NoteClosedAll();
   mStreamList = nullptr;
 }
 
 bool
 CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
 {
-  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(mStreamList);
-  mStreamList->NoteClosed(aId);
+  NoteClosed(aId);
   return true;
 }
 
 void
 CacheStreamControlParent::SetStreamList(StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(!mStreamList);
@@ -113,35 +168,30 @@ CacheStreamControlParent::Shutdown()
 }
 
 void
 CacheStreamControlParent::NotifyClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   DebugOnly<uint32_t> closedCount = 0;
 
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    // note, multiple streams may exist for same ID
-    if (stream->MatchId(aId)) {
-      stream->CloseStream();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    if (mControlList[i]->MatchId(aId)) {
+      mControlList[i]->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 }
 
 void
 CacheStreamControlParent::NotifyCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  ReadStreamList::ForwardIterator iter(mListeners);
-  while (iter.HasMore()) {
-    nsRefPtr<ReadStream> stream = iter.GetNext();
-    stream->CloseStream();
+  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
+    mControlList[i]->CloseStream();
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -3,54 +3,70 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStreamControlParent_h
 #define mozilla_dom_cache_CacheStreamControlParent_h
 
 #include "mozilla/dom/cache/PCacheStreamControlParent.h"
+#include "mozilla/dom/cache/StreamControl.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ReadStream;
 class StreamList;
 
 class CacheStreamControlParent : public PCacheStreamControlParent
+                               , public StreamControl::Actor
 {
 public:
   CacheStreamControlParent();
   ~CacheStreamControlParent();
 
-  void AddListener(ReadStream* aListener);
-  void RemoveListener(ReadStream* aListener);
+  already_AddRefed<StreamControl>
+  CreateStreamControl();
 
   void SetStreamList(StreamList* aStreamList);
   void Close(const nsID& aId);
   void CloseAll();
   void Shutdown();
 
+  // StreamControl::Actor methods
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE;
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& aFds) MOZ_OVERRIDE;
+
+  virtual void
+  DeserializeFds(const PCacheReadStream& aReadStream,
+                 nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) MOZ_OVERRIDE;
+
+  virtual void
+  NoteClosed(const nsID& aId) MOZ_OVERRIDE;
+
+private:
   // PCacheStreamControlParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
 
-private:
   void NotifyClose(const nsID& aId);
   void NotifyCloseAll();
 
   // Cycle with StreamList via a weak-ref to us.  Cleanup occurs when the actor
   // is deleted by the PBackground manager.  ActorDestroy() then calls
   // StreamList::RemoveStreamControl() to clear the weak ref.
   nsRefPtr<StreamList> mStreamList;
 
-  typedef nsTObserverArray<ReadStream*> ReadStreamList;
-  ReadStreamList mListeners;
+  nsTArray<nsRefPtr<StreamControl>> mControlList;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -4,229 +4,29 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/ReadStream.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
-#include "mozilla/dom/cache/PCacheStreamControlChild.h"
-#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/ipc/FileDescriptor.h"
-#include "mozilla/ipc/FileDescriptorSetChild.h"
-#include "mozilla/ipc/FileDescriptorSetParent.h"
-#include "mozilla/ipc/InputStreamParams.h"
 #include "mozilla/ipc/InputStreamUtils.h"
-#include "mozilla/ipc/PBackgroundChild.h"
-#include "mozilla/ipc/PBackgroundParent.h"
-#include "mozilla/ipc/PFileDescriptorSetChild.h"
-#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "mozilla/SnappyUncompressInputStream.h"
 #include "nsIAsyncInputStream.h"
 #include "nsTArray.h"
 
-namespace {
-
-using mozilla::unused;
-using mozilla::void_t;
-using mozilla::dom::cache::CacheStreamControlChild;
-using mozilla::dom::cache::CacheStreamControlParent;
-using mozilla::dom::cache::PCacheReadStream;
-using mozilla::dom::cache::PCacheStreamControlChild;
-using mozilla::dom::cache::PCacheStreamControlParent;
-using mozilla::dom::cache::ReadStream;
-using mozilla::ipc::FileDescriptor;
-using mozilla::ipc::PFileDescriptorSetChild;
-using mozilla::ipc::PFileDescriptorSetParent;
-
-// There are separate concrete implementations of ReadStream for the child
-// and parent processes.  This is unfortunately necessary because the
-// actor types are distinct for these two cases.  Also, the interface for
-// reporting the close event differs slightly for the child and parent
-// StreamControl actors.
-
-// ----------------------------------------------------------------------------
-
-class ReadStreamChild MOZ_FINAL : public ReadStream
-{
-public:
-  ReadStreamChild(PCacheStreamControlChild* aControl, const nsID& aId,
-                  nsIInputStream* aStream)
-    : ReadStream(aId, aStream)
-    , mControl(static_cast<CacheStreamControlChild*>(aControl))
-  {
-    MOZ_ASSERT(mControl);
-    mControl->AddListener(this);
-  }
-
-  virtual ~ReadStreamChild()
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    NoteClosed();
-  }
-
-  virtual void NoteClosedOnOwningThread() MOZ_OVERRIDE
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    if (mClosed) {
-      return;
-    }
-
-    mClosed = true;
-    mControl->RemoveListener(this);
-    mControl->NoteClosed(mId);
-  }
-
-  virtual void ForgetOnOwningThread() MOZ_OVERRIDE
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    if (mClosed) {
-      return;
-    }
-
-    mClosed = true;
-    mControl->RemoveListener(this);
-  }
-
-  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
-  {
-    MOZ_ASSERT(aReadStreamOut);
-    MOZ_ASSERT(!mClosed);
-    aReadStreamOut->controlParent() = nullptr;
-    aReadStreamOut->controlChild() = mControl;
-  }
-
-  virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
-               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
-  {
-    MOZ_ASSERT(!mClosed);
-    PFileDescriptorSetChild* fdSet = nullptr;
-    if (!fds.IsEmpty()) {
-      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
-      for (uint32_t i = 1; i < fds.Length(); ++i) {
-        unused << fdSet->SendAddFileDescriptor(fds[i]);
-      }
-    }
-
-    if (fdSet) {
-      aReadStreamOut->fds() = fdSet;
-    } else {
-      aReadStreamOut->fds() = void_t();
-    }
-  }
-
-private:
-  CacheStreamControlChild* mControl;
-};
-
-// ----------------------------------------------------------------------------
-
-class ReadStreamParent MOZ_FINAL : public ReadStream
-{
-public:
-  ReadStreamParent(PCacheStreamControlParent* aControl, const nsID& aId,
-                  nsIInputStream* aStream)
-    : ReadStream(aId, aStream)
-    , mControl(static_cast<CacheStreamControlParent*>(aControl))
-  {
-    MOZ_ASSERT(mControl);
-    mControl->AddListener(this);
-  }
-
-  virtual ~ReadStreamParent()
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    NoteClosed();
-  }
-
-  virtual void NoteClosedOnOwningThread() MOZ_OVERRIDE
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    if (mClosed) {
-      return;
-    }
-
-    mClosed = true;
-    mControl->RemoveListener(this);
-    // This can cause mControl to be destructed
-    mControl->RecvNoteClosed(mId);
-    mControl = nullptr;
-  }
-
-  virtual void ForgetOnOwningThread() MOZ_OVERRIDE
-  {
-    NS_ASSERT_OWNINGTHREAD(ReadStream);
-
-    if (mClosed) {
-      return;
-    }
-
-    mClosed = true;
-    // This can cause mControl to be destroyed
-    mControl->RemoveListener(this);
-    mControl = nullptr;
-  }
-
-  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
-  {
-    MOZ_ASSERT(aReadStreamOut);
-    MOZ_ASSERT(!mClosed);
-    MOZ_ASSERT(mControl);
-    aReadStreamOut->controlChild() = nullptr;
-    aReadStreamOut->controlParent() = mControl;
-  }
-
-  virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
-               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
-  {
-    MOZ_ASSERT(!mClosed);
-    MOZ_ASSERT(mControl);
-    PFileDescriptorSetParent* fdSet = nullptr;
-    if (!fds.IsEmpty()) {
-      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
-      for (uint32_t i = 1; i < fds.Length(); ++i) {
-        unused << fdSet->SendAddFileDescriptor(fds[i]);
-      }
-    }
-
-    if (fdSet) {
-      aReadStreamOut->fds() = fdSet;
-    } else {
-      aReadStreamOut->fds() = void_t();
-    }
-  }
-
-private:
-  CacheStreamControlParent* mControl;
-};
-
-// ----------------------------------------------------------------------------
-
-} // anonymous namespace
-
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ipc::FileDescriptor;
-using mozilla::ipc::FileDescriptorSetChild;
-using mozilla::ipc::FileDescriptorSetParent;
-using mozilla::ipc::InputStreamParams;
-using mozilla::ipc::OptionalFileDescriptorSet;
-using mozilla::ipc::PFileDescriptorSetChild;
 
 // Runnable to notify actors that the ReadStream has closed.  This must
 // be done on the thread associated with the PBackground actor.  Must be
 // cancelable to execute on Worker threads (which can occur when the
 // ReadStream is constructed on a child process Worker thread).
 class ReadStream::NoteClosedRunnable MOZ_FINAL : public nsCancelableRunnable
 {
 public:
@@ -281,19 +81,16 @@ public:
   }
 
 private:
   ~ForgetRunnable() { }
 
   nsRefPtr<ReadStream> mStream;
 };
 
-NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream,
-                                                   ReadStream);
-
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid)
 {
   if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
     return nullptr;
   }
 
@@ -306,98 +103,86 @@ ReadStream::Create(const PCacheReadStrea
 {
   // The parameter may or may not be for a Cache created stream.  The way we
   // tell is by looking at the stream control actor.  If the actor exists,
   // then we know the Cache created it.
   if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
     return nullptr;
   }
 
+  nsRefPtr<StreamControl> control;
+  if (aReadStream.controlChild()) {
+    auto actor = static_cast<CacheStreamControlChild*>(aReadStream.controlChild());
+    control = actor->CreateStreamControl();
+  } else {
+    auto actor = static_cast<CacheStreamControlParent*>(aReadStream.controlParent());
+    control = actor->CreateStreamControl();
+  }
+  MOZ_ASSERT(control);
+
   nsAutoTArray<FileDescriptor, 4> fds;
-  if (aReadStream.fds().type() ==
-      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
-
-    FileDescriptorSetChild* fdSetActor =
-      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
-    MOZ_ASSERT(fdSetActor);
-
-    fdSetActor->ForgetFileDescriptors(fds);
-    MOZ_ASSERT(!fds.IsEmpty());
-
-    unused << fdSetActor->Send__delete__(fdSetActor);
-  } else if (aReadStream.fds().type() ==
-      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
-
-    FileDescriptorSetParent* fdSetActor =
-      static_cast<FileDescriptorSetParent*>(aReadStream.fds().get_PFileDescriptorSetParent());
-    MOZ_ASSERT(fdSetActor);
-
-    fdSetActor->ForgetFileDescriptors(fds);
-    MOZ_ASSERT(!fds.IsEmpty());
-
-    if (!fdSetActor->Send__delete__(fdSetActor)) {
-      // child process is gone, warn and allow actor to clean up normally
-      NS_WARNING("Cache failed to delete fd set actor.");
-    }
-  }
+  control->DeserializeFds(aReadStream, fds);
 
   nsCOMPtr<nsIInputStream> stream =
     DeserializeInputStream(aReadStream.params(), fds);
   MOZ_ASSERT(stream);
 
   // Currently we expect all cache read streams to be blocking file streams.
 #ifdef DEBUG
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
   MOZ_ASSERT(!asyncStream);
 #endif
 
   nsRefPtr<ReadStream> ref;
 
   if (aReadStream.controlChild()) {
-    ref = new ReadStreamChild(aReadStream.controlChild(), aReadStream.id(),
-                              stream);
+    ref = new ReadStream(control, aReadStream.id(), stream);
   } else {
-    ref = new ReadStreamParent(aReadStream.controlParent(), aReadStream.id(),
-                               stream);
+    ref = new ReadStream(control, aReadStream.id(), stream);
   }
 
   return ref.forget();
 }
 
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
                    nsIInputStream* aStream)
 {
-  nsRefPtr<ReadStream> ref = new ReadStreamParent(aControl, aId, aStream);
+  MOZ_ASSERT(aControl);
+  auto actor = static_cast<CacheStreamControlParent*>(aControl);
+  nsRefPtr<StreamControl> control = actor->CreateStreamControl();
+  nsRefPtr<ReadStream> ref = new ReadStream(control, aId, aStream);
   return ref.forget();
 }
 
 void
 ReadStream::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
 {
+  NS_ASSERT_OWNINGTHREAD(ReadStream);
   MOZ_ASSERT(aReadStreamOut);
   PCacheReadStream stream;
   Serialize(&stream);
   *aReadStreamOut = stream;
 }
 
 void
 ReadStream::Serialize(PCacheReadStream* aReadStreamOut)
 {
+  NS_ASSERT_OWNINGTHREAD(ReadStream);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(!mClosed);
 
   aReadStreamOut->id() = mId;
-  SerializeControl(aReadStreamOut);
+  mControl->SerializeControl(aReadStreamOut);
 
   nsAutoTArray<FileDescriptor, 4> fds;
   SerializeInputStream(mStream, aReadStreamOut->params(), fds);
 
-  SerializeFds(aReadStreamOut, fds);
+  mControl->SerializeFds(aReadStreamOut, fds);
 
   // We're passing ownership across the IPC barrier with the control, so
   // do not signal that the stream is closed here.
   Forget();
 }
 
 void
 ReadStream::CloseStream()
@@ -412,72 +197,94 @@ ReadStream::CloseStreamWithoutReporting(
 }
 
 bool
 ReadStream::MatchId(const nsID& aId) const
 {
   return mId.Equals(aId);
 }
 
-ReadStream::ReadStream(const nsID& aId, nsIInputStream* aStream)
-  : mId(aId)
+ReadStream::ReadStream(StreamControl* aControl, const nsID& aId,
+                       nsIInputStream* aStream)
+  : mControl(aControl)
+  , mId(aId)
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mOwningThread(NS_GetCurrentThread())
   , mClosed(false)
 {
   MOZ_ASSERT(mStream);
+  mControl->SetReadStream(this);
 }
 
 ReadStream::~ReadStream()
 {
-  NS_ASSERT_OWNINGTHREAD(ReadStream);
+  // Any thread
+  MOZ_ASSERT(mClosed);
 
-  // We cannot directly call NoteClosed() here.  The concrete subclasses
-  // destructors must do this because it takes code paths through virtual
-  // methods.  We don't want to execute these while partially destroyed.
-  MOZ_ASSERT(mClosed);
+  if (NS_GetCurrentThread() == mOwningThread) {
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewNonOwningRunnableMethod(mControl.forget().take(), &StreamControl::Release);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::NoteClosed()
 {
   if (mClosed) {
     return;
   }
 
+  mClosed = true;
+
   if (NS_GetCurrentThread() == mOwningThread) {
     NoteClosedOnOwningThread();
     return;
   }
 
   nsCOMPtr<nsIRunnable> runnable = new NoteClosedRunnable(this);
-  nsresult rv = mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to dispatch Cache ReadStream NoteClosed() runnable.");
-  }
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
 }
 
 void
 ReadStream::Forget()
 {
   if (mClosed) {
     return;
   }
 
+  mClosed = true;
+
   if (NS_GetCurrentThread() == mOwningThread) {
     ForgetOnOwningThread();
     return;
   }
 
   nsCOMPtr<nsIRunnable> runnable = new ForgetRunnable(this);
-  nsresult rv = mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to dispatch Cache ReadStream Forget() runnable.");
-  }
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
+}
+
+void
+ReadStream::NoteClosedOnOwningThread()
+{
+  NS_ASSERT_OWNINGTHREAD(ReadStream);
+  mControl->NoteClosed(mId);
+}
+
+void
+ReadStream::ForgetOnOwningThread()
+{
+  NS_ASSERT_OWNINGTHREAD(ReadStream);
+  mControl->ForgetReadStream();
 }
 
 NS_IMETHODIMP
 ReadStream::Close()
 {
   nsresult rv = mStream->Close();
   NoteClosed();
   return rv;
@@ -528,11 +335,38 @@ ReadStream::ReadSegments(nsWriteSegmentF
 }
 
 NS_IMETHODIMP
 ReadStream::IsNonBlocking(bool* aNonBlockingOut)
 {
   return mSnappyStream->IsNonBlocking(aNonBlockingOut);
 }
 
+NS_IMPL_ADDREF(cache::ReadStream);
+NS_IMPL_QUERY_INTERFACE(cache::ReadStream, nsIInputStream, ReadStream);
+
+// Custom Release() is necessary to handle the implicit close that
+// occurs when a stream is destroyed.  We need to issue an async runnable
+// to perform this operation, so the object must not be completely
+// destroyed yet.  Therefore, we hold a ref-cycle and perform a Close()
+// when the ref count drops to 1.
+NS_IMETHODIMP_(MozExternalRefCountType)
+ReadStream::Release()
+{
+  MOZ_ASSERT(int32_t(mRefCnt) > 0, "dup release");
+  nsrefcnt count = --mRefCnt;
+  NS_LOG_RELEASE(this, count, "nsPipe");
+  if (count == 0) {
+    delete (this);
+    return 0;
+  }
+  // Automatically close if the only thing keeping us alive is our
+  // ref-cycle with StreamControl.
+  if (!mClosed && count == 1) {
+    Close();
+    return 1;
+  }
+  return count;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -7,27 +7,29 @@
 #ifndef mozilla_dom_cache_ReadStream_h
 #define mozilla_dom_cache_ReadStream_h
 
 #include "mozilla/ipc/FileDescriptor.h"
 #include "nsCOMPtr.h"
 #include "nsID.h"
 #include "nsIInputStream.h"
 #include "nsISupportsImpl.h"
+#include "nsRefPtr.h"
 #include "nsTArrayForwardDeclare.h"
 
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheReadStream;
 class PCacheReadStreamOrVoid;
 class PCacheStreamControlParent;
+class StreamControl;
 
 // IID for the dom::cache::ReadStream interface
 #define NS_DOM_CACHE_READSTREAM_IID \
 {0x8e5da7c9, 0x0940, 0x4f1d, \
   {0x97, 0x25, 0x5c, 0x59, 0x38, 0xdd, 0xb9, 0x9f}}
 
 // Custom stream class for Request and Response bodies being read from
 // a Cache.  The main purpose of this class is to report back to the
@@ -35,17 +37,17 @@ class PCacheStreamControlParent;
 // accurately determine when the underlying body file can be deleted,
 // etc.
 //
 // The ReadStream class also provides us with a convenient QI'able
 // interface that we can use to pass additional meta-data with the
 // stream channel.  For example, Cache.put() can detect that the content
 // script is passing a Cache-originated-stream back into the Cache
 // again.  This enables certain optimizations.
-class ReadStream : public nsIInputStream
+class ReadStream MOZ_FINAL : public nsIInputStream
 {
 public:
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
 
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStream& aReadStream);
 
@@ -56,44 +58,39 @@ public:
   void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
   void Serialize(PCacheReadStream* aReadStreamOut);
 
   // methods called from the child and parent CacheStreamControl actors
   void CloseStream();
   void CloseStreamWithoutReporting();
   bool MatchId(const nsID& aId) const;
 
-protected:
+private:
   class NoteClosedRunnable;
   class ForgetRunnable;
 
-  ReadStream(const nsID& aId, nsIInputStream* aStream);
-  virtual ~ReadStream();
+  ReadStream(StreamControl* aStreamControl, const nsID& aId,
+             nsIInputStream* aStream);
+  ~ReadStream();
 
   void NoteClosed();
   void Forget();
 
-  virtual void NoteClosedOnOwningThread() = 0;
-  virtual void ForgetOnOwningThread() = 0;
-  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) = 0;
+  void NoteClosedOnOwningThread();
+  void ForgetOnOwningThread();
 
-  virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
-               const nsTArray<mozilla::ipc::FileDescriptor>& fds) = 0;
-
+  nsRefPtr<StreamControl> mControl;
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
   nsCOMPtr<nsIInputStream> mSnappyStream;
   nsCOMPtr<nsIThread> mOwningThread;
-  bool mClosed;
+  Atomic<bool> mClosed;
 
 public:
-
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_READSTREAM_IID);
-
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ReadStream, NS_DOM_CACHE_READSTREAM_IID);
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/StreamControl.cpp b/dom/cache/StreamControl.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/StreamControl.cpp
@@ -0,0 +1,123 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/StreamControl.h"
+
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/ReadStream.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "nsID.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ipc::FileDescriptor;
+
+StreamControl::StreamControl(Actor* aActor)
+  : mActor(aActor)
+{
+  MOZ_ASSERT(mActor);
+}
+
+void
+StreamControl::RemoveActor(Actor* aActor)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mActor);
+  MOZ_ASSERT(mActor == aActor);
+  mActor = nullptr;
+}
+
+void
+StreamControl::CloseStream()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  if (mReadStream) {
+    mReadStream->CloseStream();
+  }
+}
+
+void
+StreamControl::CloseStreamWithoutReporting()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  if (mReadStream) {
+    mReadStream->CloseStreamWithoutReporting();
+  }
+}
+
+bool
+StreamControl::MatchId(const nsID& aId) const
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  return mReadStream && mReadStream->MatchId(aId);
+}
+
+void
+StreamControl::SetReadStream(ReadStream* aReadStream)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(!mReadStream);
+  mReadStream = aReadStream;
+  MOZ_ASSERT(mReadStream);
+}
+
+void
+StreamControl::SerializeControl(PCacheReadStream* aReadStreamOut)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mActor);
+  mActor->SerializeControl(aReadStreamOut);
+}
+
+void
+StreamControl::SerializeFds(PCacheReadStream* aReadStreamOut,
+                            const nsTArray<FileDescriptor>& aFds)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mActor);
+  mActor->SerializeFds(aReadStreamOut, aFds);
+}
+
+void
+StreamControl::DeserializeFds(const PCacheReadStream& aReadStream,
+                              nsTArray<FileDescriptor>& aFdsOut)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mActor);
+  mActor->DeserializeFds(aReadStream, aFdsOut);
+}
+
+void
+StreamControl::NoteClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mReadStream);
+  mReadStream = nullptr;
+  if (mActor) {
+    mActor->NoteClosed(aId);
+  }
+}
+
+void
+StreamControl::ForgetReadStream()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(mReadStream);
+  mReadStream = nullptr;
+}
+
+StreamControl::~StreamControl()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamControl);
+  MOZ_ASSERT(!mActor);
+  MOZ_ASSERT(!mReadStream);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/StreamControl.h b/dom/cache/StreamControl.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/StreamControl.h
@@ -0,0 +1,148 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_StreamControl_h
+#define mozilla_dom_cache_StreamControl_h
+
+#include "nsISupportsImpl.h"
+#include "nsRefPtr.h"
+#include "nsTArrayForwardDeclare.h"
+
+struct nsID;
+
+namespace mozilla {
+namespace ipc {
+ class FileDescriptor;
+}
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class ReadStream;
+
+// Utility class for connecting ReadStream objects to their backing stream
+// control IPC actors.  The interface between those two objects is quite
+// difficult for a number of reasons:
+//
+//  1) IPC actors are single thread
+//  2) IPC actors are not ref-counted and may be destroyed at any time (on
+//     their thread)
+//  3) ReadStream must be available on multiple threads so it can be read
+//     using STS.
+//  4) ReadStream is ref-counted.  The ref count is modified on different
+//     threads due to (3).
+//  5) The IPC actor must send messages to ReadStream.
+//  6) The ReadStream must send messages to the IPC actor.
+//  7) Stream objects implicitly close when destroyed, so ReadStream() needs
+//     to send a message to the IPC from its destructor.  This is the
+//     hardest issue here because the destructor might run on the wrong
+//     thread.
+//
+// To mitigate this issue we introduce this utility StreamControl class.  It
+// sits between the ReadStream and the actor.  The reference relationships
+// are like this:
+//
+//  a) IPC actor holds a strong ref to StreamControl.
+//  b) StreamControl holds a weak ref to the IPC actor.  The IPC actor clears
+//     this in its ActorDestroy().
+//  c) StreamControl holds a strong ref to ReadStream.
+//  d) ReadStream holds a strong ref to StreamControl.  This is not a thread
+//     safe ref, however, so it must be proxy released on the right thread.
+//
+// This allows both the actor and ReadStream to have a stable object to send
+// their methods to.  The StreamControl is still tied to its owning thread for
+// all its methods, but ReadStream can be assured it will survive a Runnable
+// dispatch because its strongly ref'd.
+//
+// The ref-cycle between ReadStream and StreamControl is always broken from
+// the StreamControl side.  The ReadStream can do this by calling NotifyClosed()
+// or Forget() on the owning thread.
+//
+// In the case of an implicit close due to ReadStream being destroyed, the
+// ref-cycle is broken by ReadStream::Release() issuing a Close() when its
+// ref-count drops to 1.  This is kind of ugly, but seems the safest and
+// cleanest way to deal with this implicit operation on destruction.
+class StreamControl
+{
+public:
+  // Interface implementated by the actors to abstract away Child
+  // and Parent type names.
+  class Actor
+  {
+  public:
+    virtual void
+    SerializeControl(PCacheReadStream* aReadStreamOut) = 0;
+
+    virtual void
+    SerializeFds(PCacheReadStream* aReadStreamOut,
+                 const nsTArray<mozilla::ipc::FileDescriptor>& aFds) = 0;
+
+    virtual void
+    DeserializeFds(const PCacheReadStream& aReadStream,
+                   nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) = 0;
+
+    virtual void
+    NoteClosed(const nsID& aId) = 0;
+  };
+
+  explicit StreamControl(Actor* aActor);
+
+  //
+  // Methods called from Actor
+  //
+  void
+  RemoveActor(Actor* aActor);
+
+  void
+  CloseStream();
+
+  void
+  CloseStreamWithoutReporting();
+
+  bool
+  MatchId(const nsID& aId) const;
+
+  //
+  // Methods called from ReadStream
+  //
+  void
+  SetReadStream(ReadStream* aReadStream);
+
+  void
+  SerializeControl(PCacheReadStream* aReadStreamOut);
+
+  void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& aFds);
+
+  void
+  DeserializeFds(const PCacheReadStream& aReadStream,
+                 nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut);
+
+  void
+  NoteClosed(const nsID& aId);
+
+  void
+  ForgetReadStream();
+
+private:
+  ~StreamControl();
+
+  // Weak ref cleared by RemoveActor()
+  Actor* mActor;
+
+  // Ref-cycle with ReadStream.  Neither object will be destroyed until
+  // this ref is dropped.
+  nsRefPtr<ReadStream> mReadStream;
+
+  NS_INLINE_DECL_REFCOUNTING(cache::StreamControl)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_StreamControl_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -25,23 +25,25 @@ EXPORTS.mozilla.dom.cache += [
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
     'PrincipalVerifier.h',
     'QuotaClient.h',
     'ReadStream.h',
     'SavedTypes.h',
+    'StreamControl.h',
     'StreamList.h',
     'StreamUtils.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
-UNIFIED_SOURCES += [
+#UNIFIED_SOURCES += [
+SOURCES += [
     'Action.cpp',
     'ActorChild.cpp',
     'AutoUtils.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
@@ -54,16 +56,17 @@ UNIFIED_SOURCES += [
     'Feature.cpp',
     'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'PrincipalVerifier.cpp',
     'QuotaClient.cpp',
     'ReadStream.cpp',
+    'StreamControl.cpp',
     'StreamList.cpp',
     'StreamUtils.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'CacheInitData.ipdlh',
     'PCache.ipdl',
