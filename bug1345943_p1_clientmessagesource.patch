# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c93344534abe36a85c24672bf0bf4d9449bfd0be
Bug 1345943 P1 Set the MessageEvent.source to ServiceWorker that called Client.postMessage(). r=asuth

diff --git a/dom/workers/ServiceWorkerClient.cpp b/dom/workers/ServiceWorkerClient.cpp
--- a/dom/workers/ServiceWorkerClient.cpp
+++ b/dom/workers/ServiceWorkerClient.cpp
@@ -124,22 +124,28 @@ ServiceWorkerClient::Type() const
 }
 
 namespace {
 
 class ServiceWorkerClientPostMessageRunnable final
   : public Runnable
   , public StructuredCloneHolder
 {
-  uint64_t mWindowId;
+  const uint64_t mSourceID;
+  const nsCString mSourceScope;
+  const uint64_t mWindowId;
 
 public:
-  explicit ServiceWorkerClientPostMessageRunnable(uint64_t aWindowId)
+  ServiceWorkerClientPostMessageRunnable(uint64_t aSourceID,
+                                         const nsACString& aSourceScope,
+                                         uint64_t aWindowId)
     : StructuredCloneHolder(CloningSupported, TransferringSupported,
                             StructuredCloneScope::SameProcessDifferentThread)
+    , mSourceID(aSourceID)
+    , mSourceScope(aSourceScope)
     , mWindowId(aWindowId)
   {}
 
   NS_IMETHOD
   Run() override
   {
     AssertIsOnMainThread();
     nsGlobalWindow* window = nsGlobalWindow::GetInnerWindowWithId(mWindowId);
@@ -155,22 +161,23 @@ public:
 
     RefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
     AutoJSAPI jsapi;
     if (NS_WARN_IF(!jsapi.Init(window))) {
       return NS_ERROR_FAILURE;
     }
     JSContext* cx = jsapi.cx();
 
-    return DispatchDOMEvent(cx, container);
+    return DispatchDOMEvent(cx, window->AsInner(), container);
   }
 
 private:
   NS_IMETHOD
-  DispatchDOMEvent(JSContext* aCx, ServiceWorkerContainer* aTargetContainer)
+  DispatchDOMEvent(JSContext* aCx, nsPIDOMWindowInner* aWindow,
+                   ServiceWorkerContainer* aTargetContainer)
   {
     AssertIsOnMainThread();
 
     MOZ_ASSERT(aTargetContainer->GetParentObject(),
                "How come we don't have a window here?!");
 
     JS::Rooted<JS::Value> messageData(aCx);
     ErrorResult rv;
@@ -196,19 +203,28 @@ private:
 
     init.mData = messageData;
     nsAutoCString origin;
     if (principal && !isNullPrincipal && !isSystemPrincipal) {
       principal->GetOrigin(origin);
     }
     init.mOrigin = NS_ConvertUTF8toUTF16(origin);
 
-    RefPtr<ServiceWorker> serviceWorker = aTargetContainer->GetController();
-    if (serviceWorker) {
-      init.mSource.SetValue().SetAsServiceWorker() = serviceWorker;
+
+    RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+    if (swm) {
+      RefPtr<ServiceWorkerRegistrationInfo> reg =
+        swm->GetRegistration(principal, mSourceScope);
+      if (reg) {
+        RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(mSourceID);
+        if (serviceWorker) {
+          init.mSource.SetValue().SetAsServiceWorker() =
+            serviceWorker->GetOrCreateInstance(aWindow);
+        }
+      }
     }
 
     if (!TakeTransferredPortsAsSequence(init.mPorts)) {
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
     RefPtr<MessageEvent> event =
       MessageEvent::Constructor(aTargetContainer, NS_LITERAL_STRING("message"),
@@ -241,18 +257,24 @@ ServiceWorkerClient::PostMessage(JSConte
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
 
   aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                           &transferable);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
+  // At the moment we only expose Client on ServiceWorker globals.
+  MOZ_ASSERT(workerPrivate->IsServiceWorker());
+  uint32_t serviceWorkerID = workerPrivate->ServiceWorkerID();
+  nsCString scope = workerPrivate->WorkerName();
+
   RefPtr<ServiceWorkerClientPostMessageRunnable> runnable =
-    new ServiceWorkerClientPostMessageRunnable(mWindowId);
+    new ServiceWorkerClientPostMessageRunnable(serviceWorkerID, scope,
+                                               mWindowId);
 
   runnable->Write(aCx, aMessage, transferable, JS::CloneDataPolicy().denySharedArrayBuffer(),
                   aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   aRv = workerPrivate->DispatchToMainThread(runnable.forget());
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -434,16 +434,34 @@ ServiceWorkerRegistrationInfo::GetWaitin
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetActive() const
 {
   AssertIsOnMainThread();
   return mActiveWorker;
 }
 
+ServiceWorkerInfo*
+ServiceWorkerRegistrationInfo::GetByID(uint64_t aID) const
+{
+  if (mActiveWorker && mActiveWorker->ID() == aID) {
+    return mActiveWorker;
+  }
+  if (mWaitingWorker && mWaitingWorker->ID() == aID) {
+    return mWaitingWorker;
+  }
+  if (mInstallingWorker && mInstallingWorker->ID() == aID) {
+    return mInstallingWorker;
+  }
+  if (mEvaluatingWorker && mEvaluatingWorker->ID() == aID) {
+    return mEvaluatingWorker;
+  }
+  return nullptr;
+}
+
 void
 ServiceWorkerRegistrationInfo::SetEvaluating(ServiceWorkerInfo* aServiceWorker)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aServiceWorker);
   MOZ_ASSERT(!mEvaluatingWorker);
   MOZ_ASSERT(!mInstallingWorker);
   MOZ_ASSERT(mWaitingWorker != aServiceWorker);
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.h b/dom/workers/ServiceWorkerRegistrationInfo.h
--- a/dom/workers/ServiceWorkerRegistrationInfo.h
+++ b/dom/workers/ServiceWorkerRegistrationInfo.h
@@ -129,16 +129,19 @@ public:
   GetInstalling() const;
 
   ServiceWorkerInfo*
   GetWaiting() const;
 
   ServiceWorkerInfo*
   GetActive() const;
 
+  ServiceWorkerInfo*
+  GetByID(uint64_t aID) const;
+
   // Set the given worker as the evaluating service worker.  The worker
   // state is not changed.
   void
   SetEvaluating(ServiceWorkerInfo* aServiceWorker);
 
   // Remove an existing evaluating worker, if present.  The worker will
   // be transitioned to the Redundant state.
   void
