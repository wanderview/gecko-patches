# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7fd01b8e290f36b3be37a1179d7fda028eaab2e9
Bug 1187722 Fix bad origins, error page handling, and spec issues in fetch-frame-resources.https.html. r=jgraham

diff --git a/testing/web-platform/mozilla/meta/service-workers/service-worker/__dir__.ini b/testing/web-platform/mozilla/meta/service-workers/service-worker/__dir__.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/mozilla/meta/service-workers/service-worker/__dir__.ini
@@ -0,0 +1,3 @@
+prefs: [dom.serviceWorkers.enabled: true,
+        dom.serviceWorkers.interception.enabled: true,
+        dom.serviceWorkers.interception.opaque.enabled: true]
diff --git a/testing/web-platform/mozilla/meta/service-workers/service-worker/fetch-frame-resource.https.html.ini b/testing/web-platform/mozilla/meta/service-workers/service-worker/fetch-frame-resource.https.html.ini
--- a/testing/web-platform/mozilla/meta/service-workers/service-worker/fetch-frame-resource.https.html.ini
+++ b/testing/web-platform/mozilla/meta/service-workers/service-worker/fetch-frame-resource.https.html.ini
@@ -1,26 +1,10 @@
 [fetch-frame-resource.https.html]
   type: testharness
-  expected: TIMEOUT
-  disabled:
-    if debug and (os == "linux"): https://bugzilla.mozilla.org/show_bug.cgi?id=1187722
 
-  [Basic type response could be loaded in the iframe.]
-    expected: TIMEOUT
-
-  [Basic type response could be loaded in the new window.]
-    expected: TIMEOUT
-
-  [CORS type response could not be loaded in the iframe.]
+  [CORS type response could be loaded in the iframe.]
+    bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1184967
     expected: FAIL
 
-  [Opaque type response could not be loaded in the iframe.]
+  [CORS type response could be loaded in the new window.]
+    bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1184967
     expected: FAIL
-
-  [CORS type response could not be loaded in the new window.]
-    bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1183162
-    expected: FAIL
-
-  [Opaque type response could not be loaded in the new window.]
-    bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1183162
-    expected: FAIL
-
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-frame-resource.https.html b/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-frame-resource.https.html
--- a/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-frame-resource.https.html
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-frame-resource.https.html
@@ -9,166 +9,206 @@
 var worker = 'resources/fetch-rewrite-worker.js';
 var path = base_path() + 'resources/fetch-access-control.py';
 var host_info = get_host_info();
 
 if (window.testRunner) {
   testRunner.setCanOpenWindows();
 }
 
+function getLoadedObject(win, contentFunc, closeFunc) {
+  return new Promise(function(resolve) {
+      function done(contentString) {
+        var result = null;
+        // fetch-access-control.py returns a string like "report( <json> )".
+        // Eval the returned string with a report functionto get the json
+        // object.
+        try {
+          function report(obj) { result = obj };
+          eval(contentString);
+        } catch(e) {
+          // just resolve null if we get unexpected page content
+        }
+        closeFunc(win);
+        resolve(result);
+      }
+
+      // We can't catch the network error on window. So we use the timer.
+      var timeout = setTimeout(function() {
+          // Failure pages are considered cross-origin in some browsers.  This
+          // means you cannot even .resolve() the window because the check for
+          // the .then property will throw.  Instead, treat cross-origin
+          // failure pages as the empty string which will fail to parse as the
+          // expected json result.
+          var content = '';
+          try {
+            content = contentFunc(win);
+          } catch(e) {
+            // use default empty string for cross-domain window
+          }
+          done(content);
+        }, 5000);
+
+      win.onload = function() {
+          clearTimeout(timeout);
+          var content = contentFunc(win);
+          done(content);
+        };
+    });
+}
+
+function getLoadedFrameAsObject(frame) {
+  return getLoadedObject(frame, function(f) {
+      return f.contentDocument.body.textContent;
+    }, function(f) {
+      f.parentNode.removeChild(f);
+    });
+}
+
+function getLoadedWindowAsObject(win) {
+  return getLoadedObject(win, function(w) {
+      return w.document.body.textContent
+    }, function(w) {
+      w.close();
+    });
+}
+
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/frame-basic';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
-          return with_iframe(
+          var frame = document.createElement('iframe');
+          frame.src =
             scope + '?url=' +
-            encodeURIComponent(host_info['HTTP_ORIGIN'] + path));
+            encodeURIComponent(host_info['HTTPS_ORIGIN'] + path);
+          document.body.appendChild(frame);
+          return getLoadedFrameAsObject(frame);
         })
-      .then(function(frame) {
-          assert_not_equals(
-            frame.contentDocument.body.textContent,
-            '',
+      .then(function(result) {
+          assert_equals(
+            result.jsonpResult,
+            'success',
             'Basic type response could be loaded in the iframe.');
-          frame.remove();
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
   }, 'Basic type response could be loaded in the iframe.');
 
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/frame-cors';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
           var frame = document.createElement('iframe');
           frame.src =
             scope + '?mode=cors&url=' +
-            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + path +
+            encodeURIComponent(host_info['HTTPS_REMOTE_ORIGIN'] + path +
                                '?ACAOrigin=' + host_info['HTTP_ORIGIN']);
           document.body.appendChild(frame);
-          // We can't catch the network error on iframe. So we use the timer.
-          return new Promise(function(resolve) {
-              setTimeout(function() { resolve(frame); }, 1000);
-            });
+          return getLoadedFrameAsObject(frame);
         })
-      .then(function(frame) {
+      .then(function(result) {
           assert_equals(
-            frame.contentDocument.body.textContent,
-            '',
-            'CORS type response could not be loaded in the iframe.');
-          frame.remove();
+            result.jsonpResult,
+            'success',
+            'CORS type response could be loaded in the iframe.');
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
-  }, 'CORS type response could not be loaded in the iframe.');
+  }, 'CORS type response could be loaded in the iframe.');
 
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/frame-opaque';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
           var frame = document.createElement('iframe');
           frame.src =
             scope + '?mode=no-cors&url=' +
-            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + path);
+            encodeURIComponent(host_info['HTTPS_REMOTE_ORIGIN'] + path);
           document.body.appendChild(frame);
-          // We can't catch the network error on iframe. So we use the timer.
-          return new Promise(function(resolve) {
-              setTimeout(function() { resolve(frame); }, 1000);
-            });
+          return getLoadedFrameAsObject(frame);
         })
-      .then(function(frame) {
+      .then(function(result) {
           assert_equals(
-            frame.contentDocument.body.textContent,
-            '',
+            result,
+            null,
             'Opaque type response could not be loaded in the iframe.');
-          frame.remove();
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
   }, 'Opaque type response could not be loaded in the iframe.');
 
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/window-basic';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
-          return new Promise(function(resolve) {
-              var win = window.open(
-                scope + '?url=' +
-                encodeURIComponent(host_info['HTTP_ORIGIN'] + path));
-              win.onload = function() { resolve(win); };
-            });
+          var win = window.open(
+            scope + '?url=' +
+            encodeURIComponent(host_info['HTTPS_ORIGIN'] + path));
+          return getLoadedWindowAsObject(win);
         })
-      .then(function(win) {
-          assert_not_equals(
-            win.document.body.textContent,
-            '',
+      .then(function(result) {
+          assert_equals(
+            result.jsonpResult,
+            'success',
             'Basic type response could be loaded in the new window.');
-          win.close();
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
   }, 'Basic type response could be loaded in the new window.');
 
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/window-cors';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
           var win = window.open(
             scope + '?mode=cors&url=' +
-            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + path +
+            encodeURIComponent(host_info['HTTPS_REMOTE_ORIGIN'] + path +
                                '?ACAOrigin=' + host_info['HTTP_ORIGIN']));
-          // We can't catch the network error on window. So we use the timer.
-          return new Promise(function(resolve) {
-              setTimeout(function() { resolve(win); }, 1000);
-            });
+          return getLoadedWindowAsObject(win);
         })
-      .then(function(win) {
+      .then(function(result) {
           assert_equals(
-            win.document.body.textContent,
-            '',
-            'CORS type response could not be loaded in the new window.');
-          win.close();
+            result.jsonpResult,
+            'success',
+            'CORS type response could be loaded in the new window.');
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
-  }, 'CORS type response could not be loaded in the new window.');
+  }, 'CORS type response could be loaded in the new window.');
 
 async_test(function(t) {
     var scope = 'resources/fetch-frame-resource/window-opaque';
     service_worker_unregister_and_register(t, worker, scope)
       .then(function(reg) {
           return wait_for_state(t, reg.installing, 'activated');
         })
       .then(function() {
           var win = window.open(
             scope + '?mode=no-cors&url=' +
-            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + path));
-          // We can't catch the network error on window. So we use the timer.
-          return new Promise(function(resolve) {
-              setTimeout(function() { resolve(win); }, 1000);
-            });
+            encodeURIComponent(host_info['HTTPS_REMOTE_ORIGIN'] + path));
+          return getLoadedWindowAsObject(win);
         })
-      .then(function(win) {
+      .then(function(result) {
           assert_equals(
-            win.document.body.textContent,
-            '',
+            result,
+            null,
             'Opaque type response could not be loaded in the new window.');
-          win.close();
           return service_worker_unregister_and_done(t, scope);
         })
       .catch(unreached_rejection(t));
   }, 'Opaque type response could not be loaded in the new window.');
 </script>
 </body>
