# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f521877e5c75f9d27bd5a8218ff83f0e9daab479
Bug 1363829 P12 Create a low precision mode and use it for scheduling TimeoutExecutor in background tabs. r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -17,16 +17,17 @@ TimeoutExecutor::~TimeoutExecutor()
   // and then call Shutdown() explicitly.
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Shutdown);
   MOZ_DIAGNOSTIC_ASSERT(!mOwner);
   MOZ_DIAGNOSTIC_ASSERT(!mTimer);
 }
 
 nsresult
 TimeoutExecutor::ScheduleImmediate(const TimeStamp& aDeadline,
+                                   TimeoutPrecision aPrecision,
                                    const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
@@ -35,16 +36,17 @@ TimeoutExecutor::ScheduleImmediate(const
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
+                                 TimeoutPrecision aPrecision,
                                  const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(aDeadline > aNow);
 
   nsresult rv = NS_OK;
 
@@ -56,53 +58,69 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Convert the precise delay to integral milliseconds for nsITimer.  We
-  // favor rounding down here.  If we fire early we will simply be rescheduled
-  // for an immediate runnable or a 0-ms timer.  This ends up giving us the
-  // most accurate firing time at the cost of a few more runnables.  This cost
-  // is only incurred when the browser is idle, though.  When the busy main
-  // thread is busy there will be a delay and we won't actually be early.
-  // TODO: In the future we could pass a precision argument in and round
-  //       up here for low-precision background timers.  We don't really care
-  //       if those timers fire late.
-  TimeDuration delay(aDeadline - aNow - TimeDuration::FromMilliseconds(0.1));
+  // Convert the precise delay to integral milliseconds for nsITimer.  This
+  // will require some kind of rounding.  We adjust our heurestic based on
+  // whether the window is firing high or low precision timeouts at the moment.
+  TimeDuration delay;
+
+  // For high precision timeouts we favor rounding down here.  This will
+  // cause us to fire our timer slightly early in some cases.  If this
+  // happens we will get rescheduled by TimeoutManager so we can reschedule
+  // a 0-ms nsITimer.  This may occur a few times if the browser is idle,
+  // but if the browser is busy then the delays will prevent this case from
+  // occuring.
+  if (aPrecision == TimeoutPrecision::High) {
+    delay = aDeadline - aNow - TimeDuration::FromMilliseconds(0.1);
+  }
+
+  // For low precision timers we favor rounding up.  This will minimize the
+  // chance of firing additional runnables as we do in high precision mode.
+  // The cost, of course, is that we are much more likely to fire the timeout
+  // a few milliseconds late.
+  else {
+    delay = aDeadline - aNow + TimeDuration::FromMilliseconds(0.9);
+  }
+
+  // Finally, this truncates the float delay to integral milliseconds.
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
-TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
+TimeoutExecutor::Schedule(const TimeStamp& aDeadline,
+                          TimeoutPrecision aPrecision)
 {
   TimeStamp now(TimeStamp::Now());
 
   // Schedule an immediate runnable if the desired deadline has passed
   // or is slightly in the future.  This is similar to how nsITimer will
   // fire timers early based on the interval resolution.
   if (aDeadline <= now) {
-    return ScheduleImmediate(aDeadline, now);
+    return ScheduleImmediate(aDeadline, aPrecision, now);
   }
 
-  return ScheduleDelayed(aDeadline, now);
+  return ScheduleDelayed(aDeadline, aPrecision, now);
 }
 
 nsresult
-TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline,
+                                 TimeoutPrecision aPrecision)
 {
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Immediate ||
                         mMode == Mode::Delayed);
 
   if (aDeadline >= mDeadline) {
     return NS_OK;
   }
@@ -110,17 +128,17 @@ TimeoutExecutor::MaybeReschedule(const T
   if (mMode == Mode::Immediate) {
     // Don't reduce the deadline here as we want to execute the
     // timer we originally scheduled even if its a few microseconds
     // in the future.
     return NS_OK;
   }
 
   Cancel();
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aPrecision);
 }
 
 void
 TimeoutExecutor::MaybeExecute()
 {
   MOZ_DIAGNOSTIC_ASSERT(mMode != Mode::Shutdown && mMode != Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(mOwner);
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
@@ -158,29 +176,30 @@ TimeoutExecutor::Shutdown()
     mTimer = nullptr;
   }
 
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
-TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline,
+                               TimeoutPrecision aPrecision)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
 
   if (mMode == Mode::Shutdown) {
     return NS_OK;
   }
 
   if (mMode == Mode::Immediate || mMode == Mode::Delayed) {
-    return MaybeReschedule(aDeadline);
+    return MaybeReschedule(aDeadline, aPrecision);
   }
 
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aPrecision);
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
--- a/dom/base/TimeoutExecutor.h
+++ b/dom/base/TimeoutExecutor.h
@@ -9,16 +9,30 @@
 
 #include "nsIRunnable.h"
 #include "nsITimer.h"
 #include "nsINamed.h"
 
 namespace mozilla {
 namespace dom {
 
+// The executor can run in either low or high precision.
+enum class TimeoutPrecision : uint8_t {
+  //  Low: When scheduling a delayed Timeout favor rounding up to the next
+  //       millisecond.  We will fire late more frequently, but with fewer
+  //       overall runnables.
+  Low,
+
+  //  High: When scheduling a delayed Timeout favor rounding down to the
+  //        nearest millisecond.  This will cause us to possibly check the
+  //        deadline a bit early and schedule another 0-ms timer to recheck.
+  //        This costs a few extra runnables, but gives us the best precision.
+  High
+};
+
 class TimeoutExecutor final : public nsIRunnable
                             , public nsITimerCallback
                             , public nsINamed
 {
   TimeoutManager* mOwner;
   nsCOMPtr<nsITimer> mTimer;
   TimeStamp mDeadline;
 
@@ -42,38 +56,40 @@ class TimeoutExecutor final : public nsI
     Shutdown
   };
 
   Mode mMode;
 
   ~TimeoutExecutor();
 
   nsresult
-  ScheduleImmediate(const TimeStamp& aDeadline, const TimeStamp& aNow);
+  ScheduleImmediate(const TimeStamp& aDeadline, TimeoutPrecision aPrecision,
+                    const TimeStamp& aNow);
 
   nsresult
-  ScheduleDelayed(const TimeStamp& aDeadline, const TimeStamp& aNow);
+  ScheduleDelayed(const TimeStamp& aDeadline, TimeoutPrecision aPrecision,
+                  const TimeStamp& aNow);
 
   nsresult
-  Schedule(const TimeStamp& aDeadline);
+  Schedule(const TimeStamp& aDeadline, TimeoutPrecision aPrecision);
 
   nsresult
-  MaybeReschedule(const TimeStamp& aDeadline);
+  MaybeReschedule(const TimeStamp& aDeadline, TimeoutPrecision aPrecision);
 
   void
   MaybeExecute();
 
 public:
   explicit TimeoutExecutor(TimeoutManager* aOwner);
 
   void
   Shutdown();
 
   nsresult
-  MaybeSchedule(const TimeStamp& aDeadline);
+  MaybeSchedule(const TimeStamp& aDeadline, TimeoutPrecision aPrecision);
 
   void
   Cancel();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSINAMED
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -202,16 +202,25 @@ TimeoutManager::IsInvalidFiringId(uint32
   // Finally, fall back to verifying the firing id is not anywhere
   // in the stack.  This could be slow for a large stack, but that
   // should be rare.  It can only happen with deeply nested event
   // loop spinning.  For example, a page that does a lot of timers
   // and a lot of sync XHRs within those timers could be slow here.
   return !mFiringIdStack.Contains(aFiringId);
 }
 
+TimeoutPrecision
+TimeoutManager::GetPrecision() const
+{
+  if (IsBackground()) {
+    return TimeoutPrecision::Low;
+  }
+  return TimeoutPrecision::High;
+}
+
 int32_t
 TimeoutManager::DOMMinTimeoutValue(bool aIsTracking) const {
   // Don't use the background timeout value when the tab is playing audio.
   // Until bug 1336484 we only used to do this for pages that use Web Audio.
   // The original behavior was implemented in bug 11811073.
   bool isBackground = IsBackground();
   bool throttleTracking = aIsTracking && mThrottleTrackingTimeouts;
   auto minValue = throttleTracking ? (isBackground ? gMinTrackingBackgroundTimeoutValue
@@ -410,17 +419,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
   timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     MOZ_ASSERT(!timeout->When().IsNull());
 
-    nsresult rv = mExecutor->MaybeSchedule(timeout->When());
+    nsresult rv = mExecutor->MaybeSchedule(timeout->When(), GetPrecision());
     if (NS_FAILED(rv)) {
       return rv;
     }
   }
 
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
@@ -515,17 +524,18 @@ TimeoutManager::ClearTimeout(int32_t aTi
   mExecutor->Cancel();
 
   OrderedTimeoutIterator iter(mNormalTimeouts,
                               mTrackingTimeouts,
                               nullptr,
                               nullptr);
   Timeout* nextTimeout = iter.Next();
   if (nextTimeout) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextTimeout->When()));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextTimeout->When(),
+                                                 GetPrecision()));
   }
 }
 
 void
 TimeoutManager::RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aNow.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(!aTargetDeadline.IsNull());
@@ -646,17 +656,17 @@ TimeoutManager::RunTimeout(const TimeSta
   now = TimeStamp::Now();
 
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.  Note, this *must* be done
   // before we start executing any content script handlers.  If one
   // of them spins the event loop the executor must already be scheduled
   // in order for timeouts to fire properly.
   if (!nextDeadline.IsNull()) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline, GetPrecision()));
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_normal_timeout && !last_expired_tracking_timeout) {
     return;
   }
@@ -801,17 +811,18 @@ TimeoutManager::RunTimeout(const TimeSta
       // Check to see if we have run out of time to execute timeout handlers.
       // If we've exceeded our time budget then terminate the loop immediately.
       TimeDuration elapsed = now - start;
       if (elapsed >= totalTimeLimit) {
         // We ran out of time.  Make sure to schedule the executor to
         // run immediately for the next timer, if it exists.
         RefPtr<Timeout> timeout = runIter.Next();
         if (timeout) {
-          MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(timeout->When()));
+          MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(timeout->When(),
+                                                       GetPrecision()));
         }
         break;
       }
     }
   }
 
   // Take the dummy timeout off the head of the list
   if (dummy_normal_timeout->isInList()) {
@@ -852,17 +863,17 @@ TimeoutManager::RescheduleTimeout(Timeou
   }
 
   aTimeout->SetWhenOrTimeRemaining(currentNow, delay);
 
   if (mWindow.IsSuspended()) {
     return true;
   }
 
-  nsresult rv = mExecutor->MaybeSchedule(aTimeout->When());
+  nsresult rv = mExecutor->MaybeSchedule(aTimeout->When(), GetPrecision());
   NS_ENSURE_SUCCESS(rv, false);
 
   return true;
 }
 
 nsresult
 TimeoutManager::ResetTimersForThrottleReduction()
 {
@@ -891,17 +902,17 @@ TimeoutManager::ResetTimersForThrottleRe
   NS_ENSURE_SUCCESS(rv, rv);
 
   OrderedTimeoutIterator iter(mNormalTimeouts,
                               mTrackingTimeouts,
                               nullptr,
                               nullptr);
   Timeout* firstTimeout = iter.Next();
   if (firstTimeout) {
-    rv = mExecutor->MaybeSchedule(firstTimeout->When());
+    rv = mExecutor->MaybeSchedule(firstTimeout->When(), GetPrecision());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 TimeoutManager::Timeouts::ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
@@ -1169,17 +1180,17 @@ TimeoutManager::Resume()
     aTimeout->SetWhenOrTimeRemaining(now, TimeDuration::FromMilliseconds(delay));
 
     if (nextWakeUp.IsNull() || aTimeout->When() < nextWakeUp) {
       nextWakeUp = aTimeout->When();
     }
   });
 
   if (!nextWakeUp.IsNull()) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextWakeUp));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextWakeUp, GetPrecision()));
   }
 }
 
 void
 TimeoutManager::Freeze()
 {
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Freeze(TimeoutManager=%p)\n", this));
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -13,16 +13,17 @@
 class nsIEventTarget;
 class nsITimeoutHandler;
 class nsGlobalWindow;
 
 namespace mozilla {
 namespace dom {
 
 class OrderedTimeoutIterator;
+enum class TimeoutPrecision : uint8_t;
 class TimeoutExecutor;
 
 // This class manages the timeouts in a Window's setTimeout/setInterval pool.
 class TimeoutManager final
 {
 public:
   explicit TimeoutManager(nsGlobalWindow& aWindow);
   ~TimeoutManager();
@@ -125,16 +126,19 @@ private:
   CreateFiringId();
 
   void
   DestroyFiringId(uint32_t aFiringId);
 
   bool
   IsInvalidFiringId(uint32_t aFiringId) const;
 
+  TimeoutPrecision
+  GetPrecision() const;
+
 private:
   struct Timeouts {
     Timeouts()
       : mTimeoutInsertionPoint(nullptr)
     {
     }
 
     // Insert aTimeout into the list, before all timeouts that would
