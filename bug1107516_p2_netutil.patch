# HG changeset patch
# Parent 1527fbea7605eda898c167f0a77a509bf254503d
# User Ben Kelly <ben@wanderview.com>
Bug 1107516 P2 Add nsILoadGroup helpers to nsNetUtil.h. r=mcmanus
* * *
Update NS_LoadGroupMatchPrincipal() to always allow null principal.

diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -927,16 +927,30 @@ NS_NewLoadGroup(nsILoadGroup      **resu
         if (NS_SUCCEEDED(rv)) {
             *result = nullptr;
             group.swap(*result);
         }
     }
     return rv;
 }
 
+// Create a new nsILoadGroup that will match the given principal.
+nsresult
+NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal);
+
+// Determine if the given loadGroup/principal pair will produce a principal
+// with similar permissions when passed to NS_NewChannel().  This checks for
+// things like making sure the appId and browser element flags match.  Without
+// an appropriate load group these values can be lost when getting the result
+// principal back out of the channel.  Null principals are also always allowed
+// as they do not have permissions to actually use the load group.
+bool
+NS_LoadGroupMatchesPrincipal(nsILoadGroup* aLoadGroup,
+                             nsIPrincipal* aPrincipal);
+
 inline nsresult
 NS_NewDownloader(nsIStreamListener   **result,
                  nsIDownloadObserver  *observer,
                  nsIFile              *downloadLocation = nullptr)
 {
     nsresult rv;
     nsCOMPtr<nsIDownloader> downloader =
         do_CreateInstance(NS_DOWNLOADER_CONTRACTID, &rv);
diff --git a/netwerk/base/src/nsNetUtil.cpp b/netwerk/base/src/nsNetUtil.cpp
--- a/netwerk/base/src/nsNetUtil.cpp
+++ b/netwerk/base/src/nsNetUtil.cpp
@@ -1,18 +1,83 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* vim:set ts=4 sw=4 sts=4 et cin: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "mozilla/LoadContext.h"
 #include "nsNetUtil.h"
 #include "nsHttp.h"
 
 bool NS_IsReasonableHTTPHeaderValue(const nsACString& aValue)
 {
   return mozilla::net::nsHttp::IsReasonableHeaderValue(aValue);
 }
 
 bool NS_IsValidHTTPToken(const nsACString& aToken)
 {
   return mozilla::net::nsHttp::IsValidToken(aToken);
 }
+
+nsresult
+NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal)
+{
+    using mozilla::LoadContext;
+    nsresult rv;
+
+    nsCOMPtr<nsILoadGroup> group =
+        do_CreateInstance(NS_LOADGROUP_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsRefPtr<LoadContext> loadContext = new LoadContext(aPrincipal);
+    rv = group->SetNotificationCallbacks(loadContext);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    group.forget(aResult);
+    return rv;
+}
+
+bool
+NS_LoadGroupMatchesPrincipal(nsILoadGroup* aLoadGroup,
+                             nsIPrincipal* aPrincipal)
+{
+    if (!aPrincipal) {
+      return false;
+    }
+
+    // If this is a null principal then the load group doesn't really matter.
+    // The principal will not be allowed to perform any actions that actually
+    // use the load group.  Unconditionally treat null principals as a match.
+    bool isNullPrincipal;
+    nsresult rv = aPrincipal->GetIsNullPrincipal(&isNullPrincipal);
+    NS_ENSURE_SUCCESS(rv, false);
+    if (isNullPrincipal) {
+      return true;
+    }
+
+    if (!aLoadGroup) {
+        return false;
+    }
+
+    nsCOMPtr<nsILoadContext> loadContext;
+    NS_QueryNotificationCallbacks(nullptr, aLoadGroup, NS_GET_IID(nsILoadContext),
+                                  getter_AddRefs(loadContext));
+    NS_ENSURE_TRUE(loadContext, false);
+
+    // Verify load context appId and browser flag match the principal
+    uint32_t contextAppId;
+    bool contextInBrowserElement;
+    rv = loadContext->GetAppId(&contextAppId);
+    NS_ENSURE_SUCCESS(rv, false);
+    rv = loadContext->GetIsInBrowserElement(&contextInBrowserElement);
+    NS_ENSURE_SUCCESS(rv, false);
+
+    uint32_t principalAppId;
+    bool principalInBrowserElement;
+    rv = aPrincipal->GetAppId(&principalAppId);
+    NS_ENSURE_SUCCESS(rv, false);
+    rv = aPrincipal->GetIsInBrowserElement(&principalInBrowserElement);
+    NS_ENSURE_SUCCESS(rv, false);
+
+    return contextAppId == principalAppId &&
+           contextInBrowserElement == principalInBrowserElement;
+}
