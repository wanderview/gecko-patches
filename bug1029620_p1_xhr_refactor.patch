# HG changeset patch
# Parent 7f7a0a8948773d47ae4d6e094948271636cfa1e2
# User Ben Kelly <ben@wanderview.com>
Bug 1029620 P1 Refactor XHR to move forbidden header checks to nsContentUtils.


diff --git a/content/base/public/nsContentUtils.h b/content/base/public/nsContentUtils.h
--- a/content/base/public/nsContentUtils.h
+++ b/content/base/public/nsContentUtils.h
@@ -2146,16 +2146,34 @@ public:
    * this corresponds to a <content> element that participates
    * in node distribution. In XBL this corresponds to an
    * <xbl:children> element in anonymous content.
    *
    * @param aContent The content to test for being an insertion point.
    */
   static bool IsContentInsertionPoint(const nsIContent* aContent);
 
+  /**
+   * Returns whether a given header is forbidden for an XHR or fetch
+   * request.
+   */
+  static bool IsForbiddenRequestHeader(const nsACString& aHeader);
+
+  /**
+   * Returns whether a given header is forbidden for a system XHR
+   * request.
+   */
+  static bool IsForbiddenSystemRequestHeader(const nsACString& aHeader);
+
+  /**
+   * Returns whether a given header is forbidden for an XHR or fetch
+   * response.
+   */
+  static bool IsForbiddenResponseHeader(const nsACString& aHeader);
+
 private:
   static bool InitializeEventTable();
 
   static nsresult EnsureStringBundle(PropertiesFile aFile);
 
   static bool CanCallerAccess(nsIPrincipal* aSubjectPrincipal,
                                 nsIPrincipal* aPrincipal);
 
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -6737,16 +6737,57 @@ nsContentUtils::IsContentInsertionPoint(
   // Check if the content is a web components content insertion point.
   if (aContent->IsHTML(nsGkAtoms::content)) {
     return static_cast<const HTMLContentElement*>(aContent)->IsInsertionPoint();
   }
 
   return false;
 }
 
+// static
+bool
+nsContentUtils::IsForbiddenRequestHeader(const nsACString& aHeader)
+{
+  if (IsForbiddenSystemRequestHeader(aHeader)) {
+    return true;
+  }
+
+  return StringBeginsWith(aHeader, NS_LITERAL_CSTRING("proxy-"),
+                          nsCaseInsensitiveCStringComparator()) ||
+         StringBeginsWith(aHeader, NS_LITERAL_CSTRING("sec-"),
+                          nsCaseInsensitiveCStringComparator());
+}
+
+// static
+bool
+nsContentUtils::IsForbiddenSystemRequestHeader(const nsACString& aHeader)
+{
+  static const char *kInvalidHeaders[] = {
+    "accept-charset", "accept-encoding", "access-control-request-headers",
+    "access-control-request-method", "connection", "content-length",
+    "cookie", "cookie2", "content-transfer-encoding", "date", "dnt",
+    "expect", "host", "keep-alive", "origin", "referer", "te", "trailer",
+    "transfer-encoding", "upgrade", "user-agent", "via"
+  };
+  for (uint32_t i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
+    if (aHeader.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// static
+bool
+nsContentUtils::IsForbiddenResponseHeader(const nsACString& aHeader)
+{
+  return (aHeader.LowerCaseEqualsASCII("set-cookie") ||
+          aHeader.LowerCaseEqualsASCII("set-cookie2"));
+}
+
 bool
 nsContentUtils::DOMWindowDumpEnabled()
 {
 #if !(defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
   // In optimized builds we check a pref that controls if we should
   // enable output from dump() or not, in debug builds it's always
   // enabled.
   return nsContentUtils::sDOMWindowDumpEnabled;
diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -1237,19 +1237,17 @@ nsXMLHttpRequest::SlowAbort()
 }
 
 /*Method that checks if it is safe to expose a header value to the client.
 It is used to check what headers are exposed for CORS requests.*/
 bool
 nsXMLHttpRequest::IsSafeHeader(const nsACString& header, nsIHttpChannel* httpChannel)
 {
   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
-  if (!IsSystemXHR() &&
-       (header.LowerCaseEqualsASCII("set-cookie") ||
-        header.LowerCaseEqualsASCII("set-cookie2"))) {
+  if (!IsSystemXHR() && nsContentUtils::IsForbiddenResponseHeader(header)) {
     NS_WARNING("blocked access to response header");
     return false;
   }
   // if this is not a CORS call all headers are safe
   if (!(mState & XML_HTTP_REQUEST_USE_XSITE_AC)){
     return true;
   }
   // Check for dangerous headers
@@ -3102,72 +3100,49 @@ nsXMLHttpRequest::SetRequestHeader(const
 
   // We will merge XHR headers, per the spec (secion 4.6.2) unless:
   // 1 - The caller is privileged and setting an invalid header,
   // or
   // 2 - we have not yet explicitly set that header; this allows web
   //     content to override default headers the first time they set them.
   bool mergeHeaders = true;
 
-  // Prevent modification to certain HTTP headers (see bug 302263), unless
-  // the executing script is privileged.
-  bool isInvalidHeader = false;
-  static const char *kInvalidHeaders[] = {
-    "accept-charset", "accept-encoding", "access-control-request-headers",
-    "access-control-request-method", "connection", "content-length",
-    "cookie", "cookie2", "content-transfer-encoding", "date", "dnt",
-    "expect", "host", "keep-alive", "origin", "referer", "te", "trailer",
-    "transfer-encoding", "upgrade", "user-agent", "via"
-  };
-  uint32_t i;
-  for (i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
-    if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
-      isInvalidHeader = true;
-      break;
-    }
-  }
-
   if (!IsSystemXHR()) {
     // Step 5: Check for dangerous headers.
-    if (isInvalidHeader) {
-      NS_WARNING("refusing to set request header");
-      return NS_OK;
-    }
-    if (StringBeginsWith(header, NS_LITERAL_CSTRING("proxy-"),
-                         nsCaseInsensitiveCStringComparator()) ||
-        StringBeginsWith(header, NS_LITERAL_CSTRING("sec-"),
-                         nsCaseInsensitiveCStringComparator())) {
+    // Prevent modification to certain HTTP headers (see bug 302263), unless
+    // the executing script is privileged.
+    if (nsContentUtils::IsForbiddenRequestHeader(header)) {
       NS_WARNING("refusing to set request header");
       return NS_OK;
     }
 
     // Check for dangerous cross-site headers
     bool safeHeader = IsSystemXHR();
     if (!safeHeader) {
       // Content-Type isn't always safe, but we'll deal with it in Send()
       const char *kCrossOriginSafeHeaders[] = {
         "accept", "accept-language", "content-language", "content-type",
         "last-event-id"
       };
-      for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
+      for (uint32_t i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
         if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
           safeHeader = true;
           break;
         }
       }
     }
 
     if (!safeHeader) {
       if (!mCORSUnsafeHeaders.Contains(header)) {
         mCORSUnsafeHeaders.AppendElement(header);
       }
     }
   } else {
     // Case 1 above
-    if (isInvalidHeader) {
+    if (nsContentUtils::IsForbiddenSystemRequestHeader(header)) {
       mergeHeaders = false;
     }
   }
 
   if (!mAlreadySetHeaders.Contains(header)) {
     // Case 2 above
     mergeHeaders = false;
   }
