# HG changeset patch
# Parent 038bb4824f89b6a98c2a44a694adaedaa0cc2ab2
# User Ben Kelly <ben@wanderview.com>
Fix compilation for nsFancyPipe.

diff --git a/ipc/glue/CrossProcessPipe.cpp b/ipc/glue/CrossProcessPipe.cpp
--- a/ipc/glue/CrossProcessPipe.cpp
+++ b/ipc/glue/CrossProcessPipe.cpp
@@ -36,17 +36,17 @@ namespace {
 
 class CrossProcessPipe : public nsICrossProcessPipe
 {
   typedef mozilla::ipc::PipeDirection PipeDirection;
 
   nsCOMPtr<nsIAsyncInputStream> mInputStream;
   nsCOMPtr<nsIAsyncOutputStream> mOutputStream;
 
-  ~CrossProcessPipe() {}
+  virtual ~CrossProcessPipe() {}
 
 public:
   CrossProcessPipe() {}
 
   void
   InitializeStreams(PipeDirection aDirection);
 
   NS_DECL_THREADSAFE_ISUPPORTS
@@ -57,16 +57,18 @@ public:
 // stream.  All this knows how to do is serialize.  There's no reason this can't
 // be an output stream too, but we don't have any code that serializes output
 // streams today.
 class SerializationPlaceholderStream : public nsIAsyncInputStream,
                                        public nsIIPCSerializableInputStream
 {
   nsRefPtr<CrossProcessPipe> mCrossProcessPipe;
 
+  virtual ~SerializationPlaceholderStream() { }
+
 public:
   SerializationPlaceholderStream(CrossProcessPipe* aCrossProcessPipe)
     : mCrossProcessPipe(aCrossProcessPipe)
   {
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
@@ -501,16 +503,20 @@ XPPActiveStream::CloseWithStatus(nsresul
     Flush();
 
     {
       mozilla::MutexAutoLock lock(mLock);
       mClosed = true;
       mResultCode = aRv;
     }
 
+    if (!mTransportThread) {
+      return NS_OK;
+    }
+
     if (IsOnTransportThread()) {
       CloseTransport(aRv);
     }
     else {
       nsCOMPtr<nsIRunnable> event =
         NS_NewRunnableMethodWithArg<nsresult>(this, &XPPActiveStream::CloseTransport, aRv);
       mTransportThread->Dispatch(event, 0);
     }
@@ -576,16 +582,18 @@ XPPActiveStream::Read(char* aBuf, uint32
 }
 
 NS_IMETHODIMP
 XPPActiveStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
                               uint32_t aCount, uint32_t* aBytesRead)
 {
   MOZ_ASSERT(IsReceiving());
 
+  *aBytesRead = 0;
+
   {
     mozilla::MutexAutoLock lock(mLock);
 
     auto countToCopy = std::min<uint32_t>(aCount, mData.Length());
     while (countToCopy) {
       uint32_t countCopied = 0;
       nsresult rv = aWriter(this, aClosure, (char*)mData.Elements(), *aBytesRead,
                             countToCopy, &countCopied);
diff --git a/ipc/testshell/TestShellTest.cpp b/ipc/testshell/TestShellTest.cpp
--- a/ipc/testshell/TestShellTest.cpp
+++ b/ipc/testshell/TestShellTest.cpp
@@ -26,16 +26,17 @@ public:
 
   Derived*
   AsDerived() const
   {
     return static_cast<Derived*>(const_cast<TestShellTest*>(this));
   }
 
 protected:
+  virtual ~TestShellTest() { }
   bool RecvInputStream(const InputStreamParams& aParams,
 		       const OptionalFileDescriptorSet& aFds);
 };
 
 template <class Derived>
 NS_IMPL_ADDREF(TestShellTest<Derived>)
 
 template <class Derived>
@@ -130,16 +131,19 @@ public:
   virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
   { }
 
   virtual bool RecvInputStream(const InputStreamParams& aParams,
 			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
   {
     return Base::RecvInputStream(aParams, aFds);
   }
+
+protected:
+  virtual ~TestShellTestParent() { }
 };
 
 class TestShellTestChild : public TestShellTest<TestShellTestChild>,
 			   public PTestShellTestChild
 {
 public:
   typedef TestShellTest<TestShellTestChild> Base;
   typedef PTestShellTestChild Protocol;
@@ -147,16 +151,19 @@ public:
   virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
   { }
 
   virtual bool RecvInputStream(const InputStreamParams& aParams,
 			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
   {
     return Base::RecvInputStream(aParams, aFds);
   }
+
+protected:
+  virtual ~TestShellTestChild() { }
 };
 
 template class TestShellTest<TestShellTestParent>;
 template class TestShellTest<TestShellTestChild>;
 
 PTestShellTestParent*
 TestShellParent::AllocPTestShellTestParent()
 {
