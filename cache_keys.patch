# HG changeset patch
# Parent f9e20af444e08d4d3963c051f3e3b046dc528859
# User Ben Kelly <ben@wanderview.com>
Implement Cache::Keys().

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -445,24 +445,22 @@ Cache::RecvKeysResponse(RequestId aReque
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Request>> requests;
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
-    MOZ_CRASH("not implemented - can't construct new Request()");
-    //nsRefPtr<Request> request = new Request(mOwner);
-    nsRefPtr<Request> request = nullptr;
-    if (!request) {
-      promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
-    TypeUtils::ToRequest(*request, aRequests[i]);
+    nsRefPtr<InternalRequest> internalRequest = new InternalRequest(mGlobal);
+    TypeUtils::ToInternalRequest(*internalRequest, aRequests[i]);
+    // TODO: Should mOwner and mGlobal be just one field? Right now mOwner can
+    //       be null (when on a worker), but mGlobal is always provided.
+    nsCOMPtr<nsIGlobalObject> owner = do_QueryInterface(mOwner);
+    nsRefPtr<Request> request = new Request(owner, internalRequest);
     requests.AppendElement(request);
   }
   promise->MaybeResolve(requests);
 }
 
 
 Cache::~Cache()
 {
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -115,17 +115,19 @@ CacheParent::RecvDelete(const RequestId&
   return true;
 }
 
 bool
 CacheParent::RecvKeys(const RequestId& aRequestId,
                       const PCacheRequestOrVoid& aRequest,
                       const PCacheQueryParams& aParams)
 {
-  return false;
+  MOZ_ASSERT(mManager);
+  mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
+  return true;
 }
 
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse)
 {
   PCacheResponseOrVoid responseOrVoid;
 
@@ -202,11 +204,33 @@ CacheParent::OnCachePut(RequestId aReque
 }
 
 void
 CacheParent::OnCacheDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
 }
 
+void
+CacheParent::OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                         const nsTArray<SavedRequest>& aSavedRequests)
+{
+  nsTArray<PCacheRequest> requests;
+  nsTArray<nsCOMPtr<nsIOutputStream>> requestStreams;
+  for (uint32_t i = 0; i < aSavedRequests.Length(); ++i) {
+    requests.AppendElement(aSavedRequests[i].mValue);
+
+    if (!aSavedRequests[i].mHasBodyId) {
+      requestStreams.AppendElement();
+    } else {
+      // TODO: remove stream test code
+      requestStreams.AppendElement(MemoryOutputStream::Create(4096));
+      mManager->CacheReadBody(mCacheId, aSavedRequests[i].mBodyId,
+                              requestStreams[i]);
+    }
+  }
+
+  unused << SendKeysResponse(aRequestId, aRv, requests);
+}
+
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -58,16 +58,18 @@ public:
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                    const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
+  virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                     const nsTArray<SavedRequest>& aSavedRequests) MOZ_OVERRIDE;
 
 private:
   const CacheId mCacheId;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -2,19 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBSchema.h"
 
 #include "ipc/IPCMessageUtils.h"
-#include "mozilla/dom/cache/PCacheQueryParams.h"
-#include "mozilla/dom/cache/PCacheRequest.h"
-#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
@@ -62,23 +60,26 @@ DBSchema::CreateSchema(mozIStorageConnec
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE entries ("
         "id INTEGER NOT NULL PRIMARY KEY, "
         "request_method TEXT NOT NULL, "
         "request_url TEXT NOT NULL, "
         "request_url_no_query TEXT NOT NULL, "
+        "request_referrer TEXT NOT NULL, "
+        "request_headers_guard INTEGER NOT NULL, "
         "request_mode INTEGER NOT NULL, "
         "request_credentials INTEGER NOT NULL, "
         "request_body_id TEXT NULL, "
         "response_type INTEGER NOT NULL, "
         "response_url TEXT NOT NULL, "
         "response_status INTEGER NOT NULL, "
         "response_status_text TEXT NOT NULL, "
+        "response_headers_guard INTEGER NOT NULL, "
         "response_body_id TEXT NOT NULL, "
         "cache_id INTEGER NOT NULL REFERENCES caches(id) ON DELETE CASCADE"
       ");"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE INDEX entries_request_url_index "
@@ -342,16 +343,46 @@ DBSchema::CacheDelete(mozIStorageConnect
 
   *aSuccessOut = true;
 
   return rv;
 }
 
 // static
 nsresult
+DBSchema::CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
+                    const PCacheRequestOrVoid& aRequestOrVoid,
+                    const PCacheQueryParams& aParams,
+                    nsTArray<SavedRequest>& aSavedRequestsOut)
+{
+  MOZ_ASSERT(aConn);
+  nsresult rv;
+
+  nsTArray<EntryId> matches;
+  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+    rv = QueryAll(aConn, aCacheId, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // TODO: replace this with a bulk load using SQL IN clause
+  for (uint32_t i = 0; i < matches.Length(); ++i) {
+    SavedRequest *savedRequest = aSavedRequestsOut.AppendElement();
+    rv = ReadRequest(aConn, matches[i], savedRequest);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    savedRequest->mCacheId = aCacheId;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
 DBSchema::StorageMatch(mozIStorageConnection* aConn,
                        Namespace aNamespace,
                        const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams,
                        bool* aFoundResponseOut,
                        SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(aConn);
@@ -830,64 +861,78 @@ DBSchema::InsertEntry(mozIStorageConnect
   MOZ_ASSERT(aSavedResponseOut);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO entries ("
       "request_method, "
       "request_url, "
       "request_url_no_query, "
+      "request_referrer, "
+      "request_headers_guard, "
       "request_mode, "
       "request_credentials, "
       "request_body_id, "
       "response_type, "
       "response_url, "
       "response_status, "
       "response_status_text, "
+      "response_headers_guard, "
       "response_body_id, "
       "cache_id "
-    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12)"
+    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringParameter(0, aRequest.method());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindStringParameter(1, aRequest.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindStringParameter(2, aRequest.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(3, static_cast<int32_t>(aRequest.mode()));
+  rv = state->BindStringParameter(3, aRequest.referrer());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(4,
+    static_cast<int32_t>(aRequest.headersGuard()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(5, static_cast<int32_t>(aRequest.mode()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(6,
     static_cast<int32_t>(aRequest.credentials()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = BindId(state, 5, aRequestBodyId);
+  rv = BindId(state, 7, aRequestBodyId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(6, static_cast<int32_t>(aResponse.type()));
+  rv = state->BindInt32Parameter(8, static_cast<int32_t>(aResponse.type()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringParameter(7, aResponse.url());
+  rv = state->BindStringParameter(9, aResponse.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(8, aResponse.status());
+  rv = state->BindInt32Parameter(10, aResponse.status());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindUTF8StringParameter(9, aResponse.statusText());
+  rv = state->BindUTF8StringParameter(11, aResponse.statusText());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = BindId(state, 10, aResponseBodyId);
+  rv = state->BindInt32Parameter(12,
+    static_cast<int32_t>(aResponse.headersGuard()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(11, aCacheId);
+  rv = BindId(state, 13, aResponseBodyId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(14, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT last_insert_rowid()"
   ), getter_AddRefs(state));
@@ -967,16 +1012,17 @@ DBSchema::ReadResponse(mozIStorageConnec
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "response_type, "
       "response_url, "
       "response_status, "
       "response_status_text, "
+      "response_headers_guard, "
       "response_body_id "
     "FROM entries "
     "WHERE id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -996,23 +1042,29 @@ DBSchema::ReadResponse(mozIStorageConnec
   aSavedResponseOut->mValue.status() = status;
 
   rv = state->GetUTF8String(2, aSavedResponseOut->mValue.statusText());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->GetString(3, aSavedResponseOut->mValue.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  int32_t guard;
+  rv = state->GetInt32(4, &guard);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mValue.headersGuard() =
+    static_cast<HeadersGuardEnum>(guard);
+
   bool nullBody;
-  rv = state->GetIsNull(4, &nullBody);
+  rv = state->GetIsNull(5, &nullBody);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedResponseOut->mHasBodyId = !nullBody;
 
   if (aSavedResponseOut->mHasBodyId) {
-    rv = ExtractId(state, 4, &aSavedResponseOut->mBodyId);
+    rv = ExtractId(state, 5, &aSavedResponseOut->mBodyId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "name, "
       "value "
     "FROM response_headers "
@@ -1032,16 +1084,111 @@ DBSchema::ReadResponse(mozIStorageConnec
     rv = state->GetUTF8String(1, header->value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   return rv;
 }
 
 // static
+nsresult
+DBSchema::ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
+                      SavedRequest* aSavedRequestOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aSavedRequestOut);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "request_method, "
+      "request_url, "
+      "request_url_no_query, "
+      "request_referrer, "
+      "request_headers_guard, "
+      "request_mode, "
+      "request_credentials, "
+      "request_body_id "
+    "FROM entries "
+    "WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetUTF8String(0, aSavedRequestOut->mValue.method());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(1, aSavedRequestOut->mValue.url());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(2, aSavedRequestOut->mValue.urlWithoutQuery());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(3, aSavedRequestOut->mValue.referrer());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t guard;
+  rv = state->GetInt32(4, &guard);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.headersGuard() =
+    static_cast<HeadersGuardEnum>(guard);
+
+  int32_t mode;
+  rv = state->GetInt32(5, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.mode() = static_cast<RequestMode>(mode);
+
+  int32_t credentials;
+  rv = state->GetInt32(6, &credentials);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mValue.credentials() =
+    static_cast<RequestCredentials>(credentials);
+
+  bool nullBody;
+  rv = state->GetIsNull(7, &nullBody);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedRequestOut->mHasBodyId = !nullBody;
+
+  if (aSavedRequestOut->mHasBodyId) {
+    rv = ExtractId(state, 7, &aSavedRequestOut->mBodyId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "name, "
+      "value "
+    "FROM request_headers "
+    "WHERE entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    PHeadersEntry* header = aSavedRequestOut->mValue.headers().AppendElement();
+
+    rv = state->GetUTF8String(0, header->name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetUTF8String(1, header->value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
 void
 DBSchema::AppendListParamsToQuery(nsACString& aQuery,
                                   const nsTArray<EntryId>& aEntryIdList,
                                   uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
   for (int32_t i = aPos; i < aLen; ++i) {
     if (i == 0) {
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -21,16 +21,17 @@ namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheResponseOrVoid;
+struct SavedRequest;
 struct SavedResponse;
 
 class DBSchema MOZ_FINAL
 {
 public:
   static nsresult CreateSchema(mozIStorageConnection* aConn);
 
   static nsresult CreateCache(mozIStorageConnection* aConn,
@@ -57,16 +58,20 @@ public:
                            const nsID* aResponseBodyId,
                            nsTArray<nsID>& aDeletedBodyIdListOut,
                            SavedResponse* aSavedResponseOut);
   static nsresult CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
                               const PCacheRequest& aRequest,
                               const PCacheQueryParams& aParams,
                               nsTArray<nsID>& aDeletedBodyIdListOut,
                               bool* aSuccessOut);
+  static nsresult CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
+                            const PCacheRequestOrVoid& aRequestOrVoid,
+                            const PCacheQueryParams& aParams,
+                            nsTArray<SavedRequest>& aSavedRequestsOut);
 
   static nsresult StorageMatch(mozIStorageConnection* aConn,
                                Namespace aNamespace,
                                const PCacheRequest& aRequest,
                                const PCacheQueryParams& aParams,
                                bool* aFoundResponseOut,
                                SavedResponse* aSavedResponseOut);
   static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
@@ -101,16 +106,18 @@ private:
   static nsresult InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
                               const PCacheRequest& aRequest,
                               const nsID* aRequestBodyId,
                               const PCacheResponse& aResponse,
                               const nsID* aResponseBodyId,
                               SavedResponse* aSavedResponseOut);
   static nsresult ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
                                SavedResponse* aSavedResponseOut);
+  static nsresult ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
+                              SavedRequest* aSavedRequestOut);
 
   static void AppendListParamsToQuery(nsACString& aQuery,
                                       const nsTArray<EntryId>& aEntryIdList,
                                       uint32_t aPos, int32_t aLen);
   static nsresult BindListParamsToQuery(mozIStorageStatement* aState,
                                         const nsTArray<EntryId>& aEntryIdList,
                                         uint32_t aPos, int32_t aLen);
   static nsresult BindId(mozIStorageStatement* aState, uint32_t aPos,
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -4,19 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
-#include "mozilla/dom/cache/PCacheQueryParams.h"
-#include "mozilla/dom/cache/PCacheRequest.h"
-#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
@@ -635,16 +633,56 @@ public:
 protected:
   virtual ~CacheDeleteAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   bool mSuccess;
 };
 
+class Manager::CacheKeysAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  CacheKeysAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, CacheId aCacheId,
+                    const PCacheRequestOrVoid& aRequestOrVoid,
+                    const PCacheQueryParams& aParams)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequestOrVoid(aRequestOrVoid)
+    , mParams(aParams)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::CacheKeys(aConn, mCacheId, mRequestOrVoid, mParams,
+                               mSavedRequests);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnCacheKeys(mRequestId, aRv, mSavedRequests);
+  }
+
+  virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
+  {
+    return aCacheId == mCacheId;
+  }
+
+protected:
+  virtual ~CacheKeysAction() { }
+  const CacheId mCacheId;
+  const PCacheRequestOrVoid mRequestOrVoid;
+  const PCacheQueryParams mParams;
+  nsTArray<SavedRequest> mSavedRequests;
+};
+
 class Manager::CacheReadBodyAction MOZ_FINAL : public Action
 {
 public:
   CacheReadBodyAction(Manager* aManager, CacheId aCacheId,
                       const nsID& aBodyId,
                       nsIOutputStream* aStream)
     : mManager(aManager)
     , mCacheId(aCacheId)
@@ -1103,16 +1141,30 @@ Manager::CacheDelete(Listener* aListener
   MOZ_ASSERT(aListener);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheDeleteAction(this, listenerId, aRequestId,
                                                   aCacheId, aRequest, aParams);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
+Manager::CacheKeys(Listener* aListener, RequestId aRequestId,
+                   CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                   const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheKeysAction(this, listenerId, aRequestId,
+                                                aCacheId, aRequestOrVoid,
+                                                aParams);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
 Manager::CacheReadBody(CacheId aCacheId, const nsID& aBodyId,
                        nsIOutputStream* aStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aStream);
   nsRefPtr<Action> action = new CacheReadBodyAction(this, aCacheId, aBodyId,
                                                     aStream);
   CurrentContext()->Dispatch(mIOThread, action);
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -4,32 +4,34 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
-#include "mozilla/dom/cache/PCacheRequest.h"
-#include "mozilla/dom/cache/PCacheResponse.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIOutputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheQueryParams;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
 {
 public:
   class Listener
   {
   public:
@@ -38,16 +40,18 @@ public:
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedResponse>& aSavedResponses) { }
     virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
+    virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<SavedRequest>& aSavedRequests) { }
 
     virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                                 const SavedResponse* aResponse) { }
     virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound, CacheId aCacheId) { }
     virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound) { }
     virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
@@ -76,16 +80,19 @@ public:
   void CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                 const PCacheRequest& aRequest,
                 nsIInputStream* aRequestBodyStream,
                 const PCacheResponse& aResponse,
                 nsIInputStream* aResponseBodyStream);
   void CacheDelete(Listener* aListener, RequestId aRequestId,
                    CacheId aCacheId, const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams);
+  void CacheKeys(Listener* aListener, RequestId aRequestId,
+                 CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                 const PCacheQueryParams& aParams);
   void CacheReadBody(CacheId aCacheId, const nsID& aBodyId,
                      nsIOutputStream* aStream);
 
   void StorageMatch(Listener* aListener, RequestId aRequestId,
                     Namespace aNamespace, const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams);
   void StorageGet(Listener* aListener, RequestId aRequestId,
                   Namespace aNamespace, const nsAString& aKey);
@@ -109,16 +116,17 @@ private:
   class BaseAction;
   class CheckCacheOrphanedAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAction;
   class CacheDeleteAction;
+  class CacheKeysAction;
   class CacheReadBodyAction;
 
   class StorageMatchAction;
   class StorageGetAction;
   class StorageHasAction;
   class StorageCreateAction;
   class StorageDeleteAction;
   class StorageKeysAction;
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,16 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
-include PCacheQueryParams;
-include PCacheRequest;
-include PCacheResponse;
+include PCacheTypes;
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
diff --git a/dom/cache/PCacheQueryParams.ipdlh b/dom/cache/PCacheQueryParams.ipdlh
deleted file mode 100644
--- a/dom/cache/PCacheQueryParams.ipdlh
+++ /dev/null
@@ -1,23 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include PHeaders;
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-struct PCacheQueryParams
-{
-  bool ignoreSearch;
-  bool ignoreMethod;
-  bool ignoreVary;
-  bool prefixMatch;
-  bool cacheNameSet;
-  nsString cacheName;
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/PCacheResponse.ipdlh b/dom/cache/PCacheResponse.ipdlh
deleted file mode 100644
--- a/dom/cache/PCacheResponse.ipdlh
+++ /dev/null
@@ -1,31 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include PHeaders;
-
-using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
-using mozilla::void_t from "ipc/IPCMessageUtils.h";
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-struct PCacheResponse
-{
-  ResponseType type;
-  nsString url;
-  uint32_t status;
-  nsCString statusText;
-  PHeadersEntry[] headers;
-};
-
-union PCacheResponseOrVoid
-{
-  void_t;
-  PCacheResponse;
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,17 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
-include PCacheQueryParams;
-include PCacheRequest;
-include PCacheResponse;
+include PCacheTypes;
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
diff --git a/dom/cache/PCacheRequest.ipdlh b/dom/cache/PCacheTypes.ipdlh
rename from dom/cache/PCacheRequest.ipdlh
rename to dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheRequest.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,33 +1,63 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PHeaders;
 
+using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
-using struct mozilla::void_t from "ipc/IPCMessageUtils.h";
+using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
+using mozilla::void_t from "ipc/IPCMessageUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+struct PCacheQueryParams
+{
+  bool ignoreSearch;
+  bool ignoreMethod;
+  bool ignoreVary;
+  bool prefixMatch;
+  bool cacheNameSet;
+  nsString cacheName;
+};
+
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
+  HeadersGuardEnum headersGuard;
+  nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
 };
 
 union PCacheRequestOrVoid
 {
   void_t;
   PCacheRequest;
 };
 
+struct PCacheResponse
+{
+  ResponseType type;
+  nsString url;
+  uint32_t status;
+  nsCString statusText;
+  PHeadersEntry[] headers;
+  HeadersGuardEnum headersGuard;
+};
+
+union PCacheResponseOrVoid
+{
+  void_t;
+  PCacheResponse;
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
--- a/dom/cache/SavedTypes.h
+++ b/dom/cache/SavedTypes.h
@@ -5,18 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_SavedTypes_h
 #define mozilla_dom_cache_SavedTypes_h
 
 // NOTE: This cannot be rolled into Types.h because the IPC dependency.
 //       breaks webidl unified builds.
 
-#include "mozilla/dom/cache/PCacheRequest.h"
-#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsID.h"
 #include "nsIOutputStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -2,21 +2,20 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/TypeUtils.h"
 
 #include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
-#include "mozilla/dom/cache/PCacheQueryParams.h"
-#include "mozilla/dom/cache/PCacheRequest.h"
-#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsURLParsers.h"
 
 namespace {
 
 // Utility function to remove the query from a URL.  We're not using nsIURL
 // or URL to do this because they require going to the main thread.
@@ -73,19 +72,21 @@ TypeUtils::ToPCacheRequest(PCacheRequest
   aIn.GetMethod(aOut.method());
   aIn.GetUrl(aOut.url());
   if(NS_WARN_IF(NS_FAILED(GetURLWithoutQuery(aOut.url(),
                                               aOut.urlWithoutQuery())))) {
     // Fallback to just not providing ignoreSearch support
     // TODO: Should we error out here instead?
     aIn.GetUrl(aOut.urlWithoutQuery());
   }
+  aIn.GetReferrer(aOut.referrer());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
+  aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn.Mode();
   aOut.credentials() = aIn.Credentials();
 }
 
 // static
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn)
@@ -136,16 +137,17 @@ TypeUtils::ToPCacheResponse(PCacheRespon
 {
   aOut.type() = aIn.Type();
   aIn.GetUrl(aOut.url());
   aOut.status() = aIn.Status();
   aIn.GetStatusText(aOut.statusText());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
+  aOut.headersGuard() = headers->Guard();
 }
 
 // static
 void
 TypeUtils:: ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
@@ -168,17 +170,23 @@ void
 TypeUtils::ToResponse(Response& aOut, const PCacheResponse& aIn)
 {
   // TODO: implement once real Request/Response are available
   NS_WARNING("Not filling in contents of Response returned from Cache.");
 }
 
 // static
 void
-TypeUtils::ToRequest(Request& aOut, const PCacheRequest& aIn)
+TypeUtils::ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn)
 {
-  // TODO: implement once real Request/Response are available
-  NS_WARNING("Not filling in contents of Request returned from Cache.");
+  aOut.SetMethod(aIn.method());
+  aOut.SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
+  aOut.SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
+  aOut.SetMode(aIn.mode());
+  aOut.SetCredentialsMode(aIn.credentials());
+  nsRefPtr<Headers> headers = new Headers(aOut.GetClient(), aIn.headers(),
+                                          aIn.headersGuard());
+  aOut.SetHeaders(headers);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -9,16 +9,17 @@
 
 #include "mozilla/Attributes.h"
 
 namespace mozilla {
 namespace dom {
 
 class OwningRequestOrScalarValueString;
 struct QueryParams;
+class InternalRequest;
 class Request;
 class RequestOrScalarValueString;
 class Response;
 template<typename T> class Optional;
 
 namespace cache {
 
 class PCacheQueryParams;
@@ -48,17 +49,17 @@ public:
 
   static void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   static void
   ToResponse(Response& aOut, const PCacheResponse& aIn);
 
   static void
-  ToRequest(Request& aOut, const PCacheRequest& aIn);
+  ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn);
 
 private:
   TypeUtils() MOZ_DELETE;
   ~TypeUtils() MOZ_DELETE;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -40,20 +40,18 @@ SOURCES += [
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
-    'PCacheQueryParams.ipdlh',
-    'PCacheRequest.ipdlh',
-    'PCacheResponse.ipdlh',
     'PCacheStorage.ipdl',
+    'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
 
diff --git a/dom/fetch/FetchIPCUtils.h b/dom/fetch/FetchIPCUtils.h
--- a/dom/fetch/FetchIPCUtils.h
+++ b/dom/fetch/FetchIPCUtils.h
@@ -2,21 +2,27 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_FetchIPCUtils_h
 #define mozilla_dom_FetchIPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/HeadersBinding.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 
 namespace IPC {
   template<>
+  struct ParamTraits<mozilla::dom::HeadersGuardEnum> :
+    public ContiguousTypedEnumSerializer<mozilla::dom::HeadersGuardEnum,
+                                         mozilla::dom::HeadersGuardEnum::MozNone,
+                                         mozilla::dom::HeadersGuardEnum::EndGuard_> {};
+  template<>
   struct ParamTraits<mozilla::dom::RequestMode> :
     public ContiguousTypedEnumSerializer<mozilla::dom::RequestMode,
                                          mozilla::dom::RequestMode::Same_origin,
                                          mozilla::dom::RequestMode::EndGuard_> {};
   template<>
   struct ParamTraits<mozilla::dom::RequestCredentials> :
     public ContiguousTypedEnumSerializer<mozilla::dom::RequestCredentials,
                                          mozilla::dom::RequestCredentials::Omit,
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -117,16 +117,22 @@ public:
   }
 
   void
   GetURL(nsCString& aURL) const
   {
     aURL.Assign(mURL);
   }
 
+  void
+  SetURL(const nsACString& aURL)
+  {
+    mURL.Assign(aURL);
+  }
+
   nsIGlobalObject*
   GetClient() const
   {
     return mClient;
   }
 
   bool
   ReferrerIsNone() const
@@ -187,16 +193,23 @@ public:
   }
 
   Headers*
   Headers_()
   {
     return mHeaders;
   }
 
+  void
+  SetHeaders(Headers* aHeaders)
+  {
+    MOZ_ASSERT(aHeaders);
+    mHeaders = aHeaders;
+  }
+
   bool
   ForceOriginHeader()
   {
     return mForceOriginHeader;
   }
 
   void
   GetOrigin(nsCString& aOrigin) const
@@ -221,22 +234,16 @@ public:
 
   // The global is used as the client for the new object.
   already_AddRefed<InternalRequest>
   GetRequestConstructorCopy(nsIGlobalObject* aGlobal) const;
 
 private:
   ~InternalRequest();
 
-  void
-  SetURL(const nsACString& aURL)
-  {
-    mURL.Assign(aURL);
-  }
-
   nsCString mMethod;
   nsCString mURL;
   nsRefPtr<Headers> mHeaders;
   nsCOMPtr<nsIInputStream> mBodyStream;
 
   nsIGlobalObject* mClient;
 
   // nsContentPolicyType does not cover the complete set defined in the spec,
diff --git a/dom/fetch/Request.h b/dom/fetch/Request.h
--- a/dom/fetch/Request.h
+++ b/dom/fetch/Request.h
@@ -58,25 +58,25 @@ public:
 
   RequestCredentials
   Credentials() const
   {
     return mRequest->mCredentialsMode;
   }
 
   void
-  GetReferrer(DOMString& aReferrer) const
+  GetReferrer(nsAString& aReferrer) const
   {
     if (mRequest->ReferrerIsNone()) {
-      aReferrer.AsAString() = EmptyString();
+      aReferrer = EmptyString();
       return;
     }
 
     // FIXME(nsm): Spec doesn't say what to do if referrer is client.
-    aReferrer.AsAString() = NS_ConvertUTF8toUTF16(mRequest->mReferrerURL);
+    aReferrer = NS_ConvertUTF8toUTF16(mRequest->mReferrerURL);
   }
 
   Headers* Headers_() const { return mRequest->Headers_(); }
 
   static already_AddRefed<Request>
   Constructor(const GlobalObject& aGlobal, const RequestOrScalarValueString& aInput,
               const RequestInit& aInit, ErrorResult& rv);
 
diff --git a/dom/tests/mochitest/cache/test_cache_frame.html b/dom/tests/mochitest/cache/test_cache_frame.html
--- a/dom/tests/mochitest/cache/test_cache_frame.html
+++ b/dom/tests/mochitest/cache/test_cache_frame.html
@@ -21,16 +21,24 @@
       success = success && !!createCache;
       return caches.get("foobar");
     }).then(function(getCache) {
       success = success && !!getCache;
       c = getCache;
       return c.put(request, response);
     }).then(function(putResponse) {
       success = success && !!putResponse;
+      return c.keys(request);
+    }).then(function(keys) {
+      success = success && !!keys;
+      success = success && keys.length === 1;
+      return c.keys();
+    }).then(function(keys) {
+      success = success && !!keys;
+      success = success && keys.length === 1;
       return c.matchAll(request);
     }).then(function(matchAllResponses) {
       success = success && !!matchAllResponses &&
                 matchAllResponses.length === 1;
       return c.match(request);
     }).then(function(matchResponse) {
       success = success && !!matchResponse;
       return caches.match(request);
@@ -41,16 +49,20 @@
       success = success && !!storageMatchResponse;
       var request2 = new Request("http://example.com/hmm?q=snafu");
       return c.match(request2, {ignoreSearch:true});
     }).then(function(match2Response) {
       success = success && !!match2Response;
       return c.delete(request);
     }).then(function(deleteResult) {
       success = success && deleteResult;
+      return c.keys();
+    }).then(function(keys) {
+      success = success && !!keys;
+      success = success && keys.length === 0;
       return c.matchAll(request);
     }).then(function(matchAll2Responses) {
       success = success && !!matchAll2Responses &&
                 matchAll2Responses.length === 0;
       return caches.has("foobar");
     }).then(function(hasResult) {
       success = success && hasResult;
       return caches.keys();
