# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7df8d3b660ca6259f7e828b9a47641583019c0ca
Bug 1204254 P11 Notify observers of the "http-on-stop-request" topic from InterceptedHttpChannel. r=asuth

diff --git a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
--- a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
+++ b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
@@ -81,18 +81,17 @@ function register(aWindow, aURL, aScope)
       });
     });
 }
 
 function fetchAndCheckTimedChannel(aWindow, aIntercepted, aFetch, aURL) {
   var resolveFunction;
   var promise = new Promise(aResolve => resolveFunction = aResolve);
 
-  var topic = aFetch ? "http-on-examine-response"
-                     : "service-worker-synthesized-response";
+  var topic = "http-on-stop-request";
 
   function observer(aSubject) {
     var channel = aSubject.QueryInterface(Ci.nsIChannel);
 
     // Since we cannot make sure that the network event triggered by the fetch()
     // in this testcase is the very next event processed by ObserverService, we
     // have to wait until we catch the one we want.
     if (!channel.URI.spec.endsWith(aURL)) {
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -955,16 +955,18 @@ InterceptedHttpChannel::OnStopRequest(ns
   MaybeCallStatusAndProgress();
 
   mIsPending = false;
 
   if (mListener) {
     mListener->OnStopRequest(this, mListenerContext, mStatus);
   }
 
+  gHttpHandler->OnStopRequest(this);
+
   ReleaseListeners();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnDataAvailable(nsIRequest* aRequest,
                                         nsISupports* aContext,
