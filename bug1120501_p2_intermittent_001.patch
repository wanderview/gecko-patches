# HG changeset patch
# Parent 7b99e2c67e3d4312c379e3c5d0ae5c484aeca476
# User Ben Kelly <ben@wanderview.com>
Bug 1120501 P2 intermittent 001 review feedback

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -261,24 +261,32 @@ AutoChildOpArgs::Add(InternalRequest* aR
 }
 
 namespace {
 
 bool
 MatchInPutList(InternalRequest* aRequest,
                const nsTArray<CacheRequestResponse>& aPutList)
 {
+  MOZ_ASSERT(aRequest);
+
   // This method implements the SW spec QueryCache algorithm against an
   // in memory array of Request/Response objects.  This essentially the
   // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
   // we cannot unify them because when operating against the real database
   // we don't want to load all request/response objects into memory.
 
   // Note, we can skip the check for a invalid request method because
-  // Cache will only call into here with a GET or HEAD.
+  // Cache should only call into here with a GET or HEAD.
+#ifdef DEBUG
+  nsAutoCString method;
+  aRequest->GetMethod(method);
+  MOZ_ASSERT(method.LowerCaseEqualsLiteral("get") ||
+             method.LowerCaseEqualsLiteral("head"));
+#endif
 
   nsRefPtr<InternalHeaders> requestHeaders = aRequest->Headers();
 
   for (uint32_t i = 0; i < aPutList.Length(); ++i) {
     const CacheRequest& cachedRequest = aPutList[i].request();
     const CacheResponse& cachedResponse = aPutList[i].response();
 
     nsAutoCString url;
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -106,67 +106,79 @@ public:
   ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override
   {
     NS_ASSERT_OWNINGTHREAD(FetchHandler);
 
     // Stop holding the worker alive when we leave this method.
     nsRefPtr<Feature> feature;
     feature.swap(mFeature);
 
+    // Promise::All() passed an array of fetch() Promises should give us
+    // an Array of Response objects.  The following code unwraps these
+    // JS values back to an nsTArray<nsRefPtr<Response>>.
+
     nsAutoTArray<nsRefPtr<Response>, 256> responseList;
     responseList.SetCapacity(mRequestList.Length());
 
-    JS::Rooted<JSObject*> obj(aCx, &aValue.toObject());
-
-    if (NS_WARN_IF(!JS_IsArrayObject(aCx, obj))) {
+    if (NS_WARN_IF(!JS_IsArrayObject(aCx, aValue))) {
       Fail();
       return;
     }
 
+    JS::Rooted<JSObject*> obj(aCx, &aValue.toObject());
+
     uint32_t length;
     if (NS_WARN_IF(!JS_GetArrayLength(aCx, obj, &length))) {
       Fail();
       return;
     }
 
     for (uint32_t i = 0; i < length; ++i) {
-      JS::RootedValue value(aCx);
+      JS::Rooted<JS::Value> value(aCx);
 
       if (NS_WARN_IF(!JS_GetElement(aCx, obj, i, &value))) {
         Fail();
         return;
       }
 
+      if (NS_WARN_IF(!value.isObject())) {
+        Fail();
+        return;
+      }
+
       JS::Rooted<JSObject*> responseObj(aCx, &value.toObject());
 
-      nsRefPtr<Response> response = nullptr;
+      nsRefPtr<Response> response;
       nsresult rv = UNWRAP_OBJECT(Response, responseObj, response);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         Fail();
         return;
       }
 
       if (NS_WARN_IF(response->Type() == ResponseType::Error)) {
         Fail();
         return;
       }
 
       responseList.AppendElement(Move(response));
     }
 
     MOZ_ASSERT(mRequestList.Length() == responseList.Length());
 
+    // Now store the unwrapped Response list in the Cache.
     ErrorResult result;
     nsRefPtr<Promise> put = mCache->PutAll(mRequestList, responseList, result);
     if (NS_WARN_IF(result.Failed())) {
       // TODO: abort the fetch requests we have running (bug 1157434)
       mPromise->MaybeReject(result);
       return;
     }
 
+    // Chain the Cache::Put() promise to the original promise returned to
+    // the content script.
     mPromise->MaybeResolve(put);
   }
 
   virtual void
   RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override
   {
     NS_ASSERT_OWNINGTHREAD(FetchHandler);
     Fail();
