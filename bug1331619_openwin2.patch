# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a3978751f45108ff1ae002ecebdc0fa23fc52b84
Bug 1331619 Make ServiceWorkerClients check the return value of OpenWindow2(). r=catalinb

diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -620,16 +620,17 @@ public:
 
     return NS_OK;
   }
 
 private:
   nsresult
   OpenWindow(nsPIDOMWindowOuter** aWindow)
   {
+    MOZ_DIAGNOSTIC_ASSERT(aWindow);
     WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
 
     // [[1. Let url be the result of parsing url with entry settings object's API
     //   base URL.]]
     nsCOMPtr<nsIURI> uri;
     WorkerPrivate::LocationInfo& info = workerPrivate->GetLocationInfo();
 
     nsCOMPtr<nsIURI> baseURI;
@@ -656,34 +657,41 @@ private:
         do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
       nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
       NS_ENSURE_STATE(pwwatch);
 
       nsCString spec;
-      uri->GetSpec(spec);
+      rv = uri->GetSpec(spec);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
 
       nsCOMPtr<mozIDOMWindowProxy> newWindow;
-      pwwatch->OpenWindow2(nullptr,
-                           spec.get(),
-                           nullptr,
-                           nullptr,
-                           false, false, true, nullptr,
-                           // Not a spammy popup; we got permission, we swear!
-                           /* aIsPopupSpam = */ false,
-                           // Don't force noopener.  We're not passing in an
-                           // opener anyway, and we _do_ want the returned
-                           // window.
-                           /* aForceNoOpener = */ false,
-                           /* aLoadInfp = */ nullptr,
-                           getter_AddRefs(newWindow));
+      rv = pwwatch->OpenWindow2(nullptr,
+                                spec.get(),
+                                nullptr,
+                                nullptr,
+                                false, false, true, nullptr,
+                                // Not a spammy popup; we got permission, we swear!
+                                /* aIsPopupSpam = */ false,
+                                // Don't force noopener.  We're not passing in an
+                                // opener anyway, and we _do_ want the returned
+                                // window.
+                                /* aForceNoOpener = */ false,
+                                /* aLoadInfp = */ nullptr,
+                                getter_AddRefs(newWindow));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
       nsCOMPtr<nsPIDOMWindowOuter> pwindow = nsPIDOMWindowOuter::From(newWindow);
       pwindow.forget(aWindow);
+      MOZ_DIAGNOSTIC_ASSERT(*aWindow);
       return NS_OK;
     }
 
     // Find the most recent browser window and open a new tab in it.
     nsCOMPtr<nsPIDOMWindowOuter> browserWindow =
       nsContentUtils::GetMostRecentNonPBWindow();
     if (!browserWindow) {
       // It is possible to be running without a browser window on Mac OS, so
@@ -711,16 +719,17 @@ private:
                        getter_AddRefs(win));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
     NS_ENSURE_STATE(win);
 
     nsCOMPtr<nsPIDOMWindowOuter> pWin = nsPIDOMWindowOuter::From(win);
     pWin.forget(aWindow);
+    MOZ_DIAGNOSTIC_ASSERT(*aWindow);
 
     return NS_OK;
   }
 };
 
 } // namespace
 
 already_AddRefed<Promise>
