# HG changeset patch
# Parent 14097418960c369025b3ab293bc01be5af065564
# User Ben Kelly <ben@wanderview.com>
Implement clean shutdown for Cache.

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -310,21 +310,17 @@ public:
 
   virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
   {
     MOZ_ASSERT(mState == STATE_RUNNING);
     mResult = aRv;
     mState = STATE_COMPLETING;
     nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
     if (NS_FAILED(rv)) {
-      // TODO: Investigate what to do if we can't dispatch back to initiating
-      //       thread because the PBackground worker thread went away.  Seems to
-      //       happen on linux opt mochitest.  Possibly due to not having a proper
-      //       shutdown observer yet.
-      NS_WARNING("Failed to dispatch ActionRunnable to initiating thread.");
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
     }
   }
 
 private:
   virtual ~ActionRunnable()
   {
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -6,16 +6,17 @@
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/dom/cache/ShutdownObserver.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
@@ -86,28 +87,37 @@ public:
     return *sFactory;
   }
 
   already_AddRefed<Manager> GetOrCreate(const nsACString& aOrigin,
                                         const nsACString& aBaseDomain)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
+    nsRefPtr<Manager> ref = Get(aOrigin);
+    if (!ref) {
+      ref = new Manager(aOrigin, aBaseDomain);
+      mManagerList.AppendElement(ref);
+    }
+
+    return ref.forget();
+  }
+
+  already_AddRefed<Manager> Get(const nsACString& aOrigin)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
     for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
       if (mManagerList[i]->Origin() == aOrigin) {
         nsRefPtr<Manager> ref = mManagerList[i];
         return ref.forget();
       }
     }
 
-    nsRefPtr<Manager> ref = new Manager(aOrigin, aBaseDomain);
-
-    mManagerList.AppendElement(ref);
-
-    return ref.forget();
+    return nullptr;
   }
 
   void Remove(Manager* aManager)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(aManager);
 
     for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
@@ -1144,16 +1154,24 @@ Manager::StreamList::~StreamList()
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
 }
 
+// static
+already_AddRefed<Manager>
+Manager::ForExistingOrigin(const nsACString& aOrigin)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().Get(aOrigin);
+}
+
 void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   mListeners.RemoveElement(aListener);
 }
 
 void
@@ -1177,18 +1195,21 @@ Manager::ReleaseCacheId(CacheId aCacheId
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount < 1) {
         mCacheIdRefs.RemoveElementAt(i);
-        nsRefPtr<Action> action = new CheckCacheOrphanedAction(this, aCacheId);
-        CurrentContext()->Dispatch(mIOThread, action);
+        // TODO: note that we need to check this cache for staleness on startup
+        if (!mShuttingDown) {
+          nsRefPtr<Action> action = new CheckCacheOrphanedAction(this, aCacheId);
+          CurrentContext()->Dispatch(mIOThread, action);
+        }
       }
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release CacheId that is not referenced!");
 }
 
 uint32_t
@@ -1199,57 +1220,70 @@ Manager::GetCacheIdRefCount(CacheId aCac
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
       return mCacheIdRefs[i].mCount;
     }
   }
   return 0;
 }
 
-// TODO: Call Manager::Shutdown from observer on main thread at shutdown
-// Notes:
-//  - implement a singleton called ShutdownObserver
-//  - Manager calls ShutdownObserver::AddManager(origin) at creation
-//  - Manager calls ShutdownObserver::RemoveManager(origin) at creation
-//  - origins are proxied to main thread and kept in a list
-//  - at shutdown time origins are sent to IPC thread to call Manager::Shutdown()
 void
 Manager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+  mShuttingDown = true;
   for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
     mStreamLists[i]->CloseAll();
   }
-  if (mContext) {
+
+  // If there is no context, then note that we're done shutting down
+  if (!mContext) {
+    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+    if (so) {
+      so->RemoveOrigin(mOrigin);
+    }
+
+  // Otherwise, cancel the context and note complete when it cleans up
+  } else {
     mContext->CancelAll();
   }
 }
 
 void
 Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheMatch(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                            nullptr, nullptr);
+    return;
+  }
   nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
                                                  aCacheId, aRequest, aParams,
                                                  streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
                        CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
                        const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheMatchAll(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                               nsTArray<SavedResponse>(), nullptr);
+    return;
+  }
   nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
                                                     aCacheId, aRequest, aParams,
                                                     streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
@@ -1257,16 +1291,21 @@ void
 Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   nsIInputStream* aRequestBodyStream,
                   const PCacheResponse& aResponse,
                   nsIInputStream* aResponseBodyStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCachePut(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                          nullptr, nullptr);
+    return;
+  }
   nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
                                                aCacheId,
                                                aRequest, aRequestBodyStream,
                                                aResponse, aResponseBodyStream,
                                                streamList);
   CurrentContext()->Dispatch(mIOThread, action);
@@ -1274,131 +1313,184 @@ Manager::CachePut(Listener* aListener, R
 
 void
 Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheDelete(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN, false);
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheDeleteAction(this, listenerId, aRequestId,
                                                   aCacheId, aRequest, aParams);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheKeys(Listener* aListener, RequestId aRequestId,
                    CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                    const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnCacheKeys(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                           nsTArray<SavedRequest>(), nullptr);
+    return;
+  }
   nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheKeysAction(this, listenerId, aRequestId,
                                                 aCacheId, aRequestOrVoid,
                                                 aParams, streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageMatch(Listener* aListener, RequestId aRequestId,
                       Namespace aNamespace, const PCacheRequest& aRequest,
                       const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageMatch(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                              nullptr, nullptr);
+    return;
+  }
   nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageMatchAction(this, listenerId, aRequestId,
                                                    aNamespace, aRequest,
                                                    aParams, streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageGet(Listener* aListener, RequestId aRequestId,
                     Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageGet(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                            false, 0);
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageGetAction(this, listenerId, aRequestId,
                                                  aNamespace, aKey);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageHas(Listener* aListener, RequestId aRequestId,
                     Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageHas(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                            false);
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageHasAction(this, listenerId, aRequestId,
                                                  aNamespace, aKey);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageCreate(Listener* aListener, RequestId aRequestId,
                        Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageCreate(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN, 0);
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageCreateAction(this, listenerId, aRequestId,
                                                     aNamespace, aKey);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageDelete(Listener* aListener, RequestId aRequestId,
                        Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageDelete(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                               false);
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageDeleteAction(this, listenerId, aRequestId,
                                                     aNamespace, aKey);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageKeys(Listener* aListener, RequestId aRequestId,
                      Namespace aNamespace)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  if (mShuttingDown) {
+    aListener->OnStorageKeys(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN,
+                             nsTArray<nsString>());
+    return;
+  }
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageKeysAction(this, listenerId, aRequestId,
                                                   aNamespace);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
   mContext = nullptr;
+
+  if (mShuttingDown) {
+    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+    if (so) {
+      so->RemoveOrigin(mOrigin);
+    }
+  }
 }
 
 Manager::Manager(const nsACString& aOrigin, const nsACString& aBaseDomain)
   : mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
   , mContext(nullptr)
+  , mShuttingDown(false)
 {
   nsresult rv = NS_NewNamedThread("DOMCacheThread",
                                   getter_AddRefs(mIOThread));
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Failed to spawn cache manager IO thread.");
   }
+
+  nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
+  if (so) {
+    so->AddOrigin(mOrigin);
+  } else {
+    Shutdown();
+  }
 }
 
 Manager::~Manager()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   Factory::Instance().Remove(this);
   if (mContext) {
     mContext->CancelAll();
@@ -1407,16 +1499,17 @@ Manager::~Manager()
   mIOThread->Shutdown();
 }
 
 Context*
 Manager::CurrentContext()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   if (!mContext) {
+    MOZ_ASSERT(!mShuttingDown);
     nsRefPtr<Action> setupAction = new SetupAction(mOrigin, mBaseDomain);
     mContext = new Context(this, mOrigin, mBaseDomain, setupAction);
   }
   return mContext;
 }
 
 Manager::ListenerId
 Manager::SaveListener(Listener* aListener)
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -114,16 +114,17 @@ public:
     virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                  bool aCacheDeleted) { }
     virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
                                const nsTArray<nsString>& aKeys) { }
   };
 
   static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
                                              const nsACString& aBaseDomain);
+  static already_AddRefed<Manager> ForExistingOrigin(const nsACString& aOrigin);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   uint32_t GetCacheIdRefCount(CacheId aCacheId);
   void Shutdown();
 
   // TODO: consider moving CacheId up in the argument lists below
@@ -207,16 +208,18 @@ private:
     CacheId mCacheId;
     uint32_t mCount;
   };
   nsTArray<CacheIdRefCounter> mCacheIdRefs;
 
   // weak ref as Context destructor clears this pointer
   Context* mContext;
 
+  bool mShuttingDown;
+
 public:
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/cache/ShutdownObserver.cpp b/dom/cache/ShutdownObserver.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ShutdownObserver.cpp
@@ -0,0 +1,238 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ShutdownObserver.h"
+
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/Services.h"
+#include "nsIObserverService.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+static bool sInstanceInit = false;
+static nsRefPtr<mozilla::dom::cache::ShutdownObserver> sInstance = nullptr;
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::services::GetObserverService;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ShutdownObserver, nsIObserver);
+
+// static
+already_AddRefed<ShutdownObserver>
+ShutdownObserver::Instance()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  if (!sInstanceInit) {
+    sInstanceInit = true;
+    sInstance = new ShutdownObserver();
+  }
+
+  nsRefPtr<ShutdownObserver> ref = sInstance;
+  return ref.forget();
+}
+
+nsresult
+ShutdownObserver::AddOrigin(const nsACString& aOrigin)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  printf_stderr("### ### ShutdownObserver::AddOrigin(): %s\n", nsCString(aOrigin).get());
+
+  if (mShuttingDown) {
+    return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethodWithArg<nsCString>(this,
+                                           &ShutdownObserver::AddOriginOnMainThread,
+                                           nsCString(aOrigin));
+
+  DebugOnly<nsresult> rv =
+    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+  return NS_OK;
+}
+
+void
+ShutdownObserver::RemoveOrigin(const nsACString& aOrigin)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  printf_stderr("### ### ShutdownObserver::RemoveOrigin(): %s\n", nsCString(aOrigin).get());
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethodWithArg<nsCString>(this,
+                                           &ShutdownObserver::RemoveOriginOnMainThread,
+                                           nsCString(aOrigin));
+
+  DebugOnly<nsresult> rv =
+    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+}
+
+ShutdownObserver::ShutdownObserver()
+  : mBackgroundThread(NS_GetCurrentThread())
+  , mShuttingDown(false)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  printf_stderr("### ### ShutdownObserver()\n");
+}
+
+ShutdownObserver::~ShutdownObserver()
+{
+  // This can happen on either main thread or background thread.
+  printf_stderr("### ### ~ShutdownObserver()\n");
+}
+
+void
+ShutdownObserver::AddOriginOnMainThread(const nsACString& aOrigin)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  printf_stderr("### ### ShutdownObserver::AddOriginOnMainThread(): %s\n", nsCString(aOrigin).get());
+
+  if (!mOrigins.Contains(aOrigin)) {
+    mOrigins.AppendElement(aOrigin);
+
+    if (mOrigins.Length() == 1) {
+      nsCOMPtr<nsIObserverService> os = GetObserverService();
+
+      // If there is no observer service then we are already shutting down,
+      // but content just tried to use the Cache API for the first time.
+      // Trigger an immediate Cache shutdown.
+      if (!os) {
+        printf_stderr("### ### ShutdownObserver::AddOriginOnMainThread(): %s - no observer service\n", nsCString(aOrigin).get());
+        nsCOMPtr<nsIRunnable> runnable =
+          NS_NewRunnableMethod(this, &ShutdownObserver::DoShutdown);
+
+        DebugOnly<nsresult> rv =
+          NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+        return;
+      }
+
+      printf_stderr("### ### ShutdownObserver::AddOriginOnMainThread(): %s - add observer\n", nsCString(aOrigin).get());
+      os->AddObserver(this, "profile-before-change", false /* weak ref */);
+    }
+  }
+}
+
+void
+ShutdownObserver::RemoveOriginOnMainThread(const nsACString& aOrigin)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  printf_stderr("### ### ShutdownObserver::RemoveOriginOnMainThread(): %s\n", nsCString(aOrigin).get());
+
+  size_t index = mOrigins.IndexOf(aOrigin);
+  if (index != nsTArray<nsCString>::NoIndex) {
+    mOrigins.RemoveElementAt(index);
+
+    if (mOrigins.Length() == 0) {
+      printf_stderr("### ### ShutdownObserver::RemoveOriginOnMainThread(): %s - clear observer\n", nsCString(aOrigin).get());
+      nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+      if (os) {
+        os->RemoveObserver(this, "profile-before-change");
+      }
+    }
+  }
+}
+
+void
+ShutdownObserver::StartShutdownOnBgThread()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  printf_stderr("### ### ShutdownObserver::StartShutdownOnBgThread()\n");
+
+  mShuttingDown = true;
+
+  for (uint32_t i = 0; i < mOriginsInProcess.Length(); ++i) {
+    nsRefPtr<Manager> manager = Manager::ForExistingOrigin(mOriginsInProcess[i]);
+    if (manager) {
+      manager->Shutdown();
+    }
+  }
+}
+
+void
+ShutdownObserver::FinishShutdownOnBgThread()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mShuttingDown);
+
+  printf_stderr("### ### ShutdownObserver::FinishShutdownOnBgThread()\n");
+
+  sInstance = nullptr;
+}
+
+void
+ShutdownObserver::DoShutdown()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  printf_stderr("### ### ShutdownObserver::DoShutdown()\n");
+
+  // Copy origins to separate array to process to avoid races
+  mOriginsInProcess = mOrigins;
+
+  // Send shutdown notification to origin managers
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethod(this, &ShutdownObserver::StartShutdownOnBgThread);
+  DebugOnly<nsresult> rv =
+    mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+  runnable = nullptr;
+
+  printf_stderr("### ### ShutdownObserver::DoShutdown() start wait\n");
+
+  // What for managers to shutdown
+  while (!mOrigins.IsEmpty()) {
+    printf_stderr("### ### ShutdownObserver::DoShutdown() call NS_ProcessNextEvent()\n");
+    if (!NS_ProcessNextEvent()) {
+      NS_WARNING("Something bad happened!");
+      break;
+    }
+  }
+
+  printf_stderr("### ### ShutdownObserver::DoShutdown() end wait\n");
+
+  // schedule runnable to clear singleton ref on background thread
+  runnable =
+    NS_NewRunnableMethod(this, &ShutdownObserver::FinishShutdownOnBgThread);
+  rv = mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+}
+
+NS_IMETHODIMP
+ShutdownObserver::Observe(nsISupports* aSubject, const char* aTopic,
+                          const char16_t* aData)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  printf_stderr("### ### ShutdownObserver::Observer(): %s\n", aTopic);
+
+  if (!strcmp(aTopic, "profile-before-change")) {
+    DoShutdown();
+  }
+
+  return NS_OK;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ShutdownObserver.h b/dom/cache/ShutdownObserver.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ShutdownObserver.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ShutdownObserver_h
+#define mozilla_dom_cache_ShutdownObserver_h
+
+#include "mozilla/Attributes.h"
+#include "nsCOMPtr.h"
+#include "nsIObserver.h"
+#include "nsIThread.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class ShutdownObserver MOZ_FINAL : public nsIObserver
+{
+public:
+  static already_AddRefed<ShutdownObserver> Instance();
+
+  nsresult AddOrigin(const nsACString& aOrigin);
+  void RemoveOrigin(const nsACString& aOrigin);
+
+private:
+  ShutdownObserver();
+  virtual ~ShutdownObserver();
+
+  void AddOriginOnMainThread(const nsACString& aOrigin);
+  void RemoveOriginOnMainThread(const nsACString& aOrigin);
+
+  void StartShutdownOnBgThread();
+  void FinishShutdownOnBgThread();
+
+  void DoShutdown();
+
+  nsCOMPtr<nsIThread> mBackgroundThread;
+
+  // main thread only
+  nsTArray<nsCString> mOrigins;
+
+  // set on main thread once and read on bg thread
+  nsTArray<nsCString> mOriginsInProcess;
+
+  // bg thread only
+  bool mShuttingDown;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ShutdownObserver_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -20,16 +20,17 @@ EXPORTS.mozilla.dom.cache += [
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ReadStream.h',
     'SavedTypes.h',
+    'ShutdownObserver.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
@@ -41,16 +42,17 @@ SOURCES += [
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ReadStream.cpp',
+    'ShutdownObserver.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheStorage.ipdl',
     'PCacheStreamControl.ipdl',
     'PCacheTypes.ipdlh',
