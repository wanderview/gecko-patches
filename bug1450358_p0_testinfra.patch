# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  074b4b0f96cb4ba6b1c4d34dfdc54bdb62b0dfd5
Bug 1450358 P0 Factor the event listener runtime leak checking test into a reusable test framework. r=baku

diff --git a/dom/events/test/event_leak_utils.js b/dom/events/test/event_leak_utils.js
new file mode 100644
--- /dev/null
+++ b/dom/events/test/event_leak_utils.js
@@ -0,0 +1,81 @@
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/publicdomain/zero/1.0/
+"use strict"
+
+// This function runs a number of tests where:
+//
+//  1. An iframe is created
+//  2. The target callback is executed with the iframe's contentWindow as
+//     an argument.
+//  3. The iframe is destroyed and GC is forced.
+//  4. Verifies that the iframe's contentWindow has been GC'd.
+//
+// Different ways of destroying the iframe are checked.  Simple
+// remove(), destruction via bfcache, or replacement by document.open().
+//
+// Please pass a target callback that exercises the API under
+// test using the given window.  The callback should try to leave the
+// API active to increase the liklihood of provoking an API.  Any activity
+// should be canceled by the destruction of the window.
+async function checkForEventListenerLeaks(name, target) {
+  // Test if we leak in the case where we do nothing special to
+  // the frame before removing it from the DOM.
+  await _eventListenerLeakStep(target, `${name} default`);
+
+  // Test the case where we navigate the frame before removing it
+  // from the DOM so that the window using the target API ends up
+  // in bfcache.
+  await _eventListenerLeakStep(target, `${name} bfcache`, frame => {
+    frame.src = "about:blank";
+    return new Promise(resolve => frame.onload = resolve);
+  });
+
+  // Test the case where we document.open() the frame before removing
+  // it from the DOM so that the window using the target API ends
+  // up getting replaced.
+  await _eventListenerLeakStep(target, `${name} document.open()`, frame => {
+    frame.contentDocument.open();
+    frame.contentDocument.close();
+  });
+}
+
+// ----------------
+// Internal helpers
+// ----------------
+
+// Utility function to create a loaded iframe.
+async function _withFrame(doc, url) {
+  let frame = doc.createElement('iframe');
+  frame.src = url;
+  doc.body.appendChild(frame);
+  await new Promise(resolve => frame.onload = resolve);
+  return frame;
+}
+
+// This function defines the basic form of the test cases.  We create an
+// iframe, execute the target callback to manipulate the DOM, remove the frame
+// from the DOM, and then check to see if the frame was GC'd.  The caller
+// may optionally pass in a callback that will be executed with the
+// frame as an argument before removing it from the DOM.
+async function _eventListenerLeakStep(target, name, extra) {
+  let frame = await _withFrame(document, "empty.html");
+
+  await target(frame.contentWindow);
+
+  let weakRef = SpecialPowers.Cu.getWeakReference(frame.contentWindow);
+  ok(weakRef.get(), `should be able to create a weak reference - ${name}`);
+
+  if (extra) {
+    await extra(frame);
+  }
+
+  frame.remove();
+  frame = null;
+
+  // Perform two GC'd to avoid intermittent delayed collection.
+  await new Promise(resolve => SpecialPowers.exactGC(resolve));
+  await new Promise(resolve => SpecialPowers.exactGC(resolve));
+
+  ok(!weakRef.get(), `iframe content window should be garbage collected - ${name}`);
+}
+
diff --git a/dom/events/test/mochitest.ini b/dom/events/test/mochitest.ini
--- a/dom/events/test/mochitest.ini
+++ b/dom/events/test/mochitest.ini
@@ -10,16 +10,17 @@ support-files =
   bug426082.html
   bug545268.html
   bug574663.html
   bug607464.html
   bug656379-1.html
   bug418986-3.js
   error_event_worker.js
   empty.js
+  event_leak_utils.js
   window_bug493251.html
   window_bug659071.html
   window_wheel_default_action.html
   !/gfx/layers/apz/test/mochitest/apz_test_utils.js
 
 [test_accel_virtual_modifier.html]
 [test_addEventListenerExtraArg.html]
 [test_all_synthetic_events.html]
diff --git a/dom/serviceworkers/test/mochitest.ini b/dom/serviceworkers/test/mochitest.ini
--- a/dom/serviceworkers/test/mochitest.ini
+++ b/dom/serviceworkers/test/mochitest.ini
@@ -228,16 +228,17 @@ support-files =
   service_worker.js
   service_worker_client.html
   utils.js
   bug1290951_worker_main.sjs
   bug1290951_worker_imported.sjs
   sw_storage_not_allow.js
   update_worker.sjs
   self_update_worker.sjs
+  !/dom/events/test/event_leak_utils.js
 
 [test_bug1151916.html]
 [test_bug1240436.html]
 [test_bug1408734.html]
 [test_claim.html]
 [test_claim_oninstall.html]
 [test_controller.html]
 [test_cookie_fetch.html]
diff --git a/dom/serviceworkers/test/test_event_listener_leaks.html b/dom/serviceworkers/test/test_event_listener_leaks.html
--- a/dom/serviceworkers/test/test_event_listener_leaks.html
+++ b/dom/serviceworkers/test/test_event_listener_leaks.html
@@ -3,36 +3,26 @@
   http://creativecommons.org/publicdomain/zero/1.0/
 -->
 <!DOCTYPE HTML>
 <html>
 <head>
   <title>Bug 1447871 - Test some service worker leak conditions</title>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
   <script type="text/javascript" src="utils.js"></script>
+  <script type="text/javascript" src="/tests/dom/events/test/event_leak_utils.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
 </head>
 <body>
 <p id="display"></p>
-<div id="content" style="display: none"></div>
-<pre id="test"></pre>
 <script class="testbody" type="text/javascript">
 
 const scope = new URL("empty.html?leak_tests", location).href;
 const script = new URL("empty.js", location).href;
 
-// Utility function to create a loaded iframe.
-async function withFrame(doc, url) {
-  let frame = doc.createElement('iframe');
-  frame.src = url;
-  doc.body.appendChild(frame);
-  await new Promise(resolve => frame.onload = resolve);
-  return frame;
-}
-
 // Manipulate service worker DOM objects in the frame's context.
 // Its important here that we create a listener callback from
 // the DOM objects back to the frame's global in order to
 // exercise the leak condition.
 async function useServiceWorker(contentWindow) {
   contentWindow.navigator.serviceWorker.oncontrollerchange = _ => {
     contentWindow.controlledChangeCount += 1;
   };
@@ -40,71 +30,28 @@ async function useServiceWorker(contentW
   reg.onupdatefound = _ => {
     contentWindow.updateCount += 1;
   };
   reg.active.onstatechange = _ => {
     contentWindow.stateChangeCount += 1;
   };
 }
 
-// This function defines the basic form of the test cases.  We create an
-// iframe, manipulate some service worker DOM objects, remove the frame
-// from the DOM and then check to see if the frame was GC'd.  The caller
-// may optionally pass in a callback that will be executed with the
-// frame as an argument before removing it from the DOM.
-async function leakTest(name, callback) {
-  let frame = await withFrame(document, "empty.html");
-
-  await useServiceWorker(frame.contentWindow);
-
-  let weakRef = SpecialPowers.Cu.getWeakReference(frame.contentWindow);
-  ok(weakRef.get(), `should be able to create a weak reference - ${name}`);
-
-  if (callback) {
-    await callback(frame);
-  }
-
-  frame.remove();
-  frame = null;
-
-  await new Promise(resolve => SpecialPowers.exactGC(resolve));
-  await new Promise(resolve => SpecialPowers.exactGC(resolve));
-  ok(!weakRef.get(), `iframe content window should be garbage collected - ${name}`);
-}
-
 async function runTest() {
   await SpecialPowers.pushPrefEnv({"set": [
     ["dom.serviceWorkers.exemptFromPerDomainMax", true],
     ["dom.serviceWorkers.enabled", true],
     ["dom.serviceWorkers.testing.enabled", true]
   ]});
 
   let reg = await navigator.serviceWorker.register(script, { scope });
   await waitForState(reg.installing, "activated");
 
   try {
-    // Test if we leak in the case where we do nothing special to
-    // the frame before removing it from the DOM.
-    await leakTest("default");
-
-    // Test the case where we navigate the frame before removing it
-    // from the DOM so that the service worker using window ends up
-    // in bfcache.
-    await leakTest("bfcache", frame => {
-      frame.src = "about:blank";
-      return new Promise(resolve => frame.onload = resolve);
-    });
-
-    // Test the case where we document.open() the frame before removing
-    // it from the DOM so that the service worker using window ends
-    // up getting replaced.
-    await leakTest("document.open()", frame => {
-      frame.contentDocument.open();
-      frame.contentDocument.close();
-    });
+    await checkForEventListenerLeaks("ServiceWorker", useServiceWorker);
   } catch (e) {
     ok(false, e);
   } finally {
     await reg.unregister();
     SimpleTest.finish();
   }
 }
 
