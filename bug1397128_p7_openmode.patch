# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a6416edbe5c9c187894b130c20a123bf471d9d1a
Bug 1397128 P7 Add an OpenMode enumeration to control if individual Cache API requests eagerly or lazily opens bodies. r=tt

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -280,17 +280,19 @@ Cache::Match(JSContext* aCx, const Reque
     ToInternalRequest(aCx, aRequest, IgnoreBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheMatchArgs(CacheRequest(), params), 1);
+  AutoChildOpArgs args(this,
+                       CacheMatchArgs(CacheRequest(), params, OpenMode::Eager),
+                       1);
 
   args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
@@ -304,17 +306,19 @@ Cache::MatchAll(JSContext* aCx, const Op
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheMatchAllArgs(void_t(), params), 1);
+  AutoChildOpArgs args(this,
+                       CacheMatchAllArgs(void_t(), params, OpenMode::Eager),
+                       1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir = ToInternalRequest(aCx, aRequest.Value(),
                                                    IgnoreBody, aRv);
     if (aRv.Failed()) {
       return nullptr;
     }
 
@@ -486,17 +490,19 @@ Cache::Keys(JSContext* aCx, const Option
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheKeysArgs(void_t(), params), 1);
+  AutoChildOpArgs args(this,
+                       CacheKeysArgs(void_t(), params, OpenMode::Eager),
+                       1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir =
       ToInternalRequest(aCx, aRequest.Value(), IgnoreBody, aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -328,17 +328,17 @@ CacheStorage::Match(JSContext* aCx, cons
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
-  entry->mArgs = StorageMatchArgs(CacheRequest(), params);
+  entry->mArgs = StorageMatchArgs(CacheRequest(), params, OpenMode::Eager);
   entry->mRequest = request;
 
   mPendingRequests.AppendElement(entry.forget());
   MaybeRunPendingRequests();
 
   return promise.forget();
 }
 
diff --git a/dom/cache/CacheTypes.ipdlh b/dom/cache/CacheTypes.ipdlh
--- a/dom/cache/CacheTypes.ipdlh
+++ b/dom/cache/CacheTypes.ipdlh
@@ -5,16 +5,17 @@
 include protocol PCache;
 include protocol PCacheStreamControl;
 include protocol PChildToParentStream;
 include IPCStream;
 include ChannelInfo;
 include PBackgroundSharedTypes;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCTypes.h";
+using OpenMode from "mozilla/dom/cache/IPCUtils.h";
 using ReferrerPolicy from "mozilla/dom/FetchIPCTypes.h";
 using RequestCredentials from "mozilla/dom/FetchIPCTypes.h";
 using RequestMode from "mozilla/dom/FetchIPCTypes.h";
 using RequestCache from "mozilla/dom/FetchIPCTypes.h";
 using RequestRedirect from "mozilla/dom/FetchIPCTypes.h";
 using ResponseType from "mozilla/dom/FetchIPCTypes.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
 using struct nsID from "nsID.h";
@@ -101,22 +102,24 @@ struct CacheRequestResponse
   CacheRequest request;
   CacheResponse response;
 };
 
 struct CacheMatchArgs
 {
   CacheRequest request;
   CacheQueryParams params;
+  OpenMode openMode;
 };
 
 struct CacheMatchAllArgs
 {
   CacheRequestOrVoid requestOrVoid;
   CacheQueryParams params;
+  OpenMode openMode;
 };
 
 struct CachePutAllArgs
 {
   CacheRequestResponse[] requestResponseList;
 };
 
 struct CacheDeleteArgs
@@ -124,22 +127,24 @@ struct CacheDeleteArgs
   CacheRequest request;
   CacheQueryParams params;
 };
 
 struct CacheKeysArgs
 {
   CacheRequestOrVoid requestOrVoid;
   CacheQueryParams params;
+  OpenMode openMode;
 };
 
 struct StorageMatchArgs
 {
   CacheRequest request;
   CacheQueryParams params;
+  OpenMode openMode;
 };
 
 struct StorageHasArgs
 {
   nsString key;
 };
 
 struct StorageOpenArgs
diff --git a/dom/cache/IPCUtils.h b/dom/cache/IPCUtils.h
--- a/dom/cache/IPCUtils.h
+++ b/dom/cache/IPCUtils.h
@@ -13,11 +13,18 @@
 
 namespace IPC {
   template<>
   struct ParamTraits<mozilla::dom::cache::Namespace> :
     public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
                                     mozilla::dom::cache::DEFAULT_NAMESPACE,
                                     mozilla::dom::cache::NUMBER_OF_NAMESPACES>
   {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::cache::OpenMode> :
+    public ContiguousEnumSerializer<mozilla::dom::cache::OpenMode,
+                                    mozilla::dom::cache::OpenMode::Eager,
+                                    mozilla::dom::cache::OpenMode::NumTypes>
+  {};
 } // namespace IPC
 
 #endif // mozilla_dom_cache_IPCUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -539,19 +539,21 @@ public:
 
     if (!mFoundResponse || !mResponse.mHasBodyId
                         || IsHeadRequest(mArgs.request(), mArgs.params())) {
       mResponse.mHasBodyId = false;
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId, getter_AddRefs(stream));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+    if (mArgs.openMode() == OpenMode::Eager) {
+      rv = BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId, getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+    }
 
     mStreamList->Add(mResponse.mBodyId, Move(stream));
 
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, ErrorResult&& aRv) override
@@ -604,20 +606,22 @@ public:
     for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
       if (!mSavedResponses[i].mHasBodyId
           || IsHeadRequest(mArgs.requestOrVoid(), mArgs.params())) {
         mSavedResponses[i].mHasBodyId = false;
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = BodyOpen(aQuotaInfo, aDBDir, mSavedResponses[i].mBodyId,
-                    getter_AddRefs(stream));
-      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+      if (mArgs.openMode() == OpenMode::Eager) {
+        rv = BodyOpen(aQuotaInfo, aDBDir, mSavedResponses[i].mBodyId,
+                      getter_AddRefs(stream));
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+        if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+      }
 
       mStreamList->Add(mSavedResponses[i].mBodyId, Move(stream));
     }
 
     return rv;
   }
 
   virtual void
@@ -1152,20 +1156,22 @@ public:
     for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
       if (!mSavedRequests[i].mHasBodyId
           || IsHeadRequest(mArgs.requestOrVoid(), mArgs.params())) {
         mSavedRequests[i].mHasBodyId = false;
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = BodyOpen(aQuotaInfo, aDBDir, mSavedRequests[i].mBodyId,
-                    getter_AddRefs(stream));
-      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+      if (mArgs.openMode() == OpenMode::Eager) {
+        rv = BodyOpen(aQuotaInfo, aDBDir, mSavedRequests[i].mBodyId,
+                      getter_AddRefs(stream));
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+        if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+      }
 
       mStreamList->Add(mSavedRequests[i].mBodyId, Move(stream));
     }
 
     return rv;
   }
 
   virtual void
@@ -1216,20 +1222,22 @@ public:
 
     if (!mFoundResponse || !mSavedResponse.mHasBodyId
                         || IsHeadRequest(mArgs.request(), mArgs.params())) {
       mSavedResponse.mHasBodyId = false;
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
-                  getter_AddRefs(stream));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+    if (mArgs.openMode() == OpenMode::Eager) {
+      rv = BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
+                    getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+    }
 
     mStreamList->Add(mSavedResponse.mBodyId, Move(stream));
 
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, ErrorResult&& aRv) override
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -34,13 +34,20 @@ struct QuotaInfo
   nsCOMPtr<nsIFile> mDir;
   nsCString mSuffix;
   nsCString mGroup;
   nsCString mOrigin;
 };
 
 typedef std::function<void(nsCOMPtr<nsIInputStream>&&)> InputStreamResolver;
 
+enum class OpenMode : uint8_t
+{
+  Eager,
+  Lazy,
+  NumTypes
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Types_h
