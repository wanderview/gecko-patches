# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7ad2665bf240489918a4f20771e4d5ea51975eab
Bug 1450269 P1 Add BroadcastChannel leak test. r=baku

diff --git a/dom/broadcastchannel/tests/mochitest.ini b/dom/broadcastchannel/tests/mochitest.ini
--- a/dom/broadcastchannel/tests/mochitest.ini
+++ b/dom/broadcastchannel/tests/mochitest.ini
@@ -20,8 +20,9 @@ support-files =
 [test_broadcastchannel_sharedWorker.html]
 [test_broadcastchannel_worker.html]
 [test_broadcastchannel_worker_alive.html]
 [test_bfcache.html]
 [test_invalidState.html]
 [test_ordering.html]
 [test_dataCloning.html]
 [test_dataURL.html]
+[test_leak_checks.html]
diff --git a/dom/broadcastchannel/tests/test_leak_checks.html b/dom/broadcastchannel/tests/test_leak_checks.html
new file mode 100644
--- /dev/null
+++ b/dom/broadcastchannel/tests/test_leak_checks.html
@@ -0,0 +1,108 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1447871 - Test some service worker leak conditions</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="utils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+// Utility function to create a loaded iframe.
+async function withFrame(doc, url) {
+  let frame = doc.createElement('iframe');
+  frame.src = url;
+  doc.body.appendChild(frame);
+  await new Promise(resolve => frame.onload = resolve);
+  return frame;
+}
+
+// Manipulate service worker DOM objects in the frame's context.
+// Its important here that we create a listener callback from
+// the DOM objects back to the frame's global in order to
+// exercise the leak condition.
+async function useBroadcastChannel(name, contentWindow) {
+  contentWindow.messageCount = 0;
+
+  let outer = new BroadcastChannel(name);
+  outer.postMessage('foo');
+
+  let bc = new contentWindow.BroadcastChannel(name);
+  await new Promise(resolve => {
+    bc.onmessage = e => {
+      contentWindow.messageCount += 1;
+      resolve();
+    };
+  });
+
+  is(contentWindow.messageCount, 1, "message should be received");
+
+  outer.close();
+}
+
+// This function defines the basic form of the test cases.  We create an
+// iframe, manipulate some service worker DOM objects, remove the frame
+// from the DOM and then check to see if the frame was GC'd.  The caller
+// may optionally pass in a callback that will be executed with the
+// frame as an argument before removing it from the DOM.
+async function leakTest(name, callback) {
+  let frame = await withFrame(document, "about:blank");
+
+  await useBroadcastChannel(name, frame.contentWindow);
+
+  let weakRef = SpecialPowers.Cu.getWeakReference(frame.contentWindow);
+  ok(weakRef.get(), `should be able to create a weak reference - ${name}`);
+
+  if (callback) {
+    await callback(frame);
+  }
+
+  frame.remove();
+  frame = null;
+
+  await new Promise(resolve => SpecialPowers.exactGC(resolve));
+  ok(!weakRef.get(), `iframe content window should be garbage collected - ${name}`);
+}
+
+async function runTest() {
+  try {
+    // Test if we leak in the case where we do nothing special to
+    // te frame before removing it from the DOM.
+    await leakTest("default");
+
+    // Test the case where we navigate the frame before removing it
+    // from the DOM so that the service worker using window ends up
+    // in bfcache.
+    await leakTest("bfcache", frame => {
+      frame.src = "about:blank";
+      return new Promise(resolve => frame.onload = resolve);
+    });
+
+    // Test the case where we document.open() the frame before removing
+    // it from the DOM so that the service worker using window ends
+    // up getting replaced.
+    await leakTest("document.open()", frame => {
+      frame.contentDocument.open();
+      frame.contentDocument.close();
+    });
+  } catch (e) {
+    ok(false, e);
+  } finally {
+    SimpleTest.finish();
+  }
+}
+
+SimpleTest.waitForExplicitFinish();
+addEventListener("load", runTest, { once: true });
+</script>
+</pre>
+</body>
+</html>
+
