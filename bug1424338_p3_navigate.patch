# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bf7c817cbcea985cd2c11b3e77990c65574efce9
Bug 1424338 P3 Add ClientManager::Navigate() method. r=baku

diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -255,16 +255,17 @@
 #endif
 
 #ifdef MOZ_WEBSPEECH
 #include "mozilla/dom/SpeechSynthesis.h"
 #endif
 
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientSource.h"
+#include "mozilla/dom/ClientState.h"
 
 // Apple system headers seem to have a check() macro.  <sigh>
 #ifdef check
 class nsIScriptTimeoutHandler;
 #undef check
 #endif // check
 #include "AccessCheck.h"
 
@@ -2313,16 +2314,22 @@ nsPIDOMWindowInner::SyncStateFromParentW
 }
 
 Maybe<ClientInfo>
 nsPIDOMWindowInner::GetClientInfo() const
 {
   return Move(nsGlobalWindowInner::Cast(this)->GetClientInfo());
 }
 
+Maybe<ClientState>
+nsPIDOMWindowInner::GetClientState() const
+{
+  return Move(nsGlobalWindowInner::Cast(this)->GetClientState());
+}
+
 Maybe<ServiceWorkerDescriptor>
 nsPIDOMWindowInner::GetController() const
 {
   return Move(nsGlobalWindowInner::Cast(this)->GetController());
 }
 
 void
 nsGlobalWindowInner::UpdateTopInnerWindow()
@@ -6155,16 +6162,31 @@ nsGlobalWindowInner::GetClientInfo() con
   MOZ_ASSERT(NS_IsMainThread());
   Maybe<ClientInfo> clientInfo;
   if (mClientSource) {
     clientInfo.emplace(mClientSource->Info());
   }
   return Move(clientInfo);
 }
 
+Maybe<ClientState>
+nsGlobalWindowInner::GetClientState() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  Maybe<ClientState> clientState;
+  if (mClientSource) {
+    ClientState state;
+    nsresult rv = mClientSource->SnapshotState(&state);
+    if (NS_SUCCEEDED(rv)) {
+      clientState.emplace(state);
+    }
+  }
+  return Move(clientState);
+}
+
 Maybe<ServiceWorkerDescriptor>
 nsGlobalWindowInner::GetController() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   Maybe<ServiceWorkerDescriptor> controller;
   if (mClientSource) {
     controller = mClientSource->GetController();
   }
diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -344,16 +344,17 @@ public:
   void Resume();
   virtual bool IsSuspended() const override;
   void Freeze();
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
   mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
   virtual nsresult FireDelayedDOMEvents() override;
 
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
                                   nsISupports *aState,
                                   bool aForceReuseInnerWindow) override;
 
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -42,16 +42,17 @@ class nsXBLPrototypeHandler;
 
 typedef uint32_t SuspendTypes;
 
 namespace mozilla {
 class ThrottledEventQueue;
 namespace dom {
 class AudioContext;
 class ClientInfo;
+class ClientState;
 class DocGroup;
 class TabGroup;
 class Element;
 class Performance;
 class ServiceWorkerDescriptor;
 class ServiceWorkerRegistration;
 class Timeout;
 class TimeoutManager;
@@ -322,16 +323,17 @@ public:
   // Increase/Decrease the number of open WebSockets.
   void UpdateWebSocketCount(int32_t aDelta);
 
   // Return true if there are any open WebSockets that could block
   // timeout-throttling.
   bool HasOpenWebSockets() const;
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
   mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
   mozilla::dom::TabGroup* TabGroup();
 
   virtual nsPIDOMWindowOuter* GetPrivateRoot() = 0;
 
   virtual mozilla::dom::CustomElementRegistry* CustomElements() = 0;
 
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -62,16 +62,23 @@ struct ClientSourceExecutionReadyArgs
   FrameType frameType;
 };
 
 struct ClientControlledArgs
 {
   IPCServiceWorkerDescriptor serviceWorker;
 };
 
+struct ClientNavigateArgs
+{
+  IPCClientInfo target;
+  nsCString url;
+  nsCString baseURL;
+};
+
 union ClientEndPoint
 {
   IPCClientInfo;
   IPCServiceWorkerDescriptor;
 };
 
 struct ClientMatchAllArgs
 {
@@ -93,28 +100,32 @@ struct ClientGetInfoAndStateArgs
 
 struct ClientOpenWindowArgs
 {
 };
 
 union ClientOpConstructorArgs
 {
   ClientControlledArgs;
+  ClientNavigateArgs;
   ClientMatchAllArgs;
   ClientClaimArgs;
   ClientGetInfoAndStateArgs;
 };
 
 struct ClientList
 {
   ClientInfoAndState[] values;
 };
 
 struct ClientNavigateOpConstructorArgs
 {
+  PClientSource target;
+  nsCString url;
+  nsCString baseURL;
 };
 
 union ClientOpResult
 {
   nsresult;
   ClientInfoAndState;
   ClientList;
 };
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -279,10 +279,19 @@ ClientManager::Claim(const ClientClaimAr
 RefPtr<ClientOpPromise>
 ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
                                nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->StartOp(aArgs, aSerialEventTarget);
 }
 
+// static
+RefPtr<ClientOpPromise>
+ClientManager::Navigate(const ClientNavigateArgs& aArgs,
+                        nsISerialEventTarget* aSerialEventTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aSerialEventTarget);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -19,16 +19,17 @@ class PrincipalInfo;
 namespace dom {
 
 class ClientClaimArgs;
 class ClientGetInfoAndStateArgs;
 class ClientHandle;
 class ClientInfo;
 class ClientManagerChild;
 class ClientMatchAllArgs;
+class ClientNavigateArgs;
 class ClientOpConstructorArgs;
 class ClientSource;
 enum class ClientType : uint8_t;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
@@ -101,15 +102,19 @@ public:
 
   static RefPtr<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs, nsISerialEventTarget* aSerialEventTarget);
 
   static RefPtr<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
                   nsISerialEventTarget* aSerialEventTarget);
 
+  static RefPtr<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs,
+           nsISerialEventTarget* aSerialEventTarget);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -43,16 +43,22 @@ ClientManagerOpParent::ClientManagerOpPa
 {
   MOZ_DIAGNOSTIC_ASSERT(mService);
 }
 
 void
 ClientManagerOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientNavigateArgs:
+    {
+      DoServiceOp(&ClientManagerService::Navigate,
+                  aArgs.get_ClientNavigateArgs());
+      break;
+    }
     case ClientOpConstructorArgs::TClientMatchAllArgs:
     {
       DoServiceOp(&ClientManagerService::MatchAll,
                   aArgs.get_ClientMatchAllArgs());
       break;
     }
     case ClientOpConstructorArgs::TClientClaimArgs:
     {
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerService.h"
 
 #include "ClientManagerParent.h"
+#include "ClientNavigateOpParent.h"
 #include "ClientSourceParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/SystemGroup.h"
 #include "nsIAsyncShutdown.h"
 
 namespace mozilla {
@@ -297,16 +298,57 @@ void
 ClientManagerService::RemoveManager(ClientManagerParent* aManager)
 {
   AssertIsOnBackgroundThread();
   MOZ_DIAGNOSTIC_ASSERT(aManager);
   DebugOnly<bool> removed = mManagerList.RemoveElement(aManager);
   MOZ_ASSERT(removed);
 }
 
+RefPtr<ClientOpPromise>
+ClientManagerService::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.target().id(),
+                                          aArgs.target().principalInfo());
+  if (!source) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  PClientManagerParent* manager = source->Manager();
+  MOZ_DIAGNOSTIC_ASSERT(manager);
+
+  ClientNavigateOpConstructorArgs args;
+  args.url() = aArgs.url();
+  args.baseURL() = aArgs.baseURL();
+
+  // This is safe to do because the ClientSourceChild cannot directly delete
+  // itself.  Instead it sends a Teardown message to the parent which then
+  // calls delete.  That means we can be sure that we are not racing with
+  // source destruction here.
+  args.targetParent() = source;
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  ClientNavigateOpParent* op = new ClientNavigateOpParent(args, promise);
+  PClientNavigateOpParent* result =
+    manager->SendPClientNavigateOpConstructor(op, args);
+  if (!result) {
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise;
+  return ref.forget();
+}
+
 namespace
 {
 
 class PromiseListHolder final
 {
   RefPtr<ClientOpPromise::Private> mResultPromise;
   nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
   nsTArray<ClientInfoAndState> mResultList;
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -55,16 +55,19 @@ public:
 
   void
   AddManager(ClientManagerParent* aManager);
 
   void
   RemoveManager(ClientManagerParent* aManager);
 
   RefPtr<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
+  RefPtr<ClientOpPromise>
   MatchAll(const ClientMatchAllArgs& aArgs);
 
   RefPtr<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
   RefPtr<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -1,23 +1,290 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientNavigateOpChild.h"
 
+#include "ClientState.h"
+#include "mozilla/Unused.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellLoadInfo.h"
+#include "nsIWebNavigation.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsNetUtil.h"
+#include "nsPIDOMWindow.h"
+
 namespace mozilla {
 namespace dom {
 
+namespace {
+
+class NavigateLoadListener final : public nsIWebProgressListener
+                                 , public nsSupportsWeakReference
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  RefPtr<nsPIDOMWindowOuter> mOuterWindow;
+  nsCOMPtr<nsIURI> mBaseURL;
+
+  ~NavigateLoadListener() = default;
+
+public:
+  NavigateLoadListener(ClientOpPromise::Private* aPromise,
+                       nsPIDOMWindowOuter* aOuterWindow,
+                       nsIURI* aBaseURL)
+    : mPromise(aPromise)
+    , mOuterWindow(aOuterWindow)
+    , mBaseURL(aBaseURL)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mOuterWindow);
+    MOZ_DIAGNOSTIC_ASSERT(mBaseURL);
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aResult) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+        !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
+    if (!channel) {
+      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIURI> channelURL;
+    nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
+    if (NS_FAILED(rv)) {
+      mPromise->Reject(rv, __func__);
+      return NS_OK;
+    }
+
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_DIAGNOSTIC_ASSERT(ssm);
+
+    // If the resulting window is not same origin, then resolve immediately
+    // without returning any information about the new Client.  This is
+    // step 6.10 in the Client.navigate(url) spec.
+    rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      return NS_OK;
+    }
+
+    nsPIDOMWindowInner* innerWindow = mOuterWindow->GetCurrentInnerWindow();
+    MOZ_DIAGNOSTIC_ASSERT(innerWindow);
+
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
+
+    Maybe<ClientState> clientState = innerWindow->GetClientState();
+    MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
+
+    // Otherwise, if the new window is same-origin we want to return a
+    // ClientInfoAndState object so we can provide a Client snapshot
+    // to the caller.  This is step 6.11 and 6.12 in the Client.navigate(url)
+    // spec.
+    mPromise->Resolve(ClientInfoAndState(clientInfo.ref().ToIPC(),
+                                         clientState.ref().ToIPC()), __func__);
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   nsIURI* aLocation, uint32_t aFlags) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(NavigateLoadListener, nsIWebProgressListener,
+                                        nsISupportsWeakReference);
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientNavigateOpChild::DoNavigate(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+  nsCOMPtr<nsPIDOMWindowInner> window;
+
+  // Navigating the target client window will result in the original
+  // ClientSource being destroyed.  To avoid potential UAF mistakes
+  // we use a small scope to access the ClientSource object.  Once
+  // we have a strong reference to the window object we should not
+  // access the ClientSource again.
+  {
+    ClientSourceChild* targetActor =
+      static_cast<ClientSourceChild*>(aArgs.targetChild());
+    MOZ_DIAGNOSTIC_ASSERT(targetActor);
+
+    ClientSource* target = targetActor->GetSource();
+    if (!target) {
+      ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                             __func__);
+      return ref.forget();
+    }
+
+    window = target->GetInnerWindow();
+    if (!window) {
+      ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                             __func__);
+      return ref.forget();
+    }
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  mSerialEventTarget = window->EventTargetFor(TaskCategory::Other);
+
+  // In theory we could do the URL work before paying the IPC overhead
+  // cost, but in practice its easier to do it here.  The ClientHandle
+  // may be off-main-thread while this method is guaranteed to always
+  // be main thread.
+  nsCOMPtr<nsIURI> baseURL;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIURI> url;
+  rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  if (url->GetSpecOrDefault().EqualsLiteral("about:blank")) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+  if (!doc || !doc->IsActive()) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+  if (!principal) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+  if (!docShell || !webProgress) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
+  rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  loadInfo->SetTriggeringPrincipal(principal);
+  loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
+  loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContent);
+  loadInfo->SetSourceDocShell(docShell);
+  rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  nsCOMPtr<nsIWebProgressListener> listener =
+    new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_FAILED(rv)) {
+    promise->Reject(rv, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise.get();
+
+  ref->Then(mSerialEventTarget, __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+
+  return ref.forget();
+}
+
 void
 ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientNavigateOpChild::Init(const ClientNavigateOpConstructorArgs& aArgs)
 {
+  RefPtr<ClientOpPromise> promise = DoNavigate(aArgs);
+
+  // Normally we get the event target from the window in DoNavigate().  If a
+  // failure occurred, though, we may need to fall back to the current thread
+  // target.
+  if (!mSerialEventTarget) {
+    mSerialEventTarget = GetCurrentThreadSerialEventTarget();
+  }
+
+  // Capturing `this` is safe here since we clear the mPromiseRequestHolder in
+  // ActorDestroy.
+  promise->Then(mSerialEventTarget, __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+  })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpChild.h b/dom/clients/manager/ClientNavigateOpChild.h
--- a/dom/clients/manager/ClientNavigateOpChild.h
+++ b/dom/clients/manager/ClientNavigateOpChild.h
@@ -2,22 +2,29 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientNavigateOpChild_h
 #define _mozilla_dom_ClientNavigateOpChild_h
 
 #include "mozilla/dom/PClientNavigateOpChild.h"
+#include "ClientOpPromise.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientNavigateOpChild final : public PClientNavigateOpChild
 {
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
+
+  already_AddRefed<ClientOpPromise>
+  DoNavigate(const ClientNavigateOpConstructorArgs& aArgs);
+
   // PClientNavigateOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
 public:
   ClientNavigateOpChild() = default;
   ~ClientNavigateOpChild() = default;
 
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
--- a/dom/clients/manager/ClientNavigateOpParent.cpp
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -9,16 +9,20 @@
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ClientNavigateOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_DOM_ABORT_ERR, __func__);
+    mPromise = nullptr;
+  }
 }
 
 IPCResult
 ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
   if (aResult.type() == ClientOpResult::Tnsresult &&
       NS_FAILED(aResult.get_nsresult())) {
     mPromise->Reject(aResult.get_nsresult(), __func__);
