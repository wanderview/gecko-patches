# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  949ba573218084c9041cb6c5af75c1eda24480a6
Bug 1184607 P4 interdiff 002 dom/worker nits

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -263,17 +263,17 @@ RespondWithHandler::ResolvedCallback(JSC
   // Allow opaque response interception to be disabled until we can ensure the
   // security implications are not a complete disaster.
   if (response->Type() == ResponseType::Opaque &&
       !worker->OpaqueInterceptionEnabled()) {
     autoCancel.SetCancelStatus(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED);
     return;
   }
 
-  // Section 4.2, step 2.2:
+  // Section "HTTP Fetch", step 2.2:
   //  If one of the following conditions is true, return a network error:
   //    * response's type is "error".
   //    * request's mode is not "no-cors" and response's type is "opaque".
   //    * request is a client request and response's type is neither "basic"
   //      nor "default".
   //    * request is not a navigation request and response's type is
   //      "opaqueredirect".
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -88,16 +88,25 @@ static_assert(nsIHttpChannelInternal::CO
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_NO_CORS == static_cast<uint32_t>(RequestMode::No_cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS == static_cast<uint32_t>(RequestMode::Cors),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT == static_cast<uint32_t>(RequestMode::Cors_with_forced_preflight),
               "RequestMode enumeration value should match Necko CORS mode value.");
 
+static_assert(nsIHttpChannelInternal::REDIRECT_MODE_FOLLOW == static_cast<uint32_t>(RequestRedirect::Follow),
+              "RequestRedirect enumeration value should make Necko Redirect mode value.");
+static_assert(nsIHttpChannelInternal::REDIRECT_MODE_ERROR == static_cast<uint32_t>(RequestRedirect::Error),
+              "RequestRedirect enumeration value should make Necko Redirect mode value.");
+static_assert(nsIHttpChannelInternal::REDIRECT_MODE_MANUAL == static_cast<uint32_t>(RequestRedirect::Manual),
+              "RequestRedirect enumeration value should make Necko Redirect mode value.");
+static_assert(3 == static_cast<uint32_t>(RequestRedirect::EndGuard_),
+              "RequestRedirect enumeration value should make Necko Redirect mode value.");
+
 static StaticRefPtr<ServiceWorkerManager> gInstance;
 
 // Tracks the "dom.disable_open_click_delay" preference.  Modified on main
 // thread, read on worker threads. This is set once in the ServiceWorkerManager
 // constructor before any service workers are spawned.
 // It is updated every time a "notificationclick" event is dispatched. While
 // this is done without synchronization, at the worst, the thread will just get
 // an older value within which a popup is allowed to be displayed, which will
@@ -3709,31 +3718,20 @@ public:
         case nsIHttpChannelInternal::CORS_MODE_CORS:
         case nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT:
           mRequestMode = RequestMode::Cors;
           break;
         default:
           MOZ_CRASH("Unexpected CORS mode");
       }
 
+      // This is safe due to static_asserts at top of file.
       uint32_t redirectMode;
       internalChannel->GetRedirectMode(&redirectMode);
-      switch (redirectMode) {
-        case nsIHttpChannelInternal::REDIRECT_MODE_FOLLOW:
-          mRequestRedirect = RequestRedirect::Follow;
-          break;
-        case nsIHttpChannelInternal::REDIRECT_MODE_ERROR:
-          mRequestRedirect = RequestRedirect::Error;
-          break;
-        case nsIHttpChannelInternal::REDIRECT_MODE_MANUAL:
-          mRequestRedirect = RequestRedirect::Manual;
-          break;
-        default:
-          MOZ_CRASH("Unexpected redirect mode");
-      }
+      mRequestRedirect = static_cast<RequestRedirect>(redirectMode);
 
       if (loadFlags & nsIRequest::LOAD_ANONYMOUS) {
         mRequestCredentials = RequestCredentials::Omit;
       } else {
         bool includeCrossOrigin;
         internalChannel->GetCorsIncludeCredentials(&includeCrossOrigin);
         if (includeCrossOrigin) {
           mRequestCredentials = RequestCredentials::Include;
