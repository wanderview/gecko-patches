# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  175de660e9d152afbfc8cc9959ab4fd149292a8d
Bug 1436812 P4 Factor out a method for checking global validity in ServiceWorkerContainer to reduce code duplication. r=baku

diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -248,41 +248,30 @@ ServiceWorkerContainer::GetRegistrations
   MOZ_ASSERT(ret);
   return ret.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerContainer::GetRegistration(const nsAString& aURL,
                                         ErrorResult& aRv)
 {
-  nsPIDOMWindowInner* window = GetOwner();
-  if (NS_WARN_IF(!window)) {
+  nsIGlobalObject* global = GetGlobalIfValid(aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(global);
+  if (!window) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  // Don't allow a service worker to access service worker registrations
-  // from a window with storage disabled.  If these windows can access
-  // the registration it increases the chance they can bypass the storage
-  // block via postMessage(), etc.
-  auto storageAllowed = nsContentUtils::StorageAllowedForWindow(window);
-  if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
-    nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
-    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
-                                    NS_LITERAL_CSTRING("Service Workers"), doc,
-                                    nsContentUtils::eDOM_PROPERTIES,
-                                    "ServiceWorkerGetRegistrationStorageError");
-    aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
-    return nullptr;
-  }
-
-  // Don't allow service workers to register when the *document* is chrome for
-  // now.
-  MOZ_ASSERT(!nsContentUtils::IsSystemPrincipal(window->GetExtantDoc()->NodePrincipal()));
-
+  // It would be nice not to require a window here, but right
+  // now we don't have a great way to get the base URL just
+  // from the nsIGlobalObject.
   Maybe<ClientInfo> clientInfo = window->GetClientInfo();
   if (clientInfo.isNothing()) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
   nsIDocument* doc = window->GetExtantDoc();
   if (!doc) {
@@ -313,24 +302,32 @@ ServiceWorkerContainer::GetRegistration(
     return nullptr;
   }
 
   RefPtr<ServiceWorkerContainer> self = this;
 
   mInner->GetRegistration(clientInfo.ref(), spec)->Then(
     window->EventTargetFor(TaskCategory::Other), __func__,
     [self, outer] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
-      nsIGlobalObject* global = self->GetParentObject();
-      NS_ENSURE_TRUE_VOID(global);
+      ErrorResult rv;
+      nsIGlobalObject* global = self->GetGlobalIfValid(rv);
+      if (rv.Failed()) {
+        outer->MaybeReject(rv);
+        return;
+      }
       RefPtr<ServiceWorkerRegistration> reg =
         global->GetOrCreateServiceWorkerRegistration(aDescriptor);
       outer->MaybeResolve(reg);
     }, [self, outer] (nsresult aRv) {
-      nsIGlobalObject* global = self->GetParentObject();
-      NS_ENSURE_TRUE_VOID(global);
+      ErrorResult rv;
+      Unused << self->GetGlobalIfValid(rv);
+      if (rv.Failed()) {
+        outer->MaybeReject(rv);
+        return;
+      }
       if (NS_SUCCEEDED(aRv)) {
         outer->MaybeResolveWithUndefined();
         return;
       }
       outer->MaybeReject(aRv);
     });
 
   return outer.forget();
@@ -338,42 +335,46 @@ ServiceWorkerContainer::GetRegistration(
 
 Promise*
 ServiceWorkerContainer::GetReady(ErrorResult& aRv)
 {
   if (mReadyPromise) {
     return mReadyPromise;
   }
 
-  nsIGlobalObject* global = GetParentObject();
-  if (!global) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+  nsIGlobalObject* global = GetGlobalIfValid(aRv);
+  if (aRv.Failed()) {
     return nullptr;
   }
+  MOZ_DIAGNOSTIC_ASSERT(global);
 
   Maybe<ClientInfo> clientInfo(global->GetClientInfo());
   if (clientInfo.isNothing()) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  mReadyPromise = Promise::Create(GetParentObject(), aRv);
+  mReadyPromise = Promise::Create(global, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   RefPtr<ServiceWorkerContainer> self = this;
   RefPtr<Promise> outer = mReadyPromise;
 
   mInner->GetReady(clientInfo.ref())->Then(
     global->EventTargetFor(TaskCategory::Other), __func__,
     [self, outer] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
       self->mReadyPromiseHolder.Complete();
-      nsIGlobalObject* global = self->GetParentObject();
-      NS_ENSURE_TRUE_VOID(global);
+      ErrorResult rv;
+      nsIGlobalObject* global = self->GetGlobalIfValid(rv);
+      if (rv.Failed()) {
+        outer->MaybeReject(rv);
+        return;
+      }
       RefPtr<ServiceWorkerRegistration> reg =
         global->GetOrCreateServiceWorkerRegistration(aDescriptor);
       NS_ENSURE_TRUE_VOID(reg);
       outer->MaybeResolve(reg);
     }, [self, outer] (nsresult aRv) {
       self->mReadyPromiseHolder.Complete();
       outer->MaybeReject(aRv);
     })->Track(mReadyPromiseHolder);
@@ -404,10 +405,42 @@ ServiceWorkerContainer::GetScopeForUrl(c
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
   aRv = swm->GetScopeForUrl(doc->NodePrincipal(),
                             aUrl, aScope);
 }
 
+nsIGlobalObject*
+ServiceWorkerContainer::GetGlobalIfValid(ErrorResult& aRv) const
+{
+  // For now we require a window since ServiceWorkerContainer is
+  // not exposed on worker globals yet.  The main thing we need
+  // to fix here to support that is the storage access check via
+  // the nsIGlobalObject.
+  nsPIDOMWindowInner* window = GetOwner();
+  if (NS_WARN_IF(!window)) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  // Don't allow a service worker to access service worker registrations
+  // from a window with storage disabled.  If these windows can access
+  // the registration it increases the chance they can bypass the storage
+  // block via postMessage(), etc.
+  auto storageAllowed = nsContentUtils::StorageAllowedForWindow(window);
+  if (NS_WARN_IF(storageAllowed != nsContentUtils::StorageAccess::eAllow)) {
+    nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+    nsContentUtils::ReportToConsole(nsIScriptError::errorFlag,
+                                    NS_LITERAL_CSTRING("Service Workers"), doc,
+                                    nsContentUtils::eDOM_PROPERTIES,
+                                    "ServiceWorkerGetRegistrationStorageError");
+    aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
+    return nullptr;
+  }
+  MOZ_ASSERT(!nsContentUtils::IsSystemPrincipal(window->GetExtantDoc()->NodePrincipal()));
+
+  return window->AsGlobal();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerContainer.h b/dom/serviceworkers/ServiceWorkerContainer.h
--- a/dom/serviceworkers/ServiceWorkerContainer.h
+++ b/dom/serviceworkers/ServiceWorkerContainer.h
@@ -88,16 +88,19 @@ public:
   void
   ControllerChanged(ErrorResult& aRv);
 
 private:
   ServiceWorkerContainer(nsIGlobalObject* aGlobal, Inner* aInner);
 
   ~ServiceWorkerContainer();
 
+  nsIGlobalObject*
+  GetGlobalIfValid(ErrorResult& aRv) const;
+
   RefPtr<Inner> mInner;
 
   // This only changes when a worker hijacks everything in its scope by calling
   // claim.
   RefPtr<ServiceWorker> mControllerWorker;
 
   RefPtr<Promise> mReadyPromise;
   MozPromiseRequestHolder<ServiceWorkerRegistrationPromise> mReadyPromiseHolder;
