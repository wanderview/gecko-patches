# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bcbc5618e2943ee8f48530eef3d8c200db429624
Bug 1204254 P4 Dispatch the StartResponse runnable when body copying begins. r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -382,41 +382,29 @@ private:
     }
   }
 };
 
 struct RespondWithClosure
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
-  RefPtr<InternalResponse> mInternalResponse;
-  ChannelInfo mWorkerChannelInfo;
-  const nsCString mScriptSpec;
-  const nsCString mResponseURLSpec;
   const nsString mRequestURL;
   const nsCString mRespondWithScriptSpec;
   const uint32_t mRespondWithLineNumber;
   const uint32_t mRespondWithColumnNumber;
 
   RespondWithClosure(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
-                     InternalResponse* aInternalResponse,
-                     const ChannelInfo& aWorkerChannelInfo,
-                     const nsCString& aScriptSpec,
-                     const nsACString& aResponseURLSpec,
                      const nsAString& aRequestURL,
                      const nsACString& aRespondWithScriptSpec,
                      uint32_t aRespondWithLineNumber,
                      uint32_t aRespondWithColumnNumber)
     : mInterceptedChannel(aChannel)
     , mRegistration(aRegistration)
-    , mInternalResponse(aInternalResponse)
-    , mWorkerChannelInfo(aWorkerChannelInfo)
-    , mScriptSpec(aScriptSpec)
-    , mResponseURLSpec(aResponseURLSpec)
     , mRequestURL(aRequestURL)
     , mRespondWithScriptSpec(aRespondWithScriptSpec)
     , mRespondWithLineNumber(aRespondWithLineNumber)
     , mRespondWithColumnNumber(aRespondWithColumnNumber)
   {
   }
 };
 
@@ -428,28 +416,16 @@ void RespondWithCopyComplete(void* aClos
     AsyncLog(data->mInterceptedChannel, data->mRespondWithScriptSpec,
              data->mRespondWithLineNumber, data->mRespondWithColumnNumber,
              NS_LITERAL_CSTRING("InterceptionFailedWithURL"),
              data->mRequestURL);
     event = new CancelChannelRunnable(data->mInterceptedChannel,
                                       data->mRegistration,
                                       NS_ERROR_INTERCEPTION_FAILED);
   } else {
-    event = new StartResponse(data->mInterceptedChannel,
-                              data->mInternalResponse,
-                              data->mWorkerChannelInfo,
-                              data->mScriptSpec,
-                              data->mResponseURLSpec);
-    WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
-    if (worker) {
-      MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(event.forget()));
-    } else {
-      MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(event.forget()));
-    }
-
     event = new FinishResponse(data->mInterceptedChannel);
   }
 
   // In theory this can happen after the worker thread is terminated.
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   if (worker) {
     MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(event.forget()));
   } else {
@@ -665,21 +641,25 @@ RespondWithHandler::ResolvedCallback(JSC
   // cross-origin responses, which are treated as same-origin by consumers.
   nsCString responseURL;
   if (response->Type() == ResponseType::Opaque) {
     responseURL = ir->GetUnfilteredURL();
     if (NS_WARN_IF(responseURL.IsEmpty())) {
       return;
     }
   }
+
+  nsCOMPtr<nsIRunnable> startRunnable = new StartResponse(mInterceptedChannel,
+                                                          ir,
+                                                          worker->GetChannelInfo(),
+                                                          mScriptSpec,
+                                                          responseURL);
+
   nsAutoPtr<RespondWithClosure> closure(new RespondWithClosure(mInterceptedChannel,
-                                                               mRegistration, ir,
-                                                               worker->GetChannelInfo(),
-                                                               mScriptSpec,
-                                                               responseURL,
+                                                               mRegistration,
                                                                mRequestURL,
                                                                mRespondWithScriptSpec,
                                                                mRespondWithLineNumber,
                                                                mRespondWithColumnNumber));
   nsCOMPtr<nsIInputStream> body;
   ir->GetUnfilteredBody(getter_AddRefs(body));
   // Errors and redirects may not have a body.
   if (body) {
@@ -715,24 +695,34 @@ RespondWithHandler::ResolvedCallback(JSC
       responseBody = buffered;
     }
 
     nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
     if (NS_WARN_IF(!stsThread)) {
       return;
     }
 
+    // Note, we cannot use the worker main thread event target here.  We must
+    // ensure the start runnable fires before the finish runnable.  The finish
+    // runnable, though, sometimes gets dispatched from places other than the
+    // worker thread (like at the end of copying).  Therefore it does not
+    // use the worker main thread event target either.
+    MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other,
+                                              startRunnable.forget()));
+
     // XXXnsm, Fix for Bug 1141332 means that if we decide to make this
     // streaming at some point, we'll need a different solution to that bug.
     rv = NS_AsyncCopy(body, responseBody, stsThread, NS_ASYNCCOPY_VIA_WRITESEGMENTS,
                       kCopySegmentSize, RespondWithCopyComplete, closure.forget());
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return;
     }
   } else {
+    MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other,
+                                              startRunnable.forget()));
     RespondWithCopyComplete(closure.forget(), NS_OK);
   }
 
   MOZ_ASSERT(!closure);
   autoCancel.Reset();
   mRequestWasHandled = true;
 }
 
