# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  50909c8645194fb8c8fc671ca13fc477e0c58667
Bug 1363829 P12 Prevent setTimeout() from firing early by removing TimeoutExecutor flex time. r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -21,17 +21,17 @@ TimeoutExecutor::~TimeoutExecutor()
 }
 
 nsresult
 TimeoutExecutor::ScheduleImmediate(const TimeStamp& aDeadline,
                                    const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
-  MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow + mFlexTime);
+  MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow);
 
   nsresult rv =
     mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Immediate;
   mDeadline = aDeadline;
 
@@ -39,17 +39,17 @@ TimeoutExecutor::ScheduleImmediate(const
 }
 
 nsresult
 TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
                                  const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
-  MOZ_DIAGNOSTIC_ASSERT(aDeadline > aNow + mFlexTime);
+  MOZ_DIAGNOSTIC_ASSERT(aDeadline > aNow);
 
   nsresult rv = NS_OK;
 
   if (!mTimer) {
     mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
@@ -65,17 +65,17 @@ TimeoutExecutor::ScheduleDelayed(const T
   // favor rounding down here.  If we fire early we will simply be rescheduled
   // for an immediate runnable or a 0-ms timer.  This ends up giving us the
   // most accurate firing time at the cost of a few more runnables.  This cost
   // is only incurred when the browser is idle, though.  When the busy main
   // thread is busy there will be a delay and we won't actually be early.
   // TODO: In the future we could pass a precision argument in and round
   //       up here for low-precision background timers.  We don't really care
   //       if those timers fire late.
-  TimeDuration delay(aDeadline - (aNow + mFlexTime));
+  TimeDuration delay(aDeadline - aNow - TimeDuration::FromMilliseconds(0.1));
   rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
@@ -84,17 +84,17 @@ TimeoutExecutor::ScheduleDelayed(const T
 nsresult
 TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
 {
   TimeStamp now(TimeStamp::Now());
 
   // Schedule an immediate runnable if the desired deadline has passed
   // or is slightly in the future.  This is similar to how nsITimer will
   // fire timers early based on the interval resolution.
-  if (aDeadline <= (now + mFlexTime)) {
+  if (aDeadline <= now) {
     return ScheduleImmediate(aDeadline, now);
   }
 
   return ScheduleDelayed(aDeadline, now);
 }
 
 nsresult
 TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
@@ -127,28 +127,27 @@ TimeoutExecutor::MaybeExecute()
 
   TimeStamp deadline(mDeadline);
 
   // Sometimes nsITimer or canceled timers will fire too early.  If this
   // happens then just cap our deadline to our maximum time in the future
   // and proceed.  If there are no timers ready we will get rescheduled
   // by TimeoutManager.
   TimeStamp now(TimeStamp::Now());
-  if (deadline > now + mFlexTime) {
-    deadline = now + mFlexTime;
+  if (deadline > now) {
+    deadline = now;
   }
 
   Cancel();
 
   mOwner->RunTimeout(now, deadline);
 }
 
 TimeoutExecutor::TimeoutExecutor(TimeoutManager* aOwner)
   : mOwner(aOwner)
-  , mFlexTime(TimeDuration::FromMilliseconds(0.1))
   , mMode(Mode::None)
 {
   MOZ_DIAGNOSTIC_ASSERT(mOwner);
 }
 
 void
 TimeoutExecutor::Shutdown()
 {
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
--- a/dom/base/TimeoutExecutor.h
+++ b/dom/base/TimeoutExecutor.h
@@ -16,17 +16,16 @@ namespace dom {
 
 class TimeoutExecutor final : public nsIRunnable
                             , public nsITimerCallback
                             , public nsINamed
 {
   TimeoutManager* mOwner;
   nsCOMPtr<nsITimer> mTimer;
   TimeStamp mDeadline;
-  const TimeDuration mFlexTime;
 
   enum class Mode
   {
     None,
     Immediate,
     Delayed,
     Shutdown
   };
