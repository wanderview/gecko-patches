# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bd880313bbad8ae34ac4558bead4a5dc57477012
Bug 1293277 P1 Add a ref-counted WorkerHolderToken() class. r=baku

diff --git a/dom/workers/WorkerHolderToken.cpp b/dom/workers/WorkerHolderToken.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.cpp
@@ -0,0 +1,109 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "WorkerHolderToken.h"
+
+#include "WorkerPrivate.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+// static
+already_AddRefed<WorkerHolderToken>
+WorkerHolderToken::Create(WorkerPrivate* aWorkerPrivate, Status aShutdownStatus,
+                          Behavior aBehavior)
+{
+  MOZ_ASSERT(aWorkerPrivate);
+
+  RefPtr<WorkerHolderToken> workerHolder =
+    new WorkerHolderToken(aShutdownStatus, aBehavior);
+
+  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, aShutdownStatus))) {
+    return nullptr;
+  }
+
+  return workerHolder.forget();
+}
+
+void
+WorkerHolderToken::AddListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+
+  // Allow an actor to be added after we've entered the Notifying case.  We
+  // can't stop the actor creation from racing with out destruction of the
+  // other actors and we need to wait for this extra one to close as well.
+  // Signal it should destroy itself right away.
+  if (mShuttingDown) {
+    aListener->WorkerShuttingDown();
+  }
+}
+
+void
+WorkerHolderToken::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(aListener);
+
+  DebugOnly<bool> removed = mListenerList.RemoveElement(aListener);
+
+  MOZ_ASSERT(removed);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+}
+
+bool
+WorkerHolderToken::IsShuttingDown() const
+{
+  return mShuttingDown;
+}
+
+WorkerPrivate*
+WorkerHolderToken::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  return mWorkerPrivate;
+}
+
+WorkerHolderToken::WorkerHolderToken(Status aShutdownStatus,
+                                     Behavior aBehavior)
+  : WorkerHolder(aBehavior)
+  , mShutdownStatus(aShutdownStatus)
+  , mShuttingDown(false)
+{
+}
+
+WorkerHolderToken::~WorkerHolderToken()
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+bool
+WorkerHolderToken::Notify(Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(WorkerHolderToken);
+
+  // When the service worker thread is stopped we will get Terminating,
+  // but nothing higher than that.  We must shut things down at Terminating.
+  if (aStatus < mShutdownStatus || mShuttingDown) {
+    return true;
+  }
+
+  mShuttingDown = true;
+
+  // Start the asynchronous destruction of our actors.  These will call back
+  // into RemoveActor() once the actor is destroyed.
+  for (uint32_t i = 0; i < mListenerList.Length(); ++i) {
+    mListenerList[i]->WorkerShuttingDown();
+  }
+
+  return true;
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/WorkerHolderToken.h b/dom/workers/WorkerHolderToken.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/WorkerHolderToken.h
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_WorkerHolderToken_h
+#define mozilla_dom_workers_WorkerHolderToken_h
+
+#include "nsISupportsImpl.h"
+#include "nsTArray.h"
+#include "WorkerHolder.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+class WorkerPrivate;
+
+// This is a ref-counted WorkerHolder implementation.  If you wish
+// to be notified of worker shutdown beginning, then you can implement
+// the Listener interface and call AddListener().
+//
+// This is purely a convenience class to avoid requiring code to
+// extend WorkerHolder all the time.
+class WorkerHolderToken final : public WorkerHolder
+{
+public:
+  // Pure virtual class defining the interface for objects that
+  // wish to be notified of worker shutdown.
+  class Listener
+  {
+  public:
+    virtual void
+    WorkerShuttingDown() = 0;
+  };
+
+  // Attempt to create a WorkerHolderToken().  If the shutdown has already
+  // passed the given shutdown phase or fails for another reason then
+  // nullptr is returned.
+  static already_AddRefed<WorkerHolderToken>
+  Create(workers::WorkerPrivate* aWorkerPrivate, Status aShutdownStatus,
+         Behavior aBehavior = PreventIdleShutdownStart);
+
+  // Add a listener to the token.  Note, this does not hold a strong
+  // reference to the listener.  You must call RemoveListener() before
+  // the listener is destroyed.  This can only be called on the owning
+  // worker thread.
+  void
+  AddListener(Listener* aListener);
+
+  // Remove a previously added listener.  This can only be called on the
+  // owning worker thread.
+  void
+  RemoveListener(Listener* aListener);
+
+  bool
+  IsShuttingDown() const;
+
+  WorkerPrivate*
+  GetWorkerPrivate() const;
+
+private:
+  WorkerHolderToken(Status aShutdownStatus, Behavior aBehavior);
+
+  ~WorkerHolderToken();
+
+  // WorkerHolder methods
+  virtual bool
+  Notify(workers::Status aStatus) override;
+
+  nsTArray<Listener*> mListenerList;
+  const Status mShutdownStatus;
+  bool mShuttingDown;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(WorkerHolderToken)
+};
+
+END_WORKERS_NAMESPACE
+
+#endif // mozilla_dom_workers_WorkerHolderToken_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -35,16 +35,17 @@ EXPORTS.mozilla.dom.workers += [
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'ServiceWorker.h',
     'ServiceWorkerClient.h',
     'ServiceWorkerClients.h',
     'ServiceWorkerWindowClient.h',
     'SharedWorker.h',
     'WorkerHolder.h',
+    'WorkerHolderToken.h',
 ]
 
 XPIDL_MODULE = 'dom_workers'
 
 XPIDL_SOURCES += [
     'nsIWorkerDebugger.idl',
     'nsIWorkerDebuggerManager.idl',
 ]
@@ -77,16 +78,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerUpdaterChild.cpp',
     'ServiceWorkerUpdaterParent.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerHolder.cpp',
+    'WorkerHolderToken.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
