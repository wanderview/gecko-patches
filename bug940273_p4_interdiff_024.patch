# HG changeset patch
# Parent 0b6be233533543bcf1f4bf240dd4fccf78287bb6
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 024 Manager and ShutdownObserver issues.

diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -70,17 +70,24 @@ CacheStorageParent::RecvMatch(const Requ
     Entry* entry = mPendingRequests.AppendElement();
     entry->mOp = OP_MATCH;
     entry->mRequestId = aRequestId;
     entry->mRequest = aRequest;
     entry->mParams = aParams;
     return true;
   }
 
-  cache::Manager* manager = RequestManager(aRequestId);
+  nsRefPtr<cache::Manager> manager;
+  nsresult rv = RequestManager(aRequestId, getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    PCacheResponseOrVoid response = void_t();
+    unused << SendMatchResponse(aRequestId, rv, response);
+    return true;
+  }
+
   manager->StorageMatch(this, aRequestId, mNamespace, aRequest,
                         aParams);
 
   return true;
 }
 
 bool
 CacheStorageParent::RecvHas(const RequestId& aRequestId, const nsString& aKey)
@@ -88,34 +95,46 @@ CacheStorageParent::RecvHas(const Reques
   if (!mManagerId) {
     Entry* entry = mPendingRequests.AppendElement();
     entry->mOp = OP_HAS;
     entry->mRequestId = aRequestId;
     entry->mKey = aKey;
     return true;
   }
 
-  cache::Manager* manager = RequestManager(aRequestId);
+  nsRefPtr<cache::Manager> manager;
+  nsresult rv = RequestManager(aRequestId, getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendHasResponse(aRequestId, rv, false);
+    return true;
+  }
+
   manager->StorageHas(this, aRequestId, mNamespace, aKey);
 
   return true;
 }
 
 bool
 CacheStorageParent::RecvOpen(const RequestId& aRequestId, const nsString& aKey)
 {
   if (!mManagerId) {
     Entry* entry = mPendingRequests.AppendElement();
     entry->mOp = OP_OPEN;
     entry->mRequestId = aRequestId;
     entry->mKey = aKey;
     return true;
   }
 
-  cache::Manager* manager = RequestManager(aRequestId);
+  nsRefPtr<cache::Manager> manager;
+  nsresult rv = RequestManager(aRequestId, getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendOpenResponse(aRequestId, rv, nullptr);
+    return true;
+  }
+
   manager->StorageOpen(this, aRequestId, mNamespace, aKey);
 
   return true;
 }
 
 bool
 CacheStorageParent::RecvDelete(const RequestId& aRequestId,
                                const nsString& aKey)
@@ -123,33 +142,45 @@ CacheStorageParent::RecvDelete(const Req
   if (!mManagerId) {
     Entry* entry = mPendingRequests.AppendElement();
     entry->mOp = OP_DELETE;
     entry->mRequestId = aRequestId;
     entry->mKey = aKey;
     return true;
   }
 
-  cache::Manager* manager = RequestManager(aRequestId);
+  nsRefPtr<cache::Manager> manager;
+  nsresult rv = RequestManager(aRequestId, getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendDeleteResponse(aRequestId, rv, false);
+    return true;
+  }
+
   manager->StorageDelete(this, aRequestId, mNamespace, aKey);
 
   return true;
 }
 
 bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
   if (!mManagerId) {
     Entry* entry = mPendingRequests.AppendElement();
     entry->mOp = OP_DELETE;
     entry->mRequestId = aRequestId;
     return true;
   }
 
-  cache::Manager* manager = RequestManager(aRequestId);
+  nsRefPtr<cache::Manager> manager;
+  nsresult rv = RequestManager(aRequestId, getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendKeysResponse(aRequestId, rv, nsTArray<nsString>());
+    return true;
+  }
+
   manager->StorageKeys(this, aRequestId, mNamespace);
 
   return true;
 }
 
 void
 CacheStorageParent::OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)
 {
@@ -298,27 +329,31 @@ CacheStorageParent::FailPendingRequests(
       }
       default:
         MOZ_ASSERT_UNREACHABLE("Pending request within unknown op");
     }
   }
   mPendingRequests.Clear();
 }
 
-cache::Manager*
-CacheStorageParent::RequestManager(RequestId aRequestId)
+nsresult
+CacheStorageParent::RequestManager(RequestId aRequestId,
+                                   cache::Manager** aManagerOut)
 {
   MOZ_ASSERT(!mActiveRequests.Contains(aRequestId));
-  if (!mManager) {
+  nsRefPtr<cache::Manager> ref = mManager;
+  if (!ref) {
     MOZ_ASSERT(mActiveRequests.IsEmpty());
-    mManager = Manager::GetOrCreate(mManagerId);
-    MOZ_ASSERT(mManager);
+    nsresult rv = cache::Manager::GetOrCreate(mManagerId, getter_AddRefs(ref));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    mManager = ref;
   }
   mActiveRequests.AppendElement(aRequestId);
-  return mManager;
+  ref.forget(aManagerOut);
+  return NS_OK;
 }
 
 void
 CacheStorageParent::ReleaseManager(RequestId aRequestId)
 {
   // Note that if the child process dies we also clean up the mManager in
   // ActorDestroy().  There is no race with this method, however, because
   // ActorDestroy removes this object from the Manager's listener list.
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -65,17 +65,17 @@ private:
   CacheStreamControlParent*
   SerializeReadStream(CacheStreamControlParent *aStreamControl, const nsID& aId,
                       StreamList* aStreamList,
                       PCacheReadStream* aReadStreamOut);
 
   void RetryPendingRequests();
   void FailPendingRequests(nsresult aRv);
 
-  cache::Manager* RequestManager(RequestId aRequestId);
+  nsresult RequestManager(RequestId aRequestId, cache::Manager** aManagerOut);
   void ReleaseManager(RequestId aRequestId);
 
   const Namespace mNamespace;
   nsRefPtr<PrincipalVerifier> mVerifier;
   nsRefPtr<ManagerId> mManagerId;
   nsRefPtr<cache::Manager> mManager;
 
   enum Op
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1,16 +1,18 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
+#include "mozilla/ClearOnShutdown.h"
+#include "mozilla/StaticPtr.h"
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/StreamList.h"
@@ -21,21 +23,25 @@
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
 
 namespace {
 
+using mozilla::dom::cache::Action;
 using mozilla::dom::cache::DBSchema;
 using mozilla::dom::cache::FileUtils;
 using mozilla::dom::cache::QuotaInfo;
 using mozilla::dom::cache::SyncDBAction;
 
+// An Action that is executed when a Context is first created.  It ensures that
+// the directory and database are setup properly.  This lets other actions
+// not worry about these details.
 class SetupAction MOZ_FINAL : public SyncDBAction
 {
 public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
@@ -57,131 +63,30 @@ public:
     rv = DBSchema::CreateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
-
-private:
-  virtual ~SetupAction() { }
 };
 
-} // anonymous namespace
+// ----------------------------------------------------------------------------
 
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-class Manager::Factory
-{
-private:
-  static Factory* sFactory;
-  nsTArray<Manager*> mManagerList;
-
-public:
-  static Factory& Instance()
-  {
-    mozilla::ipc::AssertIsOnBackgroundThread();
-
-    if (!sFactory) {
-      sFactory = new Factory();
-    }
-    return *sFactory;
-  }
-
-  already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId)
-  {
-    mozilla::ipc::AssertIsOnBackgroundThread();
-
-    nsRefPtr<Manager> ref = Get(aManagerId);
-    if (!ref) {
-      ref = new Manager(aManagerId);
-      mManagerList.AppendElement(ref);
-    }
-
-    return ref.forget();
-  }
-
-  already_AddRefed<Manager> Get(ManagerId* aManagerId)
-  {
-    mozilla::ipc::AssertIsOnBackgroundThread();
-
-    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
-      if (*mManagerList[i]->mManagerId == *aManagerId) {
-        nsRefPtr<Manager> ref = mManagerList[i];
-        return ref.forget();
-      }
-    }
-
-    return nullptr;
-  }
-
-  void Remove(Manager* aManager)
-  {
-    mozilla::ipc::AssertIsOnBackgroundThread();
-    MOZ_ASSERT(aManager);
-
-    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
-      if (mManagerList[i] == aManager) {
-        mManagerList.RemoveElementAt(i);
-
-        if (mManagerList.IsEmpty()) {
-          delete sFactory;
-          sFactory = nullptr;
-        }
-        return;
-      }
-    }
-  }
-};
-
-// static
-Manager::Factory* Manager::Factory::sFactory = nullptr;
-
-class Manager::BaseAction : public SyncDBAction
-{
-protected:
-  BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
-    : SyncDBAction(DBAction::Existing)
-    , mManager(aManager)
-    , mListenerId(aListenerId)
-    , mRequestId (aRequestId)
-  { }
-
-  virtual void
-  Complete(Listener* aListener, nsresult aRv) = 0;
-
-  virtual void
-  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    Listener* listener = mManager->GetListener(mListenerId);
-    if (!listener) {
-      return;
-    }
-    Complete(listener, aRv);
-    mManager = nullptr;
-  }
-
-  virtual ~BaseAction() { }
-  nsRefPtr<Manager> mManager;
-  const ListenerId mListenerId;
-  const RequestId mRequestId;
-};
-
-class Manager::DeleteOrphanedBodyAction MOZ_FINAL : public Action
+// Action that is executed when we determine that content has stopped using
+// a body file that has been orphaned.
+class DeleteOrphanedBodyAction MOZ_FINAL : public Action
 {
 public:
-  DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
+  explicit DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
     : mDeletedBodyIdList(aDeletedBodyIdList)
   { }
 
-  DeleteOrphanedBodyAction(const nsID& aBodyId)
+  explicit DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
     mDeletedBodyIdList.AppendElement(aBodyId);
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
@@ -196,31 +101,207 @@ public:
 
     rv = dbDir->Append(NS_LITERAL_STRING("cache"));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
     rv = FileUtils::BodyDeleteFiles(dbDir, mDeletedBodyIdList);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      aResolver->Resolve(rv);
-      return;
-    }
+    NS_WARN_IF(NS_FAILED(rv));
 
     aResolver->Resolve(rv);
   }
 
+  // We run synchronously, so there is nothing to do when canceled.
   virtual void CancelOnTarget() { }
 
 private:
-  virtual ~DeleteOrphanedBodyAction() { }
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// ----------------------------------------------------------------------------
+
+// Singleton class to track Manager instances and ensure there is only
+// one for each unique ManagerId.
+class Manager::Factory
+{
+public:
+  friend class StaticAutoPtr<Manager::Factory>;
+
+  static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance.  This forces the Get() call
+    // below to use the same factory.
+    MaybeCreateInstance();
+
+    nsRefPtr<Manager> ref = Get(aManagerId);
+    if (!ref) {
+      nsresult rv = shutdown::AddManagerId(aManagerId);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      // TODO: replace this with a thread pool (bug 1119864)
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("DOMCacheThread", getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      ref = new Manager(aManagerId, ioThread);
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<Manager> Get(ManagerId* aManagerId)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    MaybeCreateInstance();
+
+    for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
+      if (*sFactory->mManagerList[i]->mManagerId == *aManagerId) {
+        nsRefPtr<Manager> ref = sFactory->mManagerList[i];
+        return ref.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    MaybeCreateInstance();
+
+    for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
+      if (sFactory->mManagerList[i] == aManager) {
+        sFactory->mManagerList.RemoveElementAt(i);
+
+        // clean up the factory singleton if there are no more managers
+        if (sFactory->mManagerList.IsEmpty()) {
+          sFactory = nullptr;
+        }
+
+        return;
+      }
+    }
+
+    MOZ_ASSERT_UNREACHABLE("Factory does not know about this Manager!");
+  }
+
+  static void ShutdownAll()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
+      sFactory->mManagerList[i]->Shutdown();
+    }
+  }
+
+private:
+  Factory()
+  {
+    MOZ_COUNT_CTOR(cache::Manager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(cache::Manager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+  }
+
+  static void MaybeCreateInstance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread.  Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    MOZ_ASSERT(sFactory);
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove().
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Weak references as we don't want to keep Manager objects alive forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  nsTArray<Manager*> mManagerList;
+};
+
+// static
+StaticAutoPtr<Manager::Factory> Manager::Factory::sFactory;
+
+// ----------------------------------------------------------------------------
+
+// Abstract class to help implement the various Actions.  The vast majority
+// of Actions are synchronous and need to report back to a Listener on the
+// Manager.
+class Manager::BaseAction : public SyncDBAction
+{
+protected:
+  BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
+    : SyncDBAction(DBAction::Existing)
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId (aRequestId)
+  {
+    MOZ_ASSERT(mListenerId);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) = 0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    Listener* listener = mManager->GetListener(mListenerId);
+    if (listener) {
+      Complete(listener, aRv);
+    }
+
+    // ensure we release the manager on the initiating thread
+    mManager = nullptr;
+  }
+
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
+};
+
+// ----------------------------------------------------------------------------
+
+// Action that is executed when we determine that content has stopped using
+// a Cache object that has been orphaned.
 class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
     : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mCacheId(aCacheId)
   { }
@@ -240,26 +321,29 @@ public:
 
     return rv;
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
+
+    // ensure we release the manager on the initiating thread
     mManager = nullptr;
   }
 
 private:
-  virtual ~DeleteOrphanedCacheAction() { }
   nsRefPtr<Manager> mManager;
   const CacheId mCacheId;
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams,
                    StreamList* aStreamList)
@@ -306,26 +390,27 @@ public:
     mStreamList = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
-protected:
-  virtual ~CacheMatchAction() { }
+private:
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, CacheId aCacheId,
                       const PCacheRequestOrVoid& aRequestOrVoid,
                       const PCacheQueryParams& aParams,
                       StreamList* aStreamList)
@@ -370,25 +455,29 @@ public:
     mStreamList = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
-protected:
-  virtual ~CacheMatchAllAction() { }
+private:
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
   nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
+// ----------------------------------------------------------------------------
+
+// This is the most complex Action.  It puts a request/response pair into the
+// Cache.  It does not complete until all of the body data has been saved to
+// disk.  This means its an asynchronous Action.
 class Manager::CachePutAllAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAllAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const nsTArray<CacheRequestResponse>& aPutList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
@@ -510,20 +599,17 @@ public:
                               mDeletedBodyIdList);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         DoResolve(rv);
         return;
       }
     }
 
     rv = trans.Commit();
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      DoResolve(rv);
-      return;
-    }
+    NS_WARN_IF(NS_FAILED(rv));
 
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
@@ -532,38 +618,35 @@ public:
       mList[i].mRequestStream = nullptr;
       mList[i].mResponseStream = nullptr;
     }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
-    if (!listener) {
-      return;
+    if (listener) {
+      listener->OnCachePutAll(mRequestId, aRv);
     }
-    listener->OnCachePutAll(mRequestId, aRv);
   }
 
   virtual void
   CancelOnTarget() MOZ_OVERRIDE
   {
     CancelAllStreamCopying();
     mConn = nullptr;
     mResolver = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 private:
-  virtual ~CachePutAllAction() { }
-
   nsresult
   StartStreamCopy(const QuotaInfo& aQuotaInfo, nsIInputStream* aSource,
                   nsID* aIdOut, nsISupports** aCopyContextOut)
   {
     MOZ_ASSERT(aIdOut);
     MOZ_ASSERT(aCopyContextOut);
     MOZ_ASSERT(mDBDir);
 
@@ -654,16 +737,18 @@ private:
   nsTArray<Entry> mList;
   nsRefPtr<Resolver> mResolver;
   nsCOMPtr<nsIFile> mDBDir;
   nsCOMPtr<mozIStorageConnection> mConn;
   uint32_t mExpectedAsyncCopyCompletions;
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
     : BaseAction(aManager, aListenerId, aRequestId)
@@ -700,33 +785,34 @@ public:
     aListener->OnCacheDelete(mRequestId, aRv, mSuccess);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
-protected:
-  virtual ~CacheDeleteAction() { }
+private:
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   bool mSuccess;
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::CacheKeysAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheKeysAction(Manager* aManager, ListenerId aListenerId,
-                    RequestId aRequestId, CacheId aCacheId,
-                    const PCacheRequestOrVoid& aRequestOrVoid,
-                    const PCacheQueryParams& aParams,
-                    StreamList* aStreamList)
+                  RequestId aRequestId, CacheId aCacheId,
+                  const PCacheRequestOrVoid& aRequestOrVoid,
+                  const PCacheQueryParams& aParams,
+                  StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
     , mStreamList(aStreamList)
   { }
 
   virtual nsresult
@@ -763,25 +849,26 @@ public:
     mStreamList = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
-protected:
-  virtual ~CacheKeysAction() { }
+private:
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
   nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedRequest> mSavedRequests;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::StorageMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageMatchAction(Manager* aManager, ListenerId aListenerId,
                      RequestId aRequestId, Namespace aNamespace,
                      const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams,
                      StreamList* aStreamList)
@@ -823,27 +910,28 @@ public:
       aListener->OnStorageMatch(mRequestId, aRv, nullptr, nullptr);
     } else {
       mStreamList->Activate(mSavedResponse.mCacheId);
       aListener->OnStorageMatch(mRequestId, aRv, &mSavedResponse, mStreamList);
     }
     mStreamList = nullptr;
   }
 
-protected:
-  virtual ~StorageMatchAction() { }
+private:
   const Namespace mNamespace;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mSavedResponse;
 };
 
-class Manager::StorageHasAction : public Manager::BaseAction
+// ----------------------------------------------------------------------------
+
+class Manager::StorageHasAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageHasAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, Namespace aNamespace,
                    const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mKey(aKey)
@@ -860,23 +948,24 @@ public:
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     aListener->OnStorageHas(mRequestId, aRv, mCacheFound);
   }
 
-protected:
-  virtual ~StorageHasAction() { }
+private:
   const Namespace mNamespace;
   const nsString mKey;
   bool mCacheFound;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::StorageOpenAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageOpenAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, Namespace aNamespace,
                     const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
@@ -915,22 +1004,23 @@ public:
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     aListener->OnStorageOpen(mRequestId, aRv, mCacheId);
   }
 
 private:
-  virtual ~StorageOpenAction() { }
   const Namespace mNamespace;
   const nsString mKey;
   CacheId mCacheId;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::StorageDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageDeleteAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, Namespace aNamespace,
                       const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
@@ -981,28 +1071,29 @@ public:
         mManager->CurrentContext()->Dispatch(mManager->mIOThread, action);
       }
     }
 
     aListener->OnStorageDelete(mRequestId, aRv, mCacheDeleted);
   }
 
 private:
-  virtual ~StorageDeleteAction() { }
   const Namespace mNamespace;
   const nsString mKey;
   bool mCacheDeleted;
   CacheId mCacheId;
 };
 
+// ----------------------------------------------------------------------------
+
 class Manager::StorageKeysAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageKeysAction(Manager* aManager, ListenerId aListenerId,
-                      RequestId aRequestId, Namespace aNamespace)
+                    RequestId aRequestId, Namespace aNamespace)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
@@ -1014,42 +1105,52 @@ public:
   {
     if (NS_FAILED(aRv)) {
       mKeys.Clear();
     }
     aListener->OnStorageKeys(mRequestId, aRv, mKeys);
   }
 
 private:
-  virtual ~StorageKeysAction() { }
   const Namespace mNamespace;
   nsTArray<nsString> mKeys;
 };
 
+// ----------------------------------------------------------------------------
+
 // static
-already_AddRefed<Manager>
-Manager::GetOrCreate(ManagerId* aManagerId)
+nsresult
+Manager::GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-  return Factory::Instance().GetOrCreate(aManagerId);
+  return Factory::GetOrCreate(aManagerId, aManagerOut);
 }
 
 // static
 already_AddRefed<Manager>
 Manager::Get(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-  return Factory::Instance().Get(aManagerId);
+  return Factory::Get(aManagerId);
+}
+
+// static
+void
+Manager::ShutdownAll()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::ShutdownAll();
 }
 
 void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   mListeners.RemoveElement(aListener);
+  MOZ_ASSERT(!mListeners.Contains(aListener));
 }
 
 void
 Manager::AddRefCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
@@ -1067,17 +1168,17 @@ void
 Manager::ReleaseCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
-      if (mCacheIdRefs[i].mCount < 1) {
+      if (mCacheIdRefs[i].mCount == 0) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
         // TODO: note that we need to check this cache for staleness on startup (bug 1110446)
         if (orphaned && !mShuttingDown) {
           CurrentContext()->CancelForCacheId(aCacheId);
           nsRefPtr<Action> action = new DeleteOrphanedCacheAction(this,
                                                                   aCacheId);
           CurrentContext()->Dispatch(mIOThread, action);
@@ -1143,32 +1244,42 @@ Manager::SetCacheIdOrphanedIfRefed(Cache
   }
   return false;
 }
 
 void
 Manager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+
+  // Ignore duplicate attempts to shutdown.  This can occur when we start
+  // a browser initiated shutdown and then run ~Manager() which also
+  // calls Shutdown().
+  if (mShuttingDown) {
+    return;
+  }
+
+  // Set a flag to prevent any new requests from coming in and creating
+  // a new Context.  We must ensure all Contexts and IO operations are
+  // complete before shutdown proceeds.
   mShuttingDown = true;
+
   for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
     mStreamLists[i]->CloseAll();
   }
 
-  // If there is no context, then note that we're done shutting down
-  if (!mContext) {
-    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
-    if (so) {
-      so->RemoveManagerId(mManagerId);
-    }
+  // If there is a context, then we must wait for it to complete.  Cancel and
+  // only note that we are done after its cleaned up.
+  if (mContext) {
+    mContext->CancelAll();
+    return;
+  }
 
-  // Otherwise, cancel the context and note complete when it cleans up
-  } else {
-    mContext->CancelAll();
-  }
+  // Otherwise, note that we are complete immediately
+  shutdown::RemoveManagerId(mManagerId);
 }
 
 already_AddRefed<ManagerId>
 Manager::GetManagerId() const
 {
   nsRefPtr<ManagerId> ref = mManagerId;
   return ref.forget();
 }
@@ -1376,50 +1487,39 @@ Manager::StorageKeys(Listener* aListener
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
   mContext = nullptr;
 
+  // If we're trying to shutdown, then note that we're done.  This is the
+  // delayed case from Manager::Shutdown().
   if (mShuttingDown) {
-    nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
-    if (so) {
-      so->RemoveManagerId(mManagerId);
-    }
+    shutdown::RemoveManagerId(mManagerId);
   }
 }
 
-Manager::Manager(ManagerId* aManagerId)
+Manager::Manager(ManagerId* aManagerId, nsIThread* aIOThread)
   : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
   , mContext(nullptr)
   , mShuttingDown(false)
 {
   MOZ_ASSERT(mManagerId);
-
-  nsresult rv = NS_NewNamedThread("DOMCacheThread",
-                                  getter_AddRefs(mIOThread));
-  if (NS_FAILED(rv)) {
-    MOZ_CRASH("Failed to spawn cache manager IO thread.");
-  }
-
-  nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
-  if (so) {
-    so->AddManagerId(mManagerId);
-  } else {
-    Shutdown();
-  }
+  MOZ_ASSERT(mIOThread);
 }
 
 Manager::~Manager()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(!mContext);
   Shutdown();
-  Factory::Instance().Remove(this);
+  Factory::Remove(this);
   mIOThread->Shutdown();
 }
 
 Context*
 Manager::CurrentContext()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   if (!mContext) {
@@ -1429,16 +1529,20 @@ Manager::CurrentContext()
   }
   return mContext;
 }
 
 Manager::ListenerId
 Manager::SaveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
+
+  // Once a Listener is added, we keep a reference to it until its
+  // removed.  Since the same Listener might make multiple requests,
+  // ensure we only have a single reference in our list.
   for (uint32_t i = 0; i < mListeners.Length(); ++i) {
     if (mListeners[i] == aListener) {
       return reinterpret_cast<ListenerId>(aListener);
     }
   }
   mListeners.AppendElement(aListener);
   return reinterpret_cast<ListenerId>(aListener);
 }
@@ -1447,16 +1551,19 @@ Manager::Listener*
 Manager::GetListener(ListenerId aListenerId) const
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mListeners.Length(); ++i) {
     if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
       return mListeners[i];
     }
   }
+
+  // This can legitimately happen if the actor is deleted while a request is
+  // in process.  For example, the child process OOMs.
   return nullptr;
 }
 
 // TODO: provide way to set body non-orphaned if its added back to a cache (bug 1110479)
 
 bool
 Manager::SetBodyIdOrphanedIfRefed(const nsID& aBodyId)
 {
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -35,18 +35,16 @@ struct SavedResponse;
 class StreamList;
 
 class Manager MOZ_FINAL
 {
 public:
   class Listener
   {
   public:
-    virtual ~Listener() { }
-
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                                  const nsTArray<SavedResponse>& aSavedResponses,
                                  StreamList* aStreamList) { }
     virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
@@ -61,20 +59,24 @@ public:
     virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound) { }
     virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
                                CacheId aCacheId) { }
     virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                  bool aCacheDeleted) { }
     virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
                                const nsTArray<nsString>& aKeys) { }
+
+  protected:
+    ~Listener() { }
   };
 
-  static already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId);
+  static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut);
   static already_AddRefed<Manager> Get(ManagerId* aManagerId);
+  static void ShutdownAll();
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   void AddRefBodyId(const nsID& aBodyId);
   void ReleaseBodyId(const nsID& aBodyId);
   bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
   void Shutdown();
@@ -113,34 +115,33 @@ public:
   void StorageKeys(Listener* aListener, RequestId aRequestId,
                    Namespace aNamespace);
 
   void RemoveContext(Context* aContext);
 
 private:
   class Factory;
   class BaseAction;
-  class DeleteOrphanedBodyAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAllAction;
   class CacheDeleteAction;
   class CacheKeysAction;
 
   class StorageMatchAction;
   class StorageHasAction;
   class StorageOpenAction;
   class StorageDeleteAction;
   class StorageKeysAction;
 
   typedef uintptr_t ListenerId;
 
-  Manager(ManagerId* aManagerId);
+  Manager(ManagerId* aManagerId, nsIThread* aIOThread);
   ~Manager();
   Context* CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
@@ -148,25 +149,25 @@ private:
   nsRefPtr<ManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
   nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
   {
     CacheId mCacheId;
-    uint32_t mCount;
+    MozRefCountType mCount;
     bool mOrphaned;
   };
   nsTArray<CacheIdRefCounter> mCacheIdRefs;
 
   struct BodyIdRefCounter
   {
     nsID mBodyId;
-    uint32_t mCount;
+    MozRefCountType mCount;
     bool mOrphaned;
   };
   nsTArray<BodyIdRefCounter> mBodyIdRefs;
 
   // weak ref as Context destructor clears this pointer
   Context* mContext;
 
   bool mShuttingDown;
diff --git a/dom/cache/ManagerId.h b/dom/cache/ManagerId.h
--- a/dom/cache/ManagerId.h
+++ b/dom/cache/ManagerId.h
@@ -18,31 +18,47 @@ class nsIPrincipal;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ManagerId MOZ_FINAL
 {
 public:
+  // nsTArray comparator that compares by value instead of pointer values.
+  class Comparator MOZ_STACK_CLASS MOZ_FINAL
+  {
+  public:
+    bool Equals(ManagerId *aA, ManagerId* aB) const { return *aA == *aB; }
+    bool LessThan(ManagerId *aA, ManagerId* aB) const { return *aA < *aB; }
+  };
+
   // Main thread only
   static nsresult Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut);
 
   // Main thread only
   already_AddRefed<nsIPrincipal> Principal() const;
 
   const nsACString& Origin() const { return mOrigin; }
 
   bool operator==(const ManagerId& aOther) const
   {
     return mOrigin == aOther.mOrigin &&
            mAppId == aOther.mAppId &&
            mInBrowserElement == aOther.mInBrowserElement;
   }
 
+  bool operator<(const ManagerId& aOther) const
+  {
+    return mOrigin < aOther.mOrigin ||
+           (mOrigin == aOther.mOrigin && mAppId < aOther.mAppId) ||
+           (mOrigin == aOther.mOrigin && mAppId == aOther.mAppId &&
+            mInBrowserElement < aOther.mInBrowserElement);
+  }
+
 private:
   ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
             uint32_t aAppId, bool aInBrowserElement);
   ~ManagerId();
 
   ManagerId(const ManagerId&) MOZ_DELETE;
   ManagerId& operator=(const ManagerId&) MOZ_DELETE;
 
diff --git a/dom/cache/ShutdownObserver.cpp b/dom/cache/ShutdownObserver.cpp
--- a/dom/cache/ShutdownObserver.cpp
+++ b/dom/cache/ShutdownObserver.cpp
@@ -1,109 +1,177 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/ShutdownObserver.h"
 
+#include "mozilla/Attributes.h"
+#include "mozilla/StaticPtr.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/Services.h"
+#include "nsCOMPtr.h"
+#include "nsIObserver.h"
 #include "nsIObserverService.h"
+#include "nsIThread.h"
+#include "nsString.h"
+#include "nsTArray.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
-static bool sInstanceInit = false;
-static nsRefPtr<mozilla::dom::cache::ShutdownObserver> sInstance = nullptr;
-
-} // anonymous namespace
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
+using mozilla::DebugOnly;
+using mozilla::StaticRefPtr;
+using mozilla::dom::cache::Manager;
+using mozilla::dom::cache::ManagerId;
 using mozilla::services::GetObserverService;
 
-NS_IMPL_ISUPPORTS(mozilla::dom::cache::ShutdownObserver, nsIObserver);
+// An nsIObserver that will terminate all Cache Managers and wait for
+// them to complete.  This is somewhat complex because observer notifications
+// and shutdown occurs on the main thread while Cache Managers work on
+// background threads.
+//
+// The basic implementation is to hold an array of known ManagerIds on
+// the main thread.  New Manager objects register their ManagerId when
+// created by proxying to the main thread.  At shutdown, we proxy to
+// the PBackground worker thread and call Manager::ShutdownAll().  We
+// then spin the main thread event loop until all known ManagerIds are
+// gone.
+class CacheShutdownObserver MOZ_FINAL : public nsIObserver
+{
+public:
+  static already_AddRefed<CacheShutdownObserver> Instance();
+
+  nsresult AddManagerId(ManagerId* aManagerId);
+  void RemoveManagerId(ManagerId* aManagerId);
+
+private:
+  CacheShutdownObserver();
+  virtual ~CacheShutdownObserver();
+
+  void InitOnMainThread();
+  void AddManagerIdOnMainThread(ManagerId* aManagerId);
+  void RemoveManagerIdOnMainThread(ManagerId* aManagerId);
+
+  void StartShutdownOnBgThread();
+  void FinishShutdownOnBgThread();
+
+  void DoShutdown();
+
+  nsCOMPtr<nsIThread> mBackgroundThread;
+
+  // main thread only
+  nsTArray<nsRefPtr<ManagerId>> mManagerIds;
+
+  // bg thread only
+  bool mShuttingDown;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIOBSERVER
+};
+
+// ShutdownObserver conflicts with other code here, so use CacheShutdownObserver
+NS_IMPL_ISUPPORTS(CacheShutdownObserver, nsIObserver);
+
+static bool sInstanceInit = false;
+static StaticRefPtr<CacheShutdownObserver> sInstance;
 
 // static
-already_AddRefed<ShutdownObserver>
-ShutdownObserver::Instance()
+already_AddRefed<CacheShutdownObserver>
+CacheShutdownObserver::Instance()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
+  // Use a separate init variable here.  Since we clear sInstance after
+  // shutdown we can't just compare against nullptr.  The init variable
+  // allows us to ensure that a observer is not created in this case.
   if (!sInstanceInit) {
     sInstanceInit = true;
-    sInstance = new ShutdownObserver();
+
+    // We cannot use ClearOnShutdown() because we are not on the main
+    // thread.  Of course, we are implementing a shutdown handler,
+    // so its not a problem to clear it manually.  This is done in
+    // FinishShutdownOnBgThread().
+    sInstance = new CacheShutdownObserver();
+
+    // We must initialize our new observer on the main thread.  Do this
+    // outside the constructor because its fallible.
+    nsCOMPtr<nsIRunnable> runnable =
+      NS_NewRunnableMethod(sInstance, &CacheShutdownObserver::InitOnMainThread);
+    nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+
+    // If we try to create an instance after shutdown somehow when no
+    // Cache managers have ever been used, then we may fail to dispatch
+    // to the main thread.  Treat this the same as calling Instance() with
+    // sInstanceInit equal to true.
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      sInstance = nullptr;
+    }
   }
 
-  nsRefPtr<ShutdownObserver> ref = sInstance;
+  // can be null if we've already shutdown!
+  nsRefPtr<CacheShutdownObserver> ref = sInstance.get();
   return ref.forget();
 }
 
 nsresult
-ShutdownObserver::AddManagerId(ManagerId* aManagerId)
+CacheShutdownObserver::AddManagerId(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   if (mShuttingDown) {
     return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
   }
 
   nsCOMPtr<nsIRunnable> runnable =
     NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
-      this, &ShutdownObserver::AddManagerIdOnMainThread, aManagerId);
+      this, &CacheShutdownObserver::AddManagerIdOnMainThread, aManagerId);
 
   DebugOnly<nsresult> rv =
     NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
 
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   return NS_OK;
 }
 
 void
-ShutdownObserver::RemoveManagerId(ManagerId* aManagerId)
+CacheShutdownObserver::RemoveManagerId(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   nsCOMPtr<nsIRunnable> runnable =
     NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
-      this, &ShutdownObserver::RemoveManagerIdOnMainThread, aManagerId);
+      this, &CacheShutdownObserver::RemoveManagerIdOnMainThread, aManagerId);
 
   DebugOnly<nsresult> rv =
     NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
 
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
-ShutdownObserver::ShutdownObserver()
+CacheShutdownObserver::CacheShutdownObserver()
   : mBackgroundThread(NS_GetCurrentThread())
   , mShuttingDown(false)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-
-  nsCOMPtr<nsIRunnable> runnable =
-    NS_NewRunnableMethod(this, &ShutdownObserver::InitOnMainThread);
-  DebugOnly<nsresult> rv =
-    NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
-  MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
-ShutdownObserver::~ShutdownObserver()
+CacheShutdownObserver::~CacheShutdownObserver()
 {
   // This can happen on either main thread or background thread.
 }
 
 void
-ShutdownObserver::InitOnMainThread()
+CacheShutdownObserver::InitOnMainThread()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIObserverService> os = GetObserverService();
 
   // If there is no observer service then we are already shutting down,
   // but content just tried to use the Cache API for the first time.
   // Trigger an immediate Cache shutdown.
@@ -111,110 +179,119 @@ ShutdownObserver::InitOnMainThread()
     DoShutdown();
     return;
   }
 
   os->AddObserver(this, "profile-before-change", false /* weak ref */);
 }
 
 void
-ShutdownObserver::AddManagerIdOnMainThread(ManagerId* aManagerId)
+CacheShutdownObserver::AddManagerIdOnMainThread(ManagerId* aManagerId)
 {
   MOZ_ASSERT(NS_IsMainThread());
-
-  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
-    if (*mManagerIds[i] == *aManagerId) {
-      return;
-    }
-  }
+  MOZ_ASSERT(!mManagerIds.Contains(aManagerId, ManagerId::Comparator()));
   mManagerIds.AppendElement(aManagerId);
 }
 
 void
-ShutdownObserver::RemoveManagerIdOnMainThread(ManagerId* aManagerId)
+CacheShutdownObserver::RemoveManagerIdOnMainThread(ManagerId* aManagerId)
 {
   MOZ_ASSERT(NS_IsMainThread());
-
-  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
-    if (*mManagerIds[i] == *aManagerId) {
-      mManagerIds.RemoveElementAt(i);
-      return;
-    }
-  }
+  mManagerIds.RemoveElement(aManagerId, ManagerId::Comparator());
 }
 
 void
-ShutdownObserver::StartShutdownOnBgThread()
+CacheShutdownObserver::StartShutdownOnBgThread()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
+  // prevent any further AddManagerId() calls
   mShuttingDown = true;
 
-  for (uint32_t i = 0; i < mManagerIdsInProcess.Length(); ++i) {
-    nsRefPtr<Manager> manager = Manager::Get(mManagerIdsInProcess[i]);
-    if (manager) {
-      manager->Shutdown();
-    }
-  }
+  Manager::ShutdownAll();
 }
 
 void
-ShutdownObserver::FinishShutdownOnBgThread()
+CacheShutdownObserver::FinishShutdownOnBgThread()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   MOZ_ASSERT(mShuttingDown);
 
   sInstance = nullptr;
 }
 
 void
-ShutdownObserver::DoShutdown()
+CacheShutdownObserver::DoShutdown()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
   if (os) {
     os->RemoveObserver(this, "profile-before-change");
   }
 
-  // Copy origins to separate array to process to avoid races
-  mManagerIdsInProcess = mManagerIds;
-
   // Send shutdown notification to origin managers
   nsCOMPtr<nsIRunnable> runnable =
-    NS_NewRunnableMethod(this, &ShutdownObserver::StartShutdownOnBgThread);
+    NS_NewRunnableMethod(this, &CacheShutdownObserver::StartShutdownOnBgThread);
   DebugOnly<nsresult> rv =
     mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   runnable = nullptr;
 
   // Wait for managers to shutdown
   while (!mManagerIds.IsEmpty()) {
     if (!NS_ProcessNextEvent()) {
       NS_WARNING("Something bad happened!");
       break;
     }
   }
 
   // schedule runnable to clear singleton ref on background thread
   runnable =
-    NS_NewRunnableMethod(this, &ShutdownObserver::FinishShutdownOnBgThread);
+    NS_NewRunnableMethod(this, &CacheShutdownObserver::FinishShutdownOnBgThread);
   rv = mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
 NS_IMETHODIMP
-ShutdownObserver::Observe(nsISupports* aSubject, const char* aTopic,
+CacheShutdownObserver::Observe(nsISupports* aSubject, const char* aTopic,
                           const char16_t* aData)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!strcmp(aTopic, "profile-before-change")) {
     DoShutdown();
   }
 
   return NS_OK;
 }
 
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+namespace shutdown {
+
+nsresult AddManagerId(ManagerId* aManagerId)
+{
+  nsRefPtr<CacheShutdownObserver> so = CacheShutdownObserver::Instance();
+  if (!so) {
+    return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+  }
+
+  so->AddManagerId(aManagerId);
+
+  return NS_OK;
+}
+
+void RemoveManagerId(ManagerId* aManagerId)
+{
+  // We should never get a nullptr while a Manager is still running.
+  nsRefPtr<CacheShutdownObserver> so = CacheShutdownObserver::Instance();
+  so->RemoveManagerId(aManagerId);
+}
+
+} // namespace shutdown
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ShutdownObserver.h b/dom/cache/ShutdownObserver.h
--- a/dom/cache/ShutdownObserver.h
+++ b/dom/cache/ShutdownObserver.h
@@ -2,63 +2,32 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_ShutdownObserver_h
 #define mozilla_dom_cache_ShutdownObserver_h
 
-#include "mozilla/Attributes.h"
-#include "nsCOMPtr.h"
-#include "nsIObserver.h"
-#include "nsIThread.h"
-#include "nsString.h"
-#include "nsTArray.h"
+#include "nsError.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ManagerId;
 
-class ShutdownObserver MOZ_FINAL : public nsIObserver
-{
-public:
-  static already_AddRefed<ShutdownObserver> Instance();
+namespace shutdown {
 
-  nsresult AddManagerId(ManagerId* aManagerId);
-  void RemoveManagerId(ManagerId* aManagerId);
+// Attempt to register a Manager with the ShutdownObserver.  If successful,
+// this will block shutdown until the RemoveManagerId is called.
+nsresult AddManagerId(ManagerId* aManagerId);
 
-private:
-  ShutdownObserver();
-  virtual ~ShutdownObserver();
+// Remove the given Manager from the ShutdownObserver.  This must be called
+// exactly once for each AddManagerId() call.
+void RemoveManagerId(ManagerId* aManagerId);
 
-  void InitOnMainThread();
-  void AddManagerIdOnMainThread(ManagerId* aManagerId);
-  void RemoveManagerIdOnMainThread(ManagerId* aManagerId);
-
-  void StartShutdownOnBgThread();
-  void FinishShutdownOnBgThread();
-
-  void DoShutdown();
-
-  nsCOMPtr<nsIThread> mBackgroundThread;
-
-  // main thread only
-  nsTArray<nsRefPtr<ManagerId>> mManagerIds;
-
-  // set on main thread once and read on bg thread
-  nsTArray<nsRefPtr<ManagerId>> mManagerIdsInProcess;
-
-  // bg thread only
-  bool mShuttingDown;
-
-public:
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIOBSERVER
-};
-
+} // namespace shutdown
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_ShutdownObserver_h
