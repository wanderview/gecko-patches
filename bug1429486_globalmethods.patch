# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9539ae40ceee314ebd914afa80ac03163f343694
Bug 1429486 Expose GetClientInfo(), GetClientState(), and GetController() on nsIGlobalObject. r=asuth

diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -343,19 +343,19 @@ public:
   void Suspend();
   void Resume();
   virtual bool IsSuspended() const override;
   void Freeze();
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
-  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
-  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
-  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const override;
+  mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const override;
+  mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const override;
 
   void NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope);
 
   virtual nsresult FireDelayedDOMEvents() override;
 
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
                                   nsISupports *aState,
                                   bool aForceReuseInnerWindow) override;
diff --git a/dom/base/nsIGlobalObject.cpp b/dom/base/nsIGlobalObject.cpp
--- a/dom/base/nsIGlobalObject.cpp
+++ b/dom/base/nsIGlobalObject.cpp
@@ -4,16 +4,21 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsIGlobalObject.h"
 #include "nsContentUtils.h"
 #include "nsThreadUtils.h"
 #include "nsHostObjectProtocolHandler.h"
 
+using mozilla::Maybe;
+using mozilla::dom::ClientInfo;
+using mozilla::dom::ClientState;
+using mozilla::dom::ServiceWorkerDescriptor;
+
 nsIGlobalObject::~nsIGlobalObject()
 {
   UnlinkHostObjectURIs();
 }
 
 nsIPrincipal*
 nsIGlobalObject::PrincipalOrNull()
 {
@@ -107,8 +112,32 @@ nsIGlobalObject::TraverseHostObjectURIs(
   if (!NS_IsMainThread()) {
     return;
   }
 
   for (uint32_t index = 0; index < mHostObjectURIs.Length(); ++index) {
     nsHostObjectProtocolHandler::Traverse(mHostObjectURIs[index], aCb);
   }
 }
+
+Maybe<ClientInfo>
+nsIGlobalObject::GetClientInfo() const
+{
+  // By default globals do not expose themselves as a client.  Only real
+  // window and worker globals are currently considered clients.
+  return Maybe<ClientInfo>();
+}
+
+Maybe<ClientState>
+nsIGlobalObject::GetClientState() const
+{
+  // By default globals do not expose themselves as a client.  Only real
+  // window and worker globals are currently considered clients.
+  return Maybe<ClientState>();
+}
+
+Maybe<ServiceWorkerDescriptor>
+nsIGlobalObject::GetController() const
+{
+  // By default globals do not have a service worker controller.  Only real
+  // window and worker globals can currently be controlled as a client.
+  return Maybe<ServiceWorkerDescriptor>();
+}
diff --git a/dom/base/nsIGlobalObject.h b/dom/base/nsIGlobalObject.h
--- a/dom/base/nsIGlobalObject.h
+++ b/dom/base/nsIGlobalObject.h
@@ -12,16 +12,25 @@
 #include "nsStringFwd.h"
 #include "nsTArray.h"
 #include "js/TypeDecls.h"
 
 #define NS_IGLOBALOBJECT_IID \
 { 0x11afa8be, 0xd997, 0x4e07, \
 { 0xa6, 0xa3, 0x6f, 0x87, 0x2e, 0xc3, 0xee, 0x7f } }
 
+namespace mozilla {
+template<typename T> class Maybe;
+namespace dom {
+class ClientInfo;
+class ClientState;
+class ServiceWorkerDescriptor;
+} // namespace dom
+} // namespace mozilla
+
 class nsCycleCollectionTraversalCallback;
 class nsIPrincipal;
 
 class nsIGlobalObject : public nsISupports,
                         public mozilla::dom::DispatcherTrait
 {
   nsTArray<nsCString> mHostObjectURIs;
   bool mIsDying;
@@ -71,16 +80,25 @@ public:
 
   // Any CC class inheriting nsIGlobalObject should call these 2 methods if it
   // exposes the URL API.
   void UnlinkHostObjectURIs();
   void TraverseHostObjectURIs(nsCycleCollectionTraversalCallback &aCb);
 
   virtual bool IsInSyncOperation() { return false; }
 
+  virtual mozilla::Maybe<mozilla::dom::ClientInfo>
+  GetClientInfo() const;
+
+  virtual mozilla::Maybe<mozilla::dom::ClientState>
+  GetClientState() const;
+
+  virtual mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor>
+  GetController() const;
+
 protected:
   virtual ~nsIGlobalObject();
 
   void
   StartDying()
   {
     mIsDying = true;
   }
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -44,16 +44,17 @@
 #include "mozilla/ContentEvents.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/Likely.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/Move.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientSource.h"
+#include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/ErrorEventBinding.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
@@ -5328,16 +5329,34 @@ WorkerPrivate::EnsureClientSource()
 const ClientInfo&
 WorkerPrivate::GetClientInfo() const
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   return mClientSource->Info();
 }
 
+const ClientState
+WorkerPrivate::GetClientState() const
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  ClientState state;
+  mClientSource->SnapshotState(&state);
+  return Move(state);
+}
+
+const Maybe<ServiceWorkerDescriptor>
+WorkerPrivate::GetController() const
+{
+  AssertIsOnWorkerThread();
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  return mClientSource->GetController();
+}
+
 void
 WorkerPrivate::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   MOZ_DIAGNOSTIC_ASSERT(!IsChromeWorker());
   MOZ_DIAGNOSTIC_ASSERT(Type() != WorkerTypeService);
   mClientSource->SetController(aServiceWorker);
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1489,16 +1489,22 @@ public:
   DumpCrashInformation(nsACString& aString);
 
   bool
   EnsureClientSource();
 
   const ClientInfo&
   GetClientInfo() const;
 
+  const ClientState
+  GetClientState() const;
+
+  const Maybe<ServiceWorkerDescriptor>
+  GetController() const;
+
   void
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   void
   ExecutionReady();
 
 private:
   WorkerPrivate(WorkerPrivate* aParent,
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -510,16 +510,38 @@ WorkerGlobalScope::EventTargetFor(TaskCa
 }
 
 AbstractThread*
 WorkerGlobalScope::AbstractMainThreadFor(TaskCategory aCategory)
 {
   MOZ_CRASH("AbstractMainThreadFor not supported for workers.");
 }
 
+Maybe<ClientInfo>
+WorkerGlobalScope::GetClientInfo() const
+{
+  Maybe<ClientInfo> info;
+  info.emplace(mWorkerPrivate->GetClientInfo());
+  return Move(info);
+}
+
+Maybe<ClientState>
+WorkerGlobalScope::GetClientState() const
+{
+  Maybe<ClientState> state;
+  state.emplace(mWorkerPrivate->GetClientState());
+  return Move(state);
+}
+
+Maybe<ServiceWorkerDescriptor>
+WorkerGlobalScope::GetController() const
+{
+  return mWorkerPrivate->GetController();
+}
+
 DedicatedWorkerGlobalScope::DedicatedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate,
                                                        const nsString& aName)
   : WorkerGlobalScope(aWorkerPrivate)
   , mName(aName)
 {
 }
 
 bool
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -14,17 +14,19 @@
 #include "nsWeakReference.h"
 #include "mozilla/dom/ImageBitmapSource.h"
 
 namespace mozilla {
 namespace dom {
 
 class AnyCallback;
 struct ChannelPixelLayout;
+class ClientInfo;
 class Clients;
+class ClientState;
 class Console;
 class Crypto;
 class Function;
 class IDBFactory;
 enum class ImageBitmapFormat : uint8_t;
 class Performance;
 class Promise;
 class RequestOrUSVString;
@@ -216,16 +218,25 @@ public:
   Dispatch(TaskCategory aCategory,
            already_AddRefed<nsIRunnable>&& aRunnable) override;
 
   nsISerialEventTarget*
   EventTargetFor(TaskCategory aCategory) const override;
 
   AbstractThread*
   AbstractMainThreadFor(TaskCategory aCategory) override;
+
+  Maybe<ClientInfo>
+  GetClientInfo() const override;
+
+  Maybe<ClientState>
+  GetClientState() const override;
+
+  Maybe<ServiceWorkerDescriptor>
+  GetController() const override;
 };
 
 class DedicatedWorkerGlobalScope final : public WorkerGlobalScope
 {
   const nsString mName;
 
   ~DedicatedWorkerGlobalScope() { }
 
