# HG changeset patch
# Parent de01ec0085dcc73d59ce09d740471854d37aaa96
# User Ben Kelly <ben@wanderview.com>
Bug 1150691 Fix Cache API race with storage invalidation. r=ehsan

diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1406,27 +1406,31 @@ void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   // There may not be a listener here in the case where an actor is killed
   // before it can perform any actual async requests on Manager.
   mListeners.RemoveElement(aListener, ListenerEntryListenerComparator());
   MOZ_ASSERT(!mListeners.Contains(aListener,
                                   ListenerEntryListenerComparator()));
-  if (mListeners.IsEmpty() && mContext) {
-    mContext->AllowToClose();
-  }
+  MaybeAllowContextToClose();
 }
 
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
+
+  // Whether the Context destruction was triggered from the Manager going
+  // idle or the underlying storage being invalidated, we should be invalid
+  // when the context is destroyed.
+  MOZ_ASSERT(!mValid);
+
   mContext = nullptr;
 
   // If we're trying to shutdown, then note that we're done.  This is the
   // delayed case from Manager::Shutdown().
   if (mShuttingDown) {
     Factory::Remove(this);
   }
 }
@@ -1478,16 +1482,17 @@ Manager::ReleaseCacheId(CacheId aCacheId
         if (orphaned && !mShuttingDown && mValid) {
           nsRefPtr<Context> context = CurrentContext();
           context->CancelForCacheId(aCacheId);
           nsRefPtr<Action> action = new DeleteOrphanedCacheAction(this,
                                                                   aCacheId);
           context->Dispatch(mIOThread, action);
         }
       }
+      MaybeAllowContextToClose();
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release CacheId that is not referenced!");
 }
 
 void
 Manager::AddRefBodyId(const nsID& aBodyId)
@@ -1519,16 +1524,17 @@ Manager::ReleaseBodyId(const nsID& aBody
         mBodyIdRefs.RemoveElementAt(i);
         // TODO: note that we need to check this body for staleness on startup (bug 1110446)
         if (orphaned && !mShuttingDown && mValid) {
           nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
           nsRefPtr<Context> context = CurrentContext();
           context->Dispatch(mIOThread, action);
         }
       }
+      MaybeAllowContextToClose();
       return;
     }
   }
   MOZ_ASSERT_UNREACHABLE("Attempt to release BodyId that is not referenced!");
 }
 
 already_AddRefed<ManagerId>
 Manager::GetManagerId() const
@@ -1901,11 +1907,34 @@ Manager::NoteOrphanedBodyIdList(const ns
 
   if (!deleteNowList.IsEmpty()) {
     nsRefPtr<Action> action = new DeleteOrphanedBodyAction(deleteNowList);
     nsRefPtr<Context> context = CurrentContext();
     context->Dispatch(mIOThread, action);
   }
 }
 
+void
+Manager::MaybeAllowContextToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+
+  // If we have an active context, but we have no more users of the Manager,
+  // then let it shut itself down.  We must wait for all possible users of
+  // Cache state information to complete before doing this.  Once we allow
+  // the Context to close we may not reliably get notified of storage
+  // invalidation.
+  if (mContext && mListeners.IsEmpty()
+               && mCacheIdRefs.IsEmpty()
+               && mBodyIdRefs.IsEmpty()) {
+
+    // Mark this Manager as invalid so that it won't get used again.  We don't
+    // want to start any new operations once we allow the Context to close since
+    // it may race with the underlying storage getting invalidated.
+    mValid = false;
+
+    mContext->AllowToClose();
+  }
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -36,33 +36,35 @@ class StreamList;
 // work for a Cache or CacheStorage operation.  The DOM objects and IPC actors
 // are basically just plumbing to get the request to the right Manager object
 // running in the parent process.
 //
 // There should be exactly one Manager object for each origin or app using the
 // Cache API.  This uniqueness is defined by the ManagerId equality operator.
 // The uniqueness is enforced by the Manager GetOrCreate() factory method.
 //
-// The Manager object can out live the IPC actors in the case where the child
-// process is killed; e.g a child process OOM.  The Manager object can
-// The Manager object can potentially use non-trivial resources.  Long lived
-// DOM objects and their actors should not maintain a reference to the Manager
-// while idle.  Transient DOM objects that may keep a reference for their
-// lifetimes.
+// The life cycle of Manager objects is somewhat complex.  While code may
+// hold a strong reference to the Manager, it will invalidate itself once it
+// believes it has become completely idle.  This is currently determined when
+// all of the following conditions occur:
 //
-// For example, once a CacheStorage DOM object is access it will live until its
-// global is released.  Therefore, CacheStorage should release its Manager
-// reference after operations complete and it becomes idle.  Cache objects,
-// however, can be GC'd once content are done using them and can therefore keep
-// their Manager reference alive.  Its expected that more operations are
-// performed on a Cache object, so keeping the Manager reference will help
-// minimize overhead for each reference.
+//  1) There are no more Manager::Listener objects registered with the Manager
+//     by performing a Cache or Storage operation.
+//  2) There are no more CacheId references noted via Manager::AddRefCacheId().
+//  3) There are no more BodyId references noted via Manager::AddRefBodyId().
+//
+// In order to keep your Manager alive you should perform an operation to set
+// a Listener, call AddRefCacheId(), or call AddRefBodyId().
+//
+// Even once a Manager becomes invalid, however, it may still continue to
+// exist.  This is allowed so that any in-progress Actions can gracefully
+// complete.
 //
 // As an invariant, all Manager objects must cease all IO before shutdown.  This
-// is enforced by the ShutdownObserver.  If content still holds references to
+// is enforced by the Manager::Factory.  If content still holds references to
 // Cache DOM objects during shutdown, then all operations will begin rejecting.
 class Manager final
 {
 public:
   // Callback interface implemented by clients of Manager, such as CacheParent
   // and CacheStorageParent.  In general, if you call a Manager method you
   // should expect to receive exactly one On*() callback.  For example, if
   // you call Manager::CacheMatch(), then you should expect to receive
@@ -204,16 +206,18 @@ private:
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
 
+  void MaybeAllowContextToClose();
+
   nsRefPtr<ManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
   // Weak reference cleared by RemoveContext() in Context destructor.
   Context* MOZ_NON_OWNING_REF mContext;
 
   // Weak references cleared by RemoveListener() in Listener destructors.
   struct ListenerEntry
