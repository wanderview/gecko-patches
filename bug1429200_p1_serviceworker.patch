# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f2c51ccc9c40ae021f1be82a0c1c34c56fc2c3a2
Bug 1429200 P1 Split ServiceWorker DOM object internal outer and inner objects. r=asuth

diff --git a/dom/workers/InternalServiceWorker.h b/dom/workers/InternalServiceWorker.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/InternalServiceWorker.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_internalserviceworker_h__
+#define mozilla_dom_workers_internalserviceworker_h__
+
+#include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState.
+
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
+namespace mozilla {
+namespace dom {
+
+class ClientInfo;
+class ClientState;
+
+namespace workers {
+
+class InternalServiceWorker
+{
+public:
+  virtual void
+  SetTarget(DOMEventTargetHelper* aTarget) = 0;
+
+  virtual void
+  ClearTarget(DOMEventTargetHelper* aTarget) = 0;
+
+  virtual const nsCString&
+  Scope() const = 0;
+
+  virtual ServiceWorkerState
+  State() const = 0;
+
+  virtual void
+  GetScriptURL(nsString& aURL) const = 0;
+
+  virtual nsresult
+  PostMessage(const ClientInfo& aClientInfo,
+              const ClientState& aClientState,
+              JSContext* aCx, JS::Handle<JS::Value> aMessage,
+              const Sequence<JSObject*>& aTransferable) = 0;
+
+  NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_internalserviceworker_h__
diff --git a/dom/workers/SameProcessServiceWorker.cpp b/dom/workers/SameProcessServiceWorker.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/SameProcessServiceWorker.cpp
@@ -0,0 +1,123 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SameProcessServiceWorker.h"
+
+#include "ServiceWorkerInfo.h"
+#include "ServiceWorkerPrivate.h"
+#include "WorkerPrivate.h"
+
+#include "mozilla/DOMEventTargetHelper.h"
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientState.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
+
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
+using mozilla::ErrorResult;
+using namespace mozilla::dom;
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+SameProcessServiceWorker::SameProcessServiceWorker(ServiceWorkerInfo* aInfo)
+  : mInfo(aInfo)
+  , mTarget(nullptr)
+  , mState(ServiceWorkerState::Parsed)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aInfo);
+
+  // This will update our state too.
+  mInfo->AppendWorker(this);
+}
+
+SameProcessServiceWorker::~SameProcessServiceWorker()
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  MOZ_DIAGNOSTIC_ASSERT(!mTarget);
+  mInfo->RemoveWorker(this);
+}
+
+void
+SameProcessServiceWorker::SetTarget(DOMEventTargetHelper* aTarget)
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  MOZ_DIAGNOSTIC_ASSERT(aTarget);
+  MOZ_DIAGNOSTIC_ASSERT(!mTarget);
+  mTarget = aTarget;
+}
+
+void
+SameProcessServiceWorker::ClearTarget(DOMEventTargetHelper* aTarget)
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  MOZ_DIAGNOSTIC_ASSERT(aTarget);
+  MOZ_DIAGNOSTIC_ASSERT(mTarget == aTarget);
+  mTarget = nullptr;
+}
+
+const nsCString&
+SameProcessServiceWorker::Scope() const
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  return mInfo->Scope();
+}
+
+ServiceWorkerState
+SameProcessServiceWorker::State() const
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  return mState;
+}
+
+void
+SameProcessServiceWorker::SetState(ServiceWorkerState aState)
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  mState = aState;
+}
+
+void
+SameProcessServiceWorker::GetScriptURL(nsString& aURL) const
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  CopyUTF8toUTF16(mInfo->ScriptSpec(), aURL);
+}
+
+void
+SameProcessServiceWorker::DispatchStateChange(ServiceWorkerState aState)
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  NS_ENSURE_TRUE_VOID(mTarget);
+  mTarget->DispatchTrustedEvent(NS_LITERAL_STRING("statechange"));
+}
+
+nsresult
+SameProcessServiceWorker::PostMessage(const ClientInfo& aClientInfo,
+                                      const ClientState& aClientState,
+                                      JSContext* aCx,
+                                      JS::Handle<JS::Value> aMessage,
+                                      const Sequence<JSObject*>& aTransferable)
+{
+  NS_ASSERT_OWNINGTHREAD(SameProcessServiceWorker);
+  NS_ENSURE_TRUE(State() != ServiceWorkerState::Redundant,
+                 NS_ERROR_DOM_INVALID_STATE_ERR);
+
+  ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
+  return workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
+                                         ClientInfoAndState(aClientInfo.ToIPC(),
+                                                            aClientState.ToIPC()));
+}
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/SameProcessServiceWorker.h b/dom/workers/SameProcessServiceWorker.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/SameProcessServiceWorker.h
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_sameprocessserviceworker_h__
+#define mozilla_dom_workers_sameprocessserviceworker_h__
+
+#include "InternalServiceWorker.h"
+#include "mozilla/dom/BindingDeclarations.h"
+#include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState.
+
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
+namespace mozilla {
+
+class DOMEventTargetHelper;
+
+namespace dom {
+
+namespace workers {
+
+class ServiceWorkerInfo;
+
+class SameProcessServiceWorker final : public InternalServiceWorker
+{
+  friend class ServiceWorkerInfo;
+
+  const RefPtr<ServiceWorkerInfo> mInfo;
+  DOMEventTargetHelper* mTarget;
+  ServiceWorkerState mState;
+
+  // This class can only be created from ServiceWorkerInfo::GetOrCreateInstance().
+  SameProcessServiceWorker(ServiceWorkerInfo* aInfo);
+
+  ~SameProcessServiceWorker();
+
+public:
+  void
+  SetTarget(DOMEventTargetHelper* aTarget) override;
+
+  void
+  ClearTarget(DOMEventTargetHelper* aTarget) override;
+
+  const nsCString&
+  Scope() const override;
+
+  ServiceWorkerState
+  State() const override;
+
+  void
+  SetState(ServiceWorkerState aState);
+
+  void
+  GetScriptURL(nsString& aURL) const override;
+
+  void
+  DispatchStateChange(ServiceWorkerState aState);
+
+  nsresult
+  PostMessage(const ClientInfo& aClientInfo,
+              const ClientState& aClientState,
+              JSContext* aCx, JS::Handle<JS::Value> aMessage,
+              const Sequence<JSObject*>& aTransferable) override;
+
+  NS_INLINE_DECL_REFCOUNTING(SameProcessServiceWorker, override)
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_sameprocessserviceworker_h__
diff --git a/dom/workers/ServiceWorker.cpp b/dom/workers/ServiceWorker.cpp
--- a/dom/workers/ServiceWorker.cpp
+++ b/dom/workers/ServiceWorker.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
+#include "InternalServiceWorker.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "WorkerPrivate.h"
 
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
@@ -35,87 +36,82 @@ ServiceWorkerVisible(JSContext* aCx, JSO
   if (NS_IsMainThread()) {
     return DOMPrefs::ServiceWorkersEnabled();
   }
 
   return IS_INSTANCE_OF(ServiceWorkerGlobalScope, aObj);
 }
 
 ServiceWorker::ServiceWorker(nsPIDOMWindowInner* aWindow,
-                             ServiceWorkerInfo* aInfo)
-  : DOMEventTargetHelper(aWindow),
-    mInfo(aInfo)
+                             InternalServiceWorker* aInner)
+  : mInner(aInner)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(aInfo);
-
-  // This will update our state too.
-  mInfo->AppendWorker(this);
+  mInner->SetTarget(this);
 }
 
 ServiceWorker::~ServiceWorker()
 {
   AssertIsOnMainThread();
-  mInfo->RemoveWorker(this);
+  mInner->ClearTarget(this);
 }
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorker, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorker, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorker)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 JSObject*
 ServiceWorker::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   AssertIsOnMainThread();
 
   return ServiceWorkerBinding::Wrap(aCx, this, aGivenProto);
 }
 
+ServiceWorkerState
+ServiceWorker::State() const
+{
+  return mInner->State();
+}
+
 void
 ServiceWorker::GetScriptURL(nsString& aURL) const
 {
-  CopyUTF8toUTF16(mInfo->ScriptSpec(), aURL);
+  mInner->GetScriptURL(aURL);
 }
 
 void
 ServiceWorker::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                            const Sequence<JSObject*>& aTransferable,
                            ErrorResult& aRv)
 {
-  if (State() == ServiceWorkerState::Redundant) {
-    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return;
-  }
-
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(GetParentObject());
   if (!window || !window->GetExtantDoc()) {
     NS_WARNING("Trying to call post message from an invalid dom object.");
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
   auto storageAllowed = nsContentUtils::StorageAllowedForWindow(window);
   if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
     ServiceWorkerManager::LocalizeAndReportToAllClients(
-      mInfo->Scope(), "ServiceWorkerPostMessageStorageError",
-      nsTArray<nsString> { NS_ConvertUTF8toUTF16(mInfo->Scope()) });
+      mInner->Scope(), "ServiceWorkerPostMessageStorageError",
+      nsTArray<nsString> { NS_ConvertUTF8toUTF16(mInner->Scope()) });
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return;
   }
 
   Maybe<ClientInfo> clientInfo = window->GetClientInfo();
   Maybe<ClientState> clientState = window->GetClientState();
   if (clientInfo.isNothing() || clientState.isNothing()) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
-  ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
-  aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
-                                        ClientInfoAndState(clientInfo.ref().ToIPC(),
-                                                           clientState.ref().ToIPC()));
+  aRv = mInner->PostMessage(clientInfo.ref(), clientState.ref(), aCx, aMessage,
+                            aTransferable);
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorker.h b/dom/workers/ServiceWorker.h
--- a/dom/workers/ServiceWorker.h
+++ b/dom/workers/ServiceWorker.h
@@ -6,79 +6,57 @@
 
 #ifndef mozilla_dom_workers_serviceworker_h__
 #define mozilla_dom_workers_serviceworker_h__
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState.
 
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
-
 namespace workers {
 
+class InternalServiceWorker;
 class ServiceWorkerInfo;
-class ServiceWorkerManager;
-class SharedWorker;
 
 bool
 ServiceWorkerVisible(JSContext* aCx, JSObject* aObj);
 
 class ServiceWorker final : public DOMEventTargetHelper
 {
-  friend class ServiceWorkerInfo;
+  RefPtr<InternalServiceWorker> mInner;
+
+  ~ServiceWorker();
+
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   IMPL_EVENT_HANDLER(statechange)
   IMPL_EVENT_HANDLER(error)
 
+  ServiceWorker(nsPIDOMWindowInner* aWindow, InternalServiceWorker* aInner);
+
   virtual JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   ServiceWorkerState
-  State() const
-  {
-    return mState;
-  }
-
-  void
-  SetState(ServiceWorkerState aState)
-  {
-    mState = aState;
-  }
+  State() const;
 
   void
   GetScriptURL(nsString& aURL) const;
 
   void
-  DispatchStateChange(ServiceWorkerState aState)
-  {
-    DOMEventTargetHelper::DispatchTrustedEvent(NS_LITERAL_STRING("statechange"));
-  }
-
-#ifdef XP_WIN
-#undef PostMessage
-#endif
-
-  void
   PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
               const Sequence<JSObject*>& aTransferable, ErrorResult& aRv);
-
-private:
-  // This class can only be created from ServiceWorkerInfo::GetOrCreateInstance().
-  ServiceWorker(nsPIDOMWindowInner* aWindow, ServiceWorkerInfo* aInfo);
-
-  // This class is reference-counted and will be destroyed from Release().
-  ~ServiceWorker();
-
-  ServiceWorkerState mState;
-  const RefPtr<ServiceWorkerInfo> mInfo;
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworker_h__
diff --git a/dom/workers/ServiceWorkerInfo.cpp b/dom/workers/ServiceWorkerInfo.cpp
--- a/dom/workers/ServiceWorkerInfo.cpp
+++ b/dom/workers/ServiceWorkerInfo.cpp
@@ -106,32 +106,32 @@ ServiceWorkerInfo::AttachDebugger()
 
 NS_IMETHODIMP
 ServiceWorkerInfo::DetachDebugger()
 {
   return mServiceWorkerPrivate->DetachDebugger();
 }
 
 void
-ServiceWorkerInfo::AppendWorker(ServiceWorker* aWorker)
+ServiceWorkerInfo::AppendWorker(SameProcessServiceWorker* aWorker)
 {
   MOZ_ASSERT(aWorker);
 #ifdef DEBUG
   nsAutoString workerURL;
   aWorker->GetScriptURL(workerURL);
   MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
 #endif
   MOZ_ASSERT(!mInstances.Contains(aWorker));
 
   mInstances.AppendElement(aWorker);
   aWorker->SetState(State());
 }
 
 void
-ServiceWorkerInfo::RemoveWorker(ServiceWorker* aWorker)
+ServiceWorkerInfo::RemoveWorker(SameProcessServiceWorker* aWorker)
 {
   MOZ_ASSERT(aWorker);
 #ifdef DEBUG
   nsAutoString workerURL;
   aWorker->GetScriptURL(workerURL);
   MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
 #endif
   MOZ_ASSERT(mInstances.Contains(aWorker));
@@ -139,17 +139,17 @@ ServiceWorkerInfo::RemoveWorker(ServiceW
   mInstances.RemoveElement(aWorker);
 }
 
 namespace {
 
 class ChangeStateUpdater final : public Runnable
 {
 public:
-  ChangeStateUpdater(const nsTArray<ServiceWorker*>& aInstances,
+  ChangeStateUpdater(const nsTArray<SameProcessServiceWorker*>& aInstances,
                      ServiceWorkerState aState)
     : Runnable("dom::workers::ChangeStateUpdater")
     , mState(aState)
   {
     for (size_t i = 0; i < aInstances.Length(); ++i) {
       mInstances.AppendElement(aInstances[i]);
     }
   }
@@ -165,17 +165,17 @@ public:
     for (size_t i = 0; i < mInstances.Length(); ++i) {
       mInstances[i]->DispatchStateChange(mState);
     }
 
     return NS_OK;
   }
 
 private:
-  AutoTArray<RefPtr<ServiceWorker>, 1> mInstances;
+  AutoTArray<RefPtr<SameProcessServiceWorker>, 1> mInstances;
   ServiceWorkerState mState;
 };
 
 }
 
 void
 ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
 {
@@ -265,26 +265,29 @@ ServiceWorkerInfo::GetNextID() const
 already_AddRefed<ServiceWorker>
 ServiceWorkerInfo::GetOrCreateInstance(nsPIDOMWindowInner* aWindow)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aWindow);
 
   RefPtr<ServiceWorker> ref;
 
+  /* TODO
   for (uint32_t i = 0; i < mInstances.Length(); ++i) {
     MOZ_ASSERT(mInstances[i]);
     if (mInstances[i]->GetOwner() == aWindow) {
       ref = mInstances[i];
       break;
     }
   }
+  */
 
   if (!ref) {
-    ref = new ServiceWorker(aWindow, this);
+    RefPtr<SameProcessServiceWorker> inner = new SameProcessServiceWorker(this);
+    ref = new ServiceWorker(aWindow, inner);
   }
 
   return ref.forget();
 }
 
 void
 ServiceWorkerInfo::UpdateInstalledTime()
 {
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -10,16 +10,17 @@
 #include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState
 #include "mozilla/dom/workers/Workers.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
+class SameProcessServiceWorker;
 class ServiceWorker;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
@@ -50,19 +51,19 @@ private:
   // The time of states are 0, if SW has not reached that state yet. Besides, we
   // update each of them after UpdateState() is called in SWRegistrationInfo.
   PRTime mInstalledTime;
   PRTime mActivatedTime;
   PRTime mRedundantTime;
 
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
-  // There is a high chance of there being at least one ServiceWorker
+  // There is a high chance of there being at least one SameProcessServiceWorker
   // associated with this all the time.
-  AutoTArray<ServiceWorker*, 1> mInstances;
+  AutoTArray<SameProcessServiceWorker*, 1> mInstances;
 
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   bool mSkipWaitingFlag;
 
   enum {
     Unknown,
     Enabled,
     Disabled
@@ -181,20 +182,20 @@ public:
   HandlesFetch() const
   {
     AssertIsOnMainThread();
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch != Unknown);
     return mHandlesFetch != Disabled;
   }
 
   void
-  AppendWorker(ServiceWorker* aWorker);
+  AppendWorker(SameProcessServiceWorker* aWorker);
 
   void
-  RemoveWorker(ServiceWorker* aWorker);
+  RemoveWorker(SameProcessServiceWorker* aWorker);
 
   already_AddRefed<ServiceWorker>
   GetOrCreateInstance(nsPIDOMWindowInner* aWindow);
 
   void
   UpdateInstalledTime();
 
   void
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2618,17 +2618,18 @@ ServiceWorkerManager::GetServiceWorkerFo
   }
 
   if (NS_WARN_IF(!info)) {
     return NS_ERROR_DOM_NOT_FOUND_ERR;
   }
 
   RefPtr<ServiceWorker> serviceWorker = info->GetOrCreateInstance(aWindow);
 
-  serviceWorker->SetState(info->State());
+  // TODO
+  //serviceWorker->SetState(info->State());
   serviceWorker.forget(aServiceWorker);
   return NS_OK;
 }
 
 namespace {
 
 class ContinueDispatchFetchEventRunnable : public Runnable
 {
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -49,16 +49,17 @@ XPIDL_SOURCES += [
 ]
 
 UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
+    'SameProcessServiceWorker.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
