# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b0136b50445bdd90d60412d0fce49faf4d48b113

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -5249,32 +5249,40 @@ WorkerPrivate::EnsureClientSource()
   // ClientHandle.
   //
   // An alternative solution would have been to handle the out-of-order operations
   // on the parent side.  We could have created a small window where we allow
   // ClientHandle objects to exist without a ClientSource.  We would then time
   // out these handles if they stayed orphaned for too long.  This approach would
   // be much more complex, but also avoid this extra bit of latency when starting
   // workers.
-  mClientSource->WorkerSyncPing(this);
+  //
+  // Note, we only have to do this for workers that can be controlled by a
+  // service worker.  So avoid the sync overhead here if we are starting a
+  // service worker or a chrome worker.
+  if (Type() != WorkerTypeService && !IsChromeWorker()) {
+    mClientSource->WorkerSyncPing(this);
+  }
 }
 
 const ClientInfo&
 WorkerPrivate::GetClientInfo() const
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   return mClientSource->Info();
 }
 
 void
 WorkerPrivate::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
+  MOZ_DIAGNOSTIC_ASSERT(!IsChromeWorker());
+  MOZ_DIAGNOSTIC_ASSERT(Type() != WorkerTypeService);
   mClientSource->SetController(aServiceWorker);
 }
 
 void
 WorkerPrivate::ExecutionReady()
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
