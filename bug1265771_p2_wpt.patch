# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  91a8623d7f0f32e71f76dbe7e7f69f024a464624
Bug 1265771 P2 Expand navigate-window.https.html wpt test to cover uncontrolled windows. r=bz

diff --git a/testing/web-platform/tests/service-workers/service-worker/navigate-window.https.html b/testing/web-platform/tests/service-workers/service-worker/navigate-window.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/navigate-window.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/navigate-window.https.html
@@ -24,16 +24,21 @@ function with_window(url) {
   return wait_for_message('LOADED').then(_ => win);
 }
 
 function navigate_window(win, url) {
   win.location = url;
   return wait_for_message('LOADED').then(_ => win);
 }
 
+function reload_window(win) {
+  win.location.reload();
+  return wait_for_message('LOADED').then(_ => win);
+}
+
 function go_back(win) {
   win.history.back();
   return wait_for_message('PAGESHOW').then(_ => win);
 }
 
 function go_forward(win) {
   win.history.forward();
   return wait_for_message('PAGESHOW').then(_ => win);
@@ -56,42 +61,81 @@ function get_clients(win, sw, opts) {
 function validate_window(win, url, opts) {
   return win.navigator.serviceWorker.getRegistration(url)
     .then(reg => {
         // In order to compare service worker instances we need to
         // make sure the DOM object is owned by the same global; the
         // opened window in this case.
         assert_equals(win.navigator.serviceWorker.controller, reg.active,
                       'window should be controlled by service worker');
-        return get_clients(win, reg.active);
+        return get_clients(win, reg.active, opts);
       })
     .then(resultList => {
-        assert_equals(resultList.length, 1, 'there should only be one client');
-        assert_equals(resultList[0].url, url,
-                      'client should be our opened window');
-        assert_equals(resultList[0].frameType, 'auxiliary',
-                      'window.open() should create a client with an auxiliary frame type');
+        // We should always see our controlled window.
+        var expected = [
+          { url: url, frameType: 'auxiliary' }
+        ];
+        // If we are including uncontrolled windows, then we might see the
+        // test window itself and the test harness.
+        if (opts.includeUncontrolled) {
+          expected.push({ url: BASE_URL + 'navigate-window.https.html',
+                          frameType: 'auxiliary' });
+          expected.push({ url: host_info['HTTPS_ORIGIN'] + '/testharness_runner.html',
+                          frameType: 'top-level' });
+        }
+        assert_equals(resultList.length, expected.length,
+                      'expected number of clients');
+        for (var i = 0; i < resultList.length; ++i) {
+          assert_equals(resultList[i].url, expected[i].url,
+                        'client should have expected url');
+          assert_equals(resultList[i].frameType, expected[i].frameType,
+                        ' client should have expected frame type');
+        }
         return win;
       })
 }
 
-async_test(function(t) {
+promise_test(function(t) {
     var worker = BASE_URL + 'resources/navigate-window-worker.js';
-    var scope = BASE_URL + 'resources/loaded.html?navigate-window';
+    var scope = BASE_URL + 'resources/loaded.html?navigate-window-controlled';
     var url1 = scope + '&q=1';
     var url2 = scope + '&q=2';
-    service_worker_unregister_and_register(t, worker, scope)
+    return service_worker_unregister_and_register(t, worker, scope)
       .then(reg => wait_for_state(t, reg.installing, 'activated') )
       .then(___ => with_window(url1))
       .then(win => validate_window(win, url1, { includeUncontrolled: false }))
       .then(win => navigate_window(win, url2))
       .then(win => validate_window(win, url2, { includeUncontrolled: false }))
       .then(win => go_back(win))
       .then(win => validate_window(win, url1, { includeUncontrolled: false }))
       .then(win => go_forward(win))
       .then(win => validate_window(win, url2, { includeUncontrolled: false }))
+      .then(win => reload_window(win))
+      .then(win => validate_window(win, url2, { includeUncontrolled: false }))
       .then(win => win.close())
       .catch(unreached_rejection(t))
-      .then(___ => service_worker_unregister_and_done(t, scope))
+      .then(___ => service_worker_unregister(t, scope))
   }, 'Clients.matchAll() should not show an old window as controlled after ' +
      'it navigates.');
+
+promise_test(function(t) {
+    var worker = BASE_URL + 'resources/navigate-window-worker.js';
+    var scope = BASE_URL + 'resources/loaded.html?navigate-window-uncontrolled';
+    var url1 = scope + '&q=1';
+    var url2 = scope + '&q=2';
+    return service_worker_unregister_and_register(t, worker, scope)
+      .then(reg => wait_for_state(t, reg.installing, 'activated') )
+      .then(___ => with_window(url1))
+      .then(win => validate_window(win, url1, { includeUncontrolled: true }))
+      .then(win => navigate_window(win, url2))
+      .then(win => validate_window(win, url2, { includeUncontrolled: true }))
+      .then(win => go_back(win))
+      .then(win => validate_window(win, url1, { includeUncontrolled: true }))
+      .then(win => go_forward(win))
+      .then(win => validate_window(win, url2, { includeUncontrolled: true }))
+      .then(win => reload_window(win))
+      .then(win => validate_window(win, url2, { includeUncontrolled: true }))
+      .then(win => win.close())
+      .catch(unreached_rejection(t))
+      .then(___ => service_worker_unregister(t, scope))
+  }, 'Clients.matchAll() should not show an old window after it navigates.');
 </script>
 </body>
