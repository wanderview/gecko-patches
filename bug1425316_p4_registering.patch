# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7e0708393b35ee625f82c34d5534640014de739a
Bug 1425316 P4 Note that a ClientSource has called register() for a SW scope and use it to match window console reports. r=asuth

diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -2326,16 +2326,22 @@ nsPIDOMWindowInner::GetClientState() con
 }
 
 Maybe<ServiceWorkerDescriptor>
 nsPIDOMWindowInner::GetController() const
 {
   return Move(nsGlobalWindowInner::Cast(this)->GetController());
 }
 
+void
+nsPIDOMWindowInner::NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope)
+{
+  nsGlobalWindowInner::Cast(this)->NoteCalledRegisterForServiceWorkerScope(aScope);
+}
+
 bool
 nsGlobalWindowInner::ShouldReportForServiceWorkerScope(const nsAString& aScope)
 {
   bool result = false;
 
   nsPIDOMWindowOuter* topOuter = GetScriptableTop();
   NS_ENSURE_TRUE(topOuter, false);
 
@@ -2370,23 +2376,38 @@ nsGlobalWindowInner::ShouldReportForServ
   // First check to see if this window is controlled.  If so, then we have
   // found a match and are done.
   const Maybe<ServiceWorkerDescriptor> swd = GetController();
   if (swd.isSome() && swd.ref().Scope() == aScope) {
     *aResultOut = true;
     return CallState::Stop;
   }
 
+  if (mClientSource && mClientSource->CalledRegisterForServiceWorkerScope(aScope)) {
+    *aResultOut = true;
+    return CallState::Stop;
+  }
+
   // The current window doesn't care about this service worker, but maybe
   // one of our child frames does.
   return CallOnChildren(&nsGlobalWindowInner::ShouldReportForServiceWorkerScopeInternal,
                         aScope, aResultOut);
 }
 
 void
+nsGlobalWindowInner::NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope)
+{
+  if (!mClientSource) {
+    return;
+  }
+
+  mClientSource->NoteCalledRegisterForServiceWorkerScope(aScope);
+}
+
+void
 nsGlobalWindowInner::UpdateTopInnerWindow()
 {
   if (IsTopInnerWindow() || !mTopInnerWindow) {
     return;
   }
 
   mTopInnerWindow->UpdateWebSocketCount(-(int32_t)mNumOfOpenWebSockets);
 }
diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -346,16 +346,18 @@ public:
   void Thaw();
   virtual bool IsFrozen() const override;
   void SyncStateFromParentWindow();
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
   mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
   mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
+  void NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope);
+
   virtual nsresult FireDelayedDOMEvents() override;
 
   virtual nsresult SetNewDocument(nsIDocument *aDocument,
                                   nsISupports *aState,
                                   bool aForceReuseInnerWindow) override;
 
   virtual void SetOpenerWindow(nsPIDOMWindowOuter* aOpener,
                                bool aOriginalOpener) override;
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -326,16 +326,18 @@ public:
   // Return true if there are any open WebSockets that could block
   // timeout-throttling.
   bool HasOpenWebSockets() const;
 
   mozilla::Maybe<mozilla::dom::ClientInfo> GetClientInfo() const;
   mozilla::Maybe<mozilla::dom::ClientState> GetClientState() const;
   mozilla::Maybe<mozilla::dom::ServiceWorkerDescriptor> GetController() const;
 
+  void NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope);
+
   mozilla::dom::TabGroup* TabGroup();
 
   virtual nsPIDOMWindowOuter* GetPrivateRoot() = 0;
 
   virtual mozilla::dom::CustomElementRegistry* CustomElements() = 0;
 
   // XXX: This is called on inner windows
   virtual nsPIDOMWindowOuter* GetScriptableTop() = 0;
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -672,10 +672,25 @@ ClientSource::Traverse(nsCycleCollection
                                 aName, aFlags);
   } else if (mOwner.is<nsCOMPtr<nsIDocShell>>()) {
     ImplCycleCollectionTraverse(aCallback,
                                 mOwner.as<nsCOMPtr<nsIDocShell>>(),
                                 aName, aFlags);
   }
 }
 
+void
+ClientSource::NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope)
+{
+  if (mRegisteringScopeList.Contains(aScope)) {
+    return;
+  }
+  mRegisteringScopeList.AppendElement(aScope);
+}
+
+bool
+ClientSource::CalledRegisterForServiceWorkerScope(const nsACString& aScope)
+{
+  return mRegisteringScopeList.Contains(aScope);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -58,16 +58,18 @@ class ClientSource final : public Client
   Variant<Nothing,
           RefPtr<nsPIDOMWindowInner>,
           nsCOMPtr<nsIDocShell>,
           mozilla::dom::workers::WorkerPrivate*> mOwner;
 
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
+  AutoTArray<nsCString, 1> mRegisteringScopeList;
+
   void
   Shutdown();
 
   void
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
 
   mozilla::dom::workers::WorkerPrivate*
   GetWorkerPrivate() const;
@@ -158,16 +160,22 @@ public:
 
   nsISerialEventTarget*
   EventTarget() const;
 
   void
   Traverse(nsCycleCollectionTraversalCallback& aCallback,
            const char* aName,
            uint32_t aFlags);
+
+  void
+  NoteCalledRegisterForServiceWorkerScope(const nsACString& aScope);
+
+  bool
+  CalledRegisterForServiceWorkerScope(const nsACString& aScope);
 };
 
 inline void
 ImplCycleCollectionUnlink(UniquePtr<ClientSource>& aField)
 {
   aField.reset();
 }
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -833,16 +833,17 @@ ServiceWorkerManager::Register(mozIDOMWi
   }
 
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(documentPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
+  window->NoteCalledRegisterForServiceWorkerScope(cleanedScope);
   AddRegisteringDocument(cleanedScope, doc);
 
   RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey,
                                                             cleanedScope);
 
   RefPtr<ServiceWorkerResolveWindowPromiseOnRegisterCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnRegisterCallback(window, promise);
 
@@ -3645,51 +3646,16 @@ ServiceWorkerManager::ShouldReportToWind
   nsCOMPtr<nsPIDOMWindowOuter> targetWin = nsPIDOMWindowOuter::From(aWindow);
   if (NS_WARN_IF(!targetWin)) {
     return NS_OK;
   }
 
   targetWin = targetWin->GetScriptableTop();
   uint64_t winId = targetWin->WindowID();
 
-  // Check our weak registering document references first.  This way we clear
-  // out as many dead weak references as possible when this method is called.
-  WeakDocumentList* list = mRegisteringDocuments.Get(aScope);
-  if (list) {
-    for (int32_t i = list->Length() - 1; i >= 0; --i) {
-      nsCOMPtr<nsIDocument> doc = do_QueryReferent(list->ElementAt(i));
-      if (!doc) {
-        list->RemoveElementAt(i);
-        continue;
-      }
-
-      if (!doc->IsCurrentActiveDocument()) {
-        continue;
-      }
-
-      nsCOMPtr<nsPIDOMWindowOuter> win = doc->GetWindow();
-      if (!win) {
-        continue;
-      }
-
-      win = win->GetScriptableTop();
-
-      // Match.  We should report to this window.
-      if (win && winId == win->WindowID()) {
-        *aResult = true;
-        return NS_OK;
-      }
-    }
-
-    if (list->IsEmpty()) {
-      list = nullptr;
-      mRegisteringDocuments.Remove(aScope);
-    }
-  }
-
   // Examine any windows performing a navigation that we are currently
   // intercepting.
   InterceptionList* intList = mNavigationInterceptions.Get(aScope);
   if (intList) {
     for (uint32_t i = 0; i < intList->Length(); ++i) {
       nsCOMPtr<nsIInterceptedChannel> channel = intList->ElementAt(i);
 
       nsCOMPtr<nsIChannel> inner;
