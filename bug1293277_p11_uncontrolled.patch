# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6068b5de6a704e666193fdb7e4463fc8371e15c2
Bug 1293277 P11 Handle the case where an iframe starts with an inherited controller and then ends up uncontrolled. r=baku

diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -1809,16 +1809,38 @@ nsGlobalWindowInner::EnsureClientSource(
   // so, mark it as controlled immediately here.  The actor may
   // or may not have been notified by the parent side about being
   // controlled yet.
   if (loadInfo) {
     const Maybe<ServiceWorkerDescriptor> controller = loadInfo->GetController();
     if (controller.isSome()) {
       mClientSource->SetController(controller.ref());
     }
+
+    // We also have to handle the case where te initial about:blank is
+    // controlled due to inheritting the service worker from its parent,
+    // but the actual nsIChannel load is not covered by any service worker.
+    // In this case we want the final page to be uncontrolled.  There is
+    // an open spec issue about how exactly this should be handled, but for
+    // now we just force creation of a new ClientSource to clear the
+    // controller.
+    //
+    //  https://github.com/w3c/ServiceWorker/issues/1232
+    //
+    else if (mClientSource->GetController().isSome()) {
+      mClientSource.reset();
+      mClientSource =
+        ClientManager::CreateSource(ClientType::Window,
+                                    EventTargetFor(TaskCategory::Other),
+                                    mDoc->NodePrincipal());
+      if (NS_WARN_IF(!mClientSource)) {
+        return NS_ERROR_FAILURE;
+      }
+      newClientSource = true;
+    }
   }
 
   // Its possible that we got a client just after being frozen in
   // the bfcache.  In that case freeze the client immediately.
   if (newClientSource && IsFrozen()) {
     mClientSource->Freeze();
   }
 
