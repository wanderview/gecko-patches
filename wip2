# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1e0999195b0d3c69f8bff41ffb12a744ff4cee70

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -21,17 +21,17 @@
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/SendStream.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 using mozilla::Unused;
 using mozilla::dom::cache::CacheReadStream;
 using mozilla::dom::cache::CacheReadStreamOrVoid;
-using mozilla::ipc::AutoIPCStreamChild;
+using mozilla::ipc::AutoIPCStream;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::FileDescriptorSetParent;
 using mozilla::ipc::InputStreamParamsWithFds;
 using mozilla::ipc::InputStreamParamsWithFdsOrSendStream;
 using mozilla::ipc::OptionalFileDescriptorSet;
 using mozilla::ipc::PBackgroundParent;
 using mozilla::ipc::SendStreamChild;
@@ -389,17 +389,17 @@ AutoChildOpArgs::Add(InternalRequest* aR
   }
 }
 
 const CacheOpArgs&
 AutoChildOpArgs::SendAsOpArgs()
 {
   MOZ_ASSERT(!mSent);
   mSent = true;
-  for (UniquePtr<AutoIPCStreamChild>& autoStream : mStreamCleanupList) {
+  for (UniquePtr<AutoIPCStream>& autoStream : mStreamCleanupList) {
     autoStream->TakeValue();
   }
   return mOpArgs;
 }
 
 // --------------------------------------------
 
 AutoParentOpResult::AutoParentOpResult(mozilla::ipc::PBackgroundParent* aManager,
@@ -595,15 +595,15 @@ AutoParentOpResult::SerializeReadStream(
     }
   }
 
   aStreamList->SetStreamControl(mStreamControl);
 
   RefPtr<ReadStream> readStream = ReadStream::Create(mStreamControl,
                                                        aId, stream);
   // TODO: fix this
-  nsTArray<UniquePtr<AutoIPCStreamChild>> fakeList;
+  nsTArray<UniquePtr<AutoIPCStream>> fakeList;
   readStream->Serialize(aReadStreamOut, fakeList);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/AutoUtils.h b/dom/cache/AutoUtils.h
--- a/dom/cache/AutoUtils.h
+++ b/dom/cache/AutoUtils.h
@@ -16,17 +16,17 @@
 struct nsID;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace ipc {
 class PBackgroundParent;
-class AutoIPCStreamChild;
+class AutoIPCStream;
 } // namespace ipc
 
 namespace dom {
 
 class InternalRequest;
 
 namespace cache {
 
@@ -58,17 +58,17 @@ public:
   void Add(InternalRequest* aRequest, BodyAction aBodyAction,
            SchemeAction aSchemeAction, Response& aResponse, ErrorResult& aRv);
 
   const CacheOpArgs& SendAsOpArgs();
 
 private:
   TypeUtils* mTypeUtils;
   CacheOpArgs mOpArgs;
-  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>> mStreamCleanupList;
+  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>> mStreamCleanupList;
   bool mSent;
 };
 
 class MOZ_STACK_CLASS AutoParentOpResult final
 {
 public:
   AutoParentOpResult(mozilla::ipc::PBackgroundParent* aManager,
                      const CacheOpResult& aOpResult);
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -15,17 +15,17 @@
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-using mozilla::ipc::AutoIPCStreamChild;
+using mozilla::ipc::AutoIPCStream;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::OptionalFileDescriptorSet;
 using mozilla::ipc::PFileDescriptorSetChild;
 
 // declared in ActorUtils.h
 PCacheStreamControlChild*
 AllocPCacheStreamControlChild()
@@ -91,22 +91,22 @@ CacheStreamControlChild::SerializeContro
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   aReadStreamOut->controlParent() = nullptr;
   aReadStreamOut->controlChild() = this;
 }
 
 void
 CacheStreamControlChild::SerializeStream(CacheReadStream* aReadStreamOut,
                                          nsIInputStream* aStream,
-                                         nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList)
+                                         nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(aStream);
-  UniquePtr<AutoIPCStreamChild> autoStream(new AutoIPCStreamChild(aReadStreamOut->stream()));
+  UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(aReadStreamOut->stream()));
   autoStream->SerializeOrSend(aStream, Manager());
   aStreamCleanupList.AppendElement(Move(autoStream));
 }
 
 void
 CacheStreamControlChild::NoteClosedAfterForget(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -9,17 +9,17 @@
 
 #include "mozilla/dom/cache/ActorChild.h"
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
 #include "mozilla/dom/cache/StreamControl.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace ipc {
-class AutoIPCStreamChild;
+class AutoIPCStream;
 } // namespace ipc
 namespace dom {
 namespace cache {
 
 class ReadStream;
 
 class CacheStreamControlChild final : public PCacheStreamControlChild
                                     , public StreamControl
@@ -33,17 +33,17 @@ public:
   virtual void StartDestroy() override;
 
   // StreamControl methods
   virtual void
   SerializeControl(CacheReadStream* aReadStreamOut) override;
 
   virtual void
   SerializeStream(CacheReadStream* aReadStreamOut, nsIInputStream* aStream,
-                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList) override;
+                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList) override;
 
 private:
   virtual void
   NoteClosedAfterForget(const nsID& aId) override;
 
 #ifdef DEBUG
   virtual void
   AssertOwningThread() override;
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -50,17 +50,17 @@ CacheStreamControlParent::SerializeContr
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   aReadStreamOut->controlChild() = nullptr;
   aReadStreamOut->controlParent() = this;
 }
 
 void
 CacheStreamControlParent::SerializeStream(CacheReadStream* aReadStreamOut,
                                           nsIInputStream* aStream,
-                                          nsTArray<UniquePtr<AutoIPCStreamChild>>&)
+                                          nsTArray<UniquePtr<AutoIPCStream>>&)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(aStream);
   SerializeInputStream(aStream, aReadStreamOut->stream(), Manager());
 }
 
 void
 CacheStreamControlParent::NoteClosedAfterForget(const nsID& aId)
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -8,17 +8,17 @@
 #define mozilla_dom_cache_CacheStreamControlParent_h
 
 #include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/StreamControl.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace ipc {
-class AutoIPCStreamChild;
+class AutoIPCStream;
 } // namespace ipc
 namespace dom {
 namespace cache {
 
 class ReadStream;
 class StreamList;
 
 class CacheStreamControlParent final : public PCacheStreamControlParent
@@ -34,17 +34,17 @@ public:
   void Shutdown();
 
   // StreamControl methods
   virtual void
   SerializeControl(CacheReadStream* aReadStreamOut) override;
 
   virtual void
   SerializeStream(CacheReadStream* aReadStreamOut, nsIInputStream* aStream,
-                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList) override;
+                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList) override;
 
 private:
   virtual void
   NoteClosedAfterForget(const nsID& aId) override;
 
 #ifdef DEBUG
   virtual void
   AssertOwningThread() override;
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -15,37 +15,37 @@
 #include "nsIAsyncInputStream.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::Unused;
-using mozilla::ipc::AutoIPCStreamChild;
+using mozilla::ipc::AutoIPCStream;
 using mozilla::ipc::InputStreamParamsWithFdsOrSendStream;
 
 // ----------------------------------------------------------------------------
 
 // The inner stream class.  This is where all of the real work is done.  As
 // an invariant Inner::Close() must be called before ~Inner().  This is
 // guaranteed by our outer ReadStream class.
 class ReadStream::Inner final : public ReadStream::Controllable
 {
 public:
   Inner(StreamControl* aControl, const nsID& aId,
         nsIInputStream* aStream);
 
   void
   Serialize(CacheReadStreamOrVoid* aReadStreamOut,
-            nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList);
+            nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList);
 
   void
   Serialize(CacheReadStream* aReadStreamOut,
-            nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList);
+            nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList);
 
   // ReadStream::Controllable methods
   virtual void
   CloseStream() override;
 
   virtual void
   CloseStreamWithoutReporting() override;
 
@@ -195,28 +195,28 @@ ReadStream::Inner::Inner(StreamControl* 
 {
   MOZ_ASSERT(mStream);
   MOZ_ASSERT(mControl);
   mControl->AddReadStream(this);
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStreamOrVoid* aReadStreamOut,
-                             nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList)
+                             nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
   CacheReadStream stream;
   Serialize(&stream, aStreamCleanupList);
   *aReadStreamOut = stream;
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStream* aReadStreamOut,
-                             nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList)
+                             nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(mState == Open);
   MOZ_ASSERT(mControl);
 
   aReadStreamOut->id() = mId;
   mControl->SerializeControl(aReadStreamOut);
@@ -472,24 +472,24 @@ ReadStream::Create(PCacheStreamControlPa
   auto actor = static_cast<CacheStreamControlParent*>(aControl);
   RefPtr<Inner> inner = new Inner(actor, aId, aStream);
   RefPtr<ReadStream> ref = new ReadStream(inner);
   return ref.forget();
 }
 
 void
 ReadStream::Serialize(CacheReadStreamOrVoid* aReadStreamOut,
-                      nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList)
+                      nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   mInner->Serialize(aReadStreamOut, aStreamCleanupList);
 }
 
 void
 ReadStream::Serialize(CacheReadStream* aReadStreamOut,
-                      nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList)
+                      nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   mInner->Serialize(aReadStreamOut, aStreamCleanupList);
 }
 
 ReadStream::ReadStream(ReadStream::Inner* aInner)
   : mInner(aInner)
 {
   MOZ_ASSERT(mInner);
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -12,17 +12,17 @@
 #include "nsID.h"
 #include "nsIInputStream.h"
 #include "nsISupportsImpl.h"
 #include "mozilla/RefPtr.h"
 #include "nsTArrayForwardDeclare.h"
 
 namespace mozilla {
 namespace ipc {
-class AutoIPCStreamChild;
+class AutoIPCStream;
 } // namespace ipc
 namespace dom {
 namespace cache {
 
 class CacheReadStream;
 class CacheReadStreamOrVoid;
 class PCacheStreamControlParent;
 
@@ -80,19 +80,19 @@ public:
   static already_AddRefed<ReadStream>
   Create(const CacheReadStream& aReadStream);
 
   static already_AddRefed<ReadStream>
   Create(PCacheStreamControlParent* aControl, const nsID& aId,
          nsIInputStream* aStream);
 
   void Serialize(CacheReadStreamOrVoid* aReadStreamOut,
-                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList);
+                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList);
   void Serialize(CacheReadStream* aReadStreamOut,
-                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList);
+                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList);
 
 private:
   class Inner;
 
   explicit ReadStream(Inner* aInner);
   ~ReadStream();
 
   // Hold a strong ref to an inner class that actually implements the
diff --git a/dom/cache/StreamControl.h b/dom/cache/StreamControl.h
--- a/dom/cache/StreamControl.h
+++ b/dom/cache/StreamControl.h
@@ -10,17 +10,17 @@
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/RefPtr.h"
 #include "nsTObserverArray.h"
 
 struct nsID;
 
 namespace mozilla {
 namespace ipc {
-class AutoIPCStreamChild;
+class AutoIPCStream;
 } // namespace ipc
 namespace dom {
 namespace cache {
 
 class CacheReadStream;
 
 // Abstract class to help implement the stream control Child and Parent actors.
 // This provides an interface to partly help with serialization of IPC types,
@@ -29,17 +29,17 @@ class StreamControl
 {
 public:
   // abstract interface that must be implemented by child class
   virtual void
   SerializeControl(CacheReadStream* aReadStreamOut) = 0;
 
   virtual void
   SerializeStream(CacheReadStream* aReadStreamOut, nsIInputStream* aStream,
-                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList) = 0;
+                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList) = 0;
 
   // inherited implementation of the ReadStream::Controllable list
 
   // Begin controlling the given ReadStream.  This causes a strong ref to
   // be held by the control.  The ReadStream must call NoteClosed() or
   // ForgetReadStream() to release this ref.
   void
   AddReadStream(ReadStream::Controllable* aReadStream);
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -29,17 +29,17 @@
 #include "nsURLParsers.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-using mozilla::ipc::AutoIPCStreamChild;
+using mozilla::ipc::AutoIPCStream;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 
 namespace {
 
 static bool
@@ -116,17 +116,17 @@ TypeUtils::ToInternalRequest(const Ownin
   }
 
   return ToInternalRequest(aIn.GetAsUSVString(), aRv);
 }
 
 void
 TypeUtils::ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
                           BodyAction aBodyAction, SchemeAction aSchemeAction,
-                          nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList,
+                          nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                           ErrorResult& aRv)
 {
   MOZ_ASSERT(aIn);
 
   aIn->GetMethod(aOut.method());
 
   nsAutoCString url;
   aIn->GetURL(url);
@@ -206,17 +206,17 @@ TypeUtils::ToCacheResponseWithoutBody(Ca
     aOut.principalInfo() = *aIn.GetPrincipalInfo();
   } else {
     aOut.principalInfo() = void_t();
   }
 }
 
 void
 TypeUtils::ToCacheResponse(CacheResponse& aOut, Response& aIn,
-                           nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList,
+                           nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                            ErrorResult& aRv)
 {
   if (aIn.BodyUsed()) {
     aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
     return;
   }
 
   RefPtr<InternalResponse> ir = aIn.GetInternalResponse();
@@ -475,17 +475,17 @@ TypeUtils::ToInternalRequest(const nsASt
   if (NS_WARN_IF(aRv.Failed())) { return nullptr; }
 
   return request->GetInternalRequest();
 }
 
 void
 TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
                                 CacheReadStreamOrVoid* aStreamOut,
-                                nsTArray<UniquePtr<AutoIPCStreamChild>>& aStreamCleanupList,
+                                nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                                 ErrorResult& aRv)
 {
   *aStreamOut = void_t();
   if (!aStream) {
     return;
   }
 
   // Option 1: Send a cache-specific ReadStream if we can.
@@ -494,17 +494,17 @@ TypeUtils::SerializeCacheStream(nsIInput
     controlled->Serialize(aStreamOut, aStreamCleanupList);
     return;
   }
 
   CacheReadStream readStream;
   readStream.controlChild() = nullptr;
   readStream.controlParent() = nullptr;
 
-  UniquePtr<AutoIPCStreamChild> autoStream(new AutoIPCStreamChild(readStream.stream()));
+  UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(readStream.stream()));
   autoStream->SerializeOrSend(aStream, GetIPCManager());
 
   aStreamCleanupList.AppendElement(Move(autoStream));
   *aStreamOut = readStream;
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -16,17 +16,17 @@ class nsIGlobalObject;
 class nsIAsyncInputStream;
 class nsIInputStream;
 
 namespace mozilla {
 
 namespace ipc {
 class PBackgroundChild;
 class SendStreamChild;
-class AutoIPCStreamChild;
+class AutoIPCStream;
 }
 
 namespace dom {
 
 struct CacheQueryOptions;
 class InternalRequest;
 class InternalResponse;
 class OwningRequestOrUSVString;
@@ -75,26 +75,26 @@ public:
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const OwningRequestOrUSVString& aIn, BodyAction aBodyAction,
                     ErrorResult& aRv);
 
   void
   ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
                  BodyAction aBodyAction, SchemeAction aSchemeAction,
-                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList,
+                 nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList,
                  ErrorResult& aRv);
 
   void
   ToCacheResponseWithoutBody(CacheResponse& aOut, InternalResponse& aIn,
                              ErrorResult& aRv);
 
   void
   ToCacheResponse(CacheResponse& aOut, Response& aIn,
-                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList,
+                  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList,
                   ErrorResult& aRv);
 
   void
   ToCacheQueryParams(CacheQueryParams& aOut, const CacheQueryOptions& aIn);
 
   already_AddRefed<Response>
   ToResponse(const CacheResponse& aIn);
 
@@ -133,17 +133,17 @@ private:
   CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                       ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const nsAString& aIn, ErrorResult& aRv);
 
   void
   SerializeCacheStream(nsIInputStream* aStream, CacheReadStreamOrVoid* aStreamOut,
-                       nsTArray<UniquePtr<mozilla::ipc::AutoIPCStreamChild>>& aStreamCleanupList,
+                       nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>>& aStreamCleanupList,
                        ErrorResult& aRv);
 
   void
   SerializeSendStream(nsIInputStream* aStream, CacheReadStream& aReadStreamOut,
                       ErrorResult& aRv);
 };
 
 } // namespace cache
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -186,17 +186,17 @@ DeserializeInputStream(const OptionalInp
 
   return stream.forget();
 }
 
 namespace {
 
 // The SerializeOrSendInputStream() and CleanupSendInputStreamParamsWithFdsOrSendStream
 // functions could be externally exposed.  For now, though, keep them private
-// to encourage use of the safer RAII AutoIPCStreamChild class.
+// to encourage use of the safer RAII AutoIPCStream class.
 
 template<typename M>
 void
 SerializeInputStreamWithFdsChild(nsIInputStream* aStream,
                                  InputStreamParamsWithFdsOrSendStream& aValue,
                                  M* aManager)
 {
   MOZ_ASSERT(aStream);
@@ -462,87 +462,86 @@ SerializeInputStream(nsIInputStream* aIn
 void
 SerializeInputStream(nsIInputStream* aInputStream,
                      InputStreamParamsWithFdsOrSendStream& aValue,
                      PBackgroundParent* aManager)
 {
   SerializeInputStreamWithFdsParent(aInputStream, aValue, aManager);
 }
 
-AutoIPCStreamChild::AutoIPCStreamChild()
+AutoIPCStream::AutoIPCStream()
   : mInlineValue(void_t())
   , mValue(nullptr)
   , mOptionalValue(&mInlineValue)
   , mTaken(false)
 {
 }
 
-AutoIPCStreamChild::AutoIPCStreamChild(InputStreamParamsWithFdsOrSendStream& aTarget)
+AutoIPCStream::AutoIPCStream(InputStreamParamsWithFdsOrSendStream& aTarget)
   : mInlineValue(void_t())
   , mValue(&aTarget)
   , mOptionalValue(nullptr)
   , mTaken(false)
 {
 }
 
-AutoIPCStreamChild::AutoIPCStreamChild(OptionalInputStreamParamsWithFdsOrSendStream& aTarget)
+AutoIPCStream::AutoIPCStream(OptionalInputStreamParamsWithFdsOrSendStream& aTarget)
   : mInlineValue(void_t())
   , mValue(nullptr)
   , mOptionalValue(&aTarget)
   , mTaken(false)
 {
   *mOptionalValue = void_t();
 }
 
-AutoIPCStreamChild::~AutoIPCStreamChild()
+AutoIPCStream::~AutoIPCStream()
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   if (mValue && IsSet()) {
     CleanupInputStreamParamsWithFdsOrSendStream(*mValue, mTaken);
   } else {
     CleanupInputStreamParamsWithFdsOrSendStream(*mOptionalValue, mTaken);
   }
 }
 
 void
-AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
-                                    PContentChild* aManager)
+AutoIPCStream::SerializeOrSend(nsIInputStream* aStream, PContentChild* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
   }
 }
 
 void
-AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
-                                    PBackgroundChild* aManager)
+AutoIPCStream::SerializeOrSend(nsIInputStream* aStream,
+                               PBackgroundChild* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
   }
 }
 
 bool
-AutoIPCStreamChild::IsSet() const
+AutoIPCStream::IsSet() const
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   if (mValue) {
     return mValue->type() != InputStreamParamsWithFdsOrSendStream::T__None;
   } else {
     return mOptionalValue->type() !=
            OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t;
   }
@@ -565,17 +564,17 @@ AssertValidValueToTake(const OptionalInp
   if (aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream) {
     AssertValidValueToTake(aVal.get_InputStreamParamsWithFdsOrSendStream());
   }
 }
 
 } // anonymous namespace
 
 InputStreamParamsWithFdsOrSendStream&
-AutoIPCStreamChild::TakeValue()
+AutoIPCStream::TakeValue()
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(IsSet());
 
   mTaken = true;
 
   if (mValue) {
@@ -586,17 +585,17 @@ AutoIPCStreamChild::TakeValue()
   InputStreamParamsWithFdsOrSendStream& value =
     mOptionalValue->get_InputStreamParamsWithFdsOrSendStream();
 
   AssertValidValueToTake(value);
   return value;
 }
 
 OptionalInputStreamParamsWithFdsOrSendStream&
-AutoIPCStreamChild::TakeOptionalValue()
+AutoIPCStream::TakeOptionalValue()
 {
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!mValue);
   MOZ_ASSERT(mOptionalValue);
   mTaken = true;
   AssertValidValueToTake(*mOptionalValue);
   return *mOptionalValue;
 }
diff --git a/ipc/glue/InputStreamUtils.h b/ipc/glue/InputStreamUtils.h
--- a/ipc/glue/InputStreamUtils.h
+++ b/ipc/glue/InputStreamUtils.h
@@ -44,17 +44,17 @@ DeserializeInputStream(const OptionalInp
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const InputStreamParamsWithFdsOrSendStream& aValue);
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const OptionalInputStreamParamsWithFdsOrSendStream& aValue);
 
 // These serialization methods do not support sending as a PSendStream.  Use
-// AutoIPCStreamChild::SerializeOrSend() if you need to support non-serializable
+// AutoIPCStream::SerializeOrSend() if you need to support non-serializable
 // streams.
 void
 SerializeInputStream(nsIInputStream* aInputStream,
                      InputStreamParamsWithFdsOrSendStream& aValue,
                      dom::PContentChild* aManager);
 
 void
 SerializeInputStream(nsIInputStream* aInputStream,
@@ -86,67 +86,67 @@ SerializeInputStream(nsIInputStream* aSt
 // InputStreamParamsWithFdsOrSendStream IPC struct.  Any SendStreamChild actors
 // are automatically managed correctly.
 //
 // Use the TakeValue() method when passing the value (or just after passing the
 // value) to the IPC Send*() method.
 //
 // For example:
 //
-//  AutoIPCStreamChild streamChild();
-//  streamChild.SerializeOrSend(inputStream, actor->Manager());
-//  actor->SendData(streamChild.TakeValue());
+//  AutoIPCStream stream();
+//  stream.SerializeOrSend(inputStream, actor->Manager());
+//  actor->SendData(stream.TakeValue());
 //
 // If you need to manage an InputStreamParamsWithFdsOrSendStream struct embedded in
-// another type, you can create the AutoIPCStreamChild around the existing
+// another type, you can create the AutoIPCStream around the existing
 // struct like this:
 //
 //  MyIPCStruct data;
-//  AutoIpcStreamChild streamChild(data.myStream());
-//  streamChild.SerializeOrSend(inputStream, actor->Manager());
+//  AutoIPCStream stream(data.myStream());
+//  stream.SerializeOrSend(inputStream, actor->Manager());
 //  actor->SendData(data);
-//  streamChild.TakeValue();
+//  stream.TakeValue();
 //
-// The AutoIPCStreamChild class also supports OptionalInputStreamParamsWithFdsOrSendStream
+// The AutoIPCStream class also supports OptionalInputStreamParamsWithFdsOrSendStream
 // values.  As long as you did not initialize the object with a non-optional
 // InputStreamParamsWithFdsOrSendStream, you can call TakeOptionalValue() instead.
 //
-// Like SerializeInputStream(), the AutoIPCStreamChild will crash if
+// Like SerializeInputStream(), the AutoIPCStream will crash if
 // serialization cannot be completed.  Currently, this should only
 // occur if the nsIInputStream cannot be serialized and is also blocking.
 //
 // NOTE: This is not a MOZ_STACK_CLASS so that it can be more easily integrated
 //       with complex ipdl structures.  For example, you may want to create an
-//       array of RAII AutoIPCStreamChild objects or build your own wrapping
+//       array of RAII AutoIPCStream objects or build your own wrapping
 //       RAII object to handle other actors that need to be cleaned up.
-class AutoIPCStreamChild final
+class AutoIPCStream final
 {
   OptionalInputStreamParamsWithFdsOrSendStream mInlineValue;
   InputStreamParamsWithFdsOrSendStream* mValue;
   OptionalInputStreamParamsWithFdsOrSendStream* mOptionalValue;
   bool mTaken;
 
   bool
   IsSet() const;
 
 public:
   // Implicitly create an OptionalInputStreamParamsWithFdsOrSendStream value.  Either
   // TakeValue() or TakeOptionalValue() can be used.
-  AutoIPCStreamChild();
+  AutoIPCStream();
 
   // Wrap an existing InputStreamParamsWithFdsOrSendStream.  Only TakeValue() may be
   // used.  If a nullptr nsIInputStream is passed to SerializeOrSend() then
   // a crash will be forced.
-  explicit AutoIPCStreamChild(InputStreamParamsWithFdsOrSendStream& aTarget);
+  explicit AutoIPCStream(InputStreamParamsWithFdsOrSendStream& aTarget);
 
   // Wrap an existing OptionalInputStreamParamsWithFdsOrSendStream.  Either TakeValue()
   // or TakeOptionalValue can be used.
-  explicit AutoIPCStreamChild(OptionalInputStreamParamsWithFdsOrSendStream& aTarget);
+  explicit AutoIPCStream(OptionalInputStreamParamsWithFdsOrSendStream& aTarget);
 
-  ~AutoIPCStreamChild();
+  ~AutoIPCStream();
 
   // Serialize the input stream or create a SendStream actor using the PContent
   // manager.  If neither of these succeed, then crash.  This should only be
   // used on the main thread.
   void
   SerializeOrSend(nsIInputStream* aStream, dom::PContentChild* aManager);
 
   // Serialize the input stream or create a SendStream actor using the
