# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  197c44c09d028bced2f0d31c8656da9e7c8495fa
Bug 1204254 P2 Move StartSynthesizedResponse() out from FinishSynthesizedResponse(). r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -228,17 +228,23 @@ public:
     mInternalResponse->UnfilteredHeaders()->GetEntries(entries);
     for (uint32_t i = 0; i < entries.Length(); ++i) {
        mChannel->SynthesizeHeader(entries[i].mName, entries[i].mValue);
     }
 
     auto castLoadInfo = static_cast<LoadInfo*>(loadInfo.get());
     castLoadInfo->SynthesizeServiceWorkerTainting(mInternalResponse->GetTainting());
 
-    rv = mChannel->FinishSynthesizedResponse(mResponseURLSpec);
+    rv = mChannel->StartSynthesizedResponse(mResponseURLSpec);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
+      return NS_OK;
+    }
+
+    rv = mChannel->FinishSynthesizedResponse();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
     TimeStamp timeStamp = TimeStamp::Now();
     mChannel->SetHandleFetchEventEnd(timeStamp);
     mChannel->SetFinishSynthesizedResponseEnd(timeStamp);
diff --git a/netwerk/base/nsINetworkInterceptController.idl b/netwerk/base/nsINetworkInterceptController.idl
--- a/netwerk/base/nsINetworkInterceptController.idl
+++ b/netwerk/base/nsINetworkInterceptController.idl
@@ -49,26 +49,30 @@ interface nsIInterceptedChannel : nsISup
     void synthesizeStatus(in uint16_t status, in ACString reason);
 
     /**
      * Attach a header name/value pair to the forthcoming synthesized response.
      * Overwrites any existing header value.
      */
     void synthesizeHeader(in ACString name, in ACString value);
 
-    void startSynthesizedResponse(in ACString finalURLSpec);
-
     /**
-     * Instruct a channel that has been intercepted that a response has been
-     * synthesized and can now be read. No further header modification is allowed
+     * Instruct a channel that has been intercepted that a response is
+     * starting to be synthesized.  No further header modification is allowed
      * after this point. The caller may optionally pass a spec for a URL that
      * this response originates from; an empty string will cause the original
      * intercepted request's URL to be used instead.
      */
-    void finishSynthesizedResponse(in ACString finalURLSpec);
+    void startSynthesizedResponse(in ACString finalURLSpec);
+
+    /**
+     * Instruct a channel that has been intercepted that response synthesis
+     * has completed and all outstanding resources can be closed.
+     */
+    void finishSynthesizedResponse();
 
     /**
      * Cancel the pending intercepted request.
      * @return NS_ERROR_FAILURE if the response has already been synthesized or
      *         the original request has been instructed to continue.
      */
     void cancelInterception(in nsresult status);
 
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -313,17 +313,18 @@ public:
     , mChannel(aChannel)
   {
   }
 
   NS_IMETHOD Run() override
   {
     // The URL passed as an argument here doesn't matter, since the child will
     // receive a redirection notification as a result of this synthesized response.
-    mChannel->FinishSynthesizedResponse(EmptyCString());
+    mChannel->StartSynthesizedResponse(EmptyCString());
+    mChannel->FinishSynthesizedResponse();
     return NS_OK;
   }
 };
 
 NS_IMETHODIMP
 HttpChannelParentListener::ChannelIntercepted(nsIInterceptedChannel* aChannel)
 {
   // Its possible for the child-side interception to complete and tear down
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -316,32 +316,29 @@ InterceptedChannelContent::StartSynthesi
                                               mSynthesizedInput,
                                               mStreamListener);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
-InterceptedChannelContent::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedChannelContent::FinishSynthesizedResponse()
 {
   if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Make sure the body output stream is always closed.  If the channel was
   // intercepted with a null-body response then its possible the synthesis
   // completed without a stream copy operation.
   mResponseBody->Close();
 
   mReportCollector->FlushConsoleReports(mChannel);
 
-  nsresult rv = StartSynthesizedResponse(aFinalURLSpec);
-  NS_ENSURE_SUCCESS(rv, rv);
-
   mResponseBody = nullptr;
   mStreamListener = nullptr;
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -183,17 +183,17 @@ class InterceptedChannelContent : public
 public:
   InterceptedChannelContent(HttpChannelChild* aChannel,
                             nsINetworkInterceptController* aController,
                             InterceptStreamListener* aListener,
                             bool aSecureUpgrade);
 
   NS_IMETHOD ResetInterception() override;
   NS_IMETHOD StartSynthesizedResponse(const nsACString& aFinalURLSpec) override;
-  NS_IMETHOD FinishSynthesizedResponse(const nsACString& aFinalURLSpec) override;
+  NS_IMETHOD FinishSynthesizedResponse() override;
   NS_IMETHOD GetChannel(nsIChannel** aChannel) override;
   NS_IMETHOD GetSecureUpgradedChannelURI(nsIURI** aURI) override;
   NS_IMETHOD SynthesizeStatus(uint16_t aStatus, const nsACString& aReason) override;
   NS_IMETHOD SynthesizeHeader(const nsACString& aName, const nsACString& aValue) override;
   NS_IMETHOD CancelInterception(nsresult aStatus) override;
   NS_IMETHOD SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo) override;
   NS_IMETHOD GetInternalContentPolicyType(nsContentPolicyType *aInternalContentPolicyType) override;
 
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -733,27 +733,27 @@ InterceptedHttpChannel::StartSynthesized
   if (!equal) {
     return RedirectForOpaqueResponse(responseURI);
   }
 
   return StartPump();
 }
 
 NS_IMETHODIMP
-InterceptedHttpChannel::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedHttpChannel::FinishSynthesizedResponse()
 {
   if (mCanceled) {
     return mStatus;
   }
 
   if (mBodyWriter) {
     mBodyWriter->Close();
   }
 
-  return StartSynthesizedResponse(aFinalURLSpec);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::CancelInterception(nsresult aStatus)
 {
   return Cancel(aStatus);
 }
 
diff --git a/netwerk/test/unit/test_synthesized_response.js b/netwerk/test/unit/test_synthesized_response.js
--- a/netwerk/test/unit/test_synthesized_response.js
+++ b/netwerk/test/unit/test_synthesized_response.js
@@ -50,17 +50,18 @@ function make_channel(url, body, cb) {
     channelIntercepted: function(channel) {
       channel.QueryInterface(Ci.nsIInterceptedChannel);
       if (body) {
         var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                             .createInstance(Ci.nsIStringInputStream);
         synthesized.data = body;
 
         NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
-          channel.finishSynthesizedResponse('');
+          channel.startSynthesizedResponse('');
+          channel.finishSynthesizedResponse();
         });
       }
       if (cb) {
         cb(channel);
       }
       return {
         dispatch: function() { }
       };
@@ -140,17 +141,18 @@ add_test(function() {
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(channel) {
     do_timeout(100, function() {
       var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                           .createInstance(Ci.nsIStringInputStream);
       synthesized.data = NON_REMOTE_BODY;
       NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
         channel.synthesizeHeader("Content-Length", NON_REMOTE_BODY.length);
-        channel.finishSynthesizedResponse('');
+        channel.startSynthesizedResponse('');
+        channel.finishSynthesizedResponse();
       });
     });
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null));
 });
 
 // ensure that the channel waits for a decision
 add_test(function() {
@@ -168,17 +170,18 @@ add_test(function() {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       // set the content-type to ensure that the stream converter doesn't hold up notifications
       // and cause the test to fail
       intercepted.synthesizeHeader("Content-Type", "text/plain");
-      intercepted.finishSynthesizedResponse('');
+      intercepted.startSynthesizedResponse('');
+      intercepted.finishSynthesizedResponse();
     });
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null,
 				     CL_ALLOW_UNKNOWN_CL | CL_SUSPEND | CL_EXPECT_3S_DELAY));
 });
 
 // ensure that the intercepted channel can be cancelled
 add_test(function() {
@@ -209,34 +212,36 @@ add_test(function() {
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       let channel = intercepted.channel;
-      intercepted.finishSynthesizedResponse('');
+      intercepted.startSynthesizedResponse('');
+      intercepted.finishSynthesizedResponse();
       channel.cancel(Cr.NS_BINDING_ABORTED);
     });
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
 // ensure that the intercepted channel can be canceled before the response
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       intercepted.channel.cancel(Cr.NS_BINDING_ABORTED);
-      intercepted.finishSynthesizedResponse('');
+      intercepted.startSynthesizedResponse('');
+      intercepted.finishSynthesizedResponse();
     });
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
 // Ensure that nsIInterceptedChannel.channelIntercepted() can return an error.
 // In this case we should automatically ResetInterception() and complete the
