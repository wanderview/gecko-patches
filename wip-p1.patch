# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d92fd6b6d6bfc5b566222ae2957e55772d60151a
Bug 1333573 P1 Factor setting the worker principal out into a separate method. r=baku

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -99,16 +99,84 @@ GetBaseURI(bool aIsMainScript, WorkerPri
     baseURI = aWorkerPrivate->GetBaseURI();
     NS_ASSERTION(baseURI, "Should have been set already!");
   }
 
   return baseURI;
 }
 
 nsresult
+SetPrincipalFromChannel(WorkerPrivate* aWorkerPrivate, nsIChannel* aChannel)
+{
+  AssertIsOnMainThread();
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(aChannel);
+
+  WorkerPrivate* parent = aWorkerPrivate->GetParent();
+
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate->GetPrincipal() || parent);
+  nsCOMPtr<nsIPrincipal> loadPrincipal = aWorkerPrivate->GetPrincipal() ?
+                                         aWorkerPrivate->GetPrincipal() :
+                                         parent->GetPrincipal();
+  MOZ_DIAGNOSTIC_ASSERT(loadPrincipal);
+
+  nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+  MOZ_DIAGNOSTIC_ASSERT(ssm);
+
+  nsCOMPtr<nsIPrincipal> channelPrincipal;
+  nsresult rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(channelPrincipal));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsILoadGroup> channelLoadGroup;
+  rv = aChannel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
+  NS_ENSURE_SUCCESS(rv, rv);
+  MOZ_ASSERT(channelLoadGroup);
+
+  // If the load principal is the system principal then the channel
+  // principal must also be the system principal (we do not allow chrome
+  // code to create workers with non-chrome scripts, and if we ever decide
+  // to change this we need to make sure we don't always set
+  // mPrincipalIsSystem to true in WorkerPrivate::GetLoadInfo()). Otherwise
+  // this channel principal must be same origin with the load principal (we
+  // check again here in case redirects changed the location of the script).
+  if (nsContentUtils::IsSystemPrincipal(loadPrincipal)) {
+    if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
+      nsCOMPtr<nsIURI> finalURI;
+      rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(finalURI));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      // See if this is a resource URI. Since JSMs usually come from
+      // resource:// URIs we're currently considering all URIs with the
+      // URI_IS_UI_RESOURCE flag as valid for creating privileged workers.
+      bool isResource;
+      rv = NS_URIChainHasFlags(finalURI,
+                               nsIProtocolHandler::URI_IS_UI_RESOURCE,
+                               &isResource);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (isResource) {
+        // Assign the system principal to the resource:// worker only if it
+        // was loaded from code using the system principal.
+        channelPrincipal = loadPrincipal;
+      } else {
+        return NS_ERROR_DOM_BAD_URI;
+      }
+    }
+  }
+
+  // The principal can change, but it should still match the original
+  // load group's appId and browser element flag.
+  MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal));
+
+  aWorkerPrivate->SetPrincipal(channelPrincipal, channelLoadGroup);
+
+  return NS_OK;
+}
+
+nsresult
 ChannelFromScriptURL(nsIPrincipal* principal,
                      nsIURI* baseURI,
                      nsIDocument* parentDoc,
                      nsILoadGroup* loadGroup,
                      nsIIOService* ios,
                      nsIScriptSecurityManager* secMan,
                      const nsAString& aScriptURL,
                      bool aIsMainScript,
@@ -1132,71 +1200,18 @@ private:
     // worker's primary script.
     if (IsMainWorkerScript()) {
       // Take care of the base URI first.
       mWorkerPrivate->SetBaseURI(finalURI);
 
       // Store the channel info if needed.
       mWorkerPrivate->InitChannelInfo(channel);
 
-      // Now to figure out which principal to give this worker.
-      WorkerPrivate* parent = mWorkerPrivate->GetParent();
-
-      NS_ASSERTION(mWorkerPrivate->GetPrincipal() || parent,
-                   "Must have one of these!");
-
-      nsCOMPtr<nsIPrincipal> loadPrincipal = mWorkerPrivate->GetPrincipal() ?
-                                             mWorkerPrivate->GetPrincipal() :
-                                             parent->GetPrincipal();
-
-      nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
-      NS_ASSERTION(ssm, "Should never be null!");
-
-      nsCOMPtr<nsIPrincipal> channelPrincipal;
-      rv = ssm->GetChannelResultPrincipal(channel, getter_AddRefs(channelPrincipal));
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      nsCOMPtr<nsILoadGroup> channelLoadGroup;
-      rv = channel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
+      rv = SetPrincipalFromChannel(mWorkerPrivate, channel);
       NS_ENSURE_SUCCESS(rv, rv);
-      MOZ_ASSERT(channelLoadGroup);
-
-      // If the load principal is the system principal then the channel
-      // principal must also be the system principal (we do not allow chrome
-      // code to create workers with non-chrome scripts, and if we ever decide
-      // to change this we need to make sure we don't always set
-      // mPrincipalIsSystem to true in WorkerPrivate::GetLoadInfo()). Otherwise
-      // this channel principal must be same origin with the load principal (we
-      // check again here in case redirects changed the location of the script).
-      if (nsContentUtils::IsSystemPrincipal(loadPrincipal)) {
-        if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
-          // See if this is a resource URI. Since JSMs usually come from
-          // resource:// URIs we're currently considering all URIs with the
-          // URI_IS_UI_RESOURCE flag as valid for creating privileged workers.
-          bool isResource;
-          rv = NS_URIChainHasFlags(finalURI,
-                                   nsIProtocolHandler::URI_IS_UI_RESOURCE,
-                                   &isResource);
-          NS_ENSURE_SUCCESS(rv, rv);
-
-          if (isResource) {
-            // Assign the system principal to the resource:// worker only if it
-            // was loaded from code using the system principal.
-            channelPrincipal = loadPrincipal;
-          } else {
-            return NS_ERROR_DOM_BAD_URI;
-          }
-        }
-      }
-
-      // The principal can change, but it should still match the original
-      // load group's appId and browser element flag.
-      MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal));
-
-      mWorkerPrivate->SetPrincipal(channelPrincipal, channelLoadGroup);
 
       // We did inherit CSP in bug 1223647. If we do not already have a CSP, we
       // should get it from the HTTP headers on the worker script.
       if (!mWorkerPrivate->GetCSP() && CSPService::sCSPEnabled) {
         NS_ConvertASCIItoUTF16 cspHeaderValue(tCspHeaderValue);
         NS_ConvertASCIItoUTF16 cspROHeaderValue(tCspROHeaderValue);
 
         nsIPrincipal* principal = mWorkerPrivate->GetPrincipal();
@@ -1234,16 +1249,17 @@ private:
           NS_ENSURE_SUCCESS(rv, rv);
 
 
           if (hasReferrerPolicy) { //FIXME bug 1307366: move RP out of CSP code
             mWorkerPrivate->SetReferrerPolicy(static_cast<net::ReferrerPolicy>(rp));
           }
         }
       }
+      WorkerPrivate* parent = mWorkerPrivate->GetParent();
       if (parent) {
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
       }
     }
 
     NS_ConvertUTF8toUTF16 tRPHeaderValue(tRPHeaderCValue);
     // If there's a Referrer-Policy header, apply it.
