# HG changeset patch
# Parent 0338d81b778c0d02cd0a372d65f0b14119a7f97d
# User Ben Kelly <ben@wanderview.com>
Improve loadgroup usage in script loader a bit.

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -25,16 +25,17 @@
 #include "nsScriptLoader.h"
 #include "nsString.h"
 #include "nsTArray.h"
 #include "nsThreadUtils.h"
 #include "nsXPCOM.h"
 #include "xpcpublic.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/LoadContext.h"
 #include "mozilla/dom/Exceptions.h"
 #include "Principal.h"
 #include "WorkerFeature.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
 #define MAX_CONCURRENT_SCRIPTS 1000
 
@@ -116,39 +117,17 @@ ChannelFromScriptURL(nsIPrincipal* princ
                        loadGroup,
                        nullptr, // aCallbacks
                        flags,
                        ios);
   } else {
     // We must have a loadGroup with a load context for the principal to
     // traverse the channel correctly.
     MOZ_ASSERT(loadGroup);
-#ifdef DEBUG
-    // Verify load context exists.
-    nsCOMPtr<nsIInterfaceRequestor> callbacks;
-    rv = loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
-    MOZ_ASSERT(NS_SUCCEEDED(rv));
-    nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(callbacks);
-
-    // Verify load context appId and browser flag match the principal
-    uint32_t contextAppId;
-    bool contextInBrowserElement;
-    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(loadContext->GetAppId(&contextAppId)));
-    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
-      loadContext->GetIsInBrowserElement(&contextInBrowserElement)));
-
-    uint32_t principalAppId;
-    bool principalInBrowserElement;
-    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(principal->GetAppId(&principalAppId)));
-    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
-      principal->GetIsInBrowserElement(&principalInBrowserElement)));
-
-    MOZ_ASSERT(contextAppId == principalAppId);
-    MOZ_ASSERT(contextInBrowserElement == principalInBrowserElement);
-#endif
+    MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(loadGroup, principal));
 
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        principal,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
                        nullptr, // aCallbacks
@@ -351,21 +330,23 @@ private:
   RunInternal()
   {
     AssertIsOnMainThread();
 
     WorkerPrivate* parentWorker = mWorkerPrivate->GetParent();
 
     // Figure out which principal to use.
     nsIPrincipal* principal = mWorkerPrivate->GetPrincipal();
+    nsCOMPtr<nsILoadGroup> loadGroup = mWorkerPrivate->GetLoadGroup();
     if (!principal) {
       NS_ASSERTION(parentWorker, "Must have a principal!");
       NS_ASSERTION(mIsWorkerScript, "Must have a principal for importScripts!");
 
       principal = parentWorker->GetPrincipal();
+      loadGroup = parentWorker->GetLoadGroup();
     }
     NS_ASSERTION(principal, "This should never be null here!");
 
     // Figure out our base URI.
     nsCOMPtr<nsIURI> baseURI;
     if (mIsWorkerScript) {
       if (parentWorker) {
         baseURI = parentWorker->GetBaseURI();
@@ -385,21 +366,16 @@ private:
     nsCOMPtr<nsIDocument> parentDoc = mWorkerPrivate->GetDocument();
 
     nsCOMPtr<nsIChannel> channel;
     if (mIsWorkerScript) {
       // May be null.
       channel = mWorkerPrivate->ForgetWorkerChannel();
     }
 
-    nsCOMPtr<nsILoadGroup> loadGroup = mWorkerPrivate->GetLoadGroup();
-    if (!loadGroup) {
-      loadGroup = parentWorker->GetLoadGroup();
-    }
-
     nsCOMPtr<nsIIOService> ios(do_GetIOService());
 
     nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
     NS_ASSERTION(secMan, "This should never be null!");
 
     for (uint32_t index = 0; index < mLoadInfos.Length(); index++) {
       ScriptLoadInfo& loadInfo = mLoadInfos[index];
       nsresult& rv = loadInfo.mLoadResult;
@@ -528,16 +504,21 @@ private:
 
       nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
       NS_ASSERTION(ssm, "Should never be null!");
 
       nsCOMPtr<nsIPrincipal> channelPrincipal;
       rv = ssm->GetChannelResultPrincipal(channel, getter_AddRefs(channelPrincipal));
       NS_ENSURE_SUCCESS(rv, rv);
 
+      nsCOMPtr<nsILoadGroup> channelLoadGroup;
+      rv = channel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
+      NS_ENSURE_SUCCESS(rv, rv);
+      MOZ_ASSERT(channelLoadGroup);
+
       // See if this is a resource URI. Since JSMs usually come from resource://
       // URIs we're currently considering all URIs with the URI_IS_UI_RESOURCE
       // flag as valid for creating privileged workers.
       if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
         bool isResource;
         rv = NS_URIChainHasFlags(finalURI,
                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
                                  &isResource);
@@ -566,17 +547,23 @@ private:
 
         // We exempt data urls and other URI's that inherit their
         // principal again.
         if (NS_FAILED(loadPrincipal->CheckMayLoad(finalURI, false, true))) {
           return NS_ERROR_DOM_BAD_URI;
         }
       }
 
-      mWorkerPrivate->SetPrincipal(channelPrincipal);
+      if (!NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal)) {
+        rv = NS_NewLoadGroup(getter_AddRefs(channelLoadGroup),
+                             channelPrincipal);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+
+      mWorkerPrivate->SetPrincipal(channelPrincipal, channelLoadGroup);
 
       if (parent) {
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
 
         // Set Eval and ContentSecurityPolicy
         mWorkerPrivate->SetCSP(parent->GetCSP());
         mWorkerPrivate->SetEvalAllowed(parent->IsEvalAllowed());
@@ -648,16 +635,17 @@ class ChannelGetterRunnable MOZ_FINAL : 
 public:
   ChannelGetterRunnable(WorkerPrivate* aParentWorker,
                         nsIEventTarget* aSyncLoopTarget,
                         const nsAString& aScriptURL,
                         nsIChannel** aChannel)
   : mParentWorker(aParentWorker), mSyncLoopTarget(aSyncLoopTarget),
     mScriptURL(aScriptURL), mChannel(aChannel), mResult(NS_ERROR_FAILURE)
   {
+    MOZ_ASSERT(mParentWorker);
     aParentWorker->AssertIsOnWorkerThread();
     MOZ_ASSERT(aSyncLoopTarget);
   }
 
   NS_IMETHOD
   Run() MOZ_OVERRIDE
   {
     AssertIsOnMainThread();
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -3581,29 +3581,32 @@ WorkerPrivateParent<Derived>::SetBaseURI
     mLocationInfo.mHost.Assign(mLocationInfo.mHostname);
   }
 
   nsContentUtils::GetUTFOrigin(aBaseURI, mLocationInfo.mOrigin);
 }
 
 template <class Derived>
 void
-WorkerPrivateParent<Derived>::SetPrincipal(nsIPrincipal* aPrincipal)
+WorkerPrivateParent<Derived>::SetPrincipal(nsIPrincipal* aPrincipal,
+                                           nsILoadGroup* aLoadGroup)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!mLoadInfo.mPrincipalInfo);
 
   mLoadInfo.mPrincipal = aPrincipal;
   mLoadInfo.mPrincipalIsSystem = nsContentUtils::IsSystemPrincipal(aPrincipal);
   uint16_t appStatus = aPrincipal->GetAppStatus();
   mLoadInfo.mIsInPrivilegedApp =
     (appStatus == nsIPrincipal::APP_STATUS_CERTIFIED ||
      appStatus == nsIPrincipal::APP_STATUS_PRIVILEGED);
   mLoadInfo.mIsInCertifiedApp = (appStatus == nsIPrincipal::APP_STATUS_CERTIFIED);
 
+  mLoadInfo.mLoadGroup = aLoadGroup;
+
   mLoadInfo.mPrincipalInfo = new PrincipalInfo();
 
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     PrincipalToPrincipalInfo(aPrincipal, mLoadInfo.mPrincipalInfo)));
 }
 
 template <class Derived>
 JSContext*
@@ -4344,23 +4347,25 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
                                         &loadInfo.mEvalAllowed);
       NS_ENSURE_SUCCESS(rv, rv);
     } else {
       loadInfo.mEvalAllowed = true;
       loadInfo.mReportCSPViolations = false;
     }
 
     if (!loadInfo.mLoadGroup) {
-      loadInfo.mLoadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID, &rv);
+      rv = NS_NewLoadGroup(getter_AddRefs(loadInfo.mLoadGroup),
+                           loadInfo.mPrincipal);
       NS_ENSURE_SUCCESS(rv, rv);
-
-      nsRefPtr<LoadContext> loadContext = new LoadContext(loadInfo.mPrincipal);
-      rv = loadInfo.mLoadGroup->SetNotificationCallbacks(loadContext);
-      NS_ENSURE_SUCCESS(rv, rv);
-    }
+    }
+
+    // We should either be creating the channel with a document or
+    // with a load group and matching principal.
+    MOZ_ASSERT(document || NS_LoadGroupMatchesPrincipal(loadInfo.mLoadGroup,
+                                                        loadInfo.mPrincipal));
 
     rv = ChannelFromScriptURLMainThread(loadInfo.mPrincipal, loadInfo.mBaseURI,
                                         document, loadInfo.mLoadGroup,
                                         aScriptURL,
                                         getter_AddRefs(loadInfo.mChannel));
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = NS_GetFinalChannelURI(loadInfo.mChannel,
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -573,17 +573,17 @@ public:
   // access occurs on the main thread.
   nsIPrincipal*
   GetPrincipalDontAssertMainThread() const
   {
       return mLoadInfo.mPrincipal;
   }
 
   void
-  SetPrincipal(nsIPrincipal* aPrincipal);
+  SetPrincipal(nsIPrincipal* aPrincipal, nsILoadGroup* aLoadGroup);
 
   bool
   UsesSystemPrincipal() const
   {
     return mLoadInfo.mPrincipalIsSystem;
   }
 
   bool
diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -902,16 +902,23 @@ NS_NewLoadGroup(nsILoadGroup      **resu
         if (NS_SUCCEEDED(rv)) {
             *result = nullptr;
             group.swap(*result);
         }
     }
     return rv;
 }
 
+nsresult
+NS_NewLoadGroup(nsILoadGroup **aResult, nsIPrincipal *aPrincipal);
+
+bool
+NS_LoadGroupMatchesPrincipal(nsILoadGroup* aLoadGroup,
+                             nsIPrincipal* aPrincipal);
+
 inline nsresult
 NS_NewDownloader(nsIStreamListener   **result,
                  nsIDownloadObserver  *observer,
                  nsIFile              *downloadLocation = nullptr)
 {
     nsresult rv;
     nsCOMPtr<nsIDownloader> downloader =
         do_CreateInstance(NS_DOWNLOADER_CONTRACTID, &rv);
diff --git a/netwerk/base/src/nsNetUtil.cpp b/netwerk/base/src/nsNetUtil.cpp
--- a/netwerk/base/src/nsNetUtil.cpp
+++ b/netwerk/base/src/nsNetUtil.cpp
@@ -1,18 +1,72 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* vim:set ts=4 sw=4 sts=4 et cin: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "mozilla/LoadContext.h"
 #include "nsNetUtil.h"
 #include "nsHttp.h"
 
 bool NS_IsReasonableHTTPHeaderValue(const nsACString& aValue)
 {
   return mozilla::net::nsHttp::IsReasonableHeaderValue(aValue);
 }
 
 bool NS_IsValidHTTPToken(const nsACString& aToken)
 {
   return mozilla::net::nsHttp::IsValidToken(aToken);
 }
+
+nsresult
+NS_NewLoadGroup(nsILoadGroup **aResult, nsIPrincipal *aPrincipal)
+{
+    using mozilla::LoadContext;
+
+    nsresult rv;
+    nsCOMPtr<nsILoadGroup> group =
+        do_CreateInstance(NS_LOADGROUP_CONTRACTID, &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsRefPtr<LoadContext> loadContext = new LoadContext(aPrincipal);
+    rv = group->SetNotificationCallbacks(loadContext);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    group.forget(aResult);
+    return rv;
+}
+
+bool
+NS_LoadGroupMatchesPrincipal(nsILoadGroup* aLoadGroup,
+                             nsIPrincipal* aPrincipal)
+{
+    if (!aLoadGroup || !aPrincipal) {
+        return false;
+    }
+
+    nsCOMPtr<nsIInterfaceRequestor> callbacks;
+    nsresult rv =
+        aLoadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
+    NS_ENSURE_SUCCESS(rv, false);
+
+    nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(callbacks);
+    NS_ENSURE_TRUE(loadContext, false);
+
+    // Verify load context appId and browser flag match the principal
+    uint32_t contextAppId;
+    bool contextInBrowserElement;
+    rv = loadContext->GetAppId(&contextAppId);
+    NS_ENSURE_SUCCESS(rv, false);
+    rv = loadContext->GetIsInBrowserElement(&contextInBrowserElement);
+    NS_ENSURE_SUCCESS(rv, false);
+
+    uint32_t principalAppId;
+    bool principalInBrowserElement;
+    rv = aPrincipal->GetAppId(&principalAppId);
+    NS_ENSURE_SUCCESS(rv, false);
+    rv = aPrincipal->GetIsInBrowserElement(&principalInBrowserElement);
+    NS_ENSURE_SUCCESS(rv, false);
+
+    return contextAppId == principalAppId &&
+           contextInBrowserElement == principalInBrowserElement;
+}
