# HG changeset patch
# Parent 6d3c647560aa6be50e74bf76c175c5023dc36a97
# User Ben Kelly <ben@wanderview.com>
Bug 1160227 Improve Cache API warnings. r=ehsan


diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -224,17 +224,17 @@ Cache::Cache(nsIGlobalObject* aGlobal, C
   MOZ_ASSERT(mActor);
   mActor->SetListener(this);
 }
 
 already_AddRefed<Promise>
 Cache::Match(const RequestOrUSVString& aRequest,
              const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
@@ -251,17 +251,17 @@ Cache::Match(const RequestOrUSVString& a
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::MatchAll(const Optional<RequestOrUSVString>& aRequest,
                 const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this, CacheMatchAllArgs(void_t(), params));
@@ -281,170 +281,171 @@ Cache::MatchAll(const Optional<RequestOr
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Add(JSContext* aContext, const RequestOrUSVString& aRequest,
            ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   if (!IsValidPutRequestMethod(aRequest, aRv)) {
     return nullptr;
   }
 
   GlobalObject global(aContext, mGlobal->GetGlobalJSObject());
   MOZ_ASSERT(!global.Failed());
 
   nsTArray<nsRefPtr<Request>> requestList(1);
   nsRefPtr<Request> request = Request::Constructor(global, aRequest,
                                                    RequestInit(), aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   nsAutoString url;
   request->GetUrl(url);
-  if (!IsValidPutRequestURL(url, aRv)) {
+  if (NS_WARN_IF(!IsValidPutRequestURL(url, aRv))) {
     return nullptr;
   }
 
   requestList.AppendElement(Move(request));
   return AddAll(global, Move(requestList), aRv);
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(JSContext* aContext,
               const Sequence<OwningRequestOrUSVString>& aRequestList,
               ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   GlobalObject global(aContext, mGlobal->GetGlobalJSObject());
   MOZ_ASSERT(!global.Failed());
 
   nsTArray<nsRefPtr<Request>> requestList(aRequestList.Length());
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     RequestOrUSVString requestOrString;
 
     if (aRequestList[i].IsRequest()) {
       requestOrString.SetAsRequest() = aRequestList[i].GetAsRequest();
-      if (!IsValidPutRequestMethod(requestOrString.GetAsRequest(), aRv)) {
+      if (NS_WARN_IF(!IsValidPutRequestMethod(requestOrString.GetAsRequest(),
+                     aRv))) {
         return nullptr;
       }
     } else {
       requestOrString.SetAsUSVString().Rebind(
         aRequestList[i].GetAsUSVString().Data(),
         aRequestList[i].GetAsUSVString().Length());
     }
 
     nsRefPtr<Request> request = Request::Constructor(global, requestOrString,
                                                      RequestInit(), aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
     nsAutoString url;
     request->GetUrl(url);
-    if (!IsValidPutRequestURL(url, aRv)) {
+    if (NS_WARN_IF(!IsValidPutRequestURL(url, aRv))) {
       return nullptr;
     }
 
     requestList.AppendElement(Move(request));
   }
 
   return AddAll(global, Move(requestList), aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Put(const RequestOrUSVString& aRequest, Response& aResponse,
            ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
-  if (!IsValidPutRequestMethod(aRequest, aRv)) {
+  if (NS_WARN_IF(!IsValidPutRequestMethod(aRequest, aRv))) {
     return nullptr;
   }
 
   nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest, ReadBody, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   AutoChildOpArgs args(this, CachePutAllArgs());
 
   args.Add(ir, ReadBody, TypeErrorOnInvalidScheme,
            aResponse, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Delete(const RequestOrUSVString& aRequest,
               const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this, CacheDeleteArgs(CacheRequest(), params));
 
   args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Keys(const Optional<RequestOrUSVString>& aRequest,
             const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this, CacheKeysArgs(void_t(), params));
 
   if (aRequest.WasPassed()) {
     nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest.Value(),
                                                      IgnoreBody, aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
     args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   }
 
   return ExecuteOp(args, aRv);
 }
 
 // static
@@ -524,34 +525,34 @@ Cache::~Cache()
     MOZ_ASSERT(!mActor);
   }
 }
 
 already_AddRefed<Promise>
 Cache::ExecuteOp(AutoChildOpArgs& aOpArgs, ErrorResult& aRv)
 {
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   mActor->ExecuteOp(mGlobal, promise, this, aOpArgs.SendAsOpArgs());
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(const GlobalObject& aGlobal,
               nsTArray<nsRefPtr<Request>>&& aRequestList, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
   // If there is no work to do, then resolve immediately
   if (aRequestList.IsEmpty()) {
     nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-    if (!promise) {
+    if (NS_WARN_IF(!promise)) {
       return nullptr;
     }
 
     promise->MaybeResolve(JS::UndefinedHandleValue);
     return promise.forget();
   }
 
   nsAutoTArray<nsRefPtr<Promise>, 256> fetchList;
@@ -561,58 +562,58 @@ Cache::AddAll(const GlobalObject& aGloba
   // abandon our previous fetch calls.  In theory we could cancel them in the
   // future once fetch supports it.
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     RequestOrUSVString requestOrString;
     requestOrString.SetAsRequest() = aRequestList[i];
     nsRefPtr<Promise> fetch = FetchRequest(mGlobal, requestOrString,
                                            RequestInit(), aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
     fetchList.AppendElement(Move(fetch));
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   nsRefPtr<FetchHandler> handler = new FetchHandler(mActor->GetFeature(), this,
                                                     Move(aRequestList), promise);
 
   nsRefPtr<Promise> fetchPromise = Promise::All(aGlobal, fetchList, aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
   fetchPromise->AppendNativeHandler(handler);
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::PutAll(const nsTArray<nsRefPtr<Request>>& aRequestList,
               const nsTArray<nsRefPtr<Response>>& aResponseList,
               ErrorResult& aRv)
 {
   MOZ_ASSERT(aRequestList.Length() == aResponseList.Length());
 
-  if (!mActor) {
+  if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   AutoChildOpArgs args(this, CachePutAllArgs());
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     nsRefPtr<InternalRequest> ir = aRequestList[i]->GetInternalRequest();
     args.Add(ir, ReadBody, TypeErrorOnInvalidScheme, *aResponseList[i], aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   }
 
   return ExecuteOp(args, aRv);
 }
 
 } // namespace cache
diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -92,17 +92,17 @@ CacheOpChild::ActorDestroy(ActorDestroyR
 }
 
 bool
 CacheOpChild::Recv__delete__(const ErrorResult& aRv,
                              const CacheOpResult& aResult)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpChild);
 
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     MOZ_ASSERT(aResult.type() == CacheOpResult::Tvoid_t);
     // TODO: Remove this const_cast (bug 1152078).
     // It is safe for now since this ErrorResult is handed off to us by IPDL
     // and is thrown into the trash afterwards.
     mPromise->MaybeReject(const_cast<ErrorResult&>(aRv));
     mPromise = nullptr;
     return true;
   }
diff --git a/dom/cache/CacheOpParent.cpp b/dom/cache/CacheOpParent.cpp
--- a/dom/cache/CacheOpParent.cpp
+++ b/dom/cache/CacheOpParent.cpp
@@ -159,17 +159,17 @@ CacheOpParent::OnOpComplete(ErrorResult&
                             StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
   MOZ_ASSERT(mIpcManager);
   MOZ_ASSERT(mManager);
 
   // Never send an op-specific result if we have an error.  Instead, send
   // void_t() to ensure that we don't leak actors on the child side.
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     unused << Send__delete__(this, aRv, void_t());
     aRv.SuppressException(); // We serialiazed it, as best we could.
     return;
   }
 
   // The result must contain the appropriate type at this point.  It may
   // or may not contain the additional result data yet.  For types that
   // do not need special processing, it should already be set.  If the
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -161,40 +161,40 @@ CacheStorage::CacheStorage(Namespace aNa
     ActorCreated(actor);
     return;
   }
 
   // Otherwise we must begin the PBackground initialization process and
   // wait for the async ActorCreated() callback.
   MOZ_ASSERT(NS_IsMainThread());
   bool ok = BackgroundChild::GetOrCreateForCurrentThread(this);
-  if (!ok) {
+  if (NS_WARN_IF(!ok)) {
     ActorFailed();
   }
 }
 
 already_AddRefed<Promise>
 CacheStorage::Match(const RequestOrUSVString& aRequest,
                     const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
-  if (mFailedActor) {
+  if (NS_WARN_IF(mFailedActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<InternalRequest> request = ToInternalRequest(aRequest, IgnoreBody,
                                                         aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
@@ -207,23 +207,23 @@ CacheStorage::Match(const RequestOrUSVSt
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Has(const nsAString& aKey, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
-  if (mFailedActor) {
+  if (NS_WARN_IF(mFailedActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
   entry->mArgs = StorageHasArgs(nsString(aKey));
 
   mPendingRequests.AppendElement(entry.forget());
@@ -232,23 +232,23 @@ CacheStorage::Has(const nsAString& aKey,
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Open(const nsAString& aKey, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
-  if (mFailedActor) {
+  if (NS_WARN_IF(mFailedActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
   entry->mArgs = StorageOpenArgs(nsString(aKey));
 
   mPendingRequests.AppendElement(entry.forget());
@@ -257,23 +257,23 @@ CacheStorage::Open(const nsAString& aKey
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Delete(const nsAString& aKey, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
-  if (mFailedActor) {
+  if (NS_WARN_IF(mFailedActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
   entry->mArgs = StorageDeleteArgs(nsString(aKey));
 
   mPendingRequests.AppendElement(entry.forget());
@@ -282,23 +282,23 @@ CacheStorage::Delete(const nsAString& aK
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Keys(ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
-  if (mFailedActor) {
+  if (NS_WARN_IF(mFailedActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
-  if (!promise) {
+  if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
   entry->mArgs = StorageKeysArgs();
 
   mPendingRequests.AppendElement(entry.forget());
@@ -429,17 +429,17 @@ CacheStorage::MaybeRunPendingRequests()
 
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     ErrorResult rv;
     nsAutoPtr<Entry> entry(mPendingRequests[i].forget());
     AutoChildOpArgs args(this, entry->mArgs);
     if (entry->mRequest) {
       args.Add(entry->mRequest, IgnoreBody, IgnoreInvalidScheme, rv);
     }
-    if (rv.Failed()) {
+    if (NS_WARN_IF(rv.Failed())) {
       entry->mPromise->MaybeReject(rv);
       continue;
     }
     mActor->ExecuteOp(mGlobal, entry->mPromise, this, args.SendAsOpArgs());
   }
   mPendingRequests.Clear();
 }
 
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -95,17 +95,17 @@ CacheStorageParent::RecvPCacheOpConstruc
   auto actor = static_cast<CacheOpParent*>(aActor);
 
   if (mVerifier) {
     MOZ_ASSERT(!mManagerId);
     actor->WaitForVerification(mVerifier);
     return true;
   }
 
-  if (NS_FAILED(mVerifiedStatus)) {
+  if (NS_WARN_IF(NS_FAILED(mVerifiedStatus))) {
     unused << CacheOpParent::Send__delete__(actor, ErrorResult(mVerifiedStatus),
                                             void_t());
     return true;
   }
 
   MOZ_ASSERT(mManagerId);
   actor->Execute(mManagerId);
   return true;
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1618,17 +1618,17 @@ Manager::RemoveStreamList(StreamList* aS
 void
 Manager::ExecuteCacheOp(Listener* aListener, CacheId aCacheId,
                         const CacheOpArgs& aOpArgs)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(aOpArgs.type() != CacheOpArgs::TCachePutAllArgs);
 
-  if (mState == Closing) {
+  if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
   nsRefPtr<Context> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   nsRefPtr<StreamList> streamList = new StreamList(this, context);
@@ -1662,17 +1662,17 @@ Manager::ExecuteCacheOp(Listener* aListe
 
 void
 Manager::ExecuteStorageOp(Listener* aListener, Namespace aNamespace,
                           const CacheOpArgs& aOpArgs)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
-  if (mState == Closing) {
+  if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
   nsRefPtr<Context> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   nsRefPtr<StreamList> streamList = new StreamList(this, context);
@@ -1711,17 +1711,17 @@ void
 Manager::ExecutePutAll(Listener* aListener, CacheId aCacheId,
                        const nsTArray<CacheRequestResponse>& aPutList,
                        const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                        const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
-  if (mState == Closing) {
+  if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), CachePutAllResult());
     return;
   }
 
   nsRefPtr<Context> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   ListenerId listenerId = SaveListener(aListener);
