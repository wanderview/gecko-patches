# HG changeset patch
# Parent 5ba2a473a568deb4c6c39bd0049ae005bf8425ba
# User Ben Kelly <ben@wanderview.com>

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -372,17 +372,17 @@ AutoChildOpArgs::Add(InternalRequest* aR
   switch(mOpArgs.type()) {
     case CacheOpArgs::TCachePutAllArgs:
     {
       CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
 
       // Throw an error if a request/response pair would mask another
       // request/response pair in the same PutAll operation.  This is
       // step 2.3.2.3 from the "Batch Cache Operations" spec algorithm.
-      if (MatchInPutList(aRequest, args.requestResponseList())) {
+      if (NS_WARN_IF(MatchInPutList(aRequest, args.requestResponseList()))) {
         aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
         return;
       }
 
       // The FileDescriptorSetChild asserts in its destructor that all fds have
       // been removed.  The copy constructor, however, simply duplicates the
       // fds without removing any.  This means each temporary and copy must be
       // explicitly cleaned up.
@@ -394,17 +394,17 @@ AutoChildOpArgs::Add(InternalRequest* aR
       pair.response().body() = void_t();
 
       mTypeUtils->ToCacheRequest(pair.request(), aRequest, aBodyAction,
                                  aSchemeAction, aRv);
       if (!aRv.Failed()) {
         mTypeUtils->ToCacheResponse(pair.response(), aResponse, aRv);
       }
 
-      if (aRv.Failed()) {
+      if (NS_WARN_IF(aRv.Failed())) {
         CleanupChild(pair.request().body(), Delete);
         args.requestResponseList().RemoveElementAt(
           args.requestResponseList().Length() - 1);
       }
 
       break;
     }
     default:
diff --git a/dom/cache/Feature.cpp b/dom/cache/Feature.cpp
--- a/dom/cache/Feature.cpp
+++ b/dom/cache/Feature.cpp
@@ -20,17 +20,18 @@ using mozilla::dom::workers::WorkerPriva
 // static
 already_AddRefed<Feature>
 Feature::Create(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
 
   nsRefPtr<Feature> feature = new Feature(aWorkerPrivate);
 
-  if (!aWorkerPrivate->AddFeature(aWorkerPrivate->GetJSContext(), feature)) {
+  if (NS_WARN_IF(!aWorkerPrivate->AddFeature(aWorkerPrivate->GetJSContext(),
+                 feature))) {
     return nullptr;
   }
 
   return feature.forget();
 }
 
 void
 Feature::AddActor(ActorChild* aActor)
@@ -40,17 +41,17 @@ Feature::AddActor(ActorChild* aActor)
   MOZ_ASSERT(!mActorList.Contains(aActor));
 
   mActorList.AppendElement(aActor);
 
   // Allow an actor to be added after we've entered the Notifying case.  We
   // can't stop the actor creation from racing with out destruction of the
   // other actors and we need to wait for this extra one to close as well.
   // Signal it should destroy itself right away.
-  if (mNotified) {
+  if (NS_WARN_IF(mNotified)) {
     aActor->StartDestroy();
   }
 }
 
 void
 Feature::RemoveActor(ActorChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(Feature);
@@ -72,16 +73,18 @@ bool
 Feature::Notify(JSContext* aCx, Status aStatus)
 {
   NS_ASSERT_OWNINGTHREAD(Feature);
 
   if (aStatus < Canceling || mNotified) {
     return true;
   }
 
+  NS_WARNING("Cache Feature notified Worker is shutting down.");
+
   mNotified = true;
 
   // Start the asynchronous destruction of our actors.  These will call back
   // into RemoveActor() once the actor is destroyed.
   for (uint32_t i = 0; i < mActorList.Length(); ++i) {
     mActorList[i]->StartDestroy();
   }
 
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -109,17 +109,17 @@ TypeUtils::ToInternalRequest(const Reque
                              BodyAction aBodyAction, ErrorResult& aRv)
 {
   if (aIn.IsRequest()) {
     Request& request = aIn.GetAsRequest();
 
     // Check and set bodyUsed flag immediately because its on Request
     // instead of InternalRequest.
     CheckAndSetBodyUsed(&request, aBodyAction, aRv);
-    if (aRv.Failed()) { return nullptr; }
+    if (NS_WARN_IF(aRv.Failed())) { return nullptr; }
 
     return request.GetInternalRequest();
   }
 
   return ToInternalRequest(aIn.GetAsUSVString(), aRv);
 }
 
 already_AddRefed<InternalRequest>
@@ -128,17 +128,17 @@ TypeUtils::ToInternalRequest(const Ownin
 {
 
   if (aIn.IsRequest()) {
     nsRefPtr<Request> request = aIn.GetAsRequest().get();
 
     // Check and set bodyUsed flag immediately because its on Request
     // instead of InternalRequest.
     CheckAndSetBodyUsed(request, aBodyAction, aRv);
-    if (aRv.Failed()) { return nullptr; }
+    if (NS_WARN_IF(aRv.Failed())) { return nullptr; }
 
     return request->GetInternalRequest();
   }
 
   return ToInternalRequest(aIn.GetAsUSVString(), aRv);
 }
 
 void
@@ -151,22 +151,22 @@ TypeUtils::ToCacheRequest(CacheRequest& 
   aIn->GetMethod(aOut.method());
 
   nsAutoCString url;
   aIn->GetURL(url);
   CopyUTF8toUTF16(url, aOut.url());
 
   bool schemeValid;
   ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
-  if (aRv.Failed()) {
+  if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   if (!schemeValid) {
-    if (aSchemeAction == TypeErrorOnInvalidScheme) {
+    if (NS_WARN_IF(aSchemeAction == TypeErrorOnInvalidScheme)) {
       NS_NAMED_LITERAL_STRING(label, "Request");
       aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
       return;
     }
   }
 
   aIn->GetReferrer(aOut.referrer());
 
@@ -204,38 +204,38 @@ TypeUtils::ToCacheResponseWithoutBody(Ca
   nsAutoCString url;
   aIn.GetUrl(url);
   CopyUTF8toUTF16(url, aOut.url());
 
   if (aOut.url() != EmptyString()) {
     // Pass all Response URL schemes through... The spec only requires we take
     // action on invalid schemes for Request objects.
     ProcessURL(aOut.url(), nullptr, nullptr, aRv);
-    if (aRv.Failed()) {
+    if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
   }
 
   aOut.status() = aIn.GetStatus();
   aOut.statusText() = aIn.GetStatusText();
   nsRefPtr<InternalHeaders> headers = aIn.UnfilteredHeaders();
   MOZ_ASSERT(headers);
-  if (HasVaryStar(headers)) {
+  if (NS_WARN_IF(HasVaryStar(headers))) {
     aRv.ThrowTypeError(MSG_RESPONSE_HAS_VARY_STAR);
     return;
   }
   ToHeadersEntryList(aOut.headers(), headers);
   aOut.headersGuard() = headers->Guard();
   aOut.securityInfo() = aIn.GetSecurityInfo();
 }
 
 void
 TypeUtils::ToCacheResponse(CacheResponse& aOut, Response& aIn, ErrorResult& aRv)
 {
-  if (aIn.BodyUsed()) {
+  if (NS_WARN_IF(aIn.BodyUsed())) {
     aRv.ThrowTypeError(MSG_FETCH_BODY_CONSUMED_ERROR);
     return;
   }
 
   nsRefPtr<InternalResponse> ir = aIn.GetInternalResponse();
   ToCacheResponseWithoutBody(aOut, *ir, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
@@ -446,17 +446,17 @@ TypeUtils::CheckAndSetBodyUsed(Request* 
                                ErrorResult& aRv)
 {
   MOZ_ASSERT(aRequest);
 
   if (aBodyAction == IgnoreBody) {
     return;
   }
 
-  if (aRequest->BodyUsed()) {
+  if (NS_WARN_IF(aRequest->BodyUsed())) {
     aRv.ThrowTypeError(MSG_FETCH_BODY_CONSUMED_ERROR);
     return;
   }
 
   nsCOMPtr<nsIInputStream> stream;
   aRequest->GetBody(getter_AddRefs(stream));
   if (stream) {
     aRequest->SetBodyUsed();
