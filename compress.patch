# HG changeset patch
# Parent 9d38d76a1f8674888a87a86c53bb60830bcd4e79
# User Ben Kelly <ben@wanderview.com>
Compress Cache body data.

diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -1,21 +1,23 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/FileUtils.h"
+
+#include "mozilla/unused.h"
 #include "mozilla/dom/quota/FileStreams.h"
-#include "mozilla/unused.h"
 #include "nsIFile.h"
 #include "nsIUUIDGenerator.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
+#include "nsSnappyCompressOutputStream.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::dom::quota::FileInputStream;
@@ -45,16 +47,20 @@ FileUtils::BodyCreateDir(nsIFile* aBaseD
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     bool isDir;
     rv = aBodyDir->IsDirectory(&isDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!isDir)) { return NS_ERROR_FILE_NOT_DIRECTORY; }
   }
 
+  nsAutoCString path;
+  aBodyDir->GetNativePath(path);
+  printf_stderr("### ### Body dir: %s\n", path.get());
+
   return rv;
 }
 
 // static
 nsresult
 FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
                            nsIFile** aCacheDirOut)
 {
@@ -177,36 +183,24 @@ FileUtils::BodyStartWriteStream(const ns
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIOutputStream> fileStream =
     FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
                              aBaseDomain, aOrigin, tmpFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
-  // By default we would prefer to just use ReadSegments to copy buffers.
-  nsAsyncCopyMode mode = NS_ASYNCCOPY_VIA_READSEGMENTS;
-
-  // But first we must check to see if the source stream provides ReadSegments.
-  // If it does not, use a buffered output stream to write to the file.  We don't
-  // wrap the input because because that can lead to it being closed on the wrong
-  // thread.
-  if (!NS_InputStreamIsBuffered(aSource)) {
-    nsCOMPtr<nsIOutputStream> buffered;
-    rv = NS_NewBufferedOutputStream(getter_AddRefs(buffered), fileStream, 4096);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    fileStream = buffered.forget();
-    mode = NS_ASYNCCOPY_VIA_WRITESEGMENTS;
-  }
+  nsRefPtr<nsSnappyCompressOutputStream> compressed =
+    new nsSnappyCompressOutputStream(fileStream);
 
   // Note, we cannot auto-close the source stream here because some of
   // our source streams must be closed on the PBackground worker thread.
-  rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(), mode,
-                    4096, // chunk size
+  rv = NS_AsyncCopy(aSource, compressed, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS,
+                    compressed->BlockSize(),
                     aCallback, aClosure,
                     false, true, // close streams
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -17,16 +17,17 @@
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/InputStreamParams.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsIAsyncInputStream.h"
+#include "nsSnappyUncompressInputStream.h"
 #include "nsTArray.h"
 
 namespace {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::dom::cache::CacheStreamControlChild;
 using mozilla::dom::cache::CacheStreamControlParent;
@@ -50,16 +51,21 @@ public:
     mControl->AddListener(this);
   }
 
   virtual ~ReadStreamChild()
   {
     NoteClosed();
   }
 
+  virtual void NoteAutoClosed() MOZ_OVERRIDE
+  {
+    NoteClosed();
+  }
+
   virtual void NoteClosed() MOZ_OVERRIDE
   {
     if (mClosed) {
       return;
     }
 
     mClosed = true;
     mControl->RemoveListener(this);
@@ -118,16 +124,22 @@ public:
     mControl->AddListener(this);
   }
 
   virtual ~ReadStreamParent()
   {
     NoteClosed();
   }
 
+  virtual void NoteAutoClosed() MOZ_OVERRIDE
+  {
+    // Do not auto-close on parent side since we need to close on a specific
+    // thread.
+  }
+
   virtual void NoteClosed() MOZ_OVERRIDE
   {
     if (mClosed) {
       return;
     }
 
     mClosed = true;
     mControl->RemoveListener(this);
@@ -316,81 +328,85 @@ bool
 ReadStream::MatchId(const nsID& aId)
 {
   return mId.Equals(aId);
 }
 
 ReadStream::ReadStream(const nsID& aId, nsIInputStream* aStream)
   : mId(aId)
   , mStream(aStream)
+  , mSnappyStream(new nsSnappyUncompressInputStream(aStream))
   , mClosed(false)
 {
   MOZ_ASSERT(mStream);
+
 }
 
 ReadStream::~ReadStream()
 {
 }
 
 NS_IMETHODIMP
 ReadStream::Close()
 {
   NoteClosed();
-  return mStream->Close();
+  return mSnappyStream->Close();
 }
 
 NS_IMETHODIMP
 ReadStream::Available(uint64_t* aNumAvailableOut)
 {
-  nsresult rv = mStream->Available(aNumAvailableOut);
+  nsresult rv = mSnappyStream->Available(aNumAvailableOut);
 
   if (NS_FAILED(rv)) {
-    NoteClosed();
+    NoteAutoClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
 {
   MOZ_ASSERT(aNumReadOut);
 
-  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+  nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
 
   // Don't auto-close when end of stream is hit.  We want to close
   // this stream on a particular thread in the parent case.
 
-  if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) {
-    NoteClosed();
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteAutoClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
                          uint32_t aCount, uint32_t* aNumReadOut)
 {
   MOZ_ASSERT(aNumReadOut);
 
-  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+  nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
+                                            aNumReadOut);
 
   // Don't auto-close when end of stream is hit.  We want to close
   // this stream on a particular thread in the parent case.
 
-  if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
-                       rv != NS_ERROR_NOT_IMPLEMENTED) {
-    NoteClosed();
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                       rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteAutoClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::IsNonBlocking(bool* aNonBlockingOut)
 {
-  return mStream->IsNonBlocking(aNonBlockingOut);
+  return mSnappyStream->IsNonBlocking(aNonBlockingOut);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -49,26 +49,28 @@ public:
   // CacheStreamControlListener methods
   virtual void CloseStream() MOZ_OVERRIDE;
   virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
 
 protected:
   ReadStream(const nsID& aId, nsIInputStream* aStream);
   virtual ~ReadStream();
 
+  virtual void NoteAutoClosed()=0;
   virtual void NoteClosed()=0;
   virtual void Forget()=0;
   virtual void SerializeControl(PCacheReadStream* aReadStreamOut)=0;
 
   virtual void
   SerializeFds(PCacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& fds)=0;
 
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
+  nsCOMPtr<nsIInputStream> mSnappyStream;
   bool mClosed;
 
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_IID);
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
 };
