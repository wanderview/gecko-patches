# HG changeset patch
# Parent a4fdbd7ff48a1ce6f538ba9387dd801a791cebb8
# User Ben Kelly <ben@wanderview.com>
Compress Cache body data.

diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/FileUtils.h"
 
 #include "mozilla/dom/quota/FileStreams.h"
+#include "mozilla/SnappyCompressOutputStream.h"
 #include "mozilla/unused.h"
 #include "nsIFile.h"
 #include "nsIUUIDGenerator.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
 
@@ -177,34 +178,22 @@ FileUtils::BodyStartWriteStream(const Qu
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIOutputStream> fileStream =
     FileOutputStream::Create(PERSISTENCE_TYPE_DEFAULT, aQuotaInfo.mGroup,
                              aQuotaInfo.mOrigin, tmpFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
-  // By default we would prefer to just use ReadSegments to copy buffers.
-  nsAsyncCopyMode mode = NS_ASYNCCOPY_VIA_READSEGMENTS;
+  nsRefPtr<SnappyCompressOutputStream> compressed =
+    new SnappyCompressOutputStream(fileStream);
 
-  // But first we must check to see if the source stream provides ReadSegments.
-  // If it does not, use a buffered output stream to write to the file.  We don't
-  // wrap the input because because that can lead to it being closed on the wrong
-  // thread.
-  if (!NS_InputStreamIsBuffered(aSource)) {
-    nsCOMPtr<nsIOutputStream> buffered;
-    rv = NS_NewBufferedOutputStream(getter_AddRefs(buffered), fileStream, 4096);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    fileStream = buffered.forget();
-    mode = NS_ASYNCCOPY_VIA_WRITESEGMENTS;
-  }
-
-  rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(), mode,
-                    4096, // chunk size
+  rv = NS_AsyncCopy(aSource, compressed, NS_GetCurrentThread(),
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS,
+                    compressed->BlockSize(),
                     aCallback, aClosure,
                     true, true, // close streams
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -16,16 +16,17 @@
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/InputStreamParams.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "mozilla/SnappyUncompressInputStream.h"
 #include "nsIAsyncInputStream.h"
 #include "nsTArray.h"
 
 namespace {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::dom::cache::CacheStreamControlChild;
@@ -358,16 +359,17 @@ bool
 ReadStream::MatchId(const nsID& aId)
 {
   return mId.Equals(aId);
 }
 
 ReadStream::ReadStream(const nsID& aId, nsIInputStream* aStream)
   : mId(aId)
   , mStream(aStream)
+  , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mThread(NS_GetCurrentThread())
   , mClosed(false)
 {
   MOZ_ASSERT(mStream);
 }
 
 ReadStream::~ReadStream()
 {
@@ -416,62 +418,64 @@ ReadStream::Close()
 {
   NoteClosed();
   return mStream->Close();
 }
 
 NS_IMETHODIMP
 ReadStream::Available(uint64_t* aNumAvailableOut)
 {
-  nsresult rv = mStream->Available(aNumAvailableOut);
+  nsresult rv = mSnappyStream->Available(aNumAvailableOut);
 
   if (NS_FAILED(rv)) {
     NoteClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
 {
   MOZ_ASSERT(aNumReadOut);
 
-  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+  nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
 
   // Don't auto-close when end of stream is hit.  We want to close
   // this stream on a particular thread in the parent case.
 
-  if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) {
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
     NoteClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
                          uint32_t aCount, uint32_t* aNumReadOut)
 {
   MOZ_ASSERT(aNumReadOut);
 
-  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+  nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
+                                            aNumReadOut);
 
   // Don't auto-close when end of stream is hit.  We want to close
   // this stream on a particular thread in the parent case.
 
-  if (NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
-                       rv != NS_ERROR_NOT_IMPLEMENTED) {
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
     NoteClosed();
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 ReadStream::IsNonBlocking(bool* aNonBlockingOut)
 {
-  return mStream->IsNonBlocking(aNonBlockingOut);
+  return mSnappyStream->IsNonBlocking(aNonBlockingOut);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -64,16 +64,17 @@ protected:
   virtual void SerializeControl(PCacheReadStream* aReadStreamOut)=0;
 
   virtual void
   SerializeFds(PCacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& fds)=0;
 
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
+  nsCOMPtr<nsIInputStream> mSnappyStream;
   nsCOMPtr<nsIThread> mThread;
   bool mClosed;
 
 public:
   class NoteClosedRunnable;
   class ForgetRunnable;
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_IID);
