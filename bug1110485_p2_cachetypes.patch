# HG changeset patch
# Parent 9eff5a545441bd0d27506dbb2c45e5033be03378
# User Ben Kelly <ben@wanderview.com>
Bug 1110485 P2 Remove 'P' prefix from non-protocol IPC types in Cache API. r=baku

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -17,31 +17,31 @@
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace {
 
 using mozilla::unused;
 using mozilla::dom::cache::CachePushStreamChild;
-using mozilla::dom::cache::PCacheReadStream;
-using mozilla::dom::cache::PCacheReadStreamOrVoid;
+using mozilla::dom::cache::CacheReadStream;
+using mozilla::dom::cache::CacheReadStreamOrVoid;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::FileDescriptorSetParent;
 using mozilla::ipc::OptionalFileDescriptorSet;
 
 enum CleanupAction
 {
   Forget,
   Delete
 };
 
 void
-CleanupChildFds(PCacheReadStream& aReadStream, CleanupAction aAction)
+CleanupChildFds(CacheReadStream& aReadStream, CleanupAction aAction)
 {
   if (aReadStream.fds().type() !=
       OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
     return;
   }
 
   nsAutoTArray<FileDescriptor, 4> fds;
 
@@ -55,17 +55,17 @@ CleanupChildFds(PCacheReadStream& aReadS
 
   // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
   // unconditionally forget them here.  The fds themselves are auto-closed in
   // ~FileDescriptor since they originated in this process.
   fdSetActor->ForgetFileDescriptors(fds);
 }
 
 void
-CleanupChildPushStream(PCacheReadStream& aReadStream, CleanupAction aAction)
+CleanupChildPushStream(CacheReadStream& aReadStream, CleanupAction aAction)
 {
   if (!aReadStream.pushStreamChild()) {
     return;
   }
 
   auto pushStream =
     static_cast<CachePushStreamChild*>(aReadStream.pushStreamChild());
 
@@ -74,34 +74,34 @@ CleanupChildPushStream(PCacheReadStream&
     return;
   }
 
   // If we send the stream, then we need to start it before forgetting about it.
   pushStream->Start();
 }
 
 void
-CleanupChild(PCacheReadStream& aReadStream, CleanupAction aAction)
+CleanupChild(CacheReadStream& aReadStream, CleanupAction aAction)
 {
   CleanupChildFds(aReadStream, aAction);
   CleanupChildPushStream(aReadStream, aAction);
 }
 
 void
-CleanupChild(PCacheReadStreamOrVoid& aReadStreamOrVoid, CleanupAction aAction)
+CleanupChild(CacheReadStreamOrVoid& aReadStreamOrVoid, CleanupAction aAction)
 {
-  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aReadStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
     return;
   }
 
-  CleanupChild(aReadStreamOrVoid.get_PCacheReadStream(), aAction);
+  CleanupChild(aReadStreamOrVoid.get_CacheReadStream(), aAction);
 }
 
 void
-CleanupParentFds(PCacheReadStream& aReadStream, CleanupAction aAction)
+CleanupParentFds(CacheReadStream& aReadStream, CleanupAction aAction)
 {
   if (aReadStream.fds().type() !=
       OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
     return;
   }
 
   nsAutoTArray<FileDescriptor, 4> fds;
 
@@ -115,23 +115,23 @@ CleanupParentFds(PCacheReadStream& aRead
 
   // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
   // unconditionally forget them here.  The fds themselves are auto-closed in
   // ~FileDescriptor since they originated in this process.
   fdSetActor->ForgetFileDescriptors(fds);
 }
 
 void
-CleanupParentFds(PCacheReadStreamOrVoid& aReadStreamOrVoid, CleanupAction aAction)
+CleanupParentFds(CacheReadStreamOrVoid& aReadStreamOrVoid, CleanupAction aAction)
 {
-  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aReadStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
     return;
   }
 
-  CleanupParentFds(aReadStreamOrVoid.get_PCacheReadStream(), aAction);
+  CleanupParentFds(aReadStreamOrVoid.get_CacheReadStream(), aAction);
 }
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
@@ -157,20 +157,20 @@ AutoChildOpArgs::~AutoChildOpArgs()
     {
       CacheMatchArgs& args = mOpArgs.get_CacheMatchArgs();
       CleanupChild(args.request().body(), action);
       break;
     }
     case CacheOpArgs::TCacheMatchAllArgs:
     {
       CacheMatchAllArgs& args = mOpArgs.get_CacheMatchAllArgs();
-      if (args.requestOrVoid().type() == PCacheRequestOrVoid::Tvoid_t) {
+      if (args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t) {
         break;
       }
-      CleanupChild(args.requestOrVoid().get_PCacheRequest().body(), action);
+      CleanupChild(args.requestOrVoid().get_CacheRequest().body(), action);
       break;
     }
     case CacheOpArgs::TCacheAddAllArgs:
     {
       CacheAddAllArgs& args = mOpArgs.get_CacheAddAllArgs();
       auto& list = args.requestList();
       for (uint32_t i = 0; i < list.Length(); ++i) {
         CleanupChild(list[i].body(), action);
@@ -191,20 +191,20 @@ AutoChildOpArgs::~AutoChildOpArgs()
     {
       CacheDeleteArgs& args = mOpArgs.get_CacheDeleteArgs();
       CleanupChild(args.request().body(), action);
       break;
     }
     case CacheOpArgs::TCacheKeysArgs:
     {
       CacheKeysArgs& args = mOpArgs.get_CacheKeysArgs();
-      if (args.requestOrVoid().type() == PCacheRequestOrVoid::Tvoid_t) {
+      if (args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t) {
         break;
       }
-      CleanupChild(args.requestOrVoid().get_PCacheRequest().body(), action);
+      CleanupChild(args.requestOrVoid().get_CacheRequest().body(), action);
       break;
     }
     case CacheOpArgs::TStorageMatchArgs:
     {
       StorageMatchArgs& args = mOpArgs.get_StorageMatchArgs();
       CleanupChild(args.request().body(), action);
       break;
     }
@@ -220,71 +220,71 @@ AutoChildOpArgs::Add(InternalRequest* aR
                      ErrorResult& aRv)
 {
   MOZ_ASSERT(!mSent);
 
   switch(mOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
     {
       CacheMatchArgs& args = mOpArgs.get_CacheMatchArgs();
-      mTypeUtils->ToPCacheRequest(args.request(), aRequest, aBodyAction,
+      mTypeUtils->ToCacheRequest(args.request(), aRequest, aBodyAction,
                                   aReferrerAction, aSchemeAction, aRv);
       break;
     }
     case CacheOpArgs::TCacheMatchAllArgs:
     {
       CacheMatchAllArgs& args = mOpArgs.get_CacheMatchAllArgs();
-      MOZ_ASSERT(args.requestOrVoid().type() == PCacheRequestOrVoid::Tvoid_t);
-      args.requestOrVoid() = PCacheRequest();
-      mTypeUtils->ToPCacheRequest(args.requestOrVoid().get_PCacheRequest(),
+      MOZ_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
+      args.requestOrVoid() = CacheRequest();
+      mTypeUtils->ToCacheRequest(args.requestOrVoid().get_CacheRequest(),
                                   aRequest, aBodyAction, aReferrerAction,
                                   aSchemeAction, aRv);
       break;
     }
     case CacheOpArgs::TCacheAddAllArgs:
     {
       CacheAddAllArgs& args = mOpArgs.get_CacheAddAllArgs();
 
       // The FileDescriptorSetChild asserts in its destructor that all fds have
       // been removed.  The copy constructor, however, simply duplicates the
       // fds without removing any.  This means each temporary and copy must be
       // explicitly cleaned up.
       //
       // Avoid a lot of this hassle by making sure we only create one here.  On
       // error we remove it.
-      PCacheRequest& request = *args.requestList().AppendElement();
+      CacheRequest& request = *args.requestList().AppendElement();
 
-      mTypeUtils->ToPCacheRequest(request, aRequest, aBodyAction,
+      mTypeUtils->ToCacheRequest(request, aRequest, aBodyAction,
                                   aReferrerAction, aSchemeAction, aRv);
       if (aRv.Failed()) {
         args.requestList().RemoveElementAt(args.requestList().Length() - 1);
       }
       break;
     }
     case CacheOpArgs::TCacheDeleteArgs:
     {
       CacheDeleteArgs& args = mOpArgs.get_CacheDeleteArgs();
-      mTypeUtils->ToPCacheRequest(args.request(), aRequest, aBodyAction,
+      mTypeUtils->ToCacheRequest(args.request(), aRequest, aBodyAction,
                                   aReferrerAction, aSchemeAction, aRv);
       break;
     }
     case CacheOpArgs::TCacheKeysArgs:
     {
       CacheKeysArgs& args = mOpArgs.get_CacheKeysArgs();
-      MOZ_ASSERT(args.requestOrVoid().type() == PCacheRequestOrVoid::Tvoid_t);
-      args.requestOrVoid() = PCacheRequest();
-      mTypeUtils->ToPCacheRequest(args.requestOrVoid().get_PCacheRequest(),
+      MOZ_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
+      args.requestOrVoid() = CacheRequest();
+      mTypeUtils->ToCacheRequest(args.requestOrVoid().get_CacheRequest(),
                                   aRequest, aBodyAction, aReferrerAction,
                                   aSchemeAction, aRv);
       break;
     }
     case CacheOpArgs::TStorageMatchArgs:
     {
       StorageMatchArgs& args = mOpArgs.get_StorageMatchArgs();
-      mTypeUtils->ToPCacheRequest(args.request(), aRequest, aBodyAction,
+      mTypeUtils->ToCacheRequest(args.request(), aRequest, aBodyAction,
                                   aReferrerAction, aSchemeAction, aRv);
       break;
     }
     default:
       MOZ_CRASH("Cache args type cannot send a Request!");
   }
 }
 
@@ -306,20 +306,20 @@ AutoChildOpArgs::Add(InternalRequest* aR
       // explicitly cleaned up.
       //
       // Avoid a lot of this hassle by making sure we only create one here.  On
       // error we remove it.
       CacheRequestResponse& pair = *args.requestResponseList().AppendElement();
       pair.request().body() = void_t();
       pair.response().body() = void_t();
 
-      mTypeUtils->ToPCacheRequest(pair.request(), aRequest, aBodyAction,
+      mTypeUtils->ToCacheRequest(pair.request(), aRequest, aBodyAction,
                                   aReferrerAction, aSchemeAction, aRv);
       if (!aRv.Failed()) {
-        mTypeUtils->ToPCacheResponse(pair.response(), aResponse, aRv);
+        mTypeUtils->ToCacheResponse(pair.response(), aResponse, aRv);
       }
 
       if (aRv.Failed()) {
         CleanupChild(pair.request().body(), Delete);
         args.requestResponseList().RemoveElementAt(
           args.requestResponseList().Length() - 1);
       }
 
@@ -353,20 +353,20 @@ AutoParentOpResult::AutoParentOpResult(m
 AutoParentOpResult::~AutoParentOpResult()
 {
   CleanupAction action = mSent ? Forget : Delete;
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheMatchResult:
     {
       CacheMatchResult& result = mOpResult.get_CacheMatchResult();
-      if (result.responseOrVoid().type() == PCacheResponseOrVoid::Tvoid_t) {
+      if (result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t) {
         break;
       }
-      CleanupParentFds(result.responseOrVoid().get_PCacheResponse().body(),
+      CleanupParentFds(result.responseOrVoid().get_CacheResponse().body(),
                        action);
       break;
     }
     case CacheOpResult::TCacheMatchAllResult:
     {
       CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
       for (uint32_t i = 0; i < result.responseList().Length(); ++i) {
         CleanupParentFds(result.responseList()[i].body(), action);
@@ -379,20 +379,20 @@ AutoParentOpResult::~AutoParentOpResult(
       for (uint32_t i = 0; i < result.requestList().Length(); ++i) {
         CleanupParentFds(result.requestList()[i].body(), action);
       }
       break;
     }
     case CacheOpResult::TStorageMatchResult:
     {
       StorageMatchResult& result = mOpResult.get_StorageMatchResult();
-      if (result.responseOrVoid().type() == PCacheResponseOrVoid::Tvoid_t) {
+      if (result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t) {
         break;
       }
-      CleanupParentFds(result.responseOrVoid().get_PCacheResponse().body(),
+      CleanupParentFds(result.responseOrVoid().get_CacheResponse().body(),
                        action);
       break;
     }
     case CacheOpResult::TStorageOpenResult:
     {
       StorageOpenResult& result = mOpResult.get_StorageOpenResult();
       if (action == Forget || result.actorParent() == nullptr) {
         break;
@@ -423,37 +423,37 @@ AutoParentOpResult::Add(const SavedRespo
                         StreamList* aStreamList)
 {
   MOZ_ASSERT(!mSent);
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheMatchResult:
     {
       CacheMatchResult& result = mOpResult.get_CacheMatchResult();
-      MOZ_ASSERT(result.responseOrVoid().type() == PCacheResponseOrVoid::Tvoid_t);
+      MOZ_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
       result.responseOrVoid() = aSavedResponse.mValue;
       SerializeResponseBody(aSavedResponse, aStreamList,
-                            &result.responseOrVoid().get_PCacheResponse());
+                            &result.responseOrVoid().get_CacheResponse());
       break;
     }
     case CacheOpResult::TCacheMatchAllResult:
     {
       CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
       result.responseList().AppendElement(aSavedResponse.mValue);
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseList().LastElement());
       break;
     }
     case CacheOpResult::TStorageMatchResult:
     {
       StorageMatchResult& result = mOpResult.get_StorageMatchResult();
-      MOZ_ASSERT(result.responseOrVoid().type() == PCacheResponseOrVoid::Tvoid_t);
+      MOZ_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
       result.responseOrVoid() = aSavedResponse.mValue;
       SerializeResponseBody(aSavedResponse, aStreamList,
-                            &result.responseOrVoid().get_PCacheResponse());
+                            &result.responseOrVoid().get_CacheResponse());
       break;
     }
     default:
       MOZ_CRASH("Cache result type cannot handle returning a Response!");
   }
 }
 
 void
@@ -462,26 +462,26 @@ AutoParentOpResult::Add(const SavedReque
 {
   MOZ_ASSERT(!mSent);
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheKeysResult:
     {
       CacheKeysResult& result = mOpResult.get_CacheKeysResult();
       result.requestList().AppendElement(aSavedRequest.mValue);
-      PCacheRequest& request = result.requestList().LastElement();
+      CacheRequest& request = result.requestList().LastElement();
 
       if (!aSavedRequest.mHasBodyId) {
         request.body() = void_t();
         break;
       }
 
-      request.body() = PCacheReadStream();
+      request.body() = CacheReadStream();
       SerializeReadStream(aSavedRequest.mBodyId, aStreamList,
-                          &request.body().get_PCacheReadStream());
+                          &request.body().get_CacheReadStream());
       break;
     }
     default:
       MOZ_CRASH("Cache result type cannot handle returning a Request!");
   }
 }
 
 const CacheOpResult&
@@ -490,33 +490,33 @@ AutoParentOpResult::SendAsOpResult()
   MOZ_ASSERT(!mSent);
   mSent = true;
   return mOpResult;
 }
 
 void
 AutoParentOpResult::SerializeResponseBody(const SavedResponse& aSavedResponse,
                                           StreamList* aStreamList,
-                                          PCacheResponse* aResponseOut)
+                                          CacheResponse* aResponseOut)
 {
   MOZ_ASSERT(aResponseOut);
 
   if (!aSavedResponse.mHasBodyId) {
     aResponseOut->body() = void_t();
     return;
   }
 
-  aResponseOut->body() = PCacheReadStream();
+  aResponseOut->body() = CacheReadStream();
   SerializeReadStream(aSavedResponse.mBodyId, aStreamList,
-                      &aResponseOut->body().get_PCacheReadStream());
+                      &aResponseOut->body().get_CacheReadStream());
 }
 
 void
 AutoParentOpResult::SerializeReadStream(const nsID& aId, StreamList* aStreamList,
-                                        PCacheReadStream* aReadStreamOut)
+                                        CacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(aStreamList);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(!mSent);
 
   nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
   MOZ_ASSERT(stream);
 
diff --git a/dom/cache/AutoUtils.h b/dom/cache/AutoUtils.h
--- a/dom/cache/AutoUtils.h
+++ b/dom/cache/AutoUtils.h
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_AutoUtils_h
 #define mozilla_dom_cache_AutoUtils_h
 
 #include "mozilla/Attributes.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "nsTArray.h"
 
 struct nsID;
 
 namespace mozilla {
 
@@ -79,20 +79,20 @@ public:
   void Add(const SavedResponse& aSavedResponse, StreamList* aStreamList);
   void Add(const SavedRequest& aSavedRequest, StreamList* aStreamList);
 
   const CacheOpResult& SendAsOpResult();
 
 private:
   void SerializeResponseBody(const SavedResponse& aSavedResponse,
                              StreamList* aStreamList,
-                             PCacheResponse* aResponseOut);
+                             CacheResponse* aResponseOut);
 
   void SerializeReadStream(const nsID& aId, StreamList* aStreamList,
-                           PCacheReadStream* aReadStreamOut);
+                           CacheReadStream* aReadStreamOut);
 
   mozilla::ipc::PBackgroundParent* mManager;
   CacheOpResult mOpResult;
   CacheStreamControlParent* mStreamControl;
   bool mSent;
 };
 
 } // namespace cache
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -101,37 +101,37 @@ Cache::Match(const RequestOrUSVString& a
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  PCacheQueryParams params;
-  ToPCacheQueryParams(params, aOptions);
+  CacheQueryParams params;
+  ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheMatchArgs(PCacheRequest(), params));
+  AutoChildOpArgs args(this, CacheMatchArgs(CacheRequest(), params));
 
   args.Add(ir, IgnoreBody, PassThroughReferrer, IgnoreInvalidScheme, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::MatchAll(const Optional<RequestOrUSVString>& aRequest,
                 const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
-  PCacheQueryParams params;
-  ToPCacheQueryParams(params, aOptions);
+  CacheQueryParams params;
+  ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this, CacheMatchAllArgs(void_t(), params));
 
   if (aRequest.WasPassed()) {
     nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest.Value(),
                                                      IgnoreBody, aRv);
     if (aRv.Failed()) {
       return nullptr;
@@ -241,37 +241,37 @@ Cache::Delete(const RequestOrUSVString& 
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  PCacheQueryParams params;
-  ToPCacheQueryParams(params, aOptions);
+  CacheQueryParams params;
+  ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheDeleteArgs(PCacheRequest(), params));
+  AutoChildOpArgs args(this, CacheDeleteArgs(CacheRequest(), params));
 
   args.Add(ir, IgnoreBody, PassThroughReferrer, IgnoreInvalidScheme, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Keys(const Optional<RequestOrUSVString>& aRequest,
             const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
-  PCacheQueryParams params;
-  ToPCacheQueryParams(params, aOptions);
+  CacheQueryParams params;
+  ToCacheQueryParams(params, aOptions);
 
   AutoChildOpArgs args(this, CacheKeysArgs(void_t(), params));
 
   if (aRequest.WasPassed()) {
     nsRefPtr<InternalRequest> ir = ToInternalRequest(aRequest.Value(),
                                                      IgnoreBody, aRv);
     if (aRv.Failed()) {
       return nullptr;
diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -153,46 +153,46 @@ CacheOpChild::AssertOwningThread() const
 
 CachePushStreamChild*
 CacheOpChild::CreatePushStream(nsIAsyncInputStream* aStream)
 {
   MOZ_CRASH("CacheOpChild should never create a push stream actor!");
 }
 
 void
-CacheOpChild::HandleResponse(const PCacheResponseOrVoid& aResponseOrVoid)
+CacheOpChild::HandleResponse(const CacheResponseOrVoid& aResponseOrVoid)
 {
   nsRefPtr<Response> response;
-  if (aResponseOrVoid.type() == PCacheResponseOrVoid::TPCacheResponse) {
+  if (aResponseOrVoid.type() == CacheResponseOrVoid::TCacheResponse) {
     response = ToResponse(aResponseOrVoid);
   }
 
   if (!response) {
     mPromise->MaybeResolve(JS::UndefinedHandleValue);
     return;
   }
 
   mPromise->MaybeResolve(response);
 }
 
 void
-CacheOpChild::HandleResponseList(const nsTArray<PCacheResponse>& aResponseList)
+CacheOpChild::HandleResponseList(const nsTArray<CacheResponse>& aResponseList)
 {
   nsAutoTArray<nsRefPtr<Response>, 256> responses;
   responses.SetCapacity(aResponseList.Length());
 
   for (uint32_t i = 0; i < aResponseList.Length(); ++i) {
     responses.AppendElement(ToResponse(aResponseList[i]));
   }
 
   mPromise->MaybeResolve(responses);
 }
 
 void
-CacheOpChild::HandleRequestList(const nsTArray<PCacheRequest>& aRequestList)
+CacheOpChild::HandleRequestList(const nsTArray<CacheRequest>& aRequestList)
 {
   nsAutoTArray<nsRefPtr<Request>, 256> requests;
   requests.SetCapacity(aRequestList.Length());
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     requests.AppendElement(ToRequest(aRequestList[i]));
   }
 
diff --git a/dom/cache/CacheOpChild.h b/dom/cache/CacheOpChild.h
--- a/dom/cache/CacheOpChild.h
+++ b/dom/cache/CacheOpChild.h
@@ -51,23 +51,23 @@ private:
   AssertOwningThread() const override;
 #endif
 
   virtual CachePushStreamChild*
   CreatePushStream(nsIAsyncInputStream* aStream) override;
 
   // Utility methods
   void
-  HandleResponse(const PCacheResponseOrVoid& aResponseOrVoid);
+  HandleResponse(const CacheResponseOrVoid& aResponseOrVoid);
 
   void
-  HandleResponseList(const nsTArray<PCacheResponse>& aResponseList);
+  HandleResponseList(const nsTArray<CacheResponse>& aResponseList);
 
   void
-  HandleRequestList(const nsTArray<PCacheRequest>& aRequestList);
+  HandleRequestList(const nsTArray<CacheRequest>& aRequestList);
 
   nsCOMPtr<nsIGlobalObject> mGlobal;
   nsCOMPtr<nsISupports> mParent;
   nsRefPtr<Promise> mPromise;
 
   NS_DECL_OWNINGTHREAD
 };
 
diff --git a/dom/cache/CacheOpParent.cpp b/dom/cache/CacheOpParent.cpp
--- a/dom/cache/CacheOpParent.cpp
+++ b/dom/cache/CacheOpParent.cpp
@@ -72,17 +72,17 @@ CacheOpParent::Execute(Manager* aManager
 
   mManager = aManager;
 
   // Handle add/addAll op with a FetchPut object
   if (mOpArgs.type() == CacheOpArgs::TCacheAddAllArgs) {
     MOZ_ASSERT(mCacheId != INVALID_CACHE_ID);
 
     const CacheAddAllArgs& args = mOpArgs.get_CacheAddAllArgs();
-    const nsTArray<PCacheRequest>& list = args.requestList();
+    const nsTArray<CacheRequest>& list = args.requestList();
 
     nsAutoTArray<nsCOMPtr<nsIInputStream>, 256> requestStreamList;
     for (uint32_t i = 0; i < list.Length(); ++i) {
       requestStreamList.AppendElement(DeserializeCacheStream(list[i].body()));
     }
 
     nsRefPtr<FetchPut> fetchPut;
     nsresult rv = FetchPut::Create(this, mManager, mCacheId, list,
@@ -230,24 +230,24 @@ CacheOpParent::OnFetchPut(FetchPut* aFet
 
   aFetchPut->ClearListener();
   MOZ_ALWAYS_TRUE(mFetchPutList.RemoveElement(aFetchPut));
 
   OnOpComplete(Move(aRv), CacheAddAllResult());
 }
 
 already_AddRefed<nsIInputStream>
-CacheOpParent::DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid)
+CacheOpParent::DeserializeCacheStream(const CacheReadStreamOrVoid& aStreamOrVoid)
 {
-  if (aStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
     return nullptr;
   }
 
   nsCOMPtr<nsIInputStream> stream;
-  const PCacheReadStream& readStream = aStreamOrVoid.get_PCacheReadStream();
+  const CacheReadStream& readStream = aStreamOrVoid.get_CacheReadStream();
 
   // Option 1: A push stream actor was sent for nsPipe data
   if (readStream.pushStreamParent()) {
     MOZ_ASSERT(!readStream.controlParent());
     CachePushStreamParent* pushStream =
       static_cast<CachePushStreamParent*>(readStream.pushStreamParent());
     stream = pushStream->TakeReader();
     MOZ_ASSERT(stream);
diff --git a/dom/cache/CacheOpParent.h b/dom/cache/CacheOpParent.h
--- a/dom/cache/CacheOpParent.h
+++ b/dom/cache/CacheOpParent.h
@@ -62,17 +62,17 @@ private:
                StreamList* aStreamList) override;
 
   // FetchPut::Listener methods
   virtual void
   OnFetchPut(FetchPut* aFetchPut, ErrorResult&& aRv) override;
 
   // utility methods
   already_AddRefed<nsIInputStream>
-  DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
+  DeserializeCacheStream(const CacheReadStreamOrVoid& aStreamOrVoid);
 
   mozilla::ipc::PBackgroundParent* mIpcManager;
   const CacheId mCacheId;
   const Namespace mNamespace;
   const CacheOpArgs mOpArgs;
   nsRefPtr<Manager> mManager;
   nsRefPtr<PrincipalVerifier> mVerifier;
   nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -189,22 +189,22 @@ CacheStorage::Match(const RequestOrUSVSt
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
-  PCacheQueryParams params;
-  ToPCacheQueryParams(params, aOptions);
+  CacheQueryParams params;
+  ToCacheQueryParams(params, aOptions);
 
   nsAutoPtr<Entry> entry(new Entry());
   entry->mPromise = promise;
-  entry->mArgs = StorageMatchArgs(PCacheRequest(), params);
+  entry->mArgs = StorageMatchArgs(CacheRequest(), params);
   entry->mRequest = request;
 
   mPendingRequests.AppendElement(entry.forget());
   MaybeRunPendingRequests();
 
   return promise.forget();
 }
 
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -32,20 +32,18 @@ namespace dom {
 class Promise;
 
 namespace workers {
   class WorkerPrivate;
 }
 
 namespace cache {
 
-class CacheChild;
 class CacheStorageChild;
 class Feature;
-class PCacheResponseOrVoid;
 
 class CacheStorage final : public nsIIPCBackgroundChildCreateCallback
                          , public nsWrapperCache
                          , public TypeUtils
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -4,17 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
@@ -64,25 +64,25 @@ CacheStreamControlChild::StartDestroy()
   mDestroyStarted = true;
 
   // Begin shutting down all streams.  This is the same as if the parent had
   // asked us to shutdown.  So simulate the CloseAll IPC message.
   RecvCloseAll();
 }
 
 void
-CacheStreamControlChild::SerializeControl(PCacheReadStream* aReadStreamOut)
+CacheStreamControlChild::SerializeControl(CacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   aReadStreamOut->controlParent() = nullptr;
   aReadStreamOut->controlChild() = this;
 }
 
 void
-CacheStreamControlChild::SerializeFds(PCacheReadStream* aReadStreamOut,
+CacheStreamControlChild::SerializeFds(CacheReadStream* aReadStreamOut,
                                       const nsTArray<FileDescriptor>& aFds)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   PFileDescriptorSetChild* fdSet = nullptr;
   if (!aFds.IsEmpty()) {
     fdSet = Manager()->SendPFileDescriptorSetConstructor(aFds[0]);
     for (uint32_t i = 1; i < aFds.Length(); ++i) {
       unused << fdSet->SendAddFileDescriptor(aFds[i]);
@@ -92,17 +92,17 @@ CacheStreamControlChild::SerializeFds(PC
   if (fdSet) {
     aReadStreamOut->fds() = fdSet;
   } else {
     aReadStreamOut->fds() = void_t();
   }
 }
 
 void
-CacheStreamControlChild::DeserializeFds(const PCacheReadStream& aReadStream,
+CacheStreamControlChild::DeserializeFds(const CacheReadStream& aReadStream,
                                         nsTArray<FileDescriptor>& aFdsOut)
 {
   if (aReadStream.fds().type() !=
       OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
     return;
   }
 
   auto fdSetActor = static_cast<FileDescriptorSetChild*>(
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -26,24 +26,24 @@ public:
   CacheStreamControlChild();
   ~CacheStreamControlChild();
 
   // ActorChild methods
   virtual void StartDestroy() override;
 
   // StreamControl methods
   virtual void
-  SerializeControl(PCacheReadStream* aReadStreamOut) override;
+  SerializeControl(CacheReadStream* aReadStreamOut) override;
 
   virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
+  SerializeFds(CacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& aFds) override;
 
   virtual void
-  DeserializeFds(const PCacheReadStream& aReadStream,
+  DeserializeFds(const CacheReadStream& aReadStream,
                  nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) override;
 
 private:
   virtual void
   NoteClosedAfterForget(const nsID& aId) override;
 
 #ifdef DEBUG
   virtual void
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
@@ -40,25 +40,25 @@ CacheStreamControlParent::CacheStreamCon
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(!mStreamList);
   MOZ_COUNT_DTOR(cache::CacheStreamControlParent);
 }
 
 void
-CacheStreamControlParent::SerializeControl(PCacheReadStream* aReadStreamOut)
+CacheStreamControlParent::SerializeControl(CacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   aReadStreamOut->controlChild() = nullptr;
   aReadStreamOut->controlParent() = this;
 }
 
 void
-CacheStreamControlParent::SerializeFds(PCacheReadStream* aReadStreamOut,
+CacheStreamControlParent::SerializeFds(CacheReadStream* aReadStreamOut,
                                        const nsTArray<FileDescriptor>& aFds)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   PFileDescriptorSetParent* fdSet = nullptr;
   if (!aFds.IsEmpty()) {
     fdSet = Manager()->SendPFileDescriptorSetConstructor(aFds[0]);
     for (uint32_t i = 1; i < aFds.Length(); ++i) {
       unused << fdSet->SendAddFileDescriptor(aFds[i]);
@@ -68,17 +68,17 @@ CacheStreamControlParent::SerializeFds(P
   if (fdSet) {
     aReadStreamOut->fds() = fdSet;
   } else {
     aReadStreamOut->fds() = void_t();
   }
 }
 
 void
-CacheStreamControlParent::DeserializeFds(const PCacheReadStream& aReadStream,
+CacheStreamControlParent::DeserializeFds(const CacheReadStream& aReadStream,
                                          nsTArray<FileDescriptor>& aFdsOut)
 {
   if (aReadStream.fds().type() !=
       OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
     return;
   }
 
   FileDescriptorSetParent* fdSetActor =
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -27,24 +27,24 @@ public:
 
   void SetStreamList(StreamList* aStreamList);
   void Close(const nsID& aId);
   void CloseAll();
   void Shutdown();
 
   // StreamControl methods
   virtual void
-  SerializeControl(PCacheReadStream* aReadStreamOut) override;
+  SerializeControl(CacheReadStream* aReadStreamOut) override;
 
   virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
+  SerializeFds(CacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& aFds) override;
 
   virtual void
-  DeserializeFds(const PCacheReadStream& aReadStream,
+  DeserializeFds(const CacheReadStream& aReadStream,
                  nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) override;
 
 private:
   virtual void
   NoteClosedAfterForget(const nsID& aId) override;
 
 #ifdef DEBUG
   virtual void
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/CacheTypes.ipdlh
rename from dom/cache/PCacheTypes.ipdlh
rename to dom/cache/CacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/CacheTypes.ipdlh
@@ -16,124 +16,124 @@ using RequestContext from "mozilla/dom/F
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-struct PCacheQueryParams
+struct CacheQueryParams
 {
   bool ignoreSearch;
   bool ignoreMethod;
   bool ignoreVary;
   bool cacheNameSet;
   nsString cacheName;
 };
 
-struct PCacheReadStream
+struct CacheReadStream
 {
   nsID id;
   OptionalInputStreamParams params;
   OptionalFileDescriptorSet fds;
   nullable PCacheStreamControl control;
   nullable PCachePushStream pushStream;
 };
 
-union PCacheReadStreamOrVoid
+union CacheReadStreamOrVoid
 {
   void_t;
-  PCacheReadStream;
+  CacheReadStream;
 };
 
-struct PCacheRequest
+struct CacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
-  PCacheReadStreamOrVoid body;
+  CacheReadStreamOrVoid body;
   uint32_t contentPolicyType;
   RequestContext context;
   RequestCache requestCache;
 };
 
-union PCacheRequestOrVoid
+union CacheRequestOrVoid
 {
   void_t;
-  PCacheRequest;
+  CacheRequest;
 };
 
-struct PCacheResponse
+struct CacheResponse
 {
   ResponseType type;
   nsString url;
   uint32_t status;
   nsCString statusText;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
-  PCacheReadStreamOrVoid body;
+  CacheReadStreamOrVoid body;
   nsCString securityInfo;
 };
 
-union PCacheResponseOrVoid
+union CacheResponseOrVoid
 {
   void_t;
-  PCacheResponse;
+  CacheResponse;
 };
 
 struct CacheRequestResponse
 {
-  PCacheRequest request;
-  PCacheResponse response;
+  CacheRequest request;
+  CacheResponse response;
 };
 
 struct CacheMatchArgs
 {
-  PCacheRequest request;
-  PCacheQueryParams params;
+  CacheRequest request;
+  CacheQueryParams params;
 };
 
 struct CacheMatchAllArgs
 {
-  PCacheRequestOrVoid requestOrVoid;
-  PCacheQueryParams params;
+  CacheRequestOrVoid requestOrVoid;
+  CacheQueryParams params;
 };
 
 struct CacheAddAllArgs
 {
-  PCacheRequest[] requestList;
+  CacheRequest[] requestList;
 };
 
 struct CachePutAllArgs
 {
   CacheRequestResponse[] requestResponseList;
 };
 
 struct CacheDeleteArgs
 {
-  PCacheRequest request;
-  PCacheQueryParams params;
+  CacheRequest request;
+  CacheQueryParams params;
 };
 
 struct CacheKeysArgs
 {
-  PCacheRequestOrVoid requestOrVoid;
-  PCacheQueryParams params;
+  CacheRequestOrVoid requestOrVoid;
+  CacheQueryParams params;
 };
 
 struct StorageMatchArgs
 {
-  PCacheRequest request;
-  PCacheQueryParams params;
+  CacheRequest request;
+  CacheQueryParams params;
 };
 
 struct StorageHasArgs
 {
   nsString key;
 };
 
 struct StorageOpenArgs
@@ -162,22 +162,22 @@ union CacheOpArgs
   StorageHasArgs;
   StorageOpenArgs;
   StorageDeleteArgs;
   StorageKeysArgs;
 };
 
 struct CacheMatchResult
 {
-  PCacheResponseOrVoid responseOrVoid;
+  CacheResponseOrVoid responseOrVoid;
 };
 
 struct CacheMatchAllResult
 {
-  PCacheResponse[] responseList;
+  CacheResponse[] responseList;
 };
 
 struct CacheAddAllResult
 {
 };
 
 struct CachePutAllResult
 {
@@ -185,22 +185,22 @@ struct CachePutAllResult
 
 struct CacheDeleteResult
 {
   bool success;
 };
 
 struct CacheKeysResult
 {
-  PCacheRequest[] requestList;
+  CacheRequest[] requestList;
 };
 
 struct StorageMatchResult
 {
-  PCacheResponseOrVoid responseOrVoid;
+  CacheResponseOrVoid responseOrVoid;
 };
 
 struct StorageHasResult
 {
   bool success;
 };
 
 struct StorageOpenResult
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBSchema.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/dom/InternalHeaders.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 #include "mozilla/dom/HeadersBinding.h"
@@ -412,18 +412,18 @@ DBSchema::IsCacheOrphaned(mozIStorageCon
   *aOrphanedOut = refCount == 0;
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
-                     const PCacheRequest& aRequest,
-                     const PCacheQueryParams& aParams,
+                     const CacheRequest& aRequest,
+                     const CacheQueryParams& aParams,
                      bool* aFoundResponseOut,
                      SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aFoundResponseOut);
   MOZ_ASSERT(aSavedResponseOut);
 
@@ -444,26 +444,26 @@ DBSchema::CacheMatch(mozIStorageConnecti
   *aFoundResponseOut = true;
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
-                        const PCacheRequestOrVoid& aRequestOrVoid,
-                        const PCacheQueryParams& aParams,
+                        const CacheRequestOrVoid& aRequestOrVoid,
+                        const CacheQueryParams& aParams,
                         nsTArray<SavedResponse>& aSavedResponsesOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   nsresult rv;
 
   nsAutoTArray<EntryId, 256> matches;
-  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+  if (aRequestOrVoid.type() == CacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
@@ -476,26 +476,26 @@ DBSchema::CacheMatchAll(mozIStorageConne
   }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
-                   const PCacheRequest& aRequest,
+                   const CacheRequest& aRequest,
                    const nsID* aRequestBodyId,
-                   const PCacheResponse& aResponse,
+                   const CacheResponse& aResponse,
                    const nsID* aResponseBodyId,
                    nsTArray<nsID>& aDeletedBodyIdListOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
-  PCacheQueryParams params(false, false, false, false,
+  CacheQueryParams params(false, false, false, false,
                            NS_LITERAL_STRING(""));
   nsAutoTArray<EntryId, 256> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, params, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -504,18 +504,18 @@ DBSchema::CachePut(mozIStorageConnection
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
-                      const PCacheRequest& aRequest,
-                      const PCacheQueryParams& aParams,
+                      const CacheRequest& aRequest,
+                      const CacheQueryParams& aParams,
                       nsTArray<nsID>& aDeletedBodyIdListOut, bool* aSuccessOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aSuccessOut);
 
   *aSuccessOut = false;
 
@@ -533,26 +533,26 @@ DBSchema::CacheDelete(mozIStorageConnect
   *aSuccessOut = true;
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
-                    const PCacheRequestOrVoid& aRequestOrVoid,
-                    const PCacheQueryParams& aParams,
+                    const CacheRequestOrVoid& aRequestOrVoid,
+                    const CacheQueryParams& aParams,
                     nsTArray<SavedRequest>& aSavedRequestsOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   nsresult rv;
 
   nsAutoTArray<EntryId, 256> matches;
-  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+  if (aRequestOrVoid.type() == CacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   // TODO: replace this with a bulk load using SQL IN clause (bug 1110458)
@@ -566,18 +566,18 @@ DBSchema::CacheKeys(mozIStorageConnectio
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::StorageMatch(mozIStorageConnection* aConn,
                        Namespace aNamespace,
-                       const PCacheRequest& aRequest,
-                       const PCacheQueryParams& aParams,
+                       const CacheRequest& aRequest,
+                       const CacheQueryParams& aParams,
                        bool* aFoundResponseOut,
                        SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aFoundResponseOut);
   MOZ_ASSERT(aSavedResponseOut);
 
@@ -788,18 +788,18 @@ DBSchema::QueryAll(mozIStorageConnection
   }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
-                     const PCacheRequest& aRequest,
-                     const PCacheQueryParams& aParams,
+                     const CacheRequest& aRequest,
+                     const CacheQueryParams& aParams,
                      nsTArray<EntryId>& aEntryIdListOut,
                      uint32_t aMaxResults)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aMaxResults > 0);
 
   if (!aParams.ignoreMethod() && !aRequest.method().LowerCaseEqualsLiteral("get")
@@ -866,17 +866,17 @@ DBSchema::QueryCache(mozIStorageConnecti
   }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::MatchByVaryHeader(mozIStorageConnection* aConn,
-                            const PCacheRequest& aRequest,
+                            const CacheRequest& aRequest,
                             EntryId entryId, bool* aSuccessOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   *aSuccessOut = false;
 
   nsCOMPtr<mozIStorageStatement> state;
@@ -1066,19 +1066,19 @@ DBSchema::DeleteEntries(mozIStorageConne
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
 DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
-                      const PCacheRequest& aRequest,
+                      const CacheRequest& aRequest,
                       const nsID* aRequestBodyId,
-                      const PCacheResponse& aResponse,
+                      const CacheResponse& aResponse,
                       const nsID* aResponseBodyId)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO entries ("
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -16,20 +16,20 @@
 class mozIStorageConnection;
 class mozIStorageStatement;
 struct nsID;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class PCacheQueryParams;
-class PCacheRequest;
-class PCacheRequestOrVoid;
-class PCacheResponse;
+class CacheQueryParams;
+class CacheRequest;
+class CacheRequestOrVoid;
+class CacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 // TODO: remove static class and use functions in cache namespace (bug 1110485)
 class DBSchema final
 {
 public:
   static nsresult CreateSchema(mozIStorageConnection* aConn);
@@ -41,44 +41,44 @@ public:
   static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
                               nsTArray<nsID>& aDeletedBodyIdListOut);
 
   // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code. (bug 1110446)
   static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
                                   CacheId aCacheId, bool* aOrphanedOut);
 
   static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
-                             const PCacheRequest& aRequest,
-                             const PCacheQueryParams& aParams,
+                             const CacheRequest& aRequest,
+                             const CacheQueryParams& aParams,
                              bool* aFoundResponseOut,
                              SavedResponse* aSavedResponseOut);
   static nsresult CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
-                                const PCacheRequestOrVoid& aRequestOrVoid,
-                                const PCacheQueryParams& aParams,
+                                const CacheRequestOrVoid& aRequestOrVoid,
+                                const CacheQueryParams& aParams,
                                 nsTArray<SavedResponse>& aSavedResponsesOut);
   static nsresult CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
-                           const PCacheRequest& aRequest,
+                           const CacheRequest& aRequest,
                            const nsID* aRequestBodyId,
-                           const PCacheResponse& aResponse,
+                           const CacheResponse& aResponse,
                            const nsID* aResponseBodyId,
                            nsTArray<nsID>& aDeletedBodyIdListOut);
   static nsresult CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
-                              const PCacheRequest& aRequest,
-                              const PCacheQueryParams& aParams,
+                              const CacheRequest& aRequest,
+                              const CacheQueryParams& aParams,
                               nsTArray<nsID>& aDeletedBodyIdListOut,
                               bool* aSuccessOut);
   static nsresult CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
-                            const PCacheRequestOrVoid& aRequestOrVoid,
-                            const PCacheQueryParams& aParams,
+                            const CacheRequestOrVoid& aRequestOrVoid,
+                            const CacheQueryParams& aParams,
                             nsTArray<SavedRequest>& aSavedRequestsOut);
 
   static nsresult StorageMatch(mozIStorageConnection* aConn,
                                Namespace aNamespace,
-                               const PCacheRequest& aRequest,
-                               const PCacheQueryParams& aParams,
+                               const CacheRequest& aRequest,
+                               const CacheQueryParams& aParams,
                                bool* aFoundResponseOut,
                                SavedResponse* aSavedResponseOut);
   static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
                                     Namespace aNamespace, const nsAString& aKey,
                                     bool* aFoundCacheOut, CacheId* aCacheIdOut);
   static nsresult StoragePutCache(mozIStorageConnection* aConn,
                                   Namespace aNamespace, const nsAString& aKey,
                                   CacheId aCacheId);
@@ -93,31 +93,31 @@ public:
   static const int32_t kMaxWipeSchemaVersion;
 
 private:
   typedef int32_t EntryId;
 
   static nsresult QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
                            nsTArray<EntryId>& aEntryIdListOut);
   static nsresult QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
-                             const PCacheRequest& aRequest,
-                             const PCacheQueryParams& aParams,
+                             const CacheRequest& aRequest,
+                             const CacheQueryParams& aParams,
                              nsTArray<EntryId>& aEntryIdListOut,
                              uint32_t aMaxResults = UINT32_MAX);
   static nsresult MatchByVaryHeader(mozIStorageConnection* aConn,
-                                    const PCacheRequest& aRequest,
+                                    const CacheRequest& aRequest,
                                     EntryId entryId, bool* aSuccessOut);
   static nsresult DeleteEntries(mozIStorageConnection* aConn,
                                 const nsTArray<EntryId>& aEntryIdList,
                                 nsTArray<nsID>& aDeletedBodyIdListOut,
                                 uint32_t aPos=0, int32_t aLen=-1);
   static nsresult InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
-                              const PCacheRequest& aRequest,
+                              const CacheRequest& aRequest,
                               const nsID* aRequestBodyId,
-                              const PCacheResponse& aResponse,
+                              const CacheResponse& aResponse,
                               const nsID* aResponseBodyId);
   static nsresult ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
                                SavedResponse* aSavedResponseOut);
   static nsresult ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
                               SavedRequest* aSavedRequestOut);
 
   static void AppendListParamsToQuery(nsACString& aQuery,
                                       const nsTArray<EntryId>& aEntryIdList,
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
--- a/dom/cache/FetchPut.cpp
+++ b/dom/cache/FetchPut.cpp
@@ -11,17 +11,16 @@
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ResponseBinding.h"
 #include "mozilla/dom/UnionTypes.h"
 #include "mozilla/dom/cache/ManagerId.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
 #include "nsContentUtils.h"
 #include "nsNetUtil.h"
 #include "nsThreadUtils.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 namespace mozilla {
 namespace dom {
@@ -94,17 +93,17 @@ protected:
 private:
   nsRefPtr<FetchPut> mFetchPut;
   nsRefPtr<InternalResponse> mInternalResponse;
 };
 
 // static
 nsresult
 FetchPut::Create(Listener* aListener, Manager* aManager, CacheId aCacheId,
-                 const nsTArray<PCacheRequest>& aRequests,
+                 const nsTArray<CacheRequest>& aRequests,
                  const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
                  FetchPut** aFetchPutOut)
 {
   MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
 
   // The FetchDriver requires that all requests have a referrer already set.
 #ifdef DEBUG
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
@@ -128,32 +127,32 @@ FetchPut::Create(Listener* aListener, Ma
 void
 FetchPut::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
 FetchPut::FetchPut(Listener* aListener, Manager* aManager, CacheId aCacheId,
-                   const nsTArray<PCacheRequest>& aRequests,
+                   const nsTArray<CacheRequest>& aRequests,
                    const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams)
   : mListener(aListener)
   , mManager(aManager)
   , mCacheId(aCacheId)
   , mInitiatingThread(NS_GetCurrentThread())
   , mStateList(aRequests.Length())
   , mPendingCount(0)
 {
   MOZ_ASSERT(mListener);
   MOZ_ASSERT(mManager);
   MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
 
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
     State* s = mStateList.AppendElement();
-    s->mPCacheRequest = aRequests[i];
+    s->mCacheRequest = aRequests[i];
     s->mRequestStream = aRequestStreams[i];
   }
 
   mManager->AddRefCacheId(mCacheId);
 }
 
 FetchPut::~FetchPut()
 {
@@ -210,17 +209,17 @@ FetchPut::DoFetchOnMainThread()
   if (NS_WARN_IF(NS_FAILED(rv))) {
     MaybeSetError(ErrorResult(rv));
     MaybeCompleteOnMainThread();
     return;
   }
 
   for (uint32_t i = 0; i < mStateList.Length(); ++i) {
     nsRefPtr<InternalRequest> internalRequest =
-      ToInternalRequest(mStateList[i].mPCacheRequest);
+      ToInternalRequest(mStateList[i].mCacheRequest);
 
     // If there is a stream we must clone it so that its still available
     // to store in the cache later;
     if (mStateList[i].mRequestStream) {
       internalRequest->SetBody(mStateList[i].mRequestStream);
       nsRefPtr<InternalRequest> clone = internalRequest->Clone();
 
       // The copy construction clone above can change the source stream,
@@ -256,20 +255,20 @@ FetchPut::FetchComplete(FetchObserver* a
 
   if (aInternalResponse->IsError() && !mResult.Failed()) {
     MaybeSetError(ErrorResult(NS_ERROR_FAILURE));
   }
 
   for (uint32_t i = 0; i < mStateList.Length(); ++i) {
     if (mStateList[i].mFetchObserver == aObserver) {
       ErrorResult rv;
-      ToPCacheResponseWithoutBody(mStateList[i].mPCacheResponse,
+      ToCacheResponseWithoutBody(mStateList[i].mCacheResponse,
                                   *aInternalResponse, rv);
       if (rv.Failed()) {
-        mResult = Move(rv);
+        MaybeSetError(Move(rv));
       } else {
         aInternalResponse->GetBody(getter_AddRefs(mStateList[i].mResponseStream));
       }
       mStateList[i].mFetchObserver = nullptr;
       MOZ_ASSERT(mPendingCount > 0);
       mPendingCount -= 1;
       MaybeCompleteOnMainThread();
       return;
@@ -308,37 +307,37 @@ FetchPut::DoPutOnWorkerThread()
 
   putList.SetCapacity(mStateList.Length());
   requestStreamList.SetCapacity(mStateList.Length());
   responseStreamList.SetCapacity(mStateList.Length());
 
   for (uint32_t i = 0; i < mStateList.Length(); ++i) {
     // The spec requires us to catch if content tries to insert a set of
     // requests that would overwrite each other.
-    if (MatchInPutList(mStateList[i].mPCacheRequest, putList)) {
+    if (MatchInPutList(mStateList[i].mCacheRequest, putList)) {
       MaybeSetError(ErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
       MaybeNotifyListener();
       return;
     }
 
     CacheRequestResponse* entry = putList.AppendElement();
-    entry->request() = mStateList[i].mPCacheRequest;
-    entry->response() = mStateList[i].mPCacheResponse;
+    entry->request() = mStateList[i].mCacheRequest;
+    entry->response() = mStateList[i].mCacheResponse;
     requestStreamList.AppendElement(mStateList[i].mRequestStream.forget());
     responseStreamList.AppendElement(mStateList[i].mResponseStream.forget());
   }
   mStateList.Clear();
 
   mManager->ExecutePutAll(this, mCacheId, putList, requestStreamList,
                           responseStreamList);
 }
 
 // static
 bool
-FetchPut::MatchInPutList(const PCacheRequest& aRequest,
+FetchPut::MatchInPutList(const CacheRequest& aRequest,
                          const nsTArray<CacheRequestResponse>& aPutList)
 {
   // This method implements the SW spec QueryCache algorithm against an
   // in memory array of Request/Response objects.  This essentially the
   // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
   // we cannot unify them because when operating against the real database
   // we don't want to load all request/response objects into memory.
 
@@ -346,18 +345,18 @@ FetchPut::MatchInPutList(const PCacheReq
       !aRequest.method().LowerCaseEqualsLiteral("head")) {
     return false;
   }
 
   nsRefPtr<InternalHeaders> requestHeaders =
     new InternalHeaders(aRequest.headers());
 
   for (uint32_t i = 0; i < aPutList.Length(); ++i) {
-    const PCacheRequest& cachedRequest = aPutList[i].request();
-    const PCacheResponse& cachedResponse = aPutList[i].response();
+    const CacheRequest& cachedRequest = aPutList[i].request();
+    const CacheResponse& cachedResponse = aPutList[i].response();
 
     // If the URLs don't match, then just skip to the next entry.
     if (aRequest.url() != cachedRequest.url()) {
       continue;
     }
 
     nsRefPtr<InternalHeaders> cachedRequestHeaders =
       new InternalHeaders(cachedRequest.headers());
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
--- a/dom/cache/FetchPut.h
+++ b/dom/cache/FetchPut.h
@@ -6,17 +6,17 @@
 
 #ifndef mozilla_dom_cache_FetchPut_h
 #define mozilla_dom_cache_FetchPut_h
 
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/cache/Manager.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "nsRefPtr.h"
 #include "nsTArray.h"
 #include <utility>
 
 class nsIInputStream;
 class nsIRunnable;
@@ -40,53 +40,53 @@ public:
   {
   public:
     virtual void
     OnFetchPut(FetchPut* aFetchPut, ErrorResult&& aRv) = 0;
   };
 
   static nsresult
   Create(Listener* aListener, Manager* aManager, CacheId aCacheId,
-         const nsTArray<PCacheRequest>& aRequests,
+         const nsTArray<CacheRequest>& aRequests,
          const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
          FetchPut** aFetchPutOut);
 
   void ClearListener();
 
 private:
   class Runnable;
   class FetchObserver;
   friend class FetchObserver;
   struct State
   {
-    PCacheRequest mPCacheRequest;
+    CacheRequest mCacheRequest;
     nsCOMPtr<nsIInputStream> mRequestStream;
     nsRefPtr<FetchObserver> mFetchObserver;
-    PCacheResponse mPCacheResponse;
+    CacheResponse mCacheResponse;
     nsCOMPtr<nsIInputStream> mResponseStream;
 
     nsRefPtr<Request> mRequest;
     nsRefPtr<Response> mResponse;
   };
 
   FetchPut(Listener* aListener, Manager* aManager, CacheId aCacheId,
-           const nsTArray<PCacheRequest>& aRequests,
+           const nsTArray<CacheRequest>& aRequests,
            const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams);
   ~FetchPut();
 
   nsresult DispatchToMainThread();
   void DispatchToInitiatingThread();
 
   void DoFetchOnMainThread();
   void FetchComplete(FetchObserver* aObserver,
                      InternalResponse* aInternalResponse);
   void MaybeCompleteOnMainThread();
 
   void DoPutOnWorkerThread();
-  static bool MatchInPutList(const PCacheRequest& aRequest,
+  static bool MatchInPutList(const CacheRequest& aRequest,
                              const nsTArray<CacheRequestResponse>& aPutList);
 
   virtual void
   OnOpComplete(ErrorResult&& aRv, const CacheOpResult& aResult,
                CacheId aOpenedCacheId,
                const nsTArray<SavedResponse>& aSavedResponseList,
                const nsTArray<SavedRequest>& aSavedRequestList,
                StreamList* aStreamList) override;
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -11,17 +11,17 @@
 #include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/ManagerId.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
@@ -821,22 +821,22 @@ private:
   virtual bool MatchesCacheId(CacheId aCacheId) const override
   {
     NS_ASSERT_OWNINGTHREAD(Action);
     return aCacheId == mCacheId;
   }
 
   struct Entry
   {
-    PCacheRequest mRequest;
+    CacheRequest mRequest;
     nsCOMPtr<nsIInputStream> mRequestStream;
     nsID mRequestBodyId;
     nsCOMPtr<nsISupports> mRequestCopyContext;
 
-    PCacheResponse mResponse;
+    CacheResponse mResponse;
     nsCOMPtr<nsIInputStream> mResponseStream;
     nsID mResponseBodyId;
     nsCOMPtr<nsISupports> mResponseCopyContext;
   };
 
   enum StreamId
   {
     RequestStream,
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -2,38 +2,35 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
-#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
+#include "nsRefPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheOpArgs;
 class CacheOpResult;
 class CacheRequestResponse;
 class Context;
 class ManagerId;
-class PCacheQueryParams;
-class PCacheRequest;
-class PCacheRequestOrVoid;
 struct SavedRequest;
 struct SavedResponse;
 class StreamList;
 
 // The Manager is class is responsible for performing all of the underlying
 // work for a Cache or CacheStorage operation.  The DOM objects and IPC actors
 // are basically just plumbing to get the request to the right Manager object
 // running in the parent process.
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,20 +1,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
+include protocol PBlob; // FIXME: bug 792908
 include protocol PCacheOp;
 include protocol PCachePushStream;
-include PCacheTypes;
+include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 
-include protocol PBlob; // FIXME: bug 792908
-include protocol PCacheStreamControl;
+include CacheTypes;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
 {
   manager PBackground;
diff --git a/dom/cache/PCacheOp.ipdl b/dom/cache/PCacheOp.ipdl
--- a/dom/cache/PCacheOp.ipdl
+++ b/dom/cache/PCacheOp.ipdl
@@ -1,21 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PCache;
+include protocol PCachePushStream;
 include protocol PCacheStorage;
-
-// these are needed indirectly through CacheOpResult
-include protocol PCachePushStream;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 
-include PCacheTypes;
+include CacheTypes;
 
 using mozilla::ErrorResult from "ipc/ErrorIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheOp
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,20 +1,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
+include protocol PBlob; // FIXME: bug 792908
 include protocol PCache;
 include protocol PCacheOp;
-include PCacheTypes;
+include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 
-include protocol PBlob; // FIXME: bug 792908
-include protocol PCacheStreamControl;
+include CacheTypes;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
 {
   manager PBackground;
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -4,17 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/ReadStream.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/ipc/FileDescriptor.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/SnappyUncompressInputStream.h"
 #include "nsIAsyncInputStream.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
@@ -30,20 +30,20 @@ using mozilla::ipc::FileDescriptor;
 // guaranteed by our outer ReadStream class.
 class ReadStream::Inner final : public ReadStream::Controllable
 {
 public:
   Inner(StreamControl* aControl, const nsID& aId,
         nsIInputStream* aStream);
 
   void
-  Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
+  Serialize(CacheReadStreamOrVoid* aReadStreamOut);
 
   void
-  Serialize(PCacheReadStream* aReadStreamOut);
+  Serialize(CacheReadStream* aReadStreamOut);
 
   // ReadStream::Controllable methods
   virtual void
   CloseStream() override;
 
   virtual void
   CloseStreamWithoutReporting() override;
 
@@ -188,27 +188,27 @@ ReadStream::Inner::Inner(StreamControl* 
   , mState(Open)
 {
   MOZ_ASSERT(mStream);
   MOZ_ASSERT(mControl);
   mControl->AddReadStream(this);
 }
 
 void
-ReadStream::Inner::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
+ReadStream::Inner::Serialize(CacheReadStreamOrVoid* aReadStreamOut)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
-  PCacheReadStream stream;
+  CacheReadStream stream;
   Serialize(&stream);
   *aReadStreamOut = stream;
 }
 
 void
-ReadStream::Inner::Serialize(PCacheReadStream* aReadStreamOut)
+ReadStream::Inner::Serialize(CacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(mState == Open);
   MOZ_ASSERT(mControl);
 
   // If we are sending a ReadStream, then we never want to set the
   // pushStream actors at the same time.
@@ -386,28 +386,28 @@ ReadStream::Inner::ForgetOnOwningThread(
 }
 
 // ----------------------------------------------------------------------------
 
 NS_IMPL_ISUPPORTS(cache::ReadStream, nsIInputStream, ReadStream);
 
 // static
 already_AddRefed<ReadStream>
-ReadStream::Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+ReadStream::Create(const CacheReadStreamOrVoid& aReadStreamOrVoid)
 {
-  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aReadStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
     return nullptr;
   }
 
-  return Create(aReadStreamOrVoid.get_PCacheReadStream());
+  return Create(aReadStreamOrVoid.get_CacheReadStream());
 }
 
 // static
 already_AddRefed<ReadStream>
-ReadStream::Create(const PCacheReadStream& aReadStream)
+ReadStream::Create(const CacheReadStream& aReadStream)
 {
   // The parameter may or may not be for a Cache created stream.  The way we
   // tell is by looking at the stream control actor.  If the actor exists,
   // then we know the Cache created it.
   if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
     return nullptr;
   }
 
@@ -452,23 +452,23 @@ ReadStream::Create(PCacheStreamControlPa
   MOZ_ASSERT(aControl);
   auto actor = static_cast<CacheStreamControlParent*>(aControl);
   nsRefPtr<Inner> inner = new Inner(actor, aId, aStream);
   nsRefPtr<ReadStream> ref = new ReadStream(inner);
   return ref.forget();
 }
 
 void
-ReadStream::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
+ReadStream::Serialize(CacheReadStreamOrVoid* aReadStreamOut)
 {
   mInner->Serialize(aReadStreamOut);
 }
 
 void
-ReadStream::Serialize(PCacheReadStream* aReadStreamOut)
+ReadStream::Serialize(CacheReadStream* aReadStreamOut)
 {
   mInner->Serialize(aReadStreamOut);
 }
 
 ReadStream::ReadStream(ReadStream::Inner* aInner)
   : mInner(aInner)
 {
   MOZ_ASSERT(mInner);
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -16,18 +16,18 @@
 #include "nsTArrayForwardDeclare.h"
 
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class PCacheReadStream;
-class PCacheReadStreamOrVoid;
+class CacheReadStream;
+class CacheReadStreamOrVoid;
 class PCacheStreamControlParent;
 
 // IID for the dom::cache::ReadStream interface
 #define NS_DOM_CACHE_READSTREAM_IID \
 {0x8e5da7c9, 0x0940, 0x4f1d, \
   {0x97, 0x25, 0x5c, 0x59, 0x38, 0xdd, 0xb9, 0x9f}}
 
 
@@ -66,27 +66,27 @@ public:
     NS_IMETHOD_(MozExternalRefCountType)
     AddRef(void) = 0;
 
     NS_IMETHOD_(MozExternalRefCountType)
     Release(void) = 0;
   };
 
   static already_AddRefed<ReadStream>
-  Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+  Create(const CacheReadStreamOrVoid& aReadStreamOrVoid);
 
   static already_AddRefed<ReadStream>
-  Create(const PCacheReadStream& aReadStream);
+  Create(const CacheReadStream& aReadStream);
 
   static already_AddRefed<ReadStream>
   Create(PCacheStreamControlParent* aControl, const nsID& aId,
          nsIInputStream* aStream);
 
-  void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
-  void Serialize(PCacheReadStream* aReadStreamOut);
+  void Serialize(CacheReadStreamOrVoid* aReadStreamOut);
+  void Serialize(CacheReadStream* aReadStreamOut);
 
 private:
   class Inner;
 
   explicit ReadStream(Inner* aInner);
   ~ReadStream();
 
   // Hold a strong ref to an inner class that actually implements the
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
--- a/dom/cache/SavedTypes.h
+++ b/dom/cache/SavedTypes.h
@@ -5,39 +5,39 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_SavedTypes_h
 #define mozilla_dom_cache_SavedTypes_h
 
 // NOTE: This cannot be rolled into Types.h because the IPC dependency.
 //       breaks webidl unified builds.
 
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsID.h"
 #include "nsIOutputStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct SavedRequest
 {
   SavedRequest() : mHasBodyId(false) { mValue.body() = void_t(); }
-  PCacheRequest mValue;
+  CacheRequest mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 struct SavedResponse
 {
   SavedResponse() : mHasBodyId(false) { mValue.body() = void_t(); }
-  PCacheResponse mValue;
+  CacheResponse mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/StreamControl.h b/dom/cache/StreamControl.h
--- a/dom/cache/StreamControl.h
+++ b/dom/cache/StreamControl.h
@@ -15,34 +15,34 @@ struct nsID;
 
 namespace mozilla {
 namespace ipc {
  class FileDescriptor;
 }
 namespace dom {
 namespace cache {
 
-class PCacheReadStream;
+class CacheReadStream;
 
 // Abstract class to help implement the stream control Child and Parent actors.
 // This provides an interface to partly help with serialization of IPC types,
 // but also an implementation for tracking ReadStream objects.
 class StreamControl
 {
 public:
   // abstract interface that must be implemented by child class
   virtual void
-  SerializeControl(PCacheReadStream* aReadStreamOut) = 0;
+  SerializeControl(CacheReadStream* aReadStreamOut) = 0;
 
   virtual void
-  SerializeFds(PCacheReadStream* aReadStreamOut,
+  SerializeFds(CacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& aFds) = 0;
 
   virtual void
-  DeserializeFds(const PCacheReadStream& aReadStream,
+  DeserializeFds(const CacheReadStream& aReadStream,
                  nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) = 0;
 
   // inherited implementation of the ReadStream::Controllable list
 
   // Begin controlling the given ReadStream.  This causes a strong ref to
   // be held by the control.  The ReadStream must call NoteClosed() or
   // ForgetReadStream() to release this ref.
   void
diff --git a/dom/cache/StreamUtils.cpp b/dom/cache/StreamUtils.cpp
--- a/dom/cache/StreamUtils.cpp
+++ b/dom/cache/StreamUtils.cpp
@@ -3,37 +3,37 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/StreamUtils.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/ipc/FileDescriptor.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 namespace {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::dom::cache::CacheStreamControlChild;
 using mozilla::dom::cache::Feature;
-using mozilla::dom::cache::PCacheReadStream;
+using mozilla::dom::cache::CacheReadStream;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::OptionalFileDescriptorSet;
 
 void
-StartDestroyStreamChild(const PCacheReadStream& aReadStream)
+StartDestroyStreamChild(const CacheReadStream& aReadStream)
 {
   CacheStreamControlChild* cacheControl =
     static_cast<CacheStreamControlChild*>(aReadStream.controlChild());
   if (cacheControl) {
     cacheControl->StartDestroy();
   }
 
   if (aReadStream.fds().type() ==
@@ -47,105 +47,105 @@ StartDestroyStreamChild(const PCacheRead
     fdSetActor->ForgetFileDescriptors(fds);
     MOZ_ASSERT(!fds.IsEmpty());
 
     unused << fdSetActor->Send__delete__(fdSetActor);
   }
 }
 
 void
-AddFeatureToStreamChild(const PCacheReadStream& aReadStream, Feature* aFeature)
+AddFeatureToStreamChild(const CacheReadStream& aReadStream, Feature* aFeature)
 {
   CacheStreamControlChild* cacheControl =
     static_cast<CacheStreamControlChild*>(aReadStream.controlChild());
   if (cacheControl) {
     cacheControl->SetFeature(aFeature);
   }
 }
 
 } // anonymous namespace
 
 void
-StartDestroyStreamChild(const PCacheResponseOrVoid& aResponseOrVoid)
+StartDestroyStreamChild(const CacheResponseOrVoid& aResponseOrVoid)
 {
-  if (aResponseOrVoid.type() == PCacheResponseOrVoid::Tvoid_t) {
+  if (aResponseOrVoid.type() == CacheResponseOrVoid::Tvoid_t) {
     return;
   }
 
-  StartDestroyStreamChild(aResponseOrVoid.get_PCacheResponse());
+  StartDestroyStreamChild(aResponseOrVoid.get_CacheResponse());
 }
 
 void
-StartDestroyStreamChild(const PCacheResponse& aResponse)
+StartDestroyStreamChild(const CacheResponse& aResponse)
 {
-  if (aResponse.body().type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aResponse.body().type() == CacheReadStreamOrVoid::Tvoid_t) {
     return;
   }
 
-  StartDestroyStreamChild(aResponse.body().get_PCacheReadStream());
+  StartDestroyStreamChild(aResponse.body().get_CacheReadStream());
 }
 
 void
-StartDestroyStreamChild(const nsTArray<PCacheResponse>& aResponses)
+StartDestroyStreamChild(const nsTArray<CacheResponse>& aResponses)
 {
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     StartDestroyStreamChild(aResponses[i]);
   }
 }
 
 void
-StartDestroyStreamChild(const nsTArray<PCacheRequest>& aRequests)
+StartDestroyStreamChild(const nsTArray<CacheRequest>& aRequests)
 {
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
-    if (aRequests[i].body().type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    if (aRequests[i].body().type() == CacheReadStreamOrVoid::Tvoid_t) {
       continue;
     }
-    StartDestroyStreamChild(aRequests[i].body().get_PCacheReadStream());
+    StartDestroyStreamChild(aRequests[i].body().get_CacheReadStream());
   }
 }
 
 void
-AddFeatureToStreamChild(const PCacheResponseOrVoid& aResponseOrVoid,
+AddFeatureToStreamChild(const CacheResponseOrVoid& aResponseOrVoid,
                         Feature* aFeature)
 {
-  if (aResponseOrVoid.type() == PCacheResponseOrVoid::Tvoid_t) {
+  if (aResponseOrVoid.type() == CacheResponseOrVoid::Tvoid_t) {
     return;
   }
 
-  AddFeatureToStreamChild(aResponseOrVoid.get_PCacheResponse(), aFeature);
+  AddFeatureToStreamChild(aResponseOrVoid.get_CacheResponse(), aFeature);
 }
 
 void
-AddFeatureToStreamChild(const PCacheResponse& aResponse,
+AddFeatureToStreamChild(const CacheResponse& aResponse,
                         Feature* aFeature)
 {
-  if (aResponse.body().type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aResponse.body().type() == CacheReadStreamOrVoid::Tvoid_t) {
     return;
   }
 
-  AddFeatureToStreamChild(aResponse.body().get_PCacheReadStream(), aFeature);
+  AddFeatureToStreamChild(aResponse.body().get_CacheReadStream(), aFeature);
 }
 
 void
-AddFeatureToStreamChild(const nsTArray<PCacheResponse>& aResponses,
+AddFeatureToStreamChild(const nsTArray<CacheResponse>& aResponses,
                          Feature* aFeature)
 {
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     AddFeatureToStreamChild(aResponses[i], aFeature);
   }
 }
 
 void
-AddFeatureToStreamChild(const nsTArray<PCacheRequest>& aRequests,
+AddFeatureToStreamChild(const nsTArray<CacheRequest>& aRequests,
                          Feature* aFeature)
 {
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
-    if (aRequests[i].body().type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    if (aRequests[i].body().type() == CacheReadStreamOrVoid::Tvoid_t) {
       continue;
     }
-    AddFeatureToStreamChild(aRequests[i].body().get_PCacheReadStream(),
+    AddFeatureToStreamChild(aRequests[i].body().get_CacheReadStream(),
                             aFeature);
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/StreamUtils.h b/dom/cache/StreamUtils.h
--- a/dom/cache/StreamUtils.h
+++ b/dom/cache/StreamUtils.h
@@ -9,31 +9,31 @@
 
 #include "nsTArrayForwardDeclare.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Feature;
-class PCacheRequest;
-class PCacheResponse;
-class PCacheResponseOrVoid;
+class CacheRequest;
+class CacheResponse;
+class CacheResponseOrVoid;
 
-void StartDestroyStreamChild(const PCacheResponseOrVoid& aResponseOrVoid);
-void StartDestroyStreamChild(const PCacheResponse& aResponse);
-void StartDestroyStreamChild(const nsTArray<PCacheResponse>& aResponses);
-void StartDestroyStreamChild(const nsTArray<PCacheRequest>& aRequests);
+void StartDestroyStreamChild(const CacheResponseOrVoid& aResponseOrVoid);
+void StartDestroyStreamChild(const CacheResponse& aResponse);
+void StartDestroyStreamChild(const nsTArray<CacheResponse>& aResponses);
+void StartDestroyStreamChild(const nsTArray<CacheRequest>& aRequests);
 
-void AddFeatureToStreamChild(const PCacheResponseOrVoid& aResponseOrVoid,
+void AddFeatureToStreamChild(const CacheResponseOrVoid& aResponseOrVoid,
                              Feature* aFeature);
-void AddFeatureToStreamChild(const PCacheResponse& aResponse,
+void AddFeatureToStreamChild(const CacheResponse& aResponse,
                              Feature* aFeature);
-void AddFeatureToStreamChild(const nsTArray<PCacheResponse>& aResponses,
+void AddFeatureToStreamChild(const nsTArray<CacheResponse>& aResponses,
                               Feature* aFeature);
-void AddFeatureToStreamChild(const nsTArray<PCacheRequest>& aRequests,
+void AddFeatureToStreamChild(const nsTArray<CacheRequest>& aRequests,
                               Feature* aFeature);
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_StreamUtils_h
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -7,17 +7,17 @@
 #include "mozilla/dom/cache/TypeUtils.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/CachePushStreamChild.h"
-#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsIAsyncInputStream.h"
@@ -29,17 +29,17 @@
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 namespace {
 
 using mozilla::ErrorResult;
 using mozilla::unused;
 using mozilla::void_t;
-using mozilla::dom::cache::PCacheReadStream;
+using mozilla::dom::cache::CacheReadStream;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
@@ -125,17 +125,17 @@ HasVaryStar(mozilla::dom::InternalHeader
         return true;
       }
     }
   }
   return false;
 }
 
 void
-SerializeNormalStream(nsIInputStream* aStream, PCacheReadStream& aReadStreamOut)
+SerializeNormalStream(nsIInputStream* aStream, CacheReadStream& aReadStreamOut)
 {
   nsAutoTArray<FileDescriptor, 4> fds;
   SerializeInputStream(aStream, aReadStreamOut.params(), fds);
 
   PFileDescriptorSetChild* fdSet = nullptr;
   if (!fds.IsEmpty()) {
     // We should not be serializing until we have an actor ready
     PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
@@ -201,20 +201,20 @@ TypeUtils::ToInternalRequest(const Ownin
 
     return request->GetInternalRequest();
   }
 
   return ToInternalRequest(aIn.GetAsUSVString(), aRv);
 }
 
 void
-TypeUtils::ToPCacheRequest(PCacheRequest& aOut, InternalRequest* aIn,
-                           BodyAction aBodyAction,
-                           ReferrerAction aReferrerAction,
-                           SchemeAction aSchemeAction, ErrorResult& aRv)
+TypeUtils::ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
+                          BodyAction aBodyAction,
+                          ReferrerAction aReferrerAction,
+                          SchemeAction aSchemeAction, ErrorResult& aRv)
 {
   MOZ_ASSERT(aIn);
 
   aIn->GetMethod(aOut.method());
 
   nsAutoCString url;
   aIn->GetURL(url);
   CopyUTF8toUTF16(url, aOut.url());
@@ -264,18 +264,18 @@ TypeUtils::ToPCacheRequest(PCacheRequest
   aIn->GetBody(getter_AddRefs(stream));
   SerializeCacheStream(stream, &aOut.body(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 }
 
 void
-TypeUtils::ToPCacheResponseWithoutBody(PCacheResponse& aOut,
-                                       InternalResponse& aIn, ErrorResult& aRv)
+TypeUtils::ToCacheResponseWithoutBody(CacheResponse& aOut,
+                                      InternalResponse& aIn, ErrorResult& aRv)
 {
   aOut.type() = aIn.Type();
 
   nsAutoCString url;
   aIn.GetUrl(url);
   CopyUTF8toUTF16(url, aOut.url());
 
   if (aOut.url() != EmptyString()) {
@@ -296,25 +296,25 @@ TypeUtils::ToPCacheResponseWithoutBody(P
     return;
   }
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
   aOut.securityInfo() = aIn.GetSecurityInfo();
 }
 
 void
-TypeUtils::ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv)
+TypeUtils::ToCacheResponse(CacheResponse& aOut, Response& aIn, ErrorResult& aRv)
 {
   if (aIn.BodyUsed()) {
     aRv.ThrowTypeError(MSG_FETCH_BODY_CONSUMED_ERROR);
     return;
   }
 
   nsRefPtr<InternalResponse> ir = aIn.GetInternalResponse();
-  ToPCacheResponseWithoutBody(aOut, *ir, aRv);
+  ToCacheResponseWithoutBody(aOut, *ir, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   nsCOMPtr<nsIInputStream> stream;
   aIn.GetBody(getter_AddRefs(stream));
   if (stream) {
     aIn.SetBodyUsed();
@@ -323,32 +323,32 @@ TypeUtils::ToPCacheResponse(PCacheRespon
   SerializeCacheStream(stream, &aOut.body(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 }
 
 // static
 void
-TypeUtils::ToPCacheQueryParams(PCacheQueryParams& aOut,
-                               const CacheQueryOptions& aIn)
+TypeUtils::ToCacheQueryParams(CacheQueryParams& aOut,
+                              const CacheQueryOptions& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch;
   aOut.ignoreMethod() = aIn.mIgnoreMethod;
   aOut.ignoreVary() = aIn.mIgnoreVary;
   aOut.cacheNameSet() = aIn.mCacheName.WasPassed();
   if (aOut.cacheNameSet()) {
     aOut.cacheName() = aIn.mCacheName.Value();
   } else {
     aOut.cacheName() = NS_LITERAL_STRING("");
   }
 }
 
 already_AddRefed<Response>
-TypeUtils::ToResponse(const PCacheResponse& aIn)
+TypeUtils::ToResponse(const CacheResponse& aIn)
 {
   if (aIn.type() == ResponseType::Error) {
     nsRefPtr<InternalResponse> error = InternalResponse::NetworkError();
     nsRefPtr<Response> r = new Response(GetGlobalObject(), error);
     return r.forget();
   }
 
   nsRefPtr<InternalResponse> ir = new InternalResponse(aIn.status(),
@@ -386,17 +386,17 @@ TypeUtils::ToResponse(const PCacheRespon
   }
   MOZ_ASSERT(ir);
 
   nsRefPtr<Response> ref = new Response(GetGlobalObject(), ir);
   return ref.forget();
 }
 
 already_AddRefed<InternalRequest>
-TypeUtils::ToInternalRequest(const PCacheRequest& aIn)
+TypeUtils::ToInternalRequest(const CacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(aIn.referrer());
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
@@ -418,17 +418,17 @@ TypeUtils::ToInternalRequest(const PCach
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
 
   internalRequest->SetBody(stream);
 
   return internalRequest.forget();
 }
 
 already_AddRefed<Request>
-TypeUtils::ToRequest(const PCacheRequest& aIn)
+TypeUtils::ToRequest(const CacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = ToInternalRequest(aIn);
   nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
   return request.forget();
 }
 
 void
 TypeUtils::CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
@@ -472,32 +472,32 @@ TypeUtils::ToInternalRequest(const nsASt
                                                    RequestInit(), aRv);
   if (NS_WARN_IF(aRv.Failed())) { return nullptr; }
 
   return request->GetInternalRequest();
 }
 
 void
 TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
-                                PCacheReadStreamOrVoid* aStreamOut,
+                                CacheReadStreamOrVoid* aStreamOut,
                                 ErrorResult& aRv)
 {
   *aStreamOut = void_t();
   if (!aStream) {
     return;
   }
 
   // Option 1: Send a cache-specific ReadStream if we can.
   nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
   if (controlled) {
     controlled->Serialize(aStreamOut);
     return;
   }
 
-  PCacheReadStream readStream;
+  CacheReadStream readStream;
   readStream.controlChild() = nullptr;
   readStream.controlParent() = nullptr;
   readStream.pushStreamChild() = nullptr;
   readStream.pushStreamParent() = nullptr;
 
   // Option 2: Do normal stream serialization if its supported.
   nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
   if (serial) {
@@ -511,17 +511,17 @@ TypeUtils::SerializeCacheStream(nsIInput
     if (NS_WARN_IF(aRv.Failed())) { return; }
   }
 
   *aStreamOut = readStream;
 }
 
 void
 TypeUtils::SerializePushStream(nsIInputStream* aStream,
-                               PCacheReadStream& aReadStreamOut,
+                               CacheReadStream& aReadStreamOut,
                                ErrorResult& aRv)
 {
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(aStream);
   if (NS_WARN_IF(!asyncStream)) {
     aRv = NS_ERROR_FAILURE;
     return;
   }
 
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -24,21 +24,21 @@ class InternalResponse;
 class OwningRequestOrUSVString;
 class Request;
 class RequestOrUSVString;
 class Response;
 
 namespace cache {
 
 class CachePushStreamChild;
-class PCacheQueryParams;
-class PCacheReadStream;
-class PCacheReadStreamOrVoid;
-class PCacheRequest;
-class PCacheResponse;
+class CacheQueryParams;
+class CacheReadStream;
+class CacheReadStreamOrVoid;
+class CacheRequest;
+class CacheResponse;
 
 class TypeUtils
 {
 public:
   enum BodyAction
   {
     IgnoreBody,
     ReadBody
@@ -72,53 +72,53 @@ public:
   ToInternalRequest(const RequestOrUSVString& aIn, BodyAction aBodyAction,
                     ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const OwningRequestOrUSVString& aIn, BodyAction aBodyAction,
                     ErrorResult& aRv);
 
   void
-  ToPCacheRequest(PCacheRequest& aOut, InternalRequest* aIn,
-                  BodyAction aBodyAction, ReferrerAction aReferrerAction,
-                  SchemeAction aSchemeAction, ErrorResult& aRv);
+  ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
+                 BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                 SchemeAction aSchemeAction, ErrorResult& aRv);
 
   void
-  ToPCacheResponseWithoutBody(PCacheResponse& aOut, InternalResponse& aIn,
-                              ErrorResult& aRv);
+  ToCacheResponseWithoutBody(CacheResponse& aOut, InternalResponse& aIn,
+                             ErrorResult& aRv);
 
   void
-  ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
+  ToCacheResponse(CacheResponse& aOut, Response& aIn, ErrorResult& aRv);
 
   void
-  ToPCacheQueryParams(PCacheQueryParams& aOut, const CacheQueryOptions& aIn);
+  ToCacheQueryParams(CacheQueryParams& aOut, const CacheQueryOptions& aIn);
 
   already_AddRefed<Response>
-  ToResponse(const PCacheResponse& aIn);
+  ToResponse(const CacheResponse& aIn);
 
   already_AddRefed<InternalRequest>
-  ToInternalRequest(const PCacheRequest& aIn);
+  ToInternalRequest(const CacheRequest& aIn);
 
   already_AddRefed<Request>
-  ToRequest(const PCacheRequest& aIn);
+  ToRequest(const CacheRequest& aIn);
 
 private:
   void
   CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                       ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const nsAString& aIn, ErrorResult& aRv);
 
   void
-  SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut,
+  SerializeCacheStream(nsIInputStream* aStream, CacheReadStreamOrVoid* aStreamOut,
                        ErrorResult& aRv);
 
   void
-  SerializePushStream(nsIInputStream* aStream, PCacheReadStream& aReadStreamOut,
+  SerializePushStream(nsIInputStream* aStream, CacheReadStream& aReadStreamOut,
                       ErrorResult& aRv);
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_TypesUtils_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -72,22 +72,22 @@ UNIFIED_SOURCES += [
     'ReadStream.cpp',
     'StreamControl.cpp',
     'StreamList.cpp',
     'StreamUtils.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
+    'CacheTypes.ipdlh',
     'PCache.ipdl',
     'PCacheOp.ipdl',
     'PCachePushStream.ipdl',
     'PCacheStorage.ipdl',
     'PCacheStreamControl.ipdl',
-    'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
 
