# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7fb5f1c75351e83368f8ac94d4fd832cc7c2e81d

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -554,17 +554,20 @@ NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(n
 nsresult
 nsTimeout::InitTimer(uint32_t aDelay)
 {
   // Attempt to throttle timers through if a task queue is present.  If
   // our target is nullptr then the current thread will be used.  We do
   // this every time in order to stop using the TaskQueue if its shutdown.
   nsCOMPtr<nsIEventTarget> target;
   if (mWindow) {
-    target = mWindow->GetMainThreadTaskQueue();
+    RefPtr<TaskQueue> tq = mWindow->GetMainThreadTaskQueue();
+    if (tq) {
+      target = tq->WrapAsEventTarget();
+    }
   }
   Unused << mTimer->SetTarget(target);
 
   return mTimer->InitWithNameableFuncCallback(
     nsGlobalWindow::TimerCallback, this, aDelay,
     nsITimer::TYPE_ONE_SHOT, nsGlobalWindow::TimerNameCallback);
 }
 
@@ -3613,17 +3616,20 @@ nsGlobalWindow::MaybeCreateMainThreadTas
       GetPrincipal() == nsContentUtils::GetSystemPrincipal()) {
     return;
   }
 
   nsCOMPtr<nsIEventTarget> target;
 
   nsCOMPtr<nsPIDOMWindowOuter> parent = GetParent();
   if (parent) {
-    target = parent->GetMainThreadTaskQueue();
+    RefPtr<TaskQueue> tq = parent->GetMainThreadTaskQueue();
+    if (tq) {
+      target = tq->WrapAsEventTarget();
+    }
   }
 
   if (!target) {
     nsCOMPtr<nsIThread> mainThread;
     NS_GetMainThread(getter_AddRefs(mainThread));
     MOZ_DIAGNOSTIC_ASSERT(mainThread);
     target = mainThread;
   }
@@ -3701,17 +3707,21 @@ void
 nsGlobalWindow::MaybeShutdownMainThreadTaskQueue()
 {
   if (!mMainThreadTaskQueue) {
     return;
   }
 
   MOZ_ASSERT(IsOuterWindow());
 
+  printf_stderr("### ### [%p] nsGlobalWindow::MaybeShutdownMainThreadTaskQueue() calling BeginShutdown() on %p\n",
+                this, mMainThreadTaskQueue.get());
   RefPtr<ShutdownPromise> p = mMainThreadTaskQueue->BeginShutdown();
+  printf_stderr("### ### [%p] nsGlobalWindow::MaybeShutdownMainThreadTaskQueue() after BeginShutdown() on %p\n",
+                this, mMainThreadTaskQueue.get());
 
   RefPtr<TaskQueueShutdownHandler> handler =
     new TaskQueueShutdownHandler(mMainThreadTaskQueue.forget());
 
   p->Then<TaskQueueShutdownHandler>(
     AbstractThread::MainThread(), __func__, handler,
     &TaskQueueShutdownHandler::Done,
     &TaskQueueShutdownHandler::Done);
diff --git a/xpcom/threads/TaskQueue.cpp b/xpcom/threads/TaskQueue.cpp
--- a/xpcom/threads/TaskQueue.cpp
+++ b/xpcom/threads/TaskQueue.cpp
@@ -161,27 +161,36 @@ TaskQueue::AwaitShutdownAndIdle()
     mQueueMonitor.Wait();
   }
   AwaitIdleLocked();
 }
 
 RefPtr<ShutdownPromise>
 TaskQueue::BeginShutdown()
 {
+  printf_stderr("### ### [%p] TaskQueue::BeginShutdown() start\n", this);
+
   // Dispatch any tasks for this queue waiting in the caller's tail dispatcher,
   // since this is the last opportunity to do so.
   if (AbstractThread* currentThread = AbstractThread::GetCurrent()) {
+    printf_stderr("### ### [%p] TaskQueue::BeginShutdown() start tail dispatch for %p\n",
+                  this, currentThread);
     currentThread->TailDispatcher().DispatchTasksFor(this);
   }
 
   MonitorAutoLock mon(mQueueMonitor);
   mIsShutdown = true;
+  printf_stderr("### ### [%p] TaskQueue::BeginShutdown() create promise\n", this);
   RefPtr<ShutdownPromise> p = mShutdownPromise.Ensure(__func__);
+  printf_stderr("### ### [%p] TaskQueue::BeginShutdown() MaybeResolveShutdown\n", this);
   MaybeResolveShutdown();
   mon.NotifyAll();
+
+  printf_stderr("### ### [%p] TaskQueue::BeginShutdown() end %p\n", this, p.get());
+
   return p;
 }
 
 bool
 TaskQueue::IsEmpty()
 {
   MonitorAutoLock mon(mQueueMonitor);
   return mTasks.empty();
