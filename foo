# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  671116b2e6bdf6184f872d56697c443008350b2e

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3406,17 +3406,17 @@ nsDocShell::MaybeCreateInitialClientSour
     return;
   }
 
   // If the parent is controlled then propagate that controller to the
   // initial about:blank client as well.
   RefPtr<ClientHandle> handle =
     ClientManager::CreateHandle(mInitialClientSource->Info(),
                                 parentInner->EventTargetFor(TaskCategory::Other));
-  RefPtr<GenericPromise> ref = handle->Control(controller.ref());
+  RefPtr<ClientBoolPromise> ref = handle->Control(controller.ref());
 }
 
 Maybe<ClientInfo>
 nsDocShell::GetInitialClientInfo() const
 {
   if (mInitialClientSource) {
     Maybe<ClientInfo> result;
     result.emplace(mInitialClientSource->Info());
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -132,17 +132,17 @@ Client::PostMessage(JSContext* aCx, JS::
 
   ClientEndPoint endpoint;
   aRv = ClientGetEndPoint(mGlobal, &endpoint);
   if (aRv.Failed()) {
     return;
   }
 
   EnsureHandle();
-  RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
+  RefPtr<ClientBoolPromise> p = mHandle->PostMessage(data, endpoint);
 }
 
 VisibilityState
 Client::GetVisibilityState() const
 {
   return mData->state().get_IPCClientWindowState().visibilityState();
 }
 
@@ -187,18 +187,18 @@ Client::Focus(ErrorResult& aRv)
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
   innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
         new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -231,17 +231,17 @@ Client::Navigate(const nsAString& aURL, 
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> newClient =
         new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
--- a/dom/clients/api/ClientDOMUtil.h
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -38,17 +38,17 @@ StartClientManagerOp(Func aFunc, const A
 
   RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
   promise->Then(aTarget, __func__,
     [aResolve, token](const ClientOpResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aResolve(aResult);
-    }, [aReject, token](nsresult aResult) {
+    }, [aReject, token](const CopyableErrorResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aReject(aResult);
     });
 }
 
 } // namespace dom
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -91,17 +91,17 @@ Clients::Get(const nsAString& aClientID,
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
                                    target);
   innerPromise->Then(target, __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolve(
         new Client(global, aResult.get_ClientInfoAndState()));
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
     });
 
   return outerPromise.forget();
 }
 
 namespace {
 
@@ -166,18 +166,18 @@ Clients::MatchAll(const ClientQueryOptio
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise, global] (const ClientOpResult& aResult) {
       nsTArray<RefPtr<Client>> clientList;
       for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
         clientList.AppendElement(new Client(global, value));
       }
       clientList.Sort(MatchAllComparator());
       outerPromise->MaybeResolve(clientList);
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -237,17 +237,17 @@ Clients::OpenWindow(const nsAString& aUR
     [outerPromise, global] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> client =
         new Client(global, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(client);
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
@@ -278,17 +278,17 @@ Clients::Claim(ErrorResult& aRv)
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -45,18 +45,18 @@ ClientHandle::StartOp(const ClientOpCons
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
   promise->Then(mSerialEventTarget, __func__,
-                [kungFuGrip] (const ClientOpResult &) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const ClientOpResult&) { },
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
@@ -105,84 +105,85 @@ ClientHandle::ExecutionReady(const Clien
 }
 
 const ClientInfo&
 ClientHandle::Info() const
 {
   return mClientInfo;
 }
 
-already_AddRefed<GenericPromise>
+already_AddRefed<ClientBoolPromise>
 ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
-  RefPtr<GenericPromise::Private> outerPromise =
-    new GenericPromise::Private(__func__);
+  RefPtr<ClientBoolPromise::Private> outerPromise =
+    new ClientBoolPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
     StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
-  RefPtr<GenericPromise> ref = outerPromise.get();
+  RefPtr<ClientBoolPromise> ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<ClientStatePromise>
 ClientHandle::Focus()
 {
   RefPtr<ClientStatePromise::Private> outerPromise =
     new ClientStatePromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   RefPtr<ClientStatePromise> ref = outerPromise.get();
   return ref.forget();
 }
 
-already_AddRefed<GenericPromise>
+already_AddRefed<ClientBoolPromise>
 ClientHandle::PostMessage(StructuredCloneData& aData,
                           const ClientEndPoint& aEndPoint)
 {
-  RefPtr<GenericPromise> ref;
+  RefPtr<ClientBoolPromise> ref;
 
   ClientPostMessageArgs args;
   args.endpoint() = aEndPoint;
 
   // TODO: Ideally we should be able to wait for the actor to initialize,
   //       but for now just fail the postMessage() if its not ready.  We
   //       need a RefCounted version of the StructuredCloneData in order
   //       to capture it in the lambda here.
   if (!GetActor() ||
       !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
                                                       args.clonedData())) {
-    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    ref = ClientBoolPromise::CreateAndReject(
+      CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR), __func__);
     return ref.forget();
   }
 
-  RefPtr<GenericPromise::Private> outerPromise =
-    new GenericPromise::Private(__func__);
+  RefPtr<ClientBoolPromise::Private> outerPromise =
+    new ClientBoolPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise.get();
   return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -59,23 +59,23 @@ class ClientHandle final : public Client
   // Private methods called by ClientHandleChild
   void
   ExecutionReady(const ClientInfo& aClientInfo);
 
 public:
   const ClientInfo&
   Info() const;
 
-  already_AddRefed<GenericPromise>
+  already_AddRefed<ClientBoolPromise>
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   already_AddRefed<ClientStatePromise>
   Focus();
 
-  already_AddRefed<GenericPromise>
+  already_AddRefed<ClientBoolPromise>
   PostMessage(ipc::StructuredCloneData& aData,
               const ClientEndPoint& aEndPoint);
 
   NS_INLINE_DECL_REFCOUNTING(ClientHandle);
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpChild.cpp b/dom/clients/manager/ClientHandleOpChild.cpp
--- a/dom/clients/manager/ClientHandleOpChild.cpp
+++ b/dom/clients/manager/ClientHandleOpChild.cpp
@@ -16,19 +16,19 @@ ClientHandleOpChild::ActorDestroy(ActorD
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientHandleOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -26,17 +26,18 @@ ClientHandleOpParent::ActorDestroy(Actor
   mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   ClientSourceParent* source = GetSource();
   if (!source) {
-    Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+    Unused << PClientHandleOpParent::Send__delete__(this,
+      CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
     return;
   }
 
   RefPtr<ClientOpPromise> p;
 
   // ClientPostMessageArgs can contain PBlob actors.  This means we
   // can't just forward the args from one PBackground manager to
   // another.  Instead, unpack the structured clone data and repack
@@ -46,17 +47,18 @@ ClientHandleOpParent::Init(const ClientO
 
     ClientPostMessageArgs rebuild;
     rebuild.endpoint() = orig.endpoint();
 
     StructuredCloneData data;
     data.BorrowFromClonedMessageDataForBackgroundParent(orig.clonedData());
     if (!data.BuildClonedMessageDataForBackgroundParent(source->Manager()->Manager(),
                                                         rebuild.clonedData())) {
-      Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+      Unused << PClientHandleOpParent::Send__delete__(this,
+        CopyableErrorResult(NS_ERROR_OUT_OF_MEMORY));
       return;
     }
 
     p = source->StartOp(rebuild);
   }
 
   // Other argument types can just be forwarded straight through.
   else {
@@ -65,16 +67,16 @@ ClientHandleOpParent::Init(const ClientO
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
       [this] (const ClientOpResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
-      }, [this] (const ClientOpResult& aResult) {
+      }, [this] (const CopyableErrorResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -2,17 +2,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include IPCServiceWorkerDescriptor;
 include ProtocolTypes;
-using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
+using mozilla::CopyableErrorResult from "ipc/ErrorIPCUtils.h";
+using mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 struct ClientSourceConstructorArgs
@@ -142,16 +143,16 @@ struct ClientNavigateOpConstructorArgs
 {
   PClientSource target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientOpResult
 {
-  nsresult;
+  CopyableErrorResult;
   IPCClientState;
   ClientInfoAndState;
   ClientList;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -194,17 +194,17 @@ ClientManager::StartOp(const ClientOpCon
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientManager> kungFuGrip = this;
   promise->Then(aSerialEventTarget, __func__,
                 [kungFuGrip] (const ClientOpResult&) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
     ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
     if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
diff --git a/dom/clients/manager/ClientManagerOpChild.cpp b/dom/clients/manager/ClientManagerOpChild.cpp
--- a/dom/clients/manager/ClientManagerOpChild.cpp
+++ b/dom/clients/manager/ClientManagerOpChild.cpp
@@ -16,19 +16,19 @@ ClientManagerOpChild::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientManagerOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -24,19 +24,19 @@ ClientManagerOpParent::DoServiceOp(Metho
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [this] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const mozilla::CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
-      Unused << PClientManagerOpParent::Send__delete__(this, aRv);
+      Unused << PClientManagerOpParent::Send__delete__(this, mozilla::CopyableErrorResult(aRv));
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientManagerOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   mPromiseRequestHolder.DisconnectIfExists();
 }
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -242,17 +242,17 @@ public:
 
   already_AddRefed<ClientOpPromise>
   GetResultPromise()
   {
     RefPtr<PromiseListHolder> kungFuDeathGrip = this;
     mResultPromise->Then(
       GetCurrentThreadSerialEventTarget(), __func__,
       [kungFuDeathGrip] (const ClientOpResult& aResult) { },
-      [kungFuDeathGrip] (nsresult aResult) { });
+      [kungFuDeathGrip] (const CopyableErrorResult& aResult) { });
 
     RefPtr<ClientOpPromise> ref = mResultPromise;
     return ref.forget();
   }
 
   void
   AddPromise(already_AddRefed<ClientOpPromise> aPromise)
   {
@@ -267,17 +267,17 @@ public:
         // TODO: This is pretty clunky.  Try to figure out a better
         //       wait for MatchAll() and Claim() to share this code
         //       even though they expect different return values.
         if (aResult.type() == ClientOpResult::TClientInfoAndState) {
           self->ProcessSuccess(aResult.get_ClientInfoAndState());
         } else {
           self->ProcessCompletion();
         }
-      }, [self] (nsresult aResult) {
+      }, [self] (const CopyableErrorResult& aResult) {
         self->ProcessCompletion();
       });
   }
 
   void
   MaybeFinish()
   {
     if (!mOutstandingPromiseCount) {
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -50,32 +50,32 @@ public:
         !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
       return NS_OK;
     }
 
     aWebProgress->RemoveProgressListener(this);
 
     nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
     if (!channel) {
-      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      mPromise->Reject(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR), __func__);
       return NS_OK;
     }
 
     nsCOMPtr<nsIURI> channelURL;
     nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
     if (NS_FAILED(rv)) {
-      mPromise->Reject(rv, __func__);
+      mPromise->Reject(CopyableErrorResult(rv), __func__);
       return NS_OK;
     }
 
     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
     MOZ_DIAGNOSTIC_ASSERT(ssm);
     rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
     if (NS_FAILED(rv)) {
-      mPromise->Resolve(NS_OK, __func__);
+      mPromise->Resolve(CopyableErrorResult(NS_OK), __func__);
       return NS_OK;
     }
 
     // TODO: legacy code only did this for same-origin, was that intentional
     Unused << nsContentUtils::DispatchFocusChromeEvent(mOuterWindow);
 
     // TODO: Not clear this progress listener guarantees following assertions...
 
@@ -134,117 +134,123 @@ NS_IMPL_ISUPPORTS(NavigateLoadListener, 
                                         nsISupportsWeakReference);
 
 } // anonymous namespace
 
 already_AddRefed<ClientOpPromise>
 ClientNavigateOpChild::DoNavigate(const ClientNavigateOpConstructorArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
+  CopyableErrorResult rv;
 
   ClientSourceChild* targetActor =
     static_cast<ClientSourceChild*>(aArgs.targetChild());
   MOZ_DIAGNOSTIC_ASSERT(targetActor);
 
   ClientSource* target = targetActor->GetSource();
   if (!target) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsPIDOMWindowInner* window = target->GetInnerWindow();
   if (!window) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
   mSerialEventTarget = window->EventTargetFor(TaskCategory::Other);
 
   // In theory we could do the URL work before paying the IPC overhead
   // cost, but in practice its easier to do it here.  The ClientHandle
   // may be off-main-thread while this method is guaranteed to always
   // be main thread.
   nsCOMPtr<nsIURI> baseURL;
-  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
-  if (NS_FAILED(rv)) {
+  rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsCOMPtr<nsIURI> url;
   rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   if (url->GetSpecOrDefault().EqualsLiteral("about:blank")) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    // TODO: better error code
+    rv.Throw(NS_ERROR_FAILURE);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   if (!doc || !doc->IsActive()) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
   if (!principal) {
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
   if (!docShell || !webProgress) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
   rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   loadInfo->SetTriggeringPrincipal(principal);
   loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
   loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContent);
   loadInfo->SetSourceDocShell(docShell);
   rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   nsCOMPtr<nsIWebProgressListener> listener =
     new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     promise->Reject(rv, __func__);
     ref = promise;
     return ref.forget();
   }
 
   ref = promise.get();
 
   ref->Then(mSerialEventTarget, __func__,
     [listener] (const ClientOpResult& aResult) { },
-    [listener] (nsresult aResult) { });
+    [listener] (const CopyableErrorResult& aResult) { });
 
   return ref.forget();
 }
 
 void
 ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
   mPromiseRequestHolder.DisconnectIfExists();
@@ -261,16 +267,16 @@ ClientNavigateOpChild::Init(const Client
   if (!mSerialEventTarget) {
     mSerialEventTarget = GetCurrentThreadSerialEventTarget();
   }
 
   promise->Then(mSerialEventTarget, __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
--- a/dom/clients/manager/ClientNavigateOpParent.cpp
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -18,19 +18,19 @@ ClientNavigateOpParent::ActorDestroy(Act
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpPromise.h b/dom/clients/manager/ClientOpPromise.h
--- a/dom/clients/manager/ClientOpPromise.h
+++ b/dom/clients/manager/ClientOpPromise.h
@@ -4,21 +4,26 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientOpPromise_h
 #define _mozilla_dom_ClientOpPromise_h
 
 #include "mozilla/MozPromise.h"
 
 namespace mozilla {
+
+class CopyableErrorResult;
+
 namespace dom {
 
 class ClientOpResult;
 class ClientState;
 
-typedef MozPromise<ClientOpResult, nsresult, false> ClientOpPromise;
+typedef MozPromise<ClientOpResult, CopyableErrorResult, false> ClientOpPromise;
 
-typedef MozPromise<ClientState, nsresult, false> ClientStatePromise;
+typedef MozPromise<ClientState, CopyableErrorResult, false> ClientStatePromise;
+
+typedef MozPromise<bool, CopyableErrorResult, false> ClientBoolPromise;
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientOpPromise_h
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
--- a/dom/clients/manager/ClientOpenWindowOpChild.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -28,16 +28,16 @@ ClientOpenWindowOpChild::ActorDestroy(Ac
 void
 ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
 {
   RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
   promise->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpParent.cpp b/dom/clients/manager/ClientOpenWindowOpParent.cpp
--- a/dom/clients/manager/ClientOpenWindowOpParent.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpParent.cpp
@@ -10,27 +10,29 @@ namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ClientOpenWindowOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mPromise) {
-    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    CopyableErrorResult rv;
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    mPromise->Reject(rv, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientOpenWindowOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
--- a/dom/clients/manager/ClientOpenWindowUtils.cpp
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -59,44 +59,50 @@ public:
     }
 
     // Our caller keeps a strong reference, so it is safe to remove the listener
     // from ServiceWorkerPrivate.
     aWebProgress->RemoveProgressListener(this);
 
     nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
     if (NS_WARN_IF(!doc)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     // Check same origin.
     nsCOMPtr<nsIScriptSecurityManager> securityManager =
       nsContentUtils::GetSecurityManager();
     nsresult rv = securityManager->CheckSameOriginURI(doc->GetOriginalURI(),
                                                       mBaseURI, false);
     if (NS_FAILED(rv)) {
-      mPromise->Resolve(NS_OK, __func__);
+      mPromise->Resolve(CopyableErrorResult(), __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
     if (NS_WARN_IF(!innerWindow)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     Maybe<ClientInfo> info = innerWindow->GetClientInfo();
     Maybe<ClientState> state = innerWindow->GetClientState();
 
     if (NS_WARN_IF(info.isNothing() || state.isNothing())) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     mPromise->Resolve(ClientInfoAndState(info.ref().ToIPC(), state.ref().ToIPC()),
                       __func__);
     mPromise = nullptr;
 
@@ -142,17 +148,19 @@ public:
     MOZ_ASSERT(false, "Unexpected notification.");
     return NS_OK;
   }
 
 private:
   ~WebProgressListener()
   {
     if (mPromise) {
-      mPromise->Reject(NS_ERROR_ABORT, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
     }
   }
 
   RefPtr<ClientOpPromise::Private> mPromise;
   // TODO: make window a weak ref and stop cycle collecting
   nsCOMPtr<nsPIDOMWindowOuter> mWindow;
   nsCOMPtr<nsIURI> mBaseURI;
@@ -269,54 +277,55 @@ void
 WaitForLoad(const ClientOpenWindowArgs& aArgs,
             nsPIDOMWindowOuter* aOuterWindow,
             ClientOpPromise::Private* aPromise)
 {
   MOZ_DIAGNOSTIC_ASSERT(aOuterWindow);
 
   RefPtr<ClientOpPromise::Private> promise = aPromise;
 
-  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  CopyableErrorResult rv(nsContentUtils::DispatchFocusChromeEvent(aOuterWindow));
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIURI> baseURI;
   rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIDocShell> docShell = aOuterWindow->GetDocShell();
   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
 
   if (NS_WARN_IF(!webProgress)) {
-    promise->Reject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    promise->Reject(rv, __func__);
     return;
   }
 
   RefPtr<ClientOpPromise> ref = promise;
 
   RefPtr<WebProgressListener> listener =
     new WebProgressListener(aOuterWindow, baseURI, promise.forget());
 
 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   // Hold the listener alive until the promise settles
   ref->Then(aOuterWindow->EventTargetFor(TaskCategory::Other), __func__,
     [listener] (const ClientOpResult& aResult) { },
-    [listener] (nsresult aResult) { });
+    [listener] (const CopyableErrorResult& aResult) { });
 }
 
 #ifdef MOZ_WIDGET_ANDROID
 
 class LaunchObserver final : public nsIObserver
 {
   RefPtr<GenericPromise::Private> mPromise;
 
@@ -410,17 +419,17 @@ ClientOpenWindowInCurrentProcess(const C
       [aArgs, promise] (bool aResult) {
         nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
         nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
         if (NS_WARN_IF(NS_FAILED(rv))) {
           promise->Reject(rv, __func__);
         }
 
         WaitForLoad(aArgs, outerWindow, promise);
-      }, [promise] (nsresult aResult) {
+      }, [promise] (const CopyableErrorResult& aResult) {
         promise->Reject(aResult, __func__);
       });
     return ref.forget();
   }
 
   // If we didn't get the NOT_AVAILABLE error then there is no need
   // wait for the browser to launch.  Cancel the observer so that it
   // will release.
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -336,91 +336,94 @@ ClientSource::SetController(const Servic
 already_AddRefed<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
 
   RefPtr<ClientOpPromise> ref =
-    ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ClientOpPromise::CreateAndResolve(CopyableErrorResult(), __func__);
   return ref.forget();;
 }
 
 const Maybe<ServiceWorkerDescriptor>&
 ClientSource::GetController() const
 {
   return mController;
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::Focus(const ClientFocusArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   RefPtr<ClientOpPromise> ref;
+  CopyableErrorResult rv;
 
   if (mClientInfo.Type() != ClientType::Window) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsPIDOMWindowOuter* outer = nullptr;
 
   nsPIDOMWindowInner* inner = GetInnerWindow();
   if (inner) {
     outer = inner->GetOuterWindow();
   } else {
     nsIDocShell* docshell = GetDocShell();
     if (docshell) {
       outer = docshell->GetWindow();
     }
   }
 
   if (!outer) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(outer);
-  if (NS_FAILED(rv)) {
+  rv = nsContentUtils::DispatchFocusChromeEvent(outer);
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ClientState state;
   rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
+  CopyableErrorResult rv;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TIPCClientInfo
       ? endpoint.get_IPCClientInfo().principalInfo()
       : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   // TODO: this should probably not require strict spec matching
   if (false && !(mClientInfo.PrincipalInfo() == principalInfo)) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_FAILURE);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   StructuredCloneData clonedData;
   clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
 
   RefPtr<ServiceWorkerContainer> target;
   nsCOMPtr<nsIGlobalObject> globalObject;
@@ -451,77 +454,80 @@ ClientSource::PostMessage(const ClientPo
           globalObject = wp->GlobalScope();
         }
       }
       // TODO: Set target to self.navigator.serviceWorker on workers when its exposed there
     }
   }
 
   if (!target) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_NOT_IMPLEMENTED, __func__);
+    rv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   // If AutoJSAPI::Init() fails then either global is nullptr or not
   // in a usable state.  Treat this as a postMessage() before ExecutionReady
   // and just queue the message.  We will deliver the messages later
   // when the Client is marked ExecutionReady.
   AutoJSAPI jsapi;
   if (!jsapi.Init(globalObject)) {
     // TODO: queue messages until ExecutionReady
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   JSContext* cx = jsapi.cx();
 
-  ErrorResult result;
   JS::Rooted<JS::Value> messageData(cx);
-  clonedData.Read(cx, &messageData, result);
-  if (result.MaybeSetPendingException(cx)) {
+  clonedData.Read(cx, &messageData, rv);
+  if (rv.MaybeSetPendingException(cx)) {
     // We reported the error in the current window context.  Resolve
     // promise instead of rejecting.
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    rv.SuppressException();
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   RootedDictionary<MessageEventInit> init(cx);
 
   init.mData = messageData;
   if (!clonedData.TakeTransferredPortsAsSequence(init.mPorts)) {
     // Report the error in the current window context and resolve the
     // promise instead of rejecting.
     xpc::Throw(cx, NS_ERROR_OUT_OF_MEMORY);
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   // Currently we only support firing these messages on window Clients.
   // Once we expose ServiceWorkerContainer and the ServiceWorker on Worker
   // threads then this will need to change.
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv = NS_OK;
+  nsresult result = NS_OK;
   nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(principalInfo, &rv);
-  if (NS_FAILED(rv) || !principal) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    PrincipalInfoToPrincipal(principalInfo, &result);
+  if (NS_FAILED(result) || !principal) {
+    rv.Throw(NS_ERROR_FAILURE);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsAutoCString origin;
   rv = principal->GetOriginNoSuffix(origin);
-  if (NS_SUCCEEDED(rv)) {
+  if (!rv.Failed()) {
     CopyUTF8toUTF16(origin, init.mOrigin);
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // Shutting down. Just don't deliver this message.
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
     const IPCServiceWorkerDescriptor& swd = endpoint.get_IPCServiceWorkerDescriptor();
     RefPtr<ServiceWorkerRegistrationInfo> reg =
       swm->GetRegistration(principal, swd.scope());
     if (reg) {
@@ -536,33 +542,30 @@ ClientSource::PostMessage(const ClientPo
   // Eventually we should expose Client in MessageEvent.source.
 
   RefPtr<MessageEvent> event =
     MessageEvent::Constructor(target, NS_LITERAL_STRING("message"), init);
   event->SetTrusted(true);
 
   bool status = false;
   target->DispatchEvent(static_cast<dom::Event*>(event.get()), &status);
-  if (!status) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
-    return ref.forget();
-  }
+  // Ignore dispatch status and just resolve ok no matter what.
 
-  ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  ref = ClientOpPromise::CreateAndResolve(rv, __func__);
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::GetState(const ClientGetStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
   ClientState state;
-  nsresult rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  CopyableErrorResult rv(SnapshotState(&state));
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
   return ref.forget();
 }
 
@@ -581,43 +584,43 @@ ClientSource::Claim(const ClientClaimArg
   // it will eventually hold ClientHandle objects instead of
   // nsIDocuments.
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   nsPIDOMWindowInner* innerWindow = GetInnerWindow();
   nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
   if (!swm || !doc) {
     SetController(swd);
 
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(CopyableErrorResult(), __func__);
     return ref.forget();
   }
 
   RefPtr<ClientOpPromise::Private> outerPromise =
     new ClientOpPromise::Private(__func__);
 
   RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
   p->Then(innerWindow->EventTargetFor(TaskCategory::Other), __func__,
     [outerPromise] (bool aResult) {
-      outerPromise->Resolve(NS_OK, __func__);
+      outerPromise->Resolve(CopyableErrorResult(), __func__);
     }, [outerPromise] (nsresult aResult) {
-      outerPromise->Reject(aResult, __func__);
+      outerPromise->Reject(CopyableErrorResult(aResult), __func__);
     });
 
   ref = outerPromise;
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
   ClientState state;
-  nsresult rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  CopyableErrorResult rv(SnapshotState(&state));
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo.ToIPC(),
                                                              state.ToIPC()), __func__);
   return ref.forget();
 }
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceOpChild.h"
 
 #include "ClientSource.h"
 #include "ClientSourceChild.h"
+#include "mozilla/ErrorResult.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 ClientSource*
 ClientSourceOpChild::GetSource() const
 {
@@ -27,17 +28,19 @@ ClientSourceOpChild::DoSourceOp(Method a
   RefPtr<ClientOpPromise> promise;
   nsCOMPtr<nsISerialEventTarget> target;
 
   // Limit the scope of the source variable since running the operation
   // can cause the ClientSource object to be destroyed.
   {
     ClientSource* source = GetSource();
     if (!source) {
-      Unused << PClientSourceOpChild::Send__delete__(this, NS_ERROR_ABORT);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      Unused << PClientSourceOpChild::Send__delete__(this, rv);
       return;
     }
 
     target = source->EventTargetFor(TaskCategory::Other);
 
     // This may cause the ClientSource object to be destroyed.  Do not
     // use the source variable after this call.
     promise = (source->*aMethod)(aArgs);
@@ -45,17 +48,17 @@ ClientSourceOpChild::DoSourceOp(Method a
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   promise->Then(target, __func__,
     [this, aArgs] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const mozilla::CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientSourceOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
diff --git a/dom/clients/manager/ClientSourceOpParent.cpp b/dom/clients/manager/ClientSourceOpParent.cpp
--- a/dom/clients/manager/ClientSourceOpParent.cpp
+++ b/dom/clients/manager/ClientSourceOpParent.cpp
@@ -18,19 +18,19 @@ ClientSourceOpParent::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientSourceOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2467,19 +2467,30 @@ ServiceWorkerManager::StartControllingAD
   }
   ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
   nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
   if (activeWorker && innerWindow) {
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     if (clientInfo.isSome()) {
       RefPtr<ClientHandle> clientHandle =
         ClientManager::CreateHandle(clientInfo.ref(),
-                                    SystemGroup::EventTargetFor(TaskCategory::Other));
+                                    innerWindow->EventTargetFor(TaskCategory::Other));
       if (clientHandle) {
-        ref = clientHandle->Control(activeWorker->Descriptor());
+        RefPtr<GenericPromise::Private> outerPromise =
+          new GenericPromise::Private(__func__);
+        ref = outerPromise;
+
+        RefPtr<ClientBoolPromise> innerPromise =
+          clientHandle->Control(activeWorker->Descriptor());
+        innerPromise->Then(innerWindow->EventTargetFor(TaskCategory::Other), __func__,
+          [outerPromise](bool aResult) {
+            outerPromise->Resolve(aResult, __func__);
+          }, [outerPromise](const CopyableErrorResult& aResult) {
+            outerPromise->Reject(CopyableErrorResult(aResult).StealNSResult(), __func__);
+          });
       }
     }
   }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
   return ref.forget();
 }
 
 void
@@ -2799,17 +2810,17 @@ ServiceWorkerManager::DispatchFetchEvent
       if (clientInfo.isSome()) {
         // First, attempt to mark the reserved client controlled directly.  This
         // will update the controlled status in the ClientManagerService in the
         // parent.  It will also eventually propagate back to the ClientSource.
         RefPtr<ClientHandle> clientHandle =
           ClientManager::CreateHandle(clientInfo.ref(),
                                       SystemGroup::EventTargetFor(TaskCategory::Other));
         if (clientHandle) {
-          RefPtr<GenericPromise> p =
+          RefPtr<ClientBoolPromise> p =
             clientHandle->Control(serviceWorker->Descriptor());
         }
 
         // But we also note the reserved state on the LoadInfo.  This allows the
         // ClientSource to be updated immediately after the nsIChannel starts.
         // This is necessary to have the correct controller in place for immediate
         // follow-on requests.
         loadInfo->SetController(serviceWorker->Descriptor());
@@ -3577,17 +3588,17 @@ ServiceWorkerManager::UpdateClientContro
     }
 
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     if (clientInfo.isSome()) {
       RefPtr<ClientHandle> clientHandle =
         ClientManager::CreateHandle(clientInfo.ref(),
                                     innerWindow->EventTargetFor(TaskCategory::Other));
       if (clientHandle) {
-        RefPtr<GenericPromise> p =
+        RefPtr<ClientBoolPromise> p =
           clientHandle->Control(activeWorker->Descriptor());
       }
     }
   }
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetRegistration(nsIPrincipal* aPrincipal,
