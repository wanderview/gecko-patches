# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f018a475db7337d7ef30577ba37017bdb361eb33

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -187,18 +187,18 @@ Client::Focus(ErrorResult& aRv)
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
   innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
         new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -231,17 +231,17 @@ Client::Navigate(const nsAString& aURL, 
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> newClient =
         new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
--- a/dom/clients/api/ClientDOMUtil.h
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -38,17 +38,17 @@ StartClientManagerOp(Func aFunc, const A
 
   RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
   promise->Then(aTarget, __func__,
     [aResolve, token](const ClientOpResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aResolve(aResult);
-    }, [aReject, token](nsresult aResult) {
+    }, [aReject, token](const CopyableErrorResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aReject(aResult);
     });
 }
 
 } // namespace dom
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -91,17 +91,17 @@ Clients::Get(const nsAString& aClientID,
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
                                    target);
   innerPromise->Then(target, __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolve(
         new Client(global, aResult.get_ClientInfoAndState()));
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
     });
 
   return outerPromise.forget();
 }
 
 namespace {
 
@@ -166,18 +166,18 @@ Clients::MatchAll(const ClientQueryOptio
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise, global] (const ClientOpResult& aResult) {
       nsTArray<RefPtr<Client>> clientList;
       for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
         clientList.AppendElement(new Client(global, value));
       }
       clientList.Sort(MatchAllComparator());
       outerPromise->MaybeResolve(clientList);
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -237,17 +237,17 @@ Clients::OpenWindow(const nsAString& aUR
     [outerPromise, global] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> client =
         new Client(global, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(client);
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
@@ -278,17 +278,17 @@ Clients::Claim(ErrorResult& aRv)
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -45,18 +45,18 @@ ClientHandle::StartOp(const ClientOpCons
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
   promise->Then(mSerialEventTarget, __func__,
-                [kungFuGrip] (const ClientOpResult &) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const ClientOpResult&) { },
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
@@ -117,18 +117,18 @@ ClientHandle::Control(const ServiceWorke
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
     StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult.StealNSResult(), __func__);
     });
 
   RefPtr<GenericPromise> ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<ClientStatePromise>
 ClientHandle::Focus()
@@ -136,18 +136,18 @@ ClientHandle::Focus()
   RefPtr<ClientStatePromise::Private> outerPromise =
     new ClientStatePromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   RefPtr<ClientStatePromise> ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<GenericPromise>
 ClientHandle::PostMessage(StructuredCloneData& aData,
@@ -171,18 +171,18 @@ ClientHandle::PostMessage(StructuredClon
 
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult.StealNSResult(), __func__);
     });
 
   ref = outerPromise.get();
   return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpChild.cpp b/dom/clients/manager/ClientHandleOpChild.cpp
--- a/dom/clients/manager/ClientHandleOpChild.cpp
+++ b/dom/clients/manager/ClientHandleOpChild.cpp
@@ -16,19 +16,19 @@ ClientHandleOpChild::ActorDestroy(ActorD
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientHandleOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -26,17 +26,18 @@ ClientHandleOpParent::ActorDestroy(Actor
   mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   ClientSourceParent* source = GetSource();
   if (!source) {
-    Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+    Unused << PClientHandleOpParent::Send__delete__(this,
+      CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
     return;
   }
 
   RefPtr<ClientOpPromise> p;
 
   // ClientPostMessageArgs can contain PBlob actors.  This means we
   // can't just forward the args from one PBackground manager to
   // another.  Instead, unpack the structured clone data and repack
@@ -46,17 +47,18 @@ ClientHandleOpParent::Init(const ClientO
 
     ClientPostMessageArgs rebuild;
     rebuild.endpoint() = orig.endpoint();
 
     StructuredCloneData data;
     data.BorrowFromClonedMessageDataForBackgroundParent(orig.clonedData());
     if (!data.BuildClonedMessageDataForBackgroundParent(source->Manager()->Manager(),
                                                         rebuild.clonedData())) {
-      Unused << PClientHandleOpParent::Send__delete__(this, NS_ERROR_ABORT);
+      Unused << PClientHandleOpParent::Send__delete__(this,
+        CopyableErrorResult(NS_ERROR_OUT_OF_MEMORY));
       return;
     }
 
     p = source->StartOp(rebuild);
   }
 
   // Other argument types can just be forwarded straight through.
   else {
@@ -65,16 +67,16 @@ ClientHandleOpParent::Init(const ClientO
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
       [this] (const ClientOpResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
-      }, [this] (const ClientOpResult& aResult) {
+      }, [this] (const CopyableErrorResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -2,17 +2,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include IPCServiceWorkerDescriptor;
 include ProtocolTypes;
-using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
+using mozilla::CopyableErrorResult from "ipc/ErrorIPCUtils.h";
+using mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 struct ClientSourceConstructorArgs
@@ -142,16 +143,16 @@ struct ClientNavigateOpConstructorArgs
 {
   PClientSource target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientOpResult
 {
-  nsresult;
+  CopyableErrorResult;
   IPCClientState;
   ClientInfoAndState;
   ClientList;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -194,17 +194,17 @@ ClientManager::StartOp(const ClientOpCon
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientManager> kungFuGrip = this;
   promise->Then(aSerialEventTarget, __func__,
                 [kungFuGrip] (const ClientOpResult&) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
     ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
     if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
diff --git a/dom/clients/manager/ClientManagerOpChild.cpp b/dom/clients/manager/ClientManagerOpChild.cpp
--- a/dom/clients/manager/ClientManagerOpChild.cpp
+++ b/dom/clients/manager/ClientManagerOpChild.cpp
@@ -16,19 +16,19 @@ ClientManagerOpChild::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientManagerOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -24,19 +24,19 @@ ClientManagerOpParent::DoServiceOp(Metho
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [this] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const mozilla::CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
-      Unused << PClientManagerOpParent::Send__delete__(this, aRv);
+      Unused << PClientManagerOpParent::Send__delete__(this, mozilla::CopyableErrorResult(aRv));
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientManagerOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   mPromiseRequestHolder.DisconnectIfExists();
 }
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -242,17 +242,17 @@ public:
 
   already_AddRefed<ClientOpPromise>
   GetResultPromise()
   {
     RefPtr<PromiseListHolder> kungFuDeathGrip = this;
     mResultPromise->Then(
       GetCurrentThreadSerialEventTarget(), __func__,
       [kungFuDeathGrip] (const ClientOpResult& aResult) { },
-      [kungFuDeathGrip] (nsresult aResult) { });
+      [kungFuDeathGrip] (const CopyableErrorResult& aResult) { });
 
     RefPtr<ClientOpPromise> ref = mResultPromise;
     return ref.forget();
   }
 
   void
   AddPromise(already_AddRefed<ClientOpPromise> aPromise)
   {
@@ -267,17 +267,17 @@ public:
         // TODO: This is pretty clunky.  Try to figure out a better
         //       wait for MatchAll() and Claim() to share this code
         //       even though they expect different return values.
         if (aResult.type() == ClientOpResult::TClientInfoAndState) {
           self->ProcessSuccess(aResult.get_ClientInfoAndState());
         } else {
           self->ProcessCompletion();
         }
-      }, [self] (nsresult aResult) {
+      }, [self] (const CopyableErrorResult& aResult) {
         self->ProcessCompletion();
       });
   }
 
   void
   MaybeFinish()
   {
     if (!mOutstandingPromiseCount) {
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -261,16 +261,16 @@ ClientNavigateOpChild::Init(const Client
   if (!mSerialEventTarget) {
     mSerialEventTarget = GetCurrentThreadSerialEventTarget();
   }
 
   promise->Then(mSerialEventTarget, __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
--- a/dom/clients/manager/ClientNavigateOpParent.cpp
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -18,19 +18,19 @@ ClientNavigateOpParent::ActorDestroy(Act
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpPromise.h b/dom/clients/manager/ClientOpPromise.h
--- a/dom/clients/manager/ClientOpPromise.h
+++ b/dom/clients/manager/ClientOpPromise.h
@@ -4,21 +4,24 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientOpPromise_h
 #define _mozilla_dom_ClientOpPromise_h
 
 #include "mozilla/MozPromise.h"
 
 namespace mozilla {
+
+class CopyableErrorResult;
+
 namespace dom {
 
 class ClientOpResult;
 class ClientState;
 
-typedef MozPromise<ClientOpResult, nsresult, false> ClientOpPromise;
+typedef MozPromise<ClientOpResult, CopyableErrorResult, false> ClientOpPromise;
 
-typedef MozPromise<ClientState, nsresult, false> ClientStatePromise;
+typedef MozPromise<ClientState, CopyableErrorResult, false> ClientStatePromise;
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientOpPromise_h
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
--- a/dom/clients/manager/ClientOpenWindowOpChild.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -28,16 +28,16 @@ ClientOpenWindowOpChild::ActorDestroy(Ac
 void
 ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
 {
   RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
   promise->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpParent.cpp b/dom/clients/manager/ClientOpenWindowOpParent.cpp
--- a/dom/clients/manager/ClientOpenWindowOpParent.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpParent.cpp
@@ -10,27 +10,29 @@ namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ClientOpenWindowOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mPromise) {
-    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    CopyableErrorResult rv;
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    mPromise->Reject(rv, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientOpenWindowOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
--- a/dom/clients/manager/ClientOpenWindowUtils.cpp
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -59,44 +59,50 @@ public:
     }
 
     // Our caller keeps a strong reference, so it is safe to remove the listener
     // from ServiceWorkerPrivate.
     aWebProgress->RemoveProgressListener(this);
 
     nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
     if (NS_WARN_IF(!doc)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     // Check same origin.
     nsCOMPtr<nsIScriptSecurityManager> securityManager =
       nsContentUtils::GetSecurityManager();
     nsresult rv = securityManager->CheckSameOriginURI(doc->GetOriginalURI(),
                                                       mBaseURI, false);
     if (NS_FAILED(rv)) {
-      mPromise->Resolve(NS_OK, __func__);
+      mPromise->Resolve(CopyableErrorResult(), __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
     if (NS_WARN_IF(!innerWindow)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     Maybe<ClientInfo> info = innerWindow->GetClientInfo();
     Maybe<ClientState> state = innerWindow->GetClientState();
 
     if (NS_WARN_IF(info.isNothing() || state.isNothing())) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     mPromise->Resolve(ClientInfoAndState(info.ref().ToIPC(), state.ref().ToIPC()),
                       __func__);
     mPromise = nullptr;
 
@@ -142,17 +148,19 @@ public:
     MOZ_ASSERT(false, "Unexpected notification.");
     return NS_OK;
   }
 
 private:
   ~WebProgressListener()
   {
     if (mPromise) {
-      mPromise->Reject(NS_ERROR_ABORT, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
     }
   }
 
   RefPtr<ClientOpPromise::Private> mPromise;
   // TODO: make window a weak ref and stop cycle collecting
   nsCOMPtr<nsPIDOMWindowOuter> mWindow;
   nsCOMPtr<nsIURI> mBaseURI;
@@ -269,54 +277,55 @@ void
 WaitForLoad(const ClientOpenWindowArgs& aArgs,
             nsPIDOMWindowOuter* aOuterWindow,
             ClientOpPromise::Private* aPromise)
 {
   MOZ_DIAGNOSTIC_ASSERT(aOuterWindow);
 
   RefPtr<ClientOpPromise::Private> promise = aPromise;
 
-  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  CopyableErrorResult rv(nsContentUtils::DispatchFocusChromeEvent(aOuterWindow));
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIURI> baseURI;
   rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIDocShell> docShell = aOuterWindow->GetDocShell();
   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
 
   if (NS_WARN_IF(!webProgress)) {
-    promise->Reject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    promise->Reject(rv, __func__);
     return;
   }
 
   RefPtr<ClientOpPromise> ref = promise;
 
   RefPtr<WebProgressListener> listener =
     new WebProgressListener(aOuterWindow, baseURI, promise.forget());
 
 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   // Hold the listener alive until the promise settles
   ref->Then(aOuterWindow->EventTargetFor(TaskCategory::Other), __func__,
     [listener] (const ClientOpResult& aResult) { },
-    [listener] (nsresult aResult) { });
+    [listener] (const CopyableErrorResult& aResult) { });
 }
 
 #ifdef MOZ_WIDGET_ANDROID
 
 class LaunchObserver final : public nsIObserver
 {
   RefPtr<GenericPromise::Private> mPromise;
 
@@ -410,17 +419,17 @@ ClientOpenWindowInCurrentProcess(const C
       [aArgs, promise] (bool aResult) {
         nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
         nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
         if (NS_WARN_IF(NS_FAILED(rv))) {
           promise->Reject(rv, __func__);
         }
 
         WaitForLoad(aArgs, outerWindow, promise);
-      }, [promise] (nsresult aResult) {
+      }, [promise] (const CopyableErrorResult& aResult) {
         promise->Reject(aResult, __func__);
       });
     return ref.forget();
   }
 
   // If we didn't get the NOT_AVAILABLE error then there is no need
   // wait for the browser to launch.  Cancel the observer so that it
   // will release.
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -336,91 +336,94 @@ ClientSource::SetController(const Servic
 already_AddRefed<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
 
   RefPtr<ClientOpPromise> ref =
-    ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ClientOpPromise::CreateAndResolve(CopyableErrorResult(), __func__);
   return ref.forget();;
 }
 
 const Maybe<ServiceWorkerDescriptor>&
 ClientSource::GetController() const
 {
   return mController;
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::Focus(const ClientFocusArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
   RefPtr<ClientOpPromise> ref;
+  CopyableErrorResult rv;
 
   if (mClientInfo.Type() != ClientType::Window) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_NOT_SUPPORTED_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsPIDOMWindowOuter* outer = nullptr;
 
   nsPIDOMWindowInner* inner = GetInnerWindow();
   if (inner) {
     outer = inner->GetOuterWindow();
   } else {
     nsIDocShell* docshell = GetDocShell();
     if (docshell) {
       outer = docshell->GetWindow();
     }
   }
 
   if (!outer) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(outer);
-  if (NS_FAILED(rv)) {
+  rv = nsContentUtils::DispatchFocusChromeEvent(outer);
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ClientState state;
   rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
+  CopyableErrorResult rv;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TIPCClientInfo
       ? endpoint.get_IPCClientInfo().principalInfo()
       : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   // TODO: this should probably not require strict spec matching
   if (false && !(mClientInfo.PrincipalInfo() == principalInfo)) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_FAILURE);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   StructuredCloneData clonedData;
   clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
 
   RefPtr<ServiceWorkerContainer> target;
   nsCOMPtr<nsIGlobalObject> globalObject;
@@ -451,77 +454,80 @@ ClientSource::PostMessage(const ClientPo
           globalObject = wp->GlobalScope();
         }
       }
       // TODO: Set target to self.navigator.serviceWorker on workers when its exposed there
     }
   }
 
   if (!target) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_NOT_IMPLEMENTED, __func__);
+    rv.Throw(NS_ERROR_NOT_IMPLEMENTED);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   // If AutoJSAPI::Init() fails then either global is nullptr or not
   // in a usable state.  Treat this as a postMessage() before ExecutionReady
   // and just queue the message.  We will deliver the messages later
   // when the Client is marked ExecutionReady.
   AutoJSAPI jsapi;
   if (!jsapi.Init(globalObject)) {
     // TODO: queue messages until ExecutionReady
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   JSContext* cx = jsapi.cx();
 
-  ErrorResult result;
   JS::Rooted<JS::Value> messageData(cx);
-  clonedData.Read(cx, &messageData, result);
-  if (result.MaybeSetPendingException(cx)) {
+  clonedData.Read(cx, &messageData, rv);
+  if (rv.MaybeSetPendingException(cx)) {
     // We reported the error in the current window context.  Resolve
     // promise instead of rejecting.
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    rv.SuppressException();
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   RootedDictionary<MessageEventInit> init(cx);
 
   init.mData = messageData;
   if (!clonedData.TakeTransferredPortsAsSequence(init.mPorts)) {
     // Report the error in the current window context and resolve the
     // promise instead of rejecting.
     xpc::Throw(cx, NS_ERROR_OUT_OF_MEMORY);
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(rv, __func__);
     return ref.forget();
   }
 
   // Currently we only support firing these messages on window Clients.
   // Once we expose ServiceWorkerContainer and the ServiceWorker on Worker
   // threads then this will need to change.
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv = NS_OK;
+  nsresult result = NS_OK;
   nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(principalInfo, &rv);
-  if (NS_FAILED(rv) || !principal) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    PrincipalInfoToPrincipal(principalInfo, &result);
+  if (NS_FAILED(result) || !principal) {
+    rv.Throw(NS_ERROR_FAILURE);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   nsAutoCString origin;
   rv = principal->GetOriginNoSuffix(origin);
-  if (NS_SUCCEEDED(rv)) {
+  if (!rv.Failed()) {
     CopyUTF8toUTF16(origin, init.mOrigin);
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // Shutting down. Just don't deliver this message.
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
     const IPCServiceWorkerDescriptor& swd = endpoint.get_IPCServiceWorkerDescriptor();
     RefPtr<ServiceWorkerRegistrationInfo> reg =
       swm->GetRegistration(principal, swd.scope());
     if (reg) {
@@ -536,33 +542,30 @@ ClientSource::PostMessage(const ClientPo
   // Eventually we should expose Client in MessageEvent.source.
 
   RefPtr<MessageEvent> event =
     MessageEvent::Constructor(target, NS_LITERAL_STRING("message"), init);
   event->SetTrusted(true);
 
   bool status = false;
   target->DispatchEvent(static_cast<dom::Event*>(event.get()), &status);
-  if (!status) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
-    return ref.forget();
-  }
+  // Ignore dispatch status and just resolve ok no matter what.
 
-  ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+  ref = ClientOpPromise::CreateAndResolve(rv, __func__);
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::GetState(const ClientGetStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
   ClientState state;
-  nsresult rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  CopyableErrorResult rv(SnapshotState(&state));
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(state.ToIPC(), __func__);
   return ref.forget();
 }
 
@@ -581,43 +584,43 @@ ClientSource::Claim(const ClientClaimArg
   // it will eventually hold ClientHandle objects instead of
   // nsIDocuments.
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   nsPIDOMWindowInner* innerWindow = GetInnerWindow();
   nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
   if (!swm || !doc) {
     SetController(swd);
 
-    ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
+    ref = ClientOpPromise::CreateAndResolve(CopyableErrorResult(), __func__);
     return ref.forget();
   }
 
   RefPtr<ClientOpPromise::Private> outerPromise =
     new ClientOpPromise::Private(__func__);
 
   RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
   p->Then(innerWindow->EventTargetFor(TaskCategory::Other), __func__,
     [outerPromise] (bool aResult) {
-      outerPromise->Resolve(NS_OK, __func__);
-    }, [outerPromise] (nsresult aResult) {
+      outerPromise->Resolve(CopyableErrorResult(), __func__);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise;
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
   ClientState state;
-  nsresult rv = SnapshotState(&state);
-  if (NS_FAILED(rv)) {
+  CopyableErrorResult rv(SnapshotState(&state));
+  if (rv.Failed()) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(ClientInfoAndState(mClientInfo.ToIPC(),
                                                              state.ToIPC()), __func__);
   return ref.forget();
 }
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceOpChild.h"
 
 #include "ClientSource.h"
 #include "ClientSourceChild.h"
+#include "mozilla/ErrorResult.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 ClientSource*
 ClientSourceOpChild::GetSource() const
 {
@@ -27,17 +28,19 @@ ClientSourceOpChild::DoSourceOp(Method a
   RefPtr<ClientOpPromise> promise;
   nsCOMPtr<nsISerialEventTarget> target;
 
   // Limit the scope of the source variable since running the operation
   // can cause the ClientSource object to be destroyed.
   {
     ClientSource* source = GetSource();
     if (!source) {
-      Unused << PClientSourceOpChild::Send__delete__(this, NS_ERROR_ABORT);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      Unused << PClientSourceOpChild::Send__delete__(this, rv);
       return;
     }
 
     target = source->EventTargetFor(TaskCategory::Other);
 
     // This may cause the ClientSource object to be destroyed.  Do not
     // use the source variable after this call.
     promise = (source->*aMethod)(aArgs);
@@ -45,17 +48,17 @@ ClientSourceOpChild::DoSourceOp(Method a
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   promise->Then(target, __func__,
     [this, aArgs] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const mozilla::CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientSourceOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
diff --git a/dom/clients/manager/ClientSourceOpParent.cpp b/dom/clients/manager/ClientSourceOpParent.cpp
--- a/dom/clients/manager/ClientSourceOpParent.cpp
+++ b/dom/clients/manager/ClientSourceOpParent.cpp
@@ -18,19 +18,19 @@ ClientSourceOpParent::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientSourceOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
