# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  45545f4df5ef271ae7be05f5c2f9b613a7aba33e

diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -633,16 +633,17 @@ InterceptedChannelContent::StartSynthesi
                                               mSynthesizedInput,
                                               mStreamListener);
 
     if (!aBody) {
       if (aBodyCompletionCallback) {
         aBodyCompletionCallback->Run();
       }
     } else {
+      NS_ENSURE_TRUE(mResponseBody, NS_ERROR_FAILURE);
       nsresult rv = StreamCopyStart(mResponseBody, aBody,
                                     aBodyCompletionCallback,
                                     aBodyFailedCallback);
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
 
   return NS_OK;
diff --git a/netwerk/test/unit/test_synthesized_response.js b/netwerk/test/unit/test_synthesized_response.js
--- a/netwerk/test/unit/test_synthesized_response.js
+++ b/netwerk/test/unit/test_synthesized_response.js
@@ -49,20 +49,18 @@ function make_channel(url, body, cb) {
     },
     channelIntercepted: function(channel) {
       channel.QueryInterface(Ci.nsIInterceptedChannel);
       if (body) {
         var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                             .createInstance(Ci.nsIStringInputStream);
         synthesized.data = body;
 
-        NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
-          channel.startSynthesizedResponse(null, null, null, '');
-          channel.finishSynthesizedResponse();
-        });
+        let runnable = { run: channel.finishSynthesizedResponse };
+        channel.startSynthesizedResponse(synthesized, runnable, null, '');
       }
       if (cb) {
         cb(channel);
       }
       return {
         dispatch: function() { }
       };
     },
@@ -139,21 +137,19 @@ add_test(function() {
 
 // ensure that the channel waits for a decision and synthesizes headers correctly
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(channel) {
     do_timeout(100, function() {
       var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                           .createInstance(Ci.nsIStringInputStream);
       synthesized.data = NON_REMOTE_BODY;
-      NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
-        channel.synthesizeHeader("Content-Length", NON_REMOTE_BODY.length);
-        channel.startSynthesizedResponse(null, null, null, '');
-        channel.finishSynthesizedResponse();
-      });
+      let runnable = { run: channel.finishSynthesizedResponse };
+      channel.synthesizeHeader("Content-Length", NON_REMOTE_BODY.length);
+      channel.startSynthesizedResponse(synthesized, runnable, null, '');
     });
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null));
 });
 
 // ensure that the channel waits for a decision
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(chan) {
@@ -166,23 +162,21 @@ add_test(function() {
 
 // ensure that the intercepted channel supports suspend/resume
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
-    NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
-      // set the content-type to ensure that the stream converter doesn't hold up notifications
-      // and cause the test to fail
-      intercepted.synthesizeHeader("Content-Type", "text/plain");
-      intercepted.startSynthesizedResponse(null, null, null, '');
-      intercepted.finishSynthesizedResponse();
-    });
+    // set the content-type to ensure that the stream converter doesn't hold up notifications
+    // and cause the test to fail
+    intercepted.synthesizeHeader("Content-Type", "text/plain");
+    let runnable = { run: channel.finishSynthesizedResponse };
+    intercepted.startSynthesizedResponse(synthesized, runnable, null, '');
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null,
 				     CL_ALLOW_UNKNOWN_CL | CL_SUSPEND | CL_EXPECT_3S_DELAY));
 });
 
 // ensure that the intercepted channel can be cancelled
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
@@ -210,39 +204,39 @@ add_test(function() {
 
 // ensure that the intercepted channel can be canceled during the response
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
-    NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
-      let channel = intercepted.channel;
-      intercepted.startSynthesizedResponse(null, null, null, '');
-      intercepted.finishSynthesizedResponse();
-      channel.cancel(Cr.NS_BINDING_ABORTED);
-    });
+    let runnable = {
+      run: function() {
+        channel.finishSynthesizedResponse();
+        channel.cancel(Cr.NS_BINDING_ABORTED);
+      }
+    };
+    let channel = intercepted.channel;
+    intercepted.startSynthesizedResponse(synthesized, runnable, null, '');
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
 // ensure that the intercepted channel can be canceled before the response
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
-    NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
-      intercepted.channel.cancel(Cr.NS_BINDING_ABORTED);
-      intercepted.startSynthesizedResponse(null, null, null, '');
-      intercepted.finishSynthesizedResponse();
-    });
+    intercepted.channel.cancel(Cr.NS_BINDING_ABORTED);
+    let runnable = { run: channel.finishSynthesizedResponse };
+    intercepted.startSynthesizedResponse(synthesized, runnable, null, '');
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
 add_test(function() {
   httpServer.stop(run_next_test);
 });
