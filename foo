# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  db7c864a3daa15758fb56609b0a2ce28a690fa42

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -216,32 +216,33 @@ Client::Navigate(const nsAString& aURL, 
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       baseURL = workerPrivate->GetLocationInfo().mHref;
     }
   }
 
-  EnsureHandle();
-
   RefPtr<Client> self = this;
 
-  RefPtr<ClientHandle::NavigatePromise> innerPromise =
-    mHandle->Navigate(NS_ConvertUTF16toUTF8(aURL), baseURL);
+  ClientNavigateArgs args(mData.info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+
+  RefPtr<ClientOpPromise> innerPromise = ClientManager::Navigate(args);
 
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
-    [self, outerPromise] (const Maybe<ClientInfoAndState>& aResult) {
-      if (aResult.isNothing()) {
+    [self, outerPromise] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolveWithUndefined();
         return;
       }
-      RefPtr<Client> newClient = new Client(self->mGlobal, aResult.ref());
+      RefPtr<Client> newClient =
+        new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
     }, [self, outerPromise] (nsresult aResult) {
+      // TODO: convert to a type error
       outerPromise->MaybeReject(aResult);
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/api/Clients.h b/dom/clients/api/Clients.h
--- a/dom/clients/api/Clients.h
+++ b/dom/clients/api/Clients.h
@@ -14,17 +14,17 @@ class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
 class ClientEndPoint;
-class ClientQueryOptions;
+struct ClientQueryOptions;
 class Promise;
 
 class Clients final : public nsISupports
                     , public nsWrapperCache
 {
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
   ~Clients();
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -137,42 +137,16 @@ ClientHandle::Focus()
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
   RefPtr<ClientStatePromise> ref = outerPromise.get();
   return ref.forget();
 }
 
-already_AddRefed<ClientHandle::NavigatePromise>
-ClientHandle::Navigate(const nsACString& aURL, const nsACString& aBaseURL)
-{
-  RefPtr<NavigatePromise::Private> outerPromise =
-    new NavigatePromise::Private(__func__);
-
-  RefPtr<ClientOpPromise> innerPromise =
-    StartOp(ClientNavigateArgs(nsCString(aURL), nsCString(aBaseURL)));
-
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
-    [outerPromise](const ClientOpResult& aResult) {
-      Maybe<ClientInfoAndState> infoAndState;
-      if (aResult.type() == ClientOpResult::TClientInfoAndState) {
-        infoAndState.emplace(aResult.get_ClientInfoAndState());
-      } else {
-        MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(aResult.get_nsresult()));
-      }
-      outerPromise->Resolve(infoAndState, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
-    });
-
-  RefPtr<NavigatePromise> ref = outerPromise.get();
-  return ref.forget();
-}
-
 already_AddRefed<GenericPromise>
 ClientHandle::PostMessage(StructuredCloneData& aData,
                           const ClientEndPoint& aEndPoint)
 {
   RefPtr<GenericPromise> ref;
 
   ClientPostMessageArgs args;
   args.endpoint() = aEndPoint;
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -57,21 +57,16 @@ public:
   Info() const;
 
   already_AddRefed<GenericPromise>
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   already_AddRefed<ClientStatePromise>
   Focus();
 
-  typedef MozPromise<Maybe<ClientInfoAndState>, nsresult, false> NavigatePromise;
-
-  already_AddRefed<NavigatePromise>
-  Navigate(const nsACString& aURL, const nsACString& aBaseURL);
-
   already_AddRefed<GenericPromise>
   PostMessage(ipc::StructuredCloneData& aData,
               const ClientEndPoint& aEndPoint);
 
   NS_INLINE_DECL_REFCOUNTING(ClientHandle);
 };
 
 } // namespace dom
diff --git a/dom/clients/manager/ClientHandleChild.h b/dom/clients/manager/ClientHandleChild.h
--- a/dom/clients/manager/ClientHandleChild.h
+++ b/dom/clients/manager/ClientHandleChild.h
@@ -17,17 +17,17 @@ template <typename ActorType> class Clie
 
 class ClientHandleChild final : public PClientHandleChild
 {
   ClientHandle* mHandle;
   bool mTeardownStarted;
 
   // PClientHandleChild interface
   mozilla::ipc::IPCResult
-  RecvExecutionReady(const ClientInfo& aClientInfo);
+  RecvExecutionReady(const ClientInfo& aClientInfo) override;
 
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   PClientHandleOpChild*
   AllocPClientHandleOpChild(const ClientOpConstructorArgs& aArgs) override;
 
   bool
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -1,12 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include ServiceWorkerDescriptor;
 using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 using struct nsID from "nsID.h";
@@ -67,16 +68,17 @@ struct ClientControlledArgs
 };
 
 struct ClientFocusArgs
 {
 };
 
 struct ClientNavigateArgs
 {
+  ClientInfo target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientEndPoint
 {
   ClientInfo;
   ServiceWorkerDescriptor;
@@ -123,16 +125,23 @@ union ClientOpConstructorArgs
   ClientGetInfoAndStateArgs;
 };
 
 struct ClientList
 {
   ClientInfoAndState[] values;
 };
 
+struct ClientNavigateOpConstructorArgs
+{
+  PClientSource target;
+  nsCString url;
+  nsCString baseURL;
+};
+
 union ClientOpResult
 {
   nsresult;
   ClientState;
   ClientInfoAndState;
   ClientList;
 };
 
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -356,10 +356,18 @@ ClientManager::Claim(const ClientClaimAr
 // static
 already_AddRefed<ClientOpPromise>
 ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->StartOp(aArgs);
 }
 
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -90,15 +90,18 @@ public:
   MatchAll(const ClientMatchAllArgs& aArgs);
 
   static already_AddRefed<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
   static already_AddRefed<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
+  static already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
--- a/dom/clients/manager/ClientManagerChild.cpp
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerChild.h"
 
 #include "ClientHandleChild.h"
 #include "ClientManager.h"
 #include "ClientManagerOpChild.h"
+#include "ClientNavigateOpChild.h"
 #include "ClientSourceChild.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::workers::WorkerHolderToken;
 using mozilla::dom::workers::WorkerPrivate;
 
@@ -54,16 +55,38 @@ ClientManagerChild::AllocPClientManagerO
 
 bool
 ClientManagerChild::DeallocPClientManagerOpChild(PClientManagerOpChild* aActor)
 {
   delete aActor;
   return true;
 }
 
+PClientNavigateOpChild*
+ClientManagerChild::AllocPClientNavigateOpChild(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  return new ClientNavigateOpChild();
+}
+
+bool
+ClientManagerChild::DeallocPClientNavigateOpChild(PClientNavigateOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+mozilla::ipc::IPCResult
+ClientManagerChild::RecvPClientNavigateOpConstructor(PClientNavigateOpChild* aActor,
+                                   const ClientNavigateOpConstructorArgs& aArgs)
+{
+  auto actor = static_cast<ClientNavigateOpChild*>(aActor);
+  actor->Init(aArgs);
+  return IPC_OK();
+}
+
 PClientSourceChild*
 ClientManagerChild::AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs)
 {
   return new ClientSourceChild(aArgs);
 }
 
 bool
 ClientManagerChild::DeallocPClientSourceChild(PClientSourceChild* aActor)
diff --git a/dom/clients/manager/ClientManagerChild.h b/dom/clients/manager/ClientManagerChild.h
--- a/dom/clients/manager/ClientManagerChild.h
+++ b/dom/clients/manager/ClientManagerChild.h
@@ -37,16 +37,26 @@ class ClientManagerChild final : public 
   DeallocPClientHandleChild(PClientHandleChild* aActor) override;
 
   PClientManagerOpChild*
   AllocPClientManagerOpChild(const ClientOpConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientManagerOpChild(PClientManagerOpChild* aActor) override;
 
+  PClientNavigateOpChild*
+  AllocPClientNavigateOpChild(const ClientNavigateOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientNavigateOpChild(PClientNavigateOpChild* aActor) override;
+
+  mozilla::ipc::IPCResult
+  RecvPClientNavigateOpConstructor(PClientNavigateOpChild* aActor,
+                                   const ClientNavigateOpConstructorArgs& aArgs) override;
+
   PClientSourceChild*
   AllocPClientSourceChild(const ClientSourceConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientSourceChild(PClientSourceChild* aActor) override;
 
   // WorkerHolderToken::Listener interface
   void
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -41,16 +41,22 @@ ClientManagerOpParent::ClientManagerOpPa
 {
   MOZ_DIAGNOSTIC_ASSERT(mService);
 }
 
 void
 ClientManagerOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientNavigateArgs:
+    {
+      DoServiceOp(&ClientManagerService::Navigate,
+                  aArgs.get_ClientNavigateArgs());
+      break;
+    }
     case ClientOpConstructorArgs::TClientMatchAllArgs:
     {
       DoServiceOp(&ClientManagerService::MatchAll,
                   aArgs.get_ClientMatchAllArgs());
       break;
     }
     case ClientOpConstructorArgs::TClientClaimArgs:
     {
diff --git a/dom/clients/manager/ClientManagerParent.cpp b/dom/clients/manager/ClientManagerParent.cpp
--- a/dom/clients/manager/ClientManagerParent.cpp
+++ b/dom/clients/manager/ClientManagerParent.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerParent.h"
 
 #include "ClientHandleParent.h"
 #include "ClientManagerService.h"
 #include "ClientManagerOpParent.h"
 #include "ClientSourceParent.h"
+#include "mozilla/dom/PClientNavigateOpParent.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 IPCResult
@@ -68,16 +69,30 @@ IPCResult
 ClientManagerParent::RecvPClientManagerOpConstructor(PClientManagerOpParent* aActor,
                                                      const ClientOpConstructorArgs& aArgs)
 {
   ClientManagerOpParent* actor = static_cast<ClientManagerOpParent*>(aActor);
   actor->Init(aArgs);
   return IPC_OK();
 }
 
+PClientNavigateOpParent*
+ClientManagerParent::AllocPClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  MOZ_ASSERT_UNREACHABLE("ClientNavigateOpParent should be explicitly constructed.");
+  return nullptr;
+}
+
+bool
+ClientManagerParent::DeallocPClientNavigateOpParent(PClientNavigateOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PClientSourceParent*
 ClientManagerParent::AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs)
 {
   return new ClientSourceParent(aArgs);
 }
 
 bool
 ClientManagerParent::DeallocPClientSourceParent(PClientSourceParent* aActor)
diff --git a/dom/clients/manager/ClientManagerParent.h b/dom/clients/manager/ClientManagerParent.h
--- a/dom/clients/manager/ClientManagerParent.h
+++ b/dom/clients/manager/ClientManagerParent.h
@@ -39,16 +39,22 @@ class ClientManagerParent final : public
 
   bool
   DeallocPClientManagerOpParent(PClientManagerOpParent* aActor) override;
 
   mozilla::ipc::IPCResult
   RecvPClientManagerOpConstructor(PClientManagerOpParent* aActor,
                                  const ClientOpConstructorArgs& aArgs) override;
 
+  PClientNavigateOpParent*
+  AllocPClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs) override;
+
+  bool
+  DeallocPClientNavigateOpParent(PClientNavigateOpParent* aActor) override;
+
   PClientSourceParent*
   AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientSourceParent(PClientSourceParent* aActor) override;
 
 public:
   ClientManagerParent();
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerService.h"
 
+#include "ClientNavigateOpParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "nsURLParsers.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 using mozilla::ipc::ContentPrincipalInfo;
@@ -154,16 +155,58 @@ ClientManagerService::FindSource(const n
         source->Info().id() == aID &&
         MatchPrincipalInfo(source->Info().principalInfo(), aPrincipalInfo)) {
       return source;
     }
   }
   return nullptr;
 }
 
+already_AddRefed<ClientOpPromise>
+ClientManagerService::Navigate(const ClientNavigateArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceParent* source = FindSource(aArgs.target().id(),
+                                          aArgs.target().principalInfo());
+  if (!source) {
+    // TODO: it would be really nice to specify a useful type error message here
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  PClientManagerParent* manager = source->Manager();
+  MOZ_DIAGNOSTIC_ASSERT(manager);
+
+  ClientNavigateOpConstructorArgs args;
+  args.url() = aArgs.url();
+  args.baseURL() = aArgs.baseURL();
+
+  // This is safe to do because the ClientSourceChild cannot directly delete
+  // itself.  Instead it sends a Teardown message to the parent which then
+  // calls delete.  That means we can be sure that we are not racing with
+  // source destruction here.
+  args.targetParent() = source;
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  ClientNavigateOpParent* op = new ClientNavigateOpParent(args, promise);
+  PClientNavigateOpParent* result =
+    manager->SendPClientNavigateOpConstructor(op, args);
+  if (!result) {
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise;
+  return ref.forget();
+}
+
 namespace
 {
 
 class PromiseListHolder final
 {
   RefPtr<AbstractThread> mTarget;
   RefPtr<ClientOpPromise::Private> mResultPromise;
   nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -44,16 +44,19 @@ public:
   void
   RemoveSource(ClientSourceParent* aSource);
 
   ClientSourceParent*
   FindSource(const nsID& aID,
              const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
   already_AddRefed<ClientOpPromise>
+  Navigate(const ClientNavigateArgs& aArgs);
+
+  already_AddRefed<ClientOpPromise>
   MatchAll(const ClientMatchAllArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -0,0 +1,272 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientNavigateOpChild.h"
+
+#include "mozilla/Unused.h"
+#include "nsGlobalWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDocShellLoadInfo.h"
+#include "nsIWebNavigation.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class NavigateLoadListener final : public nsIWebProgressListener
+                                 , public nsSupportsWeakReference
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  RefPtr<nsPIDOMWindowOuter> mOuterWindow;
+  nsCOMPtr<nsIURI> mBaseURL;
+
+  ~NavigateLoadListener() = default;
+
+public:
+  NavigateLoadListener(ClientOpPromise::Private* aPromise,
+                       nsPIDOMWindowOuter* aOuterWindow,
+                       nsIURI* aBaseURL)
+    : mPromise(aPromise)
+    , mOuterWindow(aOuterWindow)
+    , mBaseURL(aBaseURL)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mOuterWindow);
+    MOZ_DIAGNOSTIC_ASSERT(mBaseURL);
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aResult) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+        !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
+    if (!channel) {
+      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIURI> channelURL;
+    nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
+    if (NS_FAILED(rv)) {
+      mPromise->Reject(rv, __func__);
+      return NS_OK;
+    }
+
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    MOZ_DIAGNOSTIC_ASSERT(ssm);
+    rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      return NS_OK;
+    }
+
+    // TODO: legacy code only did this for same-origin, was that intentional
+    Unused << nsContentUtils::DispatchFocusChromeEvent(mOuterWindow);
+
+    // TODO: Not clear this progress listener guarantees following assertions...
+
+    nsPIDOMWindowInner* innerWindow = mOuterWindow->GetCurrentInnerWindow();
+    MOZ_DIAGNOSTIC_ASSERT(innerWindow);
+
+    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
+    MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
+
+    Maybe<ClientState> clientState = innerWindow->GetClientState();
+    MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
+
+    mPromise->Resolve(ClientInfoAndState(clientInfo.ref(), clientState.ref()),
+                      __func__);
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   nsIURI* aLocation, uint32_t aFlags) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_CRASH("Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(NavigateLoadListener, nsIWebProgressListener,
+                                        nsISupportsWeakReference);
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientNavigateOpChild::DoNavigate(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  ClientSourceChild* targetActor =
+    static_cast<ClientSourceChild*>(aArgs.targetChild());
+  MOZ_DIAGNOSTIC_ASSERT(targetActor);
+
+  ClientSource* target = targetActor->GetSource();
+  if (!target) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  nsPIDOMWindowInner* window = target->GetInnerWindow();
+  if (!window) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // In theory we could do the URL work before paying the IPC overhead
+  // cost, but in practice its easier to do it here.  The ClientHandle
+  // may be off-main-thread while this method is guaranteed to always
+  // be main thread.
+  nsCOMPtr<nsIURI> baseURL;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIURI> url;
+  rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  // TODO: We should be able to just keep this from client creation
+  /* TODO
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(mClientInfo.principalInfo(), &rv);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  rv = principal->CheckMayLoad(url, true, false);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+  */
+
+  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+  if (!doc || !doc->IsActive()) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+  if (!docShell || !webProgress) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
+  rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  // TODO
+  //loadInfo->SetTriggeringPrincipal(principal);
+  loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
+  loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContentAndReplace);
+  loadInfo->SetSourceDocShell(docShell);
+  rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
+  if (NS_FAILED(rv)) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  nsCOMPtr<nsIWebProgressListener> listener =
+    new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_FAILED(rv)) {
+    promise->Reject(rv, __func__);
+    ref = promise;
+    return ref.forget();
+  }
+
+  ref = promise.get();
+
+  ref->Then(AbstractThread::GetCurrent(), __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+
+  return ref.forget();
+}
+
+void
+ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+void
+ClientNavigateOpChild::Init(const ClientNavigateOpConstructorArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> promise = DoNavigate(aArgs);
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientNavigateOpChild::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpChild.h b/dom/clients/manager/ClientNavigateOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpChild.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientNavigateOpChild_h
+#define _mozilla_dom_ClientNavigateOpChild_h
+
+#include "mozilla/dom/PClientNavigateOpChild.h"
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+
+class ClientNavigateOpChild final : public PClientNavigateOpChild
+{
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  already_AddRefed<ClientOpPromise>
+  DoNavigate(const ClientNavigateOpConstructorArgs& aArgs);
+
+  // PClientNavigateOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  ClientNavigateOpChild() = default;
+  ~ClientNavigateOpChild() = default;
+
+  void
+  Init(const ClientNavigateOpConstructorArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientNavigateOpChild_h
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientNavigateOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+void
+ClientNavigateOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientNavigateOpParent::ClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs,
+                                               ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientNavigateOpParent::~ClientNavigateOpParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpParent.h b/dom/clients/manager/ClientNavigateOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientNavigateOpParent.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientNavigateOpParent_h
+#define _mozilla_dom_ClientNavigateOpParent_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientNavigateOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientNavigateOpParent final : public PClientNavigateOpParent
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientNavigateOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientNavigateOpParent(const ClientNavigateOpConstructorArgs& aArgs,
+                         ClientOpPromise::Private* aPromise);
+
+  ~ClientNavigateOpParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientNavigateOpParent_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -11,53 +11,26 @@
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/dom/ServiceWorkerContainer.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
-#include "nsGlobalWindow.h"
-#include "nsIDocShell.h"
-#include "nsIDocShellLoadInfo.h"
-#include "nsIWebNavigation.h"
-#include "nsIWebProgress.h"
-#include "nsIWebProgressListener.h"
-#include "nsNetUtil.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
 using mozilla::dom::workers::ServiceWorkerInfo;
 using mozilla::dom::workers::ServiceWorkerManager;
 using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
 using mozilla::dom::workers::WorkerPrivate;
 
-nsPIDOMWindowInner*
-ClientSource::GetInnerWindow() const
-{
-  NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
-    return nullptr;
-  }
-  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
-}
-
-WorkerPrivate*
-ClientSource::GetWorkerPrivate() const
-{
-  NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (!mOwner.is<WorkerPrivate*>()) {
-    return nullptr;
-  }
-  return mOwner.as<WorkerPrivate*>();
-}
-
 void
 ClientSource::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   if (IsShutdown()) {
     return;
   }
 
@@ -141,16 +114,36 @@ ClientSource::Activate(PClientManagerChi
   MaybeExecuteTaskList();
 }
 
 ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
+nsPIDOMWindowInner*
+ClientSource::GetInnerWindow() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
+    return nullptr;
+  }
+  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
+}
+
+WorkerPrivate*
+ClientSource::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<WorkerPrivate*>()) {
+    return nullptr;
+  }
+  return mOwner.as<WorkerPrivate*>();
+}
+
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   // Its safe to store the WorkerPrivate* here because the ClientSource
   // is explicitly destroyed by WorkerPrivate before exiting its run loop.
@@ -331,240 +324,16 @@ ClientSource::Focus(const ClientFocusArg
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ref = ClientOpPromise::CreateAndResolve(state, __func__);
   return ref.forget();
 }
 
-namespace {
-
-class NavigateLoadListener final : public nsIWebProgressListener
-                                 , public nsSupportsWeakReference
-{
-  RefPtr<ClientOpPromise::Private> mPromise;
-  RefPtr<nsPIDOMWindowOuter> mOuterWindow;
-  nsCOMPtr<nsIURI> mBaseURL;
-
-  ~NavigateLoadListener() = default;
-
-public:
-  NavigateLoadListener(ClientOpPromise::Private* aPromise,
-                       nsPIDOMWindowOuter* aOuterWindow,
-                       nsIURI* aBaseURL)
-    : mPromise(aPromise)
-    , mOuterWindow(aOuterWindow)
-    , mBaseURL(aBaseURL)
-  {
-    MOZ_DIAGNOSTIC_ASSERT(mPromise);
-    MOZ_DIAGNOSTIC_ASSERT(mOuterWindow);
-    MOZ_DIAGNOSTIC_ASSERT(mBaseURL);
-  }
-
-  NS_IMETHOD
-  OnStateChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
-                uint32_t aStateFlags, nsresult aResult) override
-  {
-    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
-        !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
-      return NS_OK;
-    }
-
-    aWebProgress->RemoveProgressListener(this);
-
-    nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
-    if (!channel) {
-      mPromise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-      return NS_OK;
-    }
-
-    nsCOMPtr<nsIURI> channelURL;
-    nsresult rv = NS_GetFinalChannelURI(channel, getter_AddRefs(channelURL));
-    if (NS_FAILED(rv)) {
-      mPromise->Reject(rv, __func__);
-      return NS_OK;
-    }
-
-    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
-    MOZ_DIAGNOSTIC_ASSERT(ssm);
-    rv = ssm->CheckSameOriginURI(mBaseURL, channelURL, false);
-    if (NS_FAILED(rv)) {
-      mPromise->Resolve(NS_OK, __func__);
-      return NS_OK;
-    }
-
-    // TODO: legacy code only did this for same-origin, was that intentional
-    Unused << nsContentUtils::DispatchFocusChromeEvent(mOuterWindow);
-
-    // TODO: Not clear this progress listener guarantees following assertions...
-
-    nsPIDOMWindowInner* innerWindow = mOuterWindow->GetCurrentInnerWindow();
-    MOZ_DIAGNOSTIC_ASSERT(innerWindow);
-
-    Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
-    MOZ_DIAGNOSTIC_ASSERT(clientInfo.isSome());
-
-    Maybe<ClientState> clientState = innerWindow->GetClientState();
-    MOZ_DIAGNOSTIC_ASSERT(clientState.isSome());
-
-    mPromise->Resolve(ClientInfoAndState(clientInfo.ref(), clientState.ref()),
-                      __func__);
-
-    return NS_OK;
-  }
-
-  NS_IMETHOD
-  OnProgressChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
-                   int32_t aCurSelfProgress, int32_t aMaxSelfProgress,
-                   int32_t aCurTotalProgress, int32_t aMaxTotalProgress) override
-  {
-    MOZ_CRASH("Unexpected notification.");
-    return NS_OK;
-  }
-
-  NS_IMETHOD
-  OnLocationChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
-                   nsIURI* aLocation, uint32_t aFlags) override
-  {
-    MOZ_CRASH("Unexpected notification.");
-    return NS_OK;
-  }
-
-  NS_IMETHOD
-  OnStatusChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
-                 nsresult aStatus, const char16_t* aMessage) override
-  {
-    MOZ_CRASH("Unexpected notification.");
-    return NS_OK;
-  }
-
-  NS_IMETHOD
-  OnSecurityChange(nsIWebProgress* aWebProgress, nsIRequest* aRequest,
-                   uint32_t aState) override
-  {
-    MOZ_CRASH("Unexpected notification.");
-    return NS_OK;
-  }
-
-  NS_DECL_ISUPPORTS
-};
-
-NS_IMPL_ISUPPORTS(NavigateLoadListener, nsIWebProgressListener,
-                                        nsISupportsWeakReference);
-
-} // anonymous namespace
-
-already_AddRefed<ClientOpPromise>
-ClientSource::Navigate(const ClientNavigateArgs& aArgs)
-{
-  NS_ASSERT_OWNINGTHREAD(ClientSource);
-
-  RefPtr<ClientOpPromise> ref;
-
-  if (mArgs.type() != ClientType::Window) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
-                                           __func__);
-    return ref.forget();
-  }
-
-  MOZ_ASSERT(NS_IsMainThread());
-
-  nsPIDOMWindowInner* window = GetInnerWindow();
-  if (!window) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
-    return ref.forget();
-  }
-
-  // In theory we could do the URL work before paying the IPC overhead
-  // cost, but in practice its easier to do it here.  The ClientHandle
-  // may be off-main-thread while this method is guaranteed to always
-  // be main thread.
-  nsCOMPtr<nsIURI> baseURL;
-  nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  nsCOMPtr<nsIURI> url;
-  rv = NS_NewURI(getter_AddRefs(url), aArgs.url(), nullptr, baseURL);
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  // TODO: We should be able to just keep this from client creation
-  nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(mClientInfo.principalInfo(), &rv);
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  rv = principal->CheckMayLoad(url, true, false);
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
-  if (!doc || !doc->IsActive()) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    return ref.forget();
-  }
-
-  nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
-  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
-  if (!docShell || !webProgress) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    return ref.forget();
-  }
-
-  nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
-  rv = docShell->CreateLoadInfo(getter_AddRefs(loadInfo));
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  loadInfo->SetTriggeringPrincipal(principal);
-  loadInfo->SetReferrerPolicy(doc->GetReferrerPolicy());
-  loadInfo->SetLoadType(nsIDocShellLoadInfo::loadStopContentAndReplace);
-  loadInfo->SetSourceDocShell(docShell);
-  rv = docShell->LoadURI(url, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, true);
-  if (NS_FAILED(rv)) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  RefPtr<ClientOpPromise::Private> promise =
-    new ClientOpPromise::Private(__func__);
-
-  nsCOMPtr<nsIWebProgressListener> listener =
-    new NavigateLoadListener(promise, window->GetOuterWindow(), baseURL);
-
-  rv = webProgress->AddProgressListener(listener,
-                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  if (NS_FAILED(rv)) {
-    promise->Reject(rv, __func__);
-    ref = promise;
-    return ref.forget();
-  }
-
-  ref = promise.get();
-
-  ref->Then(AbstractThread::GetCurrent(), __func__,
-    [listener] (const ClientOpResult& aResult) { },
-    [listener] (nsresult aResult) { });
-
-  return ref.forget();
-}
-
 already_AddRefed<ClientOpPromise>
 ClientSource::PostMessage(const ClientPostMessageArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -38,22 +38,16 @@ class ClientSource final : public Client
   Variant<void_t,
           RefPtr<nsPIDOMWindowInner>,
           mozilla::dom::workers::WorkerPrivate*> mOwner;
 
   const ClientSourceConstructorArgs mArgs;
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
-  nsPIDOMWindowInner*
-  GetInnerWindow() const;
-
-  mozilla::dom::workers::WorkerPrivate*
-  GetWorkerPrivate() const;
-
   void
   Shutdown();
 
   void
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
 
   nsresult
   SnapshotWindowState(ClientWindowState* aStateOut);
@@ -63,16 +57,22 @@ class ClientSource final : public Client
                const ClientSourceConstructorArgs& aArgs);
 
   void
   Activate(PClientManagerChild* aActor);
 
 public:
   ~ClientSource();
 
+  nsPIDOMWindowInner*
+  GetInnerWindow() const;
+
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+
   void
   WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
 
   nsresult
   WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
 
   void
   Freeze();
@@ -94,19 +94,16 @@ public:
 
   const Maybe<ServiceWorkerDescriptor>&
   GetController() const;
 
   already_AddRefed<ClientOpPromise>
   Focus(const ClientFocusArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
-  Navigate(const ClientNavigateArgs& aArgs);
-
-  already_AddRefed<ClientOpPromise>
   PostMessage(const ClientPostMessageArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   GetState(const ClientGetStateArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -66,21 +66,16 @@ ClientSourceOpChild::Init(const ClientOp
       DoSourceOp(&ClientSource::Control, aArgs.get_ClientControlledArgs());
       break;
     }
     case ClientOpConstructorArgs::TClientFocusArgs:
     {
       DoSourceOp(&ClientSource::Focus, aArgs.get_ClientFocusArgs());
       break;
     }
-    case ClientOpConstructorArgs::TClientNavigateArgs:
-    {
-      DoSourceOp(&ClientSource::Navigate, aArgs.get_ClientNavigateArgs());
-      break;
-    }
     case ClientOpConstructorArgs::TClientPostMessageArgs:
     {
       DoSourceOp(&ClientSource::PostMessage, aArgs.get_ClientPostMessageArgs());
       break;
     }
     case ClientOpConstructorArgs::TClientGetStateArgs:
     {
       DoSourceOp(&ClientSource::GetState, aArgs.get_ClientGetStateArgs());
diff --git a/dom/clients/manager/PClientManager.ipdl b/dom/clients/manager/PClientManager.ipdl
--- a/dom/clients/manager/PClientManager.ipdl
+++ b/dom/clients/manager/PClientManager.ipdl
@@ -1,34 +1,38 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PClientHandle;
 include protocol PClientManagerOp;
+include protocol PClientNavigateOp;
 include protocol PClientSource;
 include ClientIPCTypes;
 
 namespace mozilla {
 namespace dom {
 
 sync protocol PClientManager
 {
   manager PBackground;
 
   manages PClientHandle;
   manages PClientManagerOp;
+  manages PClientNavigateOp;
   manages PClientSource;
 
 parent:
   async Teardown();
 
   async PClientHandle(ClientInfo aClientInfo);
   async PClientManagerOp(ClientOpConstructorArgs aArgs);
   async PClientSource(ClientSourceConstructorArgs aArgs);
 
 child:
+  async PClientNavigateOp(ClientNavigateOpConstructorArgs aArgs);
+
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/PClientNavigateOp.ipdl b/dom/clients/manager/PClientNavigateOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientNavigateOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PClientManager;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientNavigateOp
+{
+  manager PClientManager;
+
+parent:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -23,30 +23,33 @@ UNIFIED_SOURCES += [
   'ClientHandleParent.cpp',
   'ClientManager.cpp',
   'ClientManagerActors.cpp',
   'ClientManagerChild.cpp',
   'ClientManagerOpChild.cpp',
   'ClientManagerOpParent.cpp',
   'ClientManagerParent.cpp',
   'ClientManagerService.cpp',
+  'ClientNavigateOpChild.cpp',
+  'ClientNavigateOpParent.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ReservedClientHelper.cpp',
 ]
 
 IPDL_SOURCES += [
   'ClientIPCTypes.ipdlh',
   'PClientHandle.ipdl',
   'PClientHandleOp.ipdl',
   'PClientManager.ipdl',
   'PClientManagerOp.ipdl',
+  'PClientNavigateOp.ipdl',
   'PClientSource.ipdl',
   'PClientSourceOp.ipdl',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
   '/dom/base',
