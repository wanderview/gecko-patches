# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1f589995c7f1354347938c57bc61505372a7514d

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -187,18 +187,18 @@ Client::Focus(ErrorResult& aRv)
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
   innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
         new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Client::Navigate(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -231,17 +231,17 @@ Client::Navigate(const nsAString& aURL, 
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> newClient =
         new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
-    }, [self, outerPromise] (nsresult aResult) {
+    }, [self, outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
--- a/dom/clients/api/ClientDOMUtil.h
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -38,17 +38,17 @@ StartClientManagerOp(Func aFunc, const A
 
   RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
   promise->Then(aTarget, __func__,
     [aResolve, token](const ClientOpResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aResolve(aResult);
-    }, [aReject, token](nsresult aResult) {
+    }, [aReject, token](const CopyableErrorResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aReject(aResult);
     });
 }
 
 } // namespace dom
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -91,17 +91,17 @@ Clients::Get(const nsAString& aClientID,
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
                                    target);
   innerPromise->Then(target, __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolve(
         new Client(global, aResult.get_ClientInfoAndState()));
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
     });
 
   return outerPromise.forget();
 }
 
 namespace {
 
@@ -166,18 +166,18 @@ Clients::MatchAll(const ClientQueryOptio
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise, global] (const ClientOpResult& aResult) {
       nsTArray<RefPtr<Client>> clientList;
       for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
         clientList.AppendElement(new Client(global, value));
       }
       clientList.Sort(MatchAllComparator());
       outerPromise->MaybeResolve(clientList);
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
 {
@@ -237,17 +237,17 @@ Clients::OpenWindow(const nsAString& aUR
     [outerPromise, global] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> client =
         new Client(global, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(client);
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       // TODO: get type error and message from site of error
       outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
@@ -278,17 +278,17 @@ Clients::Claim(ErrorResult& aRv)
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
     mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
-    }, [outerPromise] (nsresult aResult) {
-      outerPromise->MaybeReject(aResult);
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
+      outerPromise->MaybeReject(CopyableErrorResult(aResult));
     });
 
   return outerPromise.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -45,18 +45,18 @@ ClientHandle::StartOp(const ClientOpCons
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
   promise->Then(mSerialEventTarget, __func__,
-                [kungFuGrip] (const ClientOpResult &) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const ClientOpResult&) { },
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
@@ -117,18 +117,18 @@ ClientHandle::Control(const ServiceWorke
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
     StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   RefPtr<GenericPromise> ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<ClientStatePromise>
 ClientHandle::Focus()
@@ -136,18 +136,18 @@ ClientHandle::Focus()
   RefPtr<ClientStatePromise::Private> outerPromise =
     new ClientStatePromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
 
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   RefPtr<ClientStatePromise> ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<GenericPromise>
 ClientHandle::PostMessage(StructuredCloneData& aData,
@@ -171,18 +171,18 @@ ClientHandle::PostMessage(StructuredClon
 
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }, [outerPromise](const CopyableErrorResult& aResult) {
+      outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise.get();
   return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpChild.cpp b/dom/clients/manager/ClientHandleOpChild.cpp
--- a/dom/clients/manager/ClientHandleOpChild.cpp
+++ b/dom/clients/manager/ClientHandleOpChild.cpp
@@ -16,19 +16,19 @@ ClientHandleOpChild::ActorDestroy(ActorD
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientHandleOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -65,16 +65,16 @@ ClientHandleOpParent::Init(const ClientO
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
       [this] (const ClientOpResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
-      }, [this] (const ClientOpResult& aResult) {
+      }, [this] (const CopyableErrorResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -2,17 +2,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include IPCServiceWorkerDescriptor;
 include ProtocolTypes;
-using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
+using mozilla::CopyableErrorResult from "ipc/ErrorIPCUtils.h";
+using mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 struct ClientSourceConstructorArgs
@@ -142,16 +143,16 @@ struct ClientNavigateOpConstructorArgs
 {
   PClientSource target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientOpResult
 {
-  nsresult;
+  CopyableErrorResult;
   IPCClientState;
   ClientInfoAndState;
   ClientList;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -194,17 +194,17 @@ ClientManager::StartOp(const ClientOpCon
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientManager> kungFuGrip = this;
   promise->Then(aSerialEventTarget, __func__,
                 [kungFuGrip] (const ClientOpResult&) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip] (const CopyableErrorResult&) { });
 
   MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
     ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
     if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
diff --git a/dom/clients/manager/ClientManagerOpChild.cpp b/dom/clients/manager/ClientManagerOpChild.cpp
--- a/dom/clients/manager/ClientManagerOpChild.cpp
+++ b/dom/clients/manager/ClientManagerOpChild.cpp
@@ -16,19 +16,19 @@ ClientManagerOpChild::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientManagerOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -24,17 +24,17 @@ ClientManagerOpParent::DoServiceOp(Metho
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   p->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [this] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientManagerOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -242,17 +242,17 @@ public:
 
   already_AddRefed<ClientOpPromise>
   GetResultPromise()
   {
     RefPtr<PromiseListHolder> kungFuDeathGrip = this;
     mResultPromise->Then(
       GetCurrentThreadSerialEventTarget(), __func__,
       [kungFuDeathGrip] (const ClientOpResult& aResult) { },
-      [kungFuDeathGrip] (nsresult aResult) { });
+      [kungFuDeathGrip] (const CopyableErrorResult& aResult) { });
 
     RefPtr<ClientOpPromise> ref = mResultPromise;
     return ref.forget();
   }
 
   void
   AddPromise(already_AddRefed<ClientOpPromise> aPromise)
   {
@@ -267,17 +267,17 @@ public:
         // TODO: This is pretty clunky.  Try to figure out a better
         //       wait for MatchAll() and Claim() to share this code
         //       even though they expect different return values.
         if (aResult.type() == ClientOpResult::TClientInfoAndState) {
           self->ProcessSuccess(aResult.get_ClientInfoAndState());
         } else {
           self->ProcessCompletion();
         }
-      }, [self] (nsresult aResult) {
+      }, [self] (const CopyableErrorResult& aResult) {
         self->ProcessCompletion();
       });
   }
 
   void
   MaybeFinish()
   {
     if (!mOutstandingPromiseCount) {
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -261,16 +261,16 @@ ClientNavigateOpChild::Init(const Client
   if (!mSerialEventTarget) {
     mSerialEventTarget = GetCurrentThreadSerialEventTarget();
   }
 
   promise->Then(mSerialEventTarget, __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientNavigateOpParent.cpp b/dom/clients/manager/ClientNavigateOpParent.cpp
--- a/dom/clients/manager/ClientNavigateOpParent.cpp
+++ b/dom/clients/manager/ClientNavigateOpParent.cpp
@@ -18,19 +18,19 @@ ClientNavigateOpParent::ActorDestroy(Act
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientNavigateOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpPromise.h b/dom/clients/manager/ClientOpPromise.h
--- a/dom/clients/manager/ClientOpPromise.h
+++ b/dom/clients/manager/ClientOpPromise.h
@@ -4,21 +4,24 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientOpPromise_h
 #define _mozilla_dom_ClientOpPromise_h
 
 #include "mozilla/MozPromise.h"
 
 namespace mozilla {
+
+class CopyableErrorResult;
+
 namespace dom {
 
 class ClientOpResult;
 class ClientState;
 
-typedef MozPromise<ClientOpResult, nsresult, false> ClientOpPromise;
+typedef MozPromise<ClientOpResult, CopyableErrorResult, false> ClientOpPromise;
 
-typedef MozPromise<ClientState, nsresult, false> ClientStatePromise;
+typedef MozPromise<ClientState, CopyableErrorResult, false> ClientStatePromise;
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientOpPromise_h
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
--- a/dom/clients/manager/ClientOpenWindowOpChild.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -28,16 +28,16 @@ ClientOpenWindowOpChild::ActorDestroy(Ac
 void
 ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
 {
   RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
   promise->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aResult) {
+    }, [this] (const CopyableErrorResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpParent.cpp b/dom/clients/manager/ClientOpenWindowOpParent.cpp
--- a/dom/clients/manager/ClientOpenWindowOpParent.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpParent.cpp
@@ -10,27 +10,29 @@ namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ClientOpenWindowOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mPromise) {
-    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    CopyableErrorResult rv;
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    mPromise->Reject(rv, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientOpenWindowOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
--- a/dom/clients/manager/ClientOpenWindowUtils.cpp
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -59,44 +59,50 @@ public:
     }
 
     // Our caller keeps a strong reference, so it is safe to remove the listener
     // from ServiceWorkerPrivate.
     aWebProgress->RemoveProgressListener(this);
 
     nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
     if (NS_WARN_IF(!doc)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     // Check same origin.
     nsCOMPtr<nsIScriptSecurityManager> securityManager =
       nsContentUtils::GetSecurityManager();
     nsresult rv = securityManager->CheckSameOriginURI(doc->GetOriginalURI(),
                                                       mBaseURI, false);
     if (NS_FAILED(rv)) {
-      mPromise->Resolve(NS_OK, __func__);
+      mPromise->Resolve(CopyableErrorResult(), __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
     if (NS_WARN_IF(!innerWindow)) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     Maybe<ClientInfo> info = innerWindow->GetClientInfo();
     Maybe<ClientState> state = innerWindow->GetClientState();
 
     if (NS_WARN_IF(info.isNothing() || state.isNothing())) {
-      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
       return NS_OK;
     }
 
     mPromise->Resolve(ClientInfoAndState(info.ref().ToIPC(), state.ref().ToIPC()),
                       __func__);
     mPromise = nullptr;
 
@@ -142,17 +148,19 @@ public:
     MOZ_ASSERT(false, "Unexpected notification.");
     return NS_OK;
   }
 
 private:
   ~WebProgressListener()
   {
     if (mPromise) {
-      mPromise->Reject(NS_ERROR_ABORT, __func__);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      mPromise->Reject(rv, __func__);
       mPromise = nullptr;
     }
   }
 
   RefPtr<ClientOpPromise::Private> mPromise;
   // TODO: make window a weak ref and stop cycle collecting
   nsCOMPtr<nsPIDOMWindowOuter> mWindow;
   nsCOMPtr<nsIURI> mBaseURI;
@@ -269,54 +277,55 @@ void
 WaitForLoad(const ClientOpenWindowArgs& aArgs,
             nsPIDOMWindowOuter* aOuterWindow,
             ClientOpPromise::Private* aPromise)
 {
   MOZ_DIAGNOSTIC_ASSERT(aOuterWindow);
 
   RefPtr<ClientOpPromise::Private> promise = aPromise;
 
-  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  CopyableErrorResult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIURI> baseURI;
   rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   nsCOMPtr<nsIDocShell> docShell = aOuterWindow->GetDocShell();
   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
 
   if (NS_WARN_IF(!webProgress)) {
-    promise->Reject(NS_ERROR_FAILURE, __func__);
+    rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    promise->Reject(rv, __func__);
     return;
   }
 
   RefPtr<ClientOpPromise> ref = promise;
 
   RefPtr<WebProgressListener> listener =
     new WebProgressListener(aOuterWindow, baseURI, promise.forget());
 
 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
+  if (NS_WARN_IF(rv.Failed())) {
     promise->Reject(rv, __func__);
     return;
   }
 
   // Hold the listener alive until the promise settles
   ref->Then(aOuterWindow->EventTargetFor(TaskCategory::Other), __func__,
     [listener] (const ClientOpResult& aResult) { },
-    [listener] (nsresult aResult) { });
+    [listener] (const CopyableErrorResult& aResult) { });
 }
 
 #ifdef MOZ_WIDGET_ANDROID
 
 class LaunchObserver final : public nsIObserver
 {
   RefPtr<GenericPromise::Private> mPromise;
 
@@ -410,17 +419,17 @@ ClientOpenWindowInCurrentProcess(const C
       [aArgs, promise] (bool aResult) {
         nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
         nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
         if (NS_WARN_IF(NS_FAILED(rv))) {
           promise->Reject(rv, __func__);
         }
 
         WaitForLoad(aArgs, outerWindow, promise);
-      }, [promise] (nsresult aResult) {
+      }, [promise] (const CopyableErrorResult& aResult) {
         promise->Reject(aResult, __func__);
       });
     return ref.forget();
   }
 
   // If we didn't get the NOT_AVAILABLE error then there is no need
   // wait for the browser to launch.  Cancel the observer so that it
   // will release.
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -592,17 +592,17 @@ ClientSource::Claim(const ClientClaimArg
 
   RefPtr<ClientOpPromise::Private> outerPromise =
     new ClientOpPromise::Private(__func__);
 
   RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
   p->Then(innerWindow->EventTargetFor(TaskCategory::Other), __func__,
     [outerPromise] (bool aResult) {
       outerPromise->Resolve(NS_OK, __func__);
-    }, [outerPromise] (nsresult aResult) {
+    }, [outerPromise] (const CopyableErrorResult& aResult) {
       outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise;
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceOpChild.h"
 
 #include "ClientSource.h"
 #include "ClientSourceChild.h"
+#include "mozilla/ErrorResult.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 ClientSource*
 ClientSourceOpChild::GetSource() const
 {
@@ -27,17 +28,19 @@ ClientSourceOpChild::DoSourceOp(Method a
   RefPtr<ClientOpPromise> promise;
   nsCOMPtr<nsISerialEventTarget> target;
 
   // Limit the scope of the source variable since running the operation
   // can cause the ClientSource object to be destroyed.
   {
     ClientSource* source = GetSource();
     if (!source) {
-      Unused << PClientSourceOpChild::Send__delete__(this, NS_ERROR_ABORT);
+      CopyableErrorResult rv;
+      rv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      Unused << PClientSourceOpChild::Send__delete__(this, rv);
       return;
     }
 
     target = source->EventTargetFor(TaskCategory::Other);
 
     // This may cause the ClientSource object to be destroyed.  Do not
     // use the source variable after this call.
     promise = (source->*aMethod)(aArgs);
@@ -45,17 +48,17 @@ ClientSourceOpChild::DoSourceOp(Method a
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
   promise->Then(target, __func__,
     [this, aArgs] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aResult);
-    }, [this] (nsresult aRv) {
+    }, [this] (const mozilla::CopyableErrorResult& aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
 
 void
 ClientSourceOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
diff --git a/dom/clients/manager/ClientSourceOpParent.cpp b/dom/clients/manager/ClientSourceOpParent.cpp
--- a/dom/clients/manager/ClientSourceOpParent.cpp
+++ b/dom/clients/manager/ClientSourceOpParent.cpp
@@ -18,19 +18,19 @@ ClientSourceOpParent::ActorDestroy(Actor
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 IPCResult
 ClientSourceOpParent::Recv__delete__(const ClientOpResult& aResult)
 {
-  if (aResult.type() == ClientOpResult::Tnsresult &&
-      NS_FAILED(aResult.get_nsresult())) {
-    mPromise->Reject(aResult.get_nsresult(), __func__);
+  if (aResult.type() == ClientOpResult::TCopyableErrorResult &&
+      aResult.get_CopyableErrorResult().Failed()) {
+    mPromise->Reject(aResult.get_CopyableErrorResult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
