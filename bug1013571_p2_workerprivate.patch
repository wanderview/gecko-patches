# HG changeset patch
# Parent e26fbd15fb9d20f9f0126c5d67efc7a93e18aee2
# User Ben Kelly <ben@wanderview.com>
Bug 1013571 Part 2: Enable PBackground in workers.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -56,16 +56,24 @@
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "BackgroundChild.h"
+
+// BackgroundChild.h indirectly brings in windows.h via the chromium ipc
+// headers.  This breaks things here due API macro collision.
+#ifdef XP_WIN
+#undef CreateFile
+#endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -901,16 +909,41 @@ public:
       nsCycleCollector_collect(nullptr);
     }
   }
 
 private:
   WorkerPrivate* mWorkerPrivate;
 };
 
+class WorkerThreadInitPBackgroundRunnable MOZ_FINAL : public nsRunnable
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+public:
+  WorkerThreadInitPBackgroundRunnable(WorkerPrivate* aWorkerPrivate,
+                                      RuntimeService::WorkerThread* aThread,
+                                      JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+private:
+  ~WorkerThreadInitPBackgroundRunnable()
+  { }
+
+  NS_DECL_NSIRUNNABLE
+};
+
 class WorkerThreadPrimaryRunnable MOZ_FINAL : public nsRunnable
 {
   WorkerPrivate* mWorkerPrivate;
   nsRefPtr<RuntimeService::WorkerThread> mThread;
   JSRuntime* mParentRuntime;
 
   class FinishedRunnable MOZ_FINAL : public nsRunnable
   {
@@ -1525,27 +1558,24 @@ RuntimeService::ScheduleWorker(JSContext
                      nsISupportsPriority::PRIORITY_NORMAL :
                      nsISupportsPriority::PRIORITY_LOW;
 
   if (NS_FAILED(thread->SetPriority(priority))) {
     NS_WARNING("Could not set the thread's priority!");
   }
 
   nsCOMPtr<nsIRunnable> runnable =
-    new WorkerThreadPrimaryRunnable(aWorkerPrivate, thread, JS_GetParentRuntime(aCx));
+    new WorkerThreadInitPBackgroundRunnable(aWorkerPrivate, thread,
+                                            JS_GetParentRuntime(aCx));
   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
     UnregisterWorker(aCx, aWorkerPrivate);
     JS_ReportError(aCx, "Could not dispatch to thread!");
     return false;
   }
 
-#ifdef DEBUG
-  thread->SetAcceptingNonWorkerRunnables(false);
-#endif
-
   return true;
 }
 
 // static
 void
 RuntimeService::ShutdownIdleThreads(nsITimer* aTimer, void* /* aClosure */)
 {
   AssertIsOnMainThread();
@@ -2504,21 +2534,87 @@ LogViolationDetailsRunnable::Run()
   nsRefPtr<MainThreadStopSyncLoopRunnable> response =
     new MainThreadStopSyncLoopRunnable(mWorkerPrivate, mSyncLoopTarget.forget(),
                                        true);
   MOZ_ALWAYS_TRUE(response->Dispatch(nullptr));
 
   return NS_OK;
 }
 
+class WorkerBackgroundChildCallback MOZ_FINAL :
+  public nsIIPCBackgroundChildCreateCallback
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+public:
+  WorkerBackgroundChildCallback(WorkerPrivate* aWorkerPrivate,
+                                RuntimeService::WorkerThread* aThread,
+                                JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~WorkerBackgroundChildCallback()
+  { }
+
+  virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
+
+  virtual void
+  ActorFailed() MOZ_OVERRIDE
+  {
+    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
+  }
+};
+
+NS_IMPL_ISUPPORTS(WorkerBackgroundChildCallback, nsIIPCBackgroundChildCreateCallback)
+
+void
+WorkerBackgroundChildCallback::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new WorkerThreadPrimaryRunnable(mWorkerPrivate, mThread, mParentRuntime);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mThread->Dispatch(runnable, NS_DISPATCH_NORMAL)));
+
+#ifdef DEBUG
+  thread->SetAcceptingNonWorkerRunnables(false);
+#endif
+}
+
+NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadInitPBackgroundRunnable, nsRunnable)
+
+NS_IMETHODIMP
+WorkerThreadInitPBackgroundRunnable::Run()
+{
+  using mozilla::ipc::BackgroundChild;
+
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new WorkerBackgroundChildCallback(mWorkerPrivate, mThread, mParentRuntime);
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Worker failed to create PBackgroundChild!");
+  }
+
+  return NS_OK;
+}
+
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::Run()
 {
+  using mozilla::ipc::BackgroundChild;
+
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
@@ -2567,16 +2663,19 @@ WorkerThreadPrimaryRunnable::Run()
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
+    // XXX Detach PBackground from thread here?
+    BackgroundChild::DetachFromCurrentThread();
+
     // Destroy the main context.  This will unroot the main worker global and
     // GC.  This is not the last JSContext (WorkerJSRuntime maintains an
     // internal JSContext).
     JS_DestroyContext(cx);
 
     // Now WorkerJSRuntime goes out of scope and its destructor will shut
     // down the cycle collector and destroy the final JSContext.  This
     // breaks any remaining cycles and collects the C++ and JS objects
