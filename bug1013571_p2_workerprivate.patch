# HG changeset patch
# Parent e26fbd15fb9d20f9f0126c5d67efc7a93e18aee2
# User Ben Kelly <ben@wanderview.com>
Bug 1013571 Part 2: Enable PBackground in workers.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -56,16 +56,24 @@
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "BackgroundChild.h"
+
+// BackgroundChild.h indirectly brings in windows.h via the chromium ipc
+// headers.  This breaks things here due API macro collision.
+#ifdef XP_WIN
+#undef CreateFile
+#endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -1524,16 +1532,20 @@ RuntimeService::ScheduleWorker(JSContext
   int32_t priority = aWorkerPrivate->IsChromeWorker() ?
                      nsISupportsPriority::PRIORITY_NORMAL :
                      nsISupportsPriority::PRIORITY_LOW;
 
   if (NS_FAILED(thread->SetPriority(priority))) {
     NS_WARNING("Could not set the thread's priority!");
   }
 
+  // XXX Fire worker runnable to attach PBackground here. Execute
+  //     WorkerThreadPrimaryRunnable and SetAcceptingNonWorkerRunnables(false)
+  //     in PBackground callback.
+
   nsCOMPtr<nsIRunnable> runnable =
     new WorkerThreadPrimaryRunnable(aWorkerPrivate, thread, JS_GetParentRuntime(aCx));
   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
     UnregisterWorker(aCx, aWorkerPrivate);
     JS_ReportError(aCx, "Could not dispatch to thread!");
     return false;
   }
 
@@ -2504,30 +2516,66 @@ LogViolationDetailsRunnable::Run()
   nsRefPtr<MainThreadStopSyncLoopRunnable> response =
     new MainThreadStopSyncLoopRunnable(mWorkerPrivate, mSyncLoopTarget.forget(),
                                        true);
   MOZ_ALWAYS_TRUE(response->Dispatch(nullptr));
 
   return NS_OK;
 }
 
+class WorkerBackgroundChildPrimer MOZ_FINAL :
+  public nsIIPCBackgroundChildCreateCallback
+{
+public:
+  WorkerBackgroundChildPrimer()
+  { }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~WorkerBackgroundChildPrimer()
+  { }
+
+  virtual void
+  ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
+  }
+
+  virtual void
+  ActorFailed() MOZ_OVERRIDE
+  {
+    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
+  }
+};
+
+NS_IMPL_ISUPPORTS(WorkerBackgroundChildPrimer, nsIIPCBackgroundChildCreateCallback)
+
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::Run()
 {
+  using mozilla::ipc::BackgroundChild;
+
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
 
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new WorkerBackgroundChildPrimer();
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Worker failed to create PBackgroundChild!");
+  }
+
   char stackBaseGuess;
 
   nsAutoCString threadName;
   threadName.AssignLiteral("WebWorker '");
   threadName.Append(NS_LossyConvertUTF16toASCII(mWorkerPrivate->ScriptURL()));
   threadName.Append('\'');
 
   profiler_register_thread(threadName.get(), &stackBaseGuess);
@@ -2567,16 +2615,19 @@ WorkerThreadPrimaryRunnable::Run()
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
+    // XXX Detach PBackground from thread here?
+    BackgroundChild::DetachFromCurrentThread();
+
     // Destroy the main context.  This will unroot the main worker global and
     // GC.  This is not the last JSContext (WorkerJSRuntime maintains an
     // internal JSContext).
     JS_DestroyContext(cx);
 
     // Now WorkerJSRuntime goes out of scope and its destructor will shut
     // down the cycle collector and destroy the final JSContext.  This
     // breaks any remaining cycles and collects the C++ and JS objects
