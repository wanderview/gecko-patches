# HG changeset patch
# Parent c6c34c13b0fdb02ce6d37ca8c70b7f29b5731d02
# User Ben Kelly <ben@wanderview.com>
Bug 1013571 Part 2: Enable PBackground in workers.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -56,16 +56,18 @@
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "BackgroundChild.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -901,16 +903,41 @@ public:
       nsCycleCollector_collect(nullptr);
     }
   }
 
 private:
   WorkerPrivate* mWorkerPrivate;
 };
 
+class WorkerThreadInitPBackgroundRunnable MOZ_FINAL : public nsRunnable
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+public:
+  WorkerThreadInitPBackgroundRunnable(WorkerPrivate* aWorkerPrivate,
+                                      RuntimeService::WorkerThread* aThread,
+                                      JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+private:
+  ~WorkerThreadInitPBackgroundRunnable()
+  { }
+
+  NS_DECL_NSIRUNNABLE
+};
+
 class WorkerThreadPrimaryRunnable MOZ_FINAL : public nsRunnable
 {
   WorkerPrivate* mWorkerPrivate;
   nsRefPtr<RuntimeService::WorkerThread> mThread;
   JSRuntime* mParentRuntime;
 
   class FinishedRunnable MOZ_FINAL : public nsRunnable
   {
@@ -1525,27 +1552,24 @@ RuntimeService::ScheduleWorker(JSContext
                      nsISupportsPriority::PRIORITY_NORMAL :
                      nsISupportsPriority::PRIORITY_LOW;
 
   if (NS_FAILED(thread->SetPriority(priority))) {
     NS_WARNING("Could not set the thread's priority!");
   }
 
   nsCOMPtr<nsIRunnable> runnable =
-    new WorkerThreadPrimaryRunnable(aWorkerPrivate, thread, JS_GetParentRuntime(aCx));
+    new WorkerThreadInitPBackgroundRunnable(aWorkerPrivate, thread,
+                                            JS_GetParentRuntime(aCx));
   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
     UnregisterWorker(aCx, aWorkerPrivate);
     JS_ReportError(aCx, "Could not dispatch to thread!");
     return false;
   }
 
-#ifdef DEBUG
-  thread->SetAcceptingNonWorkerRunnables(false);
-#endif
-
   return true;
 }
 
 // static
 void
 RuntimeService::ShutdownIdleThreads(nsITimer* aTimer, void* /* aClosure */)
 {
   AssertIsOnMainThread();
@@ -2504,21 +2528,149 @@ LogViolationDetailsRunnable::Run()
   nsRefPtr<MainThreadStopSyncLoopRunnable> response =
     new MainThreadStopSyncLoopRunnable(mWorkerPrivate, mSyncLoopTarget.forget(),
                                        true);
   MOZ_ALWAYS_TRUE(response->Dispatch(nullptr));
 
   return NS_OK;
 }
 
+class WorkerBackgroundChildCallback MOZ_FINAL :
+  public nsIIPCBackgroundChildCreateCallback
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+  // XXX: This seems wasteful and we probably should not need it.
+  class RescheduleRunnable MOZ_FINAL : public nsRunnable
+  {
+    nsRefPtr<RuntimeService::WorkerThread> mThread;
+    nsCOMPtr<nsIRunnable> mWorkerRunnable;
+
+  public:
+    RescheduleRunnable(RuntimeService::WorkerThread* aThread,
+                       nsIRunnable* aWorkerRunnable)
+    : mThread(aThread), mWorkerRunnable(aWorkerRunnable)
+    {
+      MOZ_ASSERT(mThread);
+      MOZ_ASSERT(mWorkerRunnable);
+    }
+
+    NS_DECL_ISUPPORTS_INHERITED
+
+  private:
+    ~RescheduleRunnable()
+    { }
+
+    NS_DECL_NSIRUNNABLE
+  };
+
+public:
+  WorkerBackgroundChildCallback(WorkerPrivate* aWorkerPrivate,
+                                RuntimeService::WorkerThread* aThread,
+                                JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~WorkerBackgroundChildCallback()
+  { }
+
+  virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
+
+  virtual void
+  ActorFailed() MOZ_OVERRIDE
+  {
+    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
+  }
+};
+
+
+
+NS_IMPL_ISUPPORTS(WorkerBackgroundChildCallback, nsIIPCBackgroundChildCreateCallback)
+
+void
+WorkerBackgroundChildCallback::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
+
+  // XXX: We would like to perform WorkerThreadPrimaryRunnable::Run()
+  //      logic here directly, but can't for a couple reasons:
+  //
+  //      1) We are still in the IPC callback stack which will attempt
+  //         to run additional callbacks.  We would block those callbacks
+  //         until WorkerThreadPrimaryRunnable completed.  This is
+  //         also a problem because we want to detach PBackground at the
+  //         end of WorkerThreadPrimaryRunnable.
+  //      2) We can't just mThread->Dispatch() WorkerThreadPrimaryRunnable,
+  //         though, because at this point WorkerThread expects mWorkerPrivate
+  //         to be set when receiving worker runnables.  Since mWorkerPrivate
+  //         does not get set until WorkerThreadPrimaryRunnable executes, this
+  //         trips assertions.
+  //
+  //      Can this be fixed by adjusting the assertions to understand we may
+  //      fire a worker runnable in this state?
+  //
+  //      For now workaround by bouncing to the main thread.
+
+  nsCOMPtr<nsIRunnable> mainThreadRunnable =
+    new WorkerThreadPrimaryRunnable(mWorkerPrivate, mThread, mParentRuntime);
+
+  nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
+  MOZ_ASSERT(mainThread);
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new RescheduleRunnable(mThread, mainThreadRunnable);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mainThread->Dispatch(runnable, NS_DISPATCH_NORMAL)));
+}
+
+NS_IMPL_ISUPPORTS_INHERITED0(WorkerBackgroundChildCallback::RescheduleRunnable,
+                             nsRunnable)
+
+NS_IMETHODIMP
+WorkerBackgroundChildCallback::RescheduleRunnable::Run()
+{
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mThread->Dispatch(mWorkerRunnable, NS_DISPATCH_NORMAL)));
+
+#ifdef DEBUG
+  mThread->SetAcceptingNonWorkerRunnables(false);
+#endif
+
+  return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadInitPBackgroundRunnable, nsRunnable)
+
+NS_IMETHODIMP
+WorkerThreadInitPBackgroundRunnable::Run()
+{
+  using mozilla::ipc::BackgroundChild;
+
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new WorkerBackgroundChildCallback(mWorkerPrivate, mThread, mParentRuntime);
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Worker failed to create PBackgroundChild!");
+  }
+
+  return NS_OK;
+}
+
 NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
 
 NS_IMETHODIMP
 WorkerThreadPrimaryRunnable::Run()
 {
+  using mozilla::ipc::BackgroundChild;
+
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
@@ -2567,16 +2719,19 @@ WorkerThreadPrimaryRunnable::Run()
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
+    // XXX Detach PBackground from thread here?
+    BackgroundChild::DetachFromCurrentThread();
+
     // Destroy the main context.  This will unroot the main worker global and
     // GC.  This is not the last JSContext (WorkerJSRuntime maintains an
     // internal JSContext).
     JS_DestroyContext(cx);
 
     // Now WorkerJSRuntime goes out of scope and its destructor will shut
     // down the cycle collector and destroy the final JSContext.  This
     // breaks any remaining cycles and collects the C++ and JS objects
