# HG changeset patch
# Parent 365c51824d74acf402cbb6751d8545c1360523a8
# User Ben Kelly <ben@wanderview.com>
Bug 1013571 Part 2: Enable PBackground in workers.

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -57,16 +57,18 @@
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "ServiceWorker.h"
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "BackgroundChild.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -899,16 +901,73 @@ public:
       nsCycleCollector_collect(nullptr);
     }
   }
 
 private:
   WorkerPrivate* mWorkerPrivate;
 };
 
+class WorkerThreadInitPBackgroundRunnable MOZ_FINAL : public nsRunnable
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+public:
+  WorkerThreadInitPBackgroundRunnable(WorkerPrivate* aWorkerPrivate,
+                                      RuntimeService::WorkerThread* aThread,
+                                      JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS_INHERITED
+
+private:
+  ~WorkerThreadInitPBackgroundRunnable()
+  { }
+
+  NS_DECL_NSIRUNNABLE
+};
+
+class WorkerBackgroundChildCallback MOZ_FINAL :
+  public nsIIPCBackgroundChildCreateCallback
+{
+  WorkerPrivate* mWorkerPrivate;
+  nsRefPtr<RuntimeService::WorkerThread> mThread;
+  JSRuntime* mParentRuntime;
+
+public:
+  WorkerBackgroundChildCallback(WorkerPrivate* aWorkerPrivate,
+                                RuntimeService::WorkerThread* aThread,
+                                JSRuntime* aParentRuntime)
+  : mWorkerPrivate(aWorkerPrivate), mThread(aThread), mParentRuntime(aParentRuntime)
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aThread);
+  }
+
+  NS_DECL_ISUPPORTS
+
+private:
+  ~WorkerBackgroundChildCallback()
+  { }
+
+  virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
+
+  virtual void
+  ActorFailed() MOZ_OVERRIDE
+  {
+    MOZ_CRASH("Worker failed to create a PBackgroundChild actor!");
+  }
+};
+
 class WorkerThreadPrimaryRunnable MOZ_FINAL : public nsRunnable
 {
   WorkerPrivate* mWorkerPrivate;
   nsRefPtr<RuntimeService::WorkerThread> mThread;
   JSRuntime* mParentRuntime;
 
   class FinishedRunnable MOZ_FINAL : public nsRunnable
   {
@@ -1525,27 +1584,24 @@ RuntimeService::ScheduleWorker(JSContext
                      nsISupportsPriority::PRIORITY_NORMAL :
                      nsISupportsPriority::PRIORITY_LOW;
 
   if (NS_FAILED(thread->SetPriority(priority))) {
     NS_WARNING("Could not set the thread's priority!");
   }
 
   nsCOMPtr<nsIRunnable> runnable =
-    new WorkerThreadPrimaryRunnable(aWorkerPrivate, thread, JS_GetParentRuntime(aCx));
+    new WorkerThreadInitPBackgroundRunnable(aWorkerPrivate, thread,
+                                            JS_GetParentRuntime(aCx));
   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
     UnregisterWorker(aCx, aWorkerPrivate);
     JS_ReportError(aCx, "Could not dispatch to thread!");
     return false;
   }
 
-#ifdef DEBUG
-  thread->SetAcceptingNonWorkerRunnables(false);
-#endif
-
   return true;
 }
 
 // static
 void
 RuntimeService::ShutdownIdleThreads(nsITimer* aTimer, void* /* aClosure */)
 {
   AssertIsOnMainThread();
@@ -2439,18 +2495,22 @@ NS_IMPL_ISUPPORTS_INHERITED0(RuntimeServ
 
 NS_IMETHODIMP
 RuntimeService::WorkerThread::Dispatch(nsIRunnable* aRunnable, uint32_t aFlags)
 {
   // May be called on any thread!
 
 #ifdef DEBUG
   if (PR_GetCurrentThread() == mThread) {
-    MOZ_ASSERT(mWorkerPrivate);
-    mWorkerPrivate->AssertIsOnWorkerThread();
+    // The WorkerThreadPrimaryRunnable is dispatched from the actor callback
+    // on the worker thread itself.  So we cannot assume mWorkerPrivate is
+    // set yet.
+    if (mWorkerPrivate) {
+      mWorkerPrivate->AssertIsOnWorkerThread();
+    }
   }
   else if (aRunnable && !IsAcceptingNonWorkerRunnables()) {
     // Only enforce cancelable runnables after we've started the worker loop.
     nsCOMPtr<nsICancelableRunnable> cancelable = do_QueryInterface(aRunnable);
     MOZ_ASSERT(cancelable,
                "Should have been wrapped by the worker's event target!");
   }
 #endif
@@ -2458,18 +2518,18 @@ RuntimeService::WorkerThread::Dispatch(n
   // Workers only support asynchronous dispatch for now.
   if (NS_WARN_IF(aFlags != NS_DISPATCH_NORMAL)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsIRunnable* runnableToDispatch;
   nsRefPtr<WorkerRunnable> workerRunnable;
 
-  if (aRunnable && PR_GetCurrentThread() == mThread) {
-    // No need to lock here because mWorkerPrivate is only modified on mThread.
+  // No need to lock here because mWorkerPrivate is only modified on mThread.
+  if (aRunnable && mWorkerPrivate && PR_GetCurrentThread() == mThread) {
     workerRunnable = mWorkerPrivate->MaybeWrapAsWorkerRunnable(aRunnable);
     runnableToDispatch = workerRunnable;
   }
   else {
     runnableToDispatch = aRunnable;
   }
 
   nsresult rv = nsThread::Dispatch(runnableToDispatch, NS_DISPATCH_NORMAL);
@@ -2535,30 +2595,64 @@ LogViolationDetailsRunnable::Run()
   nsRefPtr<MainThreadStopSyncLoopRunnable> response =
     new MainThreadStopSyncLoopRunnable(mWorkerPrivate, mSyncLoopTarget.forget(),
                                        true);
   MOZ_ALWAYS_TRUE(response->Dispatch(nullptr));
 
   return NS_OK;
 }
 
-NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
+NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadInitPBackgroundRunnable, nsRunnable)
 
 NS_IMETHODIMP
-WorkerThreadPrimaryRunnable::Run()
+WorkerThreadInitPBackgroundRunnable::Run()
 {
+  using mozilla::ipc::BackgroundChild;
+
 #ifdef MOZ_NUWA_PROCESS
   if (IsNuwaProcess()) {
     NS_ASSERTION(NuwaMarkCurrentThread != nullptr,
                   "NuwaMarkCurrentThread is undefined!");
     NuwaMarkCurrentThread(nullptr, nullptr);
     NuwaFreezeCurrentThread();
   }
 #endif
 
+  nsCOMPtr<nsIIPCBackgroundChildCreateCallback> callback =
+    new WorkerBackgroundChildCallback(mWorkerPrivate, mThread, mParentRuntime);
+  if (!BackgroundChild::GetOrCreateForCurrentThread(callback)) {
+    MOZ_CRASH("Worker failed to create PBackgroundChild!");
+  }
+
+  return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS(WorkerBackgroundChildCallback, nsIIPCBackgroundChildCreateCallback)
+
+void
+WorkerBackgroundChildCallback::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(aActor, "Worker failed to create a PBackgroundChild actor!");
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new WorkerThreadPrimaryRunnable(mWorkerPrivate, mThread, mParentRuntime);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mThread->Dispatch(runnable, NS_DISPATCH_NORMAL)));
+
+#ifdef DEBUG
+  mThread->SetAcceptingNonWorkerRunnables(false);
+#endif
+}
+
+NS_IMPL_ISUPPORTS_INHERITED0(WorkerThreadPrimaryRunnable, nsRunnable)
+
+NS_IMETHODIMP
+WorkerThreadPrimaryRunnable::Run()
+{
+  using mozilla::ipc::BackgroundChild;
+
   char stackBaseGuess;
 
   nsAutoCString threadName;
   threadName.AssignLiteral("WebWorker '");
   threadName.Append(NS_LossyConvertUTF16toASCII(mWorkerPrivate->ScriptURL()));
   threadName.Append('\'');
 
   profiler_register_thread(threadName.get(), &stackBaseGuess);
@@ -2616,16 +2710,18 @@ WorkerThreadPrimaryRunnable::Run()
 
   mThread->SetWorker(nullptr);
 
   mWorkerPrivate->ScheduleDeletion(WorkerPrivate::WorkerRan);
 
   // It is no longer safe to touch mWorkerPrivate.
   mWorkerPrivate = nullptr;
 
+  BackgroundChild::DetachFromCurrentThread();
+
   // Now recycle this thread.
   nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
   MOZ_ASSERT(mainThread);
 
   nsRefPtr<FinishedRunnable> finishedRunnable =
     new FinishedRunnable(mThread.forget());
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(mainThread->Dispatch(finishedRunnable,
                                                     NS_DISPATCH_NORMAL)));
