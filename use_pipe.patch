# HG changeset patch
# Parent 541e08e8313523a6725528ed464ebda7b40af22e
# User Ben Kelly <ben@wanderview.com>
Integrate CrossProcessPipe into Cache.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -45,65 +45,16 @@ Cache::Cache(nsISupports* aOwner, nsIGlo
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
   , mActor(static_cast<CacheChild*>(aActor))
 {
   MOZ_ASSERT(mActor);
   mActor->SetListener(*this);
 }
 
-// TODO: factor this out to TypeUtils
-void
-Cache::ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn,
-                       bool aReadBody, ErrorResult& aRv)
-{
-  AutoJSAPI jsapi;
-  jsapi.Init(mGlobal);
-  JSContext* cx = jsapi.cx();
-  JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
-  JSAutoCompartment ac(cx, jsGlobal);
-
-  GlobalObject global(cx, jsGlobal);
-
-  TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
-}
-
-// TODO: factor this out to TypeUtils
-void
-Cache::ToPCacheRequest(PCacheRequest& aOut, const OwningRequestOrScalarValueString& aIn,
-                       bool aReadBody, ErrorResult& aRv)
-{
-  AutoJSAPI jsapi;
-  jsapi.Init(mGlobal);
-  JSContext* cx = jsapi.cx();
-  JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
-  JSAutoCompartment ac(cx, jsGlobal);
-
-  GlobalObject global(cx, jsGlobal);
-
-  return TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
-}
-
-// TODO: factor this out to TypeUtils
-void
-Cache::ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
-                             const Optional<RequestOrScalarValueString>& aIn,
-                             bool aReadBody, ErrorResult& aRv)
-{
-  AutoJSAPI jsapi;
-  jsapi.Init(mGlobal);
-  JSContext* cx = jsapi.cx();
-  JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
-  JSAutoCompartment ac(cx, jsGlobal);
-
-  GlobalObject global(cx, jsGlobal);
-
-  return TypeUtils::ToPCacheRequestOrVoid(global, aOut, aIn, aReadBody, aRv);
-}
-
 already_AddRefed<Promise>
 Cache::Match(const RequestOrScalarValueString& aRequest,
              const QueryParams& aParams, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
@@ -112,17 +63,17 @@ Cache::Match(const RequestOrScalarValueS
 
   PCacheRequest request;
   ToPCacheRequest(request, aRequest, false, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
-  TypeUtils::ToPCacheQueryParams(params, aParams);
+  ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendMatch(requestId, request, params);
 
   return promise.forget();
 }
 
@@ -139,17 +90,17 @@ Cache::MatchAll(const Optional<RequestOr
 
   PCacheRequestOrVoid request;
   ToPCacheRequestOrVoid(request, aRequest, false, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
-  TypeUtils::ToPCacheQueryParams(params, aParams);
+  ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendMatchAll(requestId, request, params);
 
   return promise.forget();
 }
 
@@ -246,17 +197,17 @@ Cache::Put(const RequestOrScalarValueStr
 
   PCacheRequest request;
   ToPCacheRequest(request, aRequest, true, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheResponse response;
-  TypeUtils::ToPCacheResponse(response, aResponse, aRv);
+  ToPCacheResponse(response, aResponse, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendPut(requestId, request, response);
 
@@ -276,17 +227,17 @@ Cache::Delete(const RequestOrScalarValue
 
   PCacheRequest request;
   ToPCacheRequest(request, aRequest, false, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
-  TypeUtils::ToPCacheQueryParams(params, aParams);
+  ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendDelete(requestId, request, params);
 
   return promise.forget();
 }
 
@@ -303,17 +254,17 @@ Cache::Keys(const Optional<RequestOrScal
 
   PCacheRequestOrVoid request;
   ToPCacheRequestOrVoid(request, aRequest, false, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
-  TypeUtils::ToPCacheQueryParams(params, aParams);
+  ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendKeys(requestId, request, params);
 
   return promise.forget();
 }
 
@@ -381,18 +332,17 @@ Cache::RecvMatchResponse(RequestId aRequ
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
-  nsRefPtr<Response> response = TypeUtils::ToResponse(mGlobal, aResponse,
-                                                      aStreamControl);
+  nsRefPtr<Response> response = ToResponse(aResponse, aStreamControl);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                             const nsTArray<PCacheResponse>& aResponses,
                             PCacheStreamControlChild* aStreamControl)
 {
@@ -403,18 +353,17 @@ Cache::RecvMatchAllResponse(RequestId aR
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
-    nsRefPtr<Response> response = TypeUtils::ToResponse(mGlobal, aResponses[i],
-                                                        aStreamControl);
+    nsRefPtr<Response> response = ToResponse(aResponses[i], aStreamControl);
     responses.AppendElement(response.forget());
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvAddResponse(RequestId aRequestId, nsresult aRv)
 {
@@ -491,25 +440,35 @@ Cache::RecvKeysResponse(RequestId aReque
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Request>> requests;
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
-    // TODO: Should mOwner and mGlobal be just one field? Right now mOwner can
-    //       be null (when on a worker), but mGlobal is always provided.
-    nsRefPtr<Request> request = TypeUtils::ToRequest(mGlobal, aRequests[i],
-                                                     aStreamControl);
+    nsRefPtr<Request> request = ToRequest(aRequests[i], aStreamControl);
     requests.AppendElement(request.forget());
   }
   promise->MaybeResolve(requests);
 }
 
+nsIGlobalObject*
+Cache::GetGlobalObject() const
+{
+  return mGlobal;
+}
+
+#ifdef DEBUG
+void
+Cache::AssertOwningThread() const
+{
+  NS_ASSERT_OWNINGTHREAD(Cache);
+}
+#endif
 
 Cache::~Cache()
 {
   if (mActor) {
     mActor->ClearListener();
     PCacheChild::Send__delete__(mActor);
     // The actor will be deleted by the IPC manager
     mActor = nullptr;
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Cache_h
 #define mozilla_dom_cache_Cache_h
 
 #include "mozilla/dom/cache/CacheChildListener.h"
+#include "mozilla/dom/cache/TypeUtils.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
@@ -34,16 +35,17 @@ namespace cache {
 class CacheChild;
 class PCacheChild;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 
 class Cache MOZ_FINAL : public nsISupports
                       , public nsWrapperCache
                       , public CacheChildListener
+                      , public TypeUtils
 {
 public:
   Cache(nsISupports* aOwner, nsIGlobalObject* aGlobal, const nsACString& aOrigin,
         const nsACString& aBaseDomain, PCacheChild* aActor);
 
   // webidl interface methods
   already_AddRefed<Promise>
   Match(const RequestOrScalarValueString& aRequest, const QueryParams& aParams,
@@ -92,32 +94,30 @@ public:
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess) MOZ_OVERRIDE;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                    const nsTArray<PCacheRequest>& aRequests,
                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
 
+  // TypeUtils methods
+  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
 private:
   virtual ~Cache();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
-  void ToPCacheRequest(PCacheRequest& aOut,
-                       const RequestOrScalarValueString& aIn, bool aReadBody,
-                       ErrorResult& aRv);
-  void ToPCacheRequest(PCacheRequest& aOut,
-                       const OwningRequestOrScalarValueString& aIn,
-                       bool aReadBody, ErrorResult& aRv);
-  void ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
-                             const Optional<RequestOrScalarValueString>& aIn,
-                             bool aReadBody, ErrorResult& aRv);
 
 private:
+  // TODO: remove separate mOwner
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
 public:
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -110,17 +110,17 @@ CacheStorage::Match(const RequestOrScala
   PCacheRequest request;
   ToPCacheRequest(request, aRequest, false, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     nsRefPtr<Promise> unused = RemoveRequestPromise(requestId);
     return nullptr;
   }
 
   PCacheQueryParams params;
-  TypeUtils::ToPCacheQueryParams(params, aParams);
+  ToPCacheQueryParams(params, aParams);
 
   unused << mActor->SendMatch(requestId, request, params);
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Has(const nsAString& aKey, ErrorResult& aRv)
@@ -301,17 +301,17 @@ CacheStorage::ActorCreated(PBackgroundCh
           nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
           if (promise) {
             promise->MaybeReject(rv);
           }
           return;
         }
 
         PCacheQueryParams params;
-        TypeUtils::ToPCacheQueryParams(params, entry.mParams);
+        ToPCacheQueryParams(params, entry.mParams);
 
         unused << mActor->SendMatch(requestId, request, params);
         break;
       }
       case OP_HAS:
         unused << mActor->SendHas(requestId, entry.mKey);
         break;
       case OP_OPEN:
@@ -374,18 +374,17 @@ CacheStorage::RecvMatchResponse(RequestI
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
-  nsRefPtr<Response> response = TypeUtils::ToResponse(mGlobal, aResponse,
-                                                      aStreamControl);
+  nsRefPtr<Response> response = ToResponse(aResponse, aStreamControl);
   promise->MaybeResolve(response);
 }
 
 void
 CacheStorage::RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
@@ -465,16 +464,30 @@ CacheStorage::RecvKeysResponse(RequestId
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   promise->MaybeResolve(aKeys);
 }
 
+nsIGlobalObject*
+CacheStorage::GetGlobalObject() const
+{
+  return mGlobal;
+}
+
+#ifdef DEBUG
+void
+CacheStorage::AssertOwningThread() const
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+}
+#endif
+
 CacheStorage::~CacheStorage()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   if (mActor) {
     mActor->ClearListener();
     PCacheStorageChild::Send__delete__(mActor);
     // The actor will be deleted by the IPC manager
@@ -510,28 +523,11 @@ CacheStorage::RemoveRequestPromise(Reque
       ref.swap(promise);
       mRequestPromises.RemoveElementAt(i);
       return ref.forget();
     }
   }
   return nullptr;
 }
 
-// TODO: factor this out to TypeUtils
-void
-CacheStorage::ToPCacheRequest(PCacheRequest& aOut,
-                              const RequestOrScalarValueString& aIn,
-                              bool aReadBody, ErrorResult& aRv)
-{
-  AutoJSAPI jsapi;
-  jsapi.Init(mGlobal);
-  JSContext* cx = jsapi.cx();
-  JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
-  JSAutoCompartment ac(cx, jsGlobal);
-
-  GlobalObject global(cx, jsGlobal);
-
-  TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
-}
-
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorage_h
 #define mozilla_dom_cache_CacheStorage_h
 
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheStorageChildListener.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/TypeUtils.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 
 class nsIGlobalObject;
@@ -36,16 +37,17 @@ class Promise;
 namespace cache {
 
 class CacheStorageChild;
 class PCacheRequest;
 
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public CacheStorageChildListener
+                             , public TypeUtils
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
   CacheStorage(Namespace aNamespace, nsISupports* aOwner,
                nsIGlobalObject* aGlobal, const nsACString& aOrigin,
                const nsACString& aBaseDomain);
 
@@ -76,27 +78,30 @@ public:
                                bool aSuccess) MOZ_OVERRIDE;
   virtual void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
                                 PCacheChild* aActor) MOZ_OVERRIDE;
   virtual void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                   bool aSuccess) MOZ_OVERRIDE;
   virtual void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
+  // TypeUtils method
+  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
 private:
   virtual ~CacheStorage();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
-  void
-  ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn,
-                  bool aReadyBody, ErrorResult& aRv);
-
   const Namespace mNamespace;
+  // TODO: remove separate mOwner
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheStorageChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
   enum Op
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -9,34 +9,31 @@
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsURLParsers.h"
+#include "nsXULAppAPI.h"
 
 namespace {
 
 using mozilla::ErrorResult;
-using mozilla::unused;
-using mozilla::void_t;
-using mozilla::dom::cache::PCacheReadStream;
-using mozilla::dom::cache::PCacheReadStreamOrVoid;
-using mozilla::ipc::BackgroundChild;
-using mozilla::ipc::FileDescriptor;
-using mozilla::ipc::PFileDescriptorSetChild;
-using mozilla::ipc::PBackgroundChild;
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
 static void
 ProcessURL(nsAString& aUrl, bool* aSchemeValidOut,
            nsAString* aUrlWithoutQueryOut, ErrorResult& aRv)
 {
@@ -98,66 +95,79 @@ ProcessURL(nsAString& aUrl, bool* aSchem
   // ParsePath gives us query position relative to the start of the path
   queryPos += pathPos;
 
   // We want everything before the query sine we already removed the trailing
   // fragment
   *aUrlWithoutQueryOut = Substring(aUrl, 0, queryPos - 1);
 }
 
-void
-SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut)
-{
-  MOZ_ASSERT(aStreamOut);
-  if (!aStream) {
-    *aStreamOut = void_t();
-    return;
-  }
-
-  // TODO: Integrate khuey's nsFancyPipe here if aStream does not provide
-  //       efficient serialization.  (Or always use pipe.)
-
-  PCacheReadStream readStream;
-  nsTArray<FileDescriptor> fds;
-  SerializeInputStream(aStream, readStream.params(), fds);
-
-  PFileDescriptorSetChild* fdSet = nullptr;
-  if (!fds.IsEmpty()) {
-    // We should not be serializing until we have an actor ready
-    PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
-    MOZ_ASSERT(manager);
-
-    fdSet = manager->SendPFileDescriptorSetConstructor(fds[0]);
-    for (uint32_t i = 1; i < fds.Length(); ++i) {
-      unused << fdSet->SendAddFileDescriptor(fds[i]);
-    }
-  }
-
-  if (fdSet) {
-    readStream.fds() = fdSet;
-  } else {
-    readStream.fds() = void_t();
-  }
-
-  *aStreamOut = readStream;
-}
-
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+using mozilla::unused;
 using mozilla::void_t;
 using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::CreateCrossProcessPipe;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::Sending;
 
-// static
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
+                           const RequestOrScalarValueString& aIn, bool aReadBody,
+                           ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
+}
+
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
+                           const OwningRequestOrScalarValueString& aIn,
+                           bool aReadBody, ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  return ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
+}
+
+void
+TypeUtils::ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
+                                 const Optional<RequestOrScalarValueString>& aIn,
+                                 bool aReadBody, ErrorResult& aRv)
+{
+  AutoJSAPI jsapi;
+  jsapi.Init(GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+
+  GlobalObject global(cx, jsGlobal);
+
+  return ToPCacheRequestOrVoid(global, aOut, aIn, aReadBody, aRv);
+}
+
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut, Request& aIn,
                            bool aReadBody, ErrorResult& aRv)
 {
   aIn.GetMethod(aOut.method());
   aIn.GetUrl(aOut.url());
 
   bool schemeValid;
@@ -191,20 +201,22 @@ TypeUtils::ToPCacheRequest(PCacheRequest
 
   nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
   MOZ_ASSERT(internalRequest);
   nsCOMPtr<nsIInputStream> stream;
 
   internalRequest->GetBody(getter_AddRefs(stream));
   aIn.SetBodyUsed();
 
-  SerializeCacheStream(stream, &aOut.body());
+  SerializeCacheStream(stream, &aOut.body(), aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
 }
 
-// static
 void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal,
                            PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn,
                            bool aReadBody, ErrorResult& aRv)
 {
   if (aIn.IsRequest()) {
     ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
@@ -214,17 +226,16 @@ TypeUtils::ToPCacheRequest(const GlobalO
   RequestInit init;
   nsRefPtr<Request> request = Request::Constructor(aGlobal, aIn, init, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
   ToPCacheRequest(aOut, *request, aReadBody, aRv);
 }
 
-// static
 void
 TypeUtils::ToPCacheRequestOrVoid(const GlobalObject& aGlobal, PCacheRequestOrVoid& aOut,
                                  const Optional<RequestOrScalarValueString>& aIn,
                                  bool aReadBody, ErrorResult& aRv)
 {
   if (!aIn.WasPassed()) {
     aOut = void_t();
     return;
@@ -232,17 +243,16 @@ TypeUtils::ToPCacheRequestOrVoid(const G
   PCacheRequest request;
   ToPCacheRequest(aGlobal, request, aIn.Value(), aReadBody, aRv);
   if (aRv.Failed()) {
     return;
   }
   aOut = request;
 }
 
-// static
 void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                            const OwningRequestOrScalarValueString& aIn,
                            bool aReadBody, ErrorResult& aRv)
 {
   if (aIn.IsRequest()) {
     ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
     return;
@@ -256,17 +266,16 @@ TypeUtils::ToPCacheRequest(const GlobalO
 
   nsRefPtr<Request> request = Request::Constructor(aGlobal, input, init, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
   ToPCacheRequest(aOut, *request, aReadBody, aRv);
 }
 
-// static
 void
 TypeUtils::ToPCacheResponse(PCacheResponse& aOut, Response& aIn,
                             ErrorResult& aRv)
 {
   aOut.type() = aIn.Type();
   aIn.GetUrl(aOut.url());
 
   if (aOut.url() != EmptyString()) {
@@ -293,20 +302,22 @@ TypeUtils::ToPCacheResponse(PCacheRespon
     aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
     return;
   }
 
   nsCOMPtr<nsIInputStream> stream;
   aIn.GetBody(getter_AddRefs(stream));
   aIn.SetBodyUsed();
 
-  SerializeCacheStream(stream, &aOut.body());
+  SerializeCacheStream(stream, &aOut.body(), aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
 }
 
-// static
 void
 TypeUtils::ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
   aOut.ignoreMethod() = aIn.mIgnoreMethod.WasPassed() &&
                         aIn.mIgnoreMethod.Value();
   aOut.ignoreVary() = aIn.mIgnoreVary.WasPassed() &&
@@ -316,19 +327,18 @@ TypeUtils::ToPCacheQueryParams(PCacheQue
   aOut.cacheNameSet() = aIn.mCacheName.WasPassed();
   if (aOut.cacheNameSet()) {
     aOut.cacheName() = aIn.mCacheName.Value();
   } else {
     aOut.cacheName() = NS_LITERAL_STRING("");
   }
 }
 
-// static
 already_AddRefed<Response>
-TypeUtils::ToResponse(nsIGlobalObject* aGlobal, const PCacheResponse& aIn,
+TypeUtils::ToResponse(const PCacheResponse& aIn,
                       PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<InternalResponse> ir;
   switch (aIn.type())
   {
     case ResponseType::Error:
       ir = InternalResponse::NetworkError();
       break;
@@ -365,23 +375,22 @@ TypeUtils::ToResponse(nsIGlobalObject* a
   ir->Headers()->SetGuard(aIn.headersGuard(), result);
   ir->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aStreamControl,
                                                        aIn.body());
   ir->SetBody(stream);
 
-  nsRefPtr<Response> ref = new Response(aGlobal, ir);
+  nsRefPtr<Response> ref = new Response(GetGlobalObject(), ir);
   return ref.forget();
 }
 
-// static
 already_AddRefed<Request>
-TypeUtils::ToRequest(nsIGlobalObject* aGlobal, const PCacheRequest& aIn,
+TypeUtils::ToRequest(const PCacheRequest& aIn,
                      PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   internalRequest->SetMode(aIn.mode());
@@ -394,15 +403,107 @@ TypeUtils::ToRequest(nsIGlobalObject* aG
   internalRequest->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aStreamControl,
                                                        aIn.body());
 
   internalRequest->SetBody(stream);
 
-  nsRefPtr<Request> request = new Request(aGlobal, internalRequest);
+  nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
   return request.forget();
 }
 
+void
+TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
+                                PCacheReadStreamOrVoid* aStreamOut,
+                                ErrorResult& aRv)
+{
+  MOZ_ASSERT(aStreamOut);
+  if (!aStream) {
+    *aStreamOut = void_t();
+    return;
+  }
+
+  nsCOMPtr<nsIInputStream> stream;
+
+  // If the provided stream can be serialized, then just send it directly
+  nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
+
+  // TODO: remove forced pipe usage after http fetch is available
+  bool forcePipe = (XRE_GetProcessType() != GeckoProcessType_Default);
+
+  if (!forcePipe && serial) {
+    stream = aStream;
+
+  // Otherwise we need to use a cross-process pipe
+  } else {
+    nsCOMPtr<nsICrossProcessPipe> pipe = CreateCrossProcessPipe(Sending);
+
+    nsCOMPtr<nsIAsyncInputStream> asyncStream;
+    nsresult rv = pipe->GetInputStream(getter_AddRefs(asyncStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    stream = asyncStream.forget();
+
+    nsCOMPtr<nsIAsyncOutputStream> pipeStream;
+    rv = pipe->GetOutputStream(getter_AddRefs(pipeStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    rv = NS_AsyncCopy(aStream, pipeStream, GetStreamThread());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+  }
+
+  MOZ_ASSERT(stream);
+
+  PCacheReadStream readStream;
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(stream, readStream.params(), fds);
+
+  PFileDescriptorSetChild* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    // We should not be serializing until we have an actor ready
+    PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
+    MOZ_ASSERT(manager);
+
+    fdSet = manager->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+  }
+
+  if (fdSet) {
+    readStream.fds() = fdSet;
+  } else {
+    readStream.fds() = void_t();
+  }
+
+  *aStreamOut = readStream;
+}
+
+nsIThread*
+TypeUtils::GetStreamThread()
+{
+  AssertOwningThread();
+
+  if (!mStreamThread) {
+    nsresult rv = NS_NewNamedThread("DOMCacheTypeU",
+                                    getter_AddRefs(mStreamThread));
+    if (NS_FAILED(rv) || !mStreamThread) {
+      MOZ_CRASH("Failed to create DOM Cache serialization thread.");
+    }
+  }
+
+  return mStreamThread;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -24,60 +24,89 @@ class InternalRequest;
 class Request;
 class RequestOrScalarValueString;
 class Response;
 template<typename T> class Optional;
 
 namespace cache {
 
 class PCacheQueryParams;
+class PCacheReadStreamOrVoid;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheStreamControlChild;
 
 class TypeUtils
 {
-public:
-  static void
+protected:
+  virtual ~TypeUtils() { }
+  virtual nsIGlobalObject* GetGlobalObject() const=0;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const=0;
+#else
+  inline void AssertOwningThread() { }
+#endif
+
+  void
+  ToPCacheRequest(PCacheRequest& aOut,
+                  const RequestOrScalarValueString& aIn, bool aReadBody,
+                  ErrorResult& aRv);
+
+  void
+  ToPCacheRequest(PCacheRequest& aOut,
+                  const OwningRequestOrScalarValueString& aIn,
+                  bool aReadBody, ErrorResult& aRv);
+
+  void
+  ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
+                        const Optional<RequestOrScalarValueString>& aIn,
+                        bool aReadBody, ErrorResult& aRv);
+
+  void
   ToPCacheRequest(PCacheRequest& aOut, Request& aIn, bool aReadBody,
                   ErrorResult& aRv);
 
-  static void
+  void
+  ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
+
+  void
+  ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
+
+  already_AddRefed<Response>
+  ToResponse(const PCacheResponse& aIn,
+             PCacheStreamControlChild* aStreamControl);
+
+  already_AddRefed<Request>
+  ToRequest(const PCacheRequest& aIn,
+            PCacheStreamControlChild* aStreamControl);
+
+private:
+  void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                   const RequestOrScalarValueString& aIn, bool aReadBody,
                   ErrorResult& aRv);
 
-  static void
+  void
   ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
                         PCacheRequestOrVoid& aOut,
                         const Optional<RequestOrScalarValueString>& aIn,
                         bool aReadBody, ErrorResult& aRv);
 
-  static void
+  void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                   const OwningRequestOrScalarValueString& aIn,
                   bool aReadBody, ErrorResult& aRv);
 
-  static void
-  ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
+  void
+  SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut,
+                       ErrorResult& aRv);
 
-  static void
-  ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
+  nsIThread* GetStreamThread();
 
-  static already_AddRefed<Response>
-  ToResponse(nsIGlobalObject* aOwner, const PCacheResponse& aIn,
-             PCacheStreamControlChild* aStreamControl);
-
-  static already_AddRefed<Request>
-  ToRequest(nsIGlobalObject* aGlobal, const PCacheRequest& aIn,
-            PCacheStreamControlChild* aStreamControl);
-
-private:
-  TypeUtils() MOZ_DELETE;
-  ~TypeUtils() MOZ_DELETE;
+  nsCOMPtr<nsIThread> mStreamThread;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_TypesUtils_h
