# HG changeset patch
# Parent 38e8eda3b4ddd699c0fc1a616dfa3f4ee002259d
# User Ben Kelly <ben@wanderview.com>
Integrate CrossProcessPipe into Cache.

diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -9,25 +9,27 @@
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsURLParsers.h"
+#include "nsXULAppAPI.h" // For XRE_GetProcessType
 
 namespace {
 
 using mozilla::ErrorResult;
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
@@ -102,19 +104,21 @@ ProcessURL(nsAString& aUrl, bool* aSchem
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::CreateCrossProcessPipe;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::Sending;
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn, bool aReadBody,
                            ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(GetGlobalObject());
@@ -414,19 +418,59 @@ TypeUtils::SerializeCacheStream(nsIInput
                                 ErrorResult& aRv)
 {
   MOZ_ASSERT(aStreamOut);
   if (!aStream) {
     *aStreamOut = void_t();
     return;
   }
 
+  nsCOMPtr<nsIInputStream> stream;
+
+  // If the provided stream can be serialized, then just send it directly
+  nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
+
+  // TODO: remove forced pipe usage after http fetch is available
+  bool forcePipe = (XRE_GetProcessType() != GeckoProcessType_Default);
+
+  if (!forcePipe && serial) {
+    stream = aStream;
+
+  // Otherwise we need to use a cross-process pipe
+  } else {
+    nsCOMPtr<nsICrossProcessPipe> pipe = CreateCrossProcessPipe(Sending);
+
+    nsCOMPtr<nsIAsyncInputStream> asyncStream;
+    nsresult rv = pipe->GetInputStream(getter_AddRefs(asyncStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    stream = asyncStream.forget();
+
+    nsCOMPtr<nsIAsyncOutputStream> pipeStream;
+    rv = pipe->GetOutputStream(getter_AddRefs(pipeStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    rv = NS_AsyncCopy(aStream, pipeStream, GetStreamThread());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+  }
+
+  MOZ_ASSERT(stream);
+
   PCacheReadStream readStream;
   nsTArray<FileDescriptor> fds;
-  SerializeInputStream(aStream, readStream.params(), fds);
+  SerializeInputStream(stream, readStream.params(), fds);
 
   PFileDescriptorSetChild* fdSet = nullptr;
   if (!fds.IsEmpty()) {
     // We should not be serializing until we have an actor ready
     PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
     MOZ_ASSERT(manager);
 
     fdSet = manager->SendPFileDescriptorSetConstructor(fds[0]);
