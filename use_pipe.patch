# HG changeset patch
# Parent ae376215a3ca56fdc806117b9cfd18bf207ff777
# User Ben Kelly <ben@wanderview.com>
Integrate CrossProcessPipe into Cache.

diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -9,16 +9,17 @@
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsIIPCSerializableInputStream.h"
@@ -104,21 +105,23 @@ ProcessURL(nsAString& aUrl, bool* aSchem
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::ipc::BackgroundChild;
+using mozilla::ipc::CreateCrossProcessPipe;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::OptionalFileDescriptorSet;
+using mozilla::ipc::Sending;
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const RequestOrUSVString& aIn,
                            BodyAction aBodyAction,
                            ReferrerAction aReferrerAction, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
@@ -496,21 +499,52 @@ TypeUtils::SerializeCacheStream(nsIInput
   }
 
   nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
   if (controlled) {
     controlled->Serialize(aStreamOut);
     return;
   }
 
-  // TODO: implement CrossProcessPipe if we cannot directly serialize (bug 1110814)
+  nsCOMPtr<nsIInputStream> stream;
+
   nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
-  if (!serial) {
-    aRv.Throw(NS_ERROR_FAILURE);
-    return;
+  if (false && serial) {
+    stream = aStream;
+  } else {
+    nsCOMPtr<nsICrossProcessPipe> pipe = CreateCrossProcessPipe(Sending);
+
+    nsresult rv = pipe->Init(nullptr, true);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    nsCOMPtr<nsIAsyncInputStream> asyncStream;
+    rv = pipe->GetInputStream(getter_AddRefs(asyncStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    stream = asyncStream.forget();
+
+    nsCOMPtr<nsIAsyncOutputStream> pipeStream;
+    rv = pipe->GetOutputStream(getter_AddRefs(pipeStream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
+
+    rv = NS_AsyncCopy(aStream, pipeStream, GetStreamThread(),
+                      NS_ASYNCCOPY_VIA_WRITESEGMENTS);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
   }
 
   PCacheReadStream readStream;
   readStream.controlChild() = nullptr;
   readStream.controlParent() = nullptr;
 
   nsTArray<FileDescriptor> fds;
   SerializeInputStream(aStream, readStream.params(), fds);
