# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2caacd5382773574cc4f91da2881520652344fc8
Bug 1459209 P9 Implement ServiceWorkerInfo::Listener::SetState() across back to the child-side binding layer. r=baku

diff --git a/dom/serviceworkers/PServiceWorker.ipdl b/dom/serviceworkers/PServiceWorker.ipdl
--- a/dom/serviceworkers/PServiceWorker.ipdl
+++ b/dom/serviceworkers/PServiceWorker.ipdl
@@ -2,26 +2,30 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 
 include ClientIPCTypes;
 include DOMTypes;
 
+using ServiceWorkerState from "mozilla/dom/ServiceWorkerIPCUtils.h";
+
 namespace mozilla {
 namespace dom {
 
 protocol PServiceWorker
 {
   manager PBackground;
 
 parent:
   async Teardown();
 
   async PostMessage(ClonedMessageData aClonedData, ClientInfoAndState aSource);
 
 child:
   async __delete__();
+
+  async SetState(ServiceWorkerState aState);
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
@@ -122,10 +122,19 @@ RemoteServiceWorkerImpl::RevokeActor(Ser
   MOZ_DIAGNOSTIC_ASSERT(mActor);
   MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
   mActor->RevokeOwner(this);
   mActor = nullptr;
 
   mShutdown = true;
 }
 
+void
+RemoteServiceWorkerImpl::SetState(ServiceWorkerState aState)
+{
+  if (!mWorker) {
+    return;
+  }
+  mWorker->SetState(aState);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerImpl.h b/dom/serviceworkers/RemoteServiceWorkerImpl.h
--- a/dom/serviceworkers/RemoteServiceWorkerImpl.h
+++ b/dom/serviceworkers/RemoteServiceWorkerImpl.h
@@ -37,15 +37,18 @@ class RemoteServiceWorkerImpl final : pu
               const ClientInfo& aClientInfo,
               const ClientState& aClientState) override;
 public:
   explicit RemoteServiceWorkerImpl(const ServiceWorkerDescriptor& aDescriptor);
 
   void
   RevokeActor(ServiceWorkerChild* aActor);
 
+  void
+  SetState(ServiceWorkerState aState);
+
   NS_INLINE_DECL_REFCOUNTING(RemoteServiceWorkerImpl, override)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_remoteserviceworkerimpl_h__
diff --git a/dom/serviceworkers/ServiceWorkerChild.cpp b/dom/serviceworkers/ServiceWorkerChild.cpp
--- a/dom/serviceworkers/ServiceWorkerChild.cpp
+++ b/dom/serviceworkers/ServiceWorkerChild.cpp
@@ -4,30 +4,41 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerChild.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::IPCResult;
+
 void
 ServiceWorkerChild::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mWorkerHolderToken) {
     mWorkerHolderToken->RemoveListener(this);
     mWorkerHolderToken = nullptr;
   }
 
   if (mOwner) {
     mOwner->RevokeActor(this);
     MOZ_DIAGNOSTIC_ASSERT(!mOwner);
   }
 }
 
+IPCResult
+ServiceWorkerChild::RecvSetState(const ServiceWorkerState& aState)
+{
+  if (mOwner) {
+    mOwner->SetState(aState);
+  }
+  return IPC_OK();
+}
+
 void
 ServiceWorkerChild::WorkerShuttingDown()
 {
   MaybeStartTeardown();
 }
 
 ServiceWorkerChild::ServiceWorkerChild(WorkerHolderToken* aWorkerHolderToken)
   : mWorkerHolderToken(aWorkerHolderToken)
diff --git a/dom/serviceworkers/ServiceWorkerChild.h b/dom/serviceworkers/ServiceWorkerChild.h
--- a/dom/serviceworkers/ServiceWorkerChild.h
+++ b/dom/serviceworkers/ServiceWorkerChild.h
@@ -21,16 +21,19 @@ class ServiceWorkerChild final : public 
   RefPtr<WorkerHolderToken> mWorkerHolderToken;
   RemoteServiceWorkerImpl* mOwner;
   bool mTeardownStarted;
 
   // PServiceWorkerChild
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
+  mozilla::ipc::IPCResult
+  RecvSetState(const ServiceWorkerState& aState) override;
+
   // WorkerHolderToken::Listener
   void
   WorkerShuttingDown() override;
 
 public:
   explicit ServiceWorkerChild(WorkerHolderToken* aWorkerHolderToken);
   ~ServiceWorkerChild() = default;
 
diff --git a/dom/serviceworkers/ServiceWorkerProxy.cpp b/dom/serviceworkers/ServiceWorkerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerProxy.cpp
@@ -32,17 +32,17 @@ ServiceWorkerProxy::MaybeShutdownOnBGThr
 
 void
 ServiceWorkerProxy::SetStateOnBGThread(ServiceWorkerState aState)
 {
   AssertIsOnBackgroundThread();
   if (!mActor) {
     return;
   }
-  // TODO send the state
+  Unused << mActor->SendSetState(aState);
 }
 
 void
 ServiceWorkerProxy::InitOnMainThread()
 {
   AssertIsOnMainThread();
 
   auto scopeExit = MakeScopeExit([&] {
