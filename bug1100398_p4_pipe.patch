# HG changeset patch
# Parent 1864cdca9d89a2f5a9ba276f67ab5ea77a36a1ac
# User Ben Kelly <ben@wanderview.com>
Bug 1100398 P4 Make nsPipeInputStream cloneable.

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -1,20 +1,22 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ReentrantMonitor.h"
+#include "nsICloneableInputStream.h"
 #include "nsIPipe.h"
 #include "nsIEventTarget.h"
 #include "nsISeekableStream.h"
 #include "nsIProgrammingLanguage.h"
+#include "nsRefPtr.h"
 #include "nsSegmentedBuffer.h"
 #include "nsStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsCRT.h"
 #include "prlog.h"
 #include "nsIClassInfoImpl.h"
 #include "nsAlgorithm.h"
 #include "nsMemory.h"
@@ -83,83 +85,126 @@ private:
   nsCOMPtr<nsIAsyncInputStream>     mInputStream;
   nsCOMPtr<nsIInputStreamCallback>  mInputCallback;
   nsCOMPtr<nsIAsyncOutputStream>    mOutputStream;
   nsCOMPtr<nsIOutputStreamCallback> mOutputCallback;
 };
 
 //-----------------------------------------------------------------------------
 
+// This class is used to maintain input stream state.  Its broken out from the
+// nsPipeInputStream class because generally the nsPipe should be modifying
+// this state and not the input stream itself.
+struct nsPipeReadState
+{
+  nsPipeReadState()
+    : mReadCursor(nullptr)
+    , mReadLimit(nullptr)
+    , mSegment(0)
+  { }
+
+  char*    mReadCursor;
+  char*    mReadLimit;
+  int32_t  mSegment;
+};
+
+//-----------------------------------------------------------------------------
+
 // the input end of a pipe (allocated as a member of the pipe).
 class nsPipeInputStream
   : public nsIAsyncInputStream
   , public nsISeekableStream
   , public nsISearchableInputStream
+  , public nsICloneableInputStream
   , public nsIClassInfo
 {
 public:
   // since this class will be allocated as a member of the pipe, we do not
   // need our own ref count.  instead, we share the lifetime (the ref count)
   // of the entire pipe.  this macro is just convenience since it does not
   // declare a mRefCount variable; however, don't let the name fool you...
   // we are not inheriting from nsPipe ;-)
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_NSIINPUTSTREAM
   NS_DECL_NSIASYNCINPUTSTREAM
   NS_DECL_NSISEEKABLESTREAM
   NS_DECL_NSISEARCHABLEINPUTSTREAM
+  NS_DECL_NSICLONEABLEINPUTSTREAM
   NS_DECL_NSICLASSINFO
 
   explicit nsPipeInputStream(nsPipe* aPipe)
     : mPipe(aPipe)
     , mReaderRefCnt(0)
     , mLogicalOffset(0)
     , mBlocking(true)
+    , mClosed(false)
     , mBlocked(false)
     , mAvailable(0)
     , mCallbackFlags(0)
   { }
 
+  explicit nsPipeInputStream(const nsPipeInputStream& aOther)
+    : mPipe(aOther.mPipe)
+    , mReaderRefCnt(0)
+    , mLogicalOffset(aOther.mLogicalOffset)
+    , mBlocking(aOther.mBlocking)
+    , mClosed(aOther.mClosed)
+    , mBlocked(false)
+    , mAvailable(aOther.mAvailable)
+    , mCallbackFlags(0)
+    , mReadState(aOther.mReadState)
+  { }
+
   nsresult Fill();
   void SetNonBlocking(bool aNonBlocking)
   {
     mBlocking = !aNonBlocking;
   }
 
   uint32_t Available()
   {
     return mAvailable;
   }
-  void ReduceAvailable(uint32_t aAvail)
-  {
-    mAvailable -= aAvail;
-  }
 
   // synchronously wait for the pipe to become readable.
   nsresult Wait();
 
   // these functions return true to indicate that the pipe's monitor should
   // be notified, to wake up a blocked reader if any.
   bool OnInputReadable(uint32_t aBytesWritten, nsPipeEvents&);
   bool OnInputException(nsresult, nsPipeEvents&);
 
+  nsPipeReadState& ReadState()
+  {
+    return mReadState;
+  }
+
+  const nsPipeReadState& ReadState() const
+  {
+    return mReadState;
+  }
+
 private:
   nsPipe*                        mPipe;
 
   // separate refcnt so that we know when to close the consumer
   mozilla::ThreadSafeAutoRefCnt  mReaderRefCnt;
   int64_t                        mLogicalOffset;
   bool                           mBlocking;
+  bool                           mClosed;
 
   // these variables can only be accessed while inside the pipe's monitor
   bool                           mBlocked;
   uint32_t                       mAvailable;
   nsCOMPtr<nsIInputStreamCallback> mCallback;
   uint32_t                       mCallbackFlags;
+
+  // treat as an opaque token to pass to nsPipe
+  nsPipeReadState                mReadState;
 };
 
 //-----------------------------------------------------------------------------
 
 // the output end of a pipe (allocated as a member of the pipe).
 class nsPipeOutputStream
   : public nsIAsyncOutputStream
   , public nsIClassInfo
@@ -235,43 +280,57 @@ public:
 private:
   ~nsPipe();
 
 public:
   //
   // methods below may only be called while inside the pipe's monitor
   //
 
-  void PeekSegment(uint32_t aIndex, char*& aCursor, char*& aLimit);
+  void PeekSegment(const nsPipeReadState& aReadState, uint32_t aIndex,
+                   char*& aCursor, char*& aLimit);
 
   //
   // methods below may be called while outside the pipe's monitor
   //
 
-  nsresult GetReadSegment(const char*& aSegment, uint32_t& aSegmentLen);
-  void     AdvanceReadCursor(uint32_t aCount);
+  nsresult GetReadSegment(const nsPipeReadState& aReadState,
+                          const char*& aSegment, uint32_t& aSegmentLen);
+  void     AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aCount,
+                             uint32_t* aAvailableOut);
 
   nsresult GetWriteSegment(char*& aSegment, uint32_t& aSegmentLen);
   void     AdvanceWriteCursor(uint32_t aCount);
 
+  void     CloseInputStream(nsPipeInputStream* aStream, nsresult aReason);
   void     OnPipeException(nsresult aReason, bool aOutputOnly = false);
 
+  nsresult CloneInputStream(nsPipeInputStream* aOriginal,
+                            nsIInputStream** aCloneOut);
+
 protected:
+  uint32_t CountSegmentReferences(int32_t aSegment) const;
+  void SetAllNullReadCursors();
+  bool AllReadCursorsMatchWriteCursor() const;
+  void RollBackAllReadCursors(char* aWriteCursor);
+  void UpdateAllReadCursors(char* aWriteCursor);
+  void ValidateAllReadCursors();
+
   // We can't inherit from both nsIInputStream and nsIOutputStream
   // because they collide on their Close method. Consequently we nest their
   // implementations to avoid the extra object allocation.
-  nsPipeInputStream   mInput;
   nsPipeOutputStream  mOutput;
 
+  // Since the input stream can be cloned, we may have more than one.  There
+  // will always be at least one stream in this list.
+  nsTArray<nsRefPtr<nsPipeInputStream>> mInputList;
+
   ReentrantMonitor    mReentrantMonitor;
   nsSegmentedBuffer   mBuffer;
 
-  char*               mReadCursor;
-  char*               mReadLimit;
-
   int32_t             mWriteSegment;
   char*               mWriteCursor;
   char*               mWriteLimit;
 
   nsresult            mStatus;
   bool                mInited;
 };
 
@@ -314,27 +373,25 @@ protected:
 // making changes to this file, please keep this fact in mind.
 //
 
 //-----------------------------------------------------------------------------
 // nsPipe methods:
 //-----------------------------------------------------------------------------
 
 nsPipe::nsPipe()
-  : mInput(MOZ_THIS_IN_INITIALIZER_LIST())
-  , mOutput(MOZ_THIS_IN_INITIALIZER_LIST())
+  : mOutput(MOZ_THIS_IN_INITIALIZER_LIST())
   , mReentrantMonitor("nsPipe.mReentrantMonitor")
-  , mReadCursor(nullptr)
-  , mReadLimit(nullptr)
   , mWriteSegment(-1)
   , mWriteCursor(nullptr)
   , mWriteLimit(nullptr)
   , mStatus(NS_OK)
   , mInited(false)
 {
+  mInputList.AppendElement(new nsPipeInputStream(this));
 }
 
 nsPipe::~nsPipe()
 {
 }
 
 NS_IMPL_ISUPPORTS(nsPipe, nsIPipe)
 
@@ -359,122 +416,150 @@ nsPipe::Init(bool aNonBlockingIn,
     aSegmentCount = maxCount;
   }
 
   nsresult rv = mBuffer.Init(aSegmentSize, aSegmentSize * aSegmentCount);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  mInput.SetNonBlocking(aNonBlockingIn);
+  MOZ_ASSERT(mInputList.Length() == 1);
+  mInputList[0]->SetNonBlocking(aNonBlockingIn);
+
   mOutput.SetNonBlocking(aNonBlockingOut);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPipe::GetInputStream(nsIAsyncInputStream** aInputStream)
 {
-  NS_ADDREF(*aInputStream = &mInput);
+  MOZ_ASSERT(mInputList.Length() > 0);
+  nsRefPtr<nsPipeInputStream> ref = mInputList[0];
+  ref.forget(aInputStream);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPipe::GetOutputStream(nsIAsyncOutputStream** aOutputStream)
 {
   if (NS_WARN_IF(!mInited)) {
     return NS_ERROR_NOT_INITIALIZED;
   }
   NS_ADDREF(*aOutputStream = &mOutput);
   return NS_OK;
 }
 
 void
-nsPipe::PeekSegment(uint32_t aIndex, char*& aCursor, char*& aLimit)
+nsPipe::PeekSegment(const nsPipeReadState& aReadState, uint32_t aIndex,
+                    char*& aCursor, char*& aLimit)
 {
   if (aIndex == 0) {
-    NS_ASSERTION(!mReadCursor || mBuffer.GetSegmentCount(), "unexpected state");
-    aCursor = mReadCursor;
-    aLimit = mReadLimit;
+    NS_ASSERTION(!aReadState.mReadCursor || mBuffer.GetSegmentCount(),
+                 "unexpected state");
+    aCursor = aReadState.mReadCursor;
+    aLimit = aReadState.mReadLimit;
   } else {
+    uint32_t absoluteIndex = aReadState.mSegment + aIndex;
     uint32_t numSegments = mBuffer.GetSegmentCount();
-    if (aIndex >= numSegments) {
+    if (absoluteIndex >= numSegments) {
       aCursor = aLimit = nullptr;
     } else {
-      aCursor = mBuffer.GetSegment(aIndex);
-      if (mWriteSegment == (int32_t)aIndex) {
+      aCursor = mBuffer.GetSegment(absoluteIndex);
+      if (mWriteSegment == (int32_t)absoluteIndex) {
         aLimit = mWriteCursor;
       } else {
         aLimit = aCursor + mBuffer.GetSegmentSize();
       }
     }
   }
 }
 
 nsresult
-nsPipe::GetReadSegment(const char*& aSegment, uint32_t& aSegmentLen)
+nsPipe::GetReadSegment(const nsPipeReadState& aReadState, const char*& aSegment,
+                       uint32_t& aSegmentLen)
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
-  if (mReadCursor == mReadLimit) {
+  if (aReadState.mReadCursor == aReadState.mReadLimit) {
     return NS_FAILED(mStatus) ? mStatus : NS_BASE_STREAM_WOULD_BLOCK;
   }
 
-  aSegment    = mReadCursor;
-  aSegmentLen = mReadLimit - mReadCursor;
+  aSegment    = aReadState.mReadCursor;
+  aSegmentLen = aReadState.mReadLimit - aReadState.mReadCursor;
   return NS_OK;
 }
 
 void
-nsPipe::AdvanceReadCursor(uint32_t aBytesRead)
+nsPipe::AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aBytesRead,
+                          uint32_t* aAvailableOut)
 {
   NS_ASSERTION(aBytesRead, "don't call if no bytes read");
 
   nsPipeEvents events;
   {
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     LOG(("III advancing read cursor by %u\n", aBytesRead));
     NS_ASSERTION(aBytesRead <= mBuffer.GetSegmentSize(), "read too much");
 
-    mReadCursor += aBytesRead;
-    NS_ASSERTION(mReadCursor <= mReadLimit, "read cursor exceeds limit");
+    aReadState.mReadCursor += aBytesRead;
+    NS_ASSERTION(aReadState.mReadCursor <= aReadState.mReadLimit,
+                 "read cursor exceeds limit");
 
-    mInput.ReduceAvailable(aBytesRead);
+    MOZ_ASSERT(*aAvailableOut >= aBytesRead);
+    *aAvailableOut -= aBytesRead;
 
-    if (mReadCursor == mReadLimit) {
+    if (aReadState.mReadCursor == aReadState.mReadLimit) {
       // we've reached the limit of how much we can read from this segment.
       // if at the end of this segment, then we must discard this segment.
 
       // if still writing in this segment then bail because we're not done
       // with the segment and have to wait for now...
-      if (mWriteSegment == 0 && mWriteLimit > mWriteCursor) {
-        NS_ASSERTION(mReadLimit == mWriteCursor, "unexpected state");
+      if (mWriteSegment == aReadState.mSegment && mWriteLimit > mWriteCursor) {
+        NS_ASSERTION(aReadState.mReadLimit == mWriteCursor, "unexpected state");
         return;
       }
 
-      // shift write segment index (-1 indicates an empty buffer).
-      --mWriteSegment;
+      uint32_t currentSegment = aReadState.mSegment;
 
-      // done with this segment
-      mBuffer.DeleteFirstSegment();
-      LOG(("III deleting first segment\n"));
+      // Move to the next segment to read
+      aReadState.mSegment += 1;
 
-      if (mWriteSegment == -1) {
-        // buffer is completely empty
-        mReadCursor = nullptr;
-        mReadLimit = nullptr;
-        mWriteCursor = nullptr;
-        mWriteLimit = nullptr;
+      // If this was the last reference to the first segment, then remove it.
+      if (currentSegment == 0 && CountSegmentReferences(currentSegment) == 0) {
+
+        // shift write and read segment index (-1 indicates an empty buffer).
+        mWriteSegment -= 1;
+
+        for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+          mInputList[i]->ReadState().mSegment -= 1;
+        }
+
+        // done with this segment
+        mBuffer.DeleteFirstSegment();
+        LOG(("III deleting first segment\n"));
+      }
+
+      if (mWriteSegment < aReadState.mSegment) {
+        // read cursor has hit the end of written data, so reset it
+        MOZ_ASSERT(mWriteSegment == (aReadState.mSegment - 1));
+        aReadState.mReadCursor = nullptr;
+        aReadState.mReadLimit = nullptr;
+        // also, the buffer is completely empty, so reset the write cursor
+        if (mWriteSegment == -1) {
+          mWriteCursor = nullptr;
+          mWriteLimit = nullptr;
+        }
       } else {
         // advance read cursor and limit to next buffer segment
-        mReadCursor = mBuffer.GetSegment(0);
-        if (mWriteSegment == 0) {
-          mReadLimit = mWriteCursor;
+        aReadState.mReadCursor = mBuffer.GetSegment(aReadState.mSegment);
+        if (mWriteSegment == aReadState.mSegment) {
+          aReadState.mReadLimit = mWriteCursor;
         } else {
-          mReadLimit = mReadCursor + mBuffer.GetSegmentSize();
+          aReadState.mReadLimit = aReadState.mReadCursor + mBuffer.GetSegmentSize();
         }
       }
 
       // we've free'd up a segment, so notify output stream that pipe has
       // room for a new segment.
       if (mOutput.OnOutputWritable(events)) {
         mon.Notify();
       }
@@ -500,27 +585,25 @@ nsPipe::GetWriteSegment(char*& aSegment,
     }
     LOG(("OOO appended new segment\n"));
     mWriteCursor = seg;
     mWriteLimit = mWriteCursor + mBuffer.GetSegmentSize();
     ++mWriteSegment;
   }
 
   // make sure read cursor is initialized
-  if (!mReadCursor) {
-    NS_ASSERTION(mWriteSegment == 0, "unexpected null read cursor");
-    mReadCursor = mReadLimit = mWriteCursor;
-  }
+  SetAllNullReadCursors();
 
   // check to see if we can roll-back our read and write cursors to the
   // beginning of the current/first segment.  this is purely an optimization.
-  if (mReadCursor == mWriteCursor && mWriteSegment == 0) {
+  if (mWriteSegment == 0 && AllReadCursorsMatchWriteCursor()) {
     char* head = mBuffer.GetSegment(0);
     LOG(("OOO rolling back write cursor %u bytes\n", mWriteCursor - head));
-    mWriteCursor = mReadCursor = mReadLimit = head;
+    RollBackAllReadCursors(head);
+    mWriteCursor = head;
   }
 
   aSegment    = mWriteCursor;
   aSegmentLen = mWriteLimit - mWriteCursor;
   return NS_OK;
 }
 
 void
@@ -533,94 +616,213 @@ nsPipe::AdvanceWriteCursor(uint32_t aByt
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     LOG(("OOO advancing write cursor by %u\n", aBytesWritten));
 
     char* newWriteCursor = mWriteCursor + aBytesWritten;
     NS_ASSERTION(newWriteCursor <= mWriteLimit, "write cursor exceeds limit");
 
     // update read limit if reading in the same segment
-    if (mWriteSegment == 0 && mReadLimit == mWriteCursor) {
-      mReadLimit = newWriteCursor;
-    }
+    UpdateAllReadCursors(newWriteCursor);
 
     mWriteCursor = newWriteCursor;
 
-    // The only way mReadCursor == mWriteCursor is if:
-    //
-    // - mReadCursor is at the start of a segment (which, based on how
-    //   nsSegmentedBuffer works, means that this segment is the "first"
-    //   segment)
-    // - mWriteCursor points at the location past the end of the current
-    //   write segment (so the current write filled the current write
-    //   segment, so we've incremented mWriteCursor to point past the end
-    //   of it)
-    // - the segment to which data has just been written is located
-    //   exactly one segment's worth of bytes before the first segment
-    //   where mReadCursor is located
-    //
-    // Consequently, the byte immediately after the end of the current
-    // write segment is the first byte of the first segment, so
-    // mReadCursor == mWriteCursor.  (Another way to think about this is
-    // to consider the buffer architecture diagram above, but consider it
-    // with an arena allocator which allocates from the *end* of the
-    // arena to the *beginning* of the arena.)
-    NS_ASSERTION(mReadCursor != mWriteCursor ||
-                 (mBuffer.GetSegment(0) == mReadCursor &&
-                  mWriteCursor == mWriteLimit),
-                 "read cursor is bad");
+    ValidateAllReadCursors();
 
     // update the writable flag on the output stream
     if (mWriteCursor == mWriteLimit) {
       if (mBuffer.GetSize() >= mBuffer.GetMaxSize()) {
         mOutput.SetWritable(false);
       }
     }
 
     // notify input stream that pipe now contains additional data
-    if (mInput.OnInputReadable(aBytesWritten, events)) {
-      mon.Notify();
+    for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+      if (mInputList[i]->OnInputReadable(aBytesWritten, events)) {
+        mon.Notify();
+      }
     }
   }
 }
 
 void
+nsPipe::CloseInputStream(nsPipeInputStream* aStream, nsresult aReason)
+{
+  nsPipeEvents events;
+  {
+    ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+
+    for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+      if (mInputList[i].get() != aStream) {
+        continue;
+      }
+
+      // If there are more input streams open, then simply notify
+      // this stream, remove it from the list, and allow the remaining
+      // streams to continue functioning
+      if (mInputList.Length() > 1) {
+        if (mInputList[i]->OnInputException(aReason, events)) {
+          mon.Notify();
+        }
+        mInputList.RemoveElementAt(i);
+        return;
+      }
+
+      // Otherwise, this is the last input stream being closed.  Since
+      // there will be no way to get another open input stream, just
+      // shut the whole pipe down.
+      OnPipeException(aReason);
+      return;
+    }
+  }
+
+  MOZ_ASSERT_UNREACHABLE("Closing unknown pipe stream!");
+}
+
+void
 nsPipe::OnPipeException(nsresult aReason, bool aOutputOnly)
 {
   LOG(("PPP nsPipe::OnPipeException [reason=%x output-only=%d]\n",
        aReason, aOutputOnly));
 
   nsPipeEvents events;
   {
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     // if we've already hit an exception, then ignore this one.
     if (NS_FAILED(mStatus)) {
       return;
     }
 
     mStatus = aReason;
 
-    // an output-only exception applies to the input end if the pipe has
-    // zero bytes available.
-    if (aOutputOnly && !mInput.Available()) {
-      aOutputOnly = false;
-    }
+    for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+      // an output-only exception applies to the input end if the pipe has
+      // zero bytes available.
+      if (aOutputOnly && mInputList[i]->Available()) {
+        continue;
+      }
 
-    if (!aOutputOnly)
-      if (mInput.OnInputException(aReason, events)) {
+      if (mInputList[i]->OnInputException(aReason, events)) {
         mon.Notify();
       }
+    }
 
     if (mOutput.OnOutputException(aReason, events)) {
       mon.Notify();
     }
   }
 }
 
+nsresult
+nsPipe::CloneInputStream(nsPipeInputStream* aOriginal,
+                         nsIInputStream** aCloneOut)
+{
+  nsRefPtr<nsPipeInputStream> ref = new nsPipeInputStream(*aOriginal);
+  mInputList.AppendElement(ref);
+  ref.forget(aCloneOut);
+  return NS_OK;
+}
+
+uint32_t
+nsPipe::CountSegmentReferences(int32_t aSegment) const
+{
+  uint32_t count = 0;
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    if (aSegment >= mInputList[i]->ReadState().mSegment) {
+      count += 1;
+    }
+  }
+  return count;
+}
+
+void
+nsPipe::SetAllNullReadCursors()
+{
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    nsPipeReadState& readState = mInputList[i]->ReadState();
+    if (!readState.mReadCursor) {
+      NS_ASSERTION(mWriteSegment == readState.mSegment,
+                   "unexpected null read cursor");
+      readState.mReadCursor = readState.mReadLimit = mWriteCursor;
+    }
+  }
+}
+
+bool
+nsPipe::AllReadCursorsMatchWriteCursor() const
+{
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    const nsPipeReadState& readState = mInputList[i]->ReadState();
+    if (readState.mSegment != mWriteSegment ||
+        readState.mReadCursor != mWriteCursor) {
+      return false;
+    }
+  }
+  return true;
+}
+
+void
+nsPipe::RollBackAllReadCursors(char* aWriteCursor)
+{
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    nsPipeReadState& readState = mInputList[i]->ReadState();
+    MOZ_ASSERT(mWriteSegment == readState.mSegment);
+    MOZ_ASSERT(mWriteCursor == readState.mReadCursor);
+    MOZ_ASSERT(mWriteCursor == readState.mReadLimit);
+    readState.mReadCursor = aWriteCursor;
+    readState.mReadLimit = aWriteCursor;
+  }
+}
+
+void
+nsPipe::UpdateAllReadCursors(char* aWriteCursor)
+{
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    nsPipeReadState& readState = mInputList[i]->ReadState();
+    if (mWriteSegment == readState.mSegment &&
+        readState.mReadLimit == mWriteCursor) {
+      readState.mReadLimit = aWriteCursor;
+    }
+  }
+}
+
+void
+nsPipe::ValidateAllReadCursors()
+{
+  // The only way mReadCursor == mWriteCursor is if:
+  //
+  // - mReadCursor is at the start of a segment (which, based on how
+  //   nsSegmentedBuffer works, means that this segment is the "first"
+  //   segment)
+  // - mWriteCursor points at the location past the end of the current
+  //   write segment (so the current write filled the current write
+  //   segment, so we've incremented mWriteCursor to point past the end
+  //   of it)
+  // - the segment to which data has just been written is located
+  //   exactly one segment's worth of bytes before the first segment
+  //   where mReadCursor is located
+  //
+  // Consequently, the byte immediately after the end of the current
+  // write segment is the first byte of the first segment, so
+  // mReadCursor == mWriteCursor.  (Another way to think about this is
+  // to consider the buffer architecture diagram above, but consider it
+  // with an arena allocator which allocates from the *end* of the
+  // arena to the *beginning* of the arena.)
+#ifdef DEBUG
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    const nsPipeReadState& state = mInputList[i]->ReadState();
+    NS_ASSERTION(state.mReadCursor != mWriteCursor ||
+                 (mBuffer.GetSegment(state.mSegment) == state.mReadCursor &&
+                  mWriteCursor == mWriteLimit),
+                 "read cursor is bad");
+  }
+#endif
+}
+
 //-----------------------------------------------------------------------------
 // nsPipeEvents methods:
 //-----------------------------------------------------------------------------
 
 nsPipeEvents::~nsPipeEvents()
 {
   // dispatch any pending events
 
@@ -640,23 +842,25 @@ nsPipeEvents::~nsPipeEvents()
 // nsPipeInputStream methods:
 //-----------------------------------------------------------------------------
 
 NS_IMPL_QUERY_INTERFACE(nsPipeInputStream,
                         nsIInputStream,
                         nsIAsyncInputStream,
                         nsISeekableStream,
                         nsISearchableInputStream,
+                        nsICloneableInputStream,
                         nsIClassInfo)
 
 NS_IMPL_CI_INTERFACE_GETTER(nsPipeInputStream,
                             nsIInputStream,
                             nsIAsyncInputStream,
                             nsISeekableStream,
-                            nsISearchableInputStream)
+                            nsISearchableInputStream,
+                            nsICloneableInputStream)
 
 NS_IMPL_THREADSAFE_CI(nsPipeInputStream)
 
 nsresult
 nsPipeInputStream::Wait()
 {
   NS_ASSERTION(mBlocking, "wait on non-blocking pipe input stream");
 
@@ -734,21 +938,27 @@ nsPipeInputStream::Release(void)
   return mPipe->Release();
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::CloseWithStatus(nsresult aReason)
 {
   LOG(("III CloseWithStatus [this=%x reason=%x]\n", this, aReason));
 
+  if (mClosed) {
+    return NS_OK;
+  }
+
+  mClosed = true;
+
   if (NS_SUCCEEDED(aReason)) {
     aReason = NS_BASE_STREAM_CLOSED;
   }
 
-  mPipe->OnPipeException(aReason);
+  mPipe->CloseInputStream(this, aReason);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::Close()
 {
   return CloseWithStatus(NS_BASE_STREAM_CLOSED);
 }
@@ -778,17 +988,17 @@ nsPipeInputStream::ReadSegments(nsWriteS
 
   nsresult rv = NS_OK;
 
   const char* segment;
   uint32_t segmentLen;
 
   *aReadCount = 0;
   while (aCount) {
-    rv = mPipe->GetReadSegment(segment, segmentLen);
+    rv = mPipe->GetReadSegment(mReadState, segment, segmentLen);
     if (NS_FAILED(rv)) {
       // ignore this error if we've already read something.
       if (*aReadCount > 0) {
         rv = NS_OK;
         break;
       }
       if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
         // pipe is empty
@@ -833,17 +1043,17 @@ nsPipeInputStream::ReadSegments(nsWriteS
       segment += writeCount;
       segmentLen -= writeCount;
       aCount -= writeCount;
       *aReadCount += writeCount;
       mLogicalOffset += writeCount;
     }
 
     if (segmentLen < originalLen) {
-      mPipe->AdvanceReadCursor(originalLen - segmentLen);
+      mPipe->AdvanceReadCursor(mReadState, originalLen - segmentLen, &mAvailable);
     }
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::Read(char* aToBuf, uint32_t aBufLen, uint32_t* aReadCount)
@@ -940,17 +1150,17 @@ nsPipeInputStream::Search(const char* aF
 
   ReentrantMonitorAutoEnter mon(mPipe->mReentrantMonitor);
 
   char* cursor1;
   char* limit1;
   uint32_t index = 0, offset = 0;
   uint32_t strLen = strlen(aForString);
 
-  mPipe->PeekSegment(0, cursor1, limit1);
+  mPipe->PeekSegment(mReadState, 0, cursor1, limit1);
   if (cursor1 == limit1) {
     *aFound = false;
     *aOffsetSearchedTo = 0;
     LOG(("  result [aFound=%u offset=%u]\n", *aFound, *aOffsetSearchedTo));
     return NS_OK;
   }
 
   while (true) {
@@ -969,17 +1179,17 @@ nsPipeInputStream::Search(const char* aF
     // get the next segment
     char* cursor2;
     char* limit2;
     uint32_t len2;
 
     index++;
     offset += len1;
 
-    mPipe->PeekSegment(index, cursor2, limit2);
+    mPipe->PeekSegment(mReadState, index, cursor2, limit2);
     if (cursor2 == limit2) {
       *aFound = false;
       *aOffsetSearchedTo = offset - strLen + 1;
       LOG(("  result [aFound=%u offset=%u]\n", *aFound, *aOffsetSearchedTo));
       return NS_OK;
     }
     len2 = limit2 - cursor2;
 
@@ -1003,16 +1213,29 @@ nsPipeInputStream::Search(const char* aF
     cursor1 = cursor2;
     limit1 = limit2;
   }
 
   NS_NOTREACHED("can't get here");
   return NS_ERROR_UNEXPECTED;    // keep compiler happy
 }
 
+NS_IMETHODIMP
+nsPipeInputStream::GetCloneable(bool* aCloneableOut)
+{
+  *aCloneableOut = true;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPipeInputStream::Clone(nsIInputStream** aCloneOut)
+{
+  return mPipe->CloneInputStream(this, aCloneOut);
+}
+
 //-----------------------------------------------------------------------------
 // nsPipeOutputStream methods:
 //-----------------------------------------------------------------------------
 
 NS_IMPL_QUERY_INTERFACE(nsPipeOutputStream,
                         nsIOutputStream,
                         nsIAsyncOutputStream,
                         nsIClassInfo)
diff --git a/xpcom/tests/gtest/TestPipe.cpp b/xpcom/tests/gtest/TestPipe.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/gtest/TestPipe.cpp
@@ -0,0 +1,274 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <algorithm>
+#include "gtest/gtest.h"
+#include "nsCOMPtr.h"
+#include "nsICloneableInputStream.h"
+#include "nsIInputStream.h"
+#include "nsIOutputStream.h"
+#include "nsIPipe.h"
+#include "nsStreamUtils.h"
+#include "nsString.h"
+#include "TestHelpers.h"
+
+namespace {
+
+static const uint32_t DEFAULT_SEGMENT_SIZE = 4 * 1024;
+
+static void TestPipe(uint32_t aNumBytes,
+                     uint32_t aSegmentSize = DEFAULT_SEGMENT_SIZE)
+{
+  nsCOMPtr<nsIInputStream> reader;
+  nsCOMPtr<nsIOutputStream> writer;
+
+  uint32_t maxSize = std::max(aNumBytes, aSegmentSize);
+
+  nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer),
+                           aSegmentSize, maxSize);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+  testing::CreateData(aNumBytes, inputData);
+
+  testing::WriteAllAndClose(writer, inputData);
+
+  nsAutoCString outputData;
+  rv = NS_ConsumeStream(reader, UINT32_MAX, outputData);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_EQ(inputData.Length(), outputData.Length());
+}
+
+// Utility routine to validate pipe clone before.  There are many knobs.
+//
+// aTotalBytes              Total number of bytes to write to the pipe.
+// aNumWrites               How many separate write calls should be made.  Bytes
+//                          are evenly distributed over these write calls.
+// aNumInitialClones        How many clones of the pipe input stream should be
+//                          made before writing begins.
+// aNumToCloseAfterWrite    How many streams should be closed after each write.
+//                          One stream is always kept open.  This verifies that
+//                          closing one stream does not effect other open
+//                          streams.
+// aNumToCloneAfterWrite    How many clones to create after each write.  Occurs
+//                          after closing any streams.  This tests cloning
+//                          active streams on a pipe that is being written to.
+// aNumStreamToReadPerWrite How many streams to read fully after each write.
+//                          This tests reading cloned streams at different rates
+//                          while the pipe is being written to.
+static void TestPipeClone(uint32_t aTotalBytes,
+                          uint32_t aNumWrites,
+                          uint32_t aNumInitialClones,
+                          uint32_t aNumToCloseAfterWrite,
+                          uint32_t aNumToCloneAfterWrite,
+                          uint32_t aNumStreamsToReadPerWrite,
+                          uint32_t aSegmentSize = DEFAULT_SEGMENT_SIZE)
+{
+  nsCOMPtr<nsIInputStream> reader;
+  nsCOMPtr<nsIOutputStream> writer;
+
+  uint32_t maxSize = std::max(aTotalBytes, aSegmentSize);
+
+  // Use async input streams so we can NS_ConsumeStream() the current data
+  // while the pipe is still being written to.
+  nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer),
+                           aSegmentSize, maxSize,
+                           true, false); // non-blocking - reader, writer
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsICloneableInputStream> cloneable = do_QueryInterface(reader);
+  ASSERT_TRUE(cloneable);
+
+  bool canClone;
+  rv = cloneable->GetCloneable(&canClone);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+  ASSERT_TRUE(canClone);
+
+  nsTArray<nsCString> outputDataList;
+
+  nsTArray<nsCOMPtr<nsIInputStream>> streamList;
+
+  // first stream is our original reader from the pipe
+  streamList.AppendElement(reader);
+  outputDataList.AppendElement();
+
+  // Clone the initial input stream the specified number of times
+  // before performing any writes.
+  for (uint32_t i = 0; i < aNumInitialClones; ++i) {
+    nsCOMPtr<nsIInputStream>* clone = streamList.AppendElement();
+    rv = cloneable->Clone(getter_AddRefs(*clone));
+    ASSERT_TRUE(NS_SUCCEEDED(rv));
+    ASSERT_TRUE(*clone);
+
+    outputDataList.AppendElement();
+  }
+
+  nsTArray<char> inputData;
+  testing::CreateData(aTotalBytes, inputData);
+
+  const uint32_t bytesPerWrite = ((aTotalBytes - 1)/ aNumWrites) + 1;
+  uint32_t offset = 0;
+  uint32_t remaining = aTotalBytes;
+  uint32_t nextStreamToRead = 0;
+
+  while (remaining) {
+    uint32_t numToWrite = std::min(bytesPerWrite, remaining);
+    testing::Write(writer, inputData, offset, numToWrite);
+    offset += numToWrite;
+    remaining -= numToWrite;
+
+    // Close the specified number of streams.  This allows us to
+    // test that one closed clone does not break other open clones.
+    for (uint32_t i = 0; i < aNumToCloseAfterWrite &&
+                         streamList.Length() > 1; ++i) {
+
+      uint32_t lastIndex = streamList.Length() - 1;
+      streamList[lastIndex]->Close();
+      streamList.RemoveElementAt(lastIndex);
+      outputDataList.RemoveElementAt(lastIndex);
+
+      if (nextStreamToRead >= streamList.Length()) {
+        nextStreamToRead = 0;
+      }
+    }
+
+    // Create the specified number of clones.  This lets us verify
+    // that we can create clones in the middle of pipe reading and
+    // writing.
+    for (uint32_t i = 0; i < aNumToCloneAfterWrite; ++i) {
+      nsCOMPtr<nsIInputStream>* clone = streamList.AppendElement();
+      rv = cloneable->Clone(getter_AddRefs(*clone));
+      ASSERT_TRUE(NS_SUCCEEDED(rv));
+      ASSERT_TRUE(*clone);
+
+      // Initialize the new output data to make whats been read to data for
+      // the original stream.  First stream is always the original stream.
+      nsCString* outputData = outputDataList.AppendElement();
+      *outputData = outputDataList[0];
+    }
+
+    // Read the specified number of streams.  This lets us verify that we
+    // can read from the clones at different rates while the pipe is being
+    // written to.
+    for (uint32_t i = 0; i < aNumStreamsToReadPerWrite; ++i) {
+      nsCOMPtr<nsIInputStream>& stream = streamList[nextStreamToRead];
+      nsCString& outputData = outputDataList[nextStreamToRead];
+
+      nsAutoCString tmpOutputData;
+      rv = NS_ConsumeStream(stream, UINT32_MAX, tmpOutputData);
+      ASSERT_TRUE(rv == NS_BASE_STREAM_WOULD_BLOCK || NS_SUCCEEDED(rv));
+      ASSERT_GE(tmpOutputData.Length(), numToWrite);
+
+      outputData += tmpOutputData;
+
+      nextStreamToRead += 1;
+      if (nextStreamToRead >= streamList.Length()) {
+        // Note: When we wrap around on the streams being read, its possible
+        //       we will trigger a segment to be deleted from the pipe.  It
+        //       would be nice to validate this here, but we don't have any
+        //       QI'able interface that would let us check easily.
+
+        nextStreamToRead = 0;
+      }
+    }
+  }
+
+  rv = writer->Close();
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  // Finally, read the remaining bytes from each stream.  This may be
+  // different amounts of data depending on how much reading we did while
+  // writing.  Verify that the end result matches the input data.
+  for (uint32_t i = 0; i < streamList.Length(); ++i) {
+    nsCOMPtr<nsIInputStream>& stream = streamList[i];
+    nsCString& outputData = outputDataList[i];
+
+    nsAutoCString tmpOutputData;
+    rv = NS_ConsumeStream(stream, UINT32_MAX, tmpOutputData);
+    ASSERT_TRUE(rv == NS_BASE_STREAM_WOULD_BLOCK || NS_SUCCEEDED(rv));
+    stream->Close();
+
+    outputData += tmpOutputData;
+
+    ASSERT_EQ(inputData.Length(), outputData.Length());
+  }
+}
+
+} // anonymous namespace
+
+TEST(Pipe, Blocking_32k)
+{
+  TestPipe(32 * 1024);
+}
+
+TEST(Pipe, Blocking_64k)
+{
+  TestPipe(64 * 1024);
+}
+
+TEST(Pipe, Blocking_128k)
+{
+  TestPipe(128 * 1024);
+}
+
+TEST(Pipe, Clone_BeforeWrite_ReadAtEnd)
+{
+  TestPipeClone(32 * 1024, // total bytes
+                16,        // num writes
+                3,         // num initial clones
+                0,         // num streams to close after each write
+                0,         // num clones to add after each write
+                0);        // num streams to read after each write
+}
+
+TEST(Pipe, Clone_BeforeWrite_ReadDuringWrite)
+{
+  // Since this reads all streams on every write, it should trigger the
+  // pipe cursor roll back optimization.  Currently we can only verify
+  // this with logging.
+
+  TestPipeClone(32 * 1024, // total bytes
+                16,        // num writes
+                3,         // num initial clones
+                0,         // num streams to close after each write
+                0,         // num clones to add after each write
+                4);        // num streams to read after each write
+}
+
+TEST(Pipe, Clone_DuringWrite_ReadAtEnd)
+{
+  TestPipeClone(32 * 1024, // total bytes
+                16,        // num writes
+                0,         // num initial clones
+                0,         // num streams to close after each write
+                1,         // num clones to add after each write
+                0);        // num streams to read after each write
+}
+
+TEST(Pipe, Clone_DuringWrite_ReadDuringWrite)
+{
+  TestPipeClone(32 * 1024, // total bytes
+                16,        // num writes
+                0,         // num initial clones
+                0,         // num streams to close after each write
+                1,         // num clones to add after each write
+                1);        // num streams to read after each write
+}
+
+TEST(Pipe, Clone_DuringWrite_ReadDuringWrite_CloseDuringWrite)
+{
+  // Since this reads streams faster than we clone new ones, it should
+  // trigger pipe segment deletion periodically.  Currently we can
+  // only verify this with logging.
+
+  TestPipeClone(32 * 1024, // total bytes
+                16,        // num writes
+                1,         // num initial clones
+                1,         // num streams to close after each write
+                2,         // num clones to add after each write
+                3);        // num streams to read after each write
+}
diff --git a/xpcom/tests/gtest/moz.build b/xpcom/tests/gtest/moz.build
--- a/xpcom/tests/gtest/moz.build
+++ b/xpcom/tests/gtest/moz.build
@@ -1,14 +1,15 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 UNIFIED_SOURCES += [
     'TestHelpers.cpp',
+    'TestPipe.cpp',
     'TestSnappyStreams.cpp',
 ]
 
 FINAL_LIBRARY = 'xul-gtest'
 
 FAIL_ON_WARNINGS = True
