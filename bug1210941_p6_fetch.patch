# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e9f6bdc7000f9bc539efe7fd97e023a0d731482b
Bug 1210941 P6 Use LOAD_BYPASS_SERVICE_WORKER instead of ForceNoIntercept in FetchDriver. r=ehsan

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -423,28 +423,34 @@ FetchDriver::HttpFetch(bool aCORSFlag, b
   }
 
   // This is effectivetly the opposite of the use credentials flag in "HTTP
   // network or cache fetch" in the spec and decides whether to transmit
   // cookies and other identifying information. LOAD_ANONYMOUS also prevents
   // new cookies sent by the server from being stored.
   const nsLoadFlags credentialsFlag = useCredentials ? 0 : nsIRequest::LOAD_ANONYMOUS;
 
+  // Set skip serviceworker flag.
+  // While the spec also gates on the client being a ServiceWorker, we can't
+  // infer that here. Instead we rely on callers to set the flag correctly.
+  const nsLoadFlags bypassFlag = mRequest->SkipServiceWorker() ?
+                                 nsIChannel::LOAD_BYPASS_SERVICE_WORKER : 0;
+
   // From here on we create a channel and set its properties with the
   // information from the InternalRequest. This is an implementation detail.
   MOZ_ASSERT(mLoadGroup);
   nsCOMPtr<nsIChannel> chan;
   rv = NS_NewChannel(getter_AddRefs(chan),
                      uri,
                      mPrincipal,
                      nsILoadInfo::SEC_NORMAL,
                      mRequest->ContentPolicyType(),
                      mLoadGroup,
                      nullptr, /* aCallbacks */
-                     nsIRequest::LOAD_NORMAL | credentialsFlag,
+                     nsIRequest::LOAD_NORMAL | credentialsFlag | bypassFlag,
                      ios);
   mLoadGroup = nullptr;
   if (NS_WARN_IF(NS_FAILED(rv))) {
     FailWithNetworkError();
     return rv;
   }
 
   // Insert ourselves into the notification callbacks chain so we can handle
@@ -570,31 +576,16 @@ FetchDriver::HttpFetch(bool aCORSFlag, b
       mRequest->GetMethod(method);
       rv = uploadChan->ExplicitSetUploadStream(bodyStream, contentType, -1, method, false /* aStreamHasHeaders */);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return FailWithNetworkError();
       }
     }
   }
 
-  // Set skip serviceworker flag.
-  // While the spec also gates on the client being a ServiceWorker, we can't
-  // infer that here. Instead we rely on callers to set the flag correctly.
-  if (mRequest->SkipServiceWorker()) {
-    if (httpChan) {
-      nsCOMPtr<nsIHttpChannelInternal> internalChan = do_QueryInterface(httpChan);
-      internalChan->ForceNoIntercept();
-    } else {
-      nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(chan);
-      // If it is not an http channel, it has to be a jar one.
-      MOZ_ASSERT(jarChannel);
-      jarChannel->ForceNoIntercept();
-    }
-  }
-
   nsCOMPtr<nsIStreamListener> listener = this;
 
   // Only use nsCORSListenerProxy if we are in CORS mode.  Otherwise it
   // will overwrite the CorsMode flag unconditionally to "cors" or
   // "cors-with-forced-preflight".
   if (mRequest->Mode() == RequestMode::Cors) {
     // Set up a CORS proxy that will handle the various requirements of the CORS
     // protocol. It handles the preflight cache and CORS response headers.
