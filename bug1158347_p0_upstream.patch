# HG changeset patch
# Parent c478b52e0ec287e57da233dafa3524788c3eee3c
# User Ben Kelly <ben@wanderview.com>
Bug 1158347 Fallback to ServiceWorker.postMessage() when MessageChannel not available.

diff --git a/testing/web-platform/tests/resources/testharness.js b/testing/web-platform/tests/resources/testharness.js
--- a/testing/web-platform/tests/resources/testharness.js
+++ b/testing/web-platform/tests/resources/testharness.js
@@ -363,18 +363,25 @@ policies and contribution forms [3].
     function ServiceWorkerTestEnvironment() {
         WorkerTestEnvironment.call(this);
         this.all_loaded = false;
         this.on_loaded_callback = null;
         var this_obj = this;
         self.addEventListener("message",
                 function(event) {
                     if (event.data.type && event.data.type === "connect") {
+                      // MessageChannel mode
+                      if (event.ports && event.ports[0]) {
                         this_obj._add_message_port(event.ports[0]);
                         event.ports[0].start();
+
+                      // ServiceWorker.postMessage mode
+                      } else {
+                        this_obj._add_message_port(event.source);
+                      }
                     }
                 });
 
         // The oninstall event is received after the service worker script and
         // all imported scripts have been fetched and executed. It's the
         // equivalent of an onload event for a document. All tests should have
         // been added by the time this event is received, thus it's not
         // necessary to wait until the onactivate event.
@@ -1476,20 +1483,29 @@ policies and contribution forms [3].
         var message_port;
 
         if (is_service_worker(worker)) {
             // The ServiceWorker's implicit MessagePort is currently not
             // reliably accessible from the ServiceWorkerGlobalScope due to
             // Blink setting MessageEvent.source to null for messages sent via
             // ServiceWorker.postMessage(). Until that's resolved, create an
             // explicit MessageChannel and pass one end to the worker.
-            var message_channel = new MessageChannel();
-            message_port = message_channel.port1;
-            message_port.start();
-            worker.postMessage({type: "connect"}, [message_channel.port2]);
+            if (window.MessageChannel) {
+              var message_channel = new MessageChannel();
+              message_port = message_channel.port1;
+              message_port.start();
+              worker.postMessage({type: "connect"}, [message_channel.port2]);
+
+            // If MessageChannel is not available, then try the
+            // ServiceWorker.postMessage() approach using MessageEvent.source
+            // on the other end.
+            } else {
+              message_port = navigator.serviceWorker;
+              worker.postMessage({type: "connect"});
+            }
         } else if (is_shared_worker(worker)) {
             message_port = worker.port;
         } else {
             message_port = worker;
         }
 
         // Keeping a reference to the worker until worker_done() is seen
         // prevents the Worker object and its MessageChannel from going away
