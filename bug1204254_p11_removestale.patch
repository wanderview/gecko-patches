# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  eb4a3ff48f2e5a7b529bf9086adf02d8def8be4a
Bug 1204254 P11 Remove nsIInterceptedChannel.responseBody and backing nsPipe code. r=asuth

diff --git a/netwerk/base/nsINetworkInterceptController.idl b/netwerk/base/nsINetworkInterceptController.idl
--- a/netwerk/base/nsINetworkInterceptController.idl
+++ b/netwerk/base/nsINetworkInterceptController.idl
@@ -92,21 +92,16 @@ interface nsIInterceptedChannel : nsISup
     /**
      * Cancel the pending intercepted request.
      * @return NS_ERROR_FAILURE if the response has already been synthesized or
      *         the original request has been instructed to continue.
      */
     void cancelInterception(in nsresult status);
 
     /**
-     * The synthesized response body to be produced.
-     */
-    readonly attribute nsIOutputStream responseBody;
-
-    /**
      * The underlying channel object that was intercepted.
      */
     readonly attribute nsIChannel channel;
 
     /**
      * The URL of the underlying channel object, corrected for a potential
      * secure upgrade.
      */
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -45,23 +45,16 @@ InterceptedChannelBase::InterceptedChann
   , mSynthesizedOrReset(Invalid)
 {
 }
 
 InterceptedChannelBase::~InterceptedChannelBase()
 {
 }
 
-NS_IMETHODIMP
-InterceptedChannelBase::GetResponseBody(nsIOutputStream** aStream)
-{
-  NS_IF_ADDREF(*aStream = mResponseBody);
-  return NS_OK;
-}
-
 void
 InterceptedChannelBase::EnsureSynthesizedResponse()
 {
   if (mSynthesizedResponseHead.isNothing()) {
     mSynthesizedResponseHead.emplace(new nsHttpResponseHead());
   }
 }
 
@@ -224,21 +217,16 @@ InterceptedChannelContent::InterceptedCh
 , mStreamListener(aListener)
 , mSecureUpgrade(aSecureUpgrade)
 {
 }
 
 void
 InterceptedChannelContent::NotifyController()
 {
-  nsresult rv = NS_NewPipe(getter_AddRefs(mSynthesizedInput),
-                           getter_AddRefs(mResponseBody),
-                           0, UINT32_MAX, true, true);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
   DoNotifyController();
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::GetChannel(nsIChannel** aChannel)
 {
   NS_IF_ADDREF(*aChannel = mChannel);
   return NS_OK;
@@ -248,41 +236,37 @@ NS_IMETHODIMP
 InterceptedChannelContent::ResetInterception()
 {
   if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
-  mResponseBody->Close();
-  mResponseBody = nullptr;
-  mSynthesizedInput = nullptr;
-
   mChannel->ResetInterception();
 
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::SynthesizeStatus(uint16_t aStatus, const nsACString& aReason)
 {
-  if (!mResponseBody) {
+  if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return DoSynthesizeStatus(aStatus, aReason);
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::SynthesizeHeader(const nsACString& aName, const nsACString& aValue)
 {
-  if (!mResponseBody) {
+  if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::StartSynthesizedResponse(nsIInputStream* aBody,
@@ -326,24 +310,18 @@ InterceptedChannelContent::StartSynthesi
 
 NS_IMETHODIMP
 InterceptedChannelContent::FinishSynthesizedResponse()
 {
   if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // Make sure the body output stream is always closed.  If the channel was
-  // intercepted with a null-body response then its possible the synthesis
-  // completed without a stream copy operation.
-  mResponseBody->Close();
-
   mReportCollector->FlushConsoleReports(mChannel);
 
-  mResponseBody = nullptr;
   mStreamListener = nullptr;
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::CancelInterception(nsresult aStatus)
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -25,19 +25,16 @@ class InterceptStreamListener;
 
 // An object representing a channel that has been intercepted. This avoids complicating
 // the actual channel implementation with the details of synthesizing responses.
 class InterceptedChannelBase : public nsIInterceptedChannel {
 protected:
   // The interception controller to notify about the successful channel interception
   nsCOMPtr<nsINetworkInterceptController> mController;
 
-  // The stream to write the body of the synthesized response
-  nsCOMPtr<nsIOutputStream> mResponseBody;
-
   // Response head for use when synthesizing
   Maybe<nsAutoPtr<nsHttpResponseHead>> mSynthesizedResponseHead;
 
   nsCOMPtr<nsIConsoleReportCollector> mReportCollector;
   nsCOMPtr<nsISupports> mReleaseHandle;
 
   bool mClosed;
 
@@ -68,17 +65,16 @@ public:
   explicit InterceptedChannelBase(nsINetworkInterceptController* aController);
 
   // Notify the interception controller that the channel has been intercepted
   // and prepare the response body output stream.
   virtual void NotifyController() = 0;
 
   NS_DECL_ISUPPORTS
 
-  NS_IMETHOD GetResponseBody(nsIOutputStream** aOutput) override;
   NS_IMETHOD GetConsoleReportCollector(nsIConsoleReportCollector** aCollectorOut) override;
   NS_IMETHOD SetReleaseHandle(nsISupports* aHandle) override;
 
   NS_IMETHODIMP
   SetLaunchServiceWorkerStart(TimeStamp aTimeStamp) override
   {
     mLaunchServiceWorkerStart = aTimeStamp;
     return NS_OK;
@@ -166,19 +162,16 @@ public:
   SecureUpgradeChannelURI(nsIChannel* aChannel);
 };
 
 class InterceptedChannelContent : public InterceptedChannelBase
 {
   // The actual channel being intercepted.
   RefPtr<HttpChannelChild> mChannel;
 
-  // Reader-side of the response body when synthesizing in a child proces
-  nsCOMPtr<nsIInputStream> mSynthesizedInput;
-
   // Listener for the synthesized response to fix up the notifications before they reach
   // the actual channel.
   RefPtr<InterceptStreamListener> mStreamListener;
 
   // Set for intercepted channels that have gone through a secure upgrade.
   bool mSecureUpgrade;
 public:
   InterceptedChannelContent(HttpChannelChild* aChannel,
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -45,17 +45,16 @@ InterceptedHttpChannel::ReleaseListeners
 {
   if (mLoadGroup) {
     mLoadGroup->RemoveRequest(this, nullptr, mStatus);
   }
   HttpBaseChannel::ReleaseListeners();
   mSynthesizedResponseHead.reset();
   mRedirectChannel = nullptr;
   mBodyReader = nullptr;
-  mBodyWriter = nullptr;
   mReleaseHandle = nullptr;
   mProgressSink = nullptr;
   mBodyCallback = nullptr;
   mPump = nullptr;
   mParentChannel = nullptr;
 
   MOZ_DIAGNOSTIC_ASSERT(!mIsPending);
 }
@@ -725,19 +724,18 @@ NS_IMETHODIMP
 InterceptedHttpChannel::FinishSynthesizedResponse()
 {
   if (mCanceled) {
     // Return NS_OK.  The channel should fire callbacks with an error code
     // if it was cancelled before this point.
     return NS_OK;
   }
 
-  if (mBodyWriter) {
-    mBodyWriter->Close();
-  }
+  // TODO: Remove this API after interception moves to the parent process in
+  //       e10s mode.
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::CancelInterception(nsresult aStatus)
 {
   if (mCanceled) {
@@ -753,33 +751,16 @@ InterceptedHttpChannel::CancelIntercepti
   if (mPump) {
     return mPump->Cancel(mStatus);
   }
 
   return AsyncAbort(mStatus);
 }
 
 NS_IMETHODIMP
-InterceptedHttpChannel::GetResponseBody(nsIOutputStream** aResponseBody)
-{
-  if (!mBodyWriter) {
-    nsresult rv = NS_NewPipe(getter_AddRefs(mBodyReader),
-                             getter_AddRefs(mBodyWriter),
-                             0,          // default segment size
-                             UINT32_MAX, // infinite pipe length
-                             true,       // non-blocking reader
-                             true);      // non-blocking writer
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-  nsCOMPtr<nsIOutputStream> ref(mBodyWriter);
-  ref.forget(aResponseBody);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
 InterceptedHttpChannel::GetChannel(nsIChannel** aChannel)
 {
   nsCOMPtr<nsIChannel> ref(this);
   ref.forget(aChannel);
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -66,17 +66,16 @@ class InterceptedHttpChannel final : pub
   NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
 
 private:
   friend class HttpAsyncAborter<InterceptedHttpChannel>;
 
   UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIInputStream> mBodyReader;
-  nsCOMPtr<nsIOutputStream> mBodyWriter;
   nsCOMPtr<nsISupports> mReleaseHandle;
   nsCOMPtr<nsIProgressEventSink> mProgressSink;
   nsCOMPtr<nsIInterceptedBodyCallback> mBodyCallback;
   RefPtr<nsInputStreamPump> mPump;
   RefPtr<ADivertableParentChannel> mParentChannel;
   TimeStamp mFinishResponseStart;
   TimeStamp mFinishResponseEnd;
   Atomic<int64_t> mProgress;
