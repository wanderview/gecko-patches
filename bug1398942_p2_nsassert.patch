# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  857da64cd190c2fe1106c3706fd8006fcdc33b7c
Bug 1398942 P2 Convert nsPipe3.cpp NS_ASSERTION() calls to hard assertions. r=froydnj

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -76,17 +76,17 @@ public:
                                nsIInputStreamCallback* aCallback)
   {
     mInputList.AppendElement(InputEntry(aStream, aCallback));
   }
 
   inline void NotifyOutputReady(nsIAsyncOutputStream* aStream,
                                 nsIOutputStreamCallback* aCallback)
   {
-    NS_ASSERTION(!mOutputCallback, "already have an output event");
+    MOZ_DIAGNOSTIC_ASSERT(!mOutputCallback);
     mOutputStream = aStream;
     mOutputCallback = aCallback;
   }
 
 private:
   struct InputEntry
   {
     InputEntry(nsIAsyncInputStream* aStream, nsIInputStreamCallback* aCallback)
@@ -623,18 +623,17 @@ nsPipe::GetOutputStream(nsIAsyncOutputSt
   return NS_OK;
 }
 
 void
 nsPipe::PeekSegment(const nsPipeReadState& aReadState, uint32_t aIndex,
                     char*& aCursor, char*& aLimit)
 {
   if (aIndex == 0) {
-    NS_ASSERTION(!aReadState.mReadCursor || mBuffer.GetSegmentCount(),
-                 "unexpected state");
+    MOZ_DIAGNOSTIC_ASSERT(!aReadState.mReadCursor || mBuffer.GetSegmentCount());
     aCursor = aReadState.mReadCursor;
     aLimit = aReadState.mReadLimit;
   } else {
     uint32_t absoluteIndex = aReadState.mSegment + aIndex;
     uint32_t numSegments = mBuffer.GetSegmentCount();
     if (absoluteIndex >= numSegments) {
       aCursor = aLimit = nullptr;
     } else {
@@ -689,28 +688,27 @@ nsPipe::ReleaseReadSegment(nsPipeReadSta
     aReadState.mNeedDrain = false;
     DrainInputStream(aReadState, aEvents);
   }
 }
 
 void
 nsPipe::AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aBytesRead)
 {
-  NS_ASSERTION(aBytesRead, "don't call if no bytes read");
+  MOZ_DIAGNOSTIC_ASSERT(aBytesRead > 0);
 
   nsPipeEvents events;
   {
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     LOG(("III advancing read cursor by %u\n", aBytesRead));
-    NS_ASSERTION(aBytesRead <= mBuffer.GetSegmentSize(), "read too much");
+    MOZ_DIAGNOSTIC_ASSERT(aBytesRead <= mBuffer.GetSegmentSize());
 
     aReadState.mReadCursor += aBytesRead;
-    NS_ASSERTION(aReadState.mReadCursor <= aReadState.mReadLimit,
-                 "read cursor exceeds limit");
+    MOZ_DIAGNOSTIC_ASSERT(aReadState.mReadCursor <= aReadState.mReadLimit);
 
     MOZ_DIAGNOSTIC_ASSERT(aReadState.mAvailable >= aBytesRead);
     aReadState.mAvailable -= aBytesRead;
 
     // Check to see if we're at the end of the available read data.  If we
     // are, and this segment is not still being written, then we can possibly
     // free up the segment.
     if (aReadState.mReadCursor == aReadState.mReadLimit &&
@@ -856,18 +854,17 @@ nsPipe::DrainInputStream(nsPipeReadState
 }
 
 bool
 nsPipe::ReadSegmentBeingWritten(nsPipeReadState& aReadState)
 {
   mReentrantMonitor.AssertCurrentThreadIn();
   bool beingWritten = mWriteSegment == aReadState.mSegment &&
                       mWriteLimit > mWriteCursor;
-  NS_ASSERTION(!beingWritten || aReadState.mReadLimit == mWriteCursor,
-               "unexpected state");
+  MOZ_DIAGNOSTIC_ASSERT(!beingWritten || aReadState.mReadLimit == mWriteCursor);
   return beingWritten;
 }
 
 nsresult
 nsPipe::GetWriteSegment(char*& aSegment, uint32_t& aSegmentLen)
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
@@ -913,26 +910,26 @@ nsPipe::GetWriteSegment(char*& aSegment,
   aSegment    = mWriteCursor;
   aSegmentLen = mWriteLimit - mWriteCursor;
   return NS_OK;
 }
 
 void
 nsPipe::AdvanceWriteCursor(uint32_t aBytesWritten)
 {
-  NS_ASSERTION(aBytesWritten, "don't call if no bytes written");
+  MOZ_DIAGNOSTIC_ASSERT(aBytesWritten > 0);
 
   nsPipeEvents events;
   {
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     LOG(("OOO advancing write cursor by %u\n", aBytesWritten));
 
     char* newWriteCursor = mWriteCursor + aBytesWritten;
-    NS_ASSERTION(newWriteCursor <= mWriteLimit, "write cursor exceeds limit");
+    MOZ_DIAGNOSTIC_ASSERT(newWriteCursor <= mWriteLimit);
 
     // update read limit if reading in the same segment
     UpdateAllReadCursors(newWriteCursor);
 
     mWriteCursor = newWriteCursor;
 
     ValidateAllReadCursors();
 
@@ -1071,18 +1068,17 @@ nsPipe::CountSegmentReferences(int32_t a
 
 void
 nsPipe::SetAllNullReadCursors()
 {
   mReentrantMonitor.AssertCurrentThreadIn();
   for (uint32_t i = 0; i < mInputList.Length(); ++i) {
     nsPipeReadState& readState = mInputList[i]->ReadState();
     if (!readState.mReadCursor) {
-      NS_ASSERTION(mWriteSegment == readState.mSegment,
-                   "unexpected null read cursor");
+      MOZ_DIAGNOSTIC_ASSERT(mWriteSegment == readState.mSegment);
       readState.mReadCursor = readState.mReadLimit = mWriteCursor;
     }
   }
 }
 
 bool
 nsPipe::AllReadCursorsMatchWriteCursor()
 {
@@ -1145,20 +1141,19 @@ nsPipe::ValidateAllReadCursors()
   // write segment is the first byte of the first segment, so
   // mReadCursor == mWriteCursor.  (Another way to think about this is
   // to consider the buffer architecture diagram above, but consider it
   // with an arena allocator which allocates from the *end* of the
   // arena to the *beginning* of the arena.)
 #ifdef DEBUG
   for (uint32_t i = 0; i < mInputList.Length(); ++i) {
     const nsPipeReadState& state = mInputList[i]->ReadState();
-    NS_ASSERTION(state.mReadCursor != mWriteCursor ||
-                 (mBuffer.GetSegment(state.mSegment) == state.mReadCursor &&
-                  mWriteCursor == mWriteLimit),
-                 "read cursor is bad");
+    MOZ_ASSERT(state.mReadCursor != mWriteCursor ||
+               (mBuffer.GetSegment(state.mSegment) == state.mReadCursor &&
+               mWriteCursor == mWriteLimit));
   }
 #endif
 }
 
 uint32_t
 nsPipe::GetBufferSegmentCount(const nsPipeReadState& aReadState,
                               const ReentrantMonitorAutoEnter& ev) const
 {
@@ -1292,17 +1287,17 @@ nsPipeInputStream::Available()
 {
   mPipe->mReentrantMonitor.AssertCurrentThreadIn();
   return mReadState.mAvailable;
 }
 
 nsresult
 nsPipeInputStream::Wait()
 {
-  NS_ASSERTION(mBlocking, "wait on non-blocking pipe input stream");
+  MOZ_DIAGNOSTIC_ASSERT(mBlocking);
 
   ReentrantMonitorAutoEnter mon(mPipe->mReentrantMonitor);
 
   while (NS_SUCCEEDED(Status(mon)) && (mReadState.mAvailable == 0)) {
     LOG(("III pipe input: waiting for data\n"));
 
     mBlocked = true;
     mon.Wait();
@@ -1340,17 +1335,17 @@ MonitorAction
 nsPipeInputStream::OnInputException(nsresult aReason, nsPipeEvents& aEvents,
                                     const ReentrantMonitorAutoEnter& ev)
 {
   LOG(("nsPipeInputStream::OnInputException [this=%p reason=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aReason)));
 
   MonitorAction result = DoNotNotifyMonitor;
 
-  NS_ASSERTION(NS_FAILED(aReason), "huh? successful exception");
+  MOZ_DIAGNOSTIC_ASSERT(NS_FAILED(aReason));
 
   if (NS_SUCCEEDED(mInputStatus)) {
     mInputStatus = aReason;
   }
 
   // force count of available bytes to zero.
   mPipe->DrainInputStream(mReadState, aEvents);
 
@@ -1456,17 +1451,17 @@ nsPipeInputStream::ReadSegments(nsWriteS
       if (NS_FAILED(rv) || writeCount == 0) {
         aCount = 0;
         // any errors returned from the writer end here: do not
         // propagate to the caller of ReadSegments.
         rv = NS_OK;
         break;
       }
 
-      NS_ASSERTION(writeCount <= segment.Length(), "wrote more than expected");
+      MOZ_DIAGNOSTIC_ASSERT(writeCount <= segment.Length());
       segment.Advance(writeCount);
       aCount -= writeCount;
       *aReadCount += writeCount;
       mLogicalOffset += writeCount;
     }
   }
 
   return rv;
@@ -1693,17 +1688,17 @@ NS_IMPL_CI_INTERFACE_GETTER(nsPipeOutput
                             nsIOutputStream,
                             nsIAsyncOutputStream)
 
 NS_IMPL_THREADSAFE_CI(nsPipeOutputStream)
 
 nsresult
 nsPipeOutputStream::Wait()
 {
-  NS_ASSERTION(mBlocking, "wait on non-blocking pipe output stream");
+  MOZ_DIAGNOSTIC_ASSERT(mBlocking);
 
   ReentrantMonitorAutoEnter mon(mPipe->mReentrantMonitor);
 
   if (NS_SUCCEEDED(mPipe->mStatus) && !mWritable) {
     LOG(("OOO pipe output: waiting for space\n"));
     mBlocked = true;
     mon.Wait();
     mBlocked = false;
@@ -1735,17 +1730,17 @@ nsPipeOutputStream::OnOutputWritable(nsP
 MonitorAction
 nsPipeOutputStream::OnOutputException(nsresult aReason, nsPipeEvents& aEvents)
 {
   LOG(("nsPipeOutputStream::OnOutputException [this=%p reason=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aReason)));
 
   MonitorAction result = DoNotNotifyMonitor;
 
-  NS_ASSERTION(NS_FAILED(aReason), "huh? successful exception");
+  MOZ_DIAGNOSTIC_ASSERT(NS_FAILED(aReason));
   mWritable = false;
 
   if (mCallback) {
     aEvents.NotifyOutputReady(this, mCallback);
     mCallback = nullptr;
     mCallbackFlags = 0;
   } else if (mBlocked) {
     result = NotifyMonitor;
@@ -1842,17 +1837,17 @@ nsPipeOutputStream::WriteSegments(nsRead
       if (NS_FAILED(rv) || readCount == 0) {
         aCount = 0;
         // any errors returned from the aReader end here: do not
         // propagate to the caller of WriteSegments.
         rv = NS_OK;
         break;
       }
 
-      NS_ASSERTION(readCount <= segmentLen, "read more than expected");
+      MOZ_DIAGNOSTIC_ASSERT(readCount <= segmentLen);
       segment += readCount;
       segmentLen -= readCount;
       aCount -= readCount;
       *aWriteCount += readCount;
       mLogicalOffset += readCount;
     }
 
     if (segmentLen < originalLen) {
