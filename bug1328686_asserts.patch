# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b548da4e16f067e5b69349376e37b2db97983cf7
Bug 1328686 Add diagnostic assertions to dom/cache. r=asuth

diff --git a/dom/cache/ActorChild.cpp b/dom/cache/ActorChild.cpp
--- a/dom/cache/ActorChild.cpp
+++ b/dom/cache/ActorChild.cpp
@@ -15,17 +15,17 @@ namespace cache {
 
 void
 ActorChild::SetWorkerHolder(CacheWorkerHolder* aWorkerHolder)
 {
   // Some of the Cache actors can have multiple DOM objects associated with
   // them.  In this case the workerHolder will be added multiple times.  This is
   // permitted, but the workerHolder should be the same each time.
   if (mWorkerHolder) {
-    MOZ_ASSERT(mWorkerHolder == aWorkerHolder);
+    MOZ_DIAGNOSTIC_ASSERT(mWorkerHolder == aWorkerHolder);
     return;
   }
 
   mWorkerHolder = aWorkerHolder;
   if (mWorkerHolder) {
     mWorkerHolder->AddActor(this);
   }
 }
@@ -53,14 +53,14 @@ ActorChild::WorkerHolderNotified() const
 }
 
 ActorChild::ActorChild()
 {
 }
 
 ActorChild::~ActorChild()
 {
-  MOZ_ASSERT(!mWorkerHolder);
+  MOZ_DIAGNOSTIC_ASSERT(!mWorkerHolder);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -61,29 +61,29 @@ namespace cache {
 
 AutoChildOpArgs::AutoChildOpArgs(TypeUtils* aTypeUtils,
                                  const CacheOpArgs& aOpArgs,
                                  uint32_t aEntryCount)
   : mTypeUtils(aTypeUtils)
   , mOpArgs(aOpArgs)
   , mSent(false)
 {
-  MOZ_ASSERT(mTypeUtils);
+  MOZ_DIAGNOSTIC_ASSERT(mTypeUtils);
   MOZ_RELEASE_ASSERT(aEntryCount != 0);
   // We are using AutoIPCStream objects to cleanup target IPCStream
   // structures embedded in our CacheOpArgs.  These IPCStream structs
   // must not move once we attach our AutoIPCStream to them.  Therefore,
   // its important that any arrays containing streams are pre-sized for
   // the number of entries we have in order to avoid realloc moving
   // things around on us.
   if (mOpArgs.type() == CacheOpArgs::TCachePutAllArgs) {
     CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
     args.requestResponseList().SetCapacity(aEntryCount);
   } else {
-    MOZ_ASSERT(aEntryCount == 1);
+    MOZ_DIAGNOSTIC_ASSERT(aEntryCount == 1);
   }
 }
 
 AutoChildOpArgs::~AutoChildOpArgs()
 {
   CleanupAction action = mSent ? Forget : Delete;
 
   switch(mOpArgs.type()) {
@@ -140,47 +140,47 @@ AutoChildOpArgs::~AutoChildOpArgs()
 
   mStreamCleanupList.Clear();
 }
 
 void
 AutoChildOpArgs::Add(InternalRequest* aRequest, BodyAction aBodyAction,
                      SchemeAction aSchemeAction, ErrorResult& aRv)
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
 
   switch(mOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
     {
       CacheMatchArgs& args = mOpArgs.get_CacheMatchArgs();
       mTypeUtils->ToCacheRequest(args.request(), aRequest, aBodyAction,
                                  aSchemeAction, mStreamCleanupList, aRv);
       break;
     }
     case CacheOpArgs::TCacheMatchAllArgs:
     {
       CacheMatchAllArgs& args = mOpArgs.get_CacheMatchAllArgs();
-      MOZ_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
+      MOZ_DIAGNOSTIC_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
       args.requestOrVoid() = CacheRequest();
       mTypeUtils->ToCacheRequest(args.requestOrVoid().get_CacheRequest(),
                                  aRequest, aBodyAction, aSchemeAction,
                                  mStreamCleanupList, aRv);
       break;
     }
     case CacheOpArgs::TCacheDeleteArgs:
     {
       CacheDeleteArgs& args = mOpArgs.get_CacheDeleteArgs();
       mTypeUtils->ToCacheRequest(args.request(), aRequest, aBodyAction,
                                  aSchemeAction, mStreamCleanupList, aRv);
       break;
     }
     case CacheOpArgs::TCacheKeysArgs:
     {
       CacheKeysArgs& args = mOpArgs.get_CacheKeysArgs();
-      MOZ_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
+      MOZ_DIAGNOSTIC_ASSERT(args.requestOrVoid().type() == CacheRequestOrVoid::Tvoid_t);
       args.requestOrVoid() = CacheRequest();
       mTypeUtils->ToCacheRequest(args.requestOrVoid().get_CacheRequest(),
                                   aRequest, aBodyAction, aSchemeAction,
                                   mStreamCleanupList, aRv);
       break;
     }
     case CacheOpArgs::TStorageMatchArgs:
     {
@@ -195,17 +195,17 @@ AutoChildOpArgs::Add(InternalRequest* aR
 }
 
 namespace {
 
 bool
 MatchInPutList(InternalRequest* aRequest,
                const nsTArray<CacheRequestResponse>& aPutList)
 {
-  MOZ_ASSERT(aRequest);
+  MOZ_DIAGNOSTIC_ASSERT(aRequest);
 
   // This method implements the SW spec QueryCache algorithm against an
   // in memory array of Request/Response objects.  This essentially the
   // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
   // we cannot unify them because when operating against the real database
   // we don't want to load all request/response objects into memory.
 
   // Note, we can skip the check for a invalid request method because
@@ -248,33 +248,33 @@ MatchInPutList(InternalRequest* aRequest
     // Assume the vary headers match until we find a conflict
     bool varyHeadersMatch = true;
 
     char* rawBuffer = varyHeaders.BeginWriting();
     char* token = nsCRT::strtok(rawBuffer, NS_HTTP_HEADER_SEPS, &rawBuffer);
     for (; token;
          token = nsCRT::strtok(rawBuffer, NS_HTTP_HEADER_SEPS, &rawBuffer)) {
       nsDependentCString header(token);
-      MOZ_ASSERT(!header.EqualsLiteral("*"),
-                 "We should have already caught this in "
-                 "TypeUtils::ToPCacheResponseWithoutBody()");
+      MOZ_DIAGNOSTIC_ASSERT(!header.EqualsLiteral("*"),
+                            "We should have already caught this in "
+                            "TypeUtils::ToPCacheResponseWithoutBody()");
 
       ErrorResult headerRv;
       nsAutoCString value;
       requestHeaders->Get(header, value, headerRv);
       if (NS_WARN_IF(headerRv.Failed())) {
         headerRv.SuppressException();
-        MOZ_ASSERT(value.IsEmpty());
+        MOZ_DIAGNOSTIC_ASSERT(value.IsEmpty());
       }
 
       nsAutoCString cachedValue;
       cachedRequestHeaders->Get(header, cachedValue, headerRv);
       if (NS_WARN_IF(headerRv.Failed())) {
         headerRv.SuppressException();
-        MOZ_ASSERT(cachedValue.IsEmpty());
+        MOZ_DIAGNOSTIC_ASSERT(cachedValue.IsEmpty());
       }
 
       if (value != cachedValue) {
         varyHeadersMatch = false;
         break;
       }
     }
 
@@ -289,17 +289,17 @@ MatchInPutList(InternalRequest* aRequest
 
 } // namespace
 
 void
 AutoChildOpArgs::Add(InternalRequest* aRequest, BodyAction aBodyAction,
                      SchemeAction aSchemeAction, Response& aResponse,
                      ErrorResult& aRv)
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
 
   switch(mOpArgs.type()) {
     case CacheOpArgs::TCachePutAllArgs:
     {
       CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
 
       // Throw an error if a request/response pair would mask another
       // request/response pair in the same PutAll operation.  This is
@@ -345,17 +345,17 @@ AutoChildOpArgs::Add(InternalRequest* aR
     default:
       MOZ_CRASH("Cache args type cannot send a Request/Response pair!");
   }
 }
 
 const CacheOpArgs&
 AutoChildOpArgs::SendAsOpArgs()
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
   mSent = true;
   for (UniquePtr<AutoIPCStream>& autoStream : mStreamCleanupList) {
     autoStream->TakeValue();
   }
   return mOpArgs;
 }
 
 // --------------------------------------------
@@ -363,32 +363,32 @@ AutoChildOpArgs::SendAsOpArgs()
 AutoParentOpResult::AutoParentOpResult(mozilla::ipc::PBackgroundParent* aManager,
                                        const CacheOpResult& aOpResult,
                                        uint32_t aEntryCount)
   : mManager(aManager)
   , mOpResult(aOpResult)
   , mStreamControl(nullptr)
   , mSent(false)
 {
-  MOZ_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
   MOZ_RELEASE_ASSERT(aEntryCount != 0);
   // We are using AutoIPCStream objects to cleanup target IPCStream
   // structures embedded in our CacheOpArgs.  These IPCStream structs
   // must not move once we attach our AutoIPCStream to them.  Therefore,
   // its important that any arrays containing streams are pre-sized for
   // the number of entries we have in order to avoid realloc moving
   // things around on us.
   if (mOpResult.type() == CacheOpResult::TCacheMatchAllResult) {
     CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
     result.responseList().SetCapacity(aEntryCount);
   } else if (mOpResult.type() == CacheOpResult::TCacheKeysResult) {
     CacheKeysResult& result = mOpResult.get_CacheKeysResult();
     result.requestList().SetCapacity(aEntryCount);
   } else {
-    MOZ_ASSERT(aEntryCount == 1);
+    MOZ_DIAGNOSTIC_ASSERT(aEntryCount == 1);
   }
 }
 
 AutoParentOpResult::~AutoParentOpResult()
 {
   CleanupAction action = mSent ? Forget : Delete;
 
   switch (mOpResult.type()) {
@@ -411,33 +411,33 @@ AutoParentOpResult::~AutoParentOpResult(
   }
 
   mStreamCleanupList.Clear();
 }
 
 void
 AutoParentOpResult::Add(CacheId aOpenedCacheId, Manager* aManager)
 {
-  MOZ_ASSERT(mOpResult.type() == CacheOpResult::TStorageOpenResult);
-  MOZ_ASSERT(mOpResult.get_StorageOpenResult().actorParent() == nullptr);
+  MOZ_DIAGNOSTIC_ASSERT(mOpResult.type() == CacheOpResult::TStorageOpenResult);
+  MOZ_DIAGNOSTIC_ASSERT(mOpResult.get_StorageOpenResult().actorParent() == nullptr);
   mOpResult.get_StorageOpenResult().actorParent() =
     mManager->SendPCacheConstructor(new CacheParent(aManager, aOpenedCacheId));
 }
 
 void
 AutoParentOpResult::Add(const SavedResponse& aSavedResponse,
                         StreamList* aStreamList)
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheMatchResult:
     {
       CacheMatchResult& result = mOpResult.get_CacheMatchResult();
-      MOZ_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
+      MOZ_DIAGNOSTIC_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
       result.responseOrVoid() = aSavedResponse.mValue;
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseOrVoid().get_CacheResponse());
       break;
     }
     case CacheOpResult::TCacheMatchAllResult:
     {
       CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
@@ -450,32 +450,32 @@ AutoParentOpResult::Add(const SavedRespo
       result.responseList().AppendElement(aSavedResponse.mValue);
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseList().LastElement());
       break;
     }
     case CacheOpResult::TStorageMatchResult:
     {
       StorageMatchResult& result = mOpResult.get_StorageMatchResult();
-      MOZ_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
+      MOZ_DIAGNOSTIC_ASSERT(result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t);
       result.responseOrVoid() = aSavedResponse.mValue;
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseOrVoid().get_CacheResponse());
       break;
     }
     default:
       MOZ_CRASH("Cache result type cannot handle returning a Response!");
   }
 }
 
 void
 AutoParentOpResult::Add(const SavedRequest& aSavedRequest,
                         StreamList* aStreamList)
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheKeysResult:
     {
       CacheKeysResult& result = mOpResult.get_CacheKeysResult();
       // Ensure that we don't realloc the array since this can result
       // in our AutoIPCStream objects to reference the wrong memory
       // location.  This should never happen and is a UAF if it does.
@@ -498,51 +498,51 @@ AutoParentOpResult::Add(const SavedReque
     default:
       MOZ_CRASH("Cache result type cannot handle returning a Request!");
   }
 }
 
 const CacheOpResult&
 AutoParentOpResult::SendAsOpResult()
 {
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
   mSent = true;
   for (UniquePtr<AutoIPCStream>& autoStream : mStreamCleanupList) {
     autoStream->TakeValue();
   }
   return mOpResult;
 }
 
 void
 AutoParentOpResult::SerializeResponseBody(const SavedResponse& aSavedResponse,
                                           StreamList* aStreamList,
                                           CacheResponse* aResponseOut)
 {
-  MOZ_ASSERT(aResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aResponseOut);
 
   if (!aSavedResponse.mHasBodyId) {
     aResponseOut->body() = void_t();
     return;
   }
 
   aResponseOut->body() = CacheReadStream();
   SerializeReadStream(aSavedResponse.mBodyId, aStreamList,
                       &aResponseOut->body().get_CacheReadStream());
 }
 
 void
 AutoParentOpResult::SerializeReadStream(const nsID& aId, StreamList* aStreamList,
                                         CacheReadStream* aReadStreamOut)
 {
-  MOZ_ASSERT(aStreamList);
-  MOZ_ASSERT(aReadStreamOut);
-  MOZ_ASSERT(!mSent);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(!mSent);
 
   nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
-  MOZ_ASSERT(stream);
+  MOZ_DIAGNOSTIC_ASSERT(stream);
 
   if (!mStreamControl) {
     mStreamControl = static_cast<CacheStreamControlParent*>(
       mManager->SendPCacheStreamControlConstructor(new CacheStreamControlParent()));
 
     // If this failed, then the child process is gone.  Warn and allow actor
     // cleanup to proceed as normal.
     if (!mStreamControl) {
@@ -552,14 +552,14 @@ AutoParentOpResult::SerializeReadStream(
   }
 
   aStreamList->SetStreamControl(mStreamControl);
 
   RefPtr<ReadStream> readStream = ReadStream::Create(mStreamControl,
                                                      aId, stream);
   ErrorResult rv;
   readStream->Serialize(aReadStreamOut, mStreamCleanupList, rv);
-  MOZ_ASSERT(!rv.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!rv.Failed());
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -117,18 +117,18 @@ public:
   FetchHandler(CacheWorkerHolder* aWorkerHolder, Cache* aCache,
                nsTArray<RefPtr<Request>>&& aRequestList, Promise* aPromise)
     : mWorkerHolder(aWorkerHolder)
     , mCache(aCache)
     , mRequestList(Move(aRequestList))
     , mPromise(aPromise)
   {
     MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolder);
-    MOZ_ASSERT(mCache);
-    MOZ_ASSERT(mPromise);
+    MOZ_DIAGNOSTIC_ASSERT(mCache);
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
   }
 
   virtual void
   ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override
   {
     NS_ASSERT_OWNINGTHREAD(FetchHandler);
 
     // Stop holding the worker alive when we leave this method.
@@ -193,17 +193,17 @@ public:
         // TODO: abort the fetch requests we have running (bug 1157434)
         mPromise->MaybeReject(errorResult);
         return;
       }
 
       responseList.AppendElement(Move(response));
     }
 
-    MOZ_ASSERT(mRequestList.Length() == responseList.Length());
+    MOZ_DIAGNOSTIC_ASSERT(mRequestList.Length() == responseList.Length());
 
     // Now store the unwrapped Response list in the Cache.
     ErrorResult result;
     RefPtr<Promise> put = mCache->PutAll(mRequestList, responseList, result);
     if (NS_WARN_IF(result.Failed())) {
       // TODO: abort the fetch requests we have running (bug 1157434)
       mPromise->MaybeReject(result);
       return;
@@ -252,18 +252,18 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 Cache::Cache(nsIGlobalObject* aGlobal, CacheChild* aActor)
   : mGlobal(aGlobal)
   , mActor(aActor)
 {
-  MOZ_ASSERT(mGlobal);
-  MOZ_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
   mActor->SetListener(this);
 }
 
 already_AddRefed<Promise>
 Cache::Match(const RequestOrUSVString& aRequest,
              const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
   if (NS_WARN_IF(!mActor)) {
@@ -334,17 +334,17 @@ Cache::Add(JSContext* aContext, const Re
 
   CacheChild::AutoLock actorLock(mActor);
 
   if (!IsValidPutRequestMethod(aRequest, aRv)) {
     return nullptr;
   }
 
   GlobalObject global(aContext, mGlobal->GetGlobalJSObject());
-  MOZ_ASSERT(!global.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!global.Failed());
 
   nsTArray<RefPtr<Request>> requestList(1);
   RefPtr<Request> request = Request::Constructor(global, aRequest,
                                                    RequestInit(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
@@ -366,17 +366,17 @@ Cache::AddAll(JSContext* aContext,
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   GlobalObject global(aContext, mGlobal->GetGlobalJSObject());
-  MOZ_ASSERT(!global.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!global.Failed());
 
   nsTArray<RefPtr<Request>> requestList(aRequestList.Length());
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     RequestOrUSVString requestOrString;
 
     if (aRequestList[i].IsRequest()) {
       requestOrString.SetAsRequest() = aRequestList[i].GetAsRequest();
       if (NS_WARN_IF(!IsValidPutRequestMethod(requestOrString.GetAsRequest(),
@@ -536,18 +536,18 @@ JSObject*
 Cache::WrapObject(JSContext* aContext, JS::Handle<JSObject*> aGivenProto)
 {
   return CacheBinding::Wrap(aContext, this, aGivenProto);
 }
 
 void
 Cache::DestroyInternal(CacheChild* aActor)
 {
-  MOZ_ASSERT(mActor);
-  MOZ_ASSERT(mActor == aActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 nsIGlobalObject*
 Cache::GetGlobalObject() const
 {
   return mGlobal;
@@ -560,50 +560,50 @@ Cache::AssertOwningThread() const
   NS_ASSERT_OWNINGTHREAD(Cache);
 }
 #endif
 
 PBackgroundChild*
 Cache::GetIPCManager()
 {
   NS_ASSERT_OWNINGTHREAD(Cache);
-  MOZ_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
   return mActor->Manager();
 }
 
 Cache::~Cache()
 {
   NS_ASSERT_OWNINGTHREAD(Cache);
   if (mActor) {
     mActor->StartDestroyFromListener();
     // DestroyInternal() is called synchronously by StartDestroyFromListener().
     // So we should have already cleared the mActor.
-    MOZ_ASSERT(!mActor);
+    MOZ_DIAGNOSTIC_ASSERT(!mActor);
   }
 }
 
 already_AddRefed<Promise>
 Cache::ExecuteOp(AutoChildOpArgs& aOpArgs, ErrorResult& aRv)
 {
-  MOZ_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
 
   RefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (NS_WARN_IF(!promise)) {
     return nullptr;
   }
 
   mActor->ExecuteOp(mGlobal, promise, this, aOpArgs.SendAsOpArgs());
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(const GlobalObject& aGlobal,
               nsTArray<RefPtr<Request>>&& aRequestList, ErrorResult& aRv)
 {
-  MOZ_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
 
   // If there is no work to do, then resolve immediately
   if (aRequestList.IsEmpty()) {
     RefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
     if (NS_WARN_IF(!promise)) {
       return nullptr;
     }
 
@@ -648,17 +648,17 @@ Cache::AddAll(const GlobalObject& aGloba
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::PutAll(const nsTArray<RefPtr<Request>>& aRequestList,
               const nsTArray<RefPtr<Response>>& aResponseList,
               ErrorResult& aRv)
 {
-  MOZ_ASSERT(aRequestList.Length() == aResponseList.Length());
+  MOZ_DIAGNOSTIC_ASSERT(aRequestList.Length() == aResponseList.Length());
 
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -37,35 +37,35 @@ CacheChild::CacheChild()
 {
   MOZ_COUNT_CTOR(cache::CacheChild);
 }
 
 CacheChild::~CacheChild()
 {
   MOZ_COUNT_DTOR(cache::CacheChild);
   NS_ASSERT_OWNINGTHREAD(CacheChild);
-  MOZ_ASSERT(!mListener);
-  MOZ_ASSERT(!mNumChildActors);
-  MOZ_ASSERT(!mLocked);
+  MOZ_DIAGNOSTIC_ASSERT(!mListener);
+  MOZ_DIAGNOSTIC_ASSERT(!mNumChildActors);
+  MOZ_DIAGNOSTIC_ASSERT(!mLocked);
 }
 
 void
 CacheChild::SetListener(Cache* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
-  MOZ_ASSERT(!mListener);
+  MOZ_DIAGNOSTIC_ASSERT(!mListener);
   mListener = aListener;
-  MOZ_ASSERT(mListener);
+  MOZ_DIAGNOSTIC_ASSERT(mListener);
 }
 
 void
 CacheChild::ClearListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
-  MOZ_ASSERT(mListener);
+  MOZ_DIAGNOSTIC_ASSERT(mListener);
   mListener = nullptr;
 }
 
 void
 CacheChild::ExecuteOp(nsIGlobalObject* aGlobal, Promise* aPromise,
                       nsISupports* aParent, const CacheOpArgs& aArgs)
 {
   mNumChildActors += 1;
@@ -76,17 +76,17 @@ CacheChild::ExecuteOp(nsIGlobalObject* a
 void
 CacheChild::StartDestroyFromListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
 
   // The listener should be held alive by any async operations, so if it
   // is going away then there must not be any child actors.  This in turn
   // ensures that StartDestroy() will not trigger the delayed path.
-  MOZ_ASSERT(!mNumChildActors);
+  MOZ_DIAGNOSTIC_ASSERT(!mNumChildActors);
 
   StartDestroy();
 }
 
 void
 CacheChild::StartDestroy()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
@@ -108,31 +108,31 @@ CacheChild::StartDestroy()
   // that by just ignoring the second StartDestroy() call.
   if (!listener) {
     return;
   }
 
   listener->DestroyInternal(this);
 
   // Cache listener should call ClearListener() in DestroyInternal()
-  MOZ_ASSERT(!mListener);
+  MOZ_DIAGNOSTIC_ASSERT(!mListener);
 
   // Start actor destruction from parent process
   Unused << SendTeardown();
 }
 
 void
 CacheChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
   RefPtr<Cache> listener = mListener;
   if (listener) {
     listener->DestroyInternal(this);
     // Cache listener should call ClearListener() in DestroyInternal()
-    MOZ_ASSERT(!mListener);
+    MOZ_DIAGNOSTIC_ASSERT(!mListener);
   }
 
   RemoveWorkerHolder();
 }
 
 PCacheOpChild*
 CacheChild::AllocPCacheOpChild(const CacheOpArgs& aOpArgs)
 {
@@ -162,24 +162,24 @@ CacheChild::MaybeFlushDelayedDestroy()
     StartDestroy();
   }
 }
 
 void
 CacheChild::Lock()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
-  MOZ_ASSERT(!mLocked);
+  MOZ_DIAGNOSTIC_ASSERT(!mLocked);
   mLocked = true;
 }
 
 void
 CacheChild::Unlock()
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
-  MOZ_ASSERT(mLocked);
+  MOZ_DIAGNOSTIC_ASSERT(mLocked);
   mLocked = false;
   MaybeFlushDelayedDestroy();
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -30,17 +30,17 @@ public:
   class MOZ_RAII AutoLock final
   {
     CacheChild* mActor;
 
   public:
     explicit AutoLock(CacheChild* aActor)
       : mActor(aActor)
     {
-      MOZ_ASSERT(mActor);
+      MOZ_DIAGNOSTIC_ASSERT(mActor);
       mActor->Lock();
     }
 
     ~AutoLock()
     {
       mActor->Unlock();
     }
   };
diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -65,28 +65,28 @@ AddWorkerHolderToStreamChild(const Cache
 
 CacheOpChild::CacheOpChild(CacheWorkerHolder* aWorkerHolder,
                            nsIGlobalObject* aGlobal,
                            nsISupports* aParent, Promise* aPromise)
   : mGlobal(aGlobal)
   , mParent(aParent)
   , mPromise(aPromise)
 {
-  MOZ_ASSERT(mGlobal);
-  MOZ_ASSERT(mParent);
-  MOZ_ASSERT(mPromise);
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(mParent);
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
 
   MOZ_ASSERT_IF(!NS_IsMainThread(), aWorkerHolder);
   SetWorkerHolder(aWorkerHolder);
 }
 
 CacheOpChild::~CacheOpChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpChild);
-  MOZ_ASSERT(!mPromise);
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
 }
 
 void
 CacheOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpChild);
 
   // If the actor was terminated for some unknown reason, then indicate the
@@ -101,17 +101,17 @@ CacheOpChild::ActorDestroy(ActorDestroyR
 
 mozilla::ipc::IPCResult
 CacheOpChild::Recv__delete__(const ErrorResult& aRv,
                              const CacheOpResult& aResult)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpChild);
 
   if (NS_WARN_IF(aRv.Failed())) {
-    MOZ_ASSERT(aResult.type() == CacheOpResult::Tvoid_t);
+    MOZ_DIAGNOSTIC_ASSERT(aResult.type() == CacheOpResult::Tvoid_t);
     // TODO: Remove this const_cast (bug 1152078).
     // It is safe for now since this ErrorResult is handed off to us by IPDL
     // and is thrown into the trash afterwards.
     mPromise->MaybeReject(const_cast<ErrorResult&>(aRv));
     mPromise = nullptr;
     return IPC_OK();
   }
 
diff --git a/dom/cache/CacheOpParent.cpp b/dom/cache/CacheOpParent.cpp
--- a/dom/cache/CacheOpParent.cpp
+++ b/dom/cache/CacheOpParent.cpp
@@ -24,40 +24,40 @@ using mozilla::ipc::SendStreamParent;
 
 CacheOpParent::CacheOpParent(PBackgroundParent* aIpcManager, CacheId aCacheId,
                              const CacheOpArgs& aOpArgs)
   : mIpcManager(aIpcManager)
   , mCacheId(aCacheId)
   , mNamespace(INVALID_NAMESPACE)
   , mOpArgs(aOpArgs)
 {
-  MOZ_ASSERT(mIpcManager);
+  MOZ_DIAGNOSTIC_ASSERT(mIpcManager);
 }
 
 CacheOpParent::CacheOpParent(PBackgroundParent* aIpcManager,
                              Namespace aNamespace, const CacheOpArgs& aOpArgs)
   : mIpcManager(aIpcManager)
   , mCacheId(INVALID_CACHE_ID)
   , mNamespace(aNamespace)
   , mOpArgs(aOpArgs)
 {
-  MOZ_ASSERT(mIpcManager);
+  MOZ_DIAGNOSTIC_ASSERT(mIpcManager);
 }
 
 CacheOpParent::~CacheOpParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
 }
 
 void
 CacheOpParent::Execute(ManagerId* aManagerId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
-  MOZ_ASSERT(!mManager);
-  MOZ_ASSERT(!mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(!mManager);
+  MOZ_DIAGNOSTIC_ASSERT(!mVerifier);
 
   RefPtr<cache::Manager> manager;
   nsresult rv = cache::Manager::GetOrCreate(aManagerId, getter_AddRefs(manager));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ErrorResult result(rv);
     Unused << Send__delete__(this, result, void_t());
     result.SuppressException();
     return;
@@ -65,24 +65,24 @@ CacheOpParent::Execute(ManagerId* aManag
 
   Execute(manager);
 }
 
 void
 CacheOpParent::Execute(cache::Manager* aManager)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
-  MOZ_ASSERT(!mManager);
-  MOZ_ASSERT(!mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(!mManager);
+  MOZ_DIAGNOSTIC_ASSERT(!mVerifier);
 
   mManager = aManager;
 
   // Handle put op
   if (mOpArgs.type() == CacheOpArgs::TCachePutAllArgs) {
-    MOZ_ASSERT(mCacheId != INVALID_CACHE_ID);
+    MOZ_DIAGNOSTIC_ASSERT(mCacheId != INVALID_CACHE_ID);
 
     const CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
     const nsTArray<CacheRequestResponse>& list = args.requestResponseList();
 
     AutoTArray<nsCOMPtr<nsIInputStream>, 256> requestStreamList;
     AutoTArray<nsCOMPtr<nsIInputStream>, 256> responseStreamList;
 
     for (uint32_t i = 0; i < list.Length(); ++i) {
@@ -94,32 +94,32 @@ CacheOpParent::Execute(cache::Manager* a
 
     mManager->ExecutePutAll(this, mCacheId, args.requestResponseList(),
                             requestStreamList, responseStreamList);
     return;
   }
 
   // Handle all other cache ops
   if (mCacheId != INVALID_CACHE_ID) {
-    MOZ_ASSERT(mNamespace == INVALID_NAMESPACE);
+    MOZ_DIAGNOSTIC_ASSERT(mNamespace == INVALID_NAMESPACE);
     mManager->ExecuteCacheOp(this, mCacheId, mOpArgs);
     return;
   }
 
   // Handle all storage ops
-  MOZ_ASSERT(mNamespace != INVALID_NAMESPACE);
+  MOZ_DIAGNOSTIC_ASSERT(mNamespace != INVALID_NAMESPACE);
   mManager->ExecuteStorageOp(this, mNamespace, mOpArgs);
 }
 
 void
 CacheOpParent::WaitForVerification(PrincipalVerifier* aVerifier)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
-  MOZ_ASSERT(!mManager);
-  MOZ_ASSERT(!mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(!mManager);
+  MOZ_DIAGNOSTIC_ASSERT(!mVerifier);
 
   mVerifier = aVerifier;
   mVerifier->AddListener(this);
 }
 
 void
 CacheOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
@@ -159,18 +159,18 @@ CacheOpParent::OnPrincipalVerified(nsres
 void
 CacheOpParent::OnOpComplete(ErrorResult&& aRv, const CacheOpResult& aResult,
                             CacheId aOpenedCacheId,
                             const nsTArray<SavedResponse>& aSavedResponseList,
                             const nsTArray<SavedRequest>& aSavedRequestList,
                             StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpParent);
-  MOZ_ASSERT(mIpcManager);
-  MOZ_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mIpcManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
 
   // Never send an op-specific result if we have an error.  Instead, send
   // void_t() to ensure that we don't leak actors on the child side.
   if (NS_WARN_IF(aRv.Failed())) {
     Unused << Send__delete__(this, aRv, void_t());
     aRv.SuppressException(); // We serialiazed it, as best we could.
     return;
   }
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -20,30 +20,30 @@ DeallocPCacheParent(PCacheParent* aActor
   delete aActor;
 }
 
 CacheParent::CacheParent(cache::Manager* aManager, CacheId aCacheId)
   : mManager(aManager)
   , mCacheId(aCacheId)
 {
   MOZ_COUNT_CTOR(cache::CacheParent);
-  MOZ_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
   mManager->AddRefCacheId(mCacheId);
 }
 
 CacheParent::~CacheParent()
 {
   MOZ_COUNT_DTOR(cache::CacheParent);
-  MOZ_ASSERT(!mManager);
+  MOZ_DIAGNOSTIC_ASSERT(!mManager);
 }
 
 void
 CacheParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  MOZ_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
   mManager->ReleaseCacheId(mCacheId);
   mManager = nullptr;
 }
 
 PCacheOpParent*
 CacheParent::AllocPCacheOpParent(const CacheOpArgs& aOpArgs)
 {
   if (aOpArgs.type() != CacheOpArgs::TCacheMatchArgs &&
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -136,18 +136,18 @@ IsTrusted(const PrincipalInfo& aPrincipa
 } // namespace
 
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                                  nsIPrincipal* aPrincipal, bool aStorageDisabled,
                                  bool aForceTrustedOrigin, ErrorResult& aRv)
 {
-  MOZ_ASSERT(aGlobal);
-  MOZ_ASSERT(aPrincipal);
+  MOZ_DIAGNOSTIC_ASSERT(aGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   if (aStorageDisabled) {
     NS_WARNING("CacheStorage has been disabled.");
     RefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
@@ -173,18 +173,18 @@ CacheStorage::CreateOnMainThread(Namespa
   return ref.forget();
 }
 
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
                              WorkerPrivate* aWorkerPrivate, ErrorResult& aRv)
 {
-  MOZ_ASSERT(aGlobal);
-  MOZ_ASSERT(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(aGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   if (!aWorkerPrivate->IsStorageAllowed()) {
     NS_WARNING("CacheStorage is not allowed.");
     RefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
@@ -233,27 +233,27 @@ CacheStorage::CreateOnWorker(Namespace a
   return ref.forget();
 }
 
 // static
 bool
 CacheStorage::DefineCaches(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
 {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL,
-             "Passed object is not a global object!");
+  MOZ_DIAGNOSTIC_ASSERT(js::GetObjectClass(aGlobal)->flags & JSCLASS_DOM_GLOBAL,
+                                           "Passed object is not a global object!");
   js::AssertSameCompartment(aCx, aGlobal);
 
   if (NS_WARN_IF(!CacheStorageBinding::GetConstructorObject(aCx) ||
                  !CacheBinding::GetConstructorObject(aCx))) {
     return false;
   }
 
   nsIPrincipal* principal = nsContentUtils::ObjectPrincipal(aGlobal);
-  MOZ_ASSERT(principal);
+  MOZ_DIAGNOSTIC_ASSERT(principal);
 
   ErrorResult rv;
   RefPtr<CacheStorage> storage =
     CreateOnMainThread(DEFAULT_NAMESPACE, xpc::NativeGlobal(aGlobal), principal,
                        false, /* private browsing */
                        true,  /* force trusted */
                        rv);
   if (NS_WARN_IF(rv.MaybeSetPendingException(aCx))) {
@@ -273,17 +273,17 @@ CacheStorage::CacheStorage(Namespace aNa
                            CacheWorkerHolder* aWorkerHolder)
   : mNamespace(aNamespace)
   , mGlobal(aGlobal)
   , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
   , mWorkerHolder(aWorkerHolder)
   , mActor(nullptr)
   , mStatus(NS_OK)
 {
-  MOZ_ASSERT(mGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(mGlobal);
 
   // If the PBackground actor is already initialized then we can
   // immediately use it
   PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
   if (actor) {
     ActorCreated(actor);
     return;
   }
@@ -297,17 +297,17 @@ CacheStorage::CacheStorage(Namespace aNa
   }
 }
 
 CacheStorage::CacheStorage(nsresult aFailureResult)
   : mNamespace(INVALID_NAMESPACE)
   , mActor(nullptr)
   , mStatus(aFailureResult)
 {
-  MOZ_ASSERT(NS_FAILED(mStatus));
+  MOZ_DIAGNOSTIC_ASSERT(NS_FAILED(mStatus));
 }
 
 already_AddRefed<Promise>
 CacheStorage::Match(const RequestOrUSVString& aRequest,
                     const CacheQueryOptions& aOptions, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
@@ -496,17 +496,17 @@ CacheStorage::WrapObject(JSContext* aCon
 {
   return mozilla::dom::CacheStorageBinding::Wrap(aContext, this, aGivenProto);
 }
 
 void
 CacheStorage::ActorCreated(PBackgroundChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
-  MOZ_ASSERT(aActor);
+  MOZ_DIAGNOSTIC_ASSERT(aActor);
 
   if (NS_WARN_IF(mWorkerHolder && mWorkerHolder->Notified())) {
     ActorFailed();
     return;
   }
 
   // WorkerHolder ownership is passed to the CacheStorageChild actor and any
   // actors it may create.  The WorkerHolder will keep the worker thread alive
@@ -517,45 +517,45 @@ CacheStorage::ActorCreated(PBackgroundCh
 
   if (NS_WARN_IF(!constructedActor)) {
     ActorFailed();
     return;
   }
 
   mWorkerHolder = nullptr;
 
-  MOZ_ASSERT(constructedActor == newActor);
+  MOZ_DIAGNOSTIC_ASSERT(constructedActor == newActor);
   mActor = newActor;
 
   MaybeRunPendingRequests();
-  MOZ_ASSERT(mPendingRequests.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(mPendingRequests.IsEmpty());
 }
 
 void
 CacheStorage::ActorFailed()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
-  MOZ_ASSERT(!NS_FAILED(mStatus));
+  MOZ_DIAGNOSTIC_ASSERT(!NS_FAILED(mStatus));
 
   mStatus = NS_ERROR_UNEXPECTED;
   mWorkerHolder = nullptr;
 
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     nsAutoPtr<Entry> entry(mPendingRequests[i].forget());
     entry->mPromise->MaybeReject(NS_ERROR_UNEXPECTED);
   }
   mPendingRequests.Clear();
 }
 
 void
 CacheStorage::DestroyInternal(CacheStorageChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
-  MOZ_ASSERT(mActor);
-  MOZ_ASSERT(mActor == aActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
   mActor->ClearListener();
   mActor = nullptr;
 
   // Note that we will never get an actor again in case another request is
   // made before this object is destructed.
   ActorFailed();
 }
 
@@ -584,17 +584,17 @@ CacheStorage::GetIPCManager()
 
 CacheStorage::~CacheStorage()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
   if (mActor) {
     mActor->StartDestroyFromListener();
     // DestroyInternal() is called synchronously by StartDestroyFromListener().
     // So we should have already cleared the mActor.
-    MOZ_ASSERT(!mActor);
+    MOZ_DIAGNOSTIC_ASSERT(!mActor);
   }
 }
 
 void
 CacheStorage::MaybeRunPendingRequests()
 {
   if (!mActor) {
     return;
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -24,33 +24,33 @@ DeallocPCacheStorageChild(PCacheStorageC
 
 CacheStorageChild::CacheStorageChild(CacheStorage* aListener,
                                      CacheWorkerHolder* aWorkerHolder)
   : mListener(aListener)
   , mNumChildActors(0)
   , mDelayedDestroy(false)
 {
   MOZ_COUNT_CTOR(cache::CacheStorageChild);
-  MOZ_ASSERT(mListener);
+  MOZ_DIAGNOSTIC_ASSERT(mListener);
 
   SetWorkerHolder(aWorkerHolder);
 }
 
 CacheStorageChild::~CacheStorageChild()
 {
   MOZ_COUNT_DTOR(cache::CacheStorageChild);
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
-  MOZ_ASSERT(!mListener);
+  MOZ_DIAGNOSTIC_ASSERT(!mListener);
 }
 
 void
 CacheStorageChild::ClearListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
-  MOZ_ASSERT(mListener);
+  MOZ_DIAGNOSTIC_ASSERT(mListener);
   mListener = nullptr;
 }
 
 void
 CacheStorageChild::ExecuteOp(nsIGlobalObject* aGlobal, Promise* aPromise,
                              nsISupports* aParent, const CacheOpArgs& aArgs)
 {
   mNumChildActors += 1;
@@ -61,17 +61,17 @@ CacheStorageChild::ExecuteOp(nsIGlobalOb
 void
 CacheStorageChild::StartDestroyFromListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
 
   // The listener should be held alive by any async operations, so if it
   // is going away then there must not be any child actors.  This in turn
   // ensures that StartDestroy() will not trigger the delayed path.
-  MOZ_ASSERT(!mNumChildActors);
+  MOZ_DIAGNOSTIC_ASSERT(!mNumChildActors);
 
   StartDestroy();
 }
 
 void
 CacheStorageChild::StartDestroy()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
@@ -93,31 +93,31 @@ CacheStorageChild::StartDestroy()
   // that by just ignoring the second StartDestroy() call.
   if (!listener) {
     return;
   }
 
   listener->DestroyInternal(this);
 
   // CacheStorage listener should call ClearListener() in DestroyInternal()
-  MOZ_ASSERT(!mListener);
+  MOZ_DIAGNOSTIC_ASSERT(!mListener);
 
   // Start actor destruction from parent process
   Unused << SendTeardown();
 }
 
 void
 CacheStorageChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   RefPtr<CacheStorage> listener = mListener;
   if (listener) {
     listener->DestroyInternal(this);
     // CacheStorage listener should call ClearListener() in DestroyInternal()
-    MOZ_ASSERT(!mListener);
+    MOZ_DIAGNOSTIC_ASSERT(!mListener);
   }
 
   RemoveWorkerHolder();
 }
 
 PCacheOpChild*
 CacheStorageChild::AllocPCacheOpChild(const CacheOpArgs& aOpArgs)
 {
@@ -131,17 +131,17 @@ CacheStorageChild::DeallocPCacheOpChild(
   delete aActor;
   NoteDeletedActor();
   return true;
 }
 
 void
 CacheStorageChild::NoteDeletedActor()
 {
-  MOZ_ASSERT(mNumChildActors);
+  MOZ_DIAGNOSTIC_ASSERT(mNumChildActors);
   mNumChildActors -= 1;
   if (!mNumChildActors && mDelayedDestroy) {
     StartDestroy();
   }
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -38,28 +38,28 @@ DeallocPCacheStorageParent(PCacheStorage
 
 CacheStorageParent::CacheStorageParent(PBackgroundParent* aManagingActor,
                                        Namespace aNamespace,
                                        const PrincipalInfo& aPrincipalInfo)
   : mNamespace(aNamespace)
   , mVerifiedStatus(NS_OK)
 {
   MOZ_COUNT_CTOR(cache::CacheStorageParent);
-  MOZ_ASSERT(aManagingActor);
+  MOZ_DIAGNOSTIC_ASSERT(aManagingActor);
 
   // Start the async principal verification process immediately.
   mVerifier = PrincipalVerifier::CreateAndDispatch(this, aManagingActor,
                                                    aPrincipalInfo);
-  MOZ_ASSERT(mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(mVerifier);
 }
 
 CacheStorageParent::~CacheStorageParent()
 {
   MOZ_COUNT_DTOR(cache::CacheStorageParent);
-  MOZ_ASSERT(!mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(!mVerifier);
 }
 
 void
 CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mVerifier) {
     mVerifier->RemoveListener(this);
     mVerifier = nullptr;
@@ -90,29 +90,29 @@ CacheStorageParent::DeallocPCacheOpParen
 
 mozilla::ipc::IPCResult
 CacheStorageParent::RecvPCacheOpConstructor(PCacheOpParent* aActor,
                                             const CacheOpArgs& aOpArgs)
 {
   auto actor = static_cast<CacheOpParent*>(aActor);
 
   if (mVerifier) {
-    MOZ_ASSERT(!mManagerId);
+    MOZ_DIAGNOSTIC_ASSERT(!mManagerId);
     actor->WaitForVerification(mVerifier);
     return IPC_OK();
   }
 
   if (NS_WARN_IF(NS_FAILED(mVerifiedStatus))) {
     ErrorResult result(mVerifiedStatus);
     Unused << CacheOpParent::Send__delete__(actor, result, void_t());
     result.SuppressException();
     return IPC_OK();
   }
 
-  MOZ_ASSERT(mManagerId);
+  MOZ_DIAGNOSTIC_ASSERT(mManagerId);
   actor->Execute(mManagerId);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 CacheStorageParent::RecvTeardown()
 {
   if (!Send__delete__(this)) {
@@ -120,19 +120,19 @@ CacheStorageParent::RecvTeardown()
     NS_WARNING("CacheStorage failed to delete actor.");
   }
   return IPC_OK();
 }
 
 void
 CacheStorageParent::OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)
 {
-  MOZ_ASSERT(mVerifier);
-  MOZ_ASSERT(!mManagerId);
-  MOZ_ASSERT(NS_SUCCEEDED(mVerifiedStatus));
+  MOZ_DIAGNOSTIC_ASSERT(mVerifier);
+  MOZ_DIAGNOSTIC_ASSERT(!mManagerId);
+  MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(mVerifiedStatus));
 
   if (NS_WARN_IF(NS_FAILED(aRv))) {
     mVerifiedStatus = aRv;
   }
 
   mManagerId = aManagerId;
   mVerifier->RemoveListener(this);
   mVerifier = nullptr;
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -1,17 +1,16 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
-#include "mozilla/DebugOnly.h"
 #include "mozilla/Unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "nsISupportsImpl.h"
@@ -84,28 +83,29 @@ CacheStreamControlChild::StartDestroy()
   // asked us to shutdown.  So simulate the CloseAll IPC message.
   RecvCloseAll();
 }
 
 void
 CacheStreamControlChild::SerializeControl(CacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
   aReadStreamOut->controlParent() = nullptr;
   aReadStreamOut->controlChild() = this;
 }
 
 void
 CacheStreamControlChild::SerializeStream(CacheReadStream* aReadStreamOut,
                                          nsIInputStream* aStream,
                                          nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  MOZ_ASSERT(aReadStreamOut);
-  MOZ_ASSERT(aStream);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(aStream);
   UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(aReadStreamOut->stream()));
   autoStream->Serialize(aStream, Manager());
   aStreamCleanupList.AppendElement(Move(autoStream));
 }
 
 void
 CacheStreamControlChild::NoteClosedAfterForget(const nsID& aId)
 {
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -1,17 +1,16 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 
-#include "mozilla/DebugOnly.h"
 #include "mozilla/Unused.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsISupportsImpl.h"
@@ -35,35 +34,37 @@ DeallocPCacheStreamControlParent(PCacheS
 CacheStreamControlParent::CacheStreamControlParent()
 {
   MOZ_COUNT_CTOR(cache::CacheStreamControlParent);
 }
 
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(!mStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(!mStreamList);
   MOZ_COUNT_DTOR(cache::CacheStreamControlParent);
 }
 
 void
 CacheStreamControlParent::SerializeControl(CacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
   aReadStreamOut->controlChild() = nullptr;
   aReadStreamOut->controlParent() = this;
 }
 
 void
 CacheStreamControlParent::SerializeStream(CacheReadStream* aReadStreamOut,
                                           nsIInputStream* aStream,
                                           nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(aStream);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(aStream);
   UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(aReadStreamOut->stream()));
   autoStream->Serialize(aStream, Manager());
   aStreamCleanupList.AppendElement(Move(autoStream));
 }
 
 void
 CacheStreamControlParent::NoteClosedAfterForget(const nsID& aId)
 {
@@ -88,26 +89,26 @@ CacheStreamControlParent::ActorDestroy(A
   mStreamList->NoteClosedAll();
   mStreamList = nullptr;
 }
 
 mozilla::ipc::IPCResult
 CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(mStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(mStreamList);
   mStreamList->NoteClosed(aId);
   return IPC_OK();
 }
 
 void
 CacheStreamControlParent::SetStreamList(StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  MOZ_ASSERT(!mStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(!mStreamList);
   mStreamList = aStreamList;
 }
 
 void
 CacheStreamControlParent::Close(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   NotifyClose(aId);
diff --git a/dom/cache/CacheWorkerHolder.cpp b/dom/cache/CacheWorkerHolder.cpp
--- a/dom/cache/CacheWorkerHolder.cpp
+++ b/dom/cache/CacheWorkerHolder.cpp
@@ -16,31 +16,31 @@ namespace cache {
 using mozilla::dom::workers::Terminating;
 using mozilla::dom::workers::Status;
 using mozilla::dom::workers::WorkerPrivate;
 
 // static
 already_AddRefed<CacheWorkerHolder>
 CacheWorkerHolder::Create(WorkerPrivate* aWorkerPrivate)
 {
-  MOZ_ASSERT(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
 
   RefPtr<CacheWorkerHolder> workerHolder = new CacheWorkerHolder();
   if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, Terminating))) {
     return nullptr;
   }
 
   return workerHolder.forget();
 }
 
 void
 CacheWorkerHolder::AddActor(ActorChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheWorkerHolder);
-  MOZ_ASSERT(aActor);
+  MOZ_DIAGNOSTIC_ASSERT(aActor);
   MOZ_ASSERT(!mActorList.Contains(aActor));
 
   mActorList.AppendElement(aActor);
 
   // Allow an actor to be added after we've entered the Notifying case.  We
   // can't stop the actor creation from racing with out destruction of the
   // other actors and we need to wait for this extra one to close as well.
   // Signal it should destroy itself right away.
@@ -48,21 +48,24 @@ CacheWorkerHolder::AddActor(ActorChild* 
     aActor->StartDestroy();
   }
 }
 
 void
 CacheWorkerHolder::RemoveActor(ActorChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheWorkerHolder);
-  MOZ_ASSERT(aActor);
+  MOZ_DIAGNOSTIC_ASSERT(aActor);
 
-  DebugOnly<bool> removed = mActorList.RemoveElement(aActor);
+#if defined(RELEASE_OR_BETA)
+  mActorList.RemoveElement(aActor);
+#else
+  MOZ_DIAGNOSTIC_ASSERT(mActorList.RemoveElement(aActor));
+#endif
 
-  MOZ_ASSERT(removed);
   MOZ_ASSERT(!mActorList.Contains(aActor));
 }
 
 bool
 CacheWorkerHolder::Notified() const
 {
   return mNotified;
 }
@@ -78,28 +81,29 @@ CacheWorkerHolder::Notify(Status aStatus
     return true;
   }
 
   mNotified = true;
 
   // Start the asynchronous destruction of our actors.  These will call back
   // into RemoveActor() once the actor is destroyed.
   for (uint32_t i = 0; i < mActorList.Length(); ++i) {
+    MOZ_DIAGNOSTIC_ASSERT(mActorList[i]);
     mActorList[i]->StartDestroy();
   }
 
   return true;
 }
 
 CacheWorkerHolder::CacheWorkerHolder()
   : mNotified(false)
 {
 }
 
 CacheWorkerHolder::~CacheWorkerHolder()
 {
   NS_ASSERT_OWNINGTHREAD(CacheWorkerHolder);
-  MOZ_ASSERT(mActorList.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(mActorList.IsEmpty());
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Connection.cpp b/dom/cache/Connection.cpp
--- a/dom/cache/Connection.cpp
+++ b/dom/cache/Connection.cpp
@@ -17,17 +17,17 @@ using mozilla::dom::quota::QuotaObject;
 
 NS_IMPL_ISUPPORTS(cache::Connection, mozIStorageAsyncConnection,
                                      mozIStorageConnection);
 
 Connection::Connection(mozIStorageConnection* aBase)
   : mBase(aBase)
   , mClosed(false)
 {
-  MOZ_ASSERT(mBase);
+  MOZ_DIAGNOSTIC_ASSERT(mBase);
 }
 
 Connection::~Connection()
 {
   NS_ASSERT_OWNINGTHREAD(Connection);
   MOZ_ALWAYS_SUCCEEDS(Close());
 }
 
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -2,17 +2,16 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/AutoRestore.h"
-#include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Action.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "mozIStorageConnection.h"
 #include "nsIFile.h"
 #include "nsIPrincipal.h"
@@ -30,57 +29,56 @@ public:
   NullAction()
   {
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
   {
     // Resolve success immediately.  This Action does no actual work.
-    MOZ_ASSERT(aResolver);
+    MOZ_DIAGNOSTIC_ASSERT(aResolver);
     aResolver->Resolve(NS_OK);
   }
 };
 
 } // namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-using mozilla::DebugOnly;
 using mozilla::dom::quota::AssertIsOnIOThread;
 using mozilla::dom::quota::OpenDirectoryListener;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
 class Context::Data final : public Action::Data
 {
 public:
   explicit Data(nsIThread* aTarget)
     : mTarget(aTarget)
   {
-    MOZ_ASSERT(mTarget);
+    MOZ_DIAGNOSTIC_ASSERT(mTarget);
   }
 
   virtual mozIStorageConnection*
   GetConnection() const override
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     return mConnection;
   }
 
   virtual void
   SetConnection(mozIStorageConnection* aConn) override
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(!mConnection);
+    MOZ_DIAGNOSTIC_ASSERT(!mConnection);
     mConnection = aConn;
-    MOZ_ASSERT(mConnection);
+    MOZ_DIAGNOSTIC_ASSERT(mConnection);
   }
 
 private:
   ~Data()
   {
     // We could proxy release our data here, but instead just assert.  The
     // Context code should guarantee that we are destroyed on the target
     // thread once the connection is initialized.  If we're not, then
@@ -114,42 +112,42 @@ public:
     , mData(aData)
     , mTarget(aTarget)
     , mInitAction(aInitAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mResult(NS_OK)
     , mState(STATE_INIT)
     , mCanceled(false)
   {
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mManager);
-    MOZ_ASSERT(mData);
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mInitiatingThread);
-    MOZ_ASSERT(mInitAction);
+    MOZ_DIAGNOSTIC_ASSERT(mContext);
+    MOZ_DIAGNOSTIC_ASSERT(mManager);
+    MOZ_DIAGNOSTIC_ASSERT(mData);
+    MOZ_DIAGNOSTIC_ASSERT(mTarget);
+    MOZ_DIAGNOSTIC_ASSERT(mInitiatingThread);
+    MOZ_DIAGNOSTIC_ASSERT(mInitAction);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_INIT);
 
     mState = STATE_GET_INFO;
     nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
   void Cancel()
   {
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(!mCanceled);
+    MOZ_DIAGNOSTIC_ASSERT(!mCanceled);
     mCanceled = true;
     mInitAction->CancelOnInitiatingThread();
   }
 
   void OpenDirectory();
 
   // OpenDirectoryListener methods
   virtual void
@@ -165,17 +163,17 @@ private:
     SyncResolver()
       : mResolved(false)
       , mResult(NS_OK)
     { }
 
     virtual void
     Resolve(nsresult aRv) override
     {
-      MOZ_ASSERT(!mResolved);
+      MOZ_DIAGNOSTIC_ASSERT(!mResolved);
       mResolved = true;
       mResult = aRv;
     };
 
     bool Resolved() const { return mResolved; }
     nsresult Result() const { return mResult; }
 
   private:
@@ -184,19 +182,19 @@ private:
     bool mResolved;
     nsresult mResult;
 
     NS_INLINE_DECL_REFCOUNTING(Context::QuotaInitRunnable::SyncResolver, override)
   };
 
   ~QuotaInitRunnable()
   {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mInitAction);
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_COMPLETE);
+    MOZ_DIAGNOSTIC_ASSERT(!mContext);
+    MOZ_DIAGNOSTIC_ASSERT(!mInitAction);
   }
 
   enum State
   {
     STATE_INIT,
     STATE_GET_INFO,
     STATE_CREATE_QUOTA_MANAGER,
     STATE_OPEN_DIRECTORY,
@@ -205,30 +203,30 @@ private:
     STATE_RUN_ON_TARGET,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Complete(nsresult aResult)
   {
-    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
 
-    MOZ_ASSERT(NS_SUCCEEDED(mResult));
+    MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(mResult));
     mResult = aResult;
 
     mState = STATE_COMPLETING;
     MOZ_ALWAYS_SUCCEEDS(
       mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
   }
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mContext);
+    MOZ_DIAGNOSTIC_ASSERT(mContext);
     mContext = nullptr;
     mManager = nullptr;
     mInitAction = nullptr;
   }
 
   RefPtr<Context> mContext;
   RefPtr<ThreadsafeHandle> mThreadsafeHandle;
   RefPtr<Manager> mManager;
@@ -246,19 +244,19 @@ public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
 void
 Context::QuotaInitRunnable::OpenDirectory()
 {
   NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
-             mState == STATE_OPEN_DIRECTORY);
-  MOZ_ASSERT(QuotaManager::Get());
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
+                        mState == STATE_OPEN_DIRECTORY);
+  MOZ_DIAGNOSTIC_ASSERT(QuotaManager::Get());
 
   // QuotaManager::OpenDirectory() will hold a reference to us as
   // a listener.  We will then get DirectoryLockAcquired() on the owning
   // thread when it is safe to access our storage directory.
   mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
   QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
                                      mQuotaInfo.mGroup,
                                      mQuotaInfo.mOrigin,
@@ -267,43 +265,43 @@ Context::QuotaInitRunnable::OpenDirector
                                      /* aExclusive */ false,
                                      this);
 }
 
 void
 Context::QuotaInitRunnable::DirectoryLockAcquired(DirectoryLock* aLock)
 {
   NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_DIAGNOSTIC_ASSERT(!mDirectoryLock);
 
   mDirectoryLock = aLock;
 
   if (mCanceled) {
     Complete(NS_ERROR_ABORT);
     return;
   }
 
   QuotaManager* qm = QuotaManager::Get();
-  MOZ_ASSERT(qm);
+  MOZ_DIAGNOSTIC_ASSERT(qm);
 
   mState = STATE_ENSURE_ORIGIN_INITIALIZED;
   nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     Complete(rv);
     return;
   }
 }
 
 void
 Context::QuotaInitRunnable::DirectoryLockFailed()
 {
   NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_DIAGNOSTIC_ASSERT(!mDirectoryLock);
 
   NS_WARNING("Failed to acquire a directory lock!");
 
   Complete(NS_ERROR_FAILURE);
 }
 
 NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::QuotaInitRunnable, nsIRunnable);
 
@@ -429,17 +427,17 @@ Context::QuotaInitRunnable::Run()
       AssertIsOnIOThread();
 
       if (mCanceled) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       QuotaManager* qm = QuotaManager::Get();
-      MOZ_ASSERT(qm);
+      MOZ_DIAGNOSTIC_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mSuffix,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
         resolver->Resolve(rv);
@@ -457,17 +455,17 @@ Context::QuotaInitRunnable::Run()
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
 
       mState = STATE_RUNNING;
 
       // Execute the provided initialization Action.  The Action must Resolve()
       // before returning.
       mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
-      MOZ_ASSERT(resolver->Resolved());
+      MOZ_DIAGNOSTIC_ASSERT(resolver->Resolved());
 
       mData = nullptr;
 
       // If the database was opened, then we should always succeed when creating
       // the marker file.  If it wasn't opened successfully, then no need to
       // create a marker file anyway.
       if (NS_SUCCEEDED(resolver->Result())) {
         MOZ_ALWAYS_SUCCEEDS(CreateMarkerFile(mQuotaInfo));
@@ -518,28 +516,28 @@ public:
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
     , mExecutingRunOnTarget(false)
   {
-    MOZ_ASSERT(mContext);
+    MOZ_DIAGNOSTIC_ASSERT(mContext);
     // mData may be nullptr
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mAction);
+    MOZ_DIAGNOSTIC_ASSERT(mTarget);
+    MOZ_DIAGNOSTIC_ASSERT(mAction);
     // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
-    MOZ_ASSERT(mInitiatingThread);
+    MOZ_DIAGNOSTIC_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_INIT);
 
     mState = STATE_RUN_ON_TARGET;
     nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
@@ -557,17 +555,17 @@ public:
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) override
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(mState == STATE_RUNNING);
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_RUNNING);
 
     mResult = aRv;
 
     // We ultimately must complete on the initiating thread, but bounce through
     // the current thread again to ensure that we don't destroy objects and
     // state out from under the currently running action's stack.
     mState = STATE_RESOLVING;
 
@@ -583,26 +581,26 @@ public:
     // bounce to run on the target thread again.
     MOZ_ALWAYS_SUCCEEDS(
       mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
   }
 
 private:
   ~ActionRunnable()
   {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mAction);
+    MOZ_DIAGNOSTIC_ASSERT(mState == STATE_COMPLETE);
+    MOZ_DIAGNOSTIC_ASSERT(!mContext);
+    MOZ_DIAGNOSTIC_ASSERT(!mAction);
   }
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mAction);
+    MOZ_DIAGNOSTIC_ASSERT(mContext);
+    MOZ_DIAGNOSTIC_ASSERT(mAction);
     mContext->RemoveActivity(this);
     mContext = nullptr;
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
@@ -668,17 +666,17 @@ NS_IMPL_ISUPPORTS(mozilla::dom::cache::C
 NS_IMETHODIMP
 Context::ActionRunnable::Run()
 {
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      MOZ_ASSERT(!mExecutingRunOnTarget);
+      MOZ_DIAGNOSTIC_ASSERT(!mExecutingRunOnTarget);
 
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
       mState = STATE_RUNNING;
       mAction->RunOnTarget(this, mQuotaInfo, mData);
@@ -815,26 +813,26 @@ Context::ThreadsafeHandle::InvalidateAnd
   // Cancel the Context through the weak reference.  This means we can
   // allow the Context to close by dropping the strong ref, but then
   // still cancel ongoing IO if necessary.
   if (mWeakRef) {
     mWeakRef->Invalidate();
   }
   // We should synchronously have AllowToCloseOnOwningThread called when
   // the Context is canceled.
-  MOZ_ASSERT(!mStrongRef);
+  MOZ_DIAGNOSTIC_ASSERT(!mStrongRef);
 }
 
 void
 Context::ThreadsafeHandle::ContextDestroyed(Context* aContext)
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-  MOZ_ASSERT(!mStrongRef);
-  MOZ_ASSERT(mWeakRef);
-  MOZ_ASSERT(mWeakRef == aContext);
+  MOZ_DIAGNOSTIC_ASSERT(!mStrongRef);
+  MOZ_DIAGNOSTIC_ASSERT(mWeakRef);
+  MOZ_DIAGNOSTIC_ASSERT(mWeakRef == aContext);
   mWeakRef = nullptr;
 }
 
 // static
 already_AddRefed<Context>
 Context::Create(Manager* aManager, nsIThread* aTarget,
                 Action* aInitAction, Context* aOldContext)
 {
@@ -846,49 +844,49 @@ Context::Create(Manager* aManager, nsITh
 Context::Context(Manager* aManager, nsIThread* aTarget, Action* aInitAction)
   : mManager(aManager)
   , mTarget(aTarget)
   , mData(new Data(aTarget))
   , mState(STATE_CONTEXT_PREINIT)
   , mOrphanedData(false)
   , mInitAction(aInitAction)
 {
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(mTarget);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mTarget);
 }
 
 void
 Context::Dispatch(Action* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aAction);
+  MOZ_DIAGNOSTIC_ASSERT(aAction);
 
-  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
+  MOZ_DIAGNOSTIC_ASSERT(mState != STATE_CONTEXT_CANCELED);
   if (mState == STATE_CONTEXT_CANCELED) {
     return;
   } else if (mState == STATE_CONTEXT_INIT ||
              mState == STATE_CONTEXT_PREINIT) {
     PendingAction* pending = mPendingActions.AppendElement();
     pending->mAction = aAction;
     return;
   }
 
-  MOZ_ASSERT(mState == STATE_CONTEXT_READY);
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_CONTEXT_READY);
   DispatchAction(aAction);
 }
 
 void
 Context::CancelAll()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
   // In PREINIT state we have not dispatch the init action yet.  Just
   // forget it.
   if (mState == STATE_CONTEXT_PREINIT) {
-    MOZ_ASSERT(!mInitRunnable);
+    MOZ_DIAGNOSTIC_ASSERT(!mInitRunnable);
     mInitAction = nullptr;
 
   // In INIT state we have dispatched the runnable, but not received the
   // async completion yet.  Cancel the runnable, but don't forget about it
   // until we get OnQuotaInit() callback.
   } else if (mState == STATE_CONTEXT_INIT) {
     mInitRunnable->Cancel();
   }
@@ -948,18 +946,18 @@ Context::CancelForCacheId(CacheId aCache
       activity->Cancel();
     }
   }
 }
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(!mData);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(!mData);
 
   if (mThreadsafeHandle) {
     mThreadsafeHandle->ContextDestroyed(this);
   }
 
   // Note, this may set the mOrphanedData flag.
   mManager->RemoveContext(this);
 
@@ -988,23 +986,23 @@ Context::Init(Context* aOldContext)
 void
 Context::Start()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
   // Previous context closing delayed our start, but then we were canceled.
   // In this case, just do nothing here.
   if (mState == STATE_CONTEXT_CANCELED) {
-    MOZ_ASSERT(!mInitRunnable);
-    MOZ_ASSERT(!mInitAction);
+    MOZ_DIAGNOSTIC_ASSERT(!mInitRunnable);
+    MOZ_DIAGNOSTIC_ASSERT(!mInitAction);
     return;
   }
 
-  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
-  MOZ_ASSERT(!mInitRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_CONTEXT_PREINIT);
+  MOZ_DIAGNOSTIC_ASSERT(!mInitRunnable);
 
   mInitRunnable = new QuotaInitRunnable(this, mManager, mData, mTarget,
                                         mInitAction);
   mInitAction = nullptr;
 
   mState = STATE_CONTEXT_INIT;
 
   nsresult rv = mInitRunnable->Dispatch();
@@ -1038,24 +1036,24 @@ Context::DispatchAction(Action* aAction,
 }
 
 void
 Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                      already_AddRefed<DirectoryLock> aDirectoryLock)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
-  MOZ_ASSERT(mInitRunnable);
+  MOZ_DIAGNOSTIC_ASSERT(mInitRunnable);
   mInitRunnable = nullptr;
 
   mQuotaInfo = aQuotaInfo;
 
   // Always save the directory lock to ensure QuotaManager does not shutdown
   // before the Context has gone away.
-  MOZ_ASSERT(!mDirectoryLock);
+  MOZ_DIAGNOSTIC_ASSERT(!mDirectoryLock);
   mDirectoryLock = aDirectoryLock;
 
   // If we opening the context failed, but we were not explicitly canceled,
   // still treat the entire context as canceled.  We don't want to allow
   // new actions to be dispatched.  We also cannot leave the context in
   // the INIT state after failing to open.
   if (NS_FAILED(aRv)) {
     mState = STATE_CONTEXT_CANCELED;
@@ -1066,39 +1064,39 @@ Context::OnQuotaInit(nsresult aRv, const
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
     mThreadsafeHandle->AllowToClose();
     // Context will destruct after return here and last ref is released.
     return;
   }
 
-  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+  MOZ_DIAGNOSTIC_ASSERT(mState == STATE_CONTEXT_INIT);
   mState = STATE_CONTEXT_READY;
 
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     DispatchAction(mPendingActions[i].mAction);
   }
   mPendingActions.Clear();
 }
 
 void
 Context::AddActivity(Activity* aActivity)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActivity);
+  MOZ_DIAGNOSTIC_ASSERT(aActivity);
   MOZ_ASSERT(!mActivityList.Contains(aActivity));
   mActivityList.AppendElement(aActivity);
 }
 
 void
 Context::RemoveActivity(Activity* aActivity)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActivity);
+  MOZ_DIAGNOSTIC_ASSERT(aActivity);
   MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
   MOZ_ASSERT(!mActivityList.Contains(aActivity));
 }
 
 void
 Context::NoteOrphanedData()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
@@ -1116,36 +1114,36 @@ Context::CreateThreadsafeHandle()
   RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
   return ref.forget();
 }
 
 void
 Context::SetNextContext(Context* aNextContext)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aNextContext);
-  MOZ_ASSERT(!mNextContext);
+  MOZ_DIAGNOSTIC_ASSERT(aNextContext);
+  MOZ_DIAGNOSTIC_ASSERT(!mNextContext);
   mNextContext = aNextContext;
 }
 
 void
 Context::DoomTargetData()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(mData);
+  MOZ_DIAGNOSTIC_ASSERT(mData);
 
   // We are about to drop our reference to the Data.  We need to ensure that
   // the ~Context() destructor does not run until contents of Data have been
   // released on the Target thread.
 
   // Dispatch a no-op Action.  This will hold the Context alive through a
   // roundtrip to the target thread and back to the owning thread.  The
   // ref to the Data object is cleared on the owning thread after creating
   // the ActionRunnable, but before dispatching it.
   RefPtr<Action> action = new NullAction();
   DispatchAction(action, true /* doomed data */);
 
-  MOZ_ASSERT(!mData);
+  MOZ_DIAGNOSTIC_ASSERT(!mData);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -35,18 +35,18 @@ DBAction::~DBAction()
 {
 }
 
 void
 DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                       Data* aOptionalData)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aResolver);
-  MOZ_ASSERT(aQuotaInfo.mDir);
+  MOZ_DIAGNOSTIC_ASSERT(aResolver);
+  MOZ_DIAGNOSTIC_ASSERT(aQuotaInfo.mDir);
 
   if (IsCanceled()) {
     aResolver->Resolve(NS_ERROR_ABORT);
     return;
   }
 
   nsCOMPtr<nsIFile> dbDir;
   nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
@@ -70,17 +70,17 @@ DBAction::RunOnTarget(Resolver* aResolve
 
   // If there is no previous Action, then we must open one.
   if (!conn) {
     rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
-    MOZ_ASSERT(conn);
+    MOZ_DIAGNOSTIC_ASSERT(conn);
 
     // Save this connection in the shared Data object so later Actions can
     // use it.  This avoids opening a new connection for every Action.
     if (aOptionalData) {
       // Since we know this connection will be around for as long as the
       // Cache is open, use our special wrapped connection class.  This
       // will let us perform certain operations once the Cache origin
       // is closed.
@@ -92,18 +92,18 @@ DBAction::RunOnTarget(Resolver* aResolve
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
 DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                          mozIStorageConnection** aConnOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aDBDir);
-  MOZ_ASSERT(aConnOut);
+  MOZ_DIAGNOSTIC_ASSERT(aDBDir);
+  MOZ_DIAGNOSTIC_ASSERT(aConnOut);
 
   nsCOMPtr<mozIStorageConnection> conn;
 
   bool exists;
   nsresult rv = aDBDir->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (!exists) {
@@ -213,19 +213,19 @@ SyncDBAction::~SyncDBAction()
 }
 
 void
 SyncDBAction::RunWithDBOnTarget(Resolver* aResolver,
                                 const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                                 mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aResolver);
-  MOZ_ASSERT(aDBDir);
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aResolver);
+  MOZ_DIAGNOSTIC_ASSERT(aDBDir);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsresult rv = RunSyncWithDBOnTarget(aQuotaInfo, aDBDir, aConn);
   aResolver->Resolve(rv);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -401,17 +401,17 @@ private:
   nsCOMPtr<mozIStorageConnection> mConn;
   bool mForeignKeyCheckingDisabled;
 };
 
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   int32_t schemaVersion;
   nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (schemaVersion == kLatestSchemaVersion) {
     // We already have the correct schema version.  Validate it matches
     // our expected schema and then proceed.
@@ -491,17 +491,17 @@ CreateOrMigrateSchema(mozIStorageConnect
 
   return rv;
 }
 
 nsresult
 InitializeConnection(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // This function needs to perform per-connection initialization tasks that
   // need to happen regardless of the schema.
 
   nsPrintfCString pragmas(
     // Use a smaller page size to improve perf/footprint; default is too large
     "PRAGMA page_size = %u; "
     // Enable auto_vacuum; this must happen after page_size and before WAL
@@ -566,18 +566,18 @@ InitializeConnection(mozIStorageConnecti
 
   return NS_OK;
 }
 
 nsresult
 CreateCacheId(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aCacheIdOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aCacheIdOut);
 
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "INSERT INTO caches DEFAULT VALUES;"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<mozIStorageStatement> state;
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
@@ -596,17 +596,17 @@ CreateCacheId(mozIStorageConnection* aCo
   return rv;
 }
 
 nsresult
 DeleteCacheId(mozIStorageConnection* aConn, CacheId aCacheId,
               nsTArray<nsID>& aDeletedBodyIdListOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // Delete the bodies explicitly as we need to read out the body IDs
   // anyway.  These body IDs must be deleted one-by-one as content may
   // still be referencing them invidivually.
   AutoTArray<EntryId, 256> matches;
   nsresult rv = QueryAll(aConn, aCacheId, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -634,35 +634,35 @@ DeleteCacheId(mozIStorageConnection* aCo
   return rv;
 }
 
 nsresult
 IsCacheOrphaned(mozIStorageConnection* aConn, CacheId aCacheId,
                 bool* aOrphanedOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aOrphanedOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aOrphanedOut);
 
   // err on the side of not deleting user data
   *aOrphanedOut = false;
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT COUNT(*) FROM storage WHERE cache_id=:cache_id;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64ByName(NS_LITERAL_CSTRING("cache_id"), aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  MOZ_ASSERT(hasMoreData);
+  MOZ_DIAGNOSTIC_ASSERT(hasMoreData);
 
   int32_t refCount;
   rv = state->GetInt32(0, &refCount);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   *aOrphanedOut = refCount == 0;
 
   return rv;
@@ -689,17 +689,17 @@ FindOrphanedCacheIds(mozIStorageConnecti
 
   return rv;
 }
 
 nsresult
 GetKnownBodyIds(mozIStorageConnection* aConn, nsTArray<nsID>& aBodyIdListOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT request_body_id, response_body_id FROM entries;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData = false;
@@ -727,19 +727,19 @@ GetKnownBodyIds(mozIStorageConnection* a
 nsresult
 CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
            const CacheRequest& aRequest,
            const CacheQueryParams& aParams,
            bool* aFoundResponseOut,
            SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aFoundResponseOut);
-  MOZ_ASSERT(aSavedResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aFoundResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aSavedResponseOut);
 
   *aFoundResponseOut = false;
 
   AutoTArray<EntryId, 1> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches, 1);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (matches.IsEmpty()) {
@@ -757,17 +757,17 @@ CacheMatch(mozIStorageConnection* aConn,
 
 nsresult
 CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
               const CacheRequestOrVoid& aRequestOrVoid,
               const CacheQueryParams& aParams,
               nsTArray<SavedResponse>& aSavedResponsesOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
   nsresult rv;
 
   AutoTArray<EntryId, 256> matches;
   if (aRequestOrVoid.type() == CacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
@@ -790,17 +790,17 @@ nsresult
 CachePut(mozIStorageConnection* aConn, CacheId aCacheId,
          const CacheRequest& aRequest,
          const nsID* aRequestBodyId,
          const CacheResponse& aResponse,
          const nsID* aResponseBodyId,
          nsTArray<nsID>& aDeletedBodyIdListOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   CacheQueryParams params(false, false, false, false,
                            NS_LITERAL_STRING(""));
   AutoTArray<EntryId, 256> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, params, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   AutoTArray<IdCount, 16> deletedSecurityIdList;
@@ -822,18 +822,18 @@ CachePut(mozIStorageConnection* aConn, C
 
 nsresult
 CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
             const CacheRequest& aRequest,
             const CacheQueryParams& aParams,
             nsTArray<nsID>& aDeletedBodyIdListOut, bool* aSuccessOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aSuccessOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aSuccessOut);
 
   *aSuccessOut = false;
 
   AutoTArray<EntryId, 256> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (matches.IsEmpty()) {
@@ -855,17 +855,17 @@ CacheDelete(mozIStorageConnection* aConn
 
 nsresult
 CacheKeys(mozIStorageConnection* aConn, CacheId aCacheId,
           const CacheRequestOrVoid& aRequestOrVoid,
           const CacheQueryParams& aParams,
           nsTArray<SavedRequest>& aSavedRequestsOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
   nsresult rv;
 
   AutoTArray<EntryId, 256> matches;
   if (aRequestOrVoid.type() == CacheRequestOrVoid::Tvoid_t) {
     rv = QueryAll(aConn, aCacheId, matches);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   } else {
     rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
@@ -888,19 +888,19 @@ nsresult
 StorageMatch(mozIStorageConnection* aConn,
              Namespace aNamespace,
              const CacheRequest& aRequest,
              const CacheQueryParams& aParams,
              bool* aFoundResponseOut,
              SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aFoundResponseOut);
-  MOZ_ASSERT(aSavedResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aFoundResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aSavedResponseOut);
 
   *aFoundResponseOut = false;
 
   nsresult rv;
 
   // If we are given a cache to check, then simply find its cache ID
   // and perform the match.
   if (!aParams.cacheName().EqualsLiteral("")) {
@@ -956,19 +956,19 @@ StorageMatch(mozIStorageConnection* aCon
 }
 
 nsresult
 StorageGetCacheId(mozIStorageConnection* aConn, Namespace aNamespace,
                   const nsAString& aKey, bool* aFoundCacheOut,
                   CacheId* aCacheIdOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aFoundCacheOut);
-  MOZ_ASSERT(aCacheIdOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aFoundCacheOut);
+  MOZ_DIAGNOSTIC_ASSERT(aCacheIdOut);
 
   *aFoundCacheOut = false;
 
   // How we constrain the key column depends on the value of our key.  Use
   // a format string for the query and let CreateAndBindKeyStatement() fill
   // it in for us.
   const char* query = "SELECT cache_id FROM storage "
                       "WHERE namespace=:namespace AND %s "
@@ -997,17 +997,17 @@ StorageGetCacheId(mozIStorageConnection*
   return rv;
 }
 
 nsresult
 StoragePutCache(mozIStorageConnection* aConn, Namespace aNamespace,
                 const nsAString& aKey, CacheId aCacheId)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO storage (namespace, key, cache_id) "
                  "VALUES (:namespace, :key, :cache_id);"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1026,17 +1026,17 @@ StoragePutCache(mozIStorageConnection* a
   return rv;
 }
 
 nsresult
 StorageForgetCache(mozIStorageConnection* aConn, Namespace aNamespace,
                    const nsAString& aKey)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // How we constrain the key column depends on the value of our key.  Use
   // a format string for the query and let CreateAndBindKeyStatement() fill
   // it in for us.
   const char *query = "DELETE FROM storage WHERE namespace=:namespace AND %s;";
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = CreateAndBindKeyStatement(aConn, query, aKey,
@@ -1052,17 +1052,17 @@ StorageForgetCache(mozIStorageConnection
   return rv;
 }
 
 nsresult
 StorageGetKeys(mozIStorageConnection* aConn, Namespace aNamespace,
                nsTArray<nsString>& aKeysOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT key FROM storage WHERE namespace=:namespace ORDER BY rowid;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32ByName(NS_LITERAL_CSTRING("namespace"), aNamespace);
@@ -1082,17 +1082,17 @@ StorageGetKeys(mozIStorageConnection* aC
 
 namespace {
 
 nsresult
 QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
          nsTArray<EntryId>& aEntryIdListOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT id FROM entries WHERE cache_id=:cache_id ORDER BY id;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64ByName(NS_LITERAL_CSTRING("cache_id"), aCacheId);
@@ -1112,18 +1112,18 @@ QueryAll(mozIStorageConnection* aConn, C
 nsresult
 QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
            const CacheRequest& aRequest,
            const CacheQueryParams& aParams,
            nsTArray<EntryId>& aEntryIdListOut,
            uint32_t aMaxResults)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aMaxResults > 0);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aMaxResults > 0);
 
   if (!aParams.ignoreMethod() &&
       !aRequest.method().LowerCaseEqualsLiteral("get"))
   {
     return NS_OK;
   }
 
   nsAutoCString query(
@@ -1217,17 +1217,17 @@ QueryCache(mozIStorageConnection* aConn,
 }
 
 nsresult
 MatchByVaryHeader(mozIStorageConnection* aConn,
                   const CacheRequest& aRequest,
                   EntryId entryId, bool* aSuccessOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   *aSuccessOut = false;
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT value FROM response_headers "
     "WHERE name='vary' AND entry_id=:entry_id;"
   ), getter_AddRefs(state));
@@ -1243,17 +1243,17 @@ MatchByVaryHeader(mozIStorageConnection*
     nsAutoCString value;
     rv = state->GetUTF8String(0, value);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     varyValues.AppendElement(value);
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Should not have called this function if this was not the case
-  MOZ_ASSERT(!varyValues.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(!varyValues.IsEmpty());
 
   state->Reset();
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT name, value FROM request_headers "
     "WHERE entry_id=:entry_id;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1288,33 +1288,33 @@ MatchByVaryHeader(mozIStorageConnection*
     // Extract the header names inside the Vary header value.
     nsAutoCString varyValue(varyValues[i]);
     char* rawBuffer = varyValue.BeginWriting();
     char* token = nsCRT::strtok(rawBuffer, NS_HTTP_HEADER_SEPS, &rawBuffer);
     bool bailOut = false;
     for (; token;
          token = nsCRT::strtok(rawBuffer, NS_HTTP_HEADER_SEPS, &rawBuffer)) {
       nsDependentCString header(token);
-      MOZ_ASSERT(!header.EqualsLiteral("*"),
-                 "We should have already caught this in "
-                 "TypeUtils::ToPCacheResponseWithoutBody()");
+      MOZ_DIAGNOSTIC_ASSERT(!header.EqualsLiteral("*"),
+                            "We should have already caught this in "
+                            "TypeUtils::ToPCacheResponseWithoutBody()");
 
       ErrorResult errorResult;
       nsAutoCString queryValue;
       queryHeaders->Get(header, queryValue, errorResult);
       if (errorResult.Failed()) {
         errorResult.SuppressException();
-        MOZ_ASSERT(queryValue.IsEmpty());
+        MOZ_DIAGNOSTIC_ASSERT(queryValue.IsEmpty());
       }
 
       nsAutoCString cachedValue;
       cachedHeaders->Get(header, cachedValue, errorResult);
       if (errorResult.Failed()) {
         errorResult.SuppressException();
-        MOZ_ASSERT(cachedValue.IsEmpty());
+        MOZ_DIAGNOSTIC_ASSERT(cachedValue.IsEmpty());
       }
 
       if (queryValue != cachedValue) {
         varyHeadersMatch = false;
         bailOut = true;
         break;
       }
     }
@@ -1331,23 +1331,23 @@ MatchByVaryHeader(mozIStorageConnection*
 nsresult
 DeleteEntries(mozIStorageConnection* aConn,
               const nsTArray<EntryId>& aEntryIdList,
               nsTArray<nsID>& aDeletedBodyIdListOut,
               nsTArray<IdCount>& aDeletedSecurityIdListOut,
               uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   if (aEntryIdList.IsEmpty()) {
     return NS_OK;
   }
 
-  MOZ_ASSERT(aPos < aEntryIdList.Length());
+  MOZ_DIAGNOSTIC_ASSERT(aPos < aEntryIdList.Length());
 
   if (aLen < 0) {
     aLen = aEntryIdList.Length() - aPos;
   }
 
   // Sqlite limits the number of entries allowed for an IN clause,
   // so split up larger operations.
   if (aLen > kMaxEntriesPerStatement) {
@@ -1444,20 +1444,20 @@ DeleteEntries(mozIStorageConnection* aCo
 
   return rv;
 }
 
 nsresult
 InsertSecurityInfo(mozIStorageConnection* aConn, nsICryptoHash* aCrypto,
                    const nsACString& aData, int32_t *aIdOut)
 {
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aCrypto);
-  MOZ_ASSERT(aIdOut);
-  MOZ_ASSERT(!aData.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aCrypto);
+  MOZ_DIAGNOSTIC_ASSERT(aIdOut);
+  MOZ_DIAGNOSTIC_ASSERT(!aData.IsEmpty());
 
   // We want to use an index to find existing security blobs, but indexing
   // the full blob would be quite expensive.  Instead, we index a small
   // hash value.  Calculate this hash as the first 8 bytes of the SHA1 of
   // the full data.
   nsAutoCString hash;
   nsresult rv = HashCString(aCrypto, aData, hash);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -1561,17 +1561,17 @@ DeleteSecurityInfo(mozIStorageConnection
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t refcount = -1;
   rv = state->GetInt32(0, &refcount);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  MOZ_ASSERT(refcount >= aCount);
+  MOZ_DIAGNOSTIC_ASSERT(refcount >= aCount);
 
   // Next, calculate the new refcount
   int32_t newCount = refcount - aCount;
 
   // If the last reference to this security blob was removed we can
   // just remove the entire row.
   if (newCount == 0) {
     rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
@@ -1623,17 +1623,17 @@ DeleteSecurityInfoList(mozIStorageConnec
 nsresult
 InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
             const CacheRequest& aRequest,
             const nsID* aRequestBodyId,
             const CacheResponse& aResponse,
             const nsID* aResponseBodyId)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsICryptoHash> crypto =
     do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t securityId = -1;
@@ -1792,17 +1792,17 @@ InsertEntry(mozIStorageConnection* aConn
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsAutoCString serializedInfo;
   // We only allow content serviceworkers right now.
   if (aResponse.principalInfo().type() == mozilla::ipc::OptionalPrincipalInfo::TPrincipalInfo) {
     const mozilla::ipc::PrincipalInfo& principalInfo =
       aResponse.principalInfo().get_PrincipalInfo();
-    MOZ_ASSERT(principalInfo.type() == mozilla::ipc::PrincipalInfo::TContentPrincipalInfo);
+    MOZ_DIAGNOSTIC_ASSERT(principalInfo.type() == mozilla::ipc::PrincipalInfo::TContentPrincipalInfo);
     const mozilla::ipc::ContentPrincipalInfo& cInfo =
       principalInfo.get_ContentPrincipalInfo();
 
     serializedInfo.Append(cInfo.spec());
 
     nsAutoCString suffix;
     cInfo.attrs().CreateSuffix(suffix);
     serializedInfo.Append(suffix);
@@ -1907,18 +1907,18 @@ InsertEntry(mozIStorageConnection* aConn
   return rv;
 }
 
 nsresult
 ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
              SavedResponse* aSavedResponseOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aSavedResponseOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aSavedResponseOut);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "entries.response_type, "
       "entries.response_status, "
       "entries.response_status_text, "
       "entries.response_headers_guard, "
@@ -2035,18 +2035,18 @@ ReadResponse(mozIStorageConnection* aCon
   return rv;
 }
 
 nsresult
 ReadRequest(mozIStorageConnection* aConn, EntryId aEntryId,
             SavedRequest* aSavedRequestOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aSavedRequestOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aSavedRequestOut);
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "request_method, "
       "request_url_no_query, "
       "request_url_query, "
       "request_url_fragment, "
       "request_referrer, "
@@ -2154,45 +2154,45 @@ ReadRequest(mozIStorageConnection* aConn
 }
 
 void
 AppendListParamsToQuery(nsACString& aQuery,
                         const nsTArray<EntryId>& aEntryIdList,
                         uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
+  MOZ_DIAGNOSTIC_ASSERT((aPos + aLen) <= aEntryIdList.Length());
   for (int32_t i = aPos; i < aLen; ++i) {
     if (i == 0) {
       aQuery.AppendLiteral("?");
     } else {
       aQuery.AppendLiteral(",?");
     }
   }
 }
 
 nsresult
 BindListParamsToQuery(mozIStorageStatement* aState,
                       const nsTArray<EntryId>& aEntryIdList,
                       uint32_t aPos, int32_t aLen)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT((aPos + aLen) <= aEntryIdList.Length());
+  MOZ_DIAGNOSTIC_ASSERT((aPos + aLen) <= aEntryIdList.Length());
   for (int32_t i = aPos; i < aLen; ++i) {
     nsresult rv = aState->BindInt32ByIndex(i, aEntryIdList[i]);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return NS_OK;
 }
 
 nsresult
 BindId(mozIStorageStatement* aState, const nsACString& aName, const nsID* aId)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aState);
+  MOZ_DIAGNOSTIC_ASSERT(aState);
   nsresult rv;
 
   if (!aId) {
     rv = aState->BindNullByName(aName);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     return rv;
   }
 
@@ -2203,18 +2203,18 @@ BindId(mozIStorageStatement* aState, con
 
   return rv;
 }
 
 nsresult
 ExtractId(mozIStorageStatement* aState, uint32_t aPos, nsID* aIdOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aState);
-  MOZ_ASSERT(aIdOut);
+  MOZ_DIAGNOSTIC_ASSERT(aState);
+  MOZ_DIAGNOSTIC_ASSERT(aIdOut);
 
   nsAutoCString idString;
   nsresult rv = aState->GetUTF8String(aPos, idString);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool success = aIdOut->Parse(idString.get());
   if (NS_WARN_IF(!success)) { return NS_ERROR_UNEXPECTED; }
 
@@ -2222,19 +2222,19 @@ ExtractId(mozIStorageStatement* aState, 
 }
 
 nsresult
 CreateAndBindKeyStatement(mozIStorageConnection* aConn,
                           const char* aQueryFormat,
                           const nsAString& aKey,
                           mozIStorageStatement** aStateOut)
 {
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aQueryFormat);
-  MOZ_ASSERT(aStateOut);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aQueryFormat);
+  MOZ_DIAGNOSTIC_ASSERT(aStateOut);
 
   // The key is stored as a blob to avoid encoding issues.  An empty string
   // is mapped to NULL for blobs.  Normally we would just write the query
   // as "key IS :key" to do the proper NULL checking, but that prevents
   // sqlite from using the key index.  Therefore use "IS NULL" explicitly
   // if the key is empty, otherwise use "=:key" so that sqlite uses the
   // index.
   const char* constraint = nullptr;
@@ -2258,17 +2258,17 @@ CreateAndBindKeyStatement(mozIStorageCon
   state.forget(aStateOut);
 
   return rv;
 }
 
 nsresult
 HashCString(nsICryptoHash* aCrypto, const nsACString& aIn, nsACString& aOut)
 {
-  MOZ_ASSERT(aCrypto);
+  MOZ_DIAGNOSTIC_ASSERT(aCrypto);
 
   nsresult rv = aCrypto->Init(nsICryptoHash::SHA1);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aCrypto->Update(reinterpret_cast<const uint8_t*>(aIn.BeginReading()),
                        aIn.Length());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -2522,64 +2522,66 @@ RewriteEntriesSchema(mozIStorageConnecti
 
   return rv;
 }
 
 nsresult
 Migrate(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   int32_t currentVersion = 0;
   nsresult rv = aConn->GetSchemaVersion(&currentVersion);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool rewriteSchema = false;
 
   while (currentVersion < kLatestSchemaVersion) {
     // Wiping old databases is handled in DBAction because it requires
     // making a whole new mozIStorageConnection.  Make sure we don't
     // accidentally get here for one of those old databases.
-    MOZ_ASSERT(currentVersion >= kFirstShippedSchemaVersion);
+    MOZ_DIAGNOSTIC_ASSERT(currentVersion >= kFirstShippedSchemaVersion);
 
     for (uint32_t i = 0; i < sMigrationListLength; ++i) {
       if (sMigrationList[i].mFromVersion == currentVersion) {
         bool shouldRewrite = false;
         rv = sMigrationList[i].mFunc(aConn, shouldRewrite);
         if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
         if (shouldRewrite) {
           rewriteSchema = true;
         }
         break;
       }
     }
 
-    DebugOnly<int32_t> lastVersion = currentVersion;
+#if !defined(RELEASE_OR_BETA)
+    int32_t lastVersion = currentVersion;
+#endif
     rv = aConn->GetSchemaVersion(&currentVersion);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    MOZ_ASSERT(currentVersion > lastVersion);
+    MOZ_DIAGNOSTIC_ASSERT(currentVersion > lastVersion);
   }
 
-  MOZ_ASSERT(currentVersion == kLatestSchemaVersion);
+  MOZ_DIAGNOSTIC_ASSERT(currentVersion == kLatestSchemaVersion);
 
   if (rewriteSchema) {
     // Now overwrite the master SQL for the entries table to remove the column
     // default value.  This is also necessary for our Validate() method to
     // pass on this database.
     rv = RewriteEntriesSchema(aConn);
   }
 
   return rv;
 }
 
 nsresult MigrateFrom15To16(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // Add the request_redirect column with a default value of "follow".  Note,
   // we only use a default value here because its required by ALTER TABLE and
   // we need to apply the default "follow" to existing records in the table.
   // We don't actually want to keep the default in the schema for future
   // INSERTs.
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "ALTER TABLE entries "
@@ -2594,17 +2596,17 @@ nsresult MigrateFrom15To16(mozIStorageCo
 
   return rv;
 }
 
 nsresult
 MigrateFrom16To17(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // This migration path removes the response_redirected and
   // response_redirected_url columns from the entries table.  sqlite doesn't
   // support removing a column from a table using ALTER TABLE, so we need to
   // create a new table without those columns, fill it up with the existing
   // data, and then drop the original table and rename the new one to the old
   // one.
 
@@ -2726,17 +2728,17 @@ MigrateFrom16To17(mozIStorageConnection*
 
   return rv;
 }
 
 nsresult
 MigrateFrom17To18(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // This migration is needed in order to remove "only-if-cached" RequestCache
   // values from the database.  This enum value was removed from the spec in
   // https://github.com/whatwg/fetch/issues/39 but we unfortunately happily
   // accepted this value in the Request constructor.
   //
   // There is no good value to upgrade this to, so we just stick to "default".
 
@@ -2753,17 +2755,17 @@ MigrateFrom17To18(mozIStorageConnection*
 
   return rv;
 }
 
 nsresult
 MigrateFrom18To19(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // This migration is needed in order to update the RequestMode values for
   // Request objects corresponding to a navigation content policy type to
   // "navigate".
 
   static_assert(int(nsIContentPolicy::TYPE_DOCUMENT) == 6 &&
                 int(nsIContentPolicy::TYPE_SUBDOCUMENT) == 7 &&
                 int(nsIContentPolicy::TYPE_INTERNAL_FRAME) == 28 &&
@@ -2781,17 +2783,17 @@ MigrateFrom18To19(mozIStorageConnection*
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 nsresult MigrateFrom19To20(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // Add the request_referrer_policy column with a default value of
   // "no-referrer-when-downgrade".  Note, we only use a default value here
   // because its required by ALTER TABLE and we need to apply the default
   // "no-referrer-when-downgrade" to existing records in the table. We don't
   // actually want to keep the default in the schema for future INSERTs.
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "ALTER TABLE entries "
@@ -2805,17 +2807,17 @@ nsresult MigrateFrom19To20(mozIStorageCo
   aRewriteSchema = true;
 
   return rv;
 }
 
 nsresult MigrateFrom20To21(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // This migration creates response_url_list table to store response_url and
   // removes the response_url column from the entries table.
   // sqlite doesn't support removing a column from a table using ALTER TABLE,
   // so we need to create a new table without those columns, fill it up with the
   // existing data, and then drop the original table and rename the new one to
   // the old one.
 
@@ -2959,17 +2961,17 @@ nsresult MigrateFrom20To21(mozIStorageCo
   aRewriteSchema = true;
 
   return rv;
 }
 
 nsresult MigrateFrom21To22(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // Add the request_integrity column.
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "ALTER TABLE entries "
     "ADD COLUMN request_integrity TEXT NULL"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -2979,28 +2981,28 @@ nsresult MigrateFrom21To22(mozIStorageCo
   aRewriteSchema = true;
 
   return rv;
 }
 
 nsresult MigrateFrom22To23(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // The only change between 22 and 23 was a different snappy compression
   // format, but it's backwards-compatible.
   nsresult rv = aConn->SetSchemaVersion(23);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   return rv;
 }
 nsresult MigrateFrom23To24(mozIStorageConnection* aConn, bool& aRewriteSchema)
 {
   MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
+  MOZ_DIAGNOSTIC_ASSERT(aConn);
 
   // Add the request_url_fragment column.
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "ALTER TABLE entries "
     "ADD COLUMN request_url_fragment TEXT NOT NULL DEFAULT ''"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -38,17 +38,17 @@ BodyIdToFile(nsIFile* aBaseDir, const ns
              nsIFile** aBodyFileOut);
 
 } // namespace
 
 // static
 nsresult
 BodyCreateDir(nsIFile* aBaseDir)
 {
-  MOZ_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> aBodyDir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -60,17 +60,17 @@ BodyCreateDir(nsIFile* aBaseDir)
 
   return rv;
 }
 
 // static
 nsresult
 BodyDeleteDir(nsIFile* aBaseDir)
 {
-  MOZ_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> aBodyDir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -83,24 +83,24 @@ BodyDeleteDir(nsIFile* aBaseDir)
 
   return rv;
 }
 
 // static
 nsresult
 BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId, nsIFile** aCacheDirOut)
 {
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aCacheDirOut);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aCacheDirOut);
 
   *aCacheDirOut = nullptr;
 
   nsresult rv = aBaseDir->Clone(aCacheDirOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  MOZ_ASSERT(*aCacheDirOut);
+  MOZ_DIAGNOSTIC_ASSERT(*aCacheDirOut);
 
   rv = (*aCacheDirOut)->Append(NS_LITERAL_STRING("morgue"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Some file systems have poor performance when there are too many files
   // in a single directory.  Mitigate this issue by spreading the body
   // files out into sub-directories.  We use the last byte of the ID for
   // the name of the sub-directory.
@@ -121,22 +121,22 @@ BodyGetCacheDir(nsIFile* aBaseDir, const
 // static
 nsresult
 BodyStartWriteStream(const QuotaInfo& aQuotaInfo,
                      nsIFile* aBaseDir, nsIInputStream* aSource,
                      void* aClosure,
                      nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
                      nsISupports** aCopyContextOut)
 {
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aSource);
-  MOZ_ASSERT(aClosure);
-  MOZ_ASSERT(aCallback);
-  MOZ_ASSERT(aIdOut);
-  MOZ_ASSERT(aCopyContextOut);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aSource);
+  MOZ_DIAGNOSTIC_ASSERT(aClosure);
+  MOZ_DIAGNOSTIC_ASSERT(aCallback);
+  MOZ_DIAGNOSTIC_ASSERT(aIdOut);
+  MOZ_DIAGNOSTIC_ASSERT(aCopyContextOut);
 
   nsresult rv;
   nsCOMPtr<nsIUUIDGenerator> idGen =
     do_GetService("@mozilla.org/uuid-generator;1", &rv);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = idGen->GenerateUUIDInPlace(aIdOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -178,31 +178,31 @@ BodyStartWriteStream(const QuotaInfo& aQ
 
   return rv;
 }
 
 // static
 void
 BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext)
 {
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aCopyContext);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aCopyContext);
 
   nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
   Unused << NS_WARN_IF(NS_FAILED(rv));
 
   // The partially written file must be cleaned up after the async copy
   // makes its callback.
 }
 
 // static
 nsresult
 BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
 {
-  MOZ_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> tmpFile;
   nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFile> finalFile;
   rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL, getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -217,18 +217,18 @@ BodyFinalizeWrite(nsIFile* aBaseDir, con
   return rv;
 }
 
 // static
 nsresult
 BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
          nsIInputStream** aStreamOut)
 {
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamOut);
 
   nsCOMPtr<nsIFile> finalFile;
   nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
                              getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
@@ -287,24 +287,24 @@ BodyDeleteFiles(nsIFile* aBaseDir, const
 }
 
 namespace {
 
 nsresult
 BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
              nsIFile** aBodyFileOut)
 {
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aBodyFileOut);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aBodyFileOut);
 
   *aBodyFileOut = nullptr;
 
   nsresult rv = BodyGetCacheDir(aBaseDir, aId, aBodyFileOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  MOZ_ASSERT(*aBodyFileOut);
+  MOZ_DIAGNOSTIC_ASSERT(*aBodyFileOut);
 
   char idString[NSID_LENGTH];
   aId.ToProvidedString(idString);
 
   NS_ConvertASCIItoUTF16 fileName(idString);
 
   if (aType == BODY_FILE_FINAL) {
     fileName.AppendLiteral(".final");
@@ -318,17 +318,17 @@ BodyIdToFile(nsIFile* aBaseDir, const ns
   return rv;
 }
 
 } // namespace
 
 nsresult
 BodyDeleteOrphanedFiles(nsIFile* aBaseDir, nsTArray<nsID>& aKnownBodyIdList)
 {
-  MOZ_ASSERT(aBaseDir);
+  MOZ_DIAGNOSTIC_ASSERT(aBaseDir);
 
   // body files are stored in a directory structure like:
   //
   //  /morgue/01/{01fdddb2-884d-4c3d-95ba-0c8062f6c325}.final
   //  /morgue/02/{02fdddb2-884d-4c3d-95ba-0c8062f6c325}.tmp
 
   nsCOMPtr<nsIFile> dir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(dir));
@@ -416,17 +416,17 @@ BodyDeleteOrphanedFiles(nsIFile* aBaseDi
   return rv;
 }
 
 namespace {
 
 nsresult
 GetMarkerFileHandle(const QuotaInfo& aQuotaInfo, nsIFile** aFileOut)
 {
-  MOZ_ASSERT(aFileOut);
+  MOZ_DIAGNOSTIC_ASSERT(aFileOut);
 
   nsCOMPtr<nsIFile> marker;
   nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(marker));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = marker->Append(NS_LITERAL_STRING("cache"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -112,18 +112,18 @@ public:
   explicit DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
     mDeletedBodyIdList.AppendElement(aBodyId);
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo, Data*) override
   {
-    MOZ_ASSERT(aResolver);
-    MOZ_ASSERT(aQuotaInfo.mDir);
+    MOZ_DIAGNOSTIC_ASSERT(aResolver);
+    MOZ_DIAGNOSTIC_ASSERT(aQuotaInfo.mDir);
 
     // Note that since DeleteOrphanedBodyAction isn't used while the context is
     // being initialized, we don't need to check for cancellation here.
 
     nsCOMPtr<nsIFile> dbDir;
     nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
@@ -226,35 +226,35 @@ public:
 
     return nullptr;
   }
 
   static void
   Remove(Manager* aManager)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
-    MOZ_ASSERT(aManager);
-    MOZ_ASSERT(sFactory);
+    MOZ_DIAGNOSTIC_ASSERT(aManager);
+    MOZ_DIAGNOSTIC_ASSERT(sFactory);
 
     MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
 
     // clean up the factory singleton if there are no more managers
     MaybeDestroyInstance();
   }
 
   static void
   Abort(const nsACString& aOrigin)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
       return;
     }
 
-    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+    MOZ_DIAGNOSTIC_ASSERT(!sFactory->mManagerList.IsEmpty());
 
     {
       ManagerList::ForwardIterator iter(sFactory->mManagerList);
       while (iter.HasMore()) {
         RefPtr<Manager> manager = iter.GetNext();
         if (aOrigin.IsVoid() ||
             manager->mManagerId->QuotaOrigin() == aOrigin) {
           manager->Abort();
@@ -267,17 +267,17 @@ public:
   ShutdownAll()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
       return;
     }
 
-    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+    MOZ_DIAGNOSTIC_ASSERT(!sFactory->mManagerList.IsEmpty());
 
     {
       // Note that we are synchronously calling shutdown code here.  If any
       // of the shutdown code synchronously decides to delete the Factory
       // we need to delay that delete until the end of this method.
       AutoRestore<bool> restore(sFactory->mInSyncShutdown);
       sFactory->mInSyncShutdown = true;
 
@@ -303,18 +303,18 @@ private:
     : mInSyncShutdown(false)
   {
     MOZ_COUNT_CTOR(cache::Manager::Factory);
   }
 
   ~Factory()
   {
     MOZ_COUNT_DTOR(cache::Manager::Factory);
-    MOZ_ASSERT(mManagerList.IsEmpty());
-    MOZ_ASSERT(!mInSyncShutdown);
+    MOZ_DIAGNOSTIC_ASSERT(mManagerList.IsEmpty());
+    MOZ_DIAGNOSTIC_ASSERT(!mInSyncShutdown);
   }
 
   static nsresult
   MaybeCreateInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
@@ -343,17 +343,17 @@ private:
 
     return NS_OK;
   }
 
   static void
   MaybeDestroyInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
-    MOZ_ASSERT(sFactory);
+    MOZ_DIAGNOSTIC_ASSERT(sFactory);
 
     // If the factory is is still in use then we cannot delete yet.  This
     // could be due to managers still existing or because we are in the
     // middle of shutting down.  We need to be careful not to delete ourself
     // synchronously during shutdown.
     if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
       return;
     }
@@ -617,19 +617,19 @@ public:
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mCacheId(aCacheId)
     , mList(aPutList.Length())
     , mExpectedAsyncCopyCompletions(1)
     , mAsyncResult(NS_OK)
     , mMutex("cache::Manager::CachePutAllAction")
   {
-    MOZ_ASSERT(!aPutList.IsEmpty());
-    MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
-    MOZ_ASSERT(aPutList.Length() == aResponseStreamList.Length());
+    MOZ_DIAGNOSTIC_ASSERT(!aPutList.IsEmpty());
+    MOZ_DIAGNOSTIC_ASSERT(aPutList.Length() == aRequestStreamList.Length());
+    MOZ_DIAGNOSTIC_ASSERT(aPutList.Length() == aResponseStreamList.Length());
 
     for (uint32_t i = 0; i < aPutList.Length(); ++i) {
       Entry* entry = mList.AppendElement();
       entry->mRequest = aPutList[i].request();
       entry->mRequestStream = aRequestStreamList[i];
       entry->mResponse = aPutList[i].response();
       entry->mResponseStream = aResponseStreamList[i];
     }
@@ -637,31 +637,31 @@ public:
 
 private:
   ~CachePutAllAction() { }
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) override
   {
-    MOZ_ASSERT(aResolver);
-    MOZ_ASSERT(aDBDir);
-    MOZ_ASSERT(aConn);
-    MOZ_ASSERT(!mResolver);
-    MOZ_ASSERT(!mDBDir);
-    MOZ_ASSERT(!mConn);
+    MOZ_DIAGNOSTIC_ASSERT(aResolver);
+    MOZ_DIAGNOSTIC_ASSERT(aDBDir);
+    MOZ_DIAGNOSTIC_ASSERT(aConn);
+    MOZ_DIAGNOSTIC_ASSERT(!mResolver);
+    MOZ_DIAGNOSTIC_ASSERT(!mDBDir);
+    MOZ_DIAGNOSTIC_ASSERT(!mConn);
 
-    MOZ_ASSERT(!mTargetThread);
+    MOZ_DIAGNOSTIC_ASSERT(!mTargetThread);
     mTargetThread = NS_GetCurrentThread();
-    MOZ_ASSERT(mTargetThread);
+    MOZ_DIAGNOSTIC_ASSERT(mTargetThread);
 
     // We should be pre-initialized to expect one async completion.  This is
     // the "manual" completion we call at the end of this method in all
     // cases.
-    MOZ_ASSERT(mExpectedAsyncCopyCompletions == 1);
+    MOZ_DIAGNOSTIC_ASSERT(mExpectedAsyncCopyCompletions == 1);
 
     mResolver = aResolver;
     mDBDir = aDBDir;
     mConn = aConn;
 
     // File bodies are streamed to disk via asynchronous copying.  Start
     // this copying now.  Each copy will eventually result in a call
     // to OnAsyncCopyComplete().
@@ -690,19 +690,19 @@ private:
 
   // Called once for each asynchronous file copy whether it succeeds or
   // fails.  If a file copy is canceled, it still calls this method with
   // an error code.
   void
   OnAsyncCopyComplete(nsresult aRv)
   {
     MOZ_ASSERT(mTargetThread == NS_GetCurrentThread());
-    MOZ_ASSERT(mConn);
-    MOZ_ASSERT(mResolver);
-    MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
+    MOZ_DIAGNOSTIC_ASSERT(mConn);
+    MOZ_DIAGNOSTIC_ASSERT(mResolver);
+    MOZ_DIAGNOSTIC_ASSERT(mExpectedAsyncCopyCompletions > 0);
 
     // Explicitly check for cancellation here to catch a race condition.
     // Consider:
     //
     // 1) NS_AsyncCopy() executes on IO thread, but has not saved its
     //    copy context yet.
     // 2) CancelAllStreamCopying() occurs on PBackground thread
     // 3) Copy context from (1) is saved on IO thread.
@@ -837,30 +837,30 @@ private:
     ResponseStream
   };
 
   nsresult
   StartStreamCopy(const QuotaInfo& aQuotaInfo, Entry& aEntry,
                   StreamId aStreamId, uint32_t* aCopyCountOut)
   {
     MOZ_ASSERT(mTargetThread == NS_GetCurrentThread());
-    MOZ_ASSERT(aCopyCountOut);
+    MOZ_DIAGNOSTIC_ASSERT(aCopyCountOut);
 
     if (IsCanceled()) {
       return NS_ERROR_ABORT;
     }
 
     nsCOMPtr<nsIInputStream> source;
     nsID* bodyId;
 
     if (aStreamId == RequestStream) {
       source = aEntry.mRequestStream;
       bodyId = &aEntry.mRequestBodyId;
     } else {
-      MOZ_ASSERT(aStreamId == ResponseStream);
+      MOZ_DIAGNOSTIC_ASSERT(aStreamId == ResponseStream);
       source = aEntry.mResponseStream;
       bodyId = &aEntry.mResponseBodyId;
     }
 
     if (!source) {
       return NS_OK;
     }
 
@@ -893,17 +893,17 @@ private:
     }
     mCopyContextList.Clear();
   }
 
   static void
   AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
   {
     // May be on any thread, including STS event target.
-    MOZ_ASSERT(aClosure);
+    MOZ_DIAGNOSTIC_ASSERT(aClosure);
     // Weak ref as we are guaranteed to the action is alive until
     // CompleteOnInitiatingThread is called.
     CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
     action->CallOnAsyncCopyCompleteOnTargetThread(aRv);
   }
 
   void
   CallOnAsyncCopyCompleteOnTargetThread(nsresult aRv)
@@ -1448,23 +1448,23 @@ Manager::RemoveListener(Listener* aListe
                                   ListenerEntryListenerComparator()));
   MaybeAllowContextToClose();
 }
 
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(mContext);
-  MOZ_ASSERT(mContext == aContext);
+  MOZ_DIAGNOSTIC_ASSERT(mContext);
+  MOZ_DIAGNOSTIC_ASSERT(mContext == aContext);
 
   // Whether the Context destruction was triggered from the Manager going
   // idle or the underlying storage being invalidated, we should know we
   // are closing before the Context is destroyed.
-  MOZ_ASSERT(mState == Closing);
+  MOZ_DIAGNOSTIC_ASSERT(mState == Closing);
 
   // Before forgetting the Context, check to see if we have any outstanding
   // cache or body objects waiting for deletion.  If so, note that we've
   // orphaned data so it will be cleaned up on the next open.
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mOrphaned) {
       aContext->NoteOrphanedData();
       break;
@@ -1518,19 +1518,21 @@ Manager::AddRefCacheId(CacheId aCacheId)
 }
 
 void
 Manager::ReleaseCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
-      DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
+#if !defined(RELEASE_OR_BETA)
+      uint32_t oldRef = mCacheIdRefs[i].mCount;
+#endif
       mCacheIdRefs[i].mCount -= 1;
-      MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
+      MOZ_DIAGNOSTIC_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount == 0) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
         RefPtr<Context> context = mContext;
         // If the context is already gone, then orphan flag should have been
         // set in RemoveContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
@@ -1567,19 +1569,21 @@ Manager::AddRefBodyId(const nsID& aBodyI
 }
 
 void
 Manager::ReleaseBodyId(const nsID& aBodyId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
-      DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
+#if !defined(RELEASE_OR_BETA)
+      uint32_t oldRef = mBodyIdRefs[i].mCount;
+#endif
       mBodyIdRefs[i].mCount -= 1;
-      MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
+      MOZ_DIAGNOSTIC_ASSERT(mBodyIdRefs[i].mCount < oldRef);
       if (mBodyIdRefs[i].mCount < 1) {
         bool orphaned = mBodyIdRefs[i].mOrphaned;
         mBodyIdRefs.RemoveElementAt(i);
         RefPtr<Context> context = mContext;
         // If the context is already gone, then orphan flag should have been
         // set in RemoveContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
@@ -1603,43 +1607,43 @@ Manager::GetManagerId() const
   RefPtr<ManagerId> ref = mManagerId;
   return ref.forget();
 }
 
 void
 Manager::AddStreamList(StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(aStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamList);
   mStreamLists.AppendElement(aStreamList);
 }
 
 void
 Manager::RemoveStreamList(StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(aStreamList);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamList);
   mStreamLists.RemoveElement(aStreamList);
 }
 
 void
 Manager::ExecuteCacheOp(Listener* aListener, CacheId aCacheId,
                         const CacheOpArgs& aOpArgs)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(aListener);
-  MOZ_ASSERT(aOpArgs.type() != CacheOpArgs::TCachePutAllArgs);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(aOpArgs.type() != CacheOpArgs::TCachePutAllArgs);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
   RefPtr<Context> context = mContext;
-  MOZ_ASSERT(!context->IsCanceled());
+  MOZ_DIAGNOSTIC_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
   RefPtr<Action> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
       action = new CacheMatchAction(this, listenerId, aCacheId,
@@ -1665,25 +1669,25 @@ Manager::ExecuteCacheOp(Listener* aListe
   context->Dispatch(action);
 }
 
 void
 Manager::ExecuteStorageOp(Listener* aListener, Namespace aNamespace,
                           const CacheOpArgs& aOpArgs)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
   RefPtr<Context> context = mContext;
-  MOZ_ASSERT(!context->IsCanceled());
+  MOZ_DIAGNOSTIC_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
   RefPtr<Action> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TStorageMatchArgs:
       action = new StorageMatchAction(this, listenerId, aNamespace,
@@ -1714,25 +1718,25 @@ Manager::ExecuteStorageOp(Listener* aLis
 
 void
 Manager::ExecutePutAll(Listener* aListener, CacheId aCacheId,
                        const nsTArray<CacheRequestResponse>& aPutList,
                        const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                        const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), CachePutAllResult());
     return;
   }
 
   RefPtr<Context> context = mContext;
-  MOZ_ASSERT(!context->IsCanceled());
+  MOZ_DIAGNOSTIC_ASSERT(!context->IsCanceled());
 
   ListenerId listenerId = SaveListener(aListener);
 
   RefPtr<Action> action = new CachePutAllAction(this, listenerId, aCacheId,
                                                   aPutList, aRequestStreamList,
                                                   aResponseStreamList);
 
   context->Dispatch(action);
@@ -1740,25 +1744,25 @@ Manager::ExecutePutAll(Listener* aListen
 
 Manager::Manager(ManagerId* aManagerId, nsIThread* aIOThread)
   : mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
   , mShuttingDown(false)
   , mState(Open)
 {
-  MOZ_ASSERT(mManagerId);
-  MOZ_ASSERT(mIOThread);
+  MOZ_DIAGNOSTIC_ASSERT(mManagerId);
+  MOZ_DIAGNOSTIC_ASSERT(mIOThread);
 }
 
 Manager::~Manager()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(mState == Closing);
-  MOZ_ASSERT(!mContext);
+  MOZ_DIAGNOSTIC_ASSERT(mState == Closing);
+  MOZ_DIAGNOSTIC_ASSERT(!mContext);
 
   nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
 
   // Don't spin the event loop in the destructor waiting for the thread to
   // shutdown.  Defer this to the main thread, instead.
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
 }
@@ -1809,17 +1813,17 @@ Manager::Shutdown()
     return;
   }
 }
 
 void
 Manager::Abort()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
-  MOZ_ASSERT(mContext);
+  MOZ_DIAGNOSTIC_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
   // creating a new Context.  We must ensure all Contexts and IO operations are
   // complete before origin clear proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
   RefPtr<Context> context = mContext;
@@ -1863,35 +1867,35 @@ Manager::GetListener(ListenerId aListene
 }
 
 bool
 Manager::SetCacheIdOrphanedIfRefed(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
-      MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
-      MOZ_ASSERT(!mCacheIdRefs[i].mOrphaned);
+      MOZ_DIAGNOSTIC_ASSERT(mCacheIdRefs[i].mCount > 0);
+      MOZ_DIAGNOSTIC_ASSERT(!mCacheIdRefs[i].mOrphaned);
       mCacheIdRefs[i].mOrphaned = true;
       return true;
     }
   }
   return false;
 }
 
 // TODO: provide way to set body non-orphaned if its added back to a cache (bug 1110479)
 
 bool
 Manager::SetBodyIdOrphanedIfRefed(const nsID& aBodyId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
-      MOZ_ASSERT(mBodyIdRefs[i].mCount > 0);
-      MOZ_ASSERT(!mBodyIdRefs[i].mOrphaned);
+      MOZ_DIAGNOSTIC_ASSERT(mBodyIdRefs[i].mCount > 0);
+      MOZ_DIAGNOSTIC_ASSERT(!mBodyIdRefs[i].mOrphaned);
       mBodyIdRefs[i].mOrphaned = true;
       return true;
     }
   }
   return false;
 }
 
 void
diff --git a/dom/cache/ManagerId.cpp b/dom/cache/ManagerId.cpp
--- a/dom/cache/ManagerId.cpp
+++ b/dom/cache/ManagerId.cpp
@@ -47,17 +47,17 @@ ManagerId::Principal() const
   nsCOMPtr<nsIPrincipal> ref = mPrincipal;
   return ref.forget();
 }
 
 ManagerId::ManagerId(nsIPrincipal* aPrincipal, const nsACString& aQuotaOrigin)
     : mPrincipal(aPrincipal)
     , mQuotaOrigin(aQuotaOrigin)
 {
-  MOZ_ASSERT(mPrincipal);
+  MOZ_DIAGNOSTIC_ASSERT(mPrincipal);
 }
 
 ManagerId::~ManagerId()
 {
   // If we're already on the main thread, then default destruction is fine
   if (NS_IsMainThread()) {
     return;
   }
diff --git a/dom/cache/PrincipalVerifier.cpp b/dom/cache/PrincipalVerifier.cpp
--- a/dom/cache/PrincipalVerifier.cpp
+++ b/dom/cache/PrincipalVerifier.cpp
@@ -44,55 +44,55 @@ PrincipalVerifier::CreateAndDispatch(Lis
 
   return verifier.forget();
 }
 
 void
 PrincipalVerifier::AddListener(Listener* aListener)
 {
   AssertIsOnBackgroundThread();
-  MOZ_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
   MOZ_ASSERT(!mListenerList.Contains(aListener));
   mListenerList.AppendElement(aListener);
 }
 
 void
 PrincipalVerifier::RemoveListener(Listener* aListener)
 {
   AssertIsOnBackgroundThread();
-  MOZ_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
   MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
 }
 
 PrincipalVerifier::PrincipalVerifier(Listener* aListener,
                                      PBackgroundParent* aActor,
                                      const PrincipalInfo& aPrincipalInfo)
   : mActor(BackgroundParent::GetContentParent(aActor))
   , mPrincipalInfo(aPrincipalInfo)
   , mInitiatingThread(NS_GetCurrentThread())
   , mResult(NS_OK)
 {
   AssertIsOnBackgroundThread();
-  MOZ_ASSERT(mInitiatingThread);
-  MOZ_ASSERT(aListener);
+  MOZ_DIAGNOSTIC_ASSERT(mInitiatingThread);
+  MOZ_DIAGNOSTIC_ASSERT(aListener);
 
   mListenerList.AppendElement(aListener);
 }
 
 PrincipalVerifier::~PrincipalVerifier()
 {
   // Since the PrincipalVerifier is a Runnable that executes on multiple
   // threads, its a race to see which thread de-refs us last.  Therefore
   // we cannot guarantee which thread we destruct on.
 
-  MOZ_ASSERT(mListenerList.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(mListenerList.IsEmpty());
 
   // We should always be able to explicitly release the actor on the main
   // thread.
-  MOZ_ASSERT(!mActor);
+  MOZ_DIAGNOSTIC_ASSERT(!mActor);
 }
 
 NS_IMETHODIMP
 PrincipalVerifier::Run()
 {
   // Executed twice.  First, on the main thread and then back on the
   // originating thread.
 
@@ -185,17 +185,17 @@ PrincipalVerifier::CompleteOnInitiatingT
 {
   AssertIsOnBackgroundThread();
   ListenerList::ForwardIterator iter(mListenerList);
   while (iter.HasMore()) {
     iter.GetNext()->OnPrincipalVerified(mResult, mManagerId);
   }
 
   // The listener must clear its reference in OnPrincipalVerified()
-  MOZ_ASSERT(mListenerList.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(mListenerList.IsEmpty());
 }
 
 void
 PrincipalVerifier::DispatchToInitiatingThread(nsresult aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   mResult = aRv;
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -1,28 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/QuotaClient.h"
 
-#include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "mozilla/dom/quota/UsageInfo.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "nsIFile.h"
 #include "nsISimpleEnumerator.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
-using mozilla::DebugOnly;
 using mozilla::dom::ContentParentId;
 using mozilla::dom::cache::Manager;
 using mozilla::dom::quota::Client;
 using mozilla::dom::quota::PersistenceType;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::UsageInfo;
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
@@ -50,17 +48,17 @@ GetBodyUsage(nsIFile* aDir, UsageInfo* a
       rv = GetBodyUsage(file, aUsageInfo);
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       continue;
     }
 
     int64_t fileSize;
     rv = file->GetFileSize(&fileSize);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    MOZ_ASSERT(fileSize >= 0);
+    MOZ_DIAGNOSTIC_ASSERT(fileSize >= 0);
 
     aUsageInfo->AppendToFileUsage(fileSize);
   }
 
   return NS_OK;
 }
 
 class CacheQuotaClient final : public Client
@@ -85,20 +83,20 @@ public:
     return GetUsageForOrigin(aPersistenceType, aGroup, aOrigin, aUsageInfo);
   }
 
   virtual nsresult
   GetUsageForOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
                     const nsACString& aOrigin,
                     UsageInfo* aUsageInfo) override
   {
-    MOZ_ASSERT(aUsageInfo);
+    MOZ_DIAGNOSTIC_ASSERT(aUsageInfo);
 
     QuotaManager* qm = QuotaManager::Get();
-    MOZ_ASSERT(qm);
+    MOZ_DIAGNOSTIC_ASSERT(qm);
 
     nsCOMPtr<nsIFile> dir;
     nsresult rv = qm->GetDirectoryForOrigin(aPersistenceType, aOrigin,
                                             getter_AddRefs(dir));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = dir->Append(NS_LITERAL_STRING(DOMCACHE_DIRECTORY_NAME));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -143,17 +141,17 @@ public:
         continue;
       }
 
       if (leafName.EqualsLiteral("caches.sqlite") ||
           leafName.EqualsLiteral("caches.sqlite-wal")) {
         int64_t fileSize;
         rv = file->GetFileSize(&fileSize);
         if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-        MOZ_ASSERT(fileSize >= 0);
+        MOZ_DIAGNOSTIC_ASSERT(fileSize >= 0);
 
         aUsageInfo->AppendToDatabaseUsage(fileSize);
         continue;
       }
 
       NS_WARNING("Unknown Cache file found!");
     }
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -190,53 +190,53 @@ ReadStream::Inner::Inner(StreamControl* 
                          nsIInputStream* aStream)
   : mControl(aControl)
   , mId(aId)
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mOwningThread(NS_GetCurrentThread())
   , mState(Open)
 {
-  MOZ_ASSERT(mStream);
-  MOZ_ASSERT(mControl);
+  MOZ_DIAGNOSTIC_ASSERT(mStream);
+  MOZ_DIAGNOSTIC_ASSERT(mControl);
   mControl->AddReadStream(this);
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStreamOrVoid* aReadStreamOut,
                              nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                              ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
-  MOZ_ASSERT(aReadStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
   *aReadStreamOut = CacheReadStream();
   Serialize(&aReadStreamOut->get_CacheReadStream(), aStreamCleanupList, aRv);
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStream* aReadStreamOut,
                              nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                              ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
-  MOZ_ASSERT(aReadStreamOut);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut);
 
   if (mState != Open) {
     aRv.ThrowTypeError<MSG_CACHE_STREAM_CLOSED>();
     return;
   }
 
-  MOZ_ASSERT(mControl);
+  MOZ_DIAGNOSTIC_ASSERT(mControl);
 
   aReadStreamOut->id() = mId;
   mControl->SerializeControl(aReadStreamOut);
   mControl->SerializeStream(aReadStreamOut, mStream, aStreamCleanupList);
 
-  MOZ_ASSERT(aReadStreamOut->stream().type() ==
-             IPCStream::TInputStreamParamsWithFds);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStreamOut->stream().type() ==
+                        IPCStream::TInputStreamParamsWithFds);
 
   // We're passing ownership across the IPC barrier with the control, so
   // do not signal that the stream is closed here.
   Forget();
 }
 
 void
 ReadStream::Inner::CloseStream()
@@ -287,17 +287,17 @@ ReadStream::Inner::Available(uint64_t* a
 
   return rv;
 }
 
 nsresult
 ReadStream::Inner::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
 {
   // stream ops can happen on any thread
-  MOZ_ASSERT(aNumReadOut);
+  MOZ_DIAGNOSTIC_ASSERT(aNumReadOut);
 
   nsresult rv = mSnappyStream->Read(aBuf, aCount, aNumReadOut);
 
   if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
       *aNumReadOut == 0) {
     Close();
   }
 
@@ -306,17 +306,17 @@ ReadStream::Inner::Read(char* aBuf, uint
   return rv;
 }
 
 nsresult
 ReadStream::Inner::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
                                 uint32_t aCount, uint32_t* aNumReadOut)
 {
   // stream ops can happen on any thread
-  MOZ_ASSERT(aNumReadOut);
+  MOZ_DIAGNOSTIC_ASSERT(aNumReadOut);
 
   if (aCount) {
     mHasEverBeenRead = true;
   }
 
   nsresult rv = mSnappyStream->ReadSegments(aWriter, aClosure, aCount,
                                             aNumReadOut);
 
@@ -341,18 +341,18 @@ ReadStream::Inner::IsNonBlocking(bool* a
 {
   // stream ops can happen on any thread
   return mSnappyStream->IsNonBlocking(aNonBlockingOut);
 }
 
 ReadStream::Inner::~Inner()
 {
   // Any thread
-  MOZ_ASSERT(mState == Closed);
-  MOZ_ASSERT(!mControl);
+  MOZ_DIAGNOSTIC_ASSERT(mState == Closed);
+  MOZ_DIAGNOSTIC_ASSERT(!mControl);
 }
 
 void
 ReadStream::Inner::NoteClosed()
 {
   // Any thread
   if (mState == Closed) {
     return;
@@ -391,32 +391,32 @@ ReadStream::Inner::NoteClosedOnOwningThr
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
 
   // Mark closed and do nothing if we were already closed
   if (!mState.compareExchange(Open, Closed)) {
     return;
   }
 
-  MOZ_ASSERT(mControl);
+  MOZ_DIAGNOSTIC_ASSERT(mControl);
   mControl->NoteClosed(this, mId);
   mControl = nullptr;
 }
 
 void
 ReadStream::Inner::ForgetOnOwningThread()
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
 
   // Mark closed and do nothing if we were already closed
   if (!mState.compareExchange(Open, Closed)) {
     return;
   }
 
-  MOZ_ASSERT(mControl);
+  MOZ_DIAGNOSTIC_ASSERT(mControl);
   mControl->ForgetReadStream(this);
   mControl = nullptr;
 }
 
 // ----------------------------------------------------------------------------
 
 NS_IMPL_ISUPPORTS(cache::ReadStream, nsIInputStream, ReadStream);
 
@@ -437,51 +437,51 @@ ReadStream::Create(const CacheReadStream
 {
   // The parameter may or may not be for a Cache created stream.  The way we
   // tell is by looking at the stream control actor.  If the actor exists,
   // then we know the Cache created it.
   if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
     return nullptr;
   }
 
-  MOZ_ASSERT(aReadStream.stream().type() ==
-             IPCStream::TInputStreamParamsWithFds);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStream.stream().type() ==
+                        IPCStream::TInputStreamParamsWithFds);
 
   // Control is guaranteed to survive this method as ActorDestroy() cannot
   // run on this thread until we complete.
   StreamControl* control;
   if (aReadStream.controlChild()) {
     auto actor = static_cast<CacheStreamControlChild*>(aReadStream.controlChild());
     control = actor;
   } else {
     auto actor = static_cast<CacheStreamControlParent*>(aReadStream.controlParent());
     control = actor;
   }
-  MOZ_ASSERT(control);
+  MOZ_DIAGNOSTIC_ASSERT(control);
 
   nsCOMPtr<nsIInputStream> stream = DeserializeIPCStream(aReadStream.stream());
-  MOZ_ASSERT(stream);
+  MOZ_DIAGNOSTIC_ASSERT(stream);
 
   // Currently we expect all cache read streams to be blocking file streams.
-#ifdef DEBUG
+#if !defined(RELEASE_OR_BETA)
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
-  MOZ_ASSERT(!asyncStream);
+  MOZ_DIAGNOSTIC_ASSERT(!asyncStream);
 #endif
 
   RefPtr<Inner> inner = new Inner(control, aReadStream.id(), stream);
   RefPtr<ReadStream> ref = new ReadStream(inner);
   return ref.forget();
 }
 
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
                    nsIInputStream* aStream)
 {
-  MOZ_ASSERT(aControl);
+  MOZ_DIAGNOSTIC_ASSERT(aControl);
   auto actor = static_cast<CacheStreamControlParent*>(aControl);
   RefPtr<Inner> inner = new Inner(actor, aId, aStream);
   RefPtr<ReadStream> ref = new ReadStream(inner);
   return ref.forget();
 }
 
 void
 ReadStream::Serialize(CacheReadStreamOrVoid* aReadStreamOut,
@@ -497,17 +497,17 @@ ReadStream::Serialize(CacheReadStream* a
                       ErrorResult& aRv)
 {
   mInner->Serialize(aReadStreamOut, aStreamCleanupList, aRv);
 }
 
 ReadStream::ReadStream(ReadStream::Inner* aInner)
   : mInner(aInner)
 {
-  MOZ_ASSERT(mInner);
+  MOZ_DIAGNOSTIC_ASSERT(mInner);
 }
 
 ReadStream::~ReadStream()
 {
   // Explicitly close the inner stream so that it does not have to
   // deal with implicitly closing at destruction time.
   mInner->Close();
 }
diff --git a/dom/cache/StreamControl.cpp b/dom/cache/StreamControl.cpp
--- a/dom/cache/StreamControl.cpp
+++ b/dom/cache/StreamControl.cpp
@@ -9,17 +9,17 @@
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 void
 StreamControl::AddReadStream(ReadStream::Controllable* aReadStream)
 {
   AssertOwningThread();
-  MOZ_ASSERT(aReadStream);
+  MOZ_DIAGNOSTIC_ASSERT(aReadStream);
   MOZ_ASSERT(!mReadStreamList.Contains(aReadStream));
   mReadStreamList.AppendElement(aReadStream);
 }
 
 void
 StreamControl::ForgetReadStream(ReadStream::Controllable* aReadStream)
 {
   AssertOwningThread();
@@ -33,35 +33,37 @@ StreamControl::NoteClosed(ReadStream::Co
   AssertOwningThread();
   ForgetReadStream(aReadStream);
   NoteClosedAfterForget(aId);
 }
 
 StreamControl::~StreamControl()
 {
   // owning thread only, but can't call virtual AssertOwningThread in destructor
-  MOZ_ASSERT(mReadStreamList.IsEmpty());
+  MOZ_DIAGNOSTIC_ASSERT(mReadStreamList.IsEmpty());
 }
 
 void
 StreamControl::CloseReadStreams(const nsID& aId)
 {
   AssertOwningThread();
-  DebugOnly<uint32_t> closedCount = 0;
+#if !defined(RELEASE_OR_BETA)
+  uint32_t closedCount = 0;
+#endif
 
   ReadStreamList::ForwardIterator iter(mReadStreamList);
   while (iter.HasMore()) {
     RefPtr<ReadStream::Controllable> stream = iter.GetNext();
     if (stream->MatchId(aId)) {
       stream->CloseStream();
       closedCount += 1;
     }
   }
 
-  MOZ_ASSERT(closedCount > 0);
+  MOZ_DIAGNOSTIC_ASSERT(closedCount > 0);
 }
 
 void
 StreamControl::CloseAllReadStreams()
 {
   AssertOwningThread();
 
   ReadStreamList::ForwardIterator iter(mReadStreamList);
diff --git a/dom/cache/StreamList.cpp b/dom/cache/StreamList.cpp
--- a/dom/cache/StreamList.cpp
+++ b/dom/cache/StreamList.cpp
@@ -17,70 +17,70 @@ namespace cache {
 
 StreamList::StreamList(Manager* aManager, Context* aContext)
   : mManager(aManager)
   , mContext(aContext)
   , mCacheId(INVALID_CACHE_ID)
   , mStreamControl(nullptr)
   , mActivated(false)
 {
-  MOZ_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mManager);
   mContext->AddActivity(this);
 }
 
 void
 StreamList::SetStreamControl(CacheStreamControlParent* aStreamControl)
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
-  MOZ_ASSERT(aStreamControl);
+  MOZ_DIAGNOSTIC_ASSERT(aStreamControl);
 
   // For cases where multiple streams are serialized for a single list
   // then the control will get passed multiple times.  This is ok, but
   // it should be the same control each time.
   if (mStreamControl) {
-    MOZ_ASSERT(aStreamControl == mStreamControl);
+    MOZ_DIAGNOSTIC_ASSERT(aStreamControl == mStreamControl);
     return;
   }
 
   mStreamControl = aStreamControl;
   mStreamControl->SetStreamList(this);
 }
 
 void
 StreamList::RemoveStreamControl(CacheStreamControlParent* aStreamControl)
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
-  MOZ_ASSERT(mStreamControl);
-  MOZ_ASSERT(mStreamControl == aStreamControl);
+  MOZ_DIAGNOSTIC_ASSERT(mStreamControl);
+  MOZ_DIAGNOSTIC_ASSERT(mStreamControl == aStreamControl);
   mStreamControl = nullptr;
 }
 
 void
 StreamList::Activate(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
-  MOZ_ASSERT(!mActivated);
-  MOZ_ASSERT(mCacheId == INVALID_CACHE_ID);
+  MOZ_DIAGNOSTIC_ASSERT(!mActivated);
+  MOZ_DIAGNOSTIC_ASSERT(mCacheId == INVALID_CACHE_ID);
   mActivated = true;
   mCacheId = aCacheId;
   mManager->AddRefCacheId(mCacheId);
   mManager->AddStreamList(this);
 
   for (uint32_t i = 0; i < mList.Length(); ++i) {
     mManager->AddRefBodyId(mList[i].mId);
   }
 }
 
 void
 StreamList::Add(const nsID& aId, nsIInputStream* aStream)
 {
   // All streams should be added on IO thread before we set the stream
   // control on the owning IPC thread.
-  MOZ_ASSERT(!mStreamControl);
-  MOZ_ASSERT(aStream);
+  MOZ_DIAGNOSTIC_ASSERT(!mStreamControl);
+  MOZ_DIAGNOSTIC_ASSERT(aStream);
   Entry* entry = mList.AppendElement();
   entry->mId = aId;
   entry->mStream = aStream;
 }
 
 already_AddRefed<nsIInputStream>
 StreamList::Extract(const nsID& aId)
 {
@@ -154,17 +154,17 @@ StreamList::MatchesCacheId(CacheId aCach
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   return aCacheId == mCacheId;
 }
 
 StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
-  MOZ_ASSERT(!mStreamControl);
+  MOZ_DIAGNOSTIC_ASSERT(!mStreamControl);
   if (mActivated) {
     mManager->RemoveStreamList(this);
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mManager->ReleaseBodyId(mList[i].mId);
     }
     mManager->ReleaseCacheId(mCacheId);
   }
   mContext->RemoveActivity(this);
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -60,17 +60,17 @@ HasVaryStar(mozilla::dom::InternalHeader
     }
   }
   return false;
 }
 
 void
 ToHeadersEntryList(nsTArray<HeadersEntry>& aOut, InternalHeaders* aHeaders)
 {
-  MOZ_ASSERT(aHeaders);
+  MOZ_DIAGNOSTIC_ASSERT(aHeaders);
 
   AutoTArray<InternalHeaders::Entry, 16> entryList;
   aHeaders->GetEntries(entryList);
 
   for (uint32_t i = 0; i < entryList.Length(); ++i) {
     InternalHeaders::Entry& entry = entryList[i];
     aOut.AppendElement(HeadersEntry(entry.mName, entry.mValue));
   }
@@ -116,17 +116,17 @@ TypeUtils::ToInternalRequest(const Ownin
 }
 
 void
 TypeUtils::ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
                           BodyAction aBodyAction, SchemeAction aSchemeAction,
                           nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList,
                           ErrorResult& aRv)
 {
-  MOZ_ASSERT(aIn);
+  MOZ_DIAGNOSTIC_ASSERT(aIn);
   aIn->GetMethod(aOut.method());
   nsCString url(aIn->GetURLWithoutFragment());
   bool schemeValid;
   ProcessURL(url, &schemeValid, &aOut.urlWithoutQuery(), &aOut.urlQuery(), aRv);
   if (aRv.Failed()) {
     return;
   }
   if (!schemeValid) {
@@ -137,17 +137,17 @@ TypeUtils::ToCacheRequest(CacheRequest& 
       return;
     }
   }
   aOut.urlFragment() = aIn->GetFragment();
 
   aIn->GetReferrer(aOut.referrer());
   aOut.referrerPolicy() = aIn->ReferrerPolicy_();
   RefPtr<InternalHeaders> headers = aIn->Headers();
-  MOZ_ASSERT(headers);
+  MOZ_DIAGNOSTIC_ASSERT(headers);
   ToHeadersEntryList(aOut.headers(), headers);
   aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn->Mode();
   aOut.credentials() = aIn->GetCredentialsMode();
   aOut.contentPolicyType() = aIn->ContentPolicyType();
   aOut.requestCache() = aIn->GetCacheMode();
   aOut.requestRedirect() = aIn->GetRedirectMode();
 
@@ -174,26 +174,26 @@ TypeUtils::ToCacheResponseWithoutBody(Ca
 {
   aOut.type() = aIn.Type();
 
   aIn.GetUnfilteredURLList(aOut.urlList());
   AutoTArray<nsCString, 4> urlList;
   aIn.GetURLList(urlList);
 
   for (uint32_t i = 0; i < aOut.urlList().Length(); i++) {
-    MOZ_ASSERT(!aOut.urlList()[i].IsEmpty());
+    MOZ_DIAGNOSTIC_ASSERT(!aOut.urlList()[i].IsEmpty());
     // Pass all Response URL schemes through... The spec only requires we take
     // action on invalid schemes for Request objects.
     ProcessURL(aOut.urlList()[i], nullptr, nullptr, nullptr, aRv);
   }
 
   aOut.status() = aIn.GetUnfilteredStatus();
   aOut.statusText() = aIn.GetUnfilteredStatusText();
   RefPtr<InternalHeaders> headers = aIn.UnfilteredHeaders();
-  MOZ_ASSERT(headers);
+  MOZ_DIAGNOSTIC_ASSERT(headers);
   if (HasVaryStar(headers)) {
     aRv.ThrowTypeError<MSG_RESPONSE_HAS_VARY_STAR>();
     return;
   }
   ToHeadersEntryList(aOut.headers(), headers);
   aOut.headersGuard() = headers->Guard();
   aOut.channelInfo() = aIn.GetChannelInfo().AsIPCChannelInfo();
   if (aIn.GetPrincipalInfo()) {
@@ -262,19 +262,19 @@ TypeUtils::ToResponse(const CacheRespons
 
   RefPtr<InternalHeaders> internalHeaders =
     ToInternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
 
   // Be careful to fill the headers before setting the guard in order to
   // correctly re-create the original headers.
   ir->Headers()->Fill(*internalHeaders, result);
-  MOZ_ASSERT(!result.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!result.Failed());
   ir->Headers()->SetGuard(aIn.headersGuard(), result);
-  MOZ_ASSERT(!result.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!result.Failed());
 
   ir->InitChannelInfo(aIn.channelInfo());
   if (aIn.principalInfo().type() == mozilla::ipc::OptionalPrincipalInfo::TPrincipalInfo) {
     UniquePtr<mozilla::ipc::PrincipalInfo> info(new mozilla::ipc::PrincipalInfo(aIn.principalInfo().get_PrincipalInfo()));
     ir->SetPrincipalInfo(Move(info));
   }
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
@@ -294,17 +294,17 @@ TypeUtils::ToResponse(const CacheRespons
       ir = ir->OpaqueResponse();
       break;
     case ResponseType::Opaqueredirect:
       ir = ir->OpaqueRedirectResponse();
       break;
     default:
       MOZ_CRASH("Unexpected ResponseType!");
   }
-  MOZ_ASSERT(ir);
+  MOZ_DIAGNOSTIC_ASSERT(ir);
 
   RefPtr<Response> ref = new Response(GetGlobalObject(), ir);
   return ref.forget();
 }
 already_AddRefed<InternalRequest>
 TypeUtils::ToInternalRequest(const CacheRequest& aIn)
 {
   nsAutoCString url(aIn.urlWithoutQuery());
@@ -323,20 +323,20 @@ TypeUtils::ToInternalRequest(const Cache
 
   RefPtr<InternalHeaders> internalHeaders =
     ToInternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
 
   // Be careful to fill the headers before setting the guard in order to
   // correctly re-create the original headers.
   internalRequest->Headers()->Fill(*internalHeaders, result);
-  MOZ_ASSERT(!result.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!result.Failed());
 
   internalRequest->Headers()->SetGuard(aIn.headersGuard(), result);
-  MOZ_ASSERT(!result.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!result.Failed());
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
 
   internalRequest->SetBody(stream);
 
   return internalRequest.forget();
 }
 
@@ -405,17 +405,17 @@ TypeUtils::ProcessURL(nsACString& aUrl, 
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   if (!aUrlWithoutQueryOut) {
     return;
   }
 
-  MOZ_ASSERT(aUrlQueryOut);
+  MOZ_DIAGNOSTIC_ASSERT(aUrlQueryOut);
 
   if (queryLen < 0) {
     *aUrlWithoutQueryOut = aUrl;
     *aUrlQueryOut = EmptyCString();
     return;
   }
 
   // ParsePath gives us query position relative to the start of the path
@@ -424,17 +424,17 @@ TypeUtils::ProcessURL(nsACString& aUrl, 
   *aUrlWithoutQueryOut = Substring(aUrl, 0, queryPos - 1);
   *aUrlQueryOut = Substring(aUrl, queryPos - 1, queryLen + 1);
 }
 
 void
 TypeUtils::CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                                ErrorResult& aRv)
 {
-  MOZ_ASSERT(aRequest);
+  MOZ_DIAGNOSTIC_ASSERT(aRequest);
 
   if (aBodyAction == IgnoreBody) {
     return;
   }
 
   if (aRequest->BodyUsed()) {
     aRv.ThrowTypeError<MSG_FETCH_BODY_CONSUMED_ERROR>();
     return;
@@ -456,17 +456,17 @@ TypeUtils::ToInternalRequest(const nsASt
   // Re-create a GlobalObject stack object so we can use webidl Constructors.
   AutoJSAPI jsapi;
   if (NS_WARN_IF(!jsapi.Init(GetGlobalObject()))) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
   JSContext* cx = jsapi.cx();
   GlobalObject global(cx, GetGlobalObject()->GetGlobalJSObject());
-  MOZ_ASSERT(!global.Failed());
+  MOZ_DIAGNOSTIC_ASSERT(!global.Failed());
 
   RefPtr<Request> request = Request::Constructor(global, requestOrString,
                                                    RequestInit(), aRv);
   if (NS_WARN_IF(aRv.Failed())) { return nullptr; }
 
   return request->GetInternalRequest();
 }
 
