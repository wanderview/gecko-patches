# HG changeset patch
# Parent e024e5376e62b6d54c7a2d7c0f382209d0a6bc7f
# User Ben Kelly <ben@wanderview.com>
Make Request/Response Clone() fully copy the tee to a pipe to avoid stalling.

diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -5,16 +5,19 @@
 
 #include "InternalRequest.h"
 
 #include "nsIContentPolicy.h"
 #include "nsIDocument.h"
 #include "nsIInputStreamTee.h"
 #include "nsIOutputStream.h"
 #include "nsIPipe.h"
+#include "nsNetCID.h"
+#include "nsServiceManagerUtils.h"
+#include "nsStreamUtils.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/workers/Workers.h"
 
 #include "WorkerPrivate.h"
 
 namespace mozilla {
@@ -55,20 +58,30 @@ InternalRequest::InternalRequest(Interna
                            getter_AddRefs(pipeWriter));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
   nsCOMPtr<nsIInputStream> tee;
   rv = NS_NewInputStreamTee(getter_AddRefs(tee), aOther.mBodyStream,
                             pipeWriter);
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
-  // The pipe reader can get stalled if the tee is not being read.  Give the
-  // tee to the cloned stream as its more likely to be used first.
+  nsCOMPtr<nsIInputStream> pipeReader2;
+  nsCOMPtr<nsIOutputStream> pipeWriter2;
+  rv = NS_NewPipe(getter_AddRefs(pipeReader2), getter_AddRefs(pipeWriter2));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  nsCOMPtr<nsIEventTarget> target =
+    do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = NS_AsyncCopy(tee, pipeWriter2, target,
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS);
+
   aOther.mBodyStream.swap(pipeReader);
-  mBodyStream.swap(tee);
+  mBodyStream.swap(pipeReader2);
 }
 
 // The global is used to extract the principal.
 already_AddRefed<InternalRequest>
 InternalRequest::GetRequestConstructorCopy(nsIGlobalObject* aGlobal, ErrorResult& aRv) const
 {
   nsRefPtr<InternalRequest> copy = new InternalRequest();
   copy->mURL.Assign(mURL);
diff --git a/dom/fetch/InternalResponse.cpp b/dom/fetch/InternalResponse.cpp
--- a/dom/fetch/InternalResponse.cpp
+++ b/dom/fetch/InternalResponse.cpp
@@ -4,16 +4,19 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InternalResponse.h"
 
 #include "nsIDOMFile.h"
 #include "nsIInputStreamTee.h"
 #include "nsIOutputStream.h"
 #include "nsIPipe.h"
+#include "nsNetCID.h"
+#include "nsServiceManagerUtils.h"
+#include "nsStreamUtils.h"
 
 #include "mozilla/dom/InternalHeaders.h"
 
 namespace mozilla {
 namespace dom {
 
 InternalResponse::InternalResponse(uint16_t aStatus, const nsACString& aStatusText)
   : mType(ResponseType::Default)
@@ -44,20 +47,30 @@ InternalResponse::InternalResponse(Inter
                            getter_AddRefs(pipeWriter));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
   nsCOMPtr<nsIInputStream> tee;
   rv = NS_NewInputStreamTee(getter_AddRefs(tee), aOther.mBody,
                             pipeWriter);
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
-  // The pipe reader can get stalled if the tee is not being read.  Give the
-  // tee to the cloned stream as its more likely to be used first.
+  nsCOMPtr<nsIInputStream> pipeReader2;
+  nsCOMPtr<nsIOutputStream> pipeWriter2;
+  rv = NS_NewPipe(getter_AddRefs(pipeReader2), getter_AddRefs(pipeWriter2));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  nsCOMPtr<nsIEventTarget> target =
+    do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = NS_AsyncCopy(tee, pipeWriter2, target,
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS);
+
   aOther.mBody.swap(pipeReader);
-  mBody.swap(tee);
+  mBody.swap(pipeReader2);
 }
 
 already_AddRefed<InternalResponse>
 InternalResponse::Clone()
 {
   nsRefPtr<InternalResponse> ir = new InternalResponse(*this);
   ir->mHeaders = new InternalHeaders(*mHeaders);
   return ir.forget();
