# HG changeset patch
# Parent 3482c858624b445220071d0a3a73d8ebfdb17de9
# User Ben Kelly <ben@wanderview.com>
Make Request/Response Clone() fully copy the tee to a pipe to avoid stalling.


diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -55,20 +55,30 @@ InternalRequest::InternalRequest(Interna
                            getter_AddRefs(pipeWriter));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
   nsCOMPtr<nsIInputStream> tee;
   rv = NS_NewInputStreamTee(getter_AddRefs(tee), aOther.mBodyStream,
                             pipeWriter);
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
-  // The pipe reader can get stalled if the tee is not being read.  Give the
-  // tee to the cloned stream as its more likely to be used first.
+  nsCOMPtr<nsIInputStream> pipeReader2;
+  nsCOMPtr<nsIOutputStream> pipeWriter2;
+  rv = NS_NewPipe(getter_AddRefs(pipeReader2), getter_AddRefs(pipeWriter2));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  nsCOMPtr<nsIEventTarget> target =
+    do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = NS_AsyncCopy(tee, pipeWriter2, target,
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS);
+
   aOther.mBodyStream.swap(pipeReader);
-  mBodyStream.swap(tee);
+  mBodyStream.swap(pipeReader2);
 }
 
 // The global is used to extract the principal.
 already_AddRefed<InternalRequest>
 InternalRequest::GetRequestConstructorCopy(nsIGlobalObject* aGlobal, ErrorResult& aRv) const
 {
   nsRefPtr<InternalRequest> copy = new InternalRequest();
   copy->mURL.Assign(mURL);
diff --git a/dom/fetch/InternalResponse.cpp b/dom/fetch/InternalResponse.cpp
--- a/dom/fetch/InternalResponse.cpp
+++ b/dom/fetch/InternalResponse.cpp
@@ -44,20 +44,30 @@ InternalResponse::InternalResponse(Inter
                            getter_AddRefs(pipeWriter));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
   nsCOMPtr<nsIInputStream> tee;
   rv = NS_NewInputStreamTee(getter_AddRefs(tee), aOther.mBody,
                             pipeWriter);
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
-  // The pipe reader can get stalled if the tee is not being read.  Give the
-  // tee to the cloned stream as its more likely to be used first.
+  nsCOMPtr<nsIInputStream> pipeReader2;
+  nsCOMPtr<nsIOutputStream> pipeWriter2;
+  rv = NS_NewPipe(getter_AddRefs(pipeReader2), getter_AddRefs(pipeWriter2));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  nsCOMPtr<nsIEventTarget> target =
+    do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  rv = NS_AsyncCopy(tee, pipeWriter2, target,
+                    NS_ASYNCCOPY_VIA_WRITESEGMENTS);
+
   aOther.mBody.swap(pipeReader);
-  mBody.swap(tee);
+  mBody.swap(pipeReader2);
 }
 
 already_AddRefed<InternalResponse>
 InternalResponse::Clone()
 {
   nsRefPtr<InternalResponse> ir = new InternalResponse(*this);
   ir->mHeaders = new InternalHeaders(*mHeaders);
   return ir.forget();
