# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  76ea69f942f1b658d6308fe454c2fe4712483d3c
Bug 1459209 P8 Implement RemoteServiceWorkerImpl::PostMessage() across IPC and to the parent-side SWM. r=baku

diff --git a/dom/serviceworkers/PServiceWorker.ipdl b/dom/serviceworkers/PServiceWorker.ipdl
--- a/dom/serviceworkers/PServiceWorker.ipdl
+++ b/dom/serviceworkers/PServiceWorker.ipdl
@@ -1,22 +1,27 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 
+include ClientIPCTypes;
+include DOMTypes;
+
 namespace mozilla {
 namespace dom {
 
 protocol PServiceWorker
 {
   manager PBackground;
 
 parent:
   async Teardown();
 
+  async PostMessage(ClonedMessageData aClonedData, ClientInfoAndState aSource);
+
 child:
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
@@ -1,19 +1,22 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "RemoteServiceWorkerImpl.h"
 
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientState.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "ServiceWorkerChild.h"
+#include "ServiceWorkerCloneData.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
 
 RemoteServiceWorkerImpl::~RemoteServiceWorkerImpl()
@@ -62,17 +65,29 @@ RemoteServiceWorkerImpl::GetRegistration
   // TODO
 }
 
 void
 RemoteServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                      const ClientInfo& aClientInfo,
                                      const ClientState& aClientState)
 {
-  // TODO
+  NS_ASSERT_OWNINGTHREAD(RemoteServiceWorkerImpl);
+  if (!mActor) {
+    return;
+  }
+
+  ClonedMessageData data;
+  if (!aData->BuildClonedMessageDataForBackgroundChild(mActor->Manager(),
+                                                       data)) {
+    return;
+  }
+
+  mActor->SendPostMessage(data, ClientInfoAndState(aClientInfo.ToIPC(),
+                                                   aClientState.ToIPC()));
 }
 
 RemoteServiceWorkerImpl::RemoteServiceWorkerImpl(const ServiceWorkerDescriptor& aDescriptor)
   : mActor(nullptr)
   , mWorker(nullptr)
   , mShutdown(false)
 {
   PBackgroundChild* parentActor = BackgroundChild::GetOrCreateForCurrentThread();
diff --git a/dom/serviceworkers/ServiceWorkerParent.cpp b/dom/serviceworkers/ServiceWorkerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerParent.cpp
@@ -1,21 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerParent.h"
 
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerProxy.h"
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientState.h"
+#include "mozilla/dom/ipc/StructuredCloneData.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::dom::ipc::StructuredCloneData;
 using mozilla::ipc::IPCResult;
 
 void
 ServiceWorkerParent::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mProxy) {
     mProxy->RevokeActor(this);
     mProxy = nullptr;
@@ -24,16 +29,29 @@ ServiceWorkerParent::ActorDestroy(ActorD
 
 IPCResult
 ServiceWorkerParent::RecvTeardown()
 {
   MaybeSendDelete();
   return IPC_OK();
 }
 
+IPCResult
+ServiceWorkerParent::RecvPostMessage(const ClonedMessageData& aClonedData,
+                                     const ClientInfoAndState& aSource)
+{
+  RefPtr<ServiceWorkerCloneData> data = new ServiceWorkerCloneData();
+  data->CopyFromClonedMessageDataForBackgroundParent(aClonedData);
+
+  mProxy->PostMessage(std::move(data), ClientInfo(aSource.info()),
+                      ClientState::FromIPC(aSource.state()));
+
+  return IPC_OK();
+}
+
 ServiceWorkerParent::ServiceWorkerParent()
   : mDeleteSent(false)
 {
 }
 
 ServiceWorkerParent::~ServiceWorkerParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mProxy);
diff --git a/dom/serviceworkers/ServiceWorkerParent.h b/dom/serviceworkers/ServiceWorkerParent.h
--- a/dom/serviceworkers/ServiceWorkerParent.h
+++ b/dom/serviceworkers/ServiceWorkerParent.h
@@ -22,16 +22,20 @@ class ServiceWorkerParent final : public
 
   // PServiceWorkerParent
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
+  mozilla::ipc::IPCResult
+  RecvPostMessage(const ClonedMessageData& aClonedData,
+                  const ClientInfoAndState& aSource) override;
+
 public:
   ServiceWorkerParent();
   ~ServiceWorkerParent();
 
   void
   Init(const IPCServiceWorkerDescriptor& aDescriptor);
 
   void
diff --git a/dom/serviceworkers/ServiceWorkerProxy.cpp b/dom/serviceworkers/ServiceWorkerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerProxy.cpp
@@ -110,10 +110,27 @@ ServiceWorkerProxy::RevokeActor(ServiceW
   mActor = nullptr;
 
   nsCOMPtr<nsIRunnable> r =
     NewRunnableMethod(__func__, this,
                       &ServiceWorkerProxy::StopListeningOnMainThread);
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 }
 
+void
+ServiceWorkerProxy::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
+                                const ClientInfo& aClientInfo,
+                                const ClientState& aClientState)
+{
+  AssertIsOnBackgroundThread();
+  RefPtr<ServiceWorkerProxy> self = this;
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
+    [self, data = std::move(aData), aClientInfo, aClientState] () mutable {
+      if (!self->mInfo) {
+        return;
+      }
+      self->mInfo->PostMessage(std::move(data), aClientInfo, aClientState);
+    });
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerProxy.h b/dom/serviceworkers/ServiceWorkerProxy.h
--- a/dom/serviceworkers/ServiceWorkerProxy.h
+++ b/dom/serviceworkers/ServiceWorkerProxy.h
@@ -8,16 +8,17 @@
 #define moz_dom_ServiceWorkerProxy_h
 
 #include "nsProxyRelease.h"
 #include "ServiceWorkerDescriptor.h"
 
 namespace mozilla {
 namespace dom {
 
+class ServiceWorkerCloneData;
 class ServiceWorkerInfo;
 class ServiceWorkerParent;
 
 class ServiceWorkerProxy final
 {
   // Background thread only
   ServiceWorkerParent* mActor;
 
@@ -51,15 +52,20 @@ public:
   explicit ServiceWorkerProxy(const ServiceWorkerDescriptor& aDescriptor);
 
   void
   Init(ServiceWorkerParent* aActor);
 
   void
   RevokeActor(ServiceWorkerParent* aActor);
 
+  void
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
+              const ClientInfo& aClientInfo,
+              const ClientState& aState);
+
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerProxy);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // moz_dom_ServiceWorkerProxy_h
