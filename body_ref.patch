# HG changeset patch
# Parent 20ad58514fd38a8f61e593b06ecdeac1c899a6b4
# User Ben Kelly <ben@wanderview.com>
Track open Cache body streams by reference count.

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -248,30 +248,37 @@ public:
   ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
                  nsIFile* aQuotaDir)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaDir(aQuotaDir)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
+    , mCanceled(false)
     , mResult(NS_OK)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     MOZ_ASSERT(mQuotaDir);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mState == STATE_INIT);
 
+    if (mCanceled) {
+      mState = STATE_COMPLETE;
+      Clear();
+      return NS_OK;
+    }
+
     mState = STATE_RUN_ON_TARGET;
     nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
@@ -279,31 +286,29 @@ public:
   bool MatchesCacheId(CacheId aCacheId) {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     return mAction->MatchesCacheId(aCacheId);
   }
 
   void Cancel()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    mCanceled = true;
+    mResult = NS_ERROR_FAILURE;
     nsresult rv;
     switch(mState) {
-      case STATE_INIT:
-        mState = STATE_COMPLETE;
-        break;
-      case STATE_RUN_ON_TARGET:
-        mState = STATE_CANCELING;
-        break;
       case STATE_RUNNING:
-        mState = STATE_CANCELING;
+        // Re-dispatch if we are currently running
         rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
         }
-      case STATE_CANCELING:
+        break;
+      case STATE_INIT:
+      case STATE_RUN_ON_TARGET:
       case STATE_COMPLETING:
       case STATE_COMPLETE:
         break;
       default:
         MOZ_CRASH("unexpected state");
         break;
     }
   }
@@ -336,28 +341,28 @@ private:
     mContext = nullptr;
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
     STATE_RUN_ON_TARGET,
-    STATE_CANCELING,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   nsRefPtr<Context> mContext;
   nsCOMPtr<nsIEventTarget> mTarget;
   nsRefPtr<Action> mAction;
   nsCOMPtr<nsIFile> mQuotaDir;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
+  bool mCanceled;
   nsresult mResult;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
@@ -365,37 +370,54 @@ NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom
 
 NS_IMETHODIMP
 Context::ActionRunnable::Run()
 {
   nsresult rv;
   switch(mState) {
     case STATE_RUN_ON_TARGET:
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      if (mCanceled) {
+        mState = STATE_COMPLETING;
+        rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+        if (NS_FAILED(rv)) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+        }
+        break;
+      }
       mState = STATE_RUNNING;
       mAction->RunOnTarget(this, mQuotaDir);
       break;
-    case STATE_CANCELING:
+    case STATE_RUNNING:
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // We only re-enter the RUNNING state if we are canceling.  Normally we
+      // should transition out of RUNNING via Resolve() instead.
+      MOZ_ASSERT(mCanceled);
       mState = STATE_COMPLETING;
       mAction->CancelOnTarget();
       mResult = NS_FAILED(mResult) ? mResult : NS_ERROR_FAILURE;
       rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
       if (NS_FAILED(rv)) {
         MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
       }
       break;
     case STATE_COMPLETING:
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
+    case STATE_COMPLETE:
+      // We can end up running in the complete state if we cancel on the origin
+      // thread while simultaneously starting to run the action on the target
+      // thread.
+      MOZ_ASSERT(mCanceled);
+      break;
     default:
       MOZ_CRASH("unexpected state in ActionRunnable");
       break;
   }
   return NS_OK;
 }
 
 Context::Context(Listener* aListener, const nsACString& aOrigin,
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -170,25 +170,34 @@ DBSchema::CreateCache(mozIStorageConnect
   rv = state->GetInt32(0, aCacheIdOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-DBSchema::DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId)
+DBSchema::DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                      nsTArray<nsID>& aDeletedBodyIdListOut)
 {
   MOZ_ASSERT(aConn);
 
-  // Dependent data removed via ON DELETE CASCADE. Associated body files
-  // should be removed in bulk for the cache.
+  // Delete the bodies explicitly as we need to read out the body IDs
+  // anyway.  These body IDs must be deleted one-by-one as content may
+  // still be referencing them invidivually.
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryAll(aConn, aCacheId, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Delete the remainder of the cache using cascade semantics.
   nsCOMPtr<mozIStorageStatement> state;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "DELETE FROM caches WHERE id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -32,17 +32,18 @@ struct SavedResponse;
 class DBSchema MOZ_FINAL
 {
 public:
   static nsresult CreateSchema(mozIStorageConnection* aConn);
 
   static nsresult CreateCache(mozIStorageConnection* aConn,
                               CacheId* aCacheIdOut);
   // TODO: improve naming (confusing with CacheDelete)
-  static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId);
+  static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                              nsTArray<nsID>& aDeletedBodyIdListOut);
 
   // TODO: Consider removing unused IsCacheOrphaned after writing cleanup code.
   static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
                                   CacheId aCacheId, bool* aOrphanedOut);
 
   static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
                              const PCacheRequest& aRequest,
                              const PCacheQueryParams& aParams,
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -396,22 +396,18 @@ FileUtils::BodyDeleteFiles(nsIFile* aBas
     bool exists;
     rv = finalFile->Exists(&exists);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (NS_WARN_IF(!exists)) {
       continue;
     }
 
-    // TODO: figure out why files cannot be removed on windows mochitest
     rv = finalFile->Remove(false /* recursive */);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to remove Cache body file!");
-      rv = NS_OK;
-    }
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   return rv;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -162,16 +162,58 @@ protected:
   }
 
   virtual ~BaseAction() { }
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
 };
 
+class Manager::DeleteOrphanedBodyAction MOZ_FINAL : public Action
+{
+public:
+  DeleteOrphanedBodyAction(CacheId aCacheId,
+                           const nsTArray<nsID>& aDeletedBodyIdList)
+    : mCacheId(aCacheId)
+    , mDeletedBodyIdList(aDeletedBodyIdList)
+  { }
+
+  DeleteOrphanedBodyAction(CacheId aCacheId, const nsID& aBodyId)
+    : mCacheId(aCacheId)
+  {
+    mDeletedBodyIdList.AppendElement(aBodyId);
+  }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aResolver);
+    MOZ_ASSERT(aQuotaDir);
+
+    nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    rv = FileUtils::BodyDeleteFiles(aQuotaDir, mCacheId, mDeletedBodyIdList);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    aResolver->Resolve(rv);
+  }
+
+private:
+  virtual ~DeleteOrphanedBodyAction() { }
+  const CacheId mCacheId;
+  nsTArray<nsID> mDeletedBodyIdList;
+};
+
 class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
     : SyncDBAction(DBAction::Existing, aManager->Origin(),
                    aManager->BaseDomain())
     , mManager(aManager)
     , mCacheId(aCacheId)
@@ -179,38 +221,40 @@ public:
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsresult rv =  DBSchema::DeleteCache(aConn, mCacheId);
+    nsresult rv = DBSchema::DeleteCache(aConn, mCacheId, mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = FileUtils::BodyDeleteCacheDir(aDBDir, mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
+    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
     mManager = nullptr;
   }
 
 private:
   virtual ~DeleteOrphanedCacheAction() { }
   nsRefPtr<Manager> mManager;
   const CacheId mCacheId;
+  nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
@@ -341,28 +385,26 @@ protected:
 class Manager::CachePutAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAction(Manager* aManager, ListenerId aListenerId,
                  RequestId aRequestId, CacheId aCacheId,
                  const PCacheRequest& aRequest,
                  nsIInputStream* aRequestBodyStream,
                  const PCacheResponse& aResponse,
-                 nsIInputStream* aResponseBodyStream,
-                 StreamList* aStreamList)
+                 nsIInputStream* aResponseBodyStream)
     : DBAction(DBAction::Existing, aManager->Origin(), aManager->BaseDomain())
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mRequestBodyStream(aRequestBodyStream)
     , mResponse(aResponse)
     , mResponseBodyStream(aResponseBodyStream)
-    , mStreamList(aStreamList)
     , mExpectedAsyncCopyCompletions(0)
   { }
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
                     mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
@@ -445,28 +487,21 @@ public:
         DoResolve(rv);
         return;
       }
     }
 
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsTArray<nsID> deletedBodyIdList;
     rv = DBSchema::CachePut(mConn, mCacheId, mRequest,
                             mRequestBodyStream ? &mRequestBodyId : nullptr,
                             mResponse,
                             mResponseBodyStream ? &mResponseBodyId : nullptr,
-                            deletedBodyIdList);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      DoResolve(rv);
-      return;
-    }
-
-    rv = FileUtils::BodyDeleteFiles(mDBDir, mCacheId, deletedBodyIdList);
+                            mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
       return;
     }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
@@ -475,28 +510,29 @@ public:
 
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
+
+    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
+
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (!listener) {
       return;
     }
     if (NS_FAILED(aRv)) {
       listener->OnCachePut(mRequestId, aRv);
     } else {
-      mStreamList->Activate(mCacheId);
       listener->OnCachePut(mRequestId, aRv);
     }
-    mStreamList = nullptr;
   }
 
   virtual void
   CancelOnTarget() MOZ_OVERRIDE
   {
     CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
                      mRequestBodyId);
     mRequestBodyCopyContext = nullptr;
@@ -586,25 +622,25 @@ private:
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   nsCOMPtr<nsIInputStream> mRequestBodyStream;
   const PCacheResponse mResponse;
   nsCOMPtr<nsIInputStream> mResponseBodyStream;
-  nsRefPtr<StreamList> mStreamList;
   nsRefPtr<Resolver> mResolver;
   nsCOMPtr<nsIFile> mDBDir;
   nsCOMPtr<mozIStorageConnection> mConn;
   uint32_t mExpectedAsyncCopyCompletions;
   nsID mRequestBodyId;
   nsCOMPtr<nsISupports> mRequestBodyCopyContext;
   nsID mResponseBodyId;
   nsCOMPtr<nsISupports> mResponseBodyCopyContext;
+  nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
@@ -618,50 +654,48 @@ public:
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
-    nsTArray<nsID> deletedBodyIdList;
     nsresult rv = DBSchema::CacheDelete(aConn, mCacheId, mRequest, mParams,
-                                        deletedBodyIdList, &mSuccess);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = FileUtils::BodyDeleteFiles(aDBDir, mCacheId, deletedBodyIdList);
+                                        mDeletedBodyIdList, &mSuccess);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mSuccess = false;
       return rv;
     }
 
     return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
+    mManager->NoteOrphanedBodyIdList(mCacheId, mDeletedBodyIdList);
     aListener->OnCacheDelete(mRequestId, aRv, mSuccess);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheDeleteAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
   bool mSuccess;
+  nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::CacheKeysAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheKeysAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequestOrVoid& aRequestOrVoid,
@@ -1004,16 +1038,20 @@ Manager::StreamList::Activate(CacheId aC
 {
   NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
   MOZ_ASSERT(!mActivated);
   MOZ_ASSERT(!mCacheId);
   mActivated = true;
   mCacheId = aCacheId;
   mManager->AddRefCacheId(mCacheId);
   mManager->AddStreamList(this);
+
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    mManager->AddRefBodyId(mList[i].mId);
+  }
 }
 
 void
 Manager::StreamList::Add(const nsID& aId, nsIInputStream* aStream)
 {
   // All streams should be added on IO thread before we set the stream
   // control on the owning IPC thread.
   MOZ_ASSERT(!mStreamControl);
@@ -1037,16 +1075,17 @@ Manager::StreamList::Extract(const nsID&
 
 void
 Manager::StreamList::NoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
   for (uint32_t i = 0; i < mList.Length(); ++i) {
     if (mList[i].mId == aId) {
       mList.RemoveElementAt(i);
+      mManager->ReleaseBodyId(mCacheId, aId);
       break;
     }
   }
 
   if (mList.IsEmpty() && mStreamControl) {
     mStreamControl->Shutdown();
   }
 }
@@ -1070,16 +1109,19 @@ Manager::StreamList::CloseAll()
 }
 
 Manager::StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
   MOZ_ASSERT(!mStreamControl);
   if (mActivated) {
     mManager->RemoveStreamList(this);
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      mManager->ReleaseBodyId(mCacheId, mList[i].mId);
+    }
     mManager->ReleaseCacheId(mCacheId);
   }
 }
 
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
 {
@@ -1229,23 +1271,21 @@ Manager::CachePut(Listener* aListener, R
                   nsIInputStream* aResponseBodyStream)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   MOZ_ASSERT(aListener);
   if (mShuttingDown) {
     aListener->OnCachePut(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
     return;
   }
-  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
                                                aCacheId,
                                                aRequest, aRequestBodyStream,
-                                               aResponse, aResponseBodyStream,
-                                               streamList);
+                                               aResponse, aResponseBodyStream);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
@@ -1460,11 +1500,89 @@ Manager::AddStreamList(StreamList* aStre
 void
 Manager::RemoveStreamList(StreamList* aStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   MOZ_ASSERT(aStreamList);
   mStreamLists.RemoveElement(aStreamList);
 }
 
+void
+Manager::AddRefBodyId(const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      mBodyIdRefs[i].mCount += 1;
+      return;
+    }
+  }
+  BodyIdRefCounter* entry = mBodyIdRefs.AppendElement();
+  entry->mBodyId = aBodyId;
+  entry->mCount = 1;
+  entry->mOrphaned = false;
+}
+
+void
+Manager::ReleaseBodyId(CacheId aCacheId, const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
+      mBodyIdRefs[i].mCount -= 1;
+      MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
+      if (mBodyIdRefs[i].mCount < 1) {
+        bool orphaned = mBodyIdRefs[i].mOrphaned;
+        mBodyIdRefs.RemoveElementAt(i);
+        // TODO: note that we need to check this body for staleness on startup
+        if (orphaned && !mShuttingDown) {
+          nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aCacheId,
+                                                                 aBodyId);
+          CurrentContext()->Dispatch(mIOThread, action);
+        }
+      }
+      return;
+    }
+  }
+  MOZ_ASSERT_UNREACHABLE("Attempt to release BodyId that is not referenced!");
+}
+
+// TODO: provide way to set body non-orphaned if its added back to a cache
+//       once same-origin de-duplication is implemented
+
+bool
+Manager::SetBodyIdOrphanedIfRefed(const nsID& aBodyId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
+    if (mBodyIdRefs[i].mBodyId == aBodyId) {
+      MOZ_ASSERT(mBodyIdRefs[i].mCount > 0);
+      MOZ_ASSERT(!mBodyIdRefs[i].mOrphaned);
+      mBodyIdRefs[i].mOrphaned = true;
+      return true;
+    }
+  }
+  return false;
+}
+
+void
+Manager::NoteOrphanedBodyIdList(CacheId aCacheId,
+                                const nsTArray<nsID>& aDeletedBodyIdList)
+{
+  NS_ASSERT_OWNINGTHREAD(Context::Listener);
+  nsTArray<nsID> deleteNowList;
+  for (uint32_t i = 0; i < aDeletedBodyIdList.Length(); ++i) {
+    if (!SetBodyIdOrphanedIfRefed(aDeletedBodyIdList[i])) {
+      deleteNowList.AppendElement(aDeletedBodyIdList[i]);
+    }
+  }
+
+  if (!deleteNowList.IsEmpty()) {
+    nsRefPtr<Action> action = new DeleteOrphanedBodyAction(aCacheId,
+                                                           deleteNowList);
+    CurrentContext()->Dispatch(mIOThread, action);
+  }
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -158,16 +158,17 @@ public:
   const nsCString& BaseDomain() const { return mBaseDomain; }
 
   // Context::Listener methods
   virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
 
 private:
   class Factory;
   class BaseAction;
+  class DeleteOrphanedBodyAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAction;
   class CacheDeleteAction;
   class CacheKeysAction;
 
@@ -184,30 +185,44 @@ private:
   Context* CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   void AddStreamList(StreamList* aStreamList);
   void RemoveStreamList(StreamList* aStreamList);
 
+  void AddRefBodyId(const nsID& aBodyId);
+  void ReleaseBodyId(CacheId aCacheId, const nsID& aBodyId);
+  bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
+  void NoteOrphanedBodyIdList(CacheId aCacheId,
+                              const nsTArray<nsID>& aDeletedBodyIdList);
+
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
   nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
   {
     CacheId mCacheId;
     uint32_t mCount;
     bool mOrphaned;
   };
   nsTArray<CacheIdRefCounter> mCacheIdRefs;
 
+  struct BodyIdRefCounter
+  {
+    nsID mBodyId;
+    uint32_t mCount;
+    bool mOrphaned;
+  };
+  nsTArray<BodyIdRefCounter> mBodyIdRefs;
+
   // weak ref as Context destructor clears this pointer
   Context* mContext;
 
   bool mShuttingDown;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/tests/mochitest/cache/test_cache_frame.html b/dom/tests/mochitest/cache/test_cache_frame.html
--- a/dom/tests/mochitest/cache/test_cache_frame.html
+++ b/dom/tests/mochitest/cache/test_cache_frame.html
@@ -13,17 +13,17 @@
   addEventListener("message", function messageListener(evt) {
     removeEventListener("message", messageListener);
     var success = true;
     var c = null
     // FIXME(nsm): Can't use a Request object for now since the operations
     // consume it's 'body'. See
     // https://github.com/slightlyoff/ServiceWorker/issues/510.
     var request = "http://example.com/hmm?q=foobar";
-    var response = new Response();
+    var response = new Response("This is some Response!");
     success = success && !!caches;
     caches.open("foobar").then(function(openCache) {
       success = success && !!openCache;
       c = openCache;
       return c.put(request, response);
     }).then(function(putResponse) {
       success = success && putResponse === undefined;
       return c.keys(request);
