# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  74dd6b9a1d5481f3e32011655d00afc0c20f5acf
Bug 1256428 P3 Add ServiceWorkerInstallJob2 to handle installation job steps. r=ehsan

diff --git a/dom/workers/ServiceWorkerInstallJob.cpp b/dom/workers/ServiceWorkerInstallJob.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInstallJob.cpp
@@ -0,0 +1,152 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerInstallJob.h"
+
+#include "ServiceWorkerScriptCache.h"
+#include "Workers.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerInstallJob2::ContinueRunnable final : public LifeCycleEventCallback
+{
+  nsMainThreadPtrHandle<ServiceWorkerInstallJob2> mJob;
+  bool mSuccess;
+
+public:
+  explicit ContinueRunnable(const nsMainThreadPtrHandle<ServiceWorkerInstallJob2>& aJob)
+    : mJob(aJob)
+    , mSuccess(false)
+  {
+    AssertIsOnMainThread();
+  }
+
+  void
+  SetResult(bool aResult) override
+  {
+    mSuccess = aResult;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnMainThread();
+    mJob->ContinueAfterInstallEvent(mSuccess);
+    mJob = nullptr;
+    return NS_OK;
+  }
+};
+
+void
+ServiceWorkerInstallJob2::ContinueAfterInstallEvent(bool aInstallEventSuccess)
+{
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(mRegistration->mInstallingWorker);
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+
+  // "If installFailed is true"
+  if (NS_WARN_IF(!aInstallEventSuccess)) {
+    mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
+    mRegistration->mInstallingWorker = nullptr;
+    swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                   WhichServiceWorker::INSTALLING_WORKER);
+    swm->MaybeRemoveRegistration(mRegistration);
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  // "If registration's waiting worker is not null"
+  if (mRegistration->mWaitingWorker) {
+    mRegistration->mWaitingWorker->WorkerPrivate()->TerminateWorker();
+    mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
+
+    nsresult rv =
+      serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
+                                           mRegistration->mWaitingWorker->CacheName());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to purge the old waiting cache.");
+    }
+  }
+
+  mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
+  mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
+  mRegistration->NotifyListenersOnChange();
+  swm->StoreRegistration(mPrincipal, mRegistration);
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER |
+                                                 WhichServiceWorker::WAITING_WORKER);
+
+  Finish(NS_OK);
+
+  // Activate() is invoked out of band of atomic.
+  mRegistration->TryToActivateAsync();
+}
+
+void
+ServiceWorkerInstallJob2::InstallAndFinish(ServiceWorkerRegistrationInfo *aRegistration,
+                                           ServiceWorkerInfo* aServiceWorker)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aServiceWorker);
+
+  MOZ_ASSERT(aRegistration);
+  MOZ_ASSERT(!mRegistration);
+  mRegistration = aRegistration;
+
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+
+  mRegistration->mInstallingWorker = aServiceWorker;
+  mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
+  mRegistration->NotifyListenersOnChange();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER);
+
+  InvokeResultCallbacks(NS_OK);
+
+  // The job should NOT call fail from this point on.
+
+  // fire the updatefound event
+  nsCOMPtr<nsIRunnable> upr =
+    NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
+      swm,
+      &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
+      mRegistration);
+  NS_DispatchToMainThread(upr);
+
+  // Call ContinueAfterInstallEvent(false) on main thread if the SW
+  // script fails to load.
+  nsCOMPtr<nsIRunnable> failRunnable = NS_NewRunnableMethodWithArgs<bool>
+    (this, &ServiceWorkerInstallJob2::ContinueAfterInstallEvent, false);
+
+  nsMainThreadPtrHandle<ServiceWorkerInstallJob2> handle(
+    new nsMainThreadPtrHolder<ServiceWorkerInstallJob2>(this));
+  RefPtr<LifeCycleEventCallback> callback = new ContinueRunnable(handle);
+
+  // Send the install event to the worker thread
+  ServiceWorkerPrivate* workerPrivate =
+    mRegistration->mInstallingWorker->WorkerPrivate();
+  nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("install"),
+                                                  callback, failRunnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ContinueAfterInstallEvent(false /* aSuccess */);
+  }
+}
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/ServiceWorkerInstallJob.h b/dom/workers/ServiceWorkerInstallJob.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInstallJob.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_serviceworkerinstalljob_h
+#define mozilla_dom_workers_serviceworkerinstalljob_h
+
+#include "ServiceWorkerJob.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerInstallJob2 : public ServiceWorkerJob2
+{
+  class ContinueRunnable;
+
+  RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
+
+  void
+  ContinueAfterInstallEvent(bool aInstallEventSuccess);
+
+protected:
+  void
+  InstallAndFinish(ServiceWorkerRegistrationInfo* aRegistration,
+                   ServiceWorkerInfo* aServiceWorker);
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_serviceworkerinstalljob_h
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -324,16 +324,17 @@ class ServiceWorkerManager final
   , public nsIIPCBackgroundChildCreateCallback
   , public nsIObserver
 {
   friend class GetReadyPromiseRunnable;
   friend class GetRegistrationsRunnable;
   friend class GetRegistrationRunnable;
   friend class ServiceWorkerJobQueue;
   friend class ServiceWorkerInstallJob;
+  friend class ServiceWorkerInstallJob2;
   friend class ServiceWorkerRegisterJob;
   friend class ServiceWorkerJobBase;
   friend class ServiceWorkerScriptJobBase;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerUnregisterJob;
   friend class UpdateTimerCallback;
 
 public:
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -61,16 +61,17 @@ UNIFIED_SOURCES += [
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerClient.cpp',
     'ServiceWorkerClients.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerEvents.cpp',
+    'ServiceWorkerInstallJob.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerMessageEvent.cpp',
     'ServiceWorkerPrivate.cpp',
