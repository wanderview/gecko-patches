# HG changeset patch
# Parent 30fba3f4756b70f55af0e1982e0a7e45fd712632
# User Ben Kelly <ben@wanderview.com>
Bug 1110487 P2 Implement the nsIOfflineStorage interface in Cache.

diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -52,17 +52,19 @@ void
 CacheParent::ActorDestroy(ActorDestroyReason aReason)
 {
   MOZ_ASSERT(mManager);
   for (uint32_t i = 0; i < mFetchPutList.Length(); ++i) {
     mFetchPutList[i]->ClearListener();
   }
   mFetchPutList.Clear();
   mManager->RemoveListener(this);
-  mManager->ReleaseCacheId(mCacheId);
+  if (mCacheId != INVALID_CACHEID) {
+    mManager->ReleaseCacheId(mCacheId);
+  }
   mManager = nullptr;
 }
 
 bool
 CacheParent::RecvTeardown()
 {
   if (!Send__delete__(this)) {
     // child process is gone, warn and allow actor to clean up normally
@@ -159,16 +161,28 @@ CacheParent::RecvKeys(const RequestId& a
                       const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
   mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 void
+CacheParent::Invalidate()
+{
+  // Our previously attached cache is no more.  Forget it and instead reference
+  // a non-existent Cache.  This will trigger errors on any future requests.
+  // TODO: consider re-attaching to a new Cache (bug 1110491)
+  if (mCacheId != INVALID_CACHEID) {
+    mManager->ReleaseCacheId(mCacheId);
+    mCacheId = INVALID_CACHEID;
+  }
+}
+
+void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse,
                           StreamList* aStreamList)
 {
   AutoParentResponseOrVoid response(Manager());
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -51,16 +51,17 @@ private:
   virtual bool
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
+  virtual void Invalidate() MOZ_OVERRIDE;
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse,
                             StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                                const nsTArray<SavedResponse>& aSavedResponses,
                                StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
@@ -72,17 +73,17 @@ private:
   // FetchPut::Listener methods
   virtual void OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId,
                           nsresult aRv) MOZ_OVERRIDE;
 
   already_AddRefed<nsIInputStream>
   DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
 
   nsRefPtr<cache::Manager> mManager;
-  const CacheId mCacheId;
+  CacheId mCacheId;
   nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheParent_h
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -286,16 +286,23 @@ CacheStorageParent::OnPrincipalVerified(
   mManagerId = aManagerId;
   mVerifier->ClearListener();
   mVerifier = nullptr;
 
   RetryPendingRequests();
 }
 
 void
+CacheStorageParent::Invalidate()
+{
+  // Nothing to do here as we don't have internal state.  Our next
+  // request will connect to a fresh database.
+}
+
+void
 CacheStorageParent::OnStorageMatch(RequestId aRequestId, nsresult aRv,
                                    const SavedResponse* aSavedResponse,
                                    StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   ReleaseManager(aRequestId);
 
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -46,16 +46,17 @@ private:
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
   // PrincipalVerifier::Listener methods
   virtual void OnPrincipalVerified(nsresult aRv,
                                    ManagerId* aManagerId) MOZ_OVERRIDE;
 
   // Manager::Listener methods
+  virtual void Invalidate() MOZ_OVERRIDE;
   virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound) MOZ_OVERRIDE;
   virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
                              CacheId aCacheId) MOZ_OVERRIDE;
   virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -5,58 +5,57 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Action.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/dom/cache/OfflineStorage.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsIFile.h"
 #include "nsIPrincipal.h"
 #include "nsIRunnable.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::dom::Nullable;
 using mozilla::dom::cache::QuotaInfo;
+using mozilla::dom::quota::Client;
 using mozilla::dom::quota::OriginOrPatternString;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
-// Executed when the context is destroyed to release our lock on the
-// QuotaManager.
+// Release out lock on the QuotaManager directory asynchronously.
 class QuotaReleaseRunnable MOZ_FINAL : public nsRunnable
 {
 public:
-  QuotaReleaseRunnable(const QuotaInfo& aQuotaInfo, const nsACString& aQuotaId)
+  explicit QuotaReleaseRunnable(const QuotaInfo& aQuotaInfo)
     : mQuotaInfo(aQuotaInfo)
-    , mQuotaId(aQuotaId)
   { }
 
   NS_IMETHOD Run() MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
     QuotaManager* qm = QuotaManager::Get();
     MOZ_ASSERT(qm);
     qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                 Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
-                                mQuotaId);
+                                mQuotaInfo.mStorageId);
     return NS_OK;
   }
 
 private:
   ~QuotaReleaseRunnable() { }
 
   const QuotaInfo mQuotaInfo;
-  const nsCString mQuotaId;
 };
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
@@ -70,25 +69,25 @@ using mozilla::dom::quota::PersistenceTy
 // the QuotaManager.  This must be performed for each origin before any disk
 // IO occurrs.
 class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
                                            , public Action::Resolver
 {
 public:
   QuotaInitRunnable(Context* aContext,
                     Manager* aManager,
-                    const nsACString& aQuotaId,
                     Action* aQuotaIOThreadAction)
     : mContext(aContext)
+    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
     , mManager(aManager)
-    , mQuotaId(aQuotaId)
     , mQuotaIOThreadAction(aQuotaIOThreadAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
+    , mNeedsQuotaRelease(false)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
@@ -147,23 +146,25 @@ private:
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
     mContext = nullptr;
     mManager = nullptr;
     mQuotaIOThreadAction = nullptr;
   }
 
   nsRefPtr<Context> mContext;
+  nsRefPtr<ThreadsafeHandle> mThreadsafeHandle;
   nsRefPtr<Manager> mManager;
-  const nsCString mQuotaId;
   nsRefPtr<Action> mQuotaIOThreadAction;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   nsresult mResult;
   QuotaInfo mQuotaInfo;
+  nsMainThreadPtrHandle<OfflineStorage> mOfflineStorage;
+  bool mNeedsQuotaRelease;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
                             Action::Resolver, nsIRunnable);
@@ -225,35 +226,46 @@ Context::QuotaInitRunnable::Run()
                                              &mQuotaInfo.mGroup,
                                              &mQuotaInfo.mOrigin,
                                              &mQuotaInfo.mIsApp);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         Resolve(rv);
         return NS_OK;
       }
 
+      QuotaManager::GetStorageId(PERSISTENCE_TYPE_DEFAULT,
+                                 mQuotaInfo.mOrigin,
+                                 Client::DOMCACHE,
+                                 NS_LITERAL_STRING("cache"),
+                                 mQuotaInfo.mStorageId);
+
       // QuotaManager::WaitForOpenAllowed() will hold a reference to us as
       // a callback.  We will then get executed again on the main thread when
       // it is safe to open the quota directory.
       mState = STATE_WAIT_FOR_OPEN_ALLOWED;
       rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                   Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
-                                  mQuotaId, this);
+                                  mQuotaInfo.mStorageId, this);
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
       break;
     }
     // ------------------------------
     case STATE_WAIT_FOR_OPEN_ALLOWED:
     {
       MOZ_ASSERT(NS_IsMainThread());
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
+
+      nsRefPtr<OfflineStorage> offlineStorage =
+        OfflineStorage::Register(mThreadsafeHandle, mQuotaInfo);
+      mOfflineStorage = new nsMainThreadPtrHolder<OfflineStorage>(offlineStorage);
+
       mState = STATE_ENSURE_ORIGIN_INITIALIZED;
       nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         Resolve(rv);
         return NS_OK;
       }
       break;
     }
@@ -272,16 +284,17 @@ Context::QuotaInitRunnable::Run()
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
 
+      mNeedsQuotaRelease = true;
       mState = STATE_RUNNING;
 
       if (!mQuotaIOThreadAction) {
         Resolve(NS_OK);
         return NS_OK;
       }
 
       // Execute the provided initialization Action.  We pass ourselves as the
@@ -293,18 +306,26 @@ Context::QuotaInitRunnable::Run()
     }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       if (mQuotaIOThreadAction) {
         mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
       }
-      mContext->OnQuotaInit(mResult, mQuotaInfo);
+      mContext->OnQuotaInit(mResult, mQuotaInfo, mOfflineStorage);
       mState = STATE_COMPLETE;
+
+      if (mNeedsQuotaRelease) {
+        // Unlock the quota dir if we locked it previously
+        nsCOMPtr<nsIRunnable> runnable = new QuotaReleaseRunnable(mQuotaInfo);
+        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+          NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL)));
+      }
+
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
     // -----
     default:
     {
@@ -316,16 +337,17 @@ Context::QuotaInitRunnable::Run()
   return NS_OK;
 }
 
 // Runnable wrapper around Action objects dispatched on the Context.  This
 // runnable executes the Action on the appropriate threads while the Context
 // is initialized.
 class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
                                         , public Action::Resolver
+                                        , public Context::Activity
 {
 public:
   ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
                  const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
@@ -349,22 +371,25 @@ public:
     nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
-  bool MatchesCacheId(CacheId aCacheId) {
+  virtual bool
+  MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
+  {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     return mAction->MatchesCacheId(aCacheId);
   }
 
-  void Cancel()
+  virtual void
+  Cancel() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
@@ -387,17 +412,17 @@ private:
     MOZ_ASSERT(!mAction);
   }
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mAction);
-    mContext->OnActionRunnableComplete(this);
+    mContext->RemoveActivity(this);
     mContext = nullptr;
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
     STATE_RUN_ON_TARGET,
@@ -477,25 +502,117 @@ Context::ActionRunnable::Run()
     {
       MOZ_CRASH("unexpected state in ActionRunnable");
       break;
     }
   }
   return NS_OK;
 }
 
+void
+Context::ThreadsafeHandle::AllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    AllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
+}
+
+void
+Context::ThreadsafeHandle::CancelAndAllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    CancelAndAllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableMethod(this, &ThreadsafeHandle::CancelAndAllowToCloseOnOwningThread);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
+}
+
+Context::ThreadsafeHandle::ThreadsafeHandle(Context* aContext)
+  : mStrongRef(aContext)
+  , mWeakRef(aContext)
+  , mOwningThread(NS_GetCurrentThread())
+{
+}
+
+Context::ThreadsafeHandle::~ThreadsafeHandle()
+{
+  // Normally we only touch mStrongRef on the owning thread.  This is safe,
+  // however, because when we do use mStrongRef on the owning thread we are
+  // always holding a strong ref to the ThreadsafeHandle via the owning
+  // runnable.  So we cannot run the ThreadsafeHandle destructor simultaneously.
+  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewNonOwningRunnableMethod(mStrongRef.forget().take(), &Context::Release);
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL)));
+}
+
+void
+Context::ThreadsafeHandle::AllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  // A Context "closes" when its ref count drops to zero.  Dropping this
+  // strong ref is necessary, but not sufficient for the close to occur.
+  // Any outstanding IO will continue and keep the Context alive.  Once
+  // the Context is idle, it will be destroyed.
+  mStrongRef = nullptr;
+}
+
+void
+Context::ThreadsafeHandle::CancelAndAllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  // Cancel the Context through the weak reference.  This means we can
+  // allow the Context to close by dropping the strong ref, but then
+  // still cancel ongoing IO if necessary.
+  if (mWeakRef) {
+    mWeakRef->CancelAll();
+  }
+  // We should synchronously have AllowToCloseOnOwningThread called when
+  // the Context is canceled.
+  MOZ_ASSERT(!mStrongRef);
+}
+
+void
+Context::ThreadsafeHandle::ContextDestroyed(Context* aContext)
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  MOZ_ASSERT(!mStrongRef);
+  MOZ_ASSERT(mWeakRef);
+  MOZ_ASSERT(mWeakRef == aContext);
+  mWeakRef = nullptr;
+}
+
 // static
 already_AddRefed<Context>
 Context::Create(Manager* aManager, Action* aQuotaIOThreadAction)
 {
   nsRefPtr<Context> context = new Context(aManager);
 
   nsRefPtr<QuotaInitRunnable> runnable =
-    new QuotaInitRunnable(context, aManager, NS_LITERAL_CSTRING("Cache"),
-                          aQuotaIOThreadAction);
+    new QuotaInitRunnable(context, aManager, aQuotaIOThreadAction);
   nsresult rv = runnable->Dispatch();
   if (NS_FAILED(rv)) {
     // Shutdown must be delayed until all Contexts are destroyed.  Shutdown
     // must also prevent any new Contexts from being constructed.  Crash
     // for this invariant violation.
     MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
   }
 
@@ -530,52 +647,63 @@ Context::Dispatch(nsIEventTarget* aTarge
 }
 
 void
 Context::CancelAll()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   mState = STATE_CONTEXT_CANCELED;
   mPendingActions.Clear();
-  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
-    nsRefPtr<ActionRunnable> runnable = mActionRunnables[i];
-    runnable->Cancel();
+  ActivityList::ForwardIterator iter(mActivityList);
+  while (iter.HasMore()) {
+    iter.GetNext()->Cancel();
+  }
+  AllowToClose();
+}
+
+void
+Context::AllowToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->AllowToClose();
   }
 }
 
 void
 Context::CancelForCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+
+  // Remove matching pending actions
+  nsTArray<PendingAction> remainingPendingActions;
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
-      mPendingActions.RemoveElementAt(i);
+    if (!mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
+      remainingPendingActions.AppendElement(mPendingActions[i]);
     }
   }
-  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
-    nsRefPtr<ActionRunnable> runnable = mActionRunnables[i];
-    if (runnable->MatchesCacheId(aCacheId)) {
-      runnable->Cancel();
+  mPendingActions = Move(remainingPendingActions);
+
+  // Cancel activities and let them remove themselves
+  ActivityList::ForwardIterator iter(mActivityList);
+  while (iter.HasMore()) {
+    Activity* activity = iter.GetNext();
+    if (activity->MatchesCacheId(aCacheId)) {
+      activity->Cancel();
     }
   }
 }
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mManager);
 
-  // Unlock the quota dir as we go out of scope.
-  nsCOMPtr<nsIRunnable> runnable =
-    new QuotaReleaseRunnable(mQuotaInfo, NS_LITERAL_CSTRING("Cache"));
-  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
-  if (NS_FAILED(rv)) {
-    // Shutdown must be delayed until all Contexts are destroyed.  Crash
-    // for this invariant violation.
-    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->ContextDestroyed(this);
   }
 
   mManager->RemoveContext(this);
 }
 
 void
 Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
 {
@@ -584,47 +712,72 @@ Context::DispatchAction(nsIEventTarget* 
   nsRefPtr<ActionRunnable> runnable =
     new ActionRunnable(this, aTarget, aAction, mQuotaInfo);
   nsresult rv = runnable->Dispatch();
   if (NS_FAILED(rv)) {
     // Shutdown must be delayed until all Contexts are destroyed.  Crash
     // for this invariant violation.
     MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
   }
-  mActionRunnables.AppendElement(runnable);
+  AddActivity(runnable);
 }
 
 void
-Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo)
+Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                     nsMainThreadPtrHandle<OfflineStorage>& aOfflineStorage)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
   mQuotaInfo = aQuotaInfo;
 
   if (mState == STATE_CONTEXT_CANCELED || NS_FAILED(aRv)) {
     for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
+    mThreadsafeHandle = nullptr;
     // Context will destruct after return here and last ref is released.
     return;
   }
 
   MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
   mState = STATE_CONTEXT_READY;
 
+  mOfflineStorage = aOfflineStorage;
+
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
   }
   mPendingActions.Clear();
 }
 
 void
-Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+Context::AddActivity(Activity* aActivity)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActionRunnable);
-  MOZ_ALWAYS_TRUE(mActionRunnables.RemoveElement(aActionRunnable));
+  MOZ_ASSERT(aActivity);
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+  mActivityList.AppendElement(aActivity);
+}
+
+void
+Context::RemoveActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aActivity);
+  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+}
+
+already_AddRefed<Context::ThreadsafeHandle>
+Context::CreateThreadsafeHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  if (!mThreadsafeHandle) {
+    mThreadsafeHandle = new ThreadsafeHandle(this);
+  }
+  nsRefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
+  return ref.forget();
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
--- a/dom/cache/Context.h
+++ b/dom/cache/Context.h
@@ -6,28 +6,32 @@
 
 #ifndef mozilla_dom_cache_Context_h
 #define mozilla_dom_cache_Context_h
 
 #include "mozilla/dom/cache/Types.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
+#include "nsProxyRelease.h"
 #include "nsString.h"
 #include "nsTArray.h"
+#include "nsTObserverArray.h"
 
 class nsIEventTarget;
 class nsIFile;
+class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Action;
 class Manager;
+class OfflineStorage;
 
 // The Context class is RAII-style class for managing IO operations within the
 // Cache.
 //
 // When a Context is created it performs the complicated steps necessary to
 // initialize the QuotaManager.  Action objects dispatched on the Context are
 // delayed until this initialization is complete.  They are then allow to
 // execute on any specified thread.  Once all references to the Context are
@@ -40,38 +44,90 @@ class Manager;
 // originally used to create the Context.
 //
 // As an invariant, all Context objects must be destroyed before permitting
 // the "profile-before-change" shutdown event to complete.  This is ensured
 // via the code in ShutdownObserver.cpp.
 class Context MOZ_FINAL
 {
 public:
+  // Define a class allowing other threads to hold the Context alive.  This also
+  // allows these other threads to safely close or cancel the Context.
+  class ThreadsafeHandle MOZ_FINAL
+  {
+    friend class Context;
+  public:
+    void AllowToClose();
+    void CancelAndAllowToClose();
+  private:
+    explicit ThreadsafeHandle(Context* aContext);
+    ~ThreadsafeHandle();
+
+    void AllowToCloseOnOwningThread();
+    void CancelAndAllowToCloseOnOwningThread();
+
+    void ContextDestroyed(Context* aContext);
+
+    // Cleared to allow the Context to close.  Only safe to access on
+    // owning thread.
+    nsRefPtr<Context> mStrongRef;
+
+    // Used to support cancelation even while the Context is already allowed
+    // to close.  Cleared by ~Context() calling ContextDestroyed().  Only
+    // safe to access on owning thread.
+    Context* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Context::ThreadsafeHandle)
+  };
+
+  // Must call RemoveActivity() in its destructor
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+    virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
+  };
+
   static already_AddRefed<Context>
   Create(Manager* aManager, Action* aQuotaIOThreadAction);
 
   // Execute given action on the target once the quota manager has been
   // initialized.
   //
   // Only callable from the thread that created the Context.
   void Dispatch(nsIEventTarget* aTarget, Action* aAction);
 
   // Cancel any Actions running or waiting to run.  This should allow the
   // Context to be released and Listener::RemoveContext() will be called
-  // when complete.
+  // when complete.  This effectively implies AllowToClose() as well.
   //
   // Only callable from the thread that created the Context.
   void CancelAll();
 
+  // Remove any self references and allow the Context to be released when
+  // there are no more Actions to process.
+  void AllowToClose();
+
   // Cancel any Actions running or waiting to run that operate on the given
   // cache ID.
   //
   // Only callable from the thread that created the Context.
   void CancelForCacheId(CacheId aCacheId);
 
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
 private:
   class QuotaInitRunnable;
   class ActionRunnable;
 
   enum State
   {
     STATE_CONTEXT_INIT,
     STATE_CONTEXT_READY,
@@ -82,26 +138,38 @@ private:
   {
     nsCOMPtr<nsIEventTarget> mTarget;
     nsRefPtr<Action> mAction;
   };
 
   explicit Context(Manager* aManager);
   ~Context();
   void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
-  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo);
-  void OnActionRunnableComplete(ActionRunnable* const aAction);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                   nsMainThreadPtrHandle<OfflineStorage>& aOfflineStorage);
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
 
   nsRefPtr<Manager> mManager;
   State mState;
   QuotaInfo mQuotaInfo;
   nsTArray<PendingAction> mPendingActions;
 
-  // weak refs since ~ActionRunnable() removes itself from this list
-  nsTArray<ActionRunnable*> mActionRunnables;
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us.  This creates
+  // a ref-cycle that keeps the Context alive.  The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  nsRefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  nsMainThreadPtrHandle<OfflineStorage> mOfflineStorage;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(cache::Context)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -434,17 +434,17 @@ DBSchema::StorageMatch(mozIStorageConnec
 
   nsresult rv;
 
   // If we are given a cache to check, then simply find its cache ID
   // and perform the match.
   if (!aParams.cacheName().EqualsLiteral("")) {
     bool foundCache = false;
     // no invalid CacheId, init to least likely real value
-    CacheId cacheId = INT32_MAX;
+    CacheId cacheId = INVALID_CACHEID;
     rv = StorageGetCacheId(aConn, aNamespace, aParams.cacheName(), &foundCache,
                            &cacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (!foundCache) { return NS_ERROR_DOM_NOT_FOUND_ERR; }
 
     rv = CacheMatch(aConn, cacheId, aRequest, aParams, aFoundResponseOut,
                     aSavedResponseOut);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -462,17 +462,17 @@ DBSchema::StorageMatch(mozIStorageConnec
 
   rv = state->BindInt32Parameter(0, aNamespace);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsAutoTArray<CacheId, 32> cacheIdList;
 
   bool hasMoreData = false;
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    CacheId cacheId = INT32_MAX;
+    CacheId cacheId = INVALID_CACHEID;
     rv = state->GetInt32(0, &cacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     cacheIdList.AppendElement(cacheId);
   }
 
   // Now try to find a match in each cache in order
   for (uint32_t i = 0; i < cacheIdList.Length(); ++i) {
     rv = CacheMatch(aConn, cacheIdList[i], aRequest, aParams, aFoundResponseOut,
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
--- a/dom/cache/FetchPut.cpp
+++ b/dom/cache/FetchPut.cpp
@@ -149,17 +149,19 @@ FetchPut::FetchPut(Listener* aListener, 
   mManager->AddRefCacheId(mCacheId);
 }
 
 FetchPut::~FetchPut()
 {
   MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
   MOZ_ASSERT(!mListener);
   mManager->RemoveListener(this);
-  mManager->ReleaseCacheId(mCacheId);
+  if (mCacheId != INVALID_CACHEID) {
+    mManager->ReleaseCacheId(mCacheId);
+  }
 }
 
 nsresult
 FetchPut::DispatchToMainThread()
 {
   MOZ_ASSERT(!mRunnable);
 
   nsRefPtr<nsIRunnable> runnable = new Runnable(this);
@@ -409,16 +411,28 @@ void
 FetchPut::OnCachePutAll(RequestId aRequestId, nsresult aRv)
 {
   MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
   MaybeSetError(aRv);
   MaybeNotifyListener();
 }
 
 void
+FetchPut::Invalidate()
+{
+  // Our previously attached cache is no more.  Forget it and instead reference
+  // a non-existent Cache.  This will trigger errors on any future requests.
+  // TODO: consider re-attaching to a new Cache (bug 1110491)
+  if (mCacheId != INVALID_CACHEID) {
+    mManager->ReleaseCacheId(mCacheId);
+    mCacheId = INVALID_CACHEID;
+  }
+}
+
+void
 FetchPut::MaybeSetError(nsresult aRv)
 {
   if (NS_FAILED(mResult) || NS_SUCCEEDED(aRv)) {
     return;
   }
   mResult = aRv;
 }
 
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
--- a/dom/cache/FetchPut.h
+++ b/dom/cache/FetchPut.h
@@ -85,31 +85,33 @@ private:
   void DoFetchOnMainThread();
   void FetchComplete(FetchObserver* aObserver,
                      InternalResponse* aInternalResponse);
   void MaybeCompleteOnMainThread();
 
   void DoPutOnWorkerThread();
   static bool MatchInPutList(const PCacheRequest& aRequest,
                              const nsTArray<CacheRequestResponse>& aPutList);
+
+  virtual void Invalidate() MOZ_OVERRIDE;
   virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
 
   void MaybeSetError(nsresult aRv);
   void MaybeNotifyListener();
 
   // TypeUtils methods
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
   Listener* mListener;
   nsRefPtr<Manager> mManager;
   const RequestId mRequestId;
-  const CacheId mCacheId;
+  CacheId mCacheId;
   nsCOMPtr<nsIThread> mInitiatingThread;
   nsTArray<State> mStateList;
   uint32_t mPendingCount;
   nsresult mResult;
   nsCOMPtr<nsIRunnable> mRunnable;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(mozilla::dom::cache::FetchPut)
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -218,16 +218,37 @@ public:
     // Guaranteed to succeed because we should be shutdown before the
     // background thread is destroyed.
     nsCOMPtr<nsIRunnable> runnable = new ShutdownAllRunnable();
     nsresult rv = sBackgroundThread->Dispatch(runnable,
                                               nsIThread::DISPATCH_NORMAL);
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
   }
 
+  static void
+  InvalidateActorsOnIOThread()
+  {
+    MOZ_ASSERT(!NS_IsMainThread());
+
+    StaticMutexAutoLock lock(sMutex);
+
+    // Don't bother invalidating actors if we are shutting down.  It will
+    // just slow shutdown down as we waste CPU cycles with useless work.
+    if (!sBackgroundThread && !sFactoryShutdown) {
+      return;
+    }
+
+    MOZ_ASSERT(NS_GetCurrentThread() != sBackgroundThread);
+
+    nsCOMPtr<nsIRunnable> runnable = new InvalidateActorsRunnable();
+    nsresult rv = sBackgroundThread->Dispatch(runnable,
+                                              nsIThread::DISPATCH_NORMAL);
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
+  }
+
   static bool
   IsShutdownAllCompleteOnMainThread()
   {
     MOZ_ASSERT(NS_IsMainThread());
     StaticMutexAutoLock lock(sMutex);
     // Infer whether we have shutdown using the sBackgroundThread value.  We
     // guarantee this is nullptr when sFactory is destroyed.
     return sFactoryShutdown && !sBackgroundThread;
@@ -341,30 +362,66 @@ private:
         nsRefPtr<Manager> manager = iter.GetNext();
         manager->Shutdown();
       }
     }
 
     MaybeDestroyInstance();
   }
 
+  static void
+  InvalidateActorsOnBackgroundThread()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+#ifdef DEBUG
+      StaticMutexAutoLock lock(sMutex);
+      MOZ_ASSERT(!sBackgroundThread);
+#endif
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    ManagerList::ForwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      nsRefPtr<Manager> manager = iter.GetNext();
+      manager->InvalidateActors();
+    }
+  }
+
   class ShutdownAllRunnable MOZ_FINAL : public nsRunnable
   {
   public:
     NS_IMETHOD
     Run() MOZ_OVERRIDE
     {
       mozilla::ipc::AssertIsOnBackgroundThread();
       ShutdownAllOnBackgroundThread();
       return NS_OK;
     }
   private:
     ~ShutdownAllRunnable() { }
   };
 
+  class InvalidateActorsRunnable MOZ_FINAL : public nsRunnable
+  {
+  public:
+    NS_IMETHOD
+    Run() MOZ_OVERRIDE
+    {
+      mozilla::ipc::AssertIsOnBackgroundThread();
+      InvalidateActorsOnBackgroundThread();
+      return NS_OK;
+    }
+  private:
+    ~InvalidateActorsRunnable() { }
+  };
+
   // Singleton created on demand and deleted when last Manager is cleared
   // in Remove().
   // PBackground thread only.
   static StaticAutoPtr<Factory> sFactory;
 
   // protects following static attributes
   static StaticMutex sMutex;
 
@@ -1393,25 +1450,37 @@ Manager::ShutdownAllOnMainThread()
   while (!Factory::IsShutdownAllCompleteOnMainThread()) {
     if (!NS_ProcessNextEvent()) {
       NS_WARNING("Something bad happened!");
       break;
     }
   }
 }
 
+// static
+void
+Manager::InvalidateActorsOnIOThread()
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  // On QuotaManager IO thread
+  Factory::InvalidateActorsOnIOThread();
+}
+
 void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   // There may not be a listener here in the case where an actor is killed
   // before it can perform any actual async requests on Manager.
   mListeners.RemoveElement(aListener, ListenerEntryListenerComparator());
   MOZ_ASSERT(!mListeners.Contains(aListener,
                                   ListenerEntryListenerComparator()));
+  if (mListeners.IsEmpty() && mContext) {
+    mContext->AllowToClose();
+  }
 }
 
 void
 Manager::RemoveContext(Context* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
@@ -1763,33 +1832,37 @@ Manager::Shutdown()
     return;
   }
 
   // Set a flag to prevent any new requests from coming in and creating
   // a new Context.  We must ensure all Contexts and IO operations are
   // complete before shutdown proceeds.
   mShuttingDown = true;
 
-  for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
-    nsRefPtr<StreamList> streamList = mStreamLists[i];
-    streamList->CloseAll();
-  }
-
   // If there is a context, then we must wait for it to complete.  Cancel and
   // only note that we are done after its cleaned up.
   if (mContext) {
     nsRefPtr<Context> context = mContext;
     context->CancelAll();
     return;
   }
 
   // Otherwise, note that we are complete immediately
   Factory::Remove(this);
 }
 
+void
+Manager::InvalidateActors()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    mListeners[i].mListener->Invalidate();
+  }
+}
+
 already_AddRefed<Context>
 Manager::CurrentContext()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   nsRefPtr<Context> ref = mContext;
   if (!ref) {
     MOZ_ASSERT(!mShuttingDown);
     nsRefPtr<Action> setupAction = new SetupAction();
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -81,16 +81,17 @@ public:
   // Listeners must call Manager::RemoveListener() before they are destroyed
   // to clear these weak references.
   //
   // All public methods should be invoked on the same thread used to create
   // the Manager.
   class Listener
   {
   public:
+    virtual void Invalidate() = 0;
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                                  const nsTArray<SavedResponse>& aSavedResponses,
                                  StreamList* aStreamList) { }
     virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
@@ -116,16 +117,19 @@ public:
   };
 
   static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut);
   static already_AddRefed<Manager> Get(ManagerId* aManagerId);
 
   // Synchronously shutdown from main thread.  This spins the event loop.
   static void ShutdownAllOnMainThread();
 
+  // Asynchronously invalidates all existing Cache actors.
+  static void InvalidateActorsOnIOThread();
+
   // Must be called by Listener objects before they are destroyed.
   void RemoveListener(Listener* aListener);
 
   // Must be called by Context objects before they are destroyed.
   void RemoveContext(Context* aContext);
 
   // If an actor represents a long term reference to a cache or body stream,
   // then they must call AddRefCacheId() or AddRefBodyId().  This will
@@ -192,16 +196,17 @@ private:
   class StorageDeleteAction;
   class StorageKeysAction;
 
   typedef uint64_t ListenerId;
 
   Manager(ManagerId* aManagerId, nsIThread* aIOThread);
   ~Manager();
   void Shutdown();
+  void InvalidateActors();
   already_AddRefed<Context> CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
@@ -211,18 +216,18 @@ private:
 
   // Weak reference cleared by RemoveContext() in Context destructor.
   Context* MOZ_NON_OWNING_REF mContext;
 
   // Weak references cleared by RemoveListener() in Listener destructors.
   struct ListenerEntry
   {
     ListenerEntry()
-      : mId(UINT64_MAX),
-      mListener(nullptr)
+      : mId(UINT64_MAX)
+      , mListener(nullptr)
     {
     }
 
     ListenerEntry(ListenerId aId, Listener* aListener)
       : mId(aId)
       , mListener(aListener)
     {
     }
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/OfflineStorage.cpp
@@ -0,0 +1,133 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/OfflineStorage.h"
+
+#include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/QuotaClient.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::Client;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::QuotaManager;
+
+NS_IMPL_ISUPPORTS(OfflineStorage, nsIOfflineStorage);
+
+// static
+already_AddRefed<OfflineStorage>
+OfflineStorage::Register(Context::ThreadsafeHandle* aContext,
+                         const QuotaInfo& aQuotaInfo)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsRefPtr<QuotaManager> qm = QuotaManager::GetOrCreate();
+  if (NS_WARN_IF(!qm)) {
+    return nullptr;
+  }
+
+  nsRefPtr<OfflineStorage> storage =
+    new OfflineStorage(aContext, aQuotaInfo);
+
+  if (NS_WARN_IF(!qm->RegisterStorage(storage))) {
+    return nullptr;
+  }
+
+  return storage.forget();
+}
+
+void
+OfflineStorage::SetDestroyCallback(nsIRunnable* aCallback)
+{
+  MOZ_ASSERT(!mDestroyCallback);
+  mDestroyCallback = aCallback;
+}
+
+OfflineStorage::OfflineStorage(Context::ThreadsafeHandle* aContext,
+                               const QuotaInfo& aQuotaInfo)
+  : mContext(aContext)
+  , mQuotaInfo(aQuotaInfo)
+{
+  MOZ_ASSERT(mContext);
+
+  mPersistenceType = PERSISTENCE_TYPE_DEFAULT;
+  mGroup = mQuotaInfo.mGroup;
+  mClient = CreateQuotaClient();
+}
+
+OfflineStorage::~OfflineStorage()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsRefPtr<QuotaManager> qm = QuotaManager::GetOrCreate();
+  if (!qm) {
+    NS_WARNING("QuotaManager gone before Cache storage could unregister");
+    return;
+  }
+  qm->UnregisterStorage(this);
+  if (mDestroyCallback) {
+    mDestroyCallback->Run();
+  }
+}
+
+NS_IMETHODIMP_(const nsACString&)
+OfflineStorage::Id()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  return mQuotaInfo.mStorageId;
+}
+
+NS_IMETHODIMP_(Client*)
+OfflineStorage::GetClient()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  return mClient;
+}
+
+NS_IMETHODIMP_(bool)
+OfflineStorage::IsOwnedByProcess(ContentParent* aOwner)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  // The Cache and Context can be shared by multiple client processes.  They
+  // are not exclusively owned by a single process.
+  //
+  // As far as I can tell this is used by QuotaManager to shutdown storages
+  // when a particular process goes away.  We definitely don't want this
+  // since we are shared.  Also, the Cache actor code already properly
+  // handles asynchronous actor destruction when the child process dies.
+  //
+  // Therefore, always return false here.
+  return false;
+}
+
+NS_IMETHODIMP_(const nsACString&)
+OfflineStorage::Origin()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  return mQuotaInfo.mOrigin;
+}
+
+NS_IMETHODIMP_(nsresult)
+OfflineStorage::Close()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  mContext->AllowToClose();
+  return NS_OK;
+}
+
+NS_IMETHODIMP_(void)
+OfflineStorage::Invalidate()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  mContext->CancelAndAllowToClose();
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/OfflineStorage.h b/dom/cache/OfflineStorage.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/OfflineStorage.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_QuotaOfflineStorage_h
+#define mozilla_dom_cache_QuotaOfflineStorage_h
+
+#include "nsISupportsImpl.h"
+#include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/dom/cache/Context.h"
+#include "nsIOfflineStorage.h"
+
+class nsIThread;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class OfflineStorage MOZ_FINAL : public nsIOfflineStorage
+{
+public:
+  static already_AddRefed<OfflineStorage>
+  Register(Context::ThreadsafeHandle* aContext, const QuotaInfo& aQuotaInfo);
+
+  void
+  SetDestroyCallback(nsIRunnable* aCallback);
+
+private:
+  OfflineStorage(Context::ThreadsafeHandle* aContext,
+                 const QuotaInfo& aQuotaInfo);
+  ~OfflineStorage();
+
+  nsRefPtr<Context::ThreadsafeHandle> mContext;
+  const QuotaInfo mQuotaInfo;
+  nsRefPtr<Client> mClient;
+  nsCOMPtr<nsIRunnable> mDestroyCallback;
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOFFLINESTORAGE
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_QuotaOfflineStorage_h
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -3,26 +3,28 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/QuotaClient.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/OfflineStorage.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "mozilla/dom/quota/UsageInfo.h"
 #include "nsIFile.h"
 #include "nsISimpleEnumerator.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::DebugOnly;
 using mozilla::dom::cache::Manager;
+using mozilla::dom::cache::OfflineStorage;
 using mozilla::dom::quota::Client;
 using mozilla::dom::quota::PersistenceType;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::UsageInfo;
 
 static nsresult
 GetBodyUsage(nsIFile* aDir, UsageInfo* aUsageInfo)
 {
@@ -55,16 +57,51 @@ GetBodyUsage(nsIFile* aDir, UsageInfo* a
     MOZ_ASSERT(fileSize >= 0);
 
     aUsageInfo->AppendToFileUsage(fileSize);
   }
 
   return NS_OK;
 }
 
+class StoragesDestroyedRunnable MOZ_FINAL : public nsRunnable
+{
+  uint32_t mExpectedCalls;
+  nsCOMPtr<nsIRunnable> mCallback;
+
+public:
+  StoragesDestroyedRunnable(uint32_t aExpectedCalls, nsIRunnable* aCallback)
+    : mExpectedCalls(aExpectedCalls)
+    , mCallback(aCallback)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(mExpectedCalls);
+    MOZ_ASSERT(mCallback);
+  }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(mExpectedCalls);
+    mExpectedCalls -= 1;
+    if (!mExpectedCalls) {
+      mCallback->Run();
+    }
+    return NS_OK;
+  }
+
+private:
+  ~StoragesDestroyedRunnable()
+  {
+    // This is a callback runnable and not used for thread dispatch.  It should
+    // always be destroyed on the main thread.
+    MOZ_ASSERT(NS_IsMainThread());
+  }
+};
+
 class CacheQuotaClient MOZ_FINAL : public Client
 {
 public:
   virtual Type
   GetType() MOZ_OVERRIDE
   {
     return DOMCACHE;
   }
@@ -146,43 +183,55 @@ public:
 
     return NS_OK;
   }
 
   virtual void
   OnOriginClearCompleted(PersistenceType aPersistenceType,
                          const nsACString& aOrigin) MOZ_OVERRIDE
   {
-    // nothing to do
+    Manager::InvalidateActorsOnIOThread();
   }
 
   virtual void
   ReleaseIOThreadObjects() MOZ_OVERRIDE
   {
-    // nothing to do
+    // Nothing to do here as the Context handles cleaning everything up
+    // automatically.
   }
 
   virtual bool
   IsFileServiceUtilized() MOZ_OVERRIDE
   {
-    return false;
+    return true;
   }
 
   virtual bool
   IsTransactionServiceActivated() MOZ_OVERRIDE
   {
-    // TODO: implement nsIOfflineStorage interface (bug 1110487)
-    return false;
+    return true;
   }
 
   virtual void
   WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
                             nsIRunnable* aCallback) MOZ_OVERRIDE
   {
-    // TODO: implement nsIOfflineStorage interface (bug 1110487)
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(!aStorages.IsEmpty());
+
+    nsCOMPtr<nsIRunnable> callback =
+      new StoragesDestroyedRunnable(aStorages.Length(),aCallback);
+
+    for (uint32_t i = 0; i < aStorages.Length(); ++i) {
+      MOZ_ASSERT(aStorages[i]->GetClient());
+      MOZ_ASSERT(aStorages[i]->GetClient()->GetType() == Client::DOMCACHE);
+      nsRefPtr<OfflineStorage> storage =
+        static_cast<OfflineStorage*>(aStorages[i]);
+      storage->SetDestroyCallback(callback);
+    }
   }
 
 
   virtual void
   ShutdownTransactionService() MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
 
diff --git a/dom/cache/StreamList.cpp b/dom/cache/StreamList.cpp
--- a/dom/cache/StreamList.cpp
+++ b/dom/cache/StreamList.cpp
@@ -18,17 +18,17 @@ namespace cache {
 StreamList::StreamList(Manager* aManager, Context* aContext)
   : mManager(aManager)
   , mContext(aContext)
   , mCacheId(0)
   , mStreamControl(nullptr)
   , mActivated(false)
 {
   MOZ_ASSERT(mManager);
-  MOZ_ASSERT(mContext);
+  mContext->AddActivity(this);
 }
 
 void
 StreamList::SetStreamControl(CacheStreamControlParent* aStreamControl)
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   MOZ_ASSERT(aStreamControl);
 
@@ -137,24 +137,39 @@ void
 StreamList::CloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   if (mStreamControl) {
     mStreamControl->CloseAll();
   }
 }
 
+void
+StreamList::Cancel()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamList);
+  CloseAll();
+}
+
+bool
+StreamList::MatchesCacheId(CacheId aCacheId) const
+{
+  NS_ASSERT_OWNINGTHREAD(StreamList);
+  return aCacheId == mCacheId;
+}
+
 StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   MOZ_ASSERT(!mStreamControl);
   if (mActivated) {
     mManager->RemoveStreamList(this);
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mManager->ReleaseBodyId(mList[i].mId);
     }
     mManager->ReleaseCacheId(mCacheId);
   }
+  mContext->RemoveActivity(this);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/StreamList.h b/dom/cache/StreamList.h
--- a/dom/cache/StreamList.h
+++ b/dom/cache/StreamList.h
@@ -2,31 +2,31 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_StreamList_h
 #define mozilla_dom_cache_StreamList_h
 
+#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsRefPtr.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheStreamControlParent;
-class Context;
 class Manager;
 
-class StreamList
+class StreamList MOZ_FINAL : public Context::Activity
 {
 public:
   StreamList(Manager* aManager, Context* aContext);
 
   void SetStreamControl(CacheStreamControlParent* aStreamControl);
   void RemoveStreamControl(CacheStreamControlParent* aStreamControl);
 
   void Activate(CacheId aCacheId);
@@ -34,16 +34,20 @@ public:
   void Add(const nsID& aId, nsIInputStream* aStream);
   already_AddRefed<nsIInputStream> Extract(const nsID& aId);
 
   void NoteClosed(const nsID& aId);
   void NoteClosedAll();
   void Close(const nsID& aId);
   void CloseAll();
 
+  // Context::Activity methods
+  virtual void Cancel() MOZ_OVERRIDE;
+  virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE;
+
 private:
   ~StreamList();
   struct Entry
   {
     nsID mId;
     nsCOMPtr<nsIInputStream> mStream;
   };
   nsRefPtr<Manager> mManager;
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -22,23 +22,25 @@ enum Namespace
   CHROME_ONLY_NAMESPACE,
   NUMBER_OF_NAMESPACES
 };
 
 typedef uintptr_t RequestId;
 static const RequestId INVALID_REQUEST_ID = 0;
 
 typedef int32_t CacheId;
+static const CacheId INVALID_CACHEID = -1;
 
 struct QuotaInfo
 {
   QuotaInfo() : mIsApp(false) { }
   nsCOMPtr<nsIFile> mDir;
   nsCString mGroup;
   nsCString mOrigin;
+  nsCString mStorageId;
   bool mIsApp;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -21,16 +21,17 @@ EXPORTS.mozilla.dom.cache += [
     'DBAction.h',
     'DBSchema.h',
     'Feature.h',
     'FetchPut.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
+    'OfflineStorage.h',
     'PrincipalVerifier.h',
     'QuotaClient.h',
     'ReadStream.h',
     'SavedTypes.h',
     'StreamList.h',
     'StreamUtils.h',
     'Types.h',
     'TypeUtils.h',
@@ -51,16 +52,17 @@ UNIFIED_SOURCES += [
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'Feature.cpp',
     'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
+    'OfflineStorage.cpp',
     'PrincipalVerifier.cpp',
     'QuotaClient.cpp',
     'ReadStream.cpp',
     'StreamList.cpp',
     'StreamUtils.cpp',
     'TypeUtils.cpp',
 ]
 
diff --git a/dom/cache/test/mochitest/test_cache.html b/dom/cache/test/mochitest/test_cache.html
--- a/dom/cache/test/mochitest/test_cache.html
+++ b/dom/cache/test/mochitest/test_cache.html
@@ -2,16 +2,17 @@
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 <!DOCTYPE HTML>
 <html>
 <head>
   <title>Validate Interfaces Exposed to Workers</title>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
   <script type="text/javascript" src="worker_driver.js"></script>
+  <script type="text/javascript" src="helpers.js"></script>
 </head>
 <body>
 <iframe id="frame"></iframe>
 <script class="testbody" type="text/javascript">
 SimpleTest.waitForExplicitFinish();
 SpecialPowers.pushPrefEnv({
   "set": [["dom.caches.enabled", true]]
 }, function() {
diff --git a/dom/cache/test/mochitest/worker_driver.js b/dom/cache/test/mochitest/worker_driver.js
--- a/dom/cache/test/mochitest/worker_driver.js
+++ b/dom/cache/test/mochitest/worker_driver.js
@@ -21,24 +21,35 @@
 //
 //  workerTestGetPrefs() - request an array of prefs value from the main thread
 //  workerTestGetPermissions() - request an array permissions from the MT
 //  workerTestGetVersion() - request the current version string from the MT
 //  workerTestGetUserAgent() - request the user agent string from the MT
 //
 // For an example see test_worker_interfaces.html and test_worker_interfaces.js.
 
+function clearStorage(callback) {
+  var principal = SpecialPowers.wrap(document).nodePrincipal;
+  var appId, inBrowser;
+  var nsIPrincipal = SpecialPowers.Components.interfaces.nsIPrincipal;
+  if (principal.appId != nsIPrincipal.UNKNOWN_APP_ID &&
+      principal.appId != nsIPrincipal.NO_APP_ID) {
+    appId = principal.appId;
+    inBrowser = principal.isInBrowserElement;
+  }
+  SpecialPowers.clearStorageForURI(document.documentURI, callback, appId, inBrowser);
+}
+
 function workerTestExec(script) {
   SimpleTest.waitForExplicitFinish();
   var worker = new Worker('worker_wrapper.js');
   worker.onmessage = function(event) {
     if (event.data.type == 'finish') {
       SpecialPowers.forceGC();
-      SimpleTest.finish();
-
+      clearStorage(SimpleTest.finish);
     } else if (event.data.type == 'status') {
       ok(event.data.status, event.data.msg);
 
     } else if (event.data.type == 'getPrefs') {
       var result = {};
       event.data.prefs.forEach(function(pref) {
         result[pref] = SpecialPowers.Services.prefs.getBoolPref(pref);
       });
