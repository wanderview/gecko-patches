# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c989c7b352279925edf138373e4ca3f1540dbd5f
Bug 1334165 Don't allow event dispatch after WebSocket allows worker thread to exit cleanly. r=baku

diff --git a/dom/base/WebSocket.cpp b/dom/base/WebSocket.cpp
--- a/dom/base/WebSocket.cpp
+++ b/dom/base/WebSocket.cpp
@@ -2274,16 +2274,21 @@ WebSocketImpl::RegisterWorkerHolder()
 void
 WebSocketImpl::UnregisterWorkerHolder()
 {
   MOZ_ASSERT(mDisconnectingOrDisconnected);
   MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
   MOZ_ASSERT(mWorkerHolder);
 
+  {
+    MutexAutoLock lock(mMutex);
+    mWorkerShuttingDown = true;
+  }
+
   // The DTOR of this WorkerHolder will release the worker for us.
   mWorkerHolder = nullptr;
 
   mWorkerPrivate = nullptr;
 
 #ifdef DEBUG
   SetHasWorkerHolderRegistered(false);
 #endif
@@ -2828,17 +2833,17 @@ WebSocketImpl::Dispatch(already_AddRefed
     return NS_DispatchToMainThread(event_ref.forget());
   }
 
   MutexAutoLock lock(mMutex);
   if (mWorkerShuttingDown) {
     return NS_OK;
   }
 
-  MOZ_ASSERT(mWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(mWorkerPrivate);
 
 #ifdef DEBUG
   MOZ_ASSERT(HasWorkerHolderRegistered());
 #endif
 
   // If the target is a worker, we have to use a custom WorkerRunnableDispatcher
   // runnable.
   RefPtr<WorkerRunnableDispatcher> event =
