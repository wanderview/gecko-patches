# HG changeset patch
# Parent d76d4f11c98d5ae5c6d9cc3278c734a9b28d08c0
# User Ben Kelly <ben@wanderview.com>
Bug 1173439 P3 Use url query field for database matching and Request creation. r=ehsan

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -956,40 +956,42 @@ QueryCache(mozIStorageConnection* aConn,
   }
 
   nsAutoCString query(
     "SELECT id, COUNT(response_headers.name) AS vary_count "
     "FROM entries "
     "LEFT OUTER JOIN response_headers ON entries.id=response_headers.entry_id "
                                     "AND response_headers.name='vary' "
     "WHERE entries.cache_id=:cache_id "
-      "AND entries."
+      "AND entries.request_url_no_query=:url_no_query "
   );
 
-  nsAutoCString urlToMatch;
-  if (aParams.ignoreSearch()) {
-    urlToMatch = aRequest.urlWithoutQuery();
-    query.AppendLiteral("request_url_no_query");
-  } else {
-    urlToMatch = aRequest.url();
-    query.AppendLiteral("request_url");
+  if (!aParams.ignoreSearch()) {
+    query.AppendLiteral("AND entries.request_url_query=:url_query ");
   }
 
-  query.AppendLiteral("=:url GROUP BY entries.id ORDER BY entries.id;");
+  query.AppendLiteral("GROUP BY entries.id ORDER BY entries.id;");
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64ByName(NS_LITERAL_CSTRING("cache_id"), aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("url"), urlToMatch);
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("url_no_query"),
+                                   aRequest.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  if (!aParams.ignoreSearch()) {
+    rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("url_query"),
+                                     aRequest.urlQuery());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
   bool hasMoreData = false;
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
     // no invalid EntryId, init to least likely real value
     EntryId entryId = INT32_MAX;
     rv = state->GetInt32(0, &entryId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     int32_t varyCount;
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -316,17 +316,21 @@ TypeUtils::ToResponse(const CacheRespons
 }
 
 already_AddRefed<InternalRequest>
 TypeUtils::ToInternalRequest(const CacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
-  internalRequest->SetURL(aIn.url());
+
+  nsAutoCString url(aIn.urlWithoutQuery());
+  url.Append(aIn.urlQuery());
+  internalRequest->SetURL(url);
+
   internalRequest->SetReferrer(aIn.referrer());
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
   internalRequest->SetContentPolicyType(aIn.contentPolicyType());
   DebugOnly<RequestContext> contextAfterSetContentPolicyType = internalRequest->Context();
   internalRequest->SetContext(aIn.context());
   MOZ_ASSERT(contextAfterSetContentPolicyType.value == internalRequest->Context(),
              "The RequestContext and nsContentPolicyType values should not get out of sync");
