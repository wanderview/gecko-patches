# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b28506a0a9f3311d9fcd5a6b13faac2446e7f3d8
Bug 1333573 P4 Make worker ScriptLoader update principal on every redirect. r=baku

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ScriptLoader.h"
 
+#include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsIChannel.h"
 #include "nsIContentPolicy.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIDocShell.h"
 #include "nsIDOMDocument.h"
 #include "nsIHttpChannel.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIInputStreamPump.h"
@@ -111,16 +112,17 @@ ChannelFromScriptURL(nsIPrincipal* princ
                      nsIIOService* ios,
                      nsIScriptSecurityManager* secMan,
                      const nsAString& aScriptURL,
                      bool aIsMainScript,
                      WorkerScriptType aWorkerScriptType,
                      nsContentPolicyType aContentPolicyType,
                      nsLoadFlags aLoadFlags,
                      bool aDefaultURIEncoding,
+                     nsIInterfaceRequestor* aCallbacks,
                      nsIChannel** aChannel)
 {
   AssertIsOnMainThread();
 
   nsresult rv;
   nsCOMPtr<nsIURI> uri;
 
   if (aDefaultURIEncoding) {
@@ -177,32 +179,32 @@ ChannelFromScriptURL(nsIPrincipal* princ
   // situation.
   if (parentDoc && parentDoc->NodePrincipal() == principal) {
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        parentDoc,
                        secFlags,
                        aContentPolicyType,
                        loadGroup,
-                       nullptr, // aCallbacks
+                       aCallbacks,
                        aLoadFlags,
                        ios);
   } else {
     // We must have a loadGroup with a load context for the principal to
     // traverse the channel correctly.
     MOZ_ASSERT(loadGroup);
     MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(loadGroup, principal));
 
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        principal,
                        secFlags,
                        aContentPolicyType,
                        loadGroup,
-                       nullptr, // aCallbacks
+                       aCallbacks,
                        aLoadFlags,
                        ios);
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel)) {
     mozilla::net::ReferrerPolicy referrerPolicy = parentDoc ?
@@ -545,16 +547,18 @@ private:
   uint32_t mIndex;
 };
 
 NS_IMPL_ISUPPORTS(LoaderListener, nsIStreamLoaderObserver, nsIRequestObserver)
 
 class ScriptLoaderHolder;
 
 class ScriptLoaderRunnable final : public nsIRunnable
+                                 , public nsIChannelEventSink
+                                 , public nsIInterfaceRequestor
 {
   friend class ScriptExecutorRunnable;
   friend class ScriptLoaderHolder;
   friend class CachePromiseHandler;
   friend class CacheScriptLoader;
   friend class LoaderListener;
 
   WorkerPrivate* mWorkerPrivate;
@@ -933,16 +937,17 @@ private:
       // Only top level workers' main script use the document charset for the
       // script uri encoding. Otherwise, default encoding (UTF-8) is applied.
       bool useDefaultEncoding = !(!parentWorker && IsMainWorkerScript());
       rv = ChannelFromScriptURL(principal, baseURI, parentDoc, loadGroup, ios,
                                 secMan, loadInfo.mURL, IsMainWorkerScript(),
                                 mWorkerScriptType,
                                 mWorkerPrivate->ContentPolicyType(), loadFlags,
                                 useDefaultEncoding,
+                                IsMainWorkerScript() ? this :  nullptr, // callbacks
                                 getter_AddRefs(channel));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
     }
 
     // We need to know which index we're on in OnStreamComplete so we know
     // where to put the result.
@@ -1132,18 +1137,17 @@ private:
     // worker's primary script.
     if (IsMainWorkerScript()) {
       // Take care of the base URI first.
       mWorkerPrivate->SetBaseURI(finalURI);
 
       // Store the channel info if needed.
       mWorkerPrivate->InitChannelInfo(channel);
 
-      // Now to figure out which principal to give this worker.
-      WorkerPrivate* parent = mWorkerPrivate->GetParent();
+      /*
 
       NS_ASSERTION(mWorkerPrivate->GetPrincipal() || parent,
                    "Must have one of these!");
 
       nsCOMPtr<nsIPrincipal> loadPrincipal = mWorkerPrivate->GetPrincipal() ?
                                              mWorkerPrivate->GetPrincipal() :
                                              parent->GetPrincipal();
 
@@ -1187,16 +1191,17 @@ private:
         }
       }
 
       // The principal can change, but it should still match the original
       // load group's appId and browser element flag.
       MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal));
 
       mWorkerPrivate->SetPrincipal(channelPrincipal, channelLoadGroup);
+      */
 
       // We did inherit CSP in bug 1223647. If we do not already have a CSP, we
       // should get it from the HTTP headers on the worker script.
       if (!mWorkerPrivate->GetCSP() && CSPService::sCSPEnabled) {
         NS_ConvertASCIItoUTF16 cspHeaderValue(tCspHeaderValue);
         NS_ConvertASCIItoUTF16 cspROHeaderValue(tCspROHeaderValue);
 
         nsIPrincipal* principal = mWorkerPrivate->GetPrincipal();
@@ -1234,16 +1239,17 @@ private:
           NS_ENSURE_SUCCESS(rv, rv);
 
 
           if (hasReferrerPolicy) { //FIXME bug 1307366: move RP out of CSP code
             mWorkerPrivate->SetReferrerPolicy(static_cast<net::ReferrerPolicy>(rp));
           }
         }
       }
+      WorkerPrivate* parent = mWorkerPrivate->GetParent();
       if (parent) {
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
       }
     }
 
     NS_ConvertUTF8toUTF16 tRPHeaderValue(tRPHeaderCValue);
     // If there's a Referrer-Policy header, apply it.
@@ -1382,19 +1388,91 @@ private:
       RefPtr<ScriptExecutorRunnable> runnable =
         new ScriptExecutorRunnable(*this, mSyncLoopTarget, IsMainWorkerScript(),
                                    firstIndex, lastIndex);
       if (!runnable->Dispatch()) {
         MOZ_ASSERT(false, "This should never fail!");
       }
     }
   }
+
+  NS_IMETHOD
+  AsyncOnChannelRedirect(nsIChannel *aOldChannel,
+                         nsIChannel *aNewChannel,
+                         uint32_t aFlags,
+                         nsIAsyncVerifyRedirectCallback *aCallback) override
+  {
+    nsCOMPtr<nsIPrincipal> newPrincipal;
+    nsContentUtils::GetSecurityManager()->
+      GetChannelURIPrincipal(aNewChannel, getter_AddRefs(newPrincipal));
+    if (!newPrincipal) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    nsCOMPtr<nsILoadGroup> channelLoadGroup;
+    nsresult rv = aNewChannel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
+    if (NS_FAILED(rv)) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIPrincipal> loadPrincipal = mWorkerPrivate->GetPrincipal();
+
+    // If the load principal is the system principal then the channel
+    // principal must also be the system principal (we do not allow chrome
+    // code to create workers with non-chrome scripts, and if we ever decide
+    // to change this we need to make sure we don't always set
+    // mPrincipalIsSystem to true in WorkerPrivate::GetLoadInfo()). Otherwise
+    // this channel principal must be same origin with the load principal (we
+    // check again here in case redirects changed the location of the script).
+    if (nsContentUtils::IsSystemPrincipal(loadPrincipal)) {
+      if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
+        // See if this is a resource URI. Since JSMs usually come from
+        // resource:// URIs we're currently considering all URIs with the
+        // URI_IS_UI_RESOURCE flag as valid for creating privileged workers.
+        bool isResource;
+        rv = NS_URIChainHasFlags(finalURI,
+                                 nsIProtocolHandler::URI_IS_UI_RESOURCE,
+                                 &isResource);
+        NS_ENSURE_SUCCESS(rv, rv);
+
+        if (isResource) {
+          // Assign the system principal to the resource:// worker only if it
+          // was loaded from code using the system principal.
+          channelPrincipal = loadPrincipal;
+        } else {
+          return NS_ERROR_DOM_BAD_URI;
+        }
+      }
+    }
+
+    // The principal can change, but it should still match the original
+    // load group's appId and browser element flag.
+    MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal));
+
+    mWorkerPrivate->SetPrincipal(newPrincipal, channelLoadGroup);
+
+    aCallback->OnRedirectVerifyCallback(NS_OK);
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  GetInterface(const nsIID& aIID, void **aResult)
+  {
+    if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
+      *aResult = static_cast<nsIChannelEventSink*>(this);
+      NS_ADDREF_THIS();
+      return NS_OK;
+    }
+    return QueryInterface(aIID, aResult);
+  }
 };
 
-NS_IMPL_ISUPPORTS(ScriptLoaderRunnable, nsIRunnable)
+NS_IMPL_ISUPPORTS(ScriptLoaderRunnable, nsIRunnable,
+                                        nsIChannelEventSink,
+                                        nsIInterfaceRequestor)
 
 class MOZ_STACK_CLASS ScriptLoaderHolder final : public WorkerHolder
 {
   // Raw pointer because this holder object follows the mRunnable life-time.
   ScriptLoaderRunnable* mRunnable;
 
 public:
   explicit ScriptLoaderHolder(ScriptLoaderRunnable* aRunnable)
@@ -2161,17 +2239,17 @@ ChannelFromScriptURLMainThread(nsIPrinci
   nsCOMPtr<nsIIOService> ios(do_GetIOService());
 
   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
   NS_ASSERTION(secMan, "This should never be null!");
 
   return ChannelFromScriptURL(aPrincipal, aBaseURI, aParentDoc, aLoadGroup,
                               ios, secMan, aScriptURL, true, WorkerScript,
                               aContentPolicyType, nsIRequest::LOAD_NORMAL,
-                              aDefaultURIEncoding, aChannel);
+                              aDefaultURIEncoding, nullptr, aChannel);
 }
 
 nsresult
 ChannelFromScriptURLWorkerThread(JSContext* aCx,
                                  WorkerPrivate* aParent,
                                  const nsAString& aScriptURL,
                                  nsIChannel** aChannel)
 {
