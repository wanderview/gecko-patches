# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e0595117ff5bda3a63a72ad7b3b8754fec4fb4f0

diff --git a/testing/web-platform/tests/service-workers/service-worker/redirected-response.https.html b/testing/web-platform/tests/service-workers/service-worker/redirected-response.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/redirected-response.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/redirected-response.https.html
@@ -71,16 +71,18 @@ function setup_and_clean() {
 
 
 let host_info = get_host_info();
 const REDIRECT_URL = host_info['HTTPS_ORIGIN'] + base_path() +
                      'resources/redirect.py?Redirect=';
 const TARGET_URL = host_info['HTTPS_ORIGIN'] + base_path() +
                    'resources/simple.txt?';
 const REDIRECT_TO_TARGET_URL = REDIRECT_URL + encodeURIComponent(TARGET_URL);
+const REMOTE_TARGET_URL = host_info['HTTPS_REMOTE_ORIGIN'] + base_path() +
+                         'resources/simple-cors.txt?';
 let frame;
 let cache;
 let setup;
 let worker;
 
 promise_test(t => {
     const SCOPE = 'resources/blank.html?redirected-response';
     const SCRIPT = 'resources/redirect-worker.js';
@@ -294,16 +296,102 @@ promise_test(t => setup_and_clean()
                               fetch_option: {redirect: 'manual'},
                               fetch_method: frame.contentWindow.fetch,
                               expected_type: 'opaqueredirect',
                               expected_redirected: false,
                               expected_intercepted_urls: [url]})
     }),
   'mode: "manual", generated redirect response');
 
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=follow&sw=gen';
+      return redirected_test({url: url,
+                              fetch_option: {redirect: 'follow'},
+                              fetch_method: frame.contentWindow.fetch,
+                              expected_type: 'cors',
+                              expected_redirected: true,
+                              expected_intercepted_urls: [url, REMOTE_TARGET_URL]})
+    }),
+  'mode: "follow", cors generated cross-origin redirect response');
+
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=error&sw=gen';
+      return promise_rejects(
+          t, new TypeError(),
+          frame.contentWindow.fetch(url, {redirect: 'error'}),
+          'The generated redirect response from the service worker should ' +
+          'be treated as an error when the redirect flag of request was' +
+          ' \'error\'.')
+        .then(() => check_intercepted_urls([url]));
+    }),
+  'mode: "error", cors generated cross-origin redirect response');
+
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=follow&sw=gen';
+      return redirected_test({url: url,
+                              fetch_option: {redirect: 'manual'},
+                              fetch_method: frame.contentWindow.fetch,
+                              expected_type: 'opaqueredirect',
+                              expected_redirected: false,
+                              expected_intercepted_urls: [url]})
+    }),
+  'mode: "manual", cors generated cross-origin redirect response');
+
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=follow&sw=gen';
+      return redirected_test({url: url,
+                              fetch_option: {mode: 'no-cors', redirect: 'follow'},
+                              fetch_method: frame.contentWindow.fetch,
+                              expected_type: 'opaque',
+                              expected_redirected: false, // hidden on opaque
+                              expected_intercepted_urls: [url, REMOTE_TARGET_URL]})
+    }),
+  'mode: "follow", no-cors generated cross-origin redirect response');
+
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=error&sw=gen';
+      return promise_rejects(
+          t, new TypeError(),
+          frame.contentWindow.fetch(url, {mode: 'no-cors', redirect: 'error'}),
+          'The generated redirect response from the service worker should ' +
+          'be treated as an error when the redirect flag of request was' +
+          ' \'error\'.')
+        .then(() => check_intercepted_urls([url]));
+    }),
+  'mode: "error", no-cors generated cross-origin redirect response');
+
+promise_test(t => setup_and_clean()
+    .then(() => {
+      const url = host_info['HTTPS_ORIGIN'] + base_path() +
+                  'dummy?url=' + encodeURIComponent(REMOTE_TARGET_URL) +
+                  '&original-redirect-mode=follow&sw=gen';
+      return redirected_test({url: url,
+                              fetch_option: {mode: 'no-cors', redirect: 'manual'},
+                              fetch_method: frame.contentWindow.fetch,
+                              expected_type: 'opaqueredirect',
+                              expected_redirected: false,
+                              expected_intercepted_urls: [url]})
+    }),
+  'mode: "manual", no-cors generated cross-origin redirect response');
+
 // =======================================================
 // Tests for requests that are in-scope of the service worker. The service
 // worker returns a generated redirect response. And the fetch follows the
 // redirection multiple times.
 // =======================================================
 promise_test(t => setup_and_clean()
     .then(() => {
       // The Fetch spec says: "If requestâ€™s redirect count is twenty, return a
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt b/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt
@@ -0,0 +1,1 @@
+a simple text file
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt.headers b/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt.headers
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/simple-cors.txt.headers
@@ -0,0 +1,2 @@
+Content-Type: text/plain
+Access-Control-Allow-Origin: *
