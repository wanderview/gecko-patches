# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  cd89001ead8104eb539eb89849e082ec8e2c417b
Bug 1231211 P10 Move nsDocShell logic into separate ServiceWorkerInterceptController. r=asuth

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -41,16 +41,17 @@
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/HTMLAnchorElement.h"
 #include "mozilla/dom/PerformanceNavigation.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ScriptSettings.h"
+#include "mozilla/dom/ServiceWorkerInterceptController.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/TabGroup.h"
 #include "mozilla/dom/ToJSValue.h"
 
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 
 #include "mozilla/net/ReferrerPolicy.h"
 
@@ -454,16 +455,18 @@ nsDocShell::Init()
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ASSERTION(mLoadGroup, "Something went wrong!");
 
   mContentListener = new nsDSURIContentListener(this);
   rv = mContentListener->Init();
   NS_ENSURE_SUCCESS(rv, rv);
 
+  mInterceptController = new ServiceWorkerInterceptController();
+
   // We want to hold a strong ref to the loadgroup, so it better hold a weak
   // ref to us...  use an InterfaceRequestorProxy to do this.
   nsCOMPtr<nsIInterfaceRequestor> proxy =
     new InterfaceRequestorProxy(static_cast<nsIInterfaceRequestor*>(this));
   mLoadGroup->SetNotificationCallbacks(proxy);
 
   rv = nsDocLoader::AddDocLoaderAsChildOfRoot(this);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -14248,71 +14251,24 @@ nsDocShell::MaybeNotifyKeywordSearchLoad
   }
 #endif
 }
 
 NS_IMETHODIMP
 nsDocShell::ShouldPrepareForIntercept(nsIURI* aURI, nsIChannel* aChannel,
                                       bool* aShouldIntercept)
 {
-  *aShouldIntercept = false;
-
-  nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
-  if (!loadInfo) {
-    return NS_OK;
-  }
-
-  // For subresource requests we base our decision solely on the client's
-  // controller value.  Any settings that would have blocked service worker
-  // access should have been set before the initial navigation created the
-  // window.
-  if (!nsContentUtils::IsNonSubresourceRequest(aChannel)) {
-    const Maybe<ServiceWorkerDescriptor>& controller = loadInfo->GetController();
-    *aShouldIntercept = controller.isSome();
-    return NS_OK;
-  }
-
-  nsCOMPtr<nsIPrincipal> principal =
-    BasePrincipal::CreateCodebasePrincipal(aURI,
-                                           loadInfo->GetOriginAttributes());
-
-  // For navigations, first check to see if we are allowed to control a
-  // window with the given URL.
-  if (!ServiceWorkerAllowedToControlWindow(principal, aURI)) {
-    return NS_OK;
-  }
-
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (!swm) {
-    return NS_OK;
-  }
-
-  // We're allowed to control a window, so check with the ServiceWorkerManager
-  // for a matching service worker.
-  *aShouldIntercept = swm->IsAvailable(principal, aURI);
-  return NS_OK;
+  return mInterceptController->ShouldPrepareForIntercept(aURI, aChannel,
+                                                         aShouldIntercept);
 }
 
 NS_IMETHODIMP
 nsDocShell::ChannelIntercepted(nsIInterceptedChannel* aChannel)
 {
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (!swm) {
-    aChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
-    return NS_OK;
-  }
-
-  ErrorResult error;
-  swm->DispatchFetchEvent(aChannel, error);
-  if (NS_WARN_IF(error.Failed())) {
-    aChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
-    return error.StealNSResult();
-  }
-
-  return NS_OK;
+  return mInterceptController->ChannelIntercepted(aChannel);
 }
 
 bool
 nsDocShell::InFrameSwap()
 {
   RefPtr<nsDocShell> shell = this;
   do {
     if (shell->mInFrameSwap) {
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -906,16 +906,17 @@ private: // data members
   nsCString mOriginalUriString;
   nsWeakPtr mOnePermittedSandboxedNavigator;
   nsWeakPtr mOpener;
   nsTObserverArray<nsWeakPtr> mPrivacyObservers;
   nsTObserverArray<nsWeakPtr> mReflowObservers;
   nsTObserverArray<nsWeakPtr> mScrollObservers;
   mozilla::OriginAttributes mOriginAttributes;
   mozilla::UniquePtr<mozilla::dom::ClientSource> mInitialClientSource;
+  nsCOMPtr<nsINetworkInterceptController> mInterceptController;
   RefPtr<nsDOMNavigationTiming> mTiming;
   RefPtr<nsDSURIContentListener> mContentListener;
   RefPtr<nsGlobalWindowOuter> mScriptGlobal;
   nsCOMPtr<nsIPrincipal> mParentCharsetPrincipal;
   nsCOMPtr<nsILoadURIDelegate> mLoadURIDelegate;
   nsCOMPtr<nsIMutableArray> mRefreshURIList;
   nsCOMPtr<nsIMutableArray> mSavedRefreshURIList;
   nsCOMPtr<nsIDOMStorageManager> mSessionStorageManager;
diff --git a/dom/workers/ServiceWorkerInterceptController.cpp b/dom/workers/ServiceWorkerInterceptController.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInterceptController.cpp
@@ -0,0 +1,76 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerInterceptController.h"
+
+#include "mozilla/BasePrincipal.h"
+#include "nsContentUtils.h"
+#include "nsIChannel.h"
+#include "ServiceWorkerManager.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_ISUPPORTS(ServiceWorkerInterceptController, nsINetworkInterceptController)
+
+NS_IMETHODIMP
+ServiceWorkerInterceptController::ShouldPrepareForIntercept(nsIURI* aURI,
+                                                            nsIChannel* aChannel,
+                                                            bool* aShouldIntercept)
+{
+  *aShouldIntercept = false;
+
+  nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
+  if (!loadInfo) {
+    return NS_OK;
+  }
+
+  // For subresource requests we base our decision solely on the client's
+  // controller value.  Any settings that would have blocked service worker
+  // access should have been set before the initial navigation created the
+  // window.
+  if (!nsContentUtils::IsNonSubresourceRequest(aChannel)) {
+    const Maybe<ServiceWorkerDescriptor>& controller = loadInfo->GetController();
+    *aShouldIntercept = controller.isSome();
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal =
+    BasePrincipal::CreateCodebasePrincipal(aURI,
+                                           loadInfo->GetOriginAttributes());
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    return NS_OK;
+  }
+
+  // We're allowed to control a window, so check with the ServiceWorkerManager
+  // for a matching service worker.
+  *aShouldIntercept = swm->IsAvailable(principal, aURI);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerInterceptController::ChannelIntercepted(nsIInterceptedChannel* aChannel)
+{
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    aChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
+    return NS_OK;
+  }
+
+  ErrorResult error;
+  swm->DispatchFetchEvent(aChannel, error);
+  if (NS_WARN_IF(error.Failed())) {
+    aChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
+    return error.StealNSResult();
+  }
+
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/ServiceWorkerInterceptController.h b/dom/workers/ServiceWorkerInterceptController.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInterceptController.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_serviceworkerinterceptcontroller_h
+#define mozilla_dom_serviceworkerinterceptcontroller_h
+
+#include "nsINetworkInterceptController.h"
+
+namespace mozilla {
+namespace dom {
+
+class ServiceWorkerInterceptController final : public nsINetworkInterceptController
+{
+  ~ServiceWorkerInterceptController() = default;
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSINETWORKINTERCEPTCONTROLLER
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_serviceworkerinterceptcontroller_h
+
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -9,16 +9,17 @@ with Files("**"):
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
     'FileReaderSync.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
     'ServiceWorkerDescriptor.h',
     'ServiceWorkerEvents.h',
+    'ServiceWorkerInterceptController.h',
     'ServiceWorkerIPCUtils.h',
     'ServiceWorkerRegistrar.h',
     'ServiceWorkerRegistration.h',
     'WorkerLocation.h',
     'WorkerNavigator.h',
     'WorkerPrivate.h',
     'WorkerRunnable.h',
     'WorkerScope.h',
@@ -55,16 +56,17 @@ UNIFIED_SOURCES += [
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
+    'ServiceWorkerInterceptController.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerPrivate.cpp',
     'ServiceWorkerRegisterJob.cpp',
