# HG changeset patch
# User Nikhil Marathe <nsm.nikhil@gmail.com>
# Date 1418201519 28800
#      Wed Dec 10 00:51:59 2014 -0800
# Node ID 7c603aead6df12aadc7651904aa0b085ad31ae22
# Parent 021b09e92d30c8e1c41b832638e9ca60d4daae45
Bug 1039846 - Patch 5: FetchDriver basic HTTP fetch support

This patch has the following big pieces:
HTTP support in FetchDriver, which requires the principal of the caller to be passed.
Managing worker lifetime when a fetch() call is in progress.
Managing worker lifetime when a Response body is being read.
Using nsIPipe to link network streams to Request/Response body streams.
Using nsIInputStreamPump to convert Request/Response body streams into respective types.

Folded:
Bug 1039846 - Fetch API: Use a pipe to immediately start writing HTTP body data to InternalResponse.
Bug 1039846 - Assert bodystream can be set only once
Bug 1039846 - Add feature when handling fetch responses on workers
Bug 1039846 - Try to retarget http fetch delivery off main thread.
Bug 1039846 - Safely consume body using nsIInputStreamPump on workers and main thread.
Bug 1039846 - Retarget body reading to stream transport service.

diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -2,85 +2,149 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Fetch.h"
 
 #include "nsIDocument.h"
 #include "nsIGlobalObject.h"
-#include "nsIStringStream.h"
+#include "nsIInputStreamPump.h"
+#include "nsIStreamLoader.h"
+#include "nsIThreadRetargetableRequest.h"
 #include "nsIUnicodeDecoder.h"
 #include "nsIUnicodeEncoder.h"
 
 #include "nsDOMString.h"
 #include "nsNetUtil.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "mozilla/dom/FetchDriver.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
-#include "mozilla/dom/PromiseWorkerProxy.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/URLSearchParams.h"
-#include "mozilla/dom/WorkerScope.h"
-#include "mozilla/dom/workers/Workers.h"
 
 #include "InternalResponse.h"
+
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "WorkerScope.h"
+#include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 
 using namespace workers;
 
-class WorkerFetchResolver MOZ_FINAL : public FetchDriverObserver
+class WorkerFetchResolver MOZ_FINAL : public FetchDriverObserver,
+                                      public WorkerFeature
 {
+  friend class MainThreadFetchRunnable;
+  friend class WorkerFetchResponseEndRunnable;
   friend class WorkerFetchResponseRunnable;
-  friend class ResolveFetchWithBodyRunnable;
 
-  // This promise proxy is for the Promise returned by a call to fetch() that
-  // is resolved with a Response instance.
-  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
-  // Passed from main thread to worker thread after being initialized (except
-  // for the body.
-  nsRefPtr<InternalResponse> mInternalResponse;
+  workers::WorkerPrivate* mWorkerPrivate;
+
+  Mutex mCleanUpLock;
+  bool mCleanedUp;
+  // The following are initialized and used exclusively on the worker thread.
+  nsRefPtr<Promise> mFetchPromise;
+  nsRefPtr<Response> mResponse;
 public:
 
-  WorkerFetchResolver(workers::WorkerPrivate* aWorkerPrivate, Promise* aPromise);
+  WorkerFetchResolver(workers::WorkerPrivate* aWorkerPrivate, Promise* aPromise)
+    : mWorkerPrivate(aWorkerPrivate)
+    , mCleanUpLock("WorkerFetchResolver")
+    , mCleanedUp(false)
+    , mFetchPromise(aPromise)
+  {
+  }
 
   void
   OnResponseAvailable(InternalResponse* aResponse) MOZ_OVERRIDE;
 
+  void
+  OnResponseEnd() MOZ_OVERRIDE;
+
+  bool
+  Notify(JSContext* aCx, Status aStatus) MOZ_OVERRIDE
+  {
+    if (aStatus > Running) {
+      CleanUp(aCx);
+    }
+    return true;
+  }
+
+  void
+  CleanUp(JSContext* aCx)
+  {
+    MutexAutoLock lock(mCleanUpLock);
+
+    if (mCleanedUp) {
+      return;
+    }
+
+    MOZ_ASSERT(mWorkerPrivate);
+    mWorkerPrivate->AssertIsOnWorkerThread();
+    MOZ_ASSERT(mWorkerPrivate->GetJSContext() == aCx);
+
+    mWorkerPrivate->RemoveFeature(aCx, this);
+    CleanUpUnchecked();
+  }
+
+  void
+  CleanUpUnchecked()
+  {
+    mResponse = nullptr;
+    if (mFetchPromise) {
+      mFetchPromise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+      mFetchPromise = nullptr;
+    }
+    mCleanedUp = true;
+  }
+
   workers::WorkerPrivate*
-  GetWorkerPrivate() { return mPromiseProxy->GetWorkerPrivate(); }
+  GetWorkerPrivate() const
+  {
+    // It's ok to race on |mCleanedUp|, because it will never cause us to fire
+    // the assertion when we should not.
+    MOZ_ASSERT(!mCleanedUp);
+    return mWorkerPrivate;
+  }
 
 private:
-  ~WorkerFetchResolver();
+  ~WorkerFetchResolver()
+  {
+    MOZ_ASSERT(mCleanedUp);
+    MOZ_ASSERT(!mFetchPromise);
+  }
 };
 
 class MainThreadFetchResolver MOZ_FINAL : public FetchDriverObserver
 {
   nsRefPtr<Promise> mPromise;
-  nsRefPtr<InternalResponse> mInternalResponse;
+  nsRefPtr<Response> mResponse;
 
   NS_DECL_OWNINGTHREAD
 public:
   explicit MainThreadFetchResolver(Promise* aPromise);
 
   void
   OnResponseAvailable(InternalResponse* aResponse) MOZ_OVERRIDE;
 
+  void
+  OnResponseEnd() MOZ_OVERRIDE;
+
 private:
   ~MainThreadFetchResolver();
 };
 
 class MainThreadFetchRunnable : public nsRunnable
 {
   nsRefPtr<WorkerFetchResolver> mResolver;
   nsRefPtr<InternalRequest> mRequest;
@@ -89,29 +153,37 @@ public:
   MainThreadFetchRunnable(WorkerPrivate* aWorkerPrivate,
                           Promise* aPromise,
                           InternalRequest* aRequest)
     : mResolver(new WorkerFetchResolver(aWorkerPrivate, aPromise))
     , mRequest(aRequest)
   {
     MOZ_ASSERT(aWorkerPrivate);
     aWorkerPrivate->AssertIsOnWorkerThread();
+    if (!aWorkerPrivate->AddFeature(aWorkerPrivate->GetJSContext(), mResolver)) {
+      NS_WARNING("Could not add WorkerFetchResolver feature to worker");
+      mResolver->CleanUpUnchecked();
+      mResolver = nullptr;
+    }
   }
 
   NS_IMETHODIMP
   Run()
   {
     AssertIsOnMainThread();
-    nsRefPtr<FetchDriver> fetch = new FetchDriver(mRequest);
+    // AddFeature() call failed, don't bother running.
+    if (!mResolver) {
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIPrincipal> principal = mResolver->GetWorkerPrivate()->GetPrincipal();
+    nsRefPtr<FetchDriver> fetch = new FetchDriver(mRequest, principal);
     nsresult rv = fetch->Fetch(mResolver);
     // Right now we only support async fetch, which should never directly fail.
     MOZ_ASSERT(NS_SUCCEEDED(rv));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return rv;
-    }
     return NS_OK;
   }
 };
 
 already_AddRefed<Promise>
 FetchRequest(nsIGlobalObject* aGlobal, const RequestOrUSVString& aInput,
              const RequestInit& aInit, ErrorResult& aRv)
 {
@@ -138,18 +210,30 @@ FetchRequest(nsIGlobalObject* aGlobal, c
     aRv = GetRequestReferrer(aGlobal, r, ref);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
     r->SetReferrer(ref);
   }
 
   if (NS_IsMainThread()) {
+    nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal);
+    if (!window) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
+    if (!doc) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
     nsRefPtr<MainThreadFetchResolver> resolver = new MainThreadFetchResolver(p);
-    nsRefPtr<FetchDriver> fetch = new FetchDriver(r);
+    nsRefPtr<FetchDriver> fetch = new FetchDriver(r, doc->NodePrincipal());
     aRv = fetch->Fetch(resolver);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   } else {
     WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(worker);
     nsRefPtr<MainThreadFetchRunnable> run = new MainThreadFetchRunnable(worker, p, r);
@@ -166,75 +250,116 @@ MainThreadFetchResolver::MainThreadFetch
 {
 }
 
 void
 MainThreadFetchResolver::OnResponseAvailable(InternalResponse* aResponse)
 {
   NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
   AssertIsOnMainThread();
-  mInternalResponse = aResponse;
 
   nsCOMPtr<nsIGlobalObject> go = mPromise->GetParentObject();
+  mResponse = new Response(go, aResponse);
+  mPromise->MaybeResolve(mResponse);
+}
 
-  nsRefPtr<Response> response = new Response(go, aResponse);
-  mPromise->MaybeResolve(response);
+void
+MainThreadFetchResolver::OnResponseEnd()
+{
+  NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver)
+  AssertIsOnMainThread();
+  MOZ_ASSERT(mResponse);
 }
 
 MainThreadFetchResolver::~MainThreadFetchResolver()
 {
   NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
 }
 
 class WorkerFetchResponseRunnable : public WorkerRunnable
 {
   nsRefPtr<WorkerFetchResolver> mResolver;
+  // Passed from main thread to worker thread after being initialized.
+  nsRefPtr<InternalResponse> mInternalResponse;
 public:
-  explicit WorkerFetchResponseRunnable(WorkerFetchResolver* aResolver)
+  WorkerFetchResponseRunnable(WorkerFetchResolver* aResolver, InternalResponse* aResponse)
+    : WorkerRunnable(aResolver->GetWorkerPrivate(), WorkerThreadModifyBusyCount)
+    , mResolver(aResolver)
+    , mInternalResponse(aResponse)
+  {
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->AssertIsOnWorkerThread();
+    MOZ_ASSERT(aWorkerPrivate == mResolver->GetWorkerPrivate());
+
+    nsRefPtr<nsIGlobalObject> global = aWorkerPrivate->GlobalScope();
+    mResolver->mResponse = new Response(global, mInternalResponse);
+
+    nsRefPtr<Promise> promise = mResolver->mFetchPromise.forget();
+    promise->MaybeResolve(mResolver->mResponse);
+
+    return true;
+  }
+};
+
+class WorkerFetchResponseEndRunnable : public WorkerRunnable
+{
+  nsRefPtr<WorkerFetchResolver> mResolver;
+public:
+  explicit WorkerFetchResponseEndRunnable(WorkerFetchResolver* aResolver)
     : WorkerRunnable(aResolver->GetWorkerPrivate(), WorkerThreadModifyBusyCount)
     , mResolver(aResolver)
   {
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aWorkerPrivate);
     aWorkerPrivate->AssertIsOnWorkerThread();
     MOZ_ASSERT(aWorkerPrivate == mResolver->GetWorkerPrivate());
+    MOZ_ASSERT(mResolver->mResponse);
 
-    nsRefPtr<nsIGlobalObject> global = aWorkerPrivate->GlobalScope();
-    nsRefPtr<Response> response = new Response(global, mResolver->mInternalResponse);
-
-    nsRefPtr<Promise> promise = mResolver->mPromiseProxy->GetWorkerPromise();
-    MOZ_ASSERT(promise);
-    promise->MaybeResolve(response);
-
-    mResolver->mPromiseProxy->CleanUp(aCx);
+    mResolver->CleanUp(aCx);
     return true;
   }
 };
 
-WorkerFetchResolver::WorkerFetchResolver(WorkerPrivate* aWorkerPrivate, Promise* aPromise)
-{
-  mPromiseProxy = PromiseWorkerProxy::Create(aWorkerPrivate, aPromise);
-}
-
-WorkerFetchResolver::~WorkerFetchResolver()
-{
-}
-
 void
 WorkerFetchResolver::OnResponseAvailable(InternalResponse* aResponse)
 {
   AssertIsOnMainThread();
-  mInternalResponse = aResponse;
+
+  MutexAutoLock lock(mCleanUpLock);
+  if (mCleanedUp) {
+    return;
+  }
 
   nsRefPtr<WorkerFetchResponseRunnable> r =
-    new WorkerFetchResponseRunnable(this);
+    new WorkerFetchResponseRunnable(this, aResponse);
+
+  AutoSafeJSContext cx;
+  r->Dispatch(cx);
+}
+
+void
+WorkerFetchResolver::OnResponseEnd()
+{
+  AssertIsOnMainThread();
+  MutexAutoLock lock(mCleanUpLock);
+  if (mCleanedUp) {
+    return;
+  }
+
+  nsRefPtr<WorkerFetchResponseEndRunnable> r =
+    new WorkerFetchResponseEndRunnable(this);
 
   AutoSafeJSContext cx;
   if (!r->Dispatch(cx)) {
     NS_WARNING("Could not dispatch fetch resolve");
   }
 }
 
 // Empty string for no-referrer. FIXME(nsm): Does returning empty string
@@ -304,26 +429,26 @@ ExtractFromBlob(const File& aFile, nsIIn
                 nsCString& aContentType)
 {
   nsRefPtr<FileImpl> impl = aFile.Impl();
   nsresult rv = impl->GetInternalStream(aStream);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  nsString type;
+  nsAutoString type;
   impl->GetType(type);
   aContentType = NS_ConvertUTF16toUTF8(type);
   return NS_OK;
 }
 
 nsresult
 ExtractFromUSVString(const nsString& aStr,
-                             nsIInputStream** aStream,
-                             nsCString& aContentType)
+                     nsIInputStream** aStream,
+                     nsCString& aContentType)
 {
   nsCOMPtr<nsIUnicodeEncoder> encoder = EncodingUtils::EncoderForEncoding("UTF-8");
   if (!encoder) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   int32_t destBufferLen;
   nsresult rv = encoder->GetMaxLength(aStr.get(), aStr.Length(), &destBufferLen);
@@ -357,17 +482,17 @@ ExtractFromURLSearchParams(const URLSear
                            nsIInputStream** aStream,
                            nsCString& aContentType)
 {
   nsAutoString serialized;
   aParams.Stringify(serialized);
   aContentType = NS_LITERAL_CSTRING("application/x-www-form-urlencoded;charset=UTF-8");
   return NS_NewStringInputStream(aStream, serialized);
 }
-}
+} // anonymous namespace
 
 nsresult
 ExtractByteStreamFromBody(const OwningArrayBufferOrArrayBufferViewOrBlobOrUSVStringOrURLSearchParams& aBodyInit,
                           nsIInputStream** aStream,
                           nsCString& aContentType)
 {
   MOZ_ASSERT(aStream);
 
@@ -418,167 +543,623 @@ ExtractByteStreamFromBody(const ArrayBuf
     return ExtractFromURLSearchParams(params, aStream, aContentType);
   }
 
   NS_NOTREACHED("Should never reach here");
   return NS_ERROR_FAILURE;
 }
 
 namespace {
+class StreamDecoder MOZ_FINAL
+{
+  nsCOMPtr<nsIUnicodeDecoder> mDecoder;
+  nsString mDecoded;
+
+public:
+  StreamDecoder()
+    : mDecoder(EncodingUtils::DecoderForEncoding("UTF-8"))
+  {
+    MOZ_ASSERT(mDecoder);
+  }
+
+  nsresult
+  AppendText(const char* aSrcBuffer, uint32_t aSrcBufferLen)
+  {
+    int32_t destBufferLen;
+    nsresult rv =
+      mDecoder->GetMaxLength(aSrcBuffer, aSrcBufferLen, &destBufferLen);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    if (!mDecoded.SetCapacity(mDecoded.Length() + destBufferLen, fallible_t())) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    char16_t* destBuffer = mDecoded.BeginWriting() + mDecoded.Length();
+    int32_t totalChars = mDecoded.Length();
+
+    int32_t srcLen = (int32_t) aSrcBufferLen;
+    int32_t outLen = destBufferLen;
+    rv = mDecoder->Convert(aSrcBuffer, &srcLen, destBuffer, &outLen);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+    totalChars += outLen;
+    mDecoded.SetLength(totalChars);
+
+    return NS_OK;
+  }
+
+  nsString&
+  GetText()
+  {
+    return mDecoded;
+  }
+};
+
+/*
+ * Called on successfully reading the complete stream.
+ */
+template <class Derived>
+class ContinueConsumeBodyRunnable MOZ_FINAL : public WorkerRunnable
+{
+  // This has been addrefed before this runnable is dispatched,
+  // released in WorkerRun().
+  FetchBody<Derived>* mFetchBody;
+  nsresult mStatus;
+  uint32_t mLength;
+  uint8_t* mResult;
+
+public:
+  ContinueConsumeBodyRunnable(FetchBody<Derived>* aFetchBody, nsresult aStatus,
+                              uint32_t aLength, uint8_t* aResult)
+    : WorkerRunnable(aFetchBody->mWorkerPrivate, WorkerThreadModifyBusyCount)
+    , mFetchBody(aFetchBody)
+    , mStatus(aStatus)
+    , mLength(aLength)
+    , mResult(aResult)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) MOZ_OVERRIDE
+  {
+    mFetchBody->ContinueConsumeBody(mStatus, mLength, mResult);
+    return true;
+  }
+};
+
+// OnStreamComplete always adopts the buffer, utility class to release it in
+// a couple of places.
+class MOZ_STACK_CLASS AutoFreeBuffer MOZ_FINAL {
+  uint8_t* mBuffer;
+
+public:
+  AutoFreeBuffer(uint8_t* aBuffer)
+    : mBuffer(aBuffer)
+  {}
+
+  ~AutoFreeBuffer()
+  {
+    moz_free(mBuffer);
+  }
+
+  void
+  Reset()
+  {
+    mBuffer= nullptr;
+  }
+};
+
+template <class Derived>
+class FailConsumeBodyWorkerRunnable : public MainThreadWorkerControlRunnable
+{
+  FetchBody<Derived>* mBody;
+public:
+  explicit FailConsumeBodyWorkerRunnable(FetchBody<Derived>* aBody)
+    : MainThreadWorkerControlRunnable(aBody->mWorkerPrivate)
+    , mBody(aBody)
+  {
+    AssertIsOnMainThread();
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) MOZ_OVERRIDE
+  {
+    mBody->ContinueConsumeBody(NS_ERROR_FAILURE, 0, nullptr);
+    return true;
+  }
+};
+
+/*
+ * In case of failure to create a stream pump or dispatch stream completion to
+ * worker, ensure we cleanup properly. Thread agnostic.
+ */
+template <class Derived>
+class MOZ_STACK_CLASS AutoFailConsumeBody MOZ_FINAL
+{
+  FetchBody<Derived>* mBody;
+public:
+  explicit AutoFailConsumeBody(FetchBody<Derived>* aBody)
+    : mBody(aBody)
+  { }
+
+  ~AutoFailConsumeBody()
+  {
+    AssertIsOnMainThread();
+    if (mBody) {
+      if (mBody->mWorkerPrivate) {
+        nsRefPtr<FailConsumeBodyWorkerRunnable<Derived>> r =
+          new FailConsumeBodyWorkerRunnable<Derived>(mBody);
+        AutoSafeJSContext cx;
+        if (!r->Dispatch(cx)) {
+          MOZ_CRASH("We are going to leak");
+        }
+      } else {
+        mBody->ContinueConsumeBody(NS_ERROR_FAILURE, 0, nullptr);
+      }
+    }
+  }
+
+  void
+  DontFail()
+  {
+    mBody = nullptr;
+  }
+};
+
+template <class Derived>
+class ConsumeBodyDoneObserver : public nsIStreamLoaderObserver
+{
+  FetchBody<Derived>* mFetchBody;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  ConsumeBodyDoneObserver(FetchBody<Derived>* aFetchBody)
+    : mFetchBody(aFetchBody)
+  { }
+
+  NS_IMETHOD
+  OnStreamComplete(nsIStreamLoader* aLoader,
+                   nsISupports* aCtxt,
+                   nsresult aStatus,
+                   uint32_t aResultLength,
+                   const uint8_t* aResult)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    // If the binding requested cancel, we don't need to call
+    // ContinueConsumeBody, since that is the originator.
+    if (aStatus == NS_BINDING_ABORTED) {
+      return NS_OK;
+    }
+
+    uint8_t* nonconstResult = const_cast<uint8_t*>(aResult);
+    if (mFetchBody->mWorkerPrivate) {
+      // This way if the runnable dispatch fails, the body is still released.
+      AutoFailConsumeBody<Derived> autoFail(mFetchBody);
+      nsRefPtr<ContinueConsumeBodyRunnable<Derived>> r =
+        new ContinueConsumeBodyRunnable<Derived>(mFetchBody,
+                                        aStatus,
+                                        aResultLength,
+                                        nonconstResult);
+      AutoSafeJSContext cx;
+      if (r->Dispatch(cx)) {
+        autoFail.DontFail();
+      } else {
+        NS_WARNING("Could not dispatch ConsumeBodyRunnable");
+        // Return failure so that aResult is freed.
+        return NS_ERROR_FAILURE;
+      }
+    } else {
+      mFetchBody->ContinueConsumeBody(aStatus, aResultLength, nonconstResult);
+    }
+
+    // FetchBody is responsible for data.
+    return NS_SUCCESS_ADOPTED_DATA;
+  }
+
+private:
+  virtual ~ConsumeBodyDoneObserver()
+  { }
+};
+
+template <class Derived>
+NS_IMPL_ADDREF(ConsumeBodyDoneObserver<Derived>)
+template <class Derived>
+NS_IMPL_RELEASE(ConsumeBodyDoneObserver<Derived>)
+template <class Derived>
+NS_INTERFACE_MAP_BEGIN(ConsumeBodyDoneObserver<Derived>)
+  NS_INTERFACE_MAP_ENTRY(nsIStreamLoaderObserver)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStreamLoaderObserver)
+NS_INTERFACE_MAP_END
+
+template <class Derived>
+class BeginConsumeBodyRunnable MOZ_FINAL : public nsRunnable
+{
+  FetchBody<Derived>* mFetchBody;
+public:
+  BeginConsumeBodyRunnable(FetchBody<Derived>* aBody)
+    : mFetchBody(aBody)
+  { }
+
+  NS_IMETHOD
+  Run() MOZ_OVERRIDE
+  {
+    mFetchBody->BeginConsumeBodyMainThread();
+    return NS_OK;
+  }
+};
+
+template <class Derived>
+class CancelPumpRunnable MOZ_FINAL : public WorkerMainThreadRunnable
+{
+  FetchBody<Derived>* mBody;
+public:
+  CancelPumpRunnable(FetchBody<Derived>* aBody)
+    : WorkerMainThreadRunnable(aBody->mWorkerPrivate)
+    , mBody(aBody)
+  { }
+
+  bool
+  MainThreadRun() MOZ_OVERRIDE
+  {
+    mBody->CancelPump();
+    return true;
+  }
+};
+} // anonymous namespace
+
+template <class Derived>
+class FetchBodyFeature MOZ_FINAL : public workers::WorkerFeature
+{
+  // This is addrefed before the feature is created, and is released in ContinueConsumeBody()
+  // so we can hold a rawptr.
+  FetchBody<Derived>* mBody;
+
+public:
+  FetchBodyFeature(FetchBody<Derived>* aBody)
+    : mBody(aBody)
+  { }
+
+  ~FetchBodyFeature()
+  { }
+
+  bool Notify(JSContext* aCx, workers::Status aStatus) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aStatus > workers::Running);
+    mBody->ContinueConsumeBody(NS_BINDING_ABORTED, 0, nullptr);
+    return true;
+  }
+};
+
+template <class Derived>
+FetchBody<Derived>::FetchBody()
+  : mFeature(nullptr)
+  , mBodyUsed(false)
+  , mReadDone(false)
+{
+  if (!NS_IsMainThread()) {
+    mWorkerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(mWorkerPrivate);
+  } else {
+    mWorkerPrivate = nullptr;
+  }
+}
+
+// Returns true if addref succeeded.
+// Always succeeds on main thread.
+// May fail on worker if RegisterFeature() fails. In that case, it will release
+// the object before returning false.
+template <class Derived>
+bool
+FetchBody<Derived>::AddRefObject()
+{
+  AssertIsOnTargetThread();
+  DerivedClass()->AddRef();
+
+  if (mWorkerPrivate && !mFeature) {
+    if (!RegisterFeature()) {
+      ReleaseObject();
+      return false;
+    }
+  }
+  return true;
+}
+
+template <class Derived>
+void
+FetchBody<Derived>::ReleaseObject()
+{
+  AssertIsOnTargetThread();
+
+  if (mWorkerPrivate && mFeature) {
+    UnregisterFeature();
+  }
+
+  DerivedClass()->Release();
+}
+
+template <class Derived>
+bool
+FetchBody<Derived>::RegisterFeature()
+{
+  MOZ_ASSERT(mWorkerPrivate);
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(!mFeature);
+  mFeature = new FetchBodyFeature<Derived>(this);
+
+  if (!mWorkerPrivate->AddFeature(mWorkerPrivate->GetJSContext(), mFeature)) {
+    NS_WARNING("Failed to add feature");
+    mFeature = nullptr;
+    return false;
+  }
+
+  return true;
+}
+
+template <class Derived>
+void
+FetchBody<Derived>::UnregisterFeature()
+{
+  MOZ_ASSERT(mWorkerPrivate);
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(mFeature);
+
+  mWorkerPrivate->RemoveFeature(mWorkerPrivate->GetJSContext(), mFeature);
+  mFeature = nullptr;
+}
+
+template <class Derived>
+void
+FetchBody<Derived>::CancelPump()
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(mConsumeBodyPump);
+  mConsumeBodyPump->Cancel(NS_BINDING_ABORTED);
+}
+
+// Return value is used by ConsumeBody to bubble the error code up to WebIDL so
+// mConsumePromise doesn't have to be rejected on early exit.
+template <class Derived>
 nsresult
-DecodeUTF8(const nsCString& aBuffer, nsString& aDecoded)
+FetchBody<Derived>::BeginConsumeBody()
 {
-  nsCOMPtr<nsIUnicodeDecoder> decoder =
-    EncodingUtils::DecoderForEncoding("UTF-8");
-  if (!decoder) {
+  AssertIsOnTargetThread();
+  MOZ_ASSERT(!mFeature);
+  MOZ_ASSERT(mConsumePromise);
+
+  // The FetchBody is not thread-safe refcounted. We addref it here and release
+  // it once the stream read is finished.
+  if (!AddRefObject()) {
     return NS_ERROR_FAILURE;
   }
 
-  int32_t destBufferLen;
-  nsresult rv =
-    decoder->GetMaxLength(aBuffer.get(), aBuffer.Length(), &destBufferLen);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+  if (NS_IsMainThread()) {
+    BeginConsumeBodyMainThread();
+    return NS_OK;
+  } else {
+    nsRefPtr<BeginConsumeBodyRunnable<Derived>> r = new BeginConsumeBodyRunnable<Derived>(this);
+    nsresult rv = NS_DispatchToMainThread(r);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      ReleaseObject();
+      return rv;
+    }
+    return NS_OK;
+  }
+}
+
+/*
+ * BeginConsumeBodyMainThread() will automatically reject the consume promise
+ * and clean up on any failures, so there is no need for callers to do so,
+ * reflected in a lack of error return code.
+ */
+template <class Derived>
+void
+FetchBody<Derived>::BeginConsumeBodyMainThread()
+{
+  AssertIsOnMainThread();
+  AutoFailConsumeBody<Derived> autoReject(DerivedClass());
+  nsresult rv;
+  nsCOMPtr<nsIInputStream> stream;
+  DerivedClass()->GetBody(getter_AddRefs(stream));
+  if (!stream) {
+    NS_WARNING("Could not get stream");
+    return;
   }
 
-  if (!aDecoded.SetCapacity(destBufferLen, fallible_t())) {
-    return NS_ERROR_OUT_OF_MEMORY;
+  nsCOMPtr<nsIInputStreamPump> pump;
+  rv = NS_NewInputStreamPump(getter_AddRefs(pump),
+                             stream);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
   }
 
-  char16_t* destBuffer = aDecoded.BeginWriting();
-  int32_t srcLen = (int32_t) aBuffer.Length();
-  int32_t outLen = destBufferLen;
-  rv = decoder->Convert(aBuffer.get(), &srcLen, destBuffer, &outLen);
+  nsRefPtr<ConsumeBodyDoneObserver<Derived>> p = new ConsumeBodyDoneObserver<Derived>(this);
+  nsCOMPtr<nsIStreamLoader> loader;
+  rv = NS_NewStreamLoader(getter_AddRefs(loader), p);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
+    return;
   }
 
-  MOZ_ASSERT(outLen <= destBufferLen);
-  aDecoded.SetLength(outLen);
-  return NS_OK;
+  rv = pump->AsyncRead(loader, nullptr);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  // Now that everything succeeded, we can assign the pump to a pointer that
+  // stays alive for the lifetime of the FetchBody.
+  mConsumeBodyPump = new nsMainThreadPtrHolder<nsIInputStreamPump>(pump);
+  // It is ok for retargeting to fail and reads to happen on the main thread.
+  autoReject.DontFail();
+
+  // Try to retarget, otherwise fall back to main thread.
+  nsCOMPtr<nsIThreadRetargetableRequest> rr = do_QueryInterface(pump);
+  if (rr) {
+    nsCOMPtr<nsIEventTarget> sts = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID);
+    rv = rr->RetargetDeliveryTo(sts);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      NS_WARNING("Retargeting failed");
+    }
+  }
 }
+
+template <class Derived>
+void
+FetchBody<Derived>::ContinueConsumeBody(nsresult aStatus, uint32_t aResultLength, uint8_t* aResult)
+{
+  AssertIsOnTargetThread();
+  // Just a precaution to ensure ContinueConsumeBody is not called out of
+  // sync with a body read.
+  MOZ_ASSERT(mBodyUsed);
+  MOZ_ASSERT(!mReadDone);
+  MOZ_ASSERT_IF(mWorkerPrivate, mFeature);
+  mReadDone = true;
+
+  AutoFreeBuffer autoFree(aResult);
+
+  MOZ_ASSERT(mConsumePromise);
+  nsRefPtr<Promise> localPromise = mConsumePromise.forget();
+
+  nsRefPtr<Derived> kungfuDeathGrip = DerivedClass();
+  ReleaseObject();
+
+  if (NS_WARN_IF(NS_FAILED(aStatus))) {
+    localPromise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+
+    // If binding aborted, cancel the pump. We can't assert mConsumeBodyPump.
+    // In the (admittedly rare) situation that BeginConsumeBodyMainThread()
+    // context switches out, and the worker thread gets canceled before the
+    // pump is setup, mConsumeBodyPump will be null.
+    // We've to use the !! form since non-main thread pointer access on
+    // a nsMainThreadPtrHandle is not permitted.
+    if (aStatus == NS_BINDING_ABORTED && !!mConsumeBodyPump) {
+      if (NS_IsMainThread()) {
+        CancelPump();
+      } else {
+        MOZ_ASSERT(mWorkerPrivate);
+        // In case of worker thread, we block the worker while the request is
+        // canceled on the main thread. This ensures that OnStreamComplete has
+        // a valid FetchBody around to call CancelPump and we don't release the
+        // FetchBody on the main thread.
+        nsRefPtr<CancelPumpRunnable<Derived>> r =
+          new CancelPumpRunnable<Derived>(this);
+        if (!r->Dispatch(mWorkerPrivate->GetJSContext())) {
+          NS_WARNING("Could not dispatch CancelPumpRunnable. Nothing we can do here");
+        }
+      }
+    }
+  }
+
+  // Release the pump and then early exit if there was an error.
+  // Uses NS_ProxyRelease internally, so this is safe.
+  mConsumeBodyPump = nullptr;
+
+  // Don't warn here since we warned above.
+  if (NS_FAILED(aStatus)) {
+    return;
+  }
+
+  // Finish successfully consuming body according to type.
+  MOZ_ASSERT(aResult);
+
+  AutoJSAPI api;
+  api.Init(DerivedClass()->GetParentObject());
+  JSContext* cx = api.cx();
+
+  switch (mConsumeType) {
+    case CONSUME_ARRAYBUFFER: {
+      JS::Rooted<JSObject*> arrayBuffer(cx);
+      arrayBuffer = JS_NewArrayBufferWithContents(cx, aResultLength, reinterpret_cast<void *>(aResult));
+      if (!arrayBuffer) {
+        JS_ClearPendingException(cx);
+        localPromise->MaybeReject(NS_ERROR_DOM_UNKNOWN_ERR);
+        NS_WARNING("OUT OF MEMORY");
+        return;
+      }
+
+      JS::Rooted<JS::Value> val(cx);
+      val.setObjectOrNull(arrayBuffer);
+      localPromise->MaybeResolve(cx, val);
+      // ArrayBuffer takes over ownership.
+      autoFree.Reset();
+      return;
+    }
+    case CONSUME_BLOB: {
+      nsRefPtr<File> blob =
+        File::CreateMemoryFile(DerivedClass()->GetParentObject(),
+                               reinterpret_cast<void *>(aResult), aResultLength, NS_ConvertUTF8toUTF16(mMimeType));
+
+      if (!blob) {
+        localPromise->MaybeReject(NS_ERROR_DOM_UNKNOWN_ERR);
+        return;
+      }
+
+      localPromise->MaybeResolve(blob);
+      // File takes over ownership.
+      autoFree.Reset();
+      return;
+    }
+    case CONSUME_TEXT:
+      // fall through handles early exit.
+    case CONSUME_JSON: {
+      StreamDecoder decoder;
+      decoder.AppendText(reinterpret_cast<char*>(aResult), aResultLength);
+
+      nsString& decoded = decoder.GetText();
+      if (mConsumeType == CONSUME_TEXT) {
+        localPromise->MaybeResolve(decoded);
+        return;
+      }
+
+      JS::Rooted<JS::Value> json(cx);
+      if (!JS_ParseJSON(cx, decoded.get(), decoded.Length(), &json)) {
+        JS::Rooted<JS::Value> exn(cx);
+        if (JS_GetPendingException(cx, &exn)) {
+          JS_ClearPendingException(cx);
+          localPromise->MaybeReject(cx, exn);
+        }
+        return;
+      }
+
+      localPromise->MaybeResolve(cx, json);
+      return;
+    }
+  }
+
+  NS_NOTREACHED("Unexpected consume body type");
 }
 
 template <class Derived>
 already_AddRefed<Promise>
 FetchBody<Derived>::ConsumeBody(ConsumeType aType, ErrorResult& aRv)
 {
-  nsRefPtr<Promise> promise = Promise::Create(DerivedClass()->GetParentObject(), aRv);
-  if (aRv.Failed()) {
-    return nullptr;
-  }
-
+  mConsumeType = aType;
   if (BodyUsed()) {
     aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
     return nullptr;
   }
 
   SetBodyUsed();
 
-  // While the spec says to do this asynchronously, all the body constructors
-  // right now only accept bodies whose streams are backed by an in-memory
-  // buffer that can be read without blocking. So I think this is fine.
-  nsCOMPtr<nsIInputStream> stream;
-  DerivedClass()->GetBody(getter_AddRefs(stream));
-
-  if (!stream) {
-    aRv = NS_NewByteInputStream(getter_AddRefs(stream), "", 0,
-                                NS_ASSIGNMENT_COPY);
-    if (NS_WARN_IF(aRv.Failed())) {
-      return nullptr;
-    }
-  }
-
-  AutoJSAPI api;
-  api.Init(DerivedClass()->GetParentObject());
-  JSContext* cx = api.cx();
-
-  // We can make this assertion because for now we only support memory backed
-  // structures for the body argument for a Request.
-  MOZ_ASSERT(NS_InputStreamIsBuffered(stream));
-  nsCString buffer;
-  uint64_t len;
-  aRv = stream->Available(&len);
+  mConsumePromise = Promise::Create(DerivedClass()->GetParentObject(), aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  aRv = NS_ReadInputStreamToString(stream, buffer, len);
+  aRv = BeginConsumeBody();
   if (NS_WARN_IF(aRv.Failed())) {
+    mConsumePromise = nullptr;
     return nullptr;
   }
 
-  buffer.SetLength(len);
-
-  switch (aType) {
-    case CONSUME_ARRAYBUFFER: {
-      JS::Rooted<JSObject*> arrayBuffer(cx);
-      arrayBuffer =
-        ArrayBuffer::Create(cx, buffer.Length(),
-                            reinterpret_cast<const uint8_t*>(buffer.get()));
-      JS::Rooted<JS::Value> val(cx);
-      val.setObjectOrNull(arrayBuffer);
-      promise->MaybeResolve(cx, val);
-      return promise.forget();
-    }
-    case CONSUME_BLOB: {
-      // XXXnsm it is actually possible to avoid these duplicate allocations
-      // for the Blob case by having the Blob adopt the stream's memory
-      // directly, but I've not added a special case for now.
-      //
-      // FIXME(nsm): Use nsContentUtils::CreateBlobBuffer once blobs have been fixed on
-      // workers.
-      uint32_t blobLen = buffer.Length();
-      void* blobData = moz_malloc(blobLen);
-      nsRefPtr<File> blob;
-      if (blobData) {
-        memcpy(blobData, buffer.BeginReading(), blobLen);
-        blob = File::CreateMemoryFile(DerivedClass()->GetParentObject(), blobData, blobLen,
-                                      NS_ConvertUTF8toUTF16(mMimeType));
-      } else {
-        aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
-        return nullptr;
-      }
-
-      promise->MaybeResolve(blob);
-      return promise.forget();
-    }
-    case CONSUME_JSON: {
-      nsAutoString decoded;
-      aRv = DecodeUTF8(buffer, decoded);
-      if (NS_WARN_IF(aRv.Failed())) {
-        return nullptr;
-      }
-
-      JS::Rooted<JS::Value> json(cx);
-      if (!JS_ParseJSON(cx, decoded.get(), decoded.Length(), &json)) {
-        JS::Rooted<JS::Value> exn(cx);
-        if (JS_GetPendingException(cx, &exn)) {
-          JS_ClearPendingException(cx);
-          promise->MaybeReject(cx, exn);
-        }
-      }
-      promise->MaybeResolve(cx, json);
-      return promise.forget();
-    }
-    case CONSUME_TEXT: {
-      nsAutoString decoded;
-      aRv = DecodeUTF8(buffer, decoded);
-      if (NS_WARN_IF(aRv.Failed())) {
-        return nullptr;
-      }
-
-      promise->MaybeResolve(decoded);
-      return promise.forget();
-    }
-  }
-
-  NS_NOTREACHED("Unexpected consume body type");
-  // Silence warnings.
-  return nullptr;
+  nsRefPtr<Promise> promise = mConsumePromise;
+  return promise.forget();
 }
 
 template
 already_AddRefed<Promise>
 FetchBody<Request>::ConsumeBody(ConsumeType aType, ErrorResult& aRv);
 
 template
 already_AddRefed<Promise>
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -1,23 +1,30 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_Fetch_h
 #define mozilla_dom_Fetch_h
 
+#include "nsIStreamLoader.h"
+
 #include "nsCOMPtr.h"
 #include "nsError.h"
+#include "nsProxyRelease.h"
 #include "nsString.h"
+
+#include "mozilla/DebugOnly.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/RequestBinding.h"
+#include "mozilla/dom/workers/bindings/WorkerFeature.h"
 
-class nsIInputStream;
+class nsIInputStreamPump;
+class nsIOutputStream;
 class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
 class ArrayBufferOrArrayBufferViewOrBlobOrUSVStringOrURLSearchParams;
 class InternalRequest;
 class OwningArrayBufferOrArrayBufferViewOrBlobOrUSVStringOrURLSearchParams;
@@ -48,16 +55,51 @@ ExtractByteStreamFromBody(const OwningAr
 /*
  * Non-owning version.
  */
 nsresult
 ExtractByteStreamFromBody(const ArrayBufferOrArrayBufferViewOrBlobOrUSVStringOrURLSearchParams& aBodyInit,
                           nsIInputStream** aStream,
                           nsCString& aContentType);
 
+template <class Derived> class FetchBodyFeature;
+
+/*
+ * FetchBody's body consumption uses nsIInputStreamPump to read from the
+ * underlying stream to a block of memory, which is then adopted by
+ * ContinueConsumeBody() and converted to the right type based on the JS
+ * function called.
+ *
+ * Use of the nsIInputStreamPump complicates things on the worker thread.
+ * The solution used here is similar to WebSockets.
+ * The difference is that we are only interested in completion and not data
+ * events, and nsIInputStreamPump can only deliver completion on the main thread.
+ *
+ * Before starting the pump on the main thread, we addref the FetchBody to keep
+ * it alive. Then we add a feature, to track the status of the worker.
+ *
+ * ContinueConsumeBody() is the function that cleans things up in both success
+ * and error conditions and so all callers call it with the appropriate status.
+ *
+ * Once the read is initiated on the main thread there are two possibilities.
+ *
+ * 1) Pump finishes before worker has finished Running.
+ *    In this case we adopt the data and dispatch a runnable to the worker,
+ *    which derefs FetchBody and removes the feature and resolves the Promise.
+ *
+ * 2) Pump still working while worker has stopped Running.
+ *    The feature is Notify()ed and ContinueConsumeBody() is called with
+ *    NS_BINDING_ABORTED. We first Cancel() the pump using a sync runnable to
+ *    ensure that mFetchBody remains alive (since mConsumeBodyPump is strongly
+ *    held by it) until pump->Cancel() is called. OnStreamComplete() will not
+ *    do anything if the error code is NS_BINDING_ABORTED, so we don't have to
+ *    worry about keeping anything alive.
+ *
+ * The pump is always released on the main thread.
+ */
 template <class Derived>
 class FetchBody {
 public:
   bool
   BodyUsed() { return mBodyUsed; }
 
   already_AddRefed<Promise>
   ArrayBuffer(ErrorResult& aRv)
@@ -78,50 +120,102 @@ public:
   }
 
   already_AddRefed<Promise>
   Text(ErrorResult& aRv)
   {
     return ConsumeBody(CONSUME_TEXT, aRv);
   }
 
+  // Utility public methods accessed by various runnables.
+  void
+  BeginConsumeBodyMainThread();
+
+  void
+  ContinueConsumeBody(nsresult aStatus, uint32_t aLength, uint8_t* aResult);
+
+  void
+  CancelPump();
+
+  // Always set whenever the FetchBody is created on the worker thread.
+  workers::WorkerPrivate* mWorkerPrivate;
+
+  // Set when consuming the body is attempted on a worker.
+  // Unset when consumption is done/aborted.
+  nsAutoPtr<FetchBodyFeature<Derived>> mFeature;
+
 protected:
-  FetchBody()
-    : mBodyUsed(false)
+  FetchBody();
+
+  virtual ~FetchBody()
   {
   }
 
   void
   SetBodyUsed()
   {
     mBodyUsed = true;
   }
 
   void
   SetMimeType(ErrorResult& aRv);
-
 private:
   enum ConsumeType
   {
     CONSUME_ARRAYBUFFER,
     CONSUME_BLOB,
     // FormData not supported right now,
     CONSUME_JSON,
     CONSUME_TEXT,
   };
 
   Derived*
   DerivedClass() const
   {
     return static_cast<Derived*>(const_cast<FetchBody*>(this));
   }
 
+  nsresult
+  BeginConsumeBody();
+
   already_AddRefed<Promise>
   ConsumeBody(ConsumeType aType, ErrorResult& aRv);
 
+  bool
+  AddRefObject();
+
+  void
+  ReleaseObject();
+
+  bool
+  RegisterFeature();
+
+  void
+  UnregisterFeature();
+
+  bool
+  IsOnTargetThread()
+  {
+    return NS_IsMainThread() == !mWorkerPrivate;
+  }
+
+  void
+  AssertIsOnTargetThread()
+  {
+    MOZ_ASSERT(IsOnTargetThread());
+  }
+
+  // Only ever set once, always on target thread.
   bool mBodyUsed;
   nsCString mMimeType;
+
+  // Only touched on target thread.
+  ConsumeType mConsumeType;
+  nsRefPtr<Promise> mConsumePromise;
+  DebugOnly<bool> mReadDone;
+
+  nsMainThreadPtrHandle<nsIInputStreamPump> mConsumeBodyPump;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_Fetch_h
diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -1,16 +1,22 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/FetchDriver.h"
 
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIHttpChannel.h"
+#include "nsIHttpHeaderVisitor.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsIThreadRetargetableRequest.h"
+#include "nsIUploadChannel2.h"
 
 #include "nsContentPolicyUtils.h"
 #include "nsDataHandler.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsNetUtil.h"
 #include "nsStringStream.h"
 
 #include "mozilla/dom/File.h"
@@ -18,18 +24,21 @@
 
 #include "Fetch.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
 
 namespace mozilla {
 namespace dom {
 
-FetchDriver::FetchDriver(InternalRequest* aRequest)
-  : mRequest(aRequest)
+NS_IMPL_ISUPPORTS(FetchDriver, nsIStreamListener)
+
+FetchDriver::FetchDriver(InternalRequest* aRequest, nsIPrincipal* aPrincipal)
+  : mPrincipal(aPrincipal)
+  , mRequest(aRequest)
   , mFetchRecursionCount(0)
 {
 }
 
 FetchDriver::~FetchDriver()
 {
 }
 
@@ -107,39 +116,39 @@ FetchDriver::ContinueFetch(bool aCORSFla
     mRequest->SetResponseTainting(InternalRequest::RESPONSETAINT_OPAQUE);
     return BasicFetch();
   }
 
   if (!scheme.EqualsLiteral("http") && !scheme.EqualsLiteral("https")) {
     return FailWithNetworkError();
   }
 
+  bool corsPreflight = false;
   if (mRequest->Mode() == RequestMode::Cors_with_forced_preflight ||
       (mRequest->UnsafeRequest() && (mRequest->HasSimpleMethod() || !mRequest->Headers()->HasOnlySimpleHeaders()))) {
-    // FIXME(nsm): Set corsPreflight;
+    corsPreflight = true;
   }
 
   mRequest->SetResponseTainting(InternalRequest::RESPONSETAINT_CORS);
-  // FIXME(nsm): HttpFetch.
-  return FailWithNetworkError();
+  return HttpFetch(true /* aCORSFlag */, corsPreflight);
 }
 
 nsresult
 FetchDriver::BasicFetch()
 {
   nsAutoCString url;
   mRequest->GetURL(url);
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri),
                  url,
                  nullptr,
                  nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  nsCString scheme;
+  nsAutoCString scheme;
   rv = uri->GetScheme(scheme);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (scheme.LowerCaseEqualsLiteral("about")) {
     if (url.EqualsLiteral("about:blank")) {
       nsRefPtr<InternalResponse> response =
         new InternalResponse(200, NS_LITERAL_CSTRING("OK"));
       ErrorResult result;
@@ -240,25 +249,117 @@ FetchDriver::BasicFetch()
     }
 
     return FailWithNetworkError();
   }
 
   if (scheme.LowerCaseEqualsLiteral("file")) {
   } else if (scheme.LowerCaseEqualsLiteral("http") ||
              scheme.LowerCaseEqualsLiteral("https")) {
-    // FIXME(nsm): HttpFetch.
-    return FailWithNetworkError();
+    return HttpFetch();
   }
 
   return FailWithNetworkError();
 }
 
 nsresult
-FetchDriver::BeginResponse(InternalResponse* aResponse)
+FetchDriver::HttpFetch(bool aCORSFlag, bool aPreflightCORSFlag, bool aAuthenticationFlag)
+{
+  mResponse = nullptr;
+
+  // XXXnsm: The ServiceWorker interception should happen automatically.
+  return ContinueHttpFetchAfterServiceWorker();
+}
+
+NS_IMETHODIMP
+FetchDriver::ContinueHttpFetchAfterServiceWorker()
+{
+  if (!mResponse) {
+    // FIXME(nsm): Set skip SW flag.
+    // FIXME(nsm): Deal with CORS flags cases which will also call
+    // ContinueHttpFetchAfterCORSPreflight().
+    return ContinueHttpFetchAfterCORSPreflight();
+  }
+
+  // Otherwise ServiceWorker replied with a response.
+  return ContinueHttpFetchAfterNetworkFetch();
+}
+
+NS_IMETHODIMP
+FetchDriver::ContinueHttpFetchAfterCORSPreflight()
+{
+  // mResponse is currently the CORS response.
+  // We may have to pass it via argument.
+  if (mResponse && mResponse->IsError()) {
+    return FailWithNetworkError();
+  }
+
+  return HttpNetworkFetch();
+}
+
+NS_IMETHODIMP
+FetchDriver::HttpNetworkFetch()
+{
+  nsRefPtr<InternalRequest> httpRequest = new InternalRequest(*mRequest);
+  // FIXME(nsm): Figure out how to tee request's body.
+
+  // FIXME(nsm): Http network fetch steps 2-7.
+  nsresult rv;
+
+  nsCOMPtr<nsIIOService> ios = do_GetIOService(&rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsAutoCString url;
+  httpRequest->GetURL(url);
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewURI(getter_AddRefs(uri),
+                          url,
+                          nullptr,
+                          nullptr,
+                          ios);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIChannel> chan;
+  rv = NS_NewChannel(getter_AddRefs(chan),
+                     uri,
+                     mPrincipal,
+                     nsILoadInfo::SEC_NORMAL,
+                     mRequest->GetContext(),
+                     nullptr, /* FIXME(nsm): loadgroup */
+                     nullptr, /* aCallbacks */
+                     nsIRequest::LOAD_NORMAL,
+                     ios);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIHttpChannel> httpChan = do_QueryInterface(chan);
+  if (httpChan) {
+    nsAutoCString method;
+    mRequest->GetMethod(method);
+    rv = httpChan->SetRequestMethod(method);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  return chan->AsyncOpen(this, nullptr);
+}
+
+NS_IMETHODIMP
+FetchDriver::ContinueHttpFetchAfterNetworkFetch()
+{
+  workers::AssertIsOnMainThread();
+  MOZ_ASSERT(mResponse);
+  MOZ_ASSERT(!mResponse->IsError());
+
+  /*switch (mResponse->GetStatus()) {
+    default:
+  }*/
+
+  return SucceedWithResponse();
+}
+
+already_AddRefed<InternalResponse>
+FetchDriver::BeginAndGetFilteredResponse(InternalResponse* aResponse)
 {
   MOZ_ASSERT(aResponse);
   nsAutoCString reqURL;
   mRequest->GetURL(reqURL);
   aResponse->SetUrl(reqURL);
 
   // FIXME(nsm): Handle mixed content check, step 7 of fetch.
 
@@ -274,28 +375,160 @@ FetchDriver::BeginResponse(InternalRespo
       filteredResponse = InternalResponse::OpaqueResponse();
       break;
     default:
       MOZ_CRASH("Unexpected case");
   }
 
   MOZ_ASSERT(filteredResponse);
   mObserver->OnResponseAvailable(filteredResponse);
-  return NS_OK;
+  return filteredResponse.forget();
+}
+
+void
+FetchDriver::BeginResponse(InternalResponse* aResponse)
+{
+  nsRefPtr<InternalResponse> r = BeginAndGetFilteredResponse(aResponse);
+  // Release the ref.
 }
 
 nsresult
 FetchDriver::SucceedWithResponse()
 {
+  mObserver->OnResponseEnd();
   return NS_OK;
 }
 
 nsresult
 FetchDriver::FailWithNetworkError()
 {
   nsRefPtr<InternalResponse> error = InternalResponse::NetworkError();
   mObserver->OnResponseAvailable(error);
-  // FIXME(nsm): Some sort of shutdown?
+  mObserver->OnResponseEnd();
+  return NS_OK;
+}
+
+namespace {
+class FillResponseHeaders MOZ_FINAL : public nsIHttpHeaderVisitor {
+  InternalResponse* mResponse;
+
+  ~FillResponseHeaders()
+  { }
+public:
+  NS_DECL_ISUPPORTS
+
+  FillResponseHeaders(InternalResponse* aResponse)
+    : mResponse(aResponse)
+  {
+  }
+
+  NS_IMETHOD
+  VisitHeader(const nsACString & aHeader, const nsACString & aValue) MOZ_OVERRIDE
+  {
+    ErrorResult result;
+    mResponse->Headers()->Append(aHeader, aValue, result);
+    return result.ErrorCode();
+  }
+};
+
+NS_IMPL_ISUPPORTS(FillResponseHeaders, nsIHttpHeaderVisitor)
+} // anonymous namespace
+
+NS_IMETHODIMP
+FetchDriver::OnStartRequest(nsIRequest* aRequest,
+                            nsISupports* aContext)
+{
+  MOZ_ASSERT(!mPipeOutputStream);
+  nsresult requestStatus;
+  aRequest->GetStatus(&requestStatus);
+  if (NS_WARN_IF(NS_FAILED(requestStatus))) {
+    return FailWithNetworkError();
+  }
+
+  nsCOMPtr<nsIHttpChannel> channel = do_QueryInterface(aRequest);
+  // For now we only support HTTP.
+  MOZ_ASSERT(channel);
+
+  uint32_t status;
+  channel->GetResponseStatus(&status);
+
+  nsCString statusText;
+  channel->GetResponseStatusText(statusText);
+
+  nsRefPtr<InternalResponse> response = new InternalResponse(status, statusText);
+
+  nsRefPtr<FillResponseHeaders> visitor = new FillResponseHeaders(response);
+  nsresult rv = channel->VisitResponseHeaders(visitor);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    NS_WARNING("Failed to visit all headers.");
+  }
+
+  mResponse = BeginAndGetFilteredResponse(response);
+
+  // We open a pipe so that we can immediately set the pipe's read end as the
+  // response's body. Setting the segment size to UINT32_MAX means that the
+  // pipe has infinite space, which seems odd, but this is effectively what
+  // other APIs like XHR do anyway, since the entire response has to be read.
+  // The difference is that in XHR it is immediately converted to text or
+  // ArrayBuffer or similar, while in Fetch, we pass around streams until JS
+  // requests another type.
+  nsCOMPtr<nsIAsyncInputStream> pipeInputStream;
+  rv = NS_NewPipe2(getter_AddRefs(pipeInputStream),
+                   getter_AddRefs(mPipeOutputStream),
+                   true, /* non blocking input (read) end */
+                   false, /* blocking write end. Since pipe size is infinite, this won't freeze the main thread. */
+                   0, /* default segment size */
+                   UINT32_MAX /* infinite pipe */);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    FailWithNetworkError();
+    // Cancel request.
+    return rv;
+  }
+
+  nsCOMPtr<nsIInputStream> cast = do_QueryInterface(pipeInputStream);
+  mResponse->SetBody(cast);
+
+  // Try to retarget off main thread.
+  nsCOMPtr<nsIEventTarget> sts = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID);
+  if (sts) {
+    nsCOMPtr<nsIThreadRetargetableRequest> rr = do_QueryInterface(aRequest);
+    if (rr) {
+      rr->RetargetDeliveryTo(sts);
+    }
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+FetchDriver::OnDataAvailable(nsIRequest* aRequest,
+                             nsISupports* aContext,
+                             nsIInputStream* aInputStream,
+                             uint64_t aOffset,
+                             uint32_t aCount)
+{
+  uint32_t aRead;
+  MOZ_ASSERT(mResponse);
+  MOZ_ASSERT(mPipeOutputStream);
+
+  nsresult rv = aInputStream->ReadSegments(NS_CopySegmentToStream,
+                                           mPipeOutputStream,
+                                           aCount, &aRead);
+  return rv;
+}
+
+NS_IMETHODIMP
+FetchDriver::OnStopRequest(nsIRequest* aRequest,
+                           nsISupports* aContext,
+                           nsresult aStatusCode)
+{
+  MOZ_ASSERT(mPipeOutputStream);
+  mPipeOutputStream->Close();
+
+  if (NS_FAILED(aStatusCode)) {
+    return FailWithNetworkError();
+  }
+
+  ContinueHttpFetchAfterNetworkFetch();
   return NS_OK;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/FetchDriver.h b/dom/fetch/FetchDriver.h
--- a/dom/fetch/FetchDriver.h
+++ b/dom/fetch/FetchDriver.h
@@ -1,59 +1,81 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_FetchDriver_h
 #define mozilla_dom_FetchDriver_h
 
+#include "nsAutoPtr.h"
 #include "nsIStreamListener.h"
 #include "nsRefPtr.h"
 
+class nsIPrincipal;
 class nsPIDOMWindow;
 
 namespace mozilla {
 namespace dom {
 
+class BlobSet;
 class InternalRequest;
 class InternalResponse;
 
 class FetchDriverObserver
 {
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(FetchDriverObserver);
   virtual void OnResponseAvailable(InternalResponse* aResponse) = 0;
+  // This is triggered after the response's body has been set to a valid
+  // stream. ConsumeBody may proceed to read the stream.
+  virtual void OnResponseEnd() = 0;
 
 protected:
   virtual ~FetchDriverObserver()
   { };
 };
 
-class FetchDriver MOZ_FINAL
+class FetchDriver MOZ_FINAL : public nsIStreamListener
 {
-  NS_INLINE_DECL_REFCOUNTING(FetchDriver)
 public:
-  explicit FetchDriver(InternalRequest* aRequest);
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIREQUESTOBSERVER
+  NS_DECL_NSISTREAMLISTENER
+
+  explicit FetchDriver(InternalRequest* aRequest, nsIPrincipal* aPrincipal);
   NS_IMETHOD Fetch(FetchDriverObserver* aObserver);
 
 private:
+  nsCOMPtr<nsIPrincipal> mPrincipal;
   nsRefPtr<InternalRequest> mRequest;
+  nsRefPtr<InternalResponse> mResponse;
+  nsCOMPtr<nsIAsyncOutputStream> mPipeOutputStream;
   nsRefPtr<FetchDriverObserver> mObserver;
   uint32_t mFetchRecursionCount;
 
   FetchDriver() MOZ_DELETE;
   FetchDriver(const FetchDriver&) MOZ_DELETE;
   FetchDriver& operator=(const FetchDriver&) MOZ_DELETE;
   ~FetchDriver();
 
   nsresult Fetch(bool aCORSFlag);
   nsresult ContinueFetch(bool aCORSFlag);
   nsresult BasicFetch();
+  nsresult HttpFetch(bool aCORSFlag = false, bool aPreflightCORSFlag = false, bool aAuthenticationFlag = false);
+  nsresult ContinueHttpFetchAfterServiceWorker();
+  nsresult ContinueHttpFetchAfterCORSPreflight();
+  nsresult HttpNetworkFetch();
+  nsresult ContinueHttpFetchAfterNetworkFetch();
+  // Returns the filtered response sent to the observer.
+  already_AddRefed<InternalResponse>
+  BeginAndGetFilteredResponse(InternalResponse* aResponse);
+  // Utility since not all cases need to do any post processing of the filtered
+  // response.
+  void BeginResponse(InternalResponse* aResponse);
   nsresult FailWithNetworkError();
-  nsresult BeginResponse(InternalResponse* aResponse);
   nsresult SucceedWithResponse();
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_FetchDriver_h
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -235,16 +235,18 @@ public:
   SameOriginDataURL() const
   {
     return mSameOriginDataURL;
   }
 
   void
   SetBody(nsIInputStream* aStream)
   {
+    // A request's body may not be reset once set.
+    MOZ_ASSERT(!mBodyStream);
     mBodyStream = aStream;
   }
 
   // Will return the original stream!
   // Use a tee or copy if you don't want to erase the original.
   void
   GetBody(nsIInputStream** aStream)
   {
diff --git a/dom/fetch/InternalResponse.h b/dom/fetch/InternalResponse.h
--- a/dom/fetch/InternalResponse.h
+++ b/dom/fetch/InternalResponse.h
@@ -99,16 +99,18 @@ public:
   {
     nsCOMPtr<nsIInputStream> stream = mBody;
     stream.forget(aStream);
   }
 
   void
   SetBody(nsIInputStream* aBody)
   {
+    // A request's body may not be reset once set.
+    MOZ_ASSERT(!mBody);
     mBody = aBody;
   }
 
 private:
   ~InternalResponse()
   { }
 
   // Used to create filtered responses.
diff --git a/dom/fetch/Request.h b/dom/fetch/Request.h
--- a/dom/fetch/Request.h
+++ b/dom/fetch/Request.h
@@ -21,18 +21,18 @@ namespace mozilla {
 namespace dom {
 
 class Headers;
 class InternalHeaders;
 class Promise;
 class RequestOrUSVString;
 
 class Request MOZ_FINAL : public nsISupports
+                        , public FetchBody<Request>
                         , public nsWrapperCache
-                        , public FetchBody<Request>
 {
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Request)
 
 public:
   Request(nsIGlobalObject* aOwner, InternalRequest* aRequest);
 
   JSObject*
diff --git a/dom/fetch/Response.h b/dom/fetch/Response.h
--- a/dom/fetch/Response.h
+++ b/dom/fetch/Response.h
@@ -20,18 +20,18 @@ namespace mozilla {
 namespace dom {
 
 class ArrayBufferOrArrayBufferViewOrUSVStringOrURLSearchParams;
 class Headers;
 class InternalHeaders;
 class Promise;
 
 class Response MOZ_FINAL : public nsISupports
+                         , public FetchBody<Response>
                          , public nsWrapperCache
-                         , public FetchBody<Response>
 {
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Response)
 
 public:
   Response(nsIGlobalObject* aGlobal, InternalResponse* aInternalResponse);
 
   Response(const Response& aOther) MOZ_DELETE;
diff --git a/dom/tests/mochitest/fetch/mochitest.ini b/dom/tests/mochitest/fetch/mochitest.ini
--- a/dom/tests/mochitest/fetch/mochitest.ini
+++ b/dom/tests/mochitest/fetch/mochitest.ini
@@ -1,9 +1,11 @@
 [DEFAULT]
 support-files =
   test_headers_common.js
   test_headers_mainthread.js
   worker_test_fetch_basic.js
+  worker_test_fetch_basic_http.js
   worker_wrapper.js
 
 [test_headers.html]
 [test_fetch_basic.html]
+[test_fetch_basic_http.html]
diff --git a/dom/tests/mochitest/fetch/test_fetch_basic_http.html b/dom/tests/mochitest/fetch/test_fetch_basic_http.html
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/fetch/test_fetch_basic_http.html
@@ -0,0 +1,57 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1039846 - Test fetch() http fetching in worker</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script type="text/javascript" src="worker_test_fetch_basic.js"> </script>
+<script class="testbody" type="text/javascript">
+SimpleTest.waitForExplicitFinish();
+
+function testOnWorker(done) {
+  ok(true, "=== Start Worker Tests ===");
+  var worker = new Worker("worker_test_fetch_basic_http.js");
+  worker.onmessage = function(event) {
+    if (event.data.type == "finish") {
+      ok(true, "=== Finish Worker Tests ===");
+      done();
+    } else if (event.data.type == "status") {
+      ok(event.data.status, event.data.msg);
+    }
+  }
+
+  worker.onerror = function(event) {
+    ok(false, "Worker had an error: " + event.data);
+    ok(true, "=== Finish Worker Tests ===");
+    done();
+  };
+
+  worker.postMessage("start");
+}
+
+//
+// Driver
+//
+
+SpecialPowers.pushPrefEnv({"set": [
+  ["dom.fetch.enabled", true]
+]}, function() {
+  testOnWorker(function() {
+    SimpleTest.finish();
+  });
+});
+</script>
+</script>
+</pre>
+</body>
+</html>
+
diff --git a/dom/tests/mochitest/fetch/worker_test_fetch_basic.js b/dom/tests/mochitest/fetch/worker_test_fetch_basic.js
--- a/dom/tests/mochitest/fetch/worker_test_fetch_basic.js
+++ b/dom/tests/mochitest/fetch/worker_test_fetch_basic.js
@@ -77,17 +77,16 @@ function runTest() {
       postMessage({ type: 'finish' });
     }
   }
 
   Promise.resolve()
     .then(testAboutURL)
     .then(testDataURL)
     .then(testSameOriginBlobURL)
-    //.then(testAboutURL)
     // Put more promise based tests here.
     .then(done)
     .catch(function(e) {
       ok(false, "Some Response tests failed " + e);
       done();
     })
 }
 
diff --git a/dom/tests/mochitest/fetch/worker_test_fetch_basic_http.js b/dom/tests/mochitest/fetch/worker_test_fetch_basic_http.js
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/fetch/worker_test_fetch_basic_http.js
@@ -0,0 +1,91 @@
+if (typeof ok !== "function") {
+  function ok(a, msg) {
+    dump("OK: " + !!a + "  =>  " + a + " " + msg + "\n");
+    postMessage({type: 'status', status: !!a, msg: a + ": " + msg });
+  }
+}
+
+if (typeof is !== "function") {
+  function is(a, b, msg) {
+    dump("IS: " + (a===b) + "  =>  " + a + " | " + b + " " + msg + "\n");
+    postMessage({type: 'status', status: a === b, msg: a + " === " + b + ": " + msg });
+  }
+}
+
+var path = "/tests/dom/base/test/";
+
+var passFiles = [['file_XHR_pass1.xml', 'GET', 200, 'OK', 'text/xml'],
+                 ['file_XHR_pass2.txt', 'GET', 200, 'OK', 'text/plain'],
+                 ['file_XHR_pass3.txt', 'GET', 200, 'OK', 'text/plain'],
+                 ];
+  
+function testURL() {
+  var promises = [];
+  passFiles.forEach(function(entry) {
+    var p = fetch(path + entry[0]).then(function(res) {
+      ok(res.type !== "error", "Response should not be an error for " + entry[0]);
+      is(res.status, entry[2], "Status should match expected for " + entry[0]);
+      is(res.statusText, entry[3], "Status text should match expected for " + entry[0]);
+      ok(res.url.endsWith(path + entry[0]), "Response url should match request for simple fetch for " + entry[0]);
+      is(res.headers.get('content-type'), entry[4], "Response should have content-type for " + entry[0]);
+    });
+    promises.push(p);
+  });
+
+  return Promise.all(promises);
+}
+
+var failFiles = [['ftp://localhost' + path + 'file_XHR_pass1.xml', 'GET']];
+
+function testURLFail() {
+  var promises = [];
+  failFiles.forEach(function(entry) {
+    var p = fetch(entry[0]).then(function(res) {
+      ok(res.type === "error", "Response should be an error for " + entry[0]);
+      is(res.status, 0, "Response status should be 0 for " + entry[0]);
+    });
+    promises.push(p);
+  });
+
+  return Promise.all(promises);
+}
+
+function testRequestGET() {
+  var promises = [];
+  passFiles.forEach(function(entry) {
+    var req = new Request(path + entry[0], { method: entry[1] });
+    var p = fetch(req).then(function(res) {
+      ok(res.type !== "error", "Response should not be an error for " + entry[0]);
+      is(res.status, entry[2], "Status should match expected for " + entry[0]);
+      is(res.statusText, entry[3], "Status text should match expected for " + entry[0]);
+      ok(res.url.endsWith(path + entry[0]), "Response url should match request for simple fetch for " + entry[0]);
+      is(res.headers.get('content-type'), entry[4], "Response should have content-type for " + entry[0]);
+    });
+    promises.push(p);
+  });
+
+  return Promise.all(promises);
+}
+
+function runTest() {
+  var done = function() {
+    if (typeof SimpleTest === "object") {
+      SimpleTest.finish();
+    } else {
+      postMessage({ type: 'finish' });
+    }
+  }
+
+  Promise.resolve()
+    .then(testURL)
+    .then(testURLFail)
+    .then(testRequestGET)
+    // Put more promise based tests here.
+    .then(done)
+    .catch(function(e) {
+      ok(false, "Some Response tests failed " + e);
+      done();
+    })
+}
+
+onmessage = runTest;
