# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2aed7bb644ddb7f60724b7164a438ca5e1563112
Bug 1256411 Simplify and cleanup ServiceWorkerInfo. r=ehsan

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1470,17 +1470,18 @@ public:
 
     ServiceWorkerManager::RegistrationDataPerPrincipal* data;
     if (!swm->mRegistrationInfos.Get(scopeKey, &data)) {
       return Fail(NS_ERROR_FAILURE);
     }
 
     MOZ_ASSERT(!mUpdateAndInstallInfo);
     mUpdateAndInstallInfo =
-      new ServiceWorkerInfo(mRegistration, mScriptSpec, aNewCacheName);
+      new ServiceWorkerInfo(mRegistration->mPrincipal, mRegistration->mScope,
+                            mScriptSpec, aNewCacheName);
 
     RefPtr<ServiceWorkerJob> upcasted = this;
     nsMainThreadPtrHandle<nsISupports> handle(
         new nsMainThreadPtrHolder<nsISupports>(upcasted));
     RefPtr<LifeCycleEventCallback> callback = new ContinueUpdateRunnable(handle);
 
     ServiceWorkerPrivate* workerPrivate =
       mUpdateAndInstallInfo->WorkerPrivate();
@@ -3001,18 +3002,18 @@ ServiceWorkerManager::LoadRegistration(
       // No needs for updates.
       return;
     }
   }
 
   const nsCString& currentWorkerURL = aRegistration.currentWorkerURL();
   if (!currentWorkerURL.IsEmpty()) {
     registration->mActiveWorker =
-      new ServiceWorkerInfo(registration, currentWorkerURL,
-                            aRegistration.cacheName());
+      new ServiceWorkerInfo(registration->mPrincipal, registration->mScope,
+                            currentWorkerURL, aRegistration.cacheName());
     registration->mActiveWorker->SetActivateStateUncheckedWithoutEvent(ServiceWorkerState::Activated);
   }
 }
 
 void
 ServiceWorkerManager::LoadRegistrations(
                   const nsTArray<ServiceWorkerRegistrationData>& aRegistrations)
 {
@@ -5231,29 +5232,33 @@ ServiceWorkerInfo::UpdateState(ServiceWo
   if (aState == ServiceWorkerState::Activated && mState != aState) {
     mServiceWorkerPrivate->Activated();
   }
   mState = aState;
   nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(r.forget())));
 }
 
-ServiceWorkerInfo::ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
+ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
+                                     const nsACString& aScope,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName)
-  : mRegistration(aReg)
+  : mPrincipal(aPrincipal)
+  , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mCacheName(aCacheName)
   , mState(ServiceWorkerState::EndGuard_)
   , mServiceWorkerID(GetNextID())
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
   , mSkipWaitingFlag(false)
 {
-  MOZ_ASSERT(mRegistration);
-  MOZ_ASSERT(!aCacheName.IsEmpty());
+  MOZ_ASSERT(mPrincipal);
+  MOZ_ASSERT(!mScope.IsEmpty());
+  MOZ_ASSERT(!mScriptSpec.IsEmpty());
+  MOZ_ASSERT(!mCacheName.IsEmpty());
 }
 
 ServiceWorkerInfo::~ServiceWorkerInfo()
 {
   MOZ_ASSERT(mServiceWorkerPrivate);
   mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
 }
 
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -190,19 +190,20 @@ public:
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
 class ServiceWorkerInfo final : public nsIServiceWorkerInfo
 {
 private:
-  const ServiceWorkerRegistrationInfo* mRegistration;
-  nsCString mScriptSpec;
-  nsString mCacheName;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+  const nsCString mScope;
+  const nsCString mScriptSpec;
+  const nsString mCacheName;
   ServiceWorkerState mState;
 
   // This id is shared with WorkerPrivate to match requests issued by service
   // workers to their corresponding serviceWorkerInfo.
   uint64_t mServiceWorkerID;
 
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
@@ -229,50 +230,45 @@ public:
   {
     MOZ_ASSERT(mServiceWorkerPrivate);
     return mServiceWorkerPrivate;
   }
 
   nsIPrincipal*
   GetPrincipal() const
   {
-    return mRegistration->mPrincipal;
+    return mPrincipal;
   }
 
   const nsCString&
   ScriptSpec() const
   {
     return mScriptSpec;
   }
 
   const nsCString&
   Scope() const
   {
-    return mRegistration->mScope;
-  }
-
-  void SetScriptSpec(const nsCString& aSpec)
-  {
-    MOZ_ASSERT(!aSpec.IsEmpty());
-    mScriptSpec = aSpec;
+    return mScope;
   }
 
   bool SkipWaitingFlag() const
   {
     AssertIsOnMainThread();
     return mSkipWaitingFlag;
   }
 
   void SetSkipWaitingFlag()
   {
     AssertIsOnMainThread();
     mSkipWaitingFlag = true;
   }
 
-  ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
+  ServiceWorkerInfo(nsIPrincipal* aPrincipal,
+                    const nsACString& aScope,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName);
 
   ServiceWorkerState
   State() const
   {
     return mState;
   }
