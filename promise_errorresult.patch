# HG changeset patch
# Parent 8aab265d81ab73c02f7e85076a79cb9e77ce4f15
# User Ben Kelly <ben@wanderview.com>
Bug 1091091: Support ErrorResult in Promise::MaybeReject()

diff --git a/dom/bindings/ToJSValue.cpp b/dom/bindings/ToJSValue.cpp
--- a/dom/bindings/ToJSValue.cpp
+++ b/dom/bindings/ToJSValue.cpp
@@ -55,10 +55,24 @@ bool
 ToJSValue(JSContext* aCx,
           nsresult aArgument,
           JS::MutableHandle<JS::Value> aValue)
 {
   nsRefPtr<Exception> exception = CreateException(aCx, aArgument);
   return ToJSValue(aCx, exception, aValue);
 }
 
+bool
+ToJSValue(JSContext* aCx,
+          ErrorResult& aArgument,
+          JS::MutableHandle<JS::Value> aValue)
+{
+  MOZ_ASSERT(aArgument.Failed());
+  ThrowMethodFailedWithDetails(aCx, aArgument, "", "");
+  if (!JS_GetPendingException(aCx, aValue)) {
+    return false;
+  }
+  JS_ClearPendingException(aCx);
+  return true;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/bindings/ToJSValue.h b/dom/bindings/ToJSValue.h
--- a/dom/bindings/ToJSValue.h
+++ b/dom/bindings/ToJSValue.h
@@ -256,16 +256,23 @@ ToJSValue(JSContext* aCx, const JS::Root
 
 // Accept nsresult, for use in rejections, and create an XPCOM
 // exception object representing that nsresult.
 bool
 ToJSValue(JSContext* aCx,
           nsresult aArgument,
           JS::MutableHandle<JS::Value> aValue);
 
+// Accept ErrorResult, for use in rejections, and create an exception
+// representing the failure.
+bool
+ToJSValue(JSContext* aCx,
+          ErrorResult& aArgument,
+          JS::MutableHandle<JS::Value> aValue);
+
 // Accept pointers to other things we accept
 template <typename T>
 typename EnableIf<IsPointer<T>::value, bool>::Type
 ToJSValue(JSContext* aCx,
           T aArgument,
           JS::MutableHandle<JS::Value> aValue)
 {
   return ToJSValue(aCx, *aArgument, aValue);
diff --git a/dom/promise/Promise.h b/dom/promise/Promise.h
--- a/dom/promise/Promise.h
+++ b/dom/promise/Promise.h
@@ -96,16 +96,20 @@ public:
   void MaybeResolve(const T& aArg) {
     MaybeSomething(aArg, &Promise::MaybeResolve);
   }
 
   inline void MaybeReject(nsresult aArg) {
     MOZ_ASSERT(NS_FAILED(aArg));
     MaybeSomething(aArg, &Promise::MaybeReject);
   }
+  inline void MaybeReject(ErrorResult& aArg) {
+    MOZ_ASSERT(aArg.Failed());
+    MaybeSomething(aArg, &Promise::MaybeReject);
+  }
   // DO NOT USE MaybeRejectBrokenly with in new code.  Promises should be
   // rejected with Error instances.
   // Note: MaybeRejectBrokenly is a template so we can use it with DOMError
   // without instantiating the DOMError specialization of MaybeSomething in
   // every translation unit that includes this header, because that would
   // require use to include DOMError.h either here or in all those translation
   // units.
   template<typename T>
