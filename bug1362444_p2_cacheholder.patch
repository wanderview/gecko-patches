# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  64c7efe4e00568c21c2503340fa26604b852f301
Bug 1362444 P2 Allow idle worker shutdown while Cache/CacheStorage DOM objects exist, but block it during Cache operation. r=baku

diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -70,17 +70,22 @@ CacheOpChild::CacheOpChild(CacheWorkerHo
   , mParent(aParent)
   , mPromise(aPromise)
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
   MOZ_DIAGNOSTIC_ASSERT(mParent);
   MOZ_DIAGNOSTIC_ASSERT(mPromise);
 
   MOZ_ASSERT_IF(!NS_IsMainThread(), aWorkerHolder);
-  SetWorkerHolder(aWorkerHolder);
+
+  RefPtr<CacheWorkerHolder> workerHolder =
+    CacheWorkerHolder::PreferBehavior(aWorkerHolder,
+                                      CacheWorkerHolder::PreventIdleShutdownStart);
+
+  SetWorkerHolder(workerHolder);
 }
 
 CacheOpChild::~CacheOpChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheOpChild);
   MOZ_DIAGNOSTIC_ASSERT(!mPromise);
 }
 
@@ -161,17 +166,21 @@ CacheOpChild::Recv__delete__(const Error
       MOZ_DIAGNOSTIC_ASSERT(actor);
       if (!actor) {
         ErrorResult status;
         status.ThrowTypeError<MSG_CACHE_OPEN_FAILED>();
         mPromise->MaybeReject(status);
         break;
       }
 
-      actor->SetWorkerHolder(GetWorkerHolder());
+      RefPtr<CacheWorkerHolder> workerHolder =
+        CacheWorkerHolder::PreferBehavior(GetWorkerHolder(),
+                                          CacheWorkerHolder::AllowIdleShutdownStart);
+
+      actor->SetWorkerHolder(workerHolder);
       RefPtr<Cache> cache = new Cache(mGlobal, actor);
       mPromise->MaybeResolve(cache);
       break;
     }
     case CacheOpResult::TStorageDeleteResult:
     {
       mPromise->MaybeResolve(aResult.get_StorageDeleteResult().success());
       break;
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -190,17 +190,18 @@ CacheStorage::CreateOnWorker(Namespace a
 
   if (aWorkerPrivate->GetOriginAttributes().mPrivateBrowsingId > 0) {
     NS_WARNING("CacheStorage not supported during private browsing.");
     RefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
   RefPtr<CacheWorkerHolder> workerHolder =
-    CacheWorkerHolder::Create(aWorkerPrivate);
+    CacheWorkerHolder::Create(aWorkerPrivate,
+                              CacheWorkerHolder::AllowIdleShutdownStart);
   if (!workerHolder) {
     NS_WARNING("Worker thread is shutting down.");
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
diff --git a/dom/cache/CacheWorkerHolder.cpp b/dom/cache/CacheWorkerHolder.cpp
--- a/dom/cache/CacheWorkerHolder.cpp
+++ b/dom/cache/CacheWorkerHolder.cpp
@@ -14,28 +14,50 @@ namespace dom {
 namespace cache {
 
 using mozilla::dom::workers::Terminating;
 using mozilla::dom::workers::Status;
 using mozilla::dom::workers::WorkerPrivate;
 
 // static
 already_AddRefed<CacheWorkerHolder>
-CacheWorkerHolder::Create(WorkerPrivate* aWorkerPrivate)
+CacheWorkerHolder::Create(WorkerPrivate* aWorkerPrivate, Behavior aBehavior)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
 
-  RefPtr<CacheWorkerHolder> workerHolder = new CacheWorkerHolder();
+  RefPtr<CacheWorkerHolder> workerHolder = new CacheWorkerHolder(aBehavior);
   if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, Terminating))) {
     return nullptr;
   }
 
   return workerHolder.forget();
 }
 
+// static
+already_AddRefed<CacheWorkerHolder>
+CacheWorkerHolder::PreferBehavior(CacheWorkerHolder* aCurrentHolder,
+                                  Behavior aBehavior)
+{
+  if (!aCurrentHolder) {
+    return nullptr;
+  }
+
+  RefPtr<CacheWorkerHolder> orig = aCurrentHolder;
+  if (orig->GetBehavior() == aBehavior) {
+    return orig.forget();
+  }
+
+  RefPtr<CacheWorkerHolder> replace = Create(orig->mWorkerPrivate, aBehavior);
+  if (!replace) {
+    return orig.forget();
+  }
+
+  return replace.forget();
+}
+
 void
 CacheWorkerHolder::AddActor(ActorChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheWorkerHolder);
   MOZ_DIAGNOSTIC_ASSERT(aActor);
   MOZ_ASSERT(!mActorList.Contains(aActor));
 
   mActorList.AppendElement(aActor);
@@ -88,18 +110,19 @@ CacheWorkerHolder::Notify(Status aStatus
   for (uint32_t i = 0; i < mActorList.Length(); ++i) {
     MOZ_DIAGNOSTIC_ASSERT(mActorList[i]);
     mActorList[i]->StartDestroy();
   }
 
   return true;
 }
 
-CacheWorkerHolder::CacheWorkerHolder()
-  : mNotified(false)
+CacheWorkerHolder::CacheWorkerHolder(Behavior aBehavior)
+  : WorkerHolder(aBehavior)
+  , mNotified(false)
 {
 }
 
 CacheWorkerHolder::~CacheWorkerHolder()
 {
   NS_ASSERT_OWNINGTHREAD(CacheWorkerHolder);
   MOZ_DIAGNOSTIC_ASSERT(mActorList.IsEmpty());
 }
diff --git a/dom/cache/CacheWorkerHolder.h b/dom/cache/CacheWorkerHolder.h
--- a/dom/cache/CacheWorkerHolder.h
+++ b/dom/cache/CacheWorkerHolder.h
@@ -21,28 +21,32 @@ namespace dom {
 namespace cache {
 
 class ActorChild;
 
 class CacheWorkerHolder final : public workers::WorkerHolder
 {
 public:
   static already_AddRefed<CacheWorkerHolder>
-  Create(workers::WorkerPrivate* aWorkerPrivate);
+  Create(workers::WorkerPrivate* aWorkerPrivate,
+         Behavior aBehavior);
+
+  static already_AddRefed<CacheWorkerHolder>
+  PreferBehavior(CacheWorkerHolder* aCurrentHolder, Behavior aBehavior);
 
   void AddActor(ActorChild* aActor);
   void RemoveActor(ActorChild* aActor);
 
   bool Notified() const;
 
   // WorkerHolder methods
   virtual bool Notify(workers::Status aStatus) override;
 
 private:
-  CacheWorkerHolder();
+  explicit CacheWorkerHolder(Behavior aBehavior);
   ~CacheWorkerHolder();
 
   nsTArray<ActorChild*> mActorList;
   bool mNotified;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::CacheWorkerHolder)
 };
