# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  da2c9b26e9de0b9e11dd1ef252a82d554a1ac0ee
Bug 1256428 P17 Rename service worker job classes to remove "2" suffix. r=jdm

diff --git a/dom/workers/ServiceWorkerJob.cpp b/dom/workers/ServiceWorkerJob.cpp
--- a/dom/workers/ServiceWorkerJob.cpp
+++ b/dom/workers/ServiceWorkerJob.cpp
@@ -9,65 +9,65 @@
 #include "nsProxyRelease.h"
 #include "nsThreadUtils.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-ServiceWorkerJob2::Type
-ServiceWorkerJob2::GetType() const
+ServiceWorkerJob::Type
+ServiceWorkerJob::GetType() const
 {
   return mType;
 }
 
-ServiceWorkerJob2::State
-ServiceWorkerJob2::GetState() const
+ServiceWorkerJob::State
+ServiceWorkerJob::GetState() const
 {
   return mState;
 }
 
 bool
-ServiceWorkerJob2::Canceled() const
+ServiceWorkerJob::Canceled() const
 {
   return mCanceled;
 }
 
 bool
-ServiceWorkerJob2::ResultCallbacksInvoked() const
+ServiceWorkerJob::ResultCallbacksInvoked() const
 {
   return mResultCallbacksInvoked;
 }
 
 bool
-ServiceWorkerJob2::IsEquivalentTo(ServiceWorkerJob2* aJob) const
+ServiceWorkerJob::IsEquivalentTo(ServiceWorkerJob* aJob) const
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
   return mType == aJob->mType &&
          mScope.Equals(aJob->mScope) &&
          mScriptSpec.Equals(aJob->mScriptSpec) &&
          mPrincipal->Equals(aJob->mPrincipal);
 }
 
 void
-ServiceWorkerJob2::AppendResultCallback(Callback* aCallback)
+ServiceWorkerJob::AppendResultCallback(Callback* aCallback)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mState != State::Finished);
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(mFinalCallback != aCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aCallback));
   MOZ_ASSERT(!mResultCallbacksInvoked);
   mResultCallbackList.AppendElement(aCallback);
 }
 
 void
-ServiceWorkerJob2::StealResultCallbacksFrom(ServiceWorkerJob2* aJob)
+ServiceWorkerJob::StealResultCallbacksFrom(ServiceWorkerJob* aJob)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
   MOZ_ASSERT(aJob->mState == State::Initial);
 
   // Take the callbacks from the other job immediately to avoid the
   // any possibility of them existing on both jobs at once.
   nsTArray<RefPtr<Callback>> callbackList;
@@ -76,83 +76,83 @@ ServiceWorkerJob2::StealResultCallbacksF
   for (RefPtr<Callback>& callback : callbackList) {
     // Use AppendResultCallback() so that assertion checking is performed on
     // each callback.
     AppendResultCallback(callback);
   }
 }
 
 void
-ServiceWorkerJob2::Start(Callback* aFinalCallback)
+ServiceWorkerJob::Start(Callback* aFinalCallback)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!mCanceled);
 
   MOZ_ASSERT(aFinalCallback);
   MOZ_ASSERT(!mFinalCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aFinalCallback));
   mFinalCallback = aFinalCallback;
 
   MOZ_ASSERT(mState == State::Initial);
   mState = State::Started;
 
   nsCOMPtr<nsIRunnable> runnable =
-    NS_NewRunnableMethod(this, &ServiceWorkerJob2::AsyncExecute);
+    NS_NewRunnableMethod(this, &ServiceWorkerJob::AsyncExecute);
 
   // We may have to wait for the PBackground actor to be initialized
   // before proceeding.  We should always be able to get a ServiceWorkerManager,
   // however, since Start() should not be called during shutdown.
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm->HasBackgroundActor()) {
     swm->AppendPendingOperation(runnable);
     return;
   }
 
   // Otherwise start asynchronously.  We should never run a job synchronously.
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     NS_DispatchToMainThread(runnable.forget())));
 }
 
 void
-ServiceWorkerJob2::Cancel()
+ServiceWorkerJob::Cancel()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!mCanceled);
   mCanceled = true;
 }
 
-ServiceWorkerJob2::ServiceWorkerJob2(Type aType,
-                                     nsIPrincipal* aPrincipal,
-                                     const nsACString& aScope,
-                                     const nsACString& aScriptSpec)
+ServiceWorkerJob::ServiceWorkerJob(Type aType,
+                                   nsIPrincipal* aPrincipal,
+                                   const nsACString& aScope,
+                                   const nsACString& aScriptSpec)
   : mType(aType)
   , mPrincipal(aPrincipal)
   , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mState(State::Initial)
   , mCanceled(false)
   , mResultCallbacksInvoked(false)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mPrincipal);
   MOZ_ASSERT(!mScope.IsEmpty());
   // Some job types may have an empty script spec
 }
 
-ServiceWorkerJob2::~ServiceWorkerJob2()
+ServiceWorkerJob::~ServiceWorkerJob()
 {
   AssertIsOnMainThread();
   // Jobs must finish or never be started.  Destroying an actively running
   // job is an error.
   MOZ_ASSERT(mState != State::Started);
   MOZ_ASSERT_IF(mState == State::Finished, mResultCallbacksInvoked);
 }
 
 void
-ServiceWorkerJob2::InvokeResultCallbacks(ErrorResult& aRv)
+ServiceWorkerJob::InvokeResultCallbacks(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mState == State::Started);
 
   MOZ_ASSERT(!mResultCallbacksInvoked);
   mResultCallbacksInvoked = true;
 
   nsTArray<RefPtr<Callback>> callbackList;
@@ -167,24 +167,24 @@ ServiceWorkerJob2::InvokeResultCallbacks
     callback->JobFinished(this, rv);
 
     // The callback might not consume the error.
     rv.SuppressException();
   }
 }
 
 void
-ServiceWorkerJob2::InvokeResultCallbacks(nsresult aRv)
+ServiceWorkerJob::InvokeResultCallbacks(nsresult aRv)
 {
   ErrorResult converted(aRv);
   InvokeResultCallbacks(converted);
 }
 
 void
-ServiceWorkerJob2::Finish(ErrorResult& aRv)
+ServiceWorkerJob::Finish(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mState == State::Started);
 
   // Ensure that we only surface SecurityErr, TypeErr or InvalidStateErr to script.
   if (aRv.Failed() && !aRv.ErrorCodeIs(NS_ERROR_DOM_SECURITY_ERR) &&
                       !aRv.ErrorCodeIs(NS_ERROR_DOM_TYPE_ERR) &&
                       !aRv.ErrorCodeIs(NS_ERROR_DOM_INVALID_STATE_ERR)) {
@@ -195,17 +195,17 @@ ServiceWorkerJob2::Finish(ErrorResult& a
     NS_ConvertUTF8toUTF16 scriptSpec(mScriptSpec);
     NS_ConvertUTF8toUTF16 scope(mScope);
 
     // Throw the type error with a generic error message.
     aRv.ThrowTypeError<MSG_SW_INSTALL_ERROR>(scriptSpec, scope);
   }
 
   // The final callback may drop the last ref to this object.
-  RefPtr<ServiceWorkerJob2> kungFuDeathGrip = this;
+  RefPtr<ServiceWorkerJob> kungFuDeathGrip = this;
 
   if (!mResultCallbacksInvoked) {
     InvokeResultCallbacks(aRv);
   }
 
   mState = State::Finished;
 
   mFinalCallback->JobFinished(this, aRv);
@@ -215,17 +215,17 @@ ServiceWorkerJob2::Finish(ErrorResult& a
   aRv.SuppressException();
 
   // Async release this object to ensure that our caller methods complete
   // as well.
   NS_ReleaseOnMainThread(kungFuDeathGrip.forget(), true /* always proxy */);
 }
 
 void
-ServiceWorkerJob2::Finish(nsresult aRv)
+ServiceWorkerJob::Finish(nsresult aRv)
 {
   ErrorResult converted(aRv);
   Finish(converted);
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerJob.h b/dom/workers/ServiceWorkerJob.h
--- a/dom/workers/ServiceWorkerJob.h
+++ b/dom/workers/ServiceWorkerJob.h
@@ -15,28 +15,28 @@ class nsIPrincipal;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 namespace workers {
 
-class ServiceWorkerJob2
+class ServiceWorkerJob
 {
 public:
   // Implement this interface to receive notification when a job completes.
   class Callback
   {
   public:
     // Called once when the job completes.  If the job is started, then this
     // will be called.  If a job is never executed due to browser shutdown,
     // then this method will never be called.  This method is always called
     // on the main thread asynchronously after Start() completes.
-    virtual void JobFinished(ServiceWorkerJob2* aJob, ErrorResult& aStatus) = 0;
+    virtual void JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) = 0;
 
     NS_IMETHOD_(MozExternalRefCountType)
     AddRef(void) = 0;
 
     NS_IMETHOD_(MozExternalRefCountType)
     Release(void) = 0;
   };
 
@@ -67,50 +67,50 @@ public:
   Canceled() const;
 
   // Determine if the result callbacks have already been called.  This is
   // equivalent to the spec checked to see if the job promise has settled.
   bool
   ResultCallbacksInvoked() const;
 
   bool
-  IsEquivalentTo(ServiceWorkerJob2* aJob) const;
+  IsEquivalentTo(ServiceWorkerJob* aJob) const;
 
   // Add a callback that will be invoked when the job's result is available.
   // Some job types will invoke this before the job is actually finished.
   // If an early callback does not occur, then it will be called automatically
   // when Finish() is called.  These callbacks will be invoked while the job
   // state is Started.
   void
   AppendResultCallback(Callback* aCallback);
 
   // This takes ownership of any result callbacks associated with the given job
   // and then appends them to this job's callback list.
   void
-  StealResultCallbacksFrom(ServiceWorkerJob2* aJob);
+  StealResultCallbacksFrom(ServiceWorkerJob* aJob);
 
   // Start the job.  All work will be performed asynchronously on
   // the main thread.  The Finish() method must be called exactly
   // once after this point.  A final callback must be provided.  It
   // will be invoked after all other callbacks have been processed.
   void
   Start(Callback* aFinalCallback);
 
   // Set an internal flag indicating that a started job should finish as
   // soon as possible.
   void
   Cancel();
 
 protected:
-  ServiceWorkerJob2(Type aType,
-                    nsIPrincipal* aPrincipal,
-                    const nsACString& aScope,
-                    const nsACString& aScriptSpec);
+  ServiceWorkerJob(Type aType,
+                   nsIPrincipal* aPrincipal,
+                   const nsACString& aScope,
+                   const nsACString& aScriptSpec);
 
-  virtual ~ServiceWorkerJob2();
+  virtual ~ServiceWorkerJob();
 
   // Invoke the result callbacks immediately.  The job must be in the
   // Started state.  The callbacks are cleared after being invoked,
   // so subsequent method calls have no effect.
   void
   InvokeResultCallbacks(ErrorResult& aRv);
 
   // Convenience method that converts to ErrorResult and calls real method.
@@ -140,16 +140,16 @@ protected:
 private:
   RefPtr<Callback> mFinalCallback;
   nsTArray<RefPtr<Callback>> mResultCallbackList;
   State mState;
   bool mCanceled;
   bool mResultCallbacksInvoked;
 
 public:
-  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJob2)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJob)
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkerjob_h
diff --git a/dom/workers/ServiceWorkerJobQueue.cpp b/dom/workers/ServiceWorkerJobQueue.cpp
--- a/dom/workers/ServiceWorkerJobQueue.cpp
+++ b/dom/workers/ServiceWorkerJobQueue.cpp
@@ -8,50 +8,50 @@
 
 #include "ServiceWorkerJob.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-class ServiceWorkerJobQueue2::Callback final : public ServiceWorkerJob2::Callback
+class ServiceWorkerJobQueue::Callback final : public ServiceWorkerJob::Callback
 {
-  RefPtr<ServiceWorkerJobQueue2> mQueue;
+  RefPtr<ServiceWorkerJobQueue> mQueue;
 
   ~Callback()
   {
   }
 
 public:
-  explicit Callback(ServiceWorkerJobQueue2* aQueue)
+  explicit Callback(ServiceWorkerJobQueue* aQueue)
     : mQueue(aQueue)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mQueue);
   }
 
   virtual void
-  JobFinished(ServiceWorkerJob2* aJob, ErrorResult& aStatus) override
+  JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
     AssertIsOnMainThread();
     mQueue->JobFinished(aJob);
   }
 
-  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue2::Callback, override)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue::Callback, override)
 };
 
-ServiceWorkerJobQueue2::~ServiceWorkerJobQueue2()
+ServiceWorkerJobQueue::~ServiceWorkerJobQueue()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mJobList.IsEmpty());
 }
 
 void
-ServiceWorkerJobQueue2::JobFinished(ServiceWorkerJob2* aJob)
+ServiceWorkerJobQueue::JobFinished(ServiceWorkerJob* aJob)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
 
   // XXX There are some corner cases where jobs can double-complete.  Until
   // we track all these down we do a non-fatal assert in debug builds and
   // a runtime check to verify the queue is in the correct state.
   NS_ASSERTION(!mJobList.IsEmpty(),
@@ -67,68 +67,68 @@ ServiceWorkerJobQueue2::JobFinished(Serv
   if (mJobList.IsEmpty()) {
     return;
   }
 
   RunJob();
 }
 
 void
-ServiceWorkerJobQueue2::RunJob()
+ServiceWorkerJobQueue::RunJob()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(!mJobList.IsEmpty());
-  MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob2::State::Initial);
+  MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob::State::Initial);
 
   RefPtr<Callback> callback = new Callback(this);
   mJobList[0]->Start(callback);
 }
 
-ServiceWorkerJobQueue2::ServiceWorkerJobQueue2()
+ServiceWorkerJobQueue::ServiceWorkerJobQueue()
 {
   AssertIsOnMainThread();
 }
 
 void
-ServiceWorkerJobQueue2::ScheduleJob(ServiceWorkerJob2* aJob)
+ServiceWorkerJobQueue::ScheduleJob(ServiceWorkerJob* aJob)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
   MOZ_ASSERT(!mJobList.Contains(aJob));
 
   if (mJobList.IsEmpty()) {
     mJobList.AppendElement(aJob);
     RunJob();
     return;
   }
 
-  MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob2::State::Started);
+  MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob::State::Started);
 
-  RefPtr<ServiceWorkerJob2>& tailJob = mJobList[mJobList.Length() - 1];
+  RefPtr<ServiceWorkerJob>& tailJob = mJobList[mJobList.Length() - 1];
   if (!tailJob->ResultCallbacksInvoked() && aJob->IsEquivalentTo(tailJob)) {
     tailJob->StealResultCallbacksFrom(aJob);
     return;
   }
 
   mJobList.AppendElement(aJob);
 }
 
 void
-ServiceWorkerJobQueue2::CancelAll()
+ServiceWorkerJobQueue::CancelAll()
 {
   AssertIsOnMainThread();
 
-  for (RefPtr<ServiceWorkerJob2>& job : mJobList) {
+  for (RefPtr<ServiceWorkerJob>& job : mJobList) {
     job->Cancel();
   }
 
   // Remove jobs that are queued but not started since they should never
   // run after being canceled.  This means throwing away all jobs except
   // for the job at the front of the list.
   if (!mJobList.IsEmpty()) {
-    MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob2::State::Started);
+    MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob::State::Started);
     mJobList.TruncateLength(1);
   }
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerJobQueue.h b/dom/workers/ServiceWorkerJobQueue.h
--- a/dom/workers/ServiceWorkerJobQueue.h
+++ b/dom/workers/ServiceWorkerJobQueue.h
@@ -9,41 +9,41 @@
 
 #include "mozilla/RefPtr.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-class ServiceWorkerJob2;
+class ServiceWorkerJob;
 
-class ServiceWorkerJobQueue2 final
+class ServiceWorkerJobQueue final
 {
   class Callback;
 
-  nsTArray<RefPtr<ServiceWorkerJob2>> mJobList;
+  nsTArray<RefPtr<ServiceWorkerJob>> mJobList;
 
-  ~ServiceWorkerJobQueue2();
+  ~ServiceWorkerJobQueue();
 
   void
-  JobFinished(ServiceWorkerJob2* aJob);
+  JobFinished(ServiceWorkerJob* aJob);
 
   void
   RunJob();
 
 public:
-  ServiceWorkerJobQueue2();
+  ServiceWorkerJobQueue();
 
   void
-  ScheduleJob(ServiceWorkerJob2* aJob);
+  ScheduleJob(ServiceWorkerJob* aJob);
 
   void
   CancelAll();
 
-  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue2)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue)
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkerjobqueue_h
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -144,17 +144,17 @@ struct ServiceWorkerManager::Registratio
   // memmoves associated with inserting stuff in the middle of the array.
   nsTArray<nsCString> mOrderedScopes;
 
   // Scope to registration.
   // The scope should be a fully qualified valid URL.
   nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerRegistrationInfo> mInfos;
 
   // Maps scopes to job queues.
-  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerJobQueue2> mJobQueues;
+  nsRefPtrHashtable<nsCStringHashKey, ServiceWorkerJobQueue> mJobQueues;
 
   // Map scopes to scheduled update timers.
   nsInterfaceHashtable<nsCStringHashKey, nsITimer> mUpdateTimers;
 };
 
 namespace {
 
 nsresult
@@ -470,40 +470,40 @@ public:
   {
     AssertIsOnMainThread();
     mRegistration->FinishActivate(mSuccess);
     mRegistration = nullptr;
     return NS_OK;
   }
 };
 
-class ServiceWorkerResolveWindowPromiseOnRegisterCallback final : public ServiceWorkerJob2::Callback
+class ServiceWorkerResolveWindowPromiseOnRegisterCallback final : public ServiceWorkerJob::Callback
 {
   RefPtr<nsPIDOMWindowInner> mWindow;
   // The promise "returned" by the call to Update up to
   // navigator.serviceWorker.register().
   RefPtr<Promise> mPromise;
 
   ~ServiceWorkerResolveWindowPromiseOnRegisterCallback()
   {}
 
   virtual void
-  JobFinished(ServiceWorkerJob2* aJob, ErrorResult& aStatus) override
+  JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aJob);
 
     if (aStatus.Failed()) {
       mPromise->MaybeReject(aStatus);
       return;
     }
 
-    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob2::Type::Register);
-    RefPtr<ServiceWorkerRegisterJob2> registerJob =
-      static_cast<ServiceWorkerRegisterJob2*>(aJob);
+    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob::Type::Register);
+    RefPtr<ServiceWorkerRegisterJob> registerJob =
+      static_cast<ServiceWorkerRegisterJob*>(aJob);
     RefPtr<ServiceWorkerRegistrationInfo> reg = registerJob->GetRegistration();
 
     RefPtr<ServiceWorkerRegistrationMainThread> swr =
       mWindow->GetServiceWorkerRegistration(NS_ConvertUTF8toUTF16(reg->mScope));
     mPromise->MaybeResolve(swr);
   }
 
 public:
@@ -863,36 +863,36 @@ ServiceWorkerManager::Register(mozIDOMWi
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(documentPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   AddRegisteringDocument(cleanedScope, doc);
 
-  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey,
-                                                             cleanedScope);
+  RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey,
+                                                            cleanedScope);
 
   RefPtr<ServiceWorkerResolveWindowPromiseOnRegisterCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnRegisterCallback(window, promise);
 
   nsCOMPtr<nsILoadGroup> docLoadGroup = doc->GetDocumentLoadGroup();
   RefPtr<WorkerLoadInfo::InterfaceRequestor> ir =
     new WorkerLoadInfo::InterfaceRequestor(documentPrincipal, docLoadGroup);
   ir->MaybeAddTabChild(docLoadGroup);
 
   // Create a load group that is separate from, yet related to, the document's load group.
   // This allows checks for interfaces like nsILoadContext to yield the values used by the
   // the document, yet will not cancel the update job if the document's load group is cancelled.
   nsCOMPtr<nsILoadGroup> loadGroup = do_CreateInstance(NS_LOADGROUP_CONTRACTID);
   MOZ_ALWAYS_SUCCEEDS(loadGroup->SetNotificationCallbacks(ir));
 
-  RefPtr<ServiceWorkerRegisterJob2> job =
-    new ServiceWorkerRegisterJob2(documentPrincipal, cleanedScope, spec,
-                                  loadGroup);
+  RefPtr<ServiceWorkerRegisterJob> job =
+    new ServiceWorkerRegisterJob(documentPrincipal, cleanedScope, spec,
+                                 loadGroup);
   job->AppendResultCallback(cb);
   queue->ScheduleJob(job);
 
   AssertIsOnMainThread();
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
@@ -1486,46 +1486,46 @@ ServiceWorkerManager::GetActiveWorkerInf
     return nullptr;
   }
 
   return registration->mActiveWorker;
 }
 
 namespace {
 
-class UnregisterJobCallback final : public ServiceWorkerJob2::Callback
+class UnregisterJobCallback final : public ServiceWorkerJob::Callback
 {
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
 
   ~UnregisterJobCallback()
   {
   }
 
 public:
   explicit UnregisterJobCallback(nsIServiceWorkerUnregisterCallback* aCallback)
     : mCallback(aCallback)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mCallback);
   }
 
   void
-  JobFinished(ServiceWorkerJob2* aJob, ErrorResult& aStatus)
+  JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aJob);
 
     if (aStatus.Failed()) {
       mCallback->UnregisterFailed();
       return;
     }
 
-    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob2::Type::Unregister);
-    RefPtr<ServiceWorkerUnregisterJob2> unregisterJob =
-      static_cast<ServiceWorkerUnregisterJob2*>(aJob);
+    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob::Type::Unregister);
+    RefPtr<ServiceWorkerUnregisterJob> unregisterJob =
+      static_cast<ServiceWorkerUnregisterJob*>(aJob);
     mCallback->UnregisterSucceeded(unregisterJob->GetResult());
   }
 
   NS_INLINE_DECL_REFCOUNTING(UnregisterJobCallback)
 };
 
 } // anonymous namespace
 
@@ -1554,20 +1554,20 @@ ServiceWorkerManager::Unregister(nsIPrin
 
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(aPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   NS_ConvertUTF16toUTF8 scope(aScope);
-  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey, scope);
-
-  RefPtr<ServiceWorkerUnregisterJob2> job =
-    new ServiceWorkerUnregisterJob2(aPrincipal, scope, true /* send to parent */);
+  RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey, scope);
+
+  RefPtr<ServiceWorkerUnregisterJob> job =
+    new ServiceWorkerUnregisterJob(aPrincipal, scope, true /* send to parent */);
 
   if (aCallback) {
     RefPtr<UnregisterJobCallback> cb = new UnregisterJobCallback(aCallback);
     job->AppendResultCallback(cb);
   }
 
   queue->ScheduleJob(job);
   return NS_OK;
@@ -1594,40 +1594,40 @@ ServiceWorkerManager::NotifyUnregister(n
 
   nsAutoCString scopeKey;
   rv = PrincipalToScopeKey(aPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   NS_ConvertUTF16toUTF8 scope(aScope);
-  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey, scope);
-
-  RefPtr<ServiceWorkerUnregisterJob2> job =
-    new ServiceWorkerUnregisterJob2(aPrincipal, scope,
+  RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey, scope);
+
+  RefPtr<ServiceWorkerUnregisterJob> job =
+    new ServiceWorkerUnregisterJob(aPrincipal, scope,
                                     false /* send to parent */);
 
   queue->ScheduleJob(job);
   return NS_OK;
 }
 
-already_AddRefed<ServiceWorkerJobQueue2>
+already_AddRefed<ServiceWorkerJobQueue>
 ServiceWorkerManager::GetOrCreateJobQueue(const nsACString& aKey,
                                           const nsACString& aScope)
 {
   MOZ_ASSERT(!aKey.IsEmpty());
   ServiceWorkerManager::RegistrationDataPerPrincipal* data;
   if (!mRegistrationInfos.Get(aKey, &data)) {
     data = new RegistrationDataPerPrincipal();
     mRegistrationInfos.Put(aKey, data);
   }
 
-  RefPtr<ServiceWorkerJobQueue2> queue;
+  RefPtr<ServiceWorkerJobQueue> queue;
   if (!data->mJobQueues.Get(aScope, getter_AddRefs(queue))) {
-    RefPtr<ServiceWorkerJobQueue2> newQueue = new ServiceWorkerJobQueue2();
+    RefPtr<ServiceWorkerJobQueue> newQueue = new ServiceWorkerJobQueue();
     queue = newQueue;
     data->mJobQueues.Put(aScope, newQueue.forget());
   }
 
   return queue.forget();
 }
 
 /* static */
@@ -2892,57 +2892,57 @@ ServiceWorkerManager::SoftUpdate(const P
   if (!newest) {
     return;
   }
 
   // "If the registration queue for registration is empty, invoke Update algorithm,
   // or its equivalent, with client, registration as its argument."
   // TODO(catalinb): We don't implement the force bypass cache flag.
   // See: https://github.com/slightlyoff/ServiceWorker/issues/759
-  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey,
-                                                             aScope);
-
-  RefPtr<ServiceWorkerUpdateJob2> job =
-    new ServiceWorkerUpdateJob2(principal, registration->mScope,
-                                newest->ScriptSpec(), nullptr);
+  RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey,
+                                                            aScope);
+
+  RefPtr<ServiceWorkerUpdateJob> job =
+    new ServiceWorkerUpdateJob(principal, registration->mScope,
+                               newest->ScriptSpec(), nullptr);
   queue->ScheduleJob(job);
 }
 
 namespace {
 
-class UpdateJobCallback final : public ServiceWorkerJob2::Callback
+class UpdateJobCallback final : public ServiceWorkerJob::Callback
 {
   RefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
 
   ~UpdateJobCallback()
   {
   }
 
 public:
   explicit UpdateJobCallback(ServiceWorkerUpdateFinishCallback* aCallback)
     : mCallback(aCallback)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mCallback);
   }
 
   void
-  JobFinished(ServiceWorkerJob2* aJob, ErrorResult& aStatus)
+  JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aJob);
 
     if (aStatus.Failed()) {
       mCallback->UpdateFailed(aStatus);
       return;
     }
 
-    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob2::Type::Update);
-    RefPtr<ServiceWorkerUpdateJob2> updateJob =
-      static_cast<ServiceWorkerUpdateJob2*>(aJob);
+    MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob::Type::Update);
+    RefPtr<ServiceWorkerUpdateJob> updateJob =
+      static_cast<ServiceWorkerUpdateJob*>(aJob);
     RefPtr<ServiceWorkerRegistrationInfo> reg = updateJob->GetRegistration();
     mCallback->UpdateSucceeded(reg);
   }
 
   NS_INLINE_DECL_REFCOUNTING(UpdateJobCallback)
 };
 } // anonymous namespace
 
@@ -2975,23 +2975,23 @@ ServiceWorkerManager::Update(nsIPrincipa
     aCallback->UpdateFailed(error);
 
     // In case the callback does not consume the exception
     error.SuppressException();
 
     return;
   }
 
-  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey, aScope);
+  RefPtr<ServiceWorkerJobQueue> queue = GetOrCreateJobQueue(scopeKey, aScope);
 
   // "Invoke Update algorithm, or its equivalent, with client, registration as
   // its argument."
-  RefPtr<ServiceWorkerUpdateJob2> job =
-    new ServiceWorkerUpdateJob2(aPrincipal, registration->mScope,
-                                newest->ScriptSpec(), nullptr);
+  RefPtr<ServiceWorkerUpdateJob> job =
+    new ServiceWorkerUpdateJob(aPrincipal, registration->mScope,
+                               newest->ScriptSpec(), nullptr);
 
   RefPtr<UpdateJobCallback> cb = new UpdateJobCallback(aCallback);
   job->AppendResultCallback(cb);
 
   queue->ScheduleJob(job);
 }
 
 namespace {
@@ -3436,17 +3436,17 @@ ServiceWorkerManager::GetAllRegistration
 // MUST ONLY BE CALLED FROM Remove(), RemoveAll() and RemoveAllRegistrations()!
 void
 ServiceWorkerManager::ForceUnregister(RegistrationDataPerPrincipal* aRegistrationData,
                                       ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistrationData);
   MOZ_ASSERT(aRegistration);
 
-  RefPtr<ServiceWorkerJobQueue2> queue;
+  RefPtr<ServiceWorkerJobQueue> queue;
   aRegistrationData->mJobQueues.Get(aRegistration->mScope, getter_AddRefs(queue));
   if (queue) {
     queue->CancelAll();
   }
 
   nsCOMPtr<nsITimer> timer =
     aRegistrationData->mUpdateTimers.Get(aRegistration->mScope);
   if (timer) {
@@ -3751,17 +3751,17 @@ ServiceWorkerManager::Observe(nsISupport
     for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
       for (auto it2 = it1.UserData()->mUpdateTimers.Iter(); !it2.Done(); it2.Next()) {
         nsCOMPtr<nsITimer> timer = it2.UserData();
         timer->Cancel();
       }
       it1.UserData()->mUpdateTimers.Clear();
 
       for (auto it2 = it1.UserData()->mJobQueues.Iter(); !it2.Done(); it2.Next()) {
-        RefPtr<ServiceWorkerJobQueue2> queue = it2.UserData();
+        RefPtr<ServiceWorkerJobQueue> queue = it2.UserData();
         queue->CancelAll();
       }
       it1.UserData()->mJobQueues.Clear();
     }
 
     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
     if (obs) {
       obs->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -42,17 +42,17 @@ namespace dom {
 
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
 class ServiceWorker;
 class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
-class ServiceWorkerJobQueue2;
+class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 
 class ServiceWorkerRegistrationInfo final
   : public nsIServiceWorkerRegistrationInfo
 {
   uint32_t mControlledDocumentsCounter;
 
@@ -315,20 +315,20 @@ public:
 class ServiceWorkerManager final
   : public nsIServiceWorkerManager
   , public nsIIPCBackgroundChildCreateCallback
   , public nsIObserver
 {
   friend class GetReadyPromiseRunnable;
   friend class GetRegistrationsRunnable;
   friend class GetRegistrationRunnable;
-  friend class ServiceWorkerJob2;
+  friend class ServiceWorkerJob;
   friend class ServiceWorkerRegistrationInfo;
-  friend class ServiceWorkerUnregisterJob2;
-  friend class ServiceWorkerUpdateJob2;
+  friend class ServiceWorkerUnregisterJob;
+  friend class ServiceWorkerUpdateJob;
   friend class UpdateTimerCallback;
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
   NS_DECL_NSIOBSERVER
 
@@ -497,17 +497,17 @@ public:
 
 private:
   ServiceWorkerManager();
   ~ServiceWorkerManager();
 
   void
   Init();
 
-  already_AddRefed<ServiceWorkerJobQueue2>
+  already_AddRefed<ServiceWorkerJobQueue>
   GetOrCreateJobQueue(const nsACString& aOriginSuffix,
                       const nsACString& aScope);
 
   void
   MaybeRemoveRegistrationInfo(const nsACString& aScopeKey);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetRegistration(const nsACString& aScopeKey,
diff --git a/dom/workers/ServiceWorkerRegisterJob.cpp b/dom/workers/ServiceWorkerRegisterJob.cpp
--- a/dom/workers/ServiceWorkerRegisterJob.cpp
+++ b/dom/workers/ServiceWorkerRegisterJob.cpp
@@ -7,27 +7,27 @@
 #include "ServiceWorkerRegisterJob.h"
 
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-ServiceWorkerRegisterJob2::ServiceWorkerRegisterJob2(nsIPrincipal* aPrincipal,
-                                                     const nsACString& aScope,
-                                                     const nsACString& aScriptSpec,
-                                                     nsILoadGroup* aLoadGroup)
-  : ServiceWorkerUpdateJob2(ServiceWorkerJob2::Type::Register,
-                            aPrincipal, aScope, aScriptSpec, aLoadGroup)
+ServiceWorkerRegisterJob::ServiceWorkerRegisterJob(nsIPrincipal* aPrincipal,
+                                                   const nsACString& aScope,
+                                                   const nsACString& aScriptSpec,
+                                                   nsILoadGroup* aLoadGroup)
+  : ServiceWorkerUpdateJob(Type::Register, aPrincipal, aScope, aScriptSpec,
+                           aLoadGroup)
 {
 }
 
 void
-ServiceWorkerRegisterJob2::AsyncExecute()
+ServiceWorkerRegisterJob::AsyncExecute()
 {
   AssertIsOnMainThread();
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
@@ -53,15 +53,15 @@ ServiceWorkerRegisterJob2::AsyncExecute(
   } else {
     registration = swm->CreateNewRegistration(mScope, mPrincipal);
   }
 
   SetRegistration(registration);
   Update();
 }
 
-ServiceWorkerRegisterJob2::~ServiceWorkerRegisterJob2()
+ServiceWorkerRegisterJob::~ServiceWorkerRegisterJob()
 {
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerRegisterJob.h b/dom/workers/ServiceWorkerRegisterJob.h
--- a/dom/workers/ServiceWorkerRegisterJob.h
+++ b/dom/workers/ServiceWorkerRegisterJob.h
@@ -9,32 +9,32 @@
 
 #include "ServiceWorkerUpdateJob.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
 // The register job.  This implements the steps in the spec Register algorithm,
-// but then uses ServiceWorkerUpdateJob2 to implement the Update and Install
+// but then uses ServiceWorkerUpdateJob to implement the Update and Install
 // spec algorithms.
-class ServiceWorkerRegisterJob2 final : public ServiceWorkerUpdateJob2
+class ServiceWorkerRegisterJob final : public ServiceWorkerUpdateJob
 {
 public:
-  ServiceWorkerRegisterJob2(nsIPrincipal* aPrincipal,
-                            const nsACString& aScope,
-                            const nsACString& aScriptSpec,
-                            nsILoadGroup* aLoadGroup);
+  ServiceWorkerRegisterJob(nsIPrincipal* aPrincipal,
+                           const nsACString& aScope,
+                           const nsACString& aScriptSpec,
+                           nsILoadGroup* aLoadGroup);
 
 private:
   // Implement the Register algorithm steps and then call the parent class
   // Update() to complete the job execution.
   virtual void
   AsyncExecute() override;
 
-  virtual ~ServiceWorkerRegisterJob2();
+  virtual ~ServiceWorkerRegisterJob();
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkerregisterjob_h
diff --git a/dom/workers/ServiceWorkerUnregisterJob.cpp b/dom/workers/ServiceWorkerUnregisterJob.cpp
--- a/dom/workers/ServiceWorkerUnregisterJob.cpp
+++ b/dom/workers/ServiceWorkerUnregisterJob.cpp
@@ -6,37 +6,37 @@
 
 #include "ServiceWorkerUnregisterJob.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
 
-ServiceWorkerUnregisterJob2::ServiceWorkerUnregisterJob2(nsIPrincipal* aPrincipal,
-                                                         const nsACString& aScope,
-                                                         bool aSendToParent)
-  : ServiceWorkerJob2(Type::Unregister, aPrincipal, aScope, EmptyCString())
+ServiceWorkerUnregisterJob::ServiceWorkerUnregisterJob(nsIPrincipal* aPrincipal,
+                                                       const nsACString& aScope,
+                                                       bool aSendToParent)
+  : ServiceWorkerJob(Type::Unregister, aPrincipal, aScope, EmptyCString())
   , mResult(false)
   , mSendToParent(aSendToParent)
 {
 }
 
 bool
-ServiceWorkerUnregisterJob2::GetResult() const
+ServiceWorkerUnregisterJob::GetResult() const
 {
   AssertIsOnMainThread();
   return mResult;
 }
-ServiceWorkerUnregisterJob2::~ServiceWorkerUnregisterJob2()
+ServiceWorkerUnregisterJob::~ServiceWorkerUnregisterJob()
 {
 }
 
 void
-ServiceWorkerUnregisterJob2::AsyncExecute()
+ServiceWorkerUnregisterJob::AsyncExecute()
 {
   AssertIsOnMainThread();
 
   if (Canceled()) {
     Finish(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
diff --git a/dom/workers/ServiceWorkerUnregisterJob.h b/dom/workers/ServiceWorkerUnregisterJob.h
--- a/dom/workers/ServiceWorkerUnregisterJob.h
+++ b/dom/workers/ServiceWorkerUnregisterJob.h
@@ -8,28 +8,28 @@
 #define mozilla_dom_workers_serviceworkerunregisterjob_h
 
 #include "ServiceWorkerJob.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-class ServiceWorkerUnregisterJob2 final : public ServiceWorkerJob2
+class ServiceWorkerUnregisterJob final : public ServiceWorkerJob
 {
 public:
-  ServiceWorkerUnregisterJob2(nsIPrincipal* aPrincipal,
-                              const nsACString& aScope,
-                              bool aSendToParent);
+  ServiceWorkerUnregisterJob(nsIPrincipal* aPrincipal,
+                             const nsACString& aScope,
+                             bool aSendToParent);
 
   bool
   GetResult() const;
 
 private:
-  virtual ~ServiceWorkerUnregisterJob2();
+  virtual ~ServiceWorkerUnregisterJob();
 
   virtual void
   AsyncExecute() override;
 
   bool mResult;
   bool mSendToParent;
 };
 
diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
--- a/dom/workers/ServiceWorkerUpdateJob.cpp
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -8,50 +8,50 @@
 
 #include "ServiceWorkerScriptCache.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
-class ServiceWorkerUpdateJob2::CompareCallback final : public serviceWorkerScriptCache::CompareCallback
+class ServiceWorkerUpdateJob::CompareCallback final : public serviceWorkerScriptCache::CompareCallback
 {
-  RefPtr<ServiceWorkerUpdateJob2> mJob;
+  RefPtr<ServiceWorkerUpdateJob> mJob;
 
   ~CompareCallback()
   {
   }
 
 public:
-  explicit CompareCallback(ServiceWorkerUpdateJob2* aJob)
+  explicit CompareCallback(ServiceWorkerUpdateJob* aJob)
     : mJob(aJob)
   {
     MOZ_ASSERT(mJob);
   }
 
   virtual void
   ComparisonResult(nsresult aStatus,
                    bool aInCacheAndEqual,
                    const nsAString& aNewCacheName,
                    const nsACString& aMaxScope) override
   {
     mJob->ComparisonResult(aStatus, aInCacheAndEqual, aNewCacheName, aMaxScope);
   }
 
-  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob2::CompareCallback, override)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob::CompareCallback, override)
 };
 
-class ServiceWorkerUpdateJob2::ContinueUpdateRunnable final : public LifeCycleEventCallback
+class ServiceWorkerUpdateJob::ContinueUpdateRunnable final : public LifeCycleEventCallback
 {
-  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> mJob;
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob> mJob;
   bool mSuccess;
 
 public:
-  explicit ContinueUpdateRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob2>& aJob)
+  explicit ContinueUpdateRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob>& aJob)
     : mJob(aJob)
     , mSuccess(false)
   {
     AssertIsOnMainThread();
   }
 
   void
   SetResult(bool aResult) override
@@ -64,23 +64,23 @@ public:
   {
     AssertIsOnMainThread();
     mJob->ContinueUpdateAfterScriptEval(mSuccess);
     mJob = nullptr;
     return NS_OK;
   }
 };
 
-class ServiceWorkerUpdateJob2::ContinueInstallRunnable final : public LifeCycleEventCallback
+class ServiceWorkerUpdateJob::ContinueInstallRunnable final : public LifeCycleEventCallback
 {
-  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> mJob;
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob> mJob;
   bool mSuccess;
 
 public:
-  explicit ContinueInstallRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob2>& aJob)
+  explicit ContinueInstallRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob>& aJob)
     : mJob(aJob)
     , mSuccess(false)
   {
     AssertIsOnMainThread();
   }
 
   void
   SetResult(bool aResult) override
@@ -93,49 +93,49 @@ public:
   {
     AssertIsOnMainThread();
     mJob->ContinueAfterInstallEvent(mSuccess);
     mJob = nullptr;
     return NS_OK;
   }
 };
 
-ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
-                        const nsACString& aScope,
-                        const nsACString& aScriptSpec,
-                        nsILoadGroup* aLoadGroup)
-  : ServiceWorkerJob2(Type::Update, aPrincipal, aScope, aScriptSpec)
+ServiceWorkerUpdateJob::ServiceWorkerUpdateJob(nsIPrincipal* aPrincipal,
+                                               const nsACString& aScope,
+                                               const nsACString& aScriptSpec,
+                                               nsILoadGroup* aLoadGroup)
+  : ServiceWorkerJob(Type::Update, aPrincipal, aScope, aScriptSpec)
   , mLoadGroup(aLoadGroup)
 {
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
-ServiceWorkerUpdateJob2::GetRegistration() const
+ServiceWorkerUpdateJob::GetRegistration() const
 {
   AssertIsOnMainThread();
   RefPtr<ServiceWorkerRegistrationInfo> ref = mRegistration;
   return ref.forget();
 }
 
-ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(Type aType,
-                                                 nsIPrincipal* aPrincipal,
-                                                 const nsACString& aScope,
-                                                 const nsACString& aScriptSpec,
-                                                 nsILoadGroup* aLoadGroup)
-  : ServiceWorkerJob2(aType, aPrincipal, aScope, aScriptSpec)
+ServiceWorkerUpdateJob::ServiceWorkerUpdateJob(Type aType,
+                                               nsIPrincipal* aPrincipal,
+                                               const nsACString& aScope,
+                                               const nsACString& aScriptSpec,
+                                               nsILoadGroup* aLoadGroup)
+  : ServiceWorkerJob(aType, aPrincipal, aScope, aScriptSpec)
   , mLoadGroup(aLoadGroup)
 {
 }
 
-ServiceWorkerUpdateJob2::~ServiceWorkerUpdateJob2()
+ServiceWorkerUpdateJob::~ServiceWorkerUpdateJob()
 {
 }
 
 void
-ServiceWorkerUpdateJob2::FailUpdateJob(ErrorResult& aRv)
+ServiceWorkerUpdateJob::FailUpdateJob(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aRv.Failed());
 
   if (mRegistration) {
     if (mServiceWorker) {
       mServiceWorker->UpdateState(ServiceWorkerState::Redundant);
       serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
@@ -162,24 +162,24 @@ ServiceWorkerUpdateJob2::FailUpdateJob(E
 
   mServiceWorker = nullptr;
   mRegistration = nullptr;
 
   Finish(aRv);
 }
 
 void
-ServiceWorkerUpdateJob2::FailUpdateJob(nsresult aRv)
+ServiceWorkerUpdateJob::FailUpdateJob(nsresult aRv)
 {
   ErrorResult rv(aRv);
   FailUpdateJob(rv);
 }
 
 void
-ServiceWorkerUpdateJob2::AsyncExecute()
+ServiceWorkerUpdateJob::AsyncExecute()
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(GetType() == Type::Update);
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
@@ -207,27 +207,27 @@ ServiceWorkerUpdateJob2::AsyncExecute()
     return;
   }
 
   SetRegistration(registration);
   Update();
 }
 
 void
-ServiceWorkerUpdateJob2::SetRegistration(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerUpdateJob::SetRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
   AssertIsOnMainThread();
 
   MOZ_ASSERT(!mRegistration);
   MOZ_ASSERT(aRegistration);
   mRegistration = aRegistration;
 }
 
 void
-ServiceWorkerUpdateJob2::Update()
+ServiceWorkerUpdateJob::Update()
 {
   AssertIsOnMainThread();
 
   // SetRegistration() must be called before Update().
   MOZ_ASSERT(mRegistration);
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
@@ -253,20 +253,20 @@ ServiceWorkerUpdateJob2::Update()
                                       callback, mLoadGroup);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     FailUpdateJob(rv);
     return;
   }
 }
 
 void
-ServiceWorkerUpdateJob2::ComparisonResult(nsresult aStatus,
-                                          bool aInCacheAndEqual,
-                                          const nsAString& aNewCacheName,
-                                          const nsACString& aMaxScope)
+ServiceWorkerUpdateJob::ComparisonResult(nsresult aStatus,
+                                         bool aInCacheAndEqual,
+                                         const nsAString& aNewCacheName,
+                                         const nsACString& aMaxScope)
 {
   AssertIsOnMainThread();
 
   if (NS_WARN_IF(Canceled())) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
@@ -344,32 +344,32 @@ ServiceWorkerUpdateJob2::ComparisonResul
 
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_UPDATED, 1);
 
   MOZ_ASSERT(!mServiceWorker);
   mServiceWorker = new ServiceWorkerInfo(mRegistration->mPrincipal,
                                          mRegistration->mScope,
                                          mScriptSpec, aNewCacheName);
 
-  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> handle(
-      new nsMainThreadPtrHolder<ServiceWorkerUpdateJob2>(this));
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
+      new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueUpdateRunnable(handle);
 
   ServiceWorkerPrivate* workerPrivate = mServiceWorker->WorkerPrivate();
   MOZ_ASSERT(workerPrivate);
   rv = workerPrivate->CheckScriptEvaluation(callback);
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 }
 
 void
-ServiceWorkerUpdateJob2::ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult)
+ServiceWorkerUpdateJob::ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult)
 {
   AssertIsOnMainThread();
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
@@ -382,17 +382,17 @@ ServiceWorkerUpdateJob2::ContinueUpdateA
     FailUpdateJob(error);
     return;
   }
 
   Install();
 }
 
 void
-ServiceWorkerUpdateJob2::Install()
+ServiceWorkerUpdateJob::Install()
 {
   AssertIsOnMainThread();
 
   if (Canceled()) {
     return FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
   }
 
   MOZ_ASSERT(!mRegistration->mInstallingWorker);
@@ -416,34 +416,34 @@ ServiceWorkerUpdateJob2::Install()
       swm,
       &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
       mRegistration);
   NS_DispatchToMainThread(upr);
 
   // Call ContinueAfterInstallEvent(false) on main thread if the SW
   // script fails to load.
   nsCOMPtr<nsIRunnable> failRunnable = NS_NewRunnableMethodWithArgs<bool>
-    (this, &ServiceWorkerUpdateJob2::ContinueAfterInstallEvent, false);
+    (this, &ServiceWorkerUpdateJob::ContinueAfterInstallEvent, false);
 
-  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> handle(
-    new nsMainThreadPtrHolder<ServiceWorkerUpdateJob2>(this));
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
+    new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
 
   // Send the install event to the worker thread
   ServiceWorkerPrivate* workerPrivate =
     mRegistration->mInstallingWorker->WorkerPrivate();
   nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("install"),
                                                   callback, failRunnable);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ContinueAfterInstallEvent(false /* aSuccess */);
   }
 }
 
 void
-ServiceWorkerUpdateJob2::ContinueAfterInstallEvent(bool aInstallEventSuccess)
+ServiceWorkerUpdateJob::ContinueAfterInstallEvent(bool aInstallEventSuccess)
 {
   if (Canceled()) {
     return FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
   }
 
   MOZ_ASSERT(mRegistration->mInstallingWorker);
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
diff --git a/dom/workers/ServiceWorkerUpdateJob.h b/dom/workers/ServiceWorkerUpdateJob.h
--- a/dom/workers/ServiceWorkerUpdateJob.h
+++ b/dom/workers/ServiceWorkerUpdateJob.h
@@ -13,37 +13,37 @@ namespace mozilla {
 namespace dom {
 namespace workers {
 
 // A job class that performs the Update and Install algorithms from the
 // service worker spec.  This class is designed to be inherited and customized
 // as a different job type.  This is necessary because the register job
 // performs largely the same operations as the update job, but has a few
 // different starting steps.
-class ServiceWorkerUpdateJob2 : public ServiceWorkerJob2
+class ServiceWorkerUpdateJob : public ServiceWorkerJob
 {
 public:
   // Construct an update job to be used only for updates.
-  ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
-                          const nsACString& aScope,
-                          const nsACString& aScriptSpec,
-                          nsILoadGroup* aLoadGroup);
+  ServiceWorkerUpdateJob(nsIPrincipal* aPrincipal,
+                         const nsACString& aScope,
+                         const nsACString& aScriptSpec,
+                         nsILoadGroup* aLoadGroup);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetRegistration() const;
 
 protected:
   // Construct an update job that is overriden as another job type.
-  ServiceWorkerUpdateJob2(Type aType,
-                          nsIPrincipal* aPrincipal,
-                          const nsACString& aScope,
-                          const nsACString& aScriptSpec,
-                          nsILoadGroup* aLoadGroup);
+  ServiceWorkerUpdateJob(Type aType,
+                         nsIPrincipal* aPrincipal,
+                         const nsACString& aScope,
+                         const nsACString& aScriptSpec,
+                         nsILoadGroup* aLoadGroup);
 
-  virtual ~ServiceWorkerUpdateJob2();
+  virtual ~ServiceWorkerUpdateJob();
 
   // FailUpdateJob() must be called if an update job needs Finish() with
   // an error.
   void
   FailUpdateJob(ErrorResult& aRv);
 
   void
   FailUpdateJob(nsresult aRv);
