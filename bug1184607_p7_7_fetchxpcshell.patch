# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b5fe25cb824850d085ffd616bc15908d58e848af
Bug 1184067 P7.7 Allow new Response() to be used in xpcshell tests. r=ehsan

diff --git a/dom/fetch/ChannelInfo.cpp b/dom/fetch/ChannelInfo.cpp
--- a/dom/fetch/ChannelInfo.cpp
+++ b/dom/fetch/ChannelInfo.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/ChannelInfo.h"
 #include "nsCOMPtr.h"
+#include "nsContentUtils.h"
 #include "nsIChannel.h"
 #include "nsIDocument.h"
 #include "nsIHttpChannel.h"
 #include "nsSerializationHelper.h"
 #include "mozilla/net/HttpBaseChannel.h"
 #include "mozilla/ipc/ChannelInfo.h"
 #include "nsIJARChannel.h"
 #include "nsJARChannel.h"
@@ -64,16 +65,30 @@ ChannelInfo::InitFromChannel(nsIChannel*
       redirectedURI->GetSpec(mRedirectedURISpec);
     }
   }
 
   mInited = true;
 }
 
 void
+ChannelInfo::InitFromChromeGlobal(nsIGlobalObject* aGlobal)
+{
+  MOZ_ASSERT(!mInited, "Cannot initialize the object twice");
+  MOZ_ASSERT(aGlobal);
+
+  MOZ_RELEASE_ASSERT(
+    nsContentUtils::IsSystemPrincipal(aGlobal->PrincipalOrNull()));
+
+  mSecurityInfo.Truncate();
+  mRedirected = false;
+  mInited = true;
+}
+
+void
 ChannelInfo::InitFromIPCChannelInfo(const ipc::IPCChannelInfo& aChannelInfo)
 {
   MOZ_ASSERT(!mInited, "Cannot initialize the object twice");
 
   mSecurityInfo = aChannelInfo.securityInfo();
   mRedirectedURISpec = aChannelInfo.redirectedURI();
   mRedirected = aChannelInfo.redirected();
 
diff --git a/dom/fetch/ChannelInfo.h b/dom/fetch/ChannelInfo.h
--- a/dom/fetch/ChannelInfo.h
+++ b/dom/fetch/ChannelInfo.h
@@ -7,16 +7,17 @@
 #ifndef mozilla_dom_ChannelInfo_h
 #define mozilla_dom_ChannelInfo_h
 
 #include "nsString.h"
 #include "nsCOMPtr.h"
 
 class nsIChannel;
 class nsIDocument;
+class nsIGlobalObject;
 class nsIURI;
 
 namespace mozilla {
 namespace ipc {
 class IPCChannelInfo;
 } // namespace ipc
 
 namespace dom {
@@ -64,16 +65,17 @@ public:
     mRedirectedURISpec = aRHS.mRedirectedURISpec;
     mInited = aRHS.mInited;
     mRedirected = aRHS.mRedirected;
     return *this;
   }
 
   void InitFromDocument(nsIDocument* aDoc);
   void InitFromChannel(nsIChannel* aChannel);
+  void InitFromChromeGlobal(nsIGlobalObject* aGlobal);
   void InitFromIPCChannelInfo(const IPCChannelInfo& aChannelInfo);
 
   // This restores every possible information stored from a previous channel
   // object on a new one.
   nsresult ResurrectInfoOnChannel(nsIChannel* aChannel);
 
   bool IsInitialized() const
   {
diff --git a/dom/fetch/Response.cpp b/dom/fetch/Response.cpp
--- a/dom/fetch/Response.cpp
+++ b/dom/fetch/Response.cpp
@@ -157,22 +157,25 @@ Response::Constructor(const GlobalObject
   }
 
   nsRefPtr<InternalResponse> internalResponse =
     new InternalResponse(aInit.mStatus, statusText);
 
   // Grab a valid channel info from the global so this response is 'valid' for
   // interception.
   if (NS_IsMainThread()) {
+    ChannelInfo info;
     nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(global);
-    MOZ_ASSERT(window);
-    nsIDocument* doc = window->GetExtantDoc();
-    MOZ_ASSERT(doc);
-    ChannelInfo info;
-    info.InitFromDocument(doc);
+    if (window) {
+      nsIDocument* doc = window->GetExtantDoc();
+      MOZ_ASSERT(doc);
+      info.InitFromDocument(doc);
+    } else {
+      info.InitFromChromeGlobal(global);
+    }
     internalResponse->InitChannelInfo(info);
   } else {
     workers::WorkerPrivate* worker = workers::GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(worker);
     internalResponse->InitChannelInfo(worker->GetChannelInfo());
   }
 
   nsRefPtr<Response> r = new Response(global, internalResponse);
