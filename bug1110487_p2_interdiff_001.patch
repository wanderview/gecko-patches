# HG changeset patch
# Parent 1617bc5e71983ff4845bbc6c848d29182d1a3459
# User Ben Kelly <ben@wanderview.com>
Bug 1110487 P2 interdiff 001

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -75,18 +75,18 @@ public:
   QuotaInitRunnable(Context* aContext,
                     Manager* aManager,
                     Action* aQuotaIOThreadAction)
     : mContext(aContext)
     , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
     , mManager(aManager)
     , mQuotaIOThreadAction(aQuotaIOThreadAction)
     , mInitiatingThread(NS_GetCurrentThread())
+    , mResult(NS_OK)
     , mState(STATE_INIT)
-    , mResult(NS_OK)
     , mNeedsQuotaRelease(false)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
@@ -150,20 +150,20 @@ private:
     mQuotaIOThreadAction = nullptr;
   }
 
   nsRefPtr<Context> mContext;
   nsRefPtr<ThreadsafeHandle> mThreadsafeHandle;
   nsRefPtr<Manager> mManager;
   nsRefPtr<Action> mQuotaIOThreadAction;
   nsCOMPtr<nsIThread> mInitiatingThread;
-  State mState;
   nsresult mResult;
   QuotaInfo mQuotaInfo;
   nsMainThreadPtrHandle<OfflineStorage> mOfflineStorage;
+  State mState;
   bool mNeedsQuotaRelease;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
@@ -314,18 +314,17 @@ Context::QuotaInitRunnable::Run()
         mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
       }
       mContext->OnQuotaInit(mResult, mQuotaInfo, mOfflineStorage);
       mState = STATE_COMPLETE;
 
       if (mNeedsQuotaRelease) {
         // Unlock the quota dir if we locked it previously
         nsCOMPtr<nsIRunnable> runnable = new QuotaReleaseRunnable(mQuotaInfo);
-        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
-          NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL)));
+        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(runnable)));
       }
 
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
     // -----
@@ -649,19 +648,21 @@ Context::Dispatch(nsIEventTarget* aTarge
 }
 
 void
 Context::CancelAll()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   mState = STATE_CONTEXT_CANCELED;
   mPendingActions.Clear();
-  ActivityList::ForwardIterator iter(mActivityList);
-  while (iter.HasMore()) {
-    iter.GetNext()->Cancel();
+  {
+    ActivityList::ForwardIterator iter(mActivityList);
+    while (iter.HasMore()) {
+      iter.GetNext()->Cancel();
+    }
   }
   AllowToClose();
 }
 
 void
 Context::Invalidate()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
@@ -679,23 +680,21 @@ Context::AllowToClose()
 }
 
 void
 Context::CancelForCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
   // Remove matching pending actions
-  nsTArray<PendingAction> remainingPendingActions;
-  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-    if (!mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
-      remainingPendingActions.AppendElement(mPendingActions[i]);
+  for (int32_t i = mPendingActions.Length() - 1; i >= 0; --i) {
+    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
+      mPendingActions.RemoveElementAt(i);
     }
   }
-  mPendingActions = Move(remainingPendingActions);
 
   // Cancel activities and let them remove themselves
   ActivityList::ForwardIterator iter(mActivityList);
   while (iter.HasMore()) {
     Activity* activity = iter.GetNext();
     if (activity->MatchesCacheId(aCacheId)) {
       activity->Cancel();
     }
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
--- a/dom/cache/Context.h
+++ b/dom/cache/Context.h
@@ -30,18 +30,30 @@ class OfflineStorage;
 // The Context class is RAII-style class for managing IO operations within the
 // Cache.
 //
 // When a Context is created it performs the complicated steps necessary to
 // initialize the QuotaManager.  Action objects dispatched on the Context are
 // delayed until this initialization is complete.  They are then allow to
 // execute on any specified thread.  Once all references to the Context are
 // gone, then the steps necessary to release the QuotaManager are performed.
-// Since pending Action objects reference the Context, this allows overlapping
-// IO to opportunistically run without re-initializing the QuotaManager again.
+// After initialization the Context holds a self reference, so it will stay
+// alive until one of three conditions occur:
+//
+//  1) The Manager will call Context::AllowToClose() when all of the actors
+//     have removed themselves as listener.  This means an idle context with
+//     no active DOM objects will close gracefully.
+//  2) The QuotaManager invalidates the storage area so it can delete the
+//     files.  In this case the OfflineStorage calls Cache::Invalidate() which
+//     in turn cancels all existing Action objects and then marks the Manager
+//     as invalid.
+//  3) Browser shutdown occurs and the Manager calls Context::CancelAll().
+//
+// In either case, though, the Action objects must be destroyed first to
+// allow the Context to be destroyed.
 //
 // While the Context performs operations asynchronously on threads, all of
 // methods in its public interface must be called on the same thread
 // originally used to create the Context.
 //
 // As an invariant, all Context objects must be destroyed before permitting
 // the "profile-before-change" shutdown event to complete.  This is ensured
 // via the code in ShutdownObserver.cpp.
@@ -55,16 +67,20 @@ public:
     friend class Context;
   public:
     void AllowToClose();
     void InvalidateAndAllowToClose();
   private:
     explicit ThreadsafeHandle(Context* aContext);
     ~ThreadsafeHandle();
 
+    // disallow copying
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
     void AllowToCloseOnOwningThread();
     void InvalidateAndAllowToCloseOnOwningThread();
 
     void ContextDestroyed(Context* aContext);
 
     // Cleared to allow the Context to close.  Only safe to access on
     // owning thread.
     nsRefPtr<Context> mStrongRef;
@@ -74,17 +90,21 @@ public:
     // safe to access on owning thread.
     Context* mWeakRef;
 
     nsCOMPtr<nsIThread> mOwningThread;
 
     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Context::ThreadsafeHandle)
   };
 
-  // Must call RemoveActivity() in its destructor
+  // Different objects hold references to the Context while some work is being
+  // performed asynchronously.  These objects must implement the Activity
+  // interface and register themselves with the AddActivity().  When they are
+  // destroyed they must call RemoveActivity().  This allows the Context to
+  // cancel any outstanding Activity work when the Context is cancelled.
   class Activity
   {
   public:
     virtual void Cancel() = 0;
     virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
   };
 
   static already_AddRefed<Context>
@@ -114,17 +134,17 @@ public:
   // cache ID.
   //
   // Only callable from the thread that created the Context.
   void CancelForCacheId(CacheId aCacheId);
 
   void AddActivity(Activity* aActivity);
   void RemoveActivity(Activity* aActivity);
 
-  const QuotaInfo
+  const QuotaInfo&
   GetQuotaInfo() const
   {
     return mQuotaInfo;
   }
 
 private:
   class QuotaInitRunnable;
   class ActionRunnable;
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
--- a/dom/cache/OfflineStorage.cpp
+++ b/dom/cache/OfflineStorage.cpp
@@ -23,61 +23,63 @@ NS_IMPL_ISUPPORTS(OfflineStorage, nsIOff
 
 // static
 already_AddRefed<OfflineStorage>
 OfflineStorage::Register(Context::ThreadsafeHandle* aContext,
                          const QuotaInfo& aQuotaInfo)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsRefPtr<QuotaManager> qm = QuotaManager::GetOrCreate();
+  QuotaManager* qm = QuotaManager::Get();
   if (NS_WARN_IF(!qm)) {
     return nullptr;
   }
 
+  nsRefPtr<Client> client = qm->GetClient(Client::DOMCACHE);
+
   nsRefPtr<OfflineStorage> storage =
-    new OfflineStorage(aContext, aQuotaInfo);
+    new OfflineStorage(aContext, aQuotaInfo, client);
 
   if (NS_WARN_IF(!qm->RegisterStorage(storage))) {
     return nullptr;
   }
 
   return storage.forget();
 }
 
 void
-OfflineStorage::SetDestroyCallback(nsIRunnable* aCallback)
+OfflineStorage::AddDestroyCallback(nsIRunnable* aCallback)
 {
-  MOZ_ASSERT(!mDestroyCallback);
-  mDestroyCallback = aCallback;
+  MOZ_ASSERT(aCallback);
+  MOZ_ASSERT(!mDestroyCallbacks.Contains(aCallback));
+  mDestroyCallbacks.AppendElement(aCallback);
 }
 
 OfflineStorage::OfflineStorage(Context::ThreadsafeHandle* aContext,
-                               const QuotaInfo& aQuotaInfo)
+                               const QuotaInfo& aQuotaInfo,
+                               Client* aClient)
   : mContext(aContext)
   , mQuotaInfo(aQuotaInfo)
+  , mClient(aClient)
 {
   MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mClient);
 
   mPersistenceType = PERSISTENCE_TYPE_DEFAULT;
   mGroup = mQuotaInfo.mGroup;
-  mClient = GetOrCreateQuotaClient();
 }
 
 OfflineStorage::~OfflineStorage()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  nsRefPtr<QuotaManager> qm = QuotaManager::GetOrCreate();
-  if (!qm) {
-    NS_WARNING("QuotaManager gone before Cache storage could unregister");
-    return;
-  }
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
   qm->UnregisterStorage(this);
-  if (mDestroyCallback) {
-    mDestroyCallback->Run();
+  for (uint32_t i = 0; i < mDestroyCallbacks.Length(); ++i) {
+    mDestroyCallbacks[i]->Run();
   }
 }
 
 NS_IMETHODIMP_(const nsACString&)
 OfflineStorage::Id()
 {
   MOZ_ASSERT(NS_IsMainThread());
   return mQuotaInfo.mStorageId;
diff --git a/dom/cache/OfflineStorage.h b/dom/cache/OfflineStorage.h
--- a/dom/cache/OfflineStorage.h
+++ b/dom/cache/OfflineStorage.h
@@ -6,41 +6,43 @@
 
 #ifndef mozilla_dom_cache_QuotaOfflineStorage_h
 #define mozilla_dom_cache_QuotaOfflineStorage_h
 
 #include "nsISupportsImpl.h"
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/dom/cache/Context.h"
 #include "nsIOfflineStorage.h"
+#include "nsTArray.h"
 
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class OfflineStorage MOZ_FINAL : public nsIOfflineStorage
 {
 public:
   static already_AddRefed<OfflineStorage>
   Register(Context::ThreadsafeHandle* aContext, const QuotaInfo& aQuotaInfo);
 
   void
-  SetDestroyCallback(nsIRunnable* aCallback);
+  AddDestroyCallback(nsIRunnable* aCallback);
 
 private:
   OfflineStorage(Context::ThreadsafeHandle* aContext,
-                 const QuotaInfo& aQuotaInfo);
+                 const QuotaInfo& aQuotaInfo,
+                 Client* aClient);
   ~OfflineStorage();
 
   nsRefPtr<Context::ThreadsafeHandle> mContext;
   const QuotaInfo mQuotaInfo;
   nsRefPtr<Client> mClient;
-  nsCOMPtr<nsIRunnable> mDestroyCallback;
+  nsTArray<nsCOMPtr<nsIRunnable>> mDestroyCallbacks;
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOFFLINESTORAGE
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -95,29 +95,16 @@ private:
     // always be destroyed on the main thread.
     MOZ_ASSERT(NS_IsMainThread());
   }
 };
 
 class CacheQuotaClient MOZ_FINAL : public Client
 {
 public:
-  static already_AddRefed<CacheQuotaClient>
-  GetOrCreate()
-  {
-    MOZ_ASSERT(NS_IsMainThread());
-    nsRefPtr<CacheQuotaClient> ref = sInstance;
-    if (!ref) {
-      ref = new CacheQuotaClient();
-      // cleared in ~CacheQuotaClient()
-      sInstance = ref.get();
-    }
-    return ref.forget();
-  }
-
   virtual Type
   GetType() MOZ_OVERRIDE
   {
     return DOMCACHE;
   }
 
   virtual nsresult
   InitOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
@@ -209,41 +196,41 @@ public:
   {
     // Nothing to do here as the Context handles cleaning everything up
     // automatically.
   }
 
   virtual bool
   IsFileServiceUtilized() MOZ_OVERRIDE
   {
-    return true;
+    return false;
   }
 
   virtual bool
   IsTransactionServiceActivated() MOZ_OVERRIDE
   {
     return true;
   }
 
   virtual void
   WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
                             nsIRunnable* aCallback) MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(!aStorages.IsEmpty());
 
     nsCOMPtr<nsIRunnable> callback =
-      new StoragesDestroyedRunnable(aStorages.Length(),aCallback);
+      new StoragesDestroyedRunnable(aStorages.Length(), aCallback);
 
     for (uint32_t i = 0; i < aStorages.Length(); ++i) {
       MOZ_ASSERT(aStorages[i]->GetClient());
       MOZ_ASSERT(aStorages[i]->GetClient()->GetType() == Client::DOMCACHE);
       nsRefPtr<OfflineStorage> storage =
         static_cast<OfflineStorage*>(aStorages[i]);
-      storage->SetDestroyCallback(callback);
+      storage->AddDestroyCallback(callback);
     }
   }
 
 
   virtual void
   ShutdownTransactionService() MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
@@ -251,36 +238,28 @@ public:
     // spins the event loop and synchronously shuts down all Managers
     Manager::ShutdownAllOnMainThread();
   }
 
 private:
   ~CacheQuotaClient()
   {
     MOZ_ASSERT(NS_IsMainThread());
-    MOZ_ASSERT(sInstance == this);
-    sInstance = nullptr;
   }
 
-  // Weak ref set in GetOrCreate() and cleared in destructor.  All
-  // access on main thread.
-  static CacheQuotaClient* sInstance;
-
   NS_INLINE_DECL_REFCOUNTING(CacheQuotaClient, MOZ_OVERRIDE)
 };
 
-CacheQuotaClient* CacheQuotaClient::sInstance = nullptr;
-
 } // anonymous namespace;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-already_AddRefed<quota::Client> GetOrCreateQuotaClient()
+already_AddRefed<quota::Client> CreateQuotaClient()
 {
-  nsRefPtr<CacheQuotaClient> ref = CacheQuotaClient::GetOrCreate();
+  nsRefPtr<CacheQuotaClient> ref = new CacheQuotaClient();
   return ref.forget();
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/QuotaClient.h b/dom/cache/QuotaClient.h
--- a/dom/cache/QuotaClient.h
+++ b/dom/cache/QuotaClient.h
@@ -10,15 +10,15 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/quota/Client.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 already_AddRefed<quota::Client>
-GetOrCreateQuotaClient();
+CreateQuotaClient();
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_QuotaClient_h
diff --git a/dom/cache/test/mochitest/driver.js b/dom/cache/test/mochitest/driver.js
--- a/dom/cache/test/mochitest/driver.js
+++ b/dom/cache/test/mochitest/driver.js
@@ -20,16 +20,17 @@ function runTests(testFile) {
                 ["dom.serviceWorkers.testing.enabled", true],
                 ["dom.serviceWorkers.exemptFromPerDomainMax", true]]
       }, function() {
         resolve();
       });
     });
   }
 
+  // adapted from dom/indexedDB/test/helpers.js
   function clearStorage() {
     return new Promise(function(resolve, reject) {
       var principal = SpecialPowers.wrap(document).nodePrincipal;
       var appId, inBrowser;
       var nsIPrincipal = SpecialPowers.Components.interfaces.nsIPrincipal;
       if (principal.appId != nsIPrincipal.UNKNOWN_APP_ID &&
           principal.appId != nsIPrincipal.NO_APP_ID) {
         appId = principal.appId;
diff --git a/dom/quota/QuotaManager.cpp b/dom/quota/QuotaManager.cpp
--- a/dom/quota/QuotaManager.cpp
+++ b/dom/quota/QuotaManager.cpp
@@ -1426,17 +1426,17 @@ QuotaManager::Init()
   NS_ASSERTION(mClients.Capacity() == Client::TYPE_MAX,
                "Should be using an auto array with correct capacity!");
 
   nsRefPtr<Client> idbClient = indexedDB::CreateQuotaClient();
 
   // Register clients.
   mClients.AppendElement(idbClient);
   mClients.AppendElement(asmjscache::CreateClient());
-  mClients.AppendElement(cache::GetOrCreateQuotaClient());
+  mClients.AppendElement(cache::CreateQuotaClient());
 
   return NS_OK;
 }
 
 void
 QuotaManager::InitQuotaForOrigin(PersistenceType aPersistenceType,
                                  const nsACString& aGroup,
                                  const nsACString& aOrigin,
