# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bd44fa7775ab5c865bd68fd7e29284186521e79d
Bug 1325254 P4 Make nsITimer::Cancel() O(c). r=froydnj

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -383,17 +383,17 @@ TimerThread::Shutdown()
     // might potentially call some code reentering the same lock
     // that leads to unexpected behavior or deadlock.
     // See bug 422472.
     mTimers.SwapElements(timers);
   }
 
   uint32_t timersCount = timers.Length();
   for (uint32_t i = 0; i < timersCount; i++) {
-    RefPtr<nsTimerImpl> timer = timers[i].mTimerImpl.forget();
+    RefPtr<nsTimerImpl> timer = timers[i].Take();
     if (timer) {
       timer->ReleaseCallback();
     }
   }
 
   mThread->Shutdown();    // wait for the thread to die
 
   nsTimerEvent::Shutdown();
@@ -457,37 +457,33 @@ TimerThread::Run()
       uint32_t milliseconds = 100;
       if (ChaosMode::isActive(ChaosFeature::TimerScheduling)) {
         milliseconds = ChaosMode::randomUint32LessThan(200);
       }
       waitFor = PR_MillisecondsToInterval(milliseconds);
     } else {
       waitFor = PR_INTERVAL_NO_TIMEOUT;
       TimeStamp now = TimeStamp::Now();
-      nsTimerImpl* timer = nullptr;
 
       // skip any canceled timers
-      while(!mTimers.IsEmpty() && !mTimers[0].mTimerImpl) {
+      while(!mTimers.IsEmpty() && !mTimers[0].Value()) {
         RemoveFirstTimerInternal();
       }
 
       if (!mTimers.IsEmpty()) {
-        timer = mTimers[0].mTimerImpl;
-
-        if (now >= timer->mTimeout || forceRunThisTimer) {
+        if (now >= mTimers[0].Value()->mTimeout || forceRunThisTimer) {
     next:
           // NB: AddRef before the Release under RemoveTimerInternal to avoid
           // mRefCnt passing through zero, in case all other refs than the one
           // from mTimers have gone away (the last non-mTimers[i]-ref's Release
           // must be racing with us, blocked in gThread->RemoveTimer waiting
           // for TimerThread::mMonitor, under nsTimerImpl::Release.
 
-          RefPtr<nsTimerImpl> timerRef(timer);
+          RefPtr<nsTimerImpl> timerRef(mTimers[0].Take());
           RemoveFirstTimerInternal();
-          timer = nullptr;
 
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
                  ("Timer thread woke up %fms from when it was supposed to\n",
                   fabs((now - timerRef->mTimeout).ToMilliseconds())));
 
           // We are going to let the call to PostTimerEvent here handle the
           // release of the timer so that we don't end up releasing the timer
           // on the TimerThread instead of on the thread it targets.
@@ -520,24 +516,22 @@ TimerThread::Run()
 
           // Update now, as PostTimerEvent plus the locking may have taken a
           // tick or two, and we may goto next below.
           now = TimeStamp::Now();
         }
       }
 
       // skip any canceled timers
-      while(!mTimers.IsEmpty() && !mTimers[0].mTimerImpl) {
+      while(!mTimers.IsEmpty() && !mTimers[0].Value()) {
         RemoveFirstTimerInternal();
       }
 
       if (!mTimers.IsEmpty()) {
-        timer = mTimers[0].mTimerImpl;
-
-        TimeStamp timeout = timer->mTimeout;
+        TimeStamp timeout = mTimers[0].Value()->mTimeout;
 
         // Don't wait at all (even for PR_INTERVAL_NO_WAIT) if the next timer
         // is due now or overdue.
         //
         // Note that we can only sleep for integer values of a certain
         // resolution. We use halfMicrosecondsIntervalResolution, calculated
         // before, to do the optimal rounding (i.e., of how to decide what
         // interval is so small we should not wait at all).
@@ -598,17 +592,17 @@ TimerThread::AddTimer(nsTimerImpl* aTime
   }
 
   // Add the timer to our list.
   if(!AddTimerInternal(aTimer)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   // Awaken the timer thread.
-  if (mWaiting && mTimers[0].mTimerImpl == aTimer) {
+  if (mWaiting && mTimers[0].Value() == aTimer) {
     mNotified = true;
     mMonitor.Notify();
   }
 
   return NS_OK;
 }
 
 nsresult
@@ -662,23 +656,21 @@ TimerThread::AddTimerInternal(nsTimerImp
 
   return true;
 }
 
 bool
 TimerThread::RemoveTimerInternal(nsTimerImpl* aTimer)
 {
   mMonitor.AssertCurrentThreadOwns();
-  for (uint32_t i = 0; i < mTimers.Length(); ++i) {
-    if (mTimers[i].mTimerImpl == aTimer) {
-      mTimers[i].mTimerImpl = nullptr;
-      return true;
-    }
+  if (!aTimer || !aTimer->mHolder) {
+    return false;
   }
-  return false;
+  aTimer->mHolder->Forget(aTimer);
+  return true;
 }
 
 void
 TimerThread::RemoveFirstTimerInternal()
 {
   mMonitor.AssertCurrentThreadOwns();
   MOZ_ASSERT(!mTimers.IsEmpty());
   std::pop_heap(mTimers.begin(), mTimers.end());
diff --git a/xpcom/threads/TimerThread.h b/xpcom/threads/TimerThread.h
--- a/xpcom/threads/TimerThread.h
+++ b/xpcom/threads/TimerThread.h
@@ -73,50 +73,132 @@ private:
   nsCOMPtr<nsIThread> mThread;
   Monitor mMonitor;
 
   bool mShutdown;
   bool mWaiting;
   bool mNotified;
   bool mSleeping;
 
+  // The Holder is a small wrapper around the nsTimerImpl.  This allows the
+  // nsTimerImpl to detach itself by calling Forget() without iterating the
+  // mTimers list to find the correct entry.  This must be implemented as
+  // a separate heap-allocated object and not as a value object within mTimers
+  // since the pointer in the nsTimerImpl must be stable.  The values in
+  // the mTimers array can be realloc'd, etc.
+  class Holder final : public nsTimerImplHolder
+  {
+    RefPtr<nsTimerImpl> mTimerImpl;
+
+    void
+    Forget(nsTimerImpl* aTimerImpl) override
+    {
+      if (!mTimerImpl) {
+        return;
+      }
+      MOZ_ASSERT(aTimerImpl == mTimerImpl);
+      mTimerImpl->SetHolder(nullptr);
+      mTimerImpl = nullptr;
+    }
+
+  public:
+    explicit Holder(nsTimerImpl* aTimerImpl)
+      : mTimerImpl(aTimerImpl)
+    {
+      if (mTimerImpl) {
+        mTimerImpl->SetHolder(this);
+      }
+    }
+
+    ~Holder()
+    {
+      if (mTimerImpl) {
+        mTimerImpl->SetHolder(nullptr);
+      }
+    }
+
+    nsTimerImpl*
+    Value() const
+    {
+      return mTimerImpl;
+    }
+
+    already_AddRefed<nsTimerImpl>
+    Take()
+    {
+      if (mTimerImpl) {
+        mTimerImpl->SetHolder(nullptr);
+      }
+      return mTimerImpl.forget();
+    }
+  };
+
+  // The value objects held within the mTimers array consist of the
+  // TimerThread's scheduled deadline and a holder wrapping the nsTimerImpl
+  // object.  The separate timeout allows us to adjust maintain a stable
+  // time even if the deadline deviates from the timer itself.  The holder
+  // object allows us to detach the timer in O(c) without iterating the list.
   struct Entry
   {
     TimeStamp mTimeout;
-    RefPtr<nsTimerImpl> mTimerImpl;
+    mozilla::UniquePtr<Holder> mHolder;
 
     Entry(const TimeStamp& aMinTimeout, const TimeStamp& aTimeout,
           nsTimerImpl* aTimerImpl)
-      : mTimeout(std::max(aMinTimeout, aTimeout)),
-      mTimerImpl(aTimerImpl)
-    { }
+      : mTimeout(std::max(aMinTimeout, aTimeout))
+      , mHolder(new Holder(aTimerImpl))
+    {
+    }
 
     Entry(Entry&& aOther)
       : mTimeout(aOther.mTimeout)
-      , mTimerImpl(mozilla::Move(aOther.mTimerImpl))
-    { }
+      , mHolder(mozilla::Move(aOther.mHolder))
+    {
+    }
 
     Entry& operator=(Entry&& aOther)
     {
       mTimeout = aOther.mTimeout;
-      mTimerImpl = mozilla::Move(aOther.mTimerImpl);
+      mHolder = mozilla::Move(aOther.mHolder);
       return *this;
     }
 
+    ~Entry()
+    {
+    }
+
     bool operator<(const Entry& aRight) const
     {
       // Reverse logic since we are inserting into a max heap
       // that sorts the "largest" value to index 0.
       return mTimeout > aRight.mTimeout;
     }
 
     bool operator==(const Entry& aRight) const
     {
       return mTimeout == aRight.mTimeout;
     }
+
+    nsTimerImpl*
+    Value() const
+    {
+      if (!mHolder) {
+        return nullptr;
+      }
+      return mHolder->Value();
+    }
+
+    already_AddRefed<nsTimerImpl>
+    Take()
+    {
+      if (!mHolder) {
+        return nullptr;
+      }
+      return mHolder->Take();
+    }
   };
 
   nsTArray<Entry> mTimers;
 };
 
 struct TimerAdditionComparator
 {
   TimerAdditionComparator(const mozilla::TimeStamp& aNow,
diff --git a/xpcom/threads/nsTimerImpl.cpp b/xpcom/threads/nsTimerImpl.cpp
--- a/xpcom/threads/nsTimerImpl.cpp
+++ b/xpcom/threads/nsTimerImpl.cpp
@@ -131,29 +131,36 @@ nsTimer::Release(void)
   } else if (count == 0) {
     delete this;
   }
 
   return count;
 }
 
 nsTimerImpl::nsTimerImpl(nsITimer* aTimer) :
+  mHolder(nullptr),
   mClosure(nullptr),
   mName(nsTimerImpl::Nothing),
   mCallbackType(CallbackType::Unknown),
   mGeneration(0),
   mDelay(0),
   mITimer(aTimer)
 {
   // XXXbsmedberg: shouldn't this be in Init()?
   mEventTarget = static_cast<nsIEventTarget*>(NS_GetCurrentThread());
 
   mCallback.c = nullptr;
 }
 
+void
+nsTimerImpl::SetHolder(nsTimerImplHolder* aHolder)
+{
+  mHolder = aHolder;
+}
+
 nsTimerImpl::~nsTimerImpl()
 {
   ReleaseCallback();
 }
 
 //static
 nsresult
 nsTimerImpl::Startup()
diff --git a/xpcom/threads/nsTimerImpl.h b/xpcom/threads/nsTimerImpl.h
--- a/xpcom/threads/nsTimerImpl.h
+++ b/xpcom/threads/nsTimerImpl.h
@@ -27,16 +27,31 @@ extern mozilla::LogModule* GetTimerLog()
 #define NS_TIMER_CID \
 { /* 5ff24248-1dd2-11b2-8427-fbab44f29bc8 */         \
      0x5ff24248,                                     \
      0x1dd2,                                         \
      0x11b2,                                         \
     {0x84, 0x27, 0xfb, 0xab, 0x44, 0xf2, 0x9b, 0xc8} \
 }
 
+class nsTimerImpl;
+
+// Define an interface for code that will hold the nsTimerImpl.  This
+// lets the nsTimerImpl object directly instruct its holder to forget
+// the timer avoiding list lookups.
+//
+// Note, the holder implementation must clear itself from the nsTimerImpl
+// by calling SetHolder(nullptr) before its destroyed.
+class nsTimerImplHolder
+{
+public:
+  virtual void
+  Forget(nsTimerImpl* aTimerImpl) = 0;
+};
+
 // TimerThread, nsTimerEvent, and nsTimer have references to these. nsTimer has
 // a separate lifecycle so we can Cancel() the underlying timer when the user of
 // the nsTimer has let go of its last reference.
 class nsTimerImpl
 {
   ~nsTimerImpl();
 public:
   typedef mozilla::TimeStamp TimeStamp;
@@ -108,18 +123,24 @@ public:
 
   bool IsRepeatingPrecisely() const
   {
     return mType >= nsITimer::TYPE_REPEATING_PRECISE;
   }
 
   void GetName(nsACString& aName);
 
+  void SetHolder(nsTimerImplHolder* aHolder);
+
   nsCOMPtr<nsIEventTarget> mEventTarget;
 
+  // This weak reference must be cleared by the nsTimerImplHolder by calling
+  // SetHolder(nullptr) before the holder is destroyed.
+  nsTimerImplHolder*    mHolder;
+
   void*                 mClosure;
 
   union CallbackUnion
   {
     nsTimerCallbackFunc c;
     // These refcounted references are managed manually, as they are in a union
     nsITimerCallback* MOZ_OWNING_REF i;
     nsIObserver* MOZ_OWNING_REF o;
