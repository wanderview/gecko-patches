# HG changeset patch
# Parent 01e27d663e9ff8648293925d9afe444d97d1774d
# User Ben Kelly <ben@wanderview.com>
Bug 1118845 P2 Add optional base load group to NS_NewLoadGroup(). r=mcmanus

diff --git a/netwerk/base/public/nsNetUtil.h b/netwerk/base/public/nsNetUtil.h
--- a/netwerk/base/public/nsNetUtil.h
+++ b/netwerk/base/public/nsNetUtil.h
@@ -987,19 +987,22 @@ NS_NewLoadGroup(nsILoadGroup      **resu
         if (NS_SUCCEEDED(rv)) {
             *result = nullptr;
             group.swap(*result);
         }
     }
     return rv;
 }
 
-// Create a new nsILoadGroup that will match the given principal.
+// Create a new nsILoadGroup that will match the given principal.  Also,
+// if a base laod group is provided, populate the nsILoadContext of the
+// new group with information from the existing context.
 nsresult
-NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal);
+NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal,
+                nsILoadGroup* aOptionalBase = nullptr);
 
 // Determine if the given loadGroup/principal pair will produce a principal
 // with similar permissions when passed to NS_NewChannel().  This checks for
 // things like making sure the appId and browser element flags match.  Without
 // an appropriate load group these values can be lost when getting the result
 // principal back out of the channel.  Null principals are also always allowed
 // as they do not have permissions to actually use the load group.
 bool
diff --git a/netwerk/base/src/nsNetUtil.cpp b/netwerk/base/src/nsNetUtil.cpp
--- a/netwerk/base/src/nsNetUtil.cpp
+++ b/netwerk/base/src/nsNetUtil.cpp
@@ -14,26 +14,37 @@ bool NS_IsReasonableHTTPHeaderValue(cons
 }
 
 bool NS_IsValidHTTPToken(const nsACString& aToken)
 {
   return mozilla::net::nsHttp::IsValidToken(aToken);
 }
 
 nsresult
-NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal)
+NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal,
+                nsILoadGroup* aOptionalBase)
 {
     using mozilla::LoadContext;
     nsresult rv;
 
+    nsCOMPtr<nsILoadContext> baseLoadContext;
+    if (aOptionalBase) {
+      nsCOMPtr<nsIInterfaceRequestor> cb;
+      rv = aOptionalBase->GetNotificationCallbacks(getter_AddRefs(cb));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      baseLoadContext = do_QueryInterface(cb);
+    }
+
     nsCOMPtr<nsILoadGroup> group =
         do_CreateInstance(NS_LOADGROUP_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    nsRefPtr<LoadContext> loadContext = new LoadContext(aPrincipal);
+    nsRefPtr<LoadContext> loadContext = new LoadContext(aPrincipal,
+                                                        baseLoadContext);
     rv = group->SetNotificationCallbacks(loadContext);
     NS_ENSURE_SUCCESS(rv, rv);
 
     group.forget(aResult);
     return rv;
 }
 
 bool
