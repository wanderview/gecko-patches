# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f2518b8a7b97b5bb477e94bc9131584007aac887
Bug 1093357 Implement an actor for streaming pipes from child to parent. r=khuey

diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -1586,16 +1586,30 @@ ContentChild::AllocPPrintingChild()
 }
 
 bool
 ContentChild::DeallocPPrintingChild(PPrintingChild* printing)
 {
     return true;
 }
 
+PPushStreamChild*
+ContentChild::AllocPPushStreamChild()
+{
+  // TODO
+  return nullptr;
+}
+
+bool
+ContentChild::DeallocPPushStreamChild(PPushStreamChild*)
+{
+  // TODO
+  return true;
+}
+
 PScreenManagerChild*
 ContentChild::AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                                        float* aSystemDefaultScale,
                                        bool* aSuccess)
 {
     // The ContentParent should never attempt to allocate the
     // nsScreenManagerProxy. Instead, the nsScreenManagerProxy
     // service is requested and instantiated via XPCOM, and the
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -219,16 +219,19 @@ public:
     DeallocPMobileConnectionChild(PMobileConnectionChild* aActor) override;
 
     virtual PNeckoChild* AllocPNeckoChild() override;
     virtual bool DeallocPNeckoChild(PNeckoChild*) override;
 
     virtual PPrintingChild* AllocPPrintingChild() override;
     virtual bool DeallocPPrintingChild(PPrintingChild*) override;
 
+    virtual PPushStreamChild* AllocPPushStreamChild() override;
+    virtual bool DeallocPPushStreamChild(PPushStreamChild*) override;
+
     virtual PScreenManagerChild*
     AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                              float* aSystemDefaultScale,
                              bool* aSuccess) override;
     virtual bool DeallocPScreenManagerChild(PScreenManagerChild*) override;
 
     virtual PPSMContentDownloaderChild* AllocPPSMContentDownloaderChild(
             const uint32_t& aCertType) override;
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -3647,16 +3647,37 @@ ContentParent::RecvPPrintingConstructor(
 
 bool
 ContentParent::DeallocPPrintingParent(PPrintingParent* printing)
 {
     delete printing;
     return true;
 }
 
+PPushStreamParent*
+ContentParent::AllocPPushStreamParent()
+{
+  // TODO
+  return nullptr;
+}
+
+bool
+ContentParent::RecvPPushStreamConstructor(PPushStreamParent* aActor)
+{
+  // TODO
+  return true;
+}
+
+bool
+ContentParent::DeallocPPushStreamParent(PPushStreamParent* aActor)
+{
+   // TODO
+   return true;
+}
+
 PScreenManagerParent*
 ContentParent::AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                                          float* aSystemDefaultScale,
                                          bool* aSuccess)
 {
     return new ScreenManagerParent(aNumberOfScreens, aSystemDefaultScale, aSuccess);
 }
 
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -305,16 +305,20 @@ public:
     virtual bool RecvPNeckoConstructor(PNeckoParent* aActor) override {
         return PContentParent::RecvPNeckoConstructor(aActor);
     }
 
     virtual PPrintingParent* AllocPPrintingParent() override;
     virtual bool RecvPPrintingConstructor(PPrintingParent* aActor) override;
     virtual bool DeallocPPrintingParent(PPrintingParent* aActor) override;
 
+    virtual PPushStreamParent* AllocPPushStreamParent() override;
+    virtual bool RecvPPushStreamConstructor(PPushStreamParent* aActor) override;
+    virtual bool DeallocPPushStreamParent(PPushStreamParent* aActor) override;
+
     virtual PScreenManagerParent*
     AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                               float* aSystemDefaultScale,
                               bool* aSuccess) override;
     virtual bool DeallocPScreenManagerParent(PScreenManagerParent* aActor) override;
 
     virtual PHalParent* AllocPHalParent() override;
     virtual bool RecvPHalConstructor(PHalParent* aActor) override {
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -33,16 +33,17 @@ include protocol PNecko;
 //       bridging PContent and PGMP. As soon as it registers the bridge between
 //       PContent and PPluginModule it seems to think that PContent's parent and
 //       child live in the same process!
 include protocol PGMPContent;
 include protocol PGMPService;
 include protocol PPluginModule;
 include protocol PGMP;
 include protocol PPrinting;
+include protocol PPushStream;
 include protocol POfflineCacheUpdate;
 include protocol PScreenManager;
 include protocol PSharedBufferManager;
 include protocol PSms;
 include protocol PSpeechSynthesis;
 include protocol PStorage;
 include protocol PTelephony;
 include protocol PTestShell;
@@ -434,16 +435,17 @@ prio(normal upto urgent) sync protocol P
     manages PHal;
     manages PIcc;
     manages PMedia;
     manages PMemoryReportRequest;
     manages PMobileConnection;
     manages PNecko;
     manages POfflineCacheUpdate;
     manages PPrinting;
+    manages PPushStream;
     manages PScreenManager;
     manages PSms;
     manages PSpeechSynthesis;
     manages PStorage;
     manages PTelephony;
     manages PTestShell;
     manages PVoicemail;
     manages PJavaScript;
@@ -751,16 +753,18 @@ parent:
     PIcc(uint32_t serviceId);
 
     PMobileConnection(uint32_t clientId);
 
     PNecko();
 
     PPrinting();
 
+    PPushStream();
+
     prio(high) sync PScreenManager()
         returns (uint32_t numberOfScreens,
                  float systemDefaultScale,
                  bool success);
 
     PCellBroadcast();
 
     PSms();
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -364,16 +364,30 @@ bool
 BackgroundChildImpl::DeallocPNuwaChild(PNuwaChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+PPushStreamChild*
+BackgroundChildImpl::AllocPPushStreamChild()
+{
+  // TODO
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPPushStreamChild(PPushStreamChild* aActor)
+{
+  // TODO
+  return true;
+}
+
 PAsmJSCacheEntryChild*
 BackgroundChildImpl::AllocPAsmJSCacheEntryChild(
                                const dom::asmjscache::OpenMode& aOpenMode,
                                const dom::asmjscache::WriteParams& aWriteParams,
                                const PrincipalInfo& aPrincipalInfo)
 {
   MOZ_CRASH("PAsmJSCacheEntryChild actors should be manually constructed!");
 }
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -124,16 +124,22 @@ protected:
   DeallocPMessagePortChild(PMessagePortChild* aActor) override;
 
   virtual PNuwaChild*
   AllocPNuwaChild() override;
 
   virtual bool
   DeallocPNuwaChild(PNuwaChild* aActor) override;
 
+  virtual PPushStreamChild*
+  AllocPPushStreamChild() override;
+
+  virtual bool
+  DeallocPPushStreamChild(PPushStreamChild* aActor) override;
+
   virtual PAsmJSCacheEntryChild*
   AllocPAsmJSCacheEntryChild(const dom::asmjscache::OpenMode& aOpenMode,
                              const dom::asmjscache::WriteParams& aWriteParams,
                              const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPAsmJSCacheEntryChild(PAsmJSCacheEntryChild* aActor) override;
 };
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -251,16 +251,37 @@ BackgroundParentImpl::RecvPNuwaConstruct
 }
 
 bool
 BackgroundParentImpl::DeallocPNuwaParent(PNuwaParent *aActor)
 {
   return mozilla::dom::NuwaParent::Dealloc(aActor);
 }
 
+PPushStreamParent*
+BackgroundParentImpl::AllocPPushStreamParent()
+{
+  // TODO
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::RecvPPushStreamConstructor(PPushStreamParent* aActor)
+{
+  // TODO
+  return true;
+}
+
+bool
+BackgroundParentImpl::DeallocPPushStreamParent(PPushStreamParent* aActor)
+{
+  // TODO
+  return true;
+}
+
 BackgroundParentImpl::PVsyncParent*
 BackgroundParentImpl::AllocPVsyncParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   nsRefPtr<mozilla::layout::VsyncParent> actor =
       mozilla::layout::VsyncParent::Create();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -90,16 +90,25 @@ protected:
   AllocPNuwaParent() override;
 
   virtual bool
   RecvPNuwaConstructor(PNuwaParent* aActor) override;
 
   virtual bool
   DeallocPNuwaParent(PNuwaParent* aActor) override;
 
+  virtual PPushStreamParent*
+  AllocPPushStreamParent() override;
+
+  virtual bool
+  RecvPPushStreamConstructor(PPushStreamParent* aActor) override;
+
+  virtual bool
+  DeallocPPushStreamParent(PPushStreamParent* aActor) override;
+
   virtual PServiceWorkerManagerParent*
   AllocPServiceWorkerManagerParent() override;
 
   virtual bool
   DeallocPServiceWorkerManagerParent(PServiceWorkerManagerParent* aActor) override;
 
   virtual bool
   RecvShutdownServiceWorkerRegistrar() override;
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -8,16 +8,17 @@ include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PMessagePort;
 include protocol PNuwa;
+include protocol PPushStream;
 include protocol PServiceWorkerManager;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 
@@ -43,16 +44,17 @@ sync protocol PBackground
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PMessagePort;
   manages PNuwa;
+  manages PPushStream;
   manages PServiceWorkerManager;
   manages PUDPSocket;
   manages PVsync;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
@@ -69,16 +71,18 @@ parent:
   ShutdownServiceWorkerRegistrar();
 
   PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
 
   PMessagePort(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   PNuwa();
 
+  PPushStream();
+
   MessagePortForceClose(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   PAsmJSCacheEntry(OpenMode openMode,
                    WriteParams write,
                    PrincipalInfo principalInfo);
 
 child:
   PCache();
diff --git a/ipc/glue/PPushStream.ipdl b/ipc/glue/PPushStream.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PPushStream.ipdl
@@ -0,0 +1,27 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PContent;
+
+namespace mozilla {
+namespace ipc {
+
+protocol PPushStream
+{
+  manager PBackground or PContent;
+
+parent:
+  Buffer(nsCString aBuffer);
+  Close(nsresult aRv);
+
+child:
+  // Stream is always destroyed from the parent side.  This occurs if the
+  // parent encounters an error while writing to its pipe or if the child
+  // signals the stream should close by SendClose().
+  __delete__();
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/PushStreamChild.cpp b/ipc/glue/PushStreamChild.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PushStreamChild.cpp
@@ -0,0 +1,245 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "PushStreamChild.h"
+
+#include "mozilla/unused.h"
+#include "nsIAsyncInputStream.h"
+#include "nsICancelableRunnable.h"
+#include "nsIThread.h"
+#include "nsStreamUtils.h"
+
+namespace mozilla {
+namespace ipc {
+
+class PushStreamChild::Callback final : public nsIInputStreamCallback
+                                        , public nsICancelableRunnable
+{
+public:
+  explicit Callback(PushStreamChild* aActor)
+    : mActor(aActor)
+    , mOwningThread(NS_GetCurrentThread())
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHOD
+  OnInputStreamReady(nsIAsyncInputStream* aStream) override
+  {
+    // any thread
+    if (mOwningThread == NS_GetCurrentThread()) {
+      return Run();
+    }
+
+    // If this fails, then it means the owning thread is a Worker that has
+    // been shutdown.  Its ok to lose the event in this case because the
+    // PushStreamChild listens for this event through the Feature.
+    nsresult rv = mOwningThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to dispatch stream readable event to owning thread");
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    if (mActor) {
+      mActor->OnStreamReady(this);
+    }
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Cancel() override
+  {
+    // Cancel() gets called when the Worker thread is being shutdown.  We have
+    // nothing to do here because PushStreamChild handles this case via
+    // the Feature.
+    return NS_OK;
+  }
+
+  void
+  ClearActor()
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    MOZ_ASSERT(mActor);
+    mActor = nullptr;
+  }
+
+private:
+  ~Callback()
+  {
+    // called on any thread
+
+    // ClearActor() should be called before the Callback is destroyed
+    MOZ_ASSERT(!mActor);
+  }
+
+  PushStreamChild* mActor;
+  nsCOMPtr<nsIThread> mOwningThread;
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(PushStreamChild::Callback, nsIInputStreamCallback,
+                                             nsIRunnable,
+                                             nsICancelableRunnable);
+
+PushStreamChild::PushStreamChild(nsIAsyncInputStream* aStream)
+  : mStream(aStream)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mStream);
+}
+
+PushStreamChild::~PushStreamChild()
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+  MOZ_ASSERT(mClosed);
+  MOZ_ASSERT(!mCallback);
+}
+
+void
+PushStreamChild::Start()
+{
+  DoRead();
+}
+
+void
+PushStreamChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+
+  // If the parent side runs into a problem then the actor will be destroyed.
+  // In this case we have not run OnEnd(), so still need to close the input
+  // stream.
+  if (!mClosed) {
+    mStream->CloseWithStatus(NS_ERROR_ABORT);
+    mClosed = true;
+  }
+
+  if (mCallback) {
+    mCallback->ClearActor();
+    mCallback = nullptr;
+  }
+}
+
+void
+PushStreamChild::DoRead()
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // The input stream (likely a pipe) probably uses a segment size of
+  // 4kb.  If there is data already buffered it would be nice to aggregate
+  // multiple segments into a single IPC call.  Conversely, don't send too
+  // too large of a buffer in a single call to avoid spiking memory.
+  static const uint64_t kMaxBytesPerMessage = 32 * 1024;
+  static_assert(kMaxBytesPerMessage <= static_cast<uint64_t>(UINT32_MAX),
+                "kMaxBytesPerMessage must cleanly cast to uint32_t");
+
+  while (!mClosed) {
+    // Use non-auto here as we're unlikely to hit stack storage with the
+    // sizes we are sending.  Also, it would be nice to avoid another copy
+    // to the IPC layer which we avoid if we use COW strings.  Unfortunately
+    // IPC does not seem to support passing dependent storage types.
+    nsCString buffer;
+
+    uint64_t available = 0;
+    nsresult rv = mStream->Available(&available);
+    if (NS_FAILED(rv)) {
+      OnEnd(rv);
+      return;
+    }
+
+    if (available == 0) {
+      Wait();
+      return;
+    }
+
+    uint32_t expectedBytes =
+      static_cast<uint32_t>(std::min(available, kMaxBytesPerMessage));
+
+    buffer.SetLength(expectedBytes);
+
+    uint32_t bytesRead = 0;
+    rv = mStream->Read(buffer.BeginWriting(), buffer.Length(), &bytesRead);
+    buffer.SetLength(bytesRead);
+
+    // If we read any data from the stream, send it across.
+    if (!buffer.IsEmpty()) {
+      unused << SendBuffer(buffer);
+    }
+
+    if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
+      Wait();
+      return;
+    }
+
+    // Any other error or zero-byte read indicates end-of-stream
+    if (NS_FAILED(rv) || buffer.IsEmpty()) {
+      OnEnd(rv);
+      return;
+    }
+  }
+}
+
+void
+PushStreamChild::Wait()
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // Set mCallback immediately instead of waiting for success.  Its possible
+  // AsyncWait() will callback synchronously.
+  mCallback = new Callback(this);
+  nsresult rv = mStream->AsyncWait(mCallback, 0, 0, nullptr);
+  if (NS_FAILED(rv)) {
+    OnEnd(rv);
+    return;
+  }
+}
+
+void
+PushStreamChild::OnStreamReady(Callback* aCallback)
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+  MOZ_ASSERT(mCallback);
+  MOZ_ASSERT(aCallback == mCallback);
+  mCallback->ClearActor();
+  mCallback = nullptr;
+  DoRead();
+}
+
+void
+PushStreamChild::OnEnd(nsresult aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(PushStreamChild);
+  MOZ_ASSERT(aRv != NS_BASE_STREAM_WOULD_BLOCK);
+
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+
+  mStream->CloseWithStatus(aRv);
+
+  if (aRv == NS_BASE_STREAM_CLOSED) {
+    aRv = NS_OK;
+  }
+
+  // This will trigger an ActorDestroy() from the parent side
+  unused << SendClose(aRv);
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/PushStreamChild.h b/ipc/glue/PushStreamChild.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PushStreamChild.h
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_PushStreamChild_h
+#define mozilla_ipc_PushStreamChild_h
+
+#include "mozilla/ipc/PPushStreamChild.h"
+#include "nsCOMPtr.h"
+
+class nsIAsyncInputStream;
+
+namespace mozilla {
+namespace ipc {
+
+class PushStreamChild final : public PPushStreamChild
+{
+public:
+  void Start();
+
+private:
+  class Callback;
+
+  // TODO: handle worker feature
+  PushStreamChild(nsIAsyncInputStream* aStream);
+  ~PushStreamChild();
+
+  // PPushStreamChild methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  void DoRead();
+
+  void Wait();
+
+  void OnStreamReady(Callback* aCallback);
+
+  void OnEnd(nsresult aRv);
+
+  nsCOMPtr<nsIAsyncInputStream> mStream;
+  nsRefPtr<Callback> mCallback;
+  bool mClosed;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+} // namespace ipc
+} // namespace mozilla
+
+#endif // mozilla_ipc_PushStreamChild_h
diff --git a/ipc/glue/PushStreamParent.cpp b/ipc/glue/PushStreamParent.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PushStreamParent.cpp
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "PushStreamParent.h"
+
+#include "mozilla/unused.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIPipe.h"
+
+namespace mozilla {
+namespace ipc {
+
+// static
+PushStreamParent*
+PushStreamParent::Create()
+{
+  // use async versions for both reader and writer even though we are
+  // opening the writer as an infinite stream.  We want to be able to
+  // use CloseWithStatus() to communicate errors through the pipe.
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  // Use an "infinite" pipe because we cannot apply back-pressure through
+  // the async IPC layer at the moment.  Blocking the IPC worker thread
+  // is not desirable, either.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader),
+                            getter_AddRefs(writer),
+                            true, true,   // non-blocking
+                            0,            // segment size
+                            UINT32_MAX);  // "infinite" pipe
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return new PushStreamParent(reader, writer);
+}
+
+PushStreamParent::~PushStreamParent()
+{
+}
+
+already_AddRefed<nsIInputStream>
+PushStreamParent::TakeReader()
+{
+  MOZ_ASSERT(mReader);
+  return mReader.forget();
+}
+
+void
+PushStreamParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  // If we were gracefully closed we should have gotten RecvClose().  In
+  // that case, the writer will already be closed and this will have no
+  // effect.  This just aborts the writer in the case where the child process
+  // crashes.
+  mWriter->CloseWithStatus(NS_ERROR_ABORT);
+}
+
+bool
+PushStreamParent::RecvBuffer(const nsCString& aBuffer)
+{
+  uint32_t numWritten = 0;
+
+  // This should only fail if we hit an OOM condition.
+  nsresult rv = mWriter->Write(aBuffer.get(), aBuffer.Length(), &numWritten);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    RecvClose(rv);
+  }
+
+  return true;
+}
+
+bool
+PushStreamParent::RecvClose(const nsresult& aRv)
+{
+  mWriter->CloseWithStatus(aRv);
+  unused << Send__delete__(this);
+  return true;
+}
+
+PushStreamParent::PushStreamParent(nsIAsyncInputStream* aReader,
+                                             nsIAsyncOutputStream* aWriter)
+  : mReader(aReader)
+  , mWriter(aWriter)
+{
+  MOZ_ASSERT(mReader);
+  MOZ_ASSERT(mWriter);
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/PushStreamParent.h b/ipc/glue/PushStreamParent.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PushStreamParent.h
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_PushStreamParent_h
+#define mozilla_ipc_PushStreamParent_h
+
+#include "mozilla/ipc/PPushStreamParent.h"
+
+class nsIAsyncInputStream;
+class nsIAsyncOutputStream;
+class nsIInputStream;
+
+namespace mozilla {
+namespace ipc {
+
+class PushStreamParent final : public PPushStreamParent
+{
+public:
+  static PushStreamParent*
+  Create();
+
+  ~PushStreamParent();
+
+  already_AddRefed<nsIInputStream>
+  TakeReader();
+
+private:
+  PushStreamParent(nsIAsyncInputStream* aReader,
+                        nsIAsyncOutputStream* aWriter);
+
+  // PPushStreamParent methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  virtual bool
+  RecvBuffer(const nsCString& aBuffer) override;
+
+  virtual bool
+  RecvClose(const nsresult& aRv) override;
+
+  nsCOMPtr<nsIAsyncInputStream> mReader;
+  nsCOMPtr<nsIAsyncOutputStream> mWriter;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+} // namespace ipc
+} // namespace mozilla
+
+#endif // mozilla_ipc_PushStreamParent_h
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -113,16 +113,18 @@ UNIFIED_SOURCES += [
     'FileDescriptor.cpp',
     'FileDescriptorUtils.cpp',
     'InputStreamUtils.cpp',
     'MessageChannel.cpp',
     'MessageLink.cpp',
     'MessagePump.cpp',
     'ProcessChild.cpp',
     'ProtocolUtils.cpp',
+    'PushStreamChild.cpp',
+    'PushStreamParent.cpp',
     'ScopedXREEmbed.cpp',
     'SharedMemory.cpp',
     'Shmem.cpp',
     'StringUtil.cpp',
 ]
 
 # GeckoChildProcessHost.cpp cannot be built in unified mode because it uses plarena.h.
 # URIUtils.cpp cannot be built in unified mode because of name clashes on strdup.
@@ -145,16 +147,17 @@ LOCAL_INCLUDES += [
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
+    'PPushStream.ipdl',
     'ProtocolTypes.ipdlh',
     'URIParams.ipdlh',
 ]
 
 
 LOCAL_INCLUDES += [
     '/toolkit/xre',
     '/xpcom/threads',
