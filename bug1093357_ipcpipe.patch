# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f2518b8a7b97b5bb477e94bc9131584007aac887
Bug 1093357 Implement an actor for streaming pipes from child to parent. r=khuey

diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -35,16 +35,17 @@
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/nsIContentChild.h"
 #include "mozilla/psm/PSMContentListener.h"
 #include "mozilla/hal_sandbox/PHalChild.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/FileDescriptorUtils.h"
 #include "mozilla/ipc/GeckoChildProcessHost.h"
+#include "mozilla/ipc/PSendStreamChild.h"
 #include "mozilla/ipc/TestShellChild.h"
 #include "mozilla/jsipc/CrossProcessObjectWrappers.h"
 #include "mozilla/layers/CompositorChild.h"
 #include "mozilla/layers/ImageBridgeChild.h"
 #include "mozilla/layers/PCompositorChild.h"
 #include "mozilla/layers/SharedBufferManagerChild.h"
 #include "mozilla/net/NeckoChild.h"
 #include "mozilla/plugins/PluginInstanceParent.h"
@@ -1586,16 +1587,29 @@ ContentChild::AllocPPrintingChild()
 }
 
 bool
 ContentChild::DeallocPPrintingChild(PPrintingChild* printing)
 {
     return true;
 }
 
+PSendStreamChild*
+ContentChild::AllocPSendStreamChild()
+{
+  MOZ_CRASH("PSendStreamChild actors should be manually constructed!");
+}
+
+bool
+ContentChild::DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PScreenManagerChild*
 ContentChild::AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                                        float* aSystemDefaultScale,
                                        bool* aSuccess)
 {
     // The ContentParent should never attempt to allocate the
     // nsScreenManagerProxy. Instead, the nsScreenManagerProxy
     // service is requested and instantiated via XPCOM, and the
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -219,16 +219,19 @@ public:
     DeallocPMobileConnectionChild(PMobileConnectionChild* aActor) override;
 
     virtual PNeckoChild* AllocPNeckoChild() override;
     virtual bool DeallocPNeckoChild(PNeckoChild*) override;
 
     virtual PPrintingChild* AllocPPrintingChild() override;
     virtual bool DeallocPPrintingChild(PPrintingChild*) override;
 
+    virtual PSendStreamChild* AllocPSendStreamChild() override;
+    virtual bool DeallocPSendStreamChild(PSendStreamChild*) override;
+
     virtual PScreenManagerChild*
     AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                              float* aSystemDefaultScale,
                              bool* aSuccess) override;
     virtual bool DeallocPScreenManagerChild(PScreenManagerChild*) override;
 
     virtual PPSMContentDownloaderChild* AllocPPSMContentDownloaderChild(
             const uint32_t& aCertType) override;
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -64,16 +64,18 @@
 #include "mozilla/dom/voicemail/VoicemailParent.h"
 #include "mozilla/embedding/printingui/PrintingParent.h"
 #include "mozilla/hal_sandbox/PHalParent.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/FileDescriptorUtils.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+#include "mozilla/ipc/SendStreamAlloc.h"
 #include "mozilla/ipc/TestShellParent.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/jsipc/CrossProcessObjectWrappers.h"
 #include "mozilla/layers/CompositorParent.h"
 #include "mozilla/layers/ImageBridgeParent.h"
 #include "mozilla/layers/SharedBufferManagerParent.h"
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/media/MediaParent.h"
@@ -3647,16 +3649,29 @@ ContentParent::RecvPPrintingConstructor(
 
 bool
 ContentParent::DeallocPPrintingParent(PPrintingParent* printing)
 {
     delete printing;
     return true;
 }
 
+PSendStreamParent*
+ContentParent::AllocPSendStreamParent()
+{
+    return AllocPSendStreamParent();
+}
+
+bool
+ContentParent::DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+    delete aActor;
+    return true;
+}
+
 PScreenManagerParent*
 ContentParent::AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                                          float* aSystemDefaultScale,
                                          bool* aSuccess)
 {
     return new ScreenManagerParent(aNumberOfScreens, aSystemDefaultScale, aSuccess);
 }
 
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -305,16 +305,19 @@ public:
     virtual bool RecvPNeckoConstructor(PNeckoParent* aActor) override {
         return PContentParent::RecvPNeckoConstructor(aActor);
     }
 
     virtual PPrintingParent* AllocPPrintingParent() override;
     virtual bool RecvPPrintingConstructor(PPrintingParent* aActor) override;
     virtual bool DeallocPPrintingParent(PPrintingParent* aActor) override;
 
+    virtual PSendStreamParent* AllocPSendStreamParent() override;
+    virtual bool DeallocPSendStreamParent(PSendStreamParent* aActor) override;
+
     virtual PScreenManagerParent*
     AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                               float* aSystemDefaultScale,
                               bool* aSuccess) override;
     virtual bool DeallocPScreenManagerParent(PScreenManagerParent* aActor) override;
 
     virtual PHalParent* AllocPHalParent() override;
     virtual bool RecvPHalConstructor(PHalParent* aActor) override {
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -33,16 +33,17 @@ include protocol PNecko;
 //       bridging PContent and PGMP. As soon as it registers the bridge between
 //       PContent and PPluginModule it seems to think that PContent's parent and
 //       child live in the same process!
 include protocol PGMPContent;
 include protocol PGMPService;
 include protocol PPluginModule;
 include protocol PGMP;
 include protocol PPrinting;
+include protocol PSendStream;
 include protocol POfflineCacheUpdate;
 include protocol PScreenManager;
 include protocol PSharedBufferManager;
 include protocol PSms;
 include protocol PSpeechSynthesis;
 include protocol PStorage;
 include protocol PTelephony;
 include protocol PTestShell;
@@ -434,16 +435,17 @@ prio(normal upto urgent) sync protocol P
     manages PHal;
     manages PIcc;
     manages PMedia;
     manages PMemoryReportRequest;
     manages PMobileConnection;
     manages PNecko;
     manages POfflineCacheUpdate;
     manages PPrinting;
+    manages PSendStream;
     manages PScreenManager;
     manages PSms;
     manages PSpeechSynthesis;
     manages PStorage;
     manages PTelephony;
     manages PTestShell;
     manages PVoicemail;
     manages PJavaScript;
@@ -751,16 +753,18 @@ parent:
     PIcc(uint32_t serviceId);
 
     PMobileConnection(uint32_t clientId);
 
     PNecko();
 
     PPrinting();
 
+    PSendStream();
+
     prio(high) sync PScreenManager()
         returns (uint32_t numberOfScreens,
                  float systemDefaultScale,
                  bool success);
 
     PCellBroadcast();
 
     PSms();
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -12,16 +12,17 @@
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/NuwaChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
+#include "mozilla/ipc/PSendStreamChild.h"
 #include "mozilla/layout/VsyncChild.h"
 #include "mozilla/net/PUDPSocketChild.h"
 #include "mozilla/dom/network/UDPSocketChild.h"
 #include "nsID.h"
 #include "nsTraceRefcnt.h"
 
 namespace {
 
@@ -364,16 +365,29 @@ bool
 BackgroundChildImpl::DeallocPNuwaChild(PNuwaChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+PSendStreamChild*
+BackgroundChildImpl::AllocPSendStreamChild()
+{
+  MOZ_CRASH("PSendStreamChild actors should be manually constructed!");
+}
+
+bool
+BackgroundChildImpl::DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PAsmJSCacheEntryChild*
 BackgroundChildImpl::AllocPAsmJSCacheEntryChild(
                                const dom::asmjscache::OpenMode& aOpenMode,
                                const dom::asmjscache::WriteParams& aWriteParams,
                                const PrincipalInfo& aPrincipalInfo)
 {
   MOZ_CRASH("PAsmJSCacheEntryChild actors should be manually constructed!");
 }
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -124,16 +124,22 @@ protected:
   DeallocPMessagePortChild(PMessagePortChild* aActor) override;
 
   virtual PNuwaChild*
   AllocPNuwaChild() override;
 
   virtual bool
   DeallocPNuwaChild(PNuwaChild* aActor) override;
 
+  virtual PSendStreamChild*
+  AllocPSendStreamChild() override;
+
+  virtual bool
+  DeallocPSendStreamChild(PSendStreamChild* aActor) override;
+
   virtual PAsmJSCacheEntryChild*
   AllocPAsmJSCacheEntryChild(const dom::asmjscache::OpenMode& aOpenMode,
                              const dom::asmjscache::WriteParams& aWriteParams,
                              const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPAsmJSCacheEntryChild(PAsmJSCacheEntryChild* aActor) override;
 };
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -16,16 +16,18 @@
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+#include "mozilla/ipc/SendStreamAlloc.h"
 #include "mozilla/layout/VsyncParent.h"
 #include "mozilla/dom/network/UDPSocketParent.h"
 #include "nsIAppsService.h"
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "mozilla/nsRefPtr.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
@@ -251,16 +253,29 @@ BackgroundParentImpl::RecvPNuwaConstruct
 }
 
 bool
 BackgroundParentImpl::DeallocPNuwaParent(PNuwaParent *aActor)
 {
   return mozilla::dom::NuwaParent::Dealloc(aActor);
 }
 
+PSendStreamParent*
+BackgroundParentImpl::AllocPSendStreamParent()
+{
+  return mozilla::ipc::AllocPSendStreamParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 BackgroundParentImpl::PVsyncParent*
 BackgroundParentImpl::AllocPVsyncParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   nsRefPtr<mozilla::layout::VsyncParent> actor =
       mozilla::layout::VsyncParent::Create();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -90,16 +90,22 @@ protected:
   AllocPNuwaParent() override;
 
   virtual bool
   RecvPNuwaConstructor(PNuwaParent* aActor) override;
 
   virtual bool
   DeallocPNuwaParent(PNuwaParent* aActor) override;
 
+  virtual PSendStreamParent*
+  AllocPSendStreamParent() override;
+
+  virtual bool
+  DeallocPSendStreamParent(PSendStreamParent* aActor) override;
+
   virtual PServiceWorkerManagerParent*
   AllocPServiceWorkerManagerParent() override;
 
   virtual bool
   DeallocPServiceWorkerManagerParent(PServiceWorkerManagerParent* aActor) override;
 
   virtual bool
   RecvShutdownServiceWorkerRegistrar() override;
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -8,16 +8,17 @@ include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PMessagePort;
 include protocol PNuwa;
+include protocol PSendStream;
 include protocol PServiceWorkerManager;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 
@@ -43,16 +44,17 @@ sync protocol PBackground
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PMessagePort;
   manages PNuwa;
+  manages PSendStream;
   manages PServiceWorkerManager;
   manages PUDPSocket;
   manages PVsync;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
@@ -69,16 +71,18 @@ parent:
   ShutdownServiceWorkerRegistrar();
 
   PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
 
   PMessagePort(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   PNuwa();
 
+  PSendStream();
+
   MessagePortForceClose(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   PAsmJSCacheEntry(OpenMode openMode,
                    WriteParams write,
                    PrincipalInfo principalInfo);
 
 child:
   PCache();
diff --git a/ipc/glue/PSendStream.ipdl b/ipc/glue/PSendStream.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PSendStream.ipdl
@@ -0,0 +1,27 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PContent;
+
+namespace mozilla {
+namespace ipc {
+
+protocol PSendStream
+{
+  manager PBackground or PContent;
+
+parent:
+  Buffer(nsCString aBuffer);
+  Close(nsresult aRv);
+
+child:
+  // Stream is always destroyed from the parent side.  This occurs if the
+  // parent encounters an error while writing to its pipe or if the child
+  // signals the stream should close by SendClose().
+  __delete__();
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/SendStream.h b/ipc/glue/SendStream.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStream.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_SendStream_h
+#define mozilla_ipc_SendStream_h
+
+#include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/ipc/PSendStreamChild.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+
+class nsIInputStream;
+class nsIAsyncInputStream;
+
+namespace mozilla {
+
+namespace dom {
+class PContentChild;
+} // dom namespace
+
+namespace ipc {
+
+class PBackgroundChild;
+
+class SendStreamChild : public PSendStreamChild
+{
+public:
+  static SendStreamChild*
+  Create(nsIAsyncInputStream* aInputStream, dom::PContentChild* aManager);
+
+  static SendStreamChild*
+  Create(nsIAsyncInputStream* aInputStream, PBackgroundChild* aManager);
+
+  virtual void
+  Start() = 0;
+
+  virtual void
+  StartDestroy() = 0;
+
+protected:
+  virtual
+  ~SendStreamChild() = 0;
+};
+
+class SendStreamParent : public PSendStreamParent
+{
+public:
+  virtual already_AddRefed<nsIInputStream>
+  TakeReader() = 0;
+
+protected:
+  virtual
+  ~SendStreamParent() = 0;
+};
+
+} // namespace ipc
+} // namespace mozilla
+
+#endif // mozilla_ipc_SendStream_h
diff --git a/ipc/glue/SendStreamAlloc.h b/ipc/glue/SendStreamAlloc.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamAlloc.h
@@ -0,0 +1,21 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_SendStreamAlloc_h
+#define mozilla_ipc_SendStreamAlloc_h
+
+namespace mozilla {
+namespace ipc {
+
+class PSendStreamParent;
+
+PSendStreamParent*
+AllocPSendStreamParent();
+
+} // ipc namespace
+} // mozilla namespace
+
+#endif // mozilla_ipc_SendStreamAlloc_h
diff --git a/ipc/glue/SendStreamChild.cpp b/ipc/glue/SendStreamChild.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamChild.cpp
@@ -0,0 +1,417 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ipc/SendStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/PContentChild.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerFeature.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsIAsyncInputStream.h"
+#include "nsICancelableRunnable.h"
+#include "nsIThread.h"
+#include "nsStreamUtils.h"
+
+namespace mozilla {
+namespace ipc {
+
+using mozilla::dom::PContentChild;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::Status;
+using mozilla::dom::workers::WorkerFeature;
+using mozilla::dom::workers::WorkerPrivate;
+
+namespace {
+
+class SendStreamChildImpl final : public SendStreamChild
+                                , public WorkerFeature
+{
+public:
+  SendStreamChildImpl(nsIAsyncInputStream* aStream);
+  ~SendStreamChildImpl();
+
+  void Start() override;
+  void StartDestroy() override;
+
+  bool
+  AddAsWorkerFeature(dom::workers::WorkerPrivate* aWorkerPrivate);
+
+private:
+  class Callback;
+
+  // PSendStreamChild methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  // WorkerFeature methods
+  virtual bool
+  Notify(JSContext* aCx, Status aStatus) override;
+
+  void DoRead();
+
+  void Wait();
+
+  void OnStreamReady(Callback* aCallback);
+
+  void OnEnd(nsresult aRv);
+
+  nsCOMPtr<nsIAsyncInputStream> mStream;
+  nsRefPtr<Callback> mCallback;
+  WorkerPrivate* mWorkerPrivate;
+  bool mNotified;
+  bool mClosed;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+class SendStreamChildImpl::Callback final : public nsIInputStreamCallback
+                                          , public nsICancelableRunnable
+{
+public:
+  explicit Callback(SendStreamChildImpl* aActor)
+    : mActor(aActor)
+    , mOwningThread(NS_GetCurrentThread())
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHOD
+  OnInputStreamReady(nsIAsyncInputStream* aStream) override
+  {
+    // any thread
+    if (mOwningThread == NS_GetCurrentThread()) {
+      return Run();
+    }
+
+    // If this fails, then it means the owning thread is a Worker that has
+    // been shutdown.  Its ok to lose the event in this case because the
+    // SendStreamChild listens for this event through the Feature.
+    nsresult rv = mOwningThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to dispatch stream readable event to owning thread");
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    if (mActor) {
+      mActor->OnStreamReady(this);
+    }
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Cancel() override
+  {
+    // Cancel() gets called when the Worker thread is being shutdown.  We have
+    // nothing to do here because SendStreamChild handles this case via
+    // the Feature.
+    return NS_OK;
+  }
+
+  void
+  ClearActor()
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    MOZ_ASSERT(mActor);
+    mActor = nullptr;
+  }
+
+private:
+  ~Callback()
+  {
+    // called on any thread
+
+    // ClearActor() should be called before the Callback is destroyed
+    MOZ_ASSERT(!mActor);
+  }
+
+  SendStreamChildImpl* mActor;
+  nsCOMPtr<nsIThread> mOwningThread;
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(SendStreamChildImpl::Callback, nsIInputStreamCallback,
+                                                 nsIRunnable,
+                                                 nsICancelableRunnable);
+
+SendStreamChildImpl::SendStreamChildImpl(nsIAsyncInputStream* aStream)
+  : mStream(aStream)
+  , mWorkerPrivate(nullptr)
+  , mNotified(false)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mStream);
+}
+
+SendStreamChildImpl::~SendStreamChildImpl()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(mClosed);
+  MOZ_ASSERT(!mCallback);
+  MOZ_ASSERT(!mWorkerPrivate);
+}
+
+void
+SendStreamChildImpl::Start()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerPrivate);
+  DoRead();
+}
+
+void
+SendStreamChildImpl::StartDestroy()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+
+  // start actor destruction from the parent process
+  unused << SendClose(NS_ERROR_ABORT);
+}
+
+bool
+SendStreamChildImpl::AddAsWorkerFeature(WorkerPrivate* aWorkerPrivate)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(aWorkerPrivate);
+  bool result = aWorkerPrivate->AddFeature(aWorkerPrivate->GetJSContext(), this);
+  if (result) {
+    mWorkerPrivate = aWorkerPrivate;
+  }
+  return result;
+}
+
+void
+SendStreamChildImpl::ActorDestroy(ActorDestroyReason aReason)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+
+  // If the parent side runs into a problem then the actor will be destroyed.
+  // In this case we have not run OnEnd(), so still need to close the input
+  // stream.
+  if (!mClosed) {
+    mStream->CloseWithStatus(NS_ERROR_ABORT);
+    mClosed = true;
+  }
+
+  if (mCallback) {
+    mCallback->ClearActor();
+    mCallback = nullptr;
+  }
+
+  if (mWorkerPrivate) {
+    mWorkerPrivate->RemoveFeature(mWorkerPrivate->GetJSContext(), this);
+    mWorkerPrivate = nullptr;
+  }
+}
+
+bool
+SendStreamChildImpl::Notify(JSContext* aCx, Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+
+  // Keep the worker thread alive until the stream is finished.
+  return true;
+}
+
+void
+SendStreamChildImpl::DoRead()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // The input stream (likely a pipe) probably uses a segment size of
+  // 4kb.  If there is data already buffered it would be nice to aggregate
+  // multiple segments into a single IPC call.  Conversely, don't send too
+  // too large of a buffer in a single call to avoid spiking memory.
+  static const uint64_t kMaxBytesPerMessage = 32 * 1024;
+  static_assert(kMaxBytesPerMessage <= static_cast<uint64_t>(UINT32_MAX),
+                "kMaxBytesPerMessage must cleanly cast to uint32_t");
+
+  while (!mClosed) {
+    // Use non-auto here as we're unlikely to hit stack storage with the
+    // sizes we are sending.  Also, it would be nice to avoid another copy
+    // to the IPC layer which we avoid if we use COW strings.  Unfortunately
+    // IPC does not seem to support passing dependent storage types.
+    nsCString buffer;
+
+    uint64_t available = 0;
+    nsresult rv = mStream->Available(&available);
+    if (NS_FAILED(rv)) {
+      OnEnd(rv);
+      return;
+    }
+
+    if (available == 0) {
+      Wait();
+      return;
+    }
+
+    uint32_t expectedBytes =
+      static_cast<uint32_t>(std::min(available, kMaxBytesPerMessage));
+
+    buffer.SetLength(expectedBytes);
+
+    uint32_t bytesRead = 0;
+    rv = mStream->Read(buffer.BeginWriting(), buffer.Length(), &bytesRead);
+    buffer.SetLength(bytesRead);
+
+    // If we read any data from the stream, send it across.
+    if (!buffer.IsEmpty()) {
+      unused << SendBuffer(buffer);
+    }
+
+    if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
+      Wait();
+      return;
+    }
+
+    // Any other error or zero-byte read indicates end-of-stream
+    if (NS_FAILED(rv) || buffer.IsEmpty()) {
+      OnEnd(rv);
+      return;
+    }
+  }
+}
+
+void
+SendStreamChildImpl::Wait()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // Set mCallback immediately instead of waiting for success.  Its possible
+  // AsyncWait() will callback synchronously.
+  mCallback = new Callback(this);
+  nsresult rv = mStream->AsyncWait(mCallback, 0, 0, nullptr);
+  if (NS_FAILED(rv)) {
+    OnEnd(rv);
+    return;
+  }
+}
+
+void
+SendStreamChildImpl::OnStreamReady(Callback* aCallback)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(mCallback);
+  MOZ_ASSERT(aCallback == mCallback);
+  mCallback->ClearActor();
+  mCallback = nullptr;
+  DoRead();
+}
+
+void
+SendStreamChildImpl::OnEnd(nsresult aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(aRv != NS_BASE_STREAM_WOULD_BLOCK);
+
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+
+  mStream->CloseWithStatus(aRv);
+
+  if (aRv == NS_BASE_STREAM_CLOSED) {
+    aRv = NS_OK;
+  }
+
+  // This will trigger an ActorDestroy() from the parent side
+  unused << SendClose(aRv);
+}
+
+bool
+IsBlocking(nsIAsyncInputStream* aInputStream)
+{
+  bool nonBlocking = false;
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(aInputStream->IsNonBlocking(&nonBlocking)));
+  return !nonBlocking;
+}
+
+} // anonymous namespace
+
+// static
+SendStreamChild*
+SendStreamChild::Create(nsIAsyncInputStream* aInputStream,
+                        PContentChild* aManager)
+{
+  MOZ_ASSERT(aInputStream);
+  MOZ_ASSERT(aManager);
+
+  // PContent can only be used on the main thread
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // SendStreamChild reads in the current thread, so it is only supported
+  // on non-blocking, async channels
+  if (NS_WARN_IF(IsBlocking(aInputStream))) {
+    return nullptr;
+  }
+
+  SendStreamChild* actor = new SendStreamChildImpl(aInputStream);
+  aManager->SendPSendStreamConstructor(actor);
+
+  return actor;
+}
+
+// static
+SendStreamChild*
+SendStreamChild::Create(nsIAsyncInputStream* aInputStream,
+                        PBackgroundChild* aManager)
+{
+  MOZ_ASSERT(aInputStream);
+  MOZ_ASSERT(aManager);
+
+  // PBackground can be used on any thread, but we only support SendStream on
+  // main thread and Worker threads right now.  This is due to the requirement
+  // that the thread be guaranteed to live long enough to receive messages
+  // sent from parent to child.  We can enforce this guarantee with a feature
+  // on worker threads, but not other threads.
+  WorkerPrivate* workerPrivate = nullptr;
+  if (!NS_IsMainThread()) {
+    workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+  }
+
+  // SendStreamChild reads in the current thread, so it is only supported
+  // on non-blocking, async channels
+  if (NS_WARN_IF(IsBlocking(aInputStream))) {
+    return nullptr;
+  }
+
+  SendStreamChildImpl* actor = new SendStreamChildImpl(aInputStream);
+
+  if (workerPrivate && !actor->AddAsWorkerFeature(workerPrivate)) {
+    delete actor;
+    return nullptr;
+  }
+
+  aManager->SendPSendStreamConstructor(actor);
+  return actor;
+}
+
+SendStreamChild::~SendStreamChild()
+{
+}
+
+void
+DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/SendStreamParent.cpp b/ipc/glue/SendStreamParent.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamParent.cpp
@@ -0,0 +1,136 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ipc/SendStream.h"
+
+#include "mozilla/unused.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIPipe.h"
+
+namespace mozilla {
+namespace ipc {
+
+namespace {
+
+class SendStreamParentImpl final : public SendStreamParent
+{
+public:
+  SendStreamParentImpl(nsIAsyncInputStream* aReader,
+                        nsIAsyncOutputStream* aWriter);
+  ~SendStreamParentImpl();
+
+private:
+  // PSendStreamParentImpl methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  // SendStreamparent methods
+  already_AddRefed<nsIInputStream>
+  TakeReader() override;
+
+  virtual bool
+  RecvBuffer(const nsCString& aBuffer) override;
+
+  virtual bool
+  RecvClose(const nsresult& aRv) override;
+
+  nsCOMPtr<nsIAsyncInputStream> mReader;
+  nsCOMPtr<nsIAsyncOutputStream> mWriter;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+SendStreamParentImpl::~SendStreamParentImpl()
+{
+}
+
+already_AddRefed<nsIInputStream>
+SendStreamParentImpl::TakeReader()
+{
+  MOZ_ASSERT(mReader);
+  return mReader.forget();
+}
+
+void
+SendStreamParentImpl::ActorDestroy(ActorDestroyReason aReason)
+{
+  // If we were gracefully closed we should have gotten RecvClose().  In
+  // that case, the writer will already be closed and this will have no
+  // effect.  This just aborts the writer in the case where the child process
+  // crashes.
+  mWriter->CloseWithStatus(NS_ERROR_ABORT);
+}
+
+bool
+SendStreamParentImpl::RecvBuffer(const nsCString& aBuffer)
+{
+  uint32_t numWritten = 0;
+
+  // This should only fail if we hit an OOM condition.
+  nsresult rv = mWriter->Write(aBuffer.get(), aBuffer.Length(), &numWritten);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    RecvClose(rv);
+  }
+
+  return true;
+}
+
+bool
+SendStreamParentImpl::RecvClose(const nsresult& aRv)
+{
+  mWriter->CloseWithStatus(aRv);
+  unused << Send__delete__(this);
+  return true;
+}
+
+SendStreamParentImpl::SendStreamParentImpl(nsIAsyncInputStream* aReader,
+                                             nsIAsyncOutputStream* aWriter)
+  : mReader(aReader)
+  , mWriter(aWriter)
+{
+  MOZ_ASSERT(mReader);
+  MOZ_ASSERT(mWriter);
+}
+
+} // anonymouns namespace
+
+SendStreamParent::~SendStreamParent()
+{
+}
+
+PSendStreamParent*
+AllocPSendStreamParent()
+{
+  // use async versions for both reader and writer even though we are
+  // opening the writer as an infinite stream.  We want to be able to
+  // use CloseWithStatus() to communicate errors through the pipe.
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  // Use an "infinite" pipe because we cannot apply back-pressure through
+  // the async IPC layer at the moment.  Blocking the IPC worker thread
+  // is not desirable, either.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader),
+                            getter_AddRefs(writer),
+                            true, true,   // non-blocking
+                            0,            // segment size
+                            UINT32_MAX);  // "infinite" pipe
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return new SendStreamParentImpl(reader, writer);
+}
+
+void
+DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+  delete aActor;
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -24,16 +24,18 @@ EXPORTS.mozilla.ipc += [
     'InputStreamUtils.h',
     'IOThreadChild.h',
     'MessageChannel.h',
     'MessageLink.h',
     'Neutering.h',
     'ProcessChild.h',
     'ProtocolUtils.h',
     'ScopedXREEmbed.h',
+    'SendStream.h',
+    'SendStreamAlloc.h',
     'SharedMemory.h',
     'SharedMemoryBasic.h',
     'SharedMemorySysV.h',
     'Shmem.h',
     'Transport.h',
     'URIUtils.h',
     'WindowsMessageLoop.h',
 ]
@@ -114,16 +116,18 @@ UNIFIED_SOURCES += [
     'FileDescriptorUtils.cpp',
     'InputStreamUtils.cpp',
     'MessageChannel.cpp',
     'MessageLink.cpp',
     'MessagePump.cpp',
     'ProcessChild.cpp',
     'ProtocolUtils.cpp',
     'ScopedXREEmbed.cpp',
+    'SendStreamChild.cpp',
+    'SendStreamParent.cpp',
     'SharedMemory.cpp',
     'Shmem.cpp',
     'StringUtil.cpp',
 ]
 
 # GeckoChildProcessHost.cpp cannot be built in unified mode because it uses plarena.h.
 # URIUtils.cpp cannot be built in unified mode because of name clashes on strdup.
 SOURCES += [
@@ -146,16 +150,17 @@ LOCAL_INCLUDES += [
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
+    'PSendStream.ipdl',
     'URIParams.ipdlh',
 ]
 
 
 LOCAL_INCLUDES += [
     '/toolkit/xre',
     '/xpcom/threads',
 ]
