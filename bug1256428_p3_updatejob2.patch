# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  62b7471de38643b404f2c8ec59e4f77156c513fb
Bug 1256428 P3 Add ServiceWorkerUpdateJob2. r=ehsan

diff --git a/dom/bindings/Errors.msg b/dom/bindings/Errors.msg
--- a/dom/bindings/Errors.msg
+++ b/dom/bindings/Errors.msg
@@ -87,8 +87,9 @@ MSG_DEF(MSG_PROMISE_CAPABILITY_HAS_SOMET
 MSG_DEF(MSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE, 0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the resolve function.")
 MSG_DEF(MSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE, 0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the reject function.")
 MSG_DEF(MSG_PROMISE_ARG_NOT_ITERABLE, 1, JSEXN_TYPEERR, "{0} is not iterable")
 MSG_DEF(MSG_IS_NOT_PROMISE, 1, JSEXN_TYPEERR, "{0} is not a Promise")
 MSG_DEF(MSG_SW_INSTALL_ERROR, 2, JSEXN_TYPEERR, "ServiceWorker script at {0} for scope {1} encountered an error during installation.")
 MSG_DEF(MSG_SW_SCRIPT_THREW, 2, JSEXN_TYPEERR, "ServiceWorker script at {0} for scope {1} threw an exception during script evaluation.")
 MSG_DEF(MSG_TYPEDARRAY_IS_SHARED, 1, JSEXN_TYPEERR, "{0} can't be a typed array on SharedArrayBuffer")
 MSG_DEF(MSG_CACHE_ADD_FAILED_RESPONSE, 3, JSEXN_TYPEERR, "Cache got {0} response with bad status {1} while trying to add request {2}")
+MSG_DEF(MSG_SW_UPDATE_BAD_REGISTRATION, 2, JSEXN_TYPEERR, "Failed to update the ServiceWorker for scope {0] because the registration has been {1} since the update was scheduled.")
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -329,16 +329,17 @@ class ServiceWorkerManager final
   friend class GetRegistrationRunnable;
   friend class ServiceWorkerJobQueue;
   friend class ServiceWorkerInstallJob;
   friend class ServiceWorkerRegisterJob;
   friend class ServiceWorkerJobBase;
   friend class ServiceWorkerScriptJobBase;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerUnregisterJob;
+  friend class ServiceWorkerUpdateJob2;
   friend class UpdateTimerCallback;
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
   NS_DECL_NSIOBSERVER
 
diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -0,0 +1,435 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerUpdateJob.h"
+
+#include "ServiceWorkerScriptCache.h"
+#include "Workers.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerUpdateJob2::CompareCallback final : public serviceWorkerScriptCache::CompareCallback
+{
+  RefPtr<ServiceWorkerUpdateJob2> mJob;
+
+  ~CompareCallback()
+  {
+  }
+
+public:
+  explicit CompareCallback(ServiceWorkerUpdateJob2* aJob)
+    : mJob(aJob)
+  {
+    MOZ_ASSERT(mJob);
+  }
+
+  virtual void
+  ComparisonResult(nsresult aStatus,
+                   bool aInCacheAndEqual,
+                   const nsAString& aNewCacheName,
+                   const nsACString& aMaxScope) override
+  {
+    mJob->ComparisonResult(aStatus, aInCacheAndEqual, aNewCacheName, aMaxScope);
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob2::CompareCallback)
+};
+
+class ServiceWorkerUpdateJob2::ContinueUpdateRunnable final : public LifeCycleEventCallback
+{
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> mJob;
+  bool mSuccess;
+
+public:
+  explicit ContinueUpdateRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob2>& aJob)
+    : mJob(aJob)
+    , mSuccess(false)
+  {
+    AssertIsOnMainThread();
+  }
+
+  void
+  SetResult(bool aResult) override
+  {
+    mSuccess = aResult;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnMainThread();
+    mJob->ContinueUpdateAfterScriptEval(mSuccess);
+    mJob = nullptr;
+    return NS_OK;
+  }
+};
+
+class ServiceWorkerUpdateJob2::ContinueInstallRunnable final : public LifeCycleEventCallback
+{
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> mJob;
+  bool mSuccess;
+
+public:
+  explicit ContinueInstallRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob2>& aJob)
+    : mJob(aJob)
+    , mSuccess(false)
+  {
+    AssertIsOnMainThread();
+  }
+
+  void
+  SetResult(bool aResult) override
+  {
+    mSuccess = aResult;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnMainThread();
+    mJob->ContinueAfterInstallEvent(mSuccess);
+    mJob = nullptr;
+    return NS_OK;
+  }
+};
+
+ServiceWorkerUpdateJob2::~ServiceWorkerUpdateJob2()
+{
+}
+
+void
+ServiceWorkerUpdateJob2::ComparisonResult(nsresult aStatus,
+                                          bool aInCacheAndEqual,
+                                          const nsAString& aNewCacheName,
+                                          const nsACString& aMaxScope)
+{
+  AssertIsOnMainThread();
+
+  if (NS_WARN_IF(Canceled())) {
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  if (NS_WARN_IF(NS_FAILED(aStatus))) {
+    Finish(aStatus);
+    return;
+  }
+
+  if (aInCacheAndEqual) {
+    Finish(NS_OK);
+    return;
+  }
+
+  Telemetry::Accumulate(Telemetry::SERVICE_WORKER_UPDATED, 1);
+
+  nsCOMPtr<nsIURI> scriptURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(scriptURI), mScriptSpec);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Finish(NS_ERROR_DOM_SECURITY_ERR);
+    return;
+  }
+
+  nsCOMPtr<nsIURI> maxScopeURI;
+  if (!aMaxScope.IsEmpty()) {
+    rv = NS_NewURI(getter_AddRefs(maxScopeURI), aMaxScope,
+                   nullptr, scriptURI);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      Finish(NS_ERROR_DOM_SECURITY_ERR);
+      return;
+    }
+  }
+
+  nsAutoCString defaultAllowedPrefix;
+  rv = GetRequiredScopeStringPrefix(scriptURI, defaultAllowedPrefix,
+                                    eUseDirectory);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Finish(NS_ERROR_DOM_SECURITY_ERR);
+    return;
+  }
+
+  nsAutoCString maxPrefix(defaultAllowedPrefix);
+  if (maxScopeURI) {
+    rv = GetRequiredScopeStringPrefix(maxScopeURI, maxPrefix, eUsePath);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      Finish(NS_ERROR_DOM_SECURITY_ERR);
+      return;
+    }
+  }
+
+  if (!StringBeginsWith(mRegistration->mScope, maxPrefix)) {
+    NS_WARNING("By default a service worker's scope is restricted to at or below it's script's location.");
+    Finish(NS_ERROR_DOM_SECURITY_ERR);
+    return;
+  }
+
+  nsAutoCString scopeKey;
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  rv = swm->PrincipalToScopeKey(mRegistration->mPrincipal, scopeKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return Finish(NS_ERROR_FAILURE);
+  }
+
+  ServiceWorkerManager::RegistrationDataPerPrincipal* data;
+  if (!swm->mRegistrationInfos.Get(scopeKey, &data)) {
+    return Finish(NS_ERROR_FAILURE);
+  }
+
+  MOZ_ASSERT(!mServiceWorker);
+  mServiceWorker = new ServiceWorkerInfo(mRegistration->mPrincipal,
+                                         mRegistration->mScope,
+                                         mScriptSpec, aNewCacheName);
+
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> handle(
+      new nsMainThreadPtrHolder<ServiceWorkerUpdateJob2>(this));
+  RefPtr<LifeCycleEventCallback> callback = new ContinueUpdateRunnable(handle);
+
+  ServiceWorkerPrivate* workerPrivate = mServiceWorker->WorkerPrivate();
+  MOZ_ASSERT(workerPrivate);
+  rv = workerPrivate->CheckScriptEvaluation(callback);
+
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+}
+
+void
+ServiceWorkerUpdateJob2::ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult)
+{
+  AssertIsOnMainThread();
+
+  // TODO: I think we can remove this now
+  mRegistration->mUpdating = false;
+
+  if (Canceled()) {
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  if (NS_WARN_IF(!aScriptEvaluationResult)) {
+    ErrorResult error;
+
+    NS_ConvertUTF8toUTF16 scriptSpec(mScriptSpec);
+    NS_ConvertUTF8toUTF16 scope(mRegistration->mScope);
+    error.ThrowTypeError<MSG_SW_SCRIPT_THREW>(scriptSpec, scope);
+    // TODO: implement FailWithErrorResult() logic somewhere
+    Finish(error);
+    return;
+  }
+
+  Install();
+}
+
+void
+ServiceWorkerUpdateJob2::Install()
+{
+  AssertIsOnMainThread();
+
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+
+  MOZ_ASSERT(mServiceWorker);
+  mRegistration->mInstallingWorker = mServiceWorker.forget();
+  mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
+  mRegistration->NotifyListenersOnChange();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER);
+
+  InvokeResultCallbacks(NS_OK);
+
+  // The job should NOT fail from this point on.
+
+  // fire the updatefound event
+  nsCOMPtr<nsIRunnable> upr =
+    NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
+      swm,
+      &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
+      mRegistration);
+  NS_DispatchToMainThread(upr);
+
+  // Call ContinueAfterInstallEvent(false) on main thread if the SW
+  // script fails to load.
+  nsCOMPtr<nsIRunnable> failRunnable = NS_NewRunnableMethodWithArgs<bool>
+    (this, &ServiceWorkerUpdateJob2::ContinueAfterInstallEvent, false);
+
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> handle(
+    new nsMainThreadPtrHolder<ServiceWorkerUpdateJob2>(this));
+  RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
+
+  // Send the install event to the worker thread
+  ServiceWorkerPrivate* workerPrivate =
+    mRegistration->mInstallingWorker->WorkerPrivate();
+  nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("install"),
+                                                  callback, failRunnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ContinueAfterInstallEvent(false /* aSuccess */);
+  }
+}
+
+void
+ServiceWorkerUpdateJob2::ContinueAfterInstallEvent(bool aInstallEventSuccess)
+{
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(mRegistration->mInstallingWorker);
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+
+  // "If installFailed is true"
+  if (NS_WARN_IF(!aInstallEventSuccess)) {
+    mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
+    mRegistration->mInstallingWorker = nullptr;
+    swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                   WhichServiceWorker::INSTALLING_WORKER);
+    swm->MaybeRemoveRegistration(mRegistration);
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  // "If registration's waiting worker is not null"
+  if (mRegistration->mWaitingWorker) {
+    mRegistration->mWaitingWorker->WorkerPrivate()->TerminateWorker();
+    mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
+
+    nsresult rv =
+      serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
+                                           mRegistration->mWaitingWorker->CacheName());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to purge the old waiting cache.");
+    }
+  }
+
+  mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
+  mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
+  mRegistration->NotifyListenersOnChange();
+  swm->StoreRegistration(mPrincipal, mRegistration);
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER |
+                                                 WhichServiceWorker::WAITING_WORKER);
+
+  Finish(NS_OK);
+
+  // Activate() is invoked out of band of atomic.
+  mRegistration->TryToActivateAsync();
+}
+
+ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(Type aType,
+                                                 nsIPrincipal* aPrincipal,
+                                                 const nsACString& aScope,
+                                                 const nsACString& aScriptSpec,
+                                                 nsILoadGroup* aLoadGroup)
+  : ServiceWorkerJob2(aType, aPrincipal, aScope, aScriptSpec)
+  , mLoadGroup(aLoadGroup)
+{
+  AssertIsOnMainThread();
+}
+
+void
+ServiceWorkerUpdateJob2::AsyncExecute()
+{
+  MOZ_ASSERT(GetType() == Type::Update);
+
+  GetAndSetRegistration();
+
+  if (!mRegistration || mRegistration->mPendingUninstall) {
+    ErrorResult rv;
+    rv.ThrowTypeError<MSG_SW_UPDATE_BAD_REGISTRATION>(NS_ConvertUTF8toUTF16(mScope),
+                                                      NS_LITERAL_STRING("uninstalled"));
+    Finish(rv);
+    return;
+  }
+
+  // If a different script has been registered between when this update
+  // was scheduled and it running now, then simply abort.
+  RefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
+  if (newest && !mScriptSpec.Equals(newest->ScriptSpec())) {
+    ErrorResult rv;
+    rv.ThrowTypeError<MSG_SW_UPDATE_BAD_REGISTRATION>(NS_ConvertUTF8toUTF16(mScope),
+                                                      NS_LITERAL_STRING("changed"));
+    Finish(rv);
+    return;
+  }
+
+  Update();
+}
+
+void
+ServiceWorkerUpdateJob2::GetAndSetRegistration()
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(!mRegistration);
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (NS_WARN_IF(!swm)) {
+    return;
+  }
+
+  mRegistration = swm->GetRegistration(mPrincipal, mScope);
+}
+
+void
+ServiceWorkerUpdateJob2::Update()
+{
+  AssertIsOnMainThread();
+
+  // TODO: I think we can remove mUpdating from registration now
+  mRegistration->mUpdating = true;
+
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+
+  RefPtr<ServiceWorkerInfo> workerInfo = mRegistration->Newest();
+  nsAutoString cacheName;
+
+  // If the script has not changed, we need to perform a byte-for-byte
+  // comparison.
+  if (workerInfo && workerInfo->ScriptSpec().Equals(mScriptSpec)) {
+    cacheName = workerInfo->CacheName();
+  }
+
+  RefPtr<CompareCallback> callback = new CompareCallback(this);
+
+  nsresult rv =
+    serviceWorkerScriptCache::Compare(mRegistration, mPrincipal, cacheName,
+                                      NS_ConvertUTF8toUTF16(mScriptSpec),
+                                      callback, mLoadGroup);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return Finish(rv);
+  }
+}
+
+ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
+                        const nsACString& aScope,
+                        const nsACString& aScriptSpec,
+                        nsILoadGroup* aLoadGroup)
+  : ServiceWorkerJob2(Type::Update, aPrincipal, aScope, aScriptSpec)
+  , mLoadGroup(aLoadGroup)
+{
+  AssertIsOnMainThread();
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerUpdateJob2::GetRegistration() const
+{
+  RefPtr<ServiceWorkerRegistrationInfo> ref = mRegistration;
+  return ref.forget();
+}
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/ServiceWorkerUpdateJob.h b/dom/workers/ServiceWorkerUpdateJob.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerUpdateJob.h
@@ -0,0 +1,75 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_serviceworkerupdatejob_h
+#define mozilla_dom_workers_serviceworkerupdatejob_h
+
+#include "ServiceWorkerJob.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerUpdateJob2 : public ServiceWorkerJob2
+{
+  class CompareCallback;
+  class ContinueUpdateRunnable;
+  class ContinueInstallRunnable;
+
+  nsCOMPtr<nsILoadGroup> mLoadGroup;
+  RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
+  RefPtr<ServiceWorkerInfo> mServiceWorker;
+
+  virtual ~ServiceWorkerUpdateJob2();
+
+  void
+  ComparisonResult(nsresult aStatus,
+                   bool aInCacheAndEqual,
+                   const nsAString& aNewCacheName,
+                   const nsACString& aMaxScope);
+
+  void
+  ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult);
+
+  void
+  Install();
+
+  void
+  ContinueAfterInstallEvent(bool aInstallEventSuccess);
+
+protected:
+  ServiceWorkerUpdateJob2(Type aType,
+                          nsIPrincipal* aPrincipal,
+                          const nsACString& aScope,
+                          const nsACString& aScriptSpec,
+                          nsILoadGroup* aLoadGroup);
+
+  virtual void
+  AsyncExecute() override;
+
+  void
+  GetAndSetRegistration();
+
+  void
+  Update();
+
+public:
+  ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
+                          const nsACString& aScope,
+                          const nsACString& aScriptSpec,
+                          nsILoadGroup* aLoadGroup);
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetRegistration() const;
+
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob2)
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_serviceworkerupdatejob_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerMessageEvent.cpp',
     'ServiceWorkerPrivate.cpp',
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerScriptCache.cpp',
+    'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'URL.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
