# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b89f98154524c5a6da6707db0112dfd7f4a89bbe
Bug 1256428 P3 Add ServiceWorkerUpdateJob2. r=ehsan

diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -329,16 +329,17 @@ class ServiceWorkerManager final
   friend class GetRegistrationRunnable;
   friend class ServiceWorkerJobQueue;
   friend class ServiceWorkerInstallJob;
   friend class ServiceWorkerRegisterJob;
   friend class ServiceWorkerJobBase;
   friend class ServiceWorkerScriptJobBase;
   friend class ServiceWorkerRegistrationInfo;
   friend class ServiceWorkerUnregisterJob;
+  friend class ServiceWorkerUpdateJob2;
   friend class UpdateTimerCallback;
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
   NS_DECL_NSIOBSERVER
 
diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -0,0 +1,204 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerUpdateJob.h"
+
+#include "ServiceWorkerScriptCache.h"
+#include "Workers.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerUpdateJob2::ContinueRunnable final : public LifeCycleEventCallback
+{
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> mJob;
+  bool mSuccess;
+
+public:
+  explicit ContinueRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob2>& aJob)
+    : mJob(aJob)
+    , mSuccess(false)
+  {
+    AssertIsOnMainThread();
+  }
+
+  void
+  SetResult(bool aResult) override
+  {
+    mSuccess = aResult;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnMainThread();
+    mJob->ContinueAfterInstallEvent(mSuccess);
+    mJob = nullptr;
+    return NS_OK;
+  }
+};
+
+ServiceWorkerUpdateJob2::~ServiceWorkerUpdateJob2()
+{
+}
+
+void
+ServiceWorkerUpdateJob2::Install(ServiceWorkerRegistrationInfo *aRegistration,
+                                 ServiceWorkerInfo* aServiceWorker)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aServiceWorker);
+
+  MOZ_ASSERT(aRegistration);
+  MOZ_ASSERT(!mRegistration);
+  mRegistration = aRegistration;
+
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+
+  mRegistration->mInstallingWorker = aServiceWorker;
+  mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
+  mRegistration->NotifyListenersOnChange();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER);
+
+  InvokeResultCallbacks(NS_OK);
+
+  // The job should NOT call fail from this point on.
+
+  // fire the updatefound event
+  nsCOMPtr<nsIRunnable> upr =
+    NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
+      swm,
+      &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
+      mRegistration);
+  NS_DispatchToMainThread(upr);
+
+  // Call ContinueAfterInstallEvent(false) on main thread if the SW
+  // script fails to load.
+  nsCOMPtr<nsIRunnable> failRunnable = NS_NewRunnableMethodWithArgs<bool>
+    (this, &ServiceWorkerUpdateJob2::ContinueAfterInstallEvent, false);
+
+  nsMainThreadPtrHandle<ServiceWorkerUpdateJob2> handle(
+    new nsMainThreadPtrHolder<ServiceWorkerUpdateJob2>(this));
+  RefPtr<LifeCycleEventCallback> callback = new ContinueRunnable(handle);
+
+  // Send the install event to the worker thread
+  ServiceWorkerPrivate* workerPrivate =
+    mRegistration->mInstallingWorker->WorkerPrivate();
+  nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("install"),
+                                                  callback, failRunnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ContinueAfterInstallEvent(false /* aSuccess */);
+  }
+}
+
+void
+ServiceWorkerUpdateJob2::ContinueAfterInstallEvent(bool aInstallEventSuccess)
+{
+  if (Canceled()) {
+    return Finish(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  MOZ_ASSERT(mRegistration->mInstallingWorker);
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+
+  // "If installFailed is true"
+  if (NS_WARN_IF(!aInstallEventSuccess)) {
+    mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
+    mRegistration->mInstallingWorker = nullptr;
+    swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                   WhichServiceWorker::INSTALLING_WORKER);
+    swm->MaybeRemoveRegistration(mRegistration);
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  // "If registration's waiting worker is not null"
+  if (mRegistration->mWaitingWorker) {
+    mRegistration->mWaitingWorker->WorkerPrivate()->TerminateWorker();
+    mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
+
+    nsresult rv =
+      serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
+                                           mRegistration->mWaitingWorker->CacheName());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to purge the old waiting cache.");
+    }
+  }
+
+  mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
+  mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
+  mRegistration->NotifyListenersOnChange();
+  swm->StoreRegistration(mPrincipal, mRegistration);
+  swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
+                                                 WhichServiceWorker::INSTALLING_WORKER |
+                                                 WhichServiceWorker::WAITING_WORKER);
+
+  Finish(NS_OK);
+
+  // Activate() is invoked out of band of atomic.
+  mRegistration->TryToActivateAsync();
+}
+
+ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(Type aType,
+                                                 nsIPrincipal* aPrincipal,
+                                                 const nsACString& aScope,
+                                                 const nsACString& aScriptSpec)
+  : ServiceWorkerJob2(aType, aPrincipal, aScope, aScriptSpec)
+{
+  AssertIsOnMainThread();
+}
+
+void
+ServiceWorkerUpdateJob2::AsyncExecute()
+{
+  MOZ_ASSERT(GetType() == Type::Update);
+
+  // TODO: get/verify registration
+
+  if (!mRegistration || mRegistration->mPendingUninstall) {
+    // TODO: type error
+    Finish(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+
+  // If a different script spec has been registered between when this update
+  // was scheduled and it running now, then simply abort.
+  RefPtr<ServiceWorkerInfo> newest = mRegistration->Newest();
+  if (newest && !mScriptSpec.Equals(newest->ScriptSpec())) {
+    // TODO: type error
+    Finish(NS_ERROR_DOM_ABORT_ERR);
+    return;
+  }
+
+  Update();
+}
+
+void
+ServiceWorkerUpdateJob2::Update()
+{
+  // TODO
+}
+
+ServiceWorkerUpdateJob2::ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
+                        const nsACString& aScope,
+                        const nsACString& aScriptSpec)
+  : ServiceWorkerJob2(Type::Update, aPrincipal, aScope, aScriptSpec)
+{
+  AssertIsOnMainThread();
+}
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/workers/ServiceWorkerUpdateJob.h b/dom/workers/ServiceWorkerUpdateJob.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerUpdateJob.h
@@ -0,0 +1,55 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_serviceworkerupdatejob_h
+#define mozilla_dom_workers_serviceworkerupdatejob_h
+
+#include "ServiceWorkerJob.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerUpdateJob2 : public ServiceWorkerJob2
+{
+  class ContinueRunnable;
+
+  RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
+
+  virtual ~ServiceWorkerUpdateJob2();
+
+  void
+  Install(ServiceWorkerRegistrationInfo* aRegistration,
+          ServiceWorkerInfo* aServiceWorker);
+
+  void
+  ContinueAfterInstallEvent(bool aInstallEventSuccess);
+
+protected:
+  ServiceWorkerUpdateJob2(Type aType,
+                          nsIPrincipal* aPrincipal,
+                          const nsACString& aScope,
+                          const nsACString& aScriptSpec);
+
+  virtual void
+  AsyncExecute() override;
+
+  void
+  Update();
+
+public:
+  ServiceWorkerUpdateJob2(nsIPrincipal* aPrincipal,
+                          const nsACString& aScope,
+                          const nsACString& aScriptSpec);
+
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob2)
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_serviceworkerupdatejob_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -72,16 +72,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerMessageEvent.cpp',
     'ServiceWorkerPrivate.cpp',
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerScriptCache.cpp',
+    'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'URL.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerLocation.cpp',
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
