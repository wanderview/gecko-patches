# HG changeset patch
# Parent c729426da29b8ed842c2a0b8675677b9c97ebadb
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 052 address Feature review feedback


diff --git a/dom/cache/ActorChild.cpp b/dom/cache/ActorChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ActorChild.cpp
@@ -0,0 +1,53 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ActorChild.h"
+
+#include "mozilla/dom/cache/Feature.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+void
+ActorChild::SetFeature(Feature* aFeature)
+{
+  MOZ_ASSERT(!mFeature);
+  mFeature = aFeature;
+  if (mFeature) {
+    mFeature->AddActor(this);
+  }
+}
+
+void
+ActorChild::RemoveFeature()
+{
+  if (mFeature) {
+    mFeature->RemoveActor(this);
+    mFeature = nullptr;
+  }
+}
+
+Feature*
+ActorChild::GetFeature() const
+{
+  return mFeature;
+}
+
+bool
+ActorChild::FeatureNotified() const
+{
+  return mFeature && mFeature->Notified();
+}
+
+ActorChild::~ActorChild()
+{
+  MOZ_ASSERT(!mFeature);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ActorChild.h b/dom/cache/ActorChild.h
--- a/dom/cache/ActorChild.h
+++ b/dom/cache/ActorChild.h
@@ -2,23 +2,46 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_ActioChild_h
 #define mozilla_dom_cache_ActioChild_h
 
+#include "nsRefPtr.h"
+
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class Feature;
+
 class ActorChild
 {
 public:
-  virtual void StartDestroy() = 0;
+  virtual void
+  StartDestroy() = 0;
+
+  void
+  SetFeature(Feature* aFeature);
+
+  void
+  RemoveFeature();
+
+  Feature*
+  GetFeature() const;
+
+  bool
+  FeatureNotified() const;
+
+protected:
+  ~ActorChild();
+
+private:
+  nsRefPtr<Feature> mFeature;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_ActioChild_h
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheChild.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/cache/Cache.h"
-#include "mozilla/dom/cache/Feature.h"
 #include "mozilla/dom/cache/StreamUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // Declared in ActorUtils.h
 PCacheChild*
@@ -36,27 +35,16 @@ CacheChild::CacheChild()
   MOZ_COUNT_CTOR(cache::CacheChild);
 }
 
 CacheChild::~CacheChild()
 {
   MOZ_COUNT_DTOR(cache::CacheChild);
   NS_ASSERT_OWNINGTHREAD(CacheChild);
   MOZ_ASSERT(!mListener);
-  MOZ_ASSERT(!mFeature);
-}
-
-void
-CacheChild::SetFeature(Feature* aFeature)
-{
-  MOZ_ASSERT(!mFeature);
-  mFeature = aFeature;
-  if (mFeature) {
-    mFeature->AddActor(this);
-  }
 }
 
 void
 CacheChild::SetListener(Cache* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
   MOZ_ASSERT(!mListener);
   mListener = aListener;
@@ -98,29 +86,26 @@ CacheChild::ActorDestroy(ActorDestroyRea
   NS_ASSERT_OWNINGTHREAD(CacheChild);
   nsRefPtr<Cache> listener = mListener;
   if (listener) {
     listener->DestroyInternal(this);
     // Cache listener should call ClearListener() in DestroyInternal()
     MOZ_ASSERT(!mListener);
   }
 
-  if (mFeature) {
-    mFeature->RemoveActor(this);
-    mFeature = nullptr;
-  }
+  RemoveFeature();
 }
 
 bool
 CacheChild::RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
                               const PCacheResponseOrVoid& aResponse)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
 
-  AddFeatureToStreamChild(aResponse, mFeature);
+  AddFeatureToStreamChild(aResponse, GetFeature());
 
   nsRefPtr<Cache> listener = mListener;
   if (!listener) {
     StartDestroyStreamChild(aResponse);
     return true;
   }
 
   listener->RecvMatchResponse(requestId, aRv, aResponse);
@@ -128,17 +113,17 @@ CacheChild::RecvMatchResponse(const Requ
 }
 
 bool
 CacheChild::RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
                                  nsTArray<PCacheResponse>&& aResponses)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
 
-  AddFeatureToStreamChild(aResponses, mFeature);
+  AddFeatureToStreamChild(aResponses, GetFeature());
 
   nsRefPtr<Cache> listener = mListener;
   if (!listener) {
     StartDestroyStreamChild(aResponses);
     return true;
   }
 
   listener->RecvMatchAllResponse(requestId, aRv, aResponses);
@@ -180,17 +165,17 @@ CacheChild::RecvDeleteResponse(const Req
 }
 
 bool
 CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                              nsTArray<PCacheRequest>&& aRequests)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
 
-  AddFeatureToStreamChild(aRequests, mFeature);
+  AddFeatureToStreamChild(aRequests, GetFeature());
 
   nsRefPtr<Cache> listener = mListener;
   if (!listener) {
     StartDestroyStreamChild(aRequests);
     return true;
   }
 
   listener->RecvKeysResponse(requestId, aRv, aRequests);
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -10,26 +10,24 @@
 #include "mozilla/dom/cache/ActorChild.h"
 #include "mozilla/dom/cache/PCacheChild.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Cache;
-class Feature;
 
 class CacheChild MOZ_FINAL : public PCacheChild
                            , public ActorChild
 {
 public:
   CacheChild();
   ~CacheChild();
 
-  void SetFeature(Feature* aFeature);
   void SetListener(Cache* aListener);
 
   // Must be called by the associated Cache listener in its ActorDestroy()
   // method.  Also, Cache must Send__delete__() the actor in its destructor to
   // trigger ActorDestroy() if it has not been called yet.
   void ClearListener();
 
   // ActorChild methods
@@ -57,18 +55,16 @@ private:
                   const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                    nsTArray<PCacheRequest>&& requests) MOZ_OVERRIDE;
 
-  nsRefPtr<Feature> mFeature;
-
   // Use a weak ref so actor does not hold DOM object alive past content use.
   // The Cache object must call ClearListener() to null this before its
   // destroyed.
   Cache* MOZ_NON_OWNING_REF mListener;
 
   NS_DECL_OWNINGTHREAD
 };
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -102,16 +102,17 @@ CacheStorage::CreateOnWorker(Namespace a
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   nsRefPtr<Feature> feature = Feature::Create(aWorkerPrivate);
   if (!feature) {
     NS_WARNING("Worker thread is shutting down.");
+    aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
   if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
     NS_WARNING("CacheStorage not supported on null principal.");
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
@@ -324,16 +325,19 @@ CacheStorage::ActorCreated(PBackgroundCh
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(aActor);
 
   if (NS_WARN_IF(mFeature && mFeature->Notified())) {
     ActorFailed();
     return;
   }
 
+  // Feature ownership is passed to the CacheStorageChild actor and any actors
+  // it may create.  The Feature will keep the worker thread alive until the
+  // actors can gracefully shutdown.
   CacheStorageChild* newActor = new CacheStorageChild(this, mFeature);
   PCacheStorageChild* constructedActor =
     aActor->SendPCacheStorageConstructor(newActor, mNamespace, *mPrincipalInfo);
 
   if (NS_WARN_IF(!constructedActor)) {
     ActorFailed();
     return;
   }
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -4,48 +4,43 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorageChild.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/dom/cache/CacheStorage.h"
-#include "mozilla/dom/cache/Feature.h"
 #include "mozilla/dom/cache/StreamUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // declared in ActorUtils.h
 void
 DeallocPCacheStorageChild(PCacheStorageChild* aActor)
 {
   delete aActor;
 }
 
 CacheStorageChild::CacheStorageChild(CacheStorage* aListener, Feature* aFeature)
   : mListener(aListener)
-  , mFeature(aFeature)
 {
   MOZ_COUNT_CTOR(cache::CacheStorageChild);
   MOZ_ASSERT(mListener);
 
-  if (mFeature) {
-    mFeature->AddActor(this);
-  }
+  SetFeature(aFeature);
 }
 
 CacheStorageChild::~CacheStorageChild()
 {
   MOZ_COUNT_DTOR(cache::CacheStorageChild);
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   MOZ_ASSERT(!mListener);
-  MOZ_ASSERT(!mFeature);
 }
 
 void
 CacheStorageChild::ClearListener()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   MOZ_ASSERT(mListener);
   mListener = nullptr;
@@ -80,30 +75,27 @@ CacheStorageChild::ActorDestroy(ActorDes
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   nsRefPtr<CacheStorage> listener = mListener;
   if (listener) {
     listener->DestroyInternal(this);
     // CacheStorage listener should call ClearListener() in DestroyInternal()
     MOZ_ASSERT(!mListener);
   }
 
-  if (mFeature) {
-    mFeature->RemoveActor(this);
-    mFeature = nullptr;
-  }
+  RemoveFeature();
 }
 
 bool
 CacheStorageChild::RecvMatchResponse(const RequestId& aRequestId,
                                      const nsresult& aRv,
                                      const PCacheResponseOrVoid& aResponseOrVoid)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
 
-  AddFeatureToStreamChild(aResponseOrVoid, mFeature);
+  AddFeatureToStreamChild(aResponseOrVoid, GetFeature());
 
   nsRefPtr<CacheStorage> listener = mListener;
   if (!listener) {
     StartDestroyStreamChild(aResponseOrVoid);
     return true;
   }
 
   listener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid);
@@ -127,30 +119,30 @@ CacheStorageChild::RecvHasResponse(const
 bool
 CacheStorageChild::RecvOpenResponse(const RequestId& aRequestId,
                                     const nsresult& aRv,
                                     PCacheChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
 
   nsRefPtr<CacheStorage> listener = mListener;
-  if (!listener || (mFeature && mFeature->Notified())) {
+  if (!listener || FeatureNotified()) {
     if (aActor) {
       unused << aActor->SendTeardown();
     }
     return true;
   }
 
   CacheChild* cacheChild = static_cast<CacheChild*>(aActor);
 
-  // Since Feature::Notified returned false above, we are guaranteed that
+  // Since FeatureNotified() returned false above, we are guaranteed that
   // the feature won't try to shutdown the actor until after we create the
   // Cache DOM object in the listener's RecvOpenResponse() method.  This
   // is important because StartShutdown() expects a Cache object listener.
-  cacheChild->SetFeature(mFeature);
+  cacheChild->SetFeature(GetFeature());
 
   listener->RecvOpenResponse(aRequestId, aRv, cacheChild);
   return true;
 }
 
 bool
 CacheStorageChild::RecvDeleteResponse(const RequestId& aRequestId,
                                       const nsresult& aRv,
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -36,17 +36,17 @@ public:
 
   // Synchronously call ActorDestroy on our CacheStorage listener and then start
   // the actor destruction asynchronously from the parent-side.
   virtual void StartDestroy() MOZ_OVERRIDE;
 
 private:
   // PCacheStorageChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
-  virtual bool RecvMatchResponse(const RequestId& requestId,
+  virtual bool RecvMatchResponse(const RequestId& aRequestId,
                                  const nsresult& aRv,
                                  const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
   virtual bool RecvHasResponse(const cache::RequestId& aRequestId,
                                const nsresult& aRv,
                                const bool& aSuccess) MOZ_OVERRIDE;
   virtual bool RecvOpenResponse(const cache::RequestId& aRequestId,
                                 const nsresult& aRv,
                                 PCacheChild* aActor) MOZ_OVERRIDE;
@@ -57,18 +57,16 @@ private:
                                 const nsresult& aRv,
                                 nsTArray<nsString>&& aKeys) MOZ_OVERRIDE;
 
   // Use a weak ref so actor does not hold DOM object alive past content use.
   // The CacheStorage object must call ClearListener() to null this before its
   // destroyed.
   CacheStorage* MOZ_NON_OWNING_REF mListener;
 
-  nsRefPtr<Feature> mFeature;
-
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorageChild_h
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/ActorUtils.h"
-#include "mozilla/dom/cache/Feature.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // declared in ActorUtils.h
@@ -36,28 +35,16 @@ CacheStreamControlChild::CacheStreamCont
 {
   MOZ_COUNT_CTOR(cache::CacheStreamControlChild);
 }
 
 CacheStreamControlChild::~CacheStreamControlChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_COUNT_DTOR(cache::CacheStreamControlChild);
-  MOZ_ASSERT(!mFeature);
-}
-
-void
-CacheStreamControlChild::SetFeature(Feature* aFeature)
-{
-  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  MOZ_ASSERT(!mFeature);
-  mFeature = aFeature;
-  if (mFeature) {
-    mFeature->AddActor(this);
-  }
 }
 
 void
 CacheStreamControlChild::AddListener(ReadStream* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(!mListeners.Contains(aListener));
@@ -104,20 +91,17 @@ CacheStreamControlChild::ActorDestroy(Ac
   // CloseStreamWithoutReporting().
   ReadStreamList::ForwardIterator iter(mListeners);
   while (iter.HasMore()) {
     nsRefPtr<ReadStream> stream = iter.GetNext();
     stream->CloseStreamWithoutReporting();
   }
   mListeners.Clear();
 
-  if (mFeature) {
-    mFeature->RemoveActor(this);
-    mFeature = nullptr;
-  }
+  RemoveFeature();
 }
 
 bool
 CacheStreamControlChild::RecvClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   DebugOnly<uint32_t> closedCount = 0;
 
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -10,28 +10,25 @@
 #include "mozilla/dom/cache/ActorChild.h"
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
 #include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class Feature;
 class ReadStream;
 
 class CacheStreamControlChild MOZ_FINAL : public PCacheStreamControlChild
                                         , public ActorChild
 {
 public:
   CacheStreamControlChild();
   ~CacheStreamControlChild();
 
-  void SetFeature(Feature* aFeature);
-
   void AddListener(ReadStream* aListener);
   void RemoveListener(ReadStream* aListener);
 
   void NoteClosed(const nsID& aId);
 
   // ActorChild methods
   virtual void StartDestroy() MOZ_OVERRIDE;
 
@@ -39,17 +36,16 @@ private:
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
   typedef nsTObserverArray<ReadStream*> ReadStreamList;
   ReadStreamList mListeners;
 
-  nsRefPtr<Feature> mFeature;
   bool mDestroyStarted;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -33,16 +33,17 @@ EXPORTS.mozilla.dom.cache += [
     'StreamList.h',
     'StreamUtils.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 UNIFIED_SOURCES += [
     'Action.cpp',
+    'ActorChild.cpp',
     'AutoUtils.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
