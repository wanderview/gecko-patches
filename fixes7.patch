# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e2168468c36593bc826588ba282db0e7ef5ffce9

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -8948,17 +8948,18 @@ nsDocShell::RestoreFromHistory()
       NS_ASSERTION(newRootView->GetNextSibling() == rootViewSibling,
                    "error in InsertChild");
     }
   }
 
   // If parent is suspended, increase suspension count.
   // This can't be done as early as event suppression since this
   // depends on docshell tree.
-  privWin->NewSyncSuspendAndFreezeStateToParentWindow();
+  MOZ_ASSERT(privWin->GetCurrentInnerWindow());
+  privWin->GetCurrentInnerWindow()->NewSyncSuspendAndFreezeStateToParentWindow();
 
   // Now that all of the child docshells have been put into place, we can
   // restart the timers for the window and all of the child frames.
   privWin->NewResume();
 
   // Restore the refresh URI list.  The refresh timers will be restarted
   // when EndPageLoad() is called.
   mRefreshURIList = refreshURIList;
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -2834,17 +2834,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
     JS::Rooted<JSObject*> rootedJSObject(cx, GetWrapperPreserveColor());
     JS::Rooted<JSObject*> proto1(cx), proto2(cx);
     JS_GetPrototype(cx, rootedJSObject, &proto1);
     JS_GetPrototype(cx, newInnerGlobal, &proto2);
     NS_ASSERTION(proto1 == proto2,
                  "outer and inner globals should have the same prototype");
 #endif
 
-    NewSyncSuspendAndFreezeStateToParentWindow();
+    newInnerWindow->NewSyncSuspendAndFreezeStateToParentWindow();
   }
 
   // Add an extra ref in case we release mContext during GC.
   nsCOMPtr<nsIScriptContext> kungFuDeathGrip(mContext);
 
   aDocument->SetScriptGlobalObject(newInnerWindow);
 
   if (!aState) {
@@ -8777,16 +8777,17 @@ nsGlobalWindow::LeaveModalState()
   nsGlobalWindow* topWin = GetScriptableTopInternal();
 
   if (!topWin) {
     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
     return;
   }
 
   MOZ_ASSERT(topWin->mModalStateDepth != 0);
+  MOZ_ASSERT(NewIsSuspended());
   MOZ_ASSERT(topWin->NewIsSuspended());
   topWin->mModalStateDepth--;
 
   if (topWin->mModalStateDepth == 0) {
     topWin->NewResume();
 
     if (topWin->mSuspendedDoc) {
       nsCOMPtr<nsIDocument> currentDoc = topWin->GetExtantDoc();
@@ -11841,52 +11842,45 @@ nsGlobalWindow::NewIsFrozen() const
   bool frozen =  mFreezeDepth != 0;
   MOZ_ASSERT_IF(frozen, NewIsSuspended());
   return frozen;
 }
 
 void
 nsGlobalWindow::NewSyncSuspendAndFreezeStateToParentWindow()
 {
+  // This method should only be called on an inner window that has been
+  // assigned to an outer window already.
+  MOZ_ASSERT(IsInnerWindow());
   nsPIDOMWindowOuter* outer = GetOuterWindow();
-  if (!outer) {
-    return;
-  }
-
+  MOZ_ASSERT(outer);
+
+  // Attempt to find our parent windows.
   nsCOMPtr<Element> frame = outer->GetFrameElementInternal();
-  if (!frame) {
-    return;
-  }
-
-  nsPIDOMWindowOuter* parentOuter = frame->OwnerDoc()->GetWindow();
-  if (!parentOuter) {
-    return;
-  }
-
+  nsPIDOMWindowOuter* parentOuter = frame ? frame->OwnerDoc()->GetWindow()
+                                          : nullptr;
   nsGlobalWindow* parentInner =
-    nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow());
-  if (!parentInner) {
-    return;
-  }
-
-  uint32_t parentFreezeDepth = parentInner->mFreezeDepth;
-  uint32_t parentSuspendDepth = parentInner->mSuspendDepth;
-
-  // Since every Freeze() calls Suspend(), the suspend count must
-  // be equal or greater to the freeze count.
-  MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
+    parentOuter ? nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow())
+                : nullptr;
 
   // If our outer is in a modal state, but our parent is not in a modal
   // state, then we must apply the suspend directly.  If our parent is
   // in a modal state then we should get the suspend automatically
   // via the parentSuspendDepth application below.
-  if (!parentInner->IsInModalState() && IsInModalState()) {
+  if ((!parentInner || !parentInner->IsInModalState()) && IsInModalState()) {
     NewSuspend();
   }
 
+  uint32_t parentFreezeDepth = parentInner ? parentInner->mFreezeDepth : 0;
+  uint32_t parentSuspendDepth = parentInner ? parentInner->mSuspendDepth : 0;
+
+  // Since every Freeze() calls Suspend(), the suspend count must
+  // be equal or greater to the freeze count.
+  MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
+
   // First apply the Freeze() calls.
   for (uint32_t i = 0; i < parentFreezeDepth; ++i) {
     NewFreeze();
   }
 
   // Now apply only the number of Suspend() calls to reach the target
   // suspend count after applying the Freeze() calls.
   for (uint32_t i = 0; i < (parentSuspendDepth - parentFreezeDepth); ++i) {
