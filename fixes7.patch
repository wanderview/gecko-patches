# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  41a68cdde882e57276c2f2c8b02d350f6674cfcf

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1226,16 +1226,18 @@ nsGlobalWindow::nsGlobalWindow(nsGlobalW
     mDialogAbuseCount(0),
     mAreDialogsEnabled(true),
     mCanSkipCCGeneration(0),
     mStaticConstellation(0),
     mConstellation(NullCString())
 {
   AssertIsOnMainThread();
 
+  printf_stderr("### ### [%p] nsGlobalWindow()\n", this);
+
   nsLayoutStatics::AddRef();
 
   // Initialize the PRCList (this).
   PR_INIT_CLIST(this);
 
   if (aOuterWindow) {
     // |this| is an inner window, add this inner window to the outer
     // window list of inners.
@@ -1345,16 +1347,18 @@ nsGlobalWindow::Init()
 
   sWindowsById = new WindowByIdTable();
 }
 
 nsGlobalWindow::~nsGlobalWindow()
 {
   AssertIsOnMainThread();
 
+  printf_stderr("### ### [%p] ~nsGlobalWindow()\n", this);
+
   DisconnectEventTargetObjects();
 
   // We have to check if sWindowsById isn't null because ::Shutdown might have
   // been called.
   if (sWindowsById) {
     NS_ASSERTION(sWindowsById->Get(mWindowID),
                  "This window should be in the hash table");
     sWindowsById->Remove(mWindowID);
@@ -2739,16 +2743,18 @@ nsGlobalWindow::SetNewDocument(nsIDocume
 
       // Don't free objects on our current inner window if it's going to be
       // held in the bfcache.
       if (!currentInner->NewIsFrozen()) {
         currentInner->FreeInnerObjects();
       }
     }
 
+    printf_stderr("### ### [%p] nsGlobalWindow::SetNewDocument() inner %p to %p\n",
+                  this, mInnerWindow, newInnerWindow->AsInner());
     mInnerWindow = newInnerWindow->AsInner();
 
     if (!GetWrapperPreserveColor()) {
       JS::Rooted<JSObject*> outer(cx,
         NewOuterWindowProxy(cx, newInnerGlobal, thisChrome));
       NS_ENSURE_TRUE(outer, NS_ERROR_FAILURE);
 
       js::SetProxyExtra(outer, 0, js::PrivateValue(ToSupports(this)));
@@ -2834,17 +2840,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
     JS::Rooted<JSObject*> rootedJSObject(cx, GetWrapperPreserveColor());
     JS::Rooted<JSObject*> proto1(cx), proto2(cx);
     JS_GetPrototype(cx, rootedJSObject, &proto1);
     JS_GetPrototype(cx, newInnerGlobal, &proto2);
     NS_ASSERTION(proto1 == proto2,
                  "outer and inner globals should have the same prototype");
 #endif
 
-    NewSyncSuspendAndFreezeStateToParentWindow();
+    newInnerWindow->NewSyncSuspendAndFreezeStateToParentWindow();
   }
 
   // Add an extra ref in case we release mContext during GC.
   nsCOMPtr<nsIScriptContext> kungFuDeathGrip(mContext);
 
   aDocument->SetScriptGlobalObject(newInnerWindow);
 
   if (!aState) {
@@ -8713,16 +8719,19 @@ nsGlobalWindow::EnterModalState()
   // <iframe mozbrowser>.
   nsGlobalWindow* topWin = GetScriptableTopInternal();
 
   if (!topWin) {
     NS_ERROR("Uh, EnterModalState() called w/o a reachable top window?");
     return;
   }
 
+  printf_stderr("### ### [%p] nsGlobalWindow::EnterModalState() topWin:%p count:%u to %u\n",
+                this, topWin, topWin->mModalStateDepth, (topWin->mModalStateDepth + 1));
+
   // If there is an active ESM in this window, clear it. Otherwise, this can
   // cause a problem if a modal state is entered during a mouseup event.
   EventStateManager* activeESM =
     static_cast<EventStateManager*>(
       EventStateManager::GetActiveEventStateManager());
   if (activeESM && activeESM->GetPresContext()) {
     nsIPresShell* activeShell = activeESM->GetPresContext()->GetPresShell();
     if (activeShell && (
@@ -8776,17 +8785,21 @@ nsGlobalWindow::LeaveModalState()
 
   nsGlobalWindow* topWin = GetScriptableTopInternal();
 
   if (!topWin) {
     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
     return;
   }
 
+  printf_stderr("### ### [%p] nsGlobalWindow::LeaveModalState() topWin:%p count:%u to %u\n",
+                this, topWin, topWin->mModalStateDepth, (topWin->mModalStateDepth - 1));
+
   MOZ_ASSERT(topWin->mModalStateDepth != 0);
+  MOZ_ASSERT(NewIsSuspended());
   MOZ_ASSERT(topWin->NewIsSuspended());
   topWin->mModalStateDepth--;
 
   if (topWin->mModalStateDepth == 0) {
     topWin->NewResume();
 
     if (topWin->mSuspendedDoc) {
       nsCOMPtr<nsIDocument> currentDoc = topWin->GetExtantDoc();
@@ -11603,16 +11616,19 @@ nsGlobalWindow::CloneStorageEvent(const 
 void
 nsGlobalWindow::NewSuspend()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewSuspend, ());
 
   CallOnChildren(&nsGlobalWindow::NewSuspend);
 
+  printf_stderr("### ### [%p] nsGlobalWindow::NewSuspend() %u to %u\n",
+                this, mSuspendDepth, (mSuspendDepth + 1));
+
   mSuspendDepth += 1;
   if (mSuspendDepth != 1) {
     return;
   }
 
   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
   if (ac) {
     for (uint32_t i = 0; i < mEnabledSensors.Length(); i++)
@@ -11651,16 +11667,19 @@ nsGlobalWindow::NewSuspend()
 void
 nsGlobalWindow::NewResume()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewResume, ());
 
   CallOnChildren(&nsGlobalWindow::NewResume);
 
+  printf_stderr("### ### [%p] nsGlobalWindow::NewSuspend() %u to %u\n",
+                this, mSuspendDepth, (mSuspendDepth - 1));
+
   MOZ_ASSERT(mSuspendDepth != 0);
   mSuspendDepth -= 1;
   if (mSuspendDepth != 0) {
     return;
   }
 
   // We should not be able to resume a frozen window.  It must be Thaw()'d first.
   MOZ_ASSERT(mFreezeDepth == 0);
@@ -11733,16 +11752,18 @@ nsGlobalWindow::NewResume()
 }
 
 bool
 nsGlobalWindow::NewIsSuspended() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   // No inner means we are effectively suspended
   FORWARD_TO_INNER(NewIsSuspended, (), true);
+  printf_stderr("### ### [%p] nsGlobalWindow::NewIsSuspend() %u\n",
+                this, mSuspendDepth);
   return mSuspendDepth != 0;
 }
 
 void
 nsGlobalWindow::NewFreeze()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewFreeze, ());
@@ -11841,52 +11862,45 @@ nsGlobalWindow::NewIsFrozen() const
   bool frozen =  mFreezeDepth != 0;
   MOZ_ASSERT_IF(frozen, NewIsSuspended());
   return frozen;
 }
 
 void
 nsGlobalWindow::NewSyncSuspendAndFreezeStateToParentWindow()
 {
+  printf_stderr("### ### [%p] NewSyncSuspendAndFreezeStateToParentWindow()\n", this);
   nsPIDOMWindowOuter* outer = GetOuterWindow();
-  if (!outer) {
-    return;
-  }
-
-  nsCOMPtr<Element> frame = outer->GetFrameElementInternal();
-  if (!frame) {
-    return;
-  }
-
-  nsPIDOMWindowOuter* parentOuter = frame->OwnerDoc()->GetWindow();
-  if (!parentOuter) {
-    return;
-  }
-
-  nsGlobalWindow* parentInner =
-    nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow());
-  if (!parentInner) {
-    return;
-  }
-
-  uint32_t parentFreezeDepth = parentInner->mFreezeDepth;
-  uint32_t parentSuspendDepth = parentInner->mSuspendDepth;
-
-  // Since every Freeze() calls Suspend(), the suspend count must
-  // be equal or greater to the freeze count.
-  MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
+  nsCOMPtr<Element> frame = outer ? outer->GetFrameElementInternal() : nullptr;
+  nsPIDOMWindowOuter* parentOuter = frame ? frame->OwnerDoc()->GetWindow() : nullptr;
+  nsGlobalWindow* parentInner = parentOuter ?
+    nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow()) : nullptr;
 
   // If our outer is in a modal state, but our parent is not in a modal
   // state, then we must apply the suspend directly.  If our parent is
   // in a modal state then we should get the suspend automatically
   // via the parentSuspendDepth application below.
-  if (!parentInner->IsInModalState() && IsInModalState()) {
+  if ((!parentInner || !parentInner->IsInModalState()) && IsInModalState()) {
     NewSuspend();
   }
 
+  if (!parentInner) {
+    return;
+  }
+
+  printf_stderr("### ### [%p] NewSyncSuspendAndFreezeStateToParentWindow() outer:%p parentOuter:%p parentInner:%p\n",
+                this, outer, parentOuter, parentInner);
+
+  uint32_t parentFreezeDepth = parentInner->mFreezeDepth;
+  uint32_t parentSuspendDepth = parentInner->mSuspendDepth;
+
+  // Since every Freeze() calls Suspend(), the suspend count must
+  // be equal or greater to the freeze count.
+  MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
+
   // First apply the Freeze() calls.
   for (uint32_t i = 0; i < parentFreezeDepth; ++i) {
     NewFreeze();
   }
 
   // Now apply only the number of Suspend() calls to reach the target
   // suspend count after applying the Freeze() calls.
   for (uint32_t i = 0; i < (parentSuspendDepth - parentFreezeDepth); ++i) {
