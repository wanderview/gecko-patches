# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent f8377d18665b5a5f90a4570442faa7b0a9f4873c
Bug 1133939 P1 Free buffer resources when an nsPipeInputStream is closed. r=froydnj

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -287,16 +287,19 @@ public:
   //
   // methods below may be called while outside the pipe's monitor
   //
 
   nsresult GetReadSegment(const nsPipeReadState& aReadState,
                           const char*& aSegment, uint32_t& aSegmentLen);
   void     AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aCount,
                              uint32_t* aAvailableOut);
+  bool     AdvanceReadSegment(nsPipeReadState& aReadState);
+  void     DrainInputStream(nsPipeReadState& aReadState, nsPipeEvents& aEvents,
+                            uint32_t* aAvailableOut);
 
   nsresult GetWriteSegment(char*& aSegment, uint32_t& aSegmentLen);
   void     AdvanceWriteCursor(uint32_t aCount);
 
   void     OnInputStreamException(nsPipeInputStream* aStream, nsresult aReason);
   void     OnPipeException(nsresult aReason, bool aOutputOnly = false);
 
   nsresult CloneInputStream(nsPipeInputStream* aOriginal,
@@ -540,65 +543,95 @@ nsPipe::AdvanceReadCursor(nsPipeReadStat
 
       // if still writing in this segment then bail because we're not done
       // with the segment and have to wait for now...
       if (mWriteSegment == aReadState.mSegment && mWriteLimit > mWriteCursor) {
         NS_ASSERTION(aReadState.mReadLimit == mWriteCursor, "unexpected state");
         return;
       }
 
-      uint32_t currentSegment = aReadState.mSegment;
+      bool modified = AdvanceReadSegment(aReadState);
 
-      // Move to the next segment to read
-      aReadState.mSegment += 1;
-
-      // If this was the last reference to the first segment, then remove it.
-      if (currentSegment == 0 && CountSegmentReferences(currentSegment) == 0) {
-
-        // shift write and read segment index (-1 indicates an empty buffer).
-        mWriteSegment -= 1;
-
-        for (uint32_t i = 0; i < mInputList.Length(); ++i) {
-          mInputList[i]->ReadState().mSegment -= 1;
-        }
-
-        // done with this segment
-        mBuffer.DeleteFirstSegment();
-        LOG(("III deleting first segment\n"));
-      }
-
-      if (mWriteSegment < aReadState.mSegment) {
-        // read cursor has hit the end of written data, so reset it
-        MOZ_ASSERT(mWriteSegment == (aReadState.mSegment - 1));
-        aReadState.mReadCursor = nullptr;
-        aReadState.mReadLimit = nullptr;
-        // also, the buffer is completely empty, so reset the write cursor
-        if (mWriteSegment == -1) {
-          mWriteCursor = nullptr;
-          mWriteLimit = nullptr;
-        }
-      } else {
-        // advance read cursor and limit to next buffer segment
-        aReadState.mReadCursor = mBuffer.GetSegment(aReadState.mSegment);
-        if (mWriteSegment == aReadState.mSegment) {
-          aReadState.mReadLimit = mWriteCursor;
-        } else {
-          aReadState.mReadLimit = aReadState.mReadCursor + mBuffer.GetSegmentSize();
-        }
-      }
-
-      // we've free'd up a segment, so notify output stream that pipe has
+      // if we've free'd up a segment, notify output stream that pipe has
       // room for a new segment.
-      if (mOutput.OnOutputWritable(events)) {
+      if (modified && mOutput.OnOutputWritable(events)) {
         mon.Notify();
       }
     }
   }
 }
 
+bool
+nsPipe::AdvanceReadSegment(nsPipeReadState& aReadState)
+{
+  uint32_t currentSegment = aReadState.mSegment;
+
+  // Move to the next segment to read
+  aReadState.mSegment += 1;
+
+  bool segmentDeleted = false;
+
+  // If this was the last reference to the first segment, then remove it.
+  if (currentSegment == 0 && CountSegmentReferences(currentSegment) == 0) {
+
+    // shift write and read segment index (-1 indicates an empty buffer).
+    mWriteSegment -= 1;
+
+    for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+      mInputList[i]->ReadState().mSegment -= 1;
+    }
+
+    // done with this segment
+    mBuffer.DeleteFirstSegment();
+    LOG(("III deleting first segment\n"));
+
+    segmentDeleted = true;
+  }
+
+  if (mWriteSegment < aReadState.mSegment) {
+    // read cursor has hit the end of written data, so reset it
+    MOZ_ASSERT(mWriteSegment == (aReadState.mSegment - 1));
+    aReadState.mReadCursor = nullptr;
+    aReadState.mReadLimit = nullptr;
+    // also, the buffer is completely empty, so reset the write cursor
+    if (mWriteSegment == -1) {
+      mWriteCursor = nullptr;
+      mWriteLimit = nullptr;
+    }
+  } else {
+    // advance read cursor and limit to next buffer segment
+    aReadState.mReadCursor = mBuffer.GetSegment(aReadState.mSegment);
+    if (mWriteSegment == aReadState.mSegment) {
+      aReadState.mReadLimit = mWriteCursor;
+    } else {
+      aReadState.mReadLimit = aReadState.mReadCursor + mBuffer.GetSegmentSize();
+    }
+  }
+
+  return segmentDeleted;
+}
+
+void
+nsPipe::DrainInputStream(nsPipeReadState& aReadState, nsPipeEvents& aEvents,
+                         uint32_t* aAvailableOut)
+{
+  ReentrantMonitorAutoEnter mon(mReentrantMonitor);
+
+  bool modified = false;
+  while(mWriteSegment > aReadState.mSegment) {
+    modified = AdvanceReadSegment(aReadState) || modified;
+  }
+
+  // if we've free'd up a segment, notify output stream that pipe has
+  // room for a new segment.
+  if (true && mOutput.OnOutputWritable(aEvents)) {
+    mon.Notify();
+  }
+}
+
 nsresult
 nsPipe::GetWriteSegment(char*& aSegment, uint32_t& aSegmentLen)
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
   if (NS_FAILED(mStatus)) {
     return mStatus;
   }
@@ -969,17 +1002,17 @@ nsPipeInputStream::OnInputException(nsre
 
   NS_ASSERTION(NS_FAILED(aReason), "huh? successful exception");
 
   if (NS_SUCCEEDED(mInputStatus)) {
     mInputStatus = aReason;
   }
 
   // force count of available bytes to zero.
-  mAvailable = 0;
+  mPipe->DrainInputStream(mReadState, aEvents, &mAvailable);
 
   if (mCallback) {
     aEvents.NotifyInputReady(this, mCallback);
     mCallback = 0;
     mCallbackFlags = 0;
   } else if (mBlocked) {
     result = true;
   }
