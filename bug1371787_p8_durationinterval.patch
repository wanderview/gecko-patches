# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5bc027480cfd152256aee4f31e84c1f0c031c58c
Bug 1371787 P8 Change Timeout::mInterval member to a TimeDuration. r=ehsan

diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -67,18 +67,18 @@ public:
 
   // Used to allow several reasons for setting a timeout, where each
   // 'Reason' value is using a possibly overlapping set of id:s.
   Reason mReason;
 
   // Returned as value of setTimeout()
   uint32_t mTimeoutId;
 
-  // Interval in milliseconds
-  uint32_t mInterval;
+  // Interval
+  TimeDuration mInterval;
 
   // Identifies which firing level this Timeout is being processed in
   // when sync loops trigger nested firing.
   uint32_t mFiringId;
 
   uint32_t mNestingLevel;
 
   // The popup state at timeout creation time if not created from
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -230,17 +230,17 @@ TimeoutManager::IsInvalidFiringId(uint32
 
 // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
 // uses 5.
 #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
 
 TimeDuration
 TimeoutManager::CalculateDelay(Timeout* aTimeout) const {
   MOZ_DIAGNOSTIC_ASSERT(aTimeout);
-  TimeDuration result = TimeDuration::FromMilliseconds(aTimeout->mInterval);
+  TimeDuration result = aTimeout->mInterval;
 
   if (aTimeout->mIsInterval ||
       aTimeout->mNestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
     result = TimeDuration::Max(
       result, TimeDuration::FromMilliseconds(gMinClampTimeoutValue));
   }
 
   if (aTimeout->mIsTracking && mThrottleTrackingTimeouts) {
@@ -377,17 +377,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
   if (static_cast<uint32_t>(interval) > maxTimeoutMs) {
     interval = maxTimeoutMs;
   }
 
   RefPtr<Timeout> timeout = new Timeout();
   timeout->mWindow = &mWindow;
   timeout->mIsInterval = aIsInterval;
-  timeout->mInterval = interval;
+  timeout->mInterval = TimeDuration::FromMilliseconds(interval);
   timeout->mScriptHandler = aHandler;
   timeout->mReason = aReason;
 
   // No popups from timeouts by default
   timeout->mPopupState = openAbused;
 
   switch (gTimeoutBucketingStrategy) {
   default:
@@ -474,17 +474,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   *aReturn = timeout->mTimeoutId;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Set%s(TimeoutManager=%p, timeout=%p, delay=%i, "
            "minimum=%f, throttling=%s, background=%d, realInterval=%f) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
            this, timeout.get(), interval,
-           (CalculateDelay(timeout) - TimeDuration::FromMilliseconds(interval)).ToMilliseconds(),
+           (CalculateDelay(timeout) - timeout->mInterval).ToMilliseconds(),
            mThrottleTrackingTimeouts ? "yes"
                                      : (mThrottleTrackingTimeoutsTimer ?
                                           "pending" : "no"),
            int(IsBackground()), realInterval.ToMilliseconds(),
            timeout->mIsTracking ? "" : "non-",
            timeout->mTimeoutId));
 
   return NS_OK;
