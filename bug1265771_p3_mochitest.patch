# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b25ae3298eb28741f4a52cbe2af72756084fc37f
Bug 1265771 P3 Expand browser_force_refresh.js to verify Clients.matchAll() behavior on refresh. r=bz

diff --git a/dom/workers/test/serviceworkers/browser_cached_force_refresh.html b/dom/workers/test/serviceworkers/browser_cached_force_refresh.html
--- a/dom/workers/test/serviceworkers/browser_cached_force_refresh.html
+++ b/dom/workers/test/serviceworkers/browser_cached_force_refresh.html
@@ -3,15 +3,62 @@
   http://creativecommons.org/publicdomain/zero/1.0/
 -->
 <!DOCTYPE HTML>
 <html>
 <head>
 </head>
 <body>
 <script type="text/javascript">
+function ok(exp, msg) {
+  if (!exp) {
+    throw(msg);
+  }
+}
+
+function is(actual, expected, msg) {
+  if (actual !== expected) {
+    throw('got "' + actual + '", but expected "' + expected + '" - ' + msg);
+  }
+}
+
+function fail(err) {
+  var custom = new CustomEvent('cached-failure', {
+    bubbles: true,
+    detail: err
+  });
+  document.dispatchEvent(custom);
+}
+
+function getUncontrolledClients(sw) {
+  return new Promise(function(resolve, reject) {
+    navigator.serviceWorker.addEventListener('message', function onMsg(evt) {
+      if (evt.data.type === 'CLIENTS') {
+        navigator.serviceWorker.removeEventListener('message', onMsg);
+        resolve(evt.data.detail);
+      }
+    });
+    sw.postMessage({ type: 'GET_UNCONTROLLED_CLIENTS' })
+  });
+}
+
 addEventListener('load', function(event) {
-  var custom = new Event('cached-load', { bubbles: true });
-  document.dispatchEvent(custom);
+  if (!navigator.serviceWorker.controller) {
+    return fail(window.location.href + ' is not controlled!');
+  }
+
+  getUncontrolledClients(navigator.serviceWorker.controller)
+    .then(function(clientList) {
+      is(clientList.length, 1, 'should only have one client');
+      is(clientList[0].url, window.location.href,
+         'client url should match current window');
+      is(clientList[0].frameType, 'top-level',
+         'client should be a top-level window');
+      var custom = new Event('cached-load', { bubbles: true });
+      document.dispatchEvent(custom);
+    })
+    .catch(function(err) {
+      fail(err);
+    });
 });
 </script>
 </body>
 </html>
diff --git a/dom/workers/test/serviceworkers/browser_force_refresh.js b/dom/workers/test/serviceworkers/browser_force_refresh.js
--- a/dom/workers/test/serviceworkers/browser_force_refresh.js
+++ b/dom/workers/test/serviceworkers/browser_force_refresh.js
@@ -9,24 +9,25 @@ function refresh() {
 }
 
 function forceRefresh() {
   EventUtils.synthesizeKey('R', { accelKey: true, shiftKey: true });
 }
 
 function frameScript() {
   function eventHandler(event) {
-    sendAsyncMessage("test:event", {type: event.type});
+    sendAsyncMessage("test:event", {type: event.type, detail: event.detail});
   }
 
   // These are tab-local, so no need to unregister them.
   addEventListener('base-load', eventHandler, true, true);
   addEventListener('base-register', eventHandler, true, true);
   addEventListener('base-sw-ready', eventHandler, true, true);
   addEventListener('cached-load', eventHandler, true, true);
+  addEventListener('cached-failure', eventHandler, true, true);
 }
 
 function test() {
   waitForExplicitFinish();
   SpecialPowers.pushPrefEnv({'set': [['dom.serviceWorkers.enabled', true],
                                      ['dom.serviceWorkers.exemptFromPerDomainMax', true],
                                      ['dom.serviceWorkers.testing.enabled', true],
                                      ['dom.caches.enabled', true],
@@ -42,42 +43,49 @@ function test() {
 
     function done() {
       tab.linkedBrowser.messageManager.removeMessageListener("test:event", eventHandler);
 
       gBrowser.removeTab(tab);
       executeSoon(finish);
     }
 
-    var cachedLoad = false;
+    var maxCacheLoadCount = 3;
+    var cachedLoadCount = 0;
     var baseLoadCount = 0;
 
     function eventHandler(msg) {
       if (msg.data.type === 'base-load') {
         baseLoadCount += 1;
-        if (cachedLoad) {
+        if (cachedLoadCount === maxCacheLoadCount) {
           is(baseLoadCount, 2, 'cached load should occur before second base load');
           return done();
         }
         if (baseLoadCount !== 1) {
           ok(false, 'base load without cached load should only occur once');
           return done();
         }
       } else if (msg.data.type === 'base-register') {
-        ok(!cachedLoad, 'cached load should not occur before base register');
+        ok(!cachedLoadCount, 'cached load should not occur before base register');
         is(baseLoadCount, 1, 'register should occur after first base load');
       } else if (msg.data.type === 'base-sw-ready') {
-        ok(!cachedLoad, 'cached load should not occur before base ready');
+        ok(!cachedLoadCount, 'cached load should not occur before base ready');
         is(baseLoadCount, 1, 'ready should occur after first base load');
         refresh();
       } else if (msg.data.type === 'cached-load') {
-        ok(!cachedLoad, 'cached load should not occur twice');
+        ok(cachedLoadCount < maxCacheLoadCount, 'cached load should not occur too many times');
         is(baseLoadCount, 1, 'cache load occur after first base load');
-        cachedLoad = true;
+        cachedLoadCount += 1;
+        if (cachedLoadCount < maxCacheLoadCount) {
+          return refresh();
+        }
         forceRefresh();
+      } else if (msg.data.type === 'cached-failure') {
+        ok(false, 'failure: ' + msg.data.detail);
+        done();
       }
 
       return;
     }
 
     tab.linkedBrowser.messageManager.addMessageListener("test:event", eventHandler);
   });
 }
diff --git a/dom/workers/test/serviceworkers/force_refresh_browser_worker.js b/dom/workers/test/serviceworkers/force_refresh_browser_worker.js
--- a/dom/workers/test/serviceworkers/force_refresh_browser_worker.js
+++ b/dom/workers/test/serviceworkers/force_refresh_browser_worker.js
@@ -15,8 +15,20 @@ self.addEventListener('fetch', function 
   event.respondWith(
     caches.open(name).then(function(cache) {
       return cache.match(event.request);
     }).then(function(response) {
       return response || fetch(event.request);
     })
   );
 });
+
+self.addEventListener('message', function (event) {
+  if (event.data.type === 'GET_UNCONTROLLED_CLIENTS') {
+    event.waitUntil(clients.matchAll({ includeUncontrolled: true })
+      .then(function(clientList) {
+        var resultList = clientList.map(function(c) {
+          return { url: c.url, frameType: c.frameType };
+        });
+        event.source.postMessage({ type: 'CLIENTS', detail: resultList });
+      }));
+  }
+});
