# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6cf782b9c2736047a9d1dd4f16b7a6b496c1825f
Bug 1375659 P4 Remove WorkerPrivate::GetEventTarget(). r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -2969,55 +2969,16 @@ WorkerPrivateParent<Derived>::MaybeWrapA
   }
 
   workerRunnable =
     new ExternalRunnableWrapper(ParentAsWorkerPrivate(), runnable);
   return workerRunnable.forget();
 }
 
 template <class Derived>
-already_AddRefed<nsISerialEventTarget>
-WorkerPrivateParent<Derived>::GetEventTarget()
-{
-  WorkerPrivate* self = ParentAsWorkerPrivate();
-
-  nsCOMPtr<nsISerialEventTarget> target;
-
-  bool needAutoDisable = false;
-
-  {
-    MutexAutoLock lock(mMutex);
-
-    if (!mEventTarget) {
-      mEventTarget = new EventTarget(self);
-
-      // If the worker is already shutting down then we want to
-      // immediately disable the event target.  This will cause
-      // the Dispatch() method to fail, but the event target
-      // will still exist.
-      if (self->mStatus > Running) {
-        needAutoDisable = true;
-      }
-    }
-
-    target = mEventTarget;
-  }
-
-  // Make sure to call Disable() outside of the mutex since it
-  // also internally locks a mutex.
-  if (needAutoDisable) {
-    mEventTarget->Disable();
-  }
-
-
-  MOZ_DIAGNOSTIC_ASSERT(target);
-  return target.forget();
-}
-
-template <class Derived>
 bool
 WorkerPrivateParent<Derived>::Start()
 {
   // May be called on any thread!
   {
     MutexAutoLock lock(mMutex);
 
     NS_ASSERTION(mParentStatus != Running, "How can this be?!");
@@ -6152,27 +6113,16 @@ WorkerPrivate::NotifyInternal(JSContext*
     previousStatus = mStatus;
     mStatus = aStatus;
 
     // Mark parent status as closing immediately to avoid new events being
     // dispatched after we clear the queue below.
     if (aStatus == Closing) {
       Close();
     }
-
-    eventTarget = mEventTarget;
-  }
-
-  // Disable the event target, if it exists.
-  if (eventTarget) {
-    // Since we'll no longer process events, make sure we no longer allow anyone
-    // to post them. We have to do this without mMutex held, since our mutex
-    // must be acquired *after* the WorkerEventTarget's mutex when they're both
-    // held.
-    eventTarget->Disable();
   }
 
   if (mCrossThreadDispatcher) {
     // Since we'll no longer process events, make sure we no longer allow
     // anyone to post them. We have to do this without mMutex held, since our
     // mutex must be acquired *after* mCrossThreadDispatcher's mutex when
     // they're both held.
     mCrossThreadDispatcher->Forget();
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -207,17 +207,16 @@ public:
 
 protected:
   typedef mozilla::ErrorResult ErrorResult;
 
   SharedMutex mMutex;
   mozilla::CondVar mCondVar;
 
   // Protected by mMutex.
-  RefPtr<EventTarget> mEventTarget;
   nsTArray<RefPtr<WorkerRunnable>> mPreStartRunnables;
 
 private:
   WorkerPrivate* mParent;
   nsString mScriptURL;
   // This is the worker name for shared workers and dedicated workers.
   nsString mWorkerName;
   // This is the worker scope for service workers.
@@ -331,19 +330,16 @@ public:
   DispatchControlRunnable(already_AddRefed<WorkerControlRunnable> aWorkerControlRunnable);
 
   nsresult
   DispatchDebuggerRunnable(already_AddRefed<WorkerRunnable> aDebuggerRunnable);
 
   already_AddRefed<WorkerRunnable>
   MaybeWrapAsWorkerRunnable(already_AddRefed<nsIRunnable> aRunnable);
 
-  already_AddRefed<nsISerialEventTarget>
-  GetEventTarget();
-
   // May be called on any thread...
   bool
   Start();
 
   // Called on the parent thread.
   bool
   Notify(Status aStatus)
   {
