# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1f34f41b56848277e40aae10a9889531733d8cd2
Bug 1093357 P0.2 HTTP channels should clone streams instead of rewinding when possible. r=jduell

diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -2304,20 +2304,25 @@ HttpBaseChannel::SetupReplacementChannel
     return NS_OK; // no other options to set
 
   if (preserveMethod) {
     nsCOMPtr<nsIUploadChannel> uploadChannel =
       do_QueryInterface(httpChannel);
     nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
       do_QueryInterface(httpChannel);
     if (mUploadStream && (uploadChannel2 || uploadChannel)) {
-      // rewind upload stream
-      nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
-      if (seekable)
-        seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
+      // Rewind the upload stream if it can't be directly cloned.  Otherwise
+      // we don't need to rewind because we clone before passing the upload
+      // to the transaction to consume.
+      if (!NS_InputStreamIsCloneable(mUploadStream)) {
+        nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
+        if (seekable) {
+          seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
+        }
+      }
 
       // replicate original call to SetUploadStream...
       if (uploadChannel2) {
         const char *ctype = mRequestHead.PeekHeader(nsHttp::Content_Type);
         if (!ctype)
           ctype = "";
         const char *clen  = mRequestHead.PeekHeader(nsHttp::Content_Length);
         int64_t len = clen ? nsCRT::atoll(clen) : -1;
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -1630,16 +1630,25 @@ HttpChannelChild::ContinueAsyncOpen()
   SerializeURI(mDocumentURI, openArgs.doc());
   SerializeURI(mReferrer, openArgs.referrer());
   openArgs.referrerPolicy() = mReferrerPolicy;
   SerializeURI(mAPIRedirectToURI, openArgs.apiRedirectTo());
   openArgs.loadFlags() = mLoadFlags;
   openArgs.requestHeaders() = mClientSetRequestHeaders;
   openArgs.requestMethod() = mRequestHead.Method();
 
+  // Clone the upload stream before passing across IPC and consuming it.
+  // This is necessary to allow the upload stream to be set properly in
+  // redirect callbacks in the child when stream rewinding is not supported.
+  nsCOMPtr<nsIInputStream> uploadStream;
+  if (NS_FAILED(NS_CloneInputStream(mUploadStream,
+                                    getter_AddRefs(uploadStream)))) {
+    uploadStream = mUploadStream;
+  }
+
   nsTArray<mozilla::ipc::FileDescriptor> fds;
   SerializeInputStream(mUploadStream, openArgs.uploadStream(), fds);
 
   if (mResponseHead) {
     openArgs.synthesizedResponseHead() = *mResponseHead;
   } else {
     openArgs.synthesizedResponseHead() = mozilla::void_t();
   }
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -901,19 +901,29 @@ nsHttpChannel::SetupTransaction()
     NS_QueryNotificationCallbacks(mCallbacks,
                                   mLoadGroup,
                                   NS_GET_IID(nsIHttpPushListener),
                                   getter_AddRefs(pushListener));
     if (pushListener) {
         mCaps |= NS_HTTP_ONPUSH_LISTENER;
     }
 
+    // If the upload stream supports cheap clones, then favor that approach
+    // to reusing the stream instead of rewinding when a redirect is
+    // encountered.  If cloning is not directly supported then just pass
+    // the current upload stream and fallback to rewinding.
+    nsCOMPtr<nsIInputStream> uploadStream;
+    if (NS_FAILED(NS_CloneInputStream(mUploadStream,
+                                      getter_AddRefs(uploadStream)))) {
+      uploadStream = mUploadStream;
+    }
+
     nsCOMPtr<nsIAsyncInputStream> responseStream;
     rv = mTransaction->Init(mCaps, mConnectionInfo, &mRequestHead,
-                            mUploadStream, mUploadStreamHasHeaders,
+                            uploadStream, mUploadStreamHasHeaders,
                             NS_GetCurrentThread(), callbacks, this,
                             getter_AddRefs(responseStream));
     if (NS_FAILED(rv)) {
         mTransaction = nullptr;
         return rv;
     }
 
     mTransaction->SetClassOfService(mClassOfService);
@@ -6417,18 +6427,19 @@ nsHttpChannel::DoAuthRetry(nsAHttpConnec
     // notify "http-on-modify-request" observers
     CallOnModifyRequestObservers();
 
     mIsPending = true;
 
     // get rid of the old response headers
     mResponseHead = nullptr;
 
-    // rewind the upload stream
-    if (mUploadStream) {
+    // Rewind the upload stream, but only if it does not support cloning.
+    // Otherwise we will clone before consuming the stream in the transaction.
+    if (mUploadStream && !NS_InputStreamIsCloneable(mUploadStream)) {
         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
         if (seekable)
             seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
     }
 
     // set sticky connection flag and disable pipelining.
     mCaps |=  NS_HTTP_STICKY_CONNECTION;
     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
