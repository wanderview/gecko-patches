# HG changeset patch
# Parent 9fda2f3ea00e739a4601e83e298a162765c72809
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 048 rewrite shutdown code


diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -136,21 +136,22 @@ public:
   friend class StaticAutoPtr<Manager::Factory>;
 
   static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     // Ensure there is a factory instance.  This forces the Get() call
     // below to use the same factory.
-    MaybeCreateInstance();
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     nsRefPtr<Manager> ref = Get(aManagerId);
     if (!ref) {
-      nsresult rv = shutdown::AddManagerId(aManagerId);
+      rv = shutdown::AddManagerId(aManagerId);
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
       // TODO: replace this with a thread pool (bug 1119864)
       nsCOMPtr<nsIThread> ioThread;
       rv = NS_NewNamedThread("DOMCacheThread", getter_AddRefs(ioThread));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
       ref = new Manager(aManagerId, ioThread);
@@ -161,59 +162,82 @@ public:
 
     return NS_OK;
   }
 
   static already_AddRefed<Manager> Get(ManagerId* aManagerId)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
-    MaybeCreateInstance();
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return nullptr; }
 
     for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
       if (*sFactory->mManagerList[i]->mManagerId == *aManagerId) {
         nsRefPtr<Manager> ref = sFactory->mManagerList[i];
         return ref.forget();
       }
     }
 
     return nullptr;
   }
 
   static void Remove(Manager* aManager)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(aManager);
 
-    MaybeCreateInstance();
+    nsresult rv = MaybeCreateInstance();
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Removing Manager after Manager::Factory fully shutdown!");
+    }
 
     for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
       if (sFactory->mManagerList[i] == aManager) {
         sFactory->mManagerList.RemoveElementAt(i);
 
         // clean up the factory singleton if there are no more managers
         if (sFactory->mManagerList.IsEmpty()) {
-          sFactory = nullptr;
+          DestroyInstance();
         }
 
         return;
       }
     }
 
     MOZ_ASSERT_UNREACHABLE("Factory does not know about this Manager!");
   }
 
-  static void ShutdownAll()
+  static void ShutdownAll(nsIRunnable* aShutdownCallback)
+  {
+    StaticMutexAutoLock lock(sLock);
+
+    sFactoryShutdown = true;
+
+    if (!sBackgroundThread) {
+      return;
+    }
+
+    // TODO: create runnable to ShutdownAllOnWorkerThread
+
+    nsresult rv = sBackgroundThread->Dispatch(runnable);
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
+  }
+
+  static void ShutdownAllOnWorkerThread(nsIRunnable* aShutdownCallback)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
       return;
     }
 
+    MOZ_ASSERT(!sFactory->mShutdownCallback);
+    sFactory->mShutdownCallback = aShutdownCallback;
+
     for (uint32_t i = 0; i < sFactory->mManagerList.Length(); ++i) {
       sFactory->mManagerList[i]->Shutdown();
     }
   }
 
 private:
   Factory()
   {
@@ -221,46 +245,90 @@ private:
   }
 
   ~Factory()
   {
     MOZ_COUNT_DTOR(cache::Manager::Factory);
     MOZ_ASSERT(mManagerList.IsEmpty());
   }
 
-  static void MaybeCreateInstance()
+  static nsresult MaybeCreateInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
+    StaticMutexAutoLock lock(sLock);
+
     if (!sFactory) {
+      if (sFactoryShutdown) {
+        return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+      }
+
       // We cannot use ClearOnShutdown() here because we're not on the main
       // thread.  Instead, we delete sFactory in Factory::Remove() after the
       // last manager is removed.  ShutdownObserver ensures this happens
       // before shutdown.
       sFactory = new Factory();
+      sBackgroundThread = NS_GetCurrentThread();
     }
 
     // Never return sFactory to code outside Factory.  We need to delete it
     // out from under ourselves just before we return from Remove().  This
     // would be (even more) dangerous if other code had a pointer to the
     // factory itself.
+
+    return NS_OK;
+  }
+
+  static nsresult DestroyInstance()
+  {
+    StaticMutexAutoLock lock(sLock);
+
+    if (sFactoryShutdown) {
+      MOZ_ASSERT(sFactory->mShutdownCallback);
+      rv = NS_DispatchToMainThread(sFactory->mShutdownCallback);
+      MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
+    }
+
+    sBackgroundThread = nullptr;
+    sFactory = nullptr;
   }
 
   // Singleton created on demand and deleted when last Manager is cleared
   // in Remove().
+  // PBackground thread only.
   static StaticAutoPtr<Factory> sFactory;
 
+  // protects following static attributes
+  static StaticMutex sLock;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sLock to access.
+  static bool sFactoryShutdown;
+
+  // Background thread owning all Manager objects.  Only set while sFactory is
+  // set.
+  // Must hold sLock to access.
+  static StaticRefPtr<nsIThread> sBackgroundThread;
+
   // Weak references as we don't want to keep Manager objects alive forever.
   // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
   nsTArray<Manager*> mManagerList;
+
+  // Attribute accessed on PBackground thread only and runnable dispatched to
+  // main thread.
+  nsCOMPtr<nsIRunnable> mShutdownCallback;
 };
 
 // static
 StaticAutoPtr<Manager::Factory> Manager::Factory::sFactory;
 
+// static
+bool Manager::Factory::sFactoryShutdown = false;
+
 // ----------------------------------------------------------------------------
 
 // Abstract class to help implement the various Actions.  The vast majority
 // of Actions are synchronous and need to report back to a Listener on the
 // Manager.
 class Manager::BaseAction : public SyncDBAction
 {
 protected:
@@ -1129,20 +1197,20 @@ already_AddRefed<Manager>
 Manager::Get(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   return Factory::Get(aManagerId);
 }
 
 // static
 void
-Manager::ShutdownAll()
+Manager::ShutdownAll(nsIRunnable* aShutdownCallback)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-  return Factory::ShutdownAll();
+  return Factory::ShutdownAll(aShutdownCallback);
 }
 
 void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   mListeners.RemoveElement(aListener);
   MOZ_ASSERT(!mListeners.Contains(aListener));
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -12,16 +12,17 @@
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIOutputStream;
+class nsIRunnable;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheRequestResponse;
 class Context;
@@ -112,17 +113,17 @@ public:
                                const nsTArray<nsString>& aKeys) { }
 
   protected:
     ~Listener() { }
   };
 
   static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut);
   static already_AddRefed<Manager> Get(ManagerId* aManagerId);
-  static void ShutdownAll();
+  static void ShutdownAll(nsIRunnable* aShutdownCallback);
 
   // Must be called by Listener objects before they are destroyed.
   void RemoveListener(Listener* aListener);
 
   // Must be called by Context objects before they are destroyed.
   void RemoveContext(Context* aContext);
 
   // If an actor represents a long term reference to a cache or body stream,
diff --git a/dom/cache/ShutdownObserver.cpp b/dom/cache/ShutdownObserver.cpp
--- a/dom/cache/ShutdownObserver.cpp
+++ b/dom/cache/ShutdownObserver.cpp
@@ -196,17 +196,18 @@ void
 CacheShutdownObserver::StartShutdownOnBgThread()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   MOZ_ASSERT(!gShuttingDown);
 
   // prevent any further AddManagerId() or Instance() calls
   gShuttingDown = true;
 
-  Manager::ShutdownAll();
+  // TODO: fix callback
+  Manager::ShutdownAll(nullptr);
 }
 
 void
 CacheShutdownObserver::ReleaseInstance()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   // Detect if a new ManagerId has been added in the time between
