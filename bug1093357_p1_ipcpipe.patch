# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4950176129282b21d0719ad4e1996d625d86be59
Bug 1093357 P1 Implement an actor for streaming pipes from child to parent. r=jld
* * *
Bug 1093357 P1 interdiff 001 address review feedback

diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -38,16 +38,17 @@
 #include "mozilla/dom/nsIContentChild.h"
 #include "mozilla/psm/PSMContentListener.h"
 #include "mozilla/hal_sandbox/PHalChild.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/FileDescriptorUtils.h"
 #include "mozilla/ipc/GeckoChildProcessHost.h"
 #include "mozilla/ipc/ProcessChild.h"
+#include "mozilla/ipc/PSendStreamChild.h"
 #include "mozilla/ipc/TestShellChild.h"
 #include "mozilla/jsipc/CrossProcessObjectWrappers.h"
 #include "mozilla/layers/APZChild.h"
 #include "mozilla/layers/CompositorBridgeChild.h"
 #include "mozilla/layers/ImageBridgeChild.h"
 #include "mozilla/layers/SharedBufferManagerChild.h"
 #include "mozilla/layout/RenderFrameChild.h"
 #include "mozilla/net/NeckoChild.h"
@@ -1876,16 +1877,29 @@ ContentChild::AllocPPrintingChild()
 }
 
 bool
 ContentChild::DeallocPPrintingChild(PPrintingChild* printing)
 {
   return true;
 }
 
+PSendStreamChild*
+ContentChild::AllocPSendStreamChild()
+{
+  MOZ_CRASH("PSendStreamChild actors should be manually constructed!");
+}
+
+bool
+ContentChild::DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PScreenManagerChild*
 ContentChild::AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                                        float* aSystemDefaultScale,
                                        bool* aSuccess)
 {
   // The ContentParent should never attempt to allocate the
   // nsScreenManagerProxy. Instead, the nsScreenManagerProxy
   // service is requested and instantiated via XPCOM, and the
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -282,16 +282,19 @@ public:
   virtual PNeckoChild* AllocPNeckoChild() override;
 
   virtual bool DeallocPNeckoChild(PNeckoChild*) override;
 
   virtual PPrintingChild* AllocPPrintingChild() override;
 
   virtual bool DeallocPPrintingChild(PPrintingChild*) override;
 
+  virtual PSendStreamChild* AllocPSendStreamChild() override;
+  virtual bool DeallocPSendStreamChild(PSendStreamChild*) override;
+
   virtual PScreenManagerChild*
   AllocPScreenManagerChild(uint32_t* aNumberOfScreens,
                            float* aSystemDefaultScale,
                            bool* aSuccess) override;
 
   virtual bool DeallocPScreenManagerChild(PScreenManagerChild*) override;
 
   virtual PPSMContentDownloaderChild*
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -74,16 +74,18 @@
 #include "mozilla/dom/voicemail/VoicemailParent.h"
 #include "mozilla/embedding/printingui/PrintingParent.h"
 #include "mozilla/hal_sandbox/PHalParent.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/FileDescriptorUtils.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+#include "mozilla/ipc/SendStreamAlloc.h"
 #include "mozilla/ipc/TestShellParent.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/jsipc/CrossProcessObjectWrappers.h"
 #include "mozilla/layers/PAPZParent.h"
 #include "mozilla/layers/CompositorBridgeParent.h"
 #include "mozilla/layers/ImageBridgeParent.h"
 #include "mozilla/layers/SharedBufferManagerParent.h"
 #include "mozilla/layout/RenderFrameParent.h"
@@ -3831,16 +3833,29 @@ ContentParent::RecvPPrintingConstructor(
 
 bool
 ContentParent::DeallocPPrintingParent(PPrintingParent* printing)
 {
   delete printing;
   return true;
 }
 
+PSendStreamParent*
+ContentParent::AllocPSendStreamParent()
+{
+  return mozilla::ipc::AllocPSendStreamParent();
+}
+
+bool
+ContentParent::DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PScreenManagerParent*
 ContentParent::AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                                          float* aSystemDefaultScale,
                                          bool* aSuccess)
 {
   return new ScreenManagerParent(aNumberOfScreens, aSystemDefaultScale, aSuccess);
 }
 
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -379,16 +379,19 @@ public:
   }
 
   virtual PPrintingParent* AllocPPrintingParent() override;
 
   virtual bool RecvPPrintingConstructor(PPrintingParent* aActor) override;
 
   virtual bool DeallocPPrintingParent(PPrintingParent* aActor) override;
 
+  virtual PSendStreamParent* AllocPSendStreamParent() override;
+  virtual bool DeallocPSendStreamParent(PSendStreamParent* aActor) override;
+
   virtual PScreenManagerParent*
   AllocPScreenManagerParent(uint32_t* aNumberOfScreens,
                             float* aSystemDefaultScale,
                             bool* aSuccess) override;
 
   virtual bool
   DeallocPScreenManagerParent(PScreenManagerParent* aActor) override;
 
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -35,16 +35,17 @@ include protocol PNecko;
 //       bridging PContent and PGMP. As soon as it registers the bridge between
 //       PContent and PPluginModule it seems to think that PContent's parent and
 //       child live in the same process!
 include protocol PGMPContent;
 include protocol PGMPService;
 include protocol PPluginModule;
 include protocol PGMP;
 include protocol PPrinting;
+include protocol PSendStream;
 include protocol POfflineCacheUpdate;
 include protocol PRenderFrame;
 include protocol PScreenManager;
 include protocol PSharedBufferManager;
 include protocol PSms;
 include protocol PSpeechSynthesis;
 include protocol PStorage;
 include protocol PTelephony;
@@ -413,16 +414,17 @@ prio(normal upto urgent) sync protocol P
     manages PHeapSnapshotTempFileHelper;
     manages PIcc;
     manages PMedia;
     manages PMemoryReportRequest;
     manages PMobileConnection;
     manages PNecko;
     manages POfflineCacheUpdate;
     manages PPrinting;
+    manages PSendStream;
     manages PScreenManager;
     manages PSms;
     manages PSpeechSynthesis;
     manages PStorage;
     manages PTelephony;
     manages PTestShell;
     manages PVoicemail;
     manages PJavaScript;
@@ -814,16 +816,18 @@ parent:
     async PIcc(uint32_t serviceId);
 
     async PMobileConnection(uint32_t clientId);
 
     async PNecko();
 
     async PPrinting();
 
+    async PSendStream();
+
     prio(high) sync PScreenManager()
         returns (uint32_t numberOfScreens,
                  float systemDefaultScale,
                  bool success);
 
     async PCellBroadcast();
 
     async PSms();
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/quota/PQuotaChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/NuwaChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
+#include "mozilla/ipc/PSendStreamChild.h"
 #include "mozilla/layout/VsyncChild.h"
 #include "mozilla/net/PUDPSocketChild.h"
 #include "mozilla/dom/network/UDPSocketChild.h"
 #include "nsID.h"
 #include "nsTraceRefcnt.h"
 
 namespace {
 
@@ -413,16 +414,29 @@ bool
 BackgroundChildImpl::DeallocPNuwaChild(PNuwaChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+PSendStreamChild*
+BackgroundChildImpl::AllocPSendStreamChild()
+{
+  MOZ_CRASH("PSendStreamChild actors should be manually constructed!");
+}
+
+bool
+BackgroundChildImpl::DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 PAsmJSCacheEntryChild*
 BackgroundChildImpl::AllocPAsmJSCacheEntryChild(
                                const dom::asmjscache::OpenMode& aOpenMode,
                                const dom::asmjscache::WriteParams& aWriteParams,
                                const PrincipalInfo& aPrincipalInfo)
 {
   MOZ_CRASH("PAsmJSCacheEntryChild actors should be manually constructed!");
 }
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -140,16 +140,22 @@ protected:
   DeallocPMessagePortChild(PMessagePortChild* aActor) override;
 
   virtual PNuwaChild*
   AllocPNuwaChild() override;
 
   virtual bool
   DeallocPNuwaChild(PNuwaChild* aActor) override;
 
+  virtual PSendStreamChild*
+  AllocPSendStreamChild() override;
+
+  virtual bool
+  DeallocPSendStreamChild(PSendStreamChild* aActor) override;
+
   virtual PAsmJSCacheEntryChild*
   AllocPAsmJSCacheEntryChild(const dom::asmjscache::OpenMode& aOpenMode,
                              const dom::asmjscache::WriteParams& aWriteParams,
                              const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPAsmJSCacheEntryChild(PAsmJSCacheEntryChild* aActor) override;
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -24,16 +24,18 @@
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/dom/quota/ActorsParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+#include "mozilla/ipc/SendStreamAlloc.h"
 #include "mozilla/layout/VsyncParent.h"
 #include "mozilla/dom/network/UDPSocketParent.h"
 #include "mozilla/Preferences.h"
 #include "nsIAppsService.h"
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsProxyRelease.h"
 #include "mozilla/RefPtr.h"
@@ -300,16 +302,29 @@ BackgroundParentImpl::RecvPNuwaConstruct
 }
 
 bool
 BackgroundParentImpl::DeallocPNuwaParent(PNuwaParent *aActor)
 {
   return mozilla::dom::NuwaParent::Dealloc(aActor);
 }
 
+PSendStreamParent*
+BackgroundParentImpl::AllocPSendStreamParent()
+{
+  return mozilla::ipc::AllocPSendStreamParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 BackgroundParentImpl::PVsyncParent*
 BackgroundParentImpl::AllocPVsyncParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   RefPtr<mozilla::layout::VsyncParent> actor =
       mozilla::layout::VsyncParent::Create();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -105,16 +105,22 @@ protected:
   AllocPNuwaParent() override;
 
   virtual bool
   RecvPNuwaConstructor(PNuwaParent* aActor) override;
 
   virtual bool
   DeallocPNuwaParent(PNuwaParent* aActor) override;
 
+  virtual PSendStreamParent*
+  AllocPSendStreamParent() override;
+
+  virtual bool
+  DeallocPSendStreamParent(PSendStreamParent* aActor) override;
+
   virtual PServiceWorkerManagerParent*
   AllocPServiceWorkerManagerParent() override;
 
   virtual bool
   DeallocPServiceWorkerManagerParent(PServiceWorkerManagerParent* aActor) override;
 
   virtual PCamerasParent*
   AllocPCamerasParent() override;
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -12,16 +12,17 @@ include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PFileSystemRequest;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PNuwa;
 include protocol PQuota;
+include protocol PSendStream;
 include protocol PServiceWorkerManager;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 include PFileSystemParams;
@@ -52,16 +53,17 @@ sync protocol PBackground
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
   manages PMessagePort;
   manages PCameras;
   manages PNuwa;
   manages PQuota;
+  manages PSendStream;
   manages PServiceWorkerManager;
   manages PUDPSocket;
   manages PVsync;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   async PBackgroundTest(nsCString testArg);
 
@@ -85,16 +87,18 @@ parent:
   async ShutdownServiceWorkerRegistrar();
 
   async PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
 
   async PMessagePort(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   async PNuwa();
 
+  async PSendStream();
+
   async MessagePortForceClose(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
diff --git a/ipc/glue/PSendStream.ipdl b/ipc/glue/PSendStream.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PSendStream.ipdl
@@ -0,0 +1,32 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+include protocol PContent;
+
+namespace mozilla {
+namespace ipc {
+
+protocol PSendStream
+{
+  manager PBackground or PContent;
+
+parent:
+  async Buffer(nsCString aBuffer);
+  async Close(nsresult aRv);
+
+child:
+  // The parent side has hit an error condition and has requested the child
+  // actor issue a Close() message.  The close must be initiated by the child
+  // to avoid racing with an in-flight Buffer() message.
+  async RequestClose(nsresult aRv);
+
+  // Stream is always destroyed from the parent side.  This occurs if the
+  // parent encounters an error while writing to its pipe or if the child
+  // signals the stream should close by SendClose().
+  async __delete__();
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/SendStream.h b/ipc/glue/SendStream.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStream.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_SendStream_h
+#define mozilla_ipc_SendStream_h
+
+#include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/ipc/PSendStreamChild.h"
+#include "mozilla/ipc/PSendStreamParent.h"
+
+class nsIInputStream;
+class nsIAsyncInputStream;
+
+namespace mozilla {
+
+namespace dom {
+class PContentChild;
+} // dom namespace
+
+namespace ipc {
+
+class PBackgroundChild;
+
+// The SendStream IPC actor is designed to push an nsIInputStream from child to
+// parent incrementally.  This is mainly needed for streams such as nsPipe that
+// may not yet have all their data available when the stream must be sent across
+// an IPC boundary.  While many streams are handled by SerializeInputStream(),
+// these streams cannot be serialized and must be sent using this actor.
+//
+// The SendStream actor only supports sending data from child to parent.
+//
+// The SendStream actor only support async, non-blocking streams because they
+// must be read inline on the main thread and Worker threads.
+//
+// In general, the creation and handling of the SendStream actor cannot be
+// abstracted away behind SerializeInputStream() because the actor must be
+// carefully managed.  Specifically:
+//
+//  1) The data flow must be explicitly initiated by calling
+//     SendStreamChild::Start() after the actor has been sent to the parent.
+//  2) If the actor is never sent to the parent, then the child code must
+//     call SendStreamChild::StartDestroy() to avoid memory leaks.
+//  3) The SendStreamChild actor can only be used on threads that can be
+//     guaranteed to stay alive as long as the actor is alive.  Right now
+//     this limits SendStream to the main thread and Worker threads.
+//
+// In general you should probably use the AutoIPCStreamChild RAII class
+// defined in InputStreamUtils.h instead of using SendStreamChild directly.
+class SendStreamChild : public PSendStreamChild
+{
+public:
+  // Create a SendStreamChild using a PContent IPC manager on the
+  // main thread.  This can return nullptr if the provided stream is
+  // blocking.
+  static SendStreamChild*
+  Create(nsIAsyncInputStream* aInputStream, dom::PContentChild* aManager);
+
+  // Create a SendStreamChild using a PBackground IPC manager on the
+  // main thread or a Worker thread.  This can return nullptr if the provided
+  // stream is blocking or if the Worker thread is already shutting down.
+  static SendStreamChild*
+  Create(nsIAsyncInputStream* aInputStream, PBackgroundChild* aManager);
+
+  // Start reading data from the nsIAsyncInputStream used to create the actor.
+  // This must be called after the actor is passed to the parent.  If you
+  // use AutoIPCStreamChild this is handled automatically.
+  virtual void
+  Start() = 0;
+
+  // Start cleaning up the actor.  This must be called if the actor is never
+  // sent to the parent.  If you use AutoIPCStreamChild this is handled
+  // automatically.
+  virtual void
+  StartDestroy() = 0;
+
+protected:
+  virtual
+  ~SendStreamChild() = 0;
+};
+
+// On the parent side, you must simply call TakeReader() upon receiving a
+// reference to the SendStreamParent actor.  You do not need to maintain a
+// reference to the actor itself.
+class SendStreamParent : public PSendStreamParent
+{
+public:
+  virtual already_AddRefed<nsIInputStream>
+  TakeReader() = 0;
+
+protected:
+  virtual
+  ~SendStreamParent() = 0;
+};
+
+} // namespace ipc
+} // namespace mozilla
+
+#endif // mozilla_ipc_SendStream_h
diff --git a/ipc/glue/SendStreamAlloc.h b/ipc/glue/SendStreamAlloc.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamAlloc.h
@@ -0,0 +1,21 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_SendStreamAlloc_h
+#define mozilla_ipc_SendStreamAlloc_h
+
+namespace mozilla {
+namespace ipc {
+
+class PSendStreamParent;
+
+PSendStreamParent*
+AllocPSendStreamParent();
+
+} // ipc namespace
+} // mozilla namespace
+
+#endif // mozilla_ipc_SendStreamAlloc_h
diff --git a/ipc/glue/SendStreamChild.cpp b/ipc/glue/SendStreamChild.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamChild.cpp
@@ -0,0 +1,428 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ipc/SendStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/PContentChild.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerFeature.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsIAsyncInputStream.h"
+#include "nsICancelableRunnable.h"
+#include "nsIRunnable.h"
+#include "nsIThread.h"
+#include "nsStreamUtils.h"
+
+namespace mozilla {
+namespace ipc {
+
+using mozilla::dom::PContentChild;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::Status;
+using mozilla::dom::workers::WorkerFeature;
+using mozilla::dom::workers::WorkerPrivate;
+
+namespace {
+
+class SendStreamChildImpl final : public SendStreamChild
+                                , public WorkerFeature
+{
+public:
+  explicit SendStreamChildImpl(nsIAsyncInputStream* aStream);
+  ~SendStreamChildImpl();
+
+  void Start() override;
+  void StartDestroy() override;
+
+  bool
+  AddAsWorkerFeature(dom::workers::WorkerPrivate* aWorkerPrivate);
+
+private:
+  class Callback;
+
+  // PSendStreamChild methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  virtual bool
+  RecvRequestClose(const nsresult& aRv) override;
+
+  // WorkerFeature methods
+  virtual bool
+  Notify(Status aStatus) override;
+
+  void DoRead();
+
+  void Wait();
+
+  void OnStreamReady(Callback* aCallback);
+
+  void OnEnd(nsresult aRv);
+
+  nsCOMPtr<nsIAsyncInputStream> mStream;
+  RefPtr<Callback> mCallback;
+  WorkerPrivate* mWorkerPrivate;
+  bool mClosed;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+class SendStreamChildImpl::Callback final : public nsIInputStreamCallback
+                                          , public nsIRunnable
+                                          , public nsICancelableRunnable
+{
+public:
+  explicit Callback(SendStreamChildImpl* aActor)
+    : mActor(aActor)
+    , mOwningThread(NS_GetCurrentThread())
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHOD
+  OnInputStreamReady(nsIAsyncInputStream* aStream) override
+  {
+    // any thread
+    if (mOwningThread == NS_GetCurrentThread()) {
+      return Run();
+    }
+
+    // If this fails, then it means the owning thread is a Worker that has
+    // been shutdown.  Its ok to lose the event in this case because the
+    // SendStreamChild listens for this event through the Feature.
+    nsresult rv = mOwningThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to dispatch stream readable event to owning thread");
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    if (mActor) {
+      mActor->OnStreamReady(this);
+    }
+    return NS_OK;
+  }
+
+  nsresult
+  Cancel() override
+  {
+    // Cancel() gets called when the Worker thread is being shutdown.  We have
+    // nothing to do here because SendStreamChild handles this case via
+    // the Feature.
+    return NS_OK;
+  }
+
+  void
+  ClearActor()
+  {
+    MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+    MOZ_ASSERT(mActor);
+    mActor = nullptr;
+  }
+
+private:
+  ~Callback()
+  {
+    // called on any thread
+
+    // ClearActor() should be called before the Callback is destroyed
+    MOZ_ASSERT(!mActor);
+  }
+
+  SendStreamChildImpl* mActor;
+  nsCOMPtr<nsIThread> mOwningThread;
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(SendStreamChildImpl::Callback, nsIInputStreamCallback,
+                                                 nsIRunnable,
+                                                 nsICancelableRunnable);
+
+SendStreamChildImpl::SendStreamChildImpl(nsIAsyncInputStream* aStream)
+  : mStream(aStream)
+  , mWorkerPrivate(nullptr)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mStream);
+}
+
+SendStreamChildImpl::~SendStreamChildImpl()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(mClosed);
+  MOZ_ASSERT(!mCallback);
+  MOZ_ASSERT(!mWorkerPrivate);
+}
+
+void
+SendStreamChildImpl::Start()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerPrivate);
+  DoRead();
+}
+
+void
+SendStreamChildImpl::StartDestroy()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  OnEnd(NS_ERROR_ABORT);
+}
+
+bool
+SendStreamChildImpl::AddAsWorkerFeature(WorkerPrivate* aWorkerPrivate)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(aWorkerPrivate);
+  bool result = aWorkerPrivate->AddFeature(this);
+  if (result) {
+    mWorkerPrivate = aWorkerPrivate;
+  }
+  return result;
+}
+
+void
+SendStreamChildImpl::ActorDestroy(ActorDestroyReason aReason)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+
+  // If the parent side runs into a problem it will ask the child to
+  // close the connection via RequestClose().  Therefore OnEnd() should
+  // always run before the actor is destroyed.
+  MOZ_ASSERT(mClosed);
+
+  if (mCallback) {
+    mCallback->ClearActor();
+    mCallback = nullptr;
+  }
+
+  if (mWorkerPrivate) {
+    mWorkerPrivate->RemoveFeature(this);
+    mWorkerPrivate = nullptr;
+  }
+}
+
+bool
+SendStreamChildImpl::RecvRequestClose(const nsresult& aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  OnEnd(aRv);
+  return true;
+}
+
+bool
+SendStreamChildImpl::Notify(Status aStatus)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+
+  // Keep the worker thread alive until the stream is finished.
+  return true;
+}
+
+void
+SendStreamChildImpl::DoRead()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // The input stream (likely a pipe) probably uses a segment size of
+  // 4kb.  If there is data already buffered it would be nice to aggregate
+  // multiple segments into a single IPC call.  Conversely, don't send too
+  // too large of a buffer in a single call to avoid spiking memory.
+  static const uint64_t kMaxBytesPerMessage = 32 * 1024;
+  static_assert(kMaxBytesPerMessage <= static_cast<uint64_t>(UINT32_MAX),
+                "kMaxBytesPerMessage must cleanly cast to uint32_t");
+
+  while (true) {
+    // It should not be possible to transition to closed state without
+    // this loop terminating via a return.
+    MOZ_ASSERT(!mClosed);
+
+    // Use non-auto here as we're unlikely to hit stack storage with the
+    // sizes we are sending.  Also, it would be nice to avoid another copy
+    // to the IPC layer which we avoid if we use COW strings.  Unfortunately
+    // IPC does not seem to support passing dependent storage types.
+    nsCString buffer;
+
+    uint64_t available = 0;
+    nsresult rv = mStream->Available(&available);
+    if (NS_FAILED(rv)) {
+      OnEnd(rv);
+      return;
+    }
+
+    if (available == 0) {
+      Wait();
+      return;
+    }
+
+    uint32_t expectedBytes =
+      static_cast<uint32_t>(std::min(available, kMaxBytesPerMessage));
+
+    buffer.SetLength(expectedBytes);
+
+    uint32_t bytesRead = 0;
+    rv = mStream->Read(buffer.BeginWriting(), buffer.Length(), &bytesRead);
+    MOZ_ASSERT_IF(NS_FAILED(rv), bytesRead == 0);
+    buffer.SetLength(bytesRead);
+
+    // If we read any data from the stream, send it across.
+    if (!buffer.IsEmpty()) {
+      Unused << SendBuffer(buffer);
+    }
+
+    if (rv == NS_BASE_STREAM_WOULD_BLOCK) {
+      Wait();
+      return;
+    }
+
+    // Any other error or zero-byte read indicates end-of-stream
+    if (NS_FAILED(rv) || buffer.IsEmpty()) {
+      OnEnd(rv);
+      return;
+    }
+  }
+}
+
+void
+SendStreamChildImpl::Wait()
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(!mCallback);
+
+  // Set mCallback immediately instead of waiting for success.  Its possible
+  // AsyncWait() will callback synchronously.
+  mCallback = new Callback(this);
+  nsresult rv = mStream->AsyncWait(mCallback, 0, 0, nullptr);
+  if (NS_FAILED(rv)) {
+    OnEnd(rv);
+    return;
+  }
+}
+
+void
+SendStreamChildImpl::OnStreamReady(Callback* aCallback)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(mCallback);
+  MOZ_ASSERT(aCallback == mCallback);
+  mCallback->ClearActor();
+  mCallback = nullptr;
+  DoRead();
+}
+
+void
+SendStreamChildImpl::OnEnd(nsresult aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(SendStreamChild);
+  MOZ_ASSERT(aRv != NS_BASE_STREAM_WOULD_BLOCK);
+
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+
+  mStream->CloseWithStatus(aRv);
+
+  if (aRv == NS_BASE_STREAM_CLOSED) {
+    aRv = NS_OK;
+  }
+
+  // This will trigger an ActorDestroy() from the parent side
+  Unused << SendClose(aRv);
+}
+
+bool
+IsBlocking(nsIAsyncInputStream* aInputStream)
+{
+  bool nonBlocking = false;
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(aInputStream->IsNonBlocking(&nonBlocking)));
+  return !nonBlocking;
+}
+
+} // anonymous namespace
+
+// static
+SendStreamChild*
+SendStreamChild::Create(nsIAsyncInputStream* aInputStream,
+                        PContentChild* aManager)
+{
+  MOZ_ASSERT(aInputStream);
+  MOZ_ASSERT(aManager);
+
+  // PContent can only be used on the main thread
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // SendStreamChild reads in the current thread, so it is only supported
+  // on non-blocking, async channels
+  if (NS_WARN_IF(IsBlocking(aInputStream))) {
+    return nullptr;
+  }
+
+  SendStreamChild* actor = new SendStreamChildImpl(aInputStream);
+  aManager->SendPSendStreamConstructor(actor);
+
+  return actor;
+}
+
+// static
+SendStreamChild*
+SendStreamChild::Create(nsIAsyncInputStream* aInputStream,
+                        PBackgroundChild* aManager)
+{
+  MOZ_ASSERT(aInputStream);
+  MOZ_ASSERT(aManager);
+
+  // PBackground can be used on any thread, but we only support SendStream on
+  // main thread and Worker threads right now.  This is due to the requirement
+  // that the thread be guaranteed to live long enough to receive messages
+  // sent from parent to child.  We can enforce this guarantee with a feature
+  // on worker threads, but not other threads.
+  WorkerPrivate* workerPrivate = nullptr;
+  if (!NS_IsMainThread()) {
+    workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+  }
+
+  // SendStreamChild reads in the current thread, so it is only supported
+  // on non-blocking, async channels
+  if (NS_WARN_IF(IsBlocking(aInputStream))) {
+    return nullptr;
+  }
+
+  SendStreamChildImpl* actor = new SendStreamChildImpl(aInputStream);
+
+  if (workerPrivate && !actor->AddAsWorkerFeature(workerPrivate)) {
+    delete actor;
+    return nullptr;
+  }
+
+  aManager->SendPSendStreamConstructor(actor);
+  return actor;
+}
+
+SendStreamChild::~SendStreamChild()
+{
+}
+
+void
+DeallocPSendStreamChild(PSendStreamChild* aActor)
+{
+  delete aActor;
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/SendStreamParent.cpp b/ipc/glue/SendStreamParent.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/SendStreamParent.cpp
@@ -0,0 +1,136 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ipc/SendStream.h"
+
+#include "mozilla/unused.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIPipe.h"
+
+namespace mozilla {
+namespace ipc {
+
+namespace {
+
+class SendStreamParentImpl final : public SendStreamParent
+{
+public:
+  SendStreamParentImpl(nsIAsyncInputStream* aReader,
+                        nsIAsyncOutputStream* aWriter);
+  ~SendStreamParentImpl();
+
+private:
+  // PSendStreamParentImpl methods
+  virtual void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  // SendStreamparent methods
+  already_AddRefed<nsIInputStream>
+  TakeReader() override;
+
+  virtual bool
+  RecvBuffer(const nsCString& aBuffer) override;
+
+  virtual bool
+  RecvClose(const nsresult& aRv) override;
+
+  nsCOMPtr<nsIAsyncInputStream> mReader;
+  nsCOMPtr<nsIAsyncOutputStream> mWriter;
+
+  NS_DECL_OWNINGTHREAD
+};
+
+SendStreamParentImpl::~SendStreamParentImpl()
+{
+}
+
+already_AddRefed<nsIInputStream>
+SendStreamParentImpl::TakeReader()
+{
+  MOZ_ASSERT(mReader);
+  return mReader.forget();
+}
+
+void
+SendStreamParentImpl::ActorDestroy(ActorDestroyReason aReason)
+{
+  // If we were gracefully closed we should have gotten RecvClose().  In
+  // that case, the writer will already be closed and this will have no
+  // effect.  This just aborts the writer in the case where the child process
+  // crashes.
+  mWriter->CloseWithStatus(NS_ERROR_ABORT);
+}
+
+bool
+SendStreamParentImpl::RecvBuffer(const nsCString& aBuffer)
+{
+  uint32_t numWritten = 0;
+
+  // This should only fail if we hit an OOM condition.
+  nsresult rv = mWriter->Write(aBuffer.get(), aBuffer.Length(), &numWritten);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Unused << SendRequestClose(rv);
+  }
+
+  return true;
+}
+
+bool
+SendStreamParentImpl::RecvClose(const nsresult& aRv)
+{
+  mWriter->CloseWithStatus(aRv);
+  Unused << Send__delete__(this);
+  return true;
+}
+
+SendStreamParentImpl::SendStreamParentImpl(nsIAsyncInputStream* aReader,
+                                             nsIAsyncOutputStream* aWriter)
+  : mReader(aReader)
+  , mWriter(aWriter)
+{
+  MOZ_ASSERT(mReader);
+  MOZ_ASSERT(mWriter);
+}
+
+} // anonymous namespace
+
+SendStreamParent::~SendStreamParent()
+{
+}
+
+PSendStreamParent*
+AllocPSendStreamParent()
+{
+  // use async versions for both reader and writer even though we are
+  // opening the writer as an infinite stream.  We want to be able to
+  // use CloseWithStatus() to communicate errors through the pipe.
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  // Use an "infinite" pipe because we cannot apply back-pressure through
+  // the async IPC layer at the moment.  Blocking the IPC worker thread
+  // is not desirable, either.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader),
+                            getter_AddRefs(writer),
+                            true, true,   // non-blocking
+                            0,            // segment size
+                            UINT32_MAX);  // "infinite" pipe
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return new SendStreamParentImpl(reader, writer);
+}
+
+void
+DeallocPSendStreamParent(PSendStreamParent* aActor)
+{
+  delete aActor;
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -24,16 +24,18 @@ EXPORTS.mozilla.ipc += [
     'InputStreamUtils.h',
     'IOThreadChild.h',
     'MessageChannel.h',
     'MessageLink.h',
     'Neutering.h',
     'ProcessChild.h',
     'ProtocolUtils.h',
     'ScopedXREEmbed.h',
+    'SendStream.h',
+    'SendStreamAlloc.h',
     'SharedMemory.h',
     'SharedMemoryBasic.h',
     'Shmem.h',
     'Transport.h',
     'URIUtils.h',
     'WindowsMessageLoop.h',
 ]
 
@@ -116,16 +118,18 @@ UNIFIED_SOURCES += [
     'InputStreamUtils.cpp',
     'IPCMessageUtils.cpp',
     'MessageChannel.cpp',
     'MessageLink.cpp',
     'MessagePump.cpp',
     'ProcessChild.cpp',
     'ProtocolUtils.cpp',
     'ScopedXREEmbed.cpp',
+    'SendStreamChild.cpp',
+    'SendStreamParent.cpp',
     'SharedMemory.cpp',
     'Shmem.cpp',
     'StringUtil.cpp',
 ]
 
 # GeckoChildProcessHost.cpp cannot be built in unified mode because it uses plarena.h.
 # URIUtils.cpp cannot be built in unified mode because of name clashes on strdup.
 SOURCES += [
@@ -155,16 +159,17 @@ LOCAL_INCLUDES += [
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
+    'PSendStream.ipdl',
     'URIParams.ipdlh',
 ]
 
 
 LOCAL_INCLUDES += [
     '/toolkit/xre',
     '/xpcom/threads',
 ]
