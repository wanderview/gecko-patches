# HG changeset patch
# Parent f0a191e4579bddac52f550694afe6f252005b38a
# User Ben Kelly <ben@wanderview.com>
Bug 1110487 P3 Cache should ensure Actions are finished before completing. r=ehsan

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -107,24 +107,27 @@ public:
   {
     // Depending on the error or success path, this can run on either the
     // main thread or the QuotaManager IO thread.  The IO thread is an
     // idle thread which may be destroyed and recreated, so its hard to
     // assert on.
     MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aRv));
 
     mResult = aRv;
-    mState = STATE_COMPLETING;
 
-    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-    if (NS_FAILED(rv)) {
-      // Shutdown must be delayed until all Contexts are destroyed.  Crash for
-      // this invariant violation.
-      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
-    }
+    // Always bounce back through the current thread to ensure that the
+    // resolving methods stack is cleaned up.  We don't want to delete
+    // any objects out from under it.
+    mState = STATE_RESOLVING;
+
+    // Unfortunately we cannot dispatch to the QM IO thread from anywhere
+    // except the main thread.  So bounce through the main thread and then
+    // back through the IO thread to ensure all methods have returned
+    // before completing.
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(this)));
   }
 
 private:
   ~QuotaInitRunnable()
   {
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mQuotaIOThreadAction);
@@ -132,16 +135,17 @@ private:
 
   enum State
   {
     STATE_INIT,
     STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
     STATE_WAIT_FOR_OPEN_ALLOWED,
     STATE_ENSURE_ORIGIN_INITIALIZED,
     STATE_RUNNING,
+    STATE_RESOLVING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
@@ -186,28 +190,39 @@ NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom
 //   |  (Main Thread)   +-------------------+
 //   +--------+---------+                   |
 //            |                             |
 // +----------v------------+                |
 // |EnsureOriginInitialized| Resolve(error) |
 // |   (Quota IO Thread)   +----------------+
 // +----------+------------+                |
 //            |                             |
-//  +---------v---------+            +------v------+
-//  |      Running      |  Resolve() |  Completing |
-//  | (Quota IO Thread) +------------>(Orig Thread)|
-//  +-------------------+            +------+------+
-//                                          |
-//                                    +-----v----+
-//                                    | Complete |
-//                                    +----------+
+//  +---------v---------+                   |
+//  |      Running      |    Resolve()      |
+//  | (Quota IO Thread) +-------------------+
+//  +-------------------+                   |
+//            |                             |
+//  +---------v---------+                   |
+//  |      Resolving    <-------------------+
+//  |    (Main Thread)  |
+//  +-------------------+
+//            |
+//  +---------v---------+                           +-------------+
+//  |      Resolving    |                           |  Completing |
+//  | (Quota IO Thread) +--------------------------->(Orig Thread)|
+//  +-------------------+                           +------+------+
+//                                                         |
+//                                                   +-----v----+
+//                                                   | Complete |
+//                                                   +----------+
 //
 // The initialization process proceeds through the main states.  If an error
-// occurs, then we transition back to Completing state back on the original
-// thread.
+// occurs, then we transition to Completing state back on the original thread.
+// We must always first bounce through the main and IO threads to ensure that
+// the method that triggered the Resolve() is complete, however.
 NS_IMETHODIMP
 Context::QuotaInitRunnable::Run()
 {
   // May run on different threads depending on the state.  See individual
   // state cases for thread assertions.
 
   switch(mState) {
     // -----------------------------------
@@ -302,16 +317,49 @@ Context::QuotaInitRunnable::Run()
       // Execute the provided initialization Action.  We pass ourselves as the
       // Resolver.  The Action must either call Resolve() immediately or hold
       // a ref to us and call Resolve() later.
       mQuotaIOThreadAction->RunOnTarget(this, mQuotaInfo);
 
       break;
     }
     // -------------------
+    case STATE_RESOLVING:
+    {
+      // This can happen on the main thread or the IO thread depending on where
+      // Resolve() was called.
+
+      // If QuotaManager doesn't exist, then it means we never got to the IO
+      // thread.  So we can complete immediately.
+      QuotaManager* qm = QuotaManager::Get();
+      if (!qm) {
+        MOZ_ASSERT(NS_IsMainThread());
+        mState = STATE_COMPLETING;
+        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+          mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
+        break;
+      }
+
+      // Otherwise, if we are on the main thread, then we must bounce through
+      // the QuotaManager IO thread to be sure we don't delete state out
+      // from under the setup action.
+      if (NS_IsMainThread()) {
+        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+          qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
+        break;
+      }
+
+      // Finally, if we are on the IO thread here we can complete the
+      // initialization process.
+      mState = STATE_COMPLETING;
+      MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
+      break;
+    }
+    // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       if (mQuotaIOThreadAction) {
         mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
       }
       mContext->OnQuotaInit(mResult, mQuotaInfo, mOfflineStorage);
       mState = STATE_COMPLETE;
@@ -391,23 +439,24 @@ public:
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) override
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     MOZ_ASSERT(mState == STATE_RUNNING);
     mResult = aRv;
-    mState = STATE_COMPLETING;
-    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-    if (NS_FAILED(rv)) {
-      // Shutdown must be delayed until all Contexts are destroyed.  Crash
-      // for this invariant violation.
-      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
-    }
+    // We ultimately must complete on the initiating thread, but bounce threw
+    // the current thread again to ensure that we don't destroy objects and
+    // state out from under the currently running action's stack.
+    mState = STATE_RESOLVING;
+    // Shutdown must be delayed until all Contexts are destroyed.  Crash
+    // for this invariant violation.
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
   }
 
 private:
   ~ActionRunnable()
   {
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mAction);
@@ -423,16 +472,17 @@ private:
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
     STATE_RUN_ON_TARGET,
     STATE_RUNNING,
+    STATE_RESOLVING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   nsRefPtr<Context> mContext;
   nsCOMPtr<nsIEventTarget> mTarget;
   nsRefPtr<Action> mAction;
   const QuotaInfo mQuotaInfo;
@@ -453,21 +503,27 @@ NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom
 //
 //   +-------------+
 //   |    Start    |
 //   |(Orig Thread)|
 //   +-----+-------+
 //         |
 // +-------v---------+
 // |  RunOnTarget    |
-// |Target IO Thread)+-------------------------------+
-// +-------+---------+                               |
-//         |                                         |
-// +-------v----------+ Resolve()            +-------v-----+
-// |     Running      |                      |  Completing |
+// |Target IO Thread)+---+ Resolve()
+// +-------+---------+   |
+//         |             |
+// +-------v----------+  |
+// |     Running      |  |
+// |(Target IO Thread)|  |
+// +------------------+  |
+//         | Resolve()   |
+// +-------v----------+  |
+// |     Resolving    <--+                   +-------------+
+// |                  |                      |  Completing |
 // |(Target IO Thread)+---------------------->(Orig Thread)|
 // +------------------+                      +-------+-----+
 //                                                   |
 //                                                   |
 //                                              +----v---+
 //                                              |Complete|
 //                                              +--------+
 //
@@ -482,16 +538,30 @@ Context::ActionRunnable::Run()
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       mState = STATE_RUNNING;
       mAction->RunOnTarget(this, mQuotaInfo);
       break;
     }
+    // -----------------
+    case STATE_RESOLVING:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // The call to Action::RunOnTarget() must have returned now if we
+      // are running on the target thread again.  We may now proceed
+      // with completion.
+      mState = STATE_COMPLETING;
+      // Shutdown must be delayed until all Contexts are destroyed.  Crash
+      // for this invariant violation.
+      MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
+      break;
+    }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
