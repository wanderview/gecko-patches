# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  df84244e3e133d8ff9791447391b6a0d865ef818
Bug 1232558 P3 Block shutdown until canceled service worker jobs gracefully exit. r=ehsan

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -245,21 +245,21 @@ public:
     bool wasEmpty = queue.mJobs.IsEmpty();
     queue.mJobs.AppendElement(aJob);
     if (wasEmpty) {
       aJob->Start();
     }
   }
 
   void
-  CancelJobs();
+  CancelJobs(nsTArray<RefPtr<ServiceWorkerJob>>& aRunningJobsOut);
 
 private:
   void
-  CancelJobs(QueueData& aQueue);
+  CancelJobs(QueueData& aQueue, ServiceWorkerJob** aRunningJobOut);
 
   // Internal helper function used to assign jobs to the correct queue.
   QueueData&
   GetQueue(ServiceWorkerJob::Type aType)
   {
     switch (aType) {
     case ServiceWorkerJob::Type::RegisterJob:
     case ServiceWorkerJob::Type::UpdateJob:
@@ -1617,39 +1617,51 @@ private:
 
     ServiceWorkerJob::Done(aStatus);
   }
 };
 
 NS_IMPL_ISUPPORTS_INHERITED0(ServiceWorkerRegisterJob, ServiceWorkerJob);
 
 void
-ServiceWorkerJobQueue::CancelJobs()
+ServiceWorkerJobQueue::CancelJobs(nsTArray<RefPtr<ServiceWorkerJob>>& aRunningJobsOut)
 {
   // The order doesn't matter. Cancel() just sets a flag on these jobs.
-  CancelJobs(mRegistrationJobQueue);
-  CancelJobs(mInstallationJobQueue);
+  RefPtr<ServiceWorkerJob> ref;
+  CancelJobs(mRegistrationJobQueue, getter_AddRefs(ref));
+  if (ref) {
+    aRunningJobsOut.AppendElement(ref.forget());
+  }
+
+  CancelJobs(mInstallationJobQueue, getter_AddRefs(ref));
+  if (ref) {
+    aRunningJobsOut.AppendElement(ref.forget());
+  }
 }
 
 void
-ServiceWorkerJobQueue::CancelJobs(QueueData& aQueue)
+ServiceWorkerJobQueue::CancelJobs(QueueData& aQueue, ServiceWorkerJob** aRunningJobOut)
 {
+  MOZ_ASSERT(aRunningJobOut);
+
   if (aQueue.mJobs.IsEmpty()) {
     return;
   }
 
   // We have to treat the first job specially. It is the running job and needs
   // to be notified correctly.
   RefPtr<ServiceWorkerJob> runningJob = aQueue.mJobs[0];
   // We can just let an Unregister job run to completion.
   if (runningJob->IsRegisterOrInstallJob()) {
     ServiceWorkerJobBase* job = static_cast<ServiceWorkerJobBase*>(runningJob.get());
     job->Cancel();
   }
 
+  runningJob.forget(aRunningJobOut);
+
   // Get rid of everything. Non-main thread objects may still be holding a ref
   // to the running register job. Since we called Cancel() on it, the job's
   // main thread functions will just exit.
   aQueue.mJobs.Clear();
 }
 
 NS_IMETHODIMP
 ContinueUpdateRunnable::Run()
@@ -4409,17 +4421,18 @@ ServiceWorkerManager::ForceUnregister(Re
                                       ServiceWorkerRegistrationInfo* aRegistration)
 {
   MOZ_ASSERT(aRegistrationData);
   MOZ_ASSERT(aRegistration);
 
   ServiceWorkerJobQueue* queue;
   aRegistrationData->mJobQueues.Get(aRegistration->mScope, &queue);
   if (queue) {
-    queue->CancelJobs();
+    nsAutoTArray<RefPtr<ServiceWorkerJob>, 4> runningJobs;
+    queue->CancelJobs(runningJobs);
   }
 
   nsCOMPtr<nsITimer> timer =
     aRegistrationData->mUpdateTimers.Get(aRegistration->mScope);
   if (timer) {
     timer->Cancel();
     aRegistrationData->mUpdateTimers.Remove(aRegistration->mScope);
   }
@@ -4748,30 +4761,50 @@ ServiceWorkerManager::Observe(nsISupport
 
     RemoveAllRegistrations(&attrs);
     return NS_OK;
   }
 
   if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
     mShuttingDown = true;
 
+    nsAutoTArray<RefPtr<ServiceWorkerJob>, 4> runningJobs;
+
+    // Cancel out all current timers and jobs.  Track any jobs that get cancelled
+    // but that might still be running.
     for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
       for (auto it2 = it1.UserData()->mUpdateTimers.Iter(); !it2.Done(); it2.Next()) {
         nsCOMPtr<nsITimer> timer = it2.UserData();
         timer->Cancel();
       }
       it1.UserData()->mUpdateTimers.Clear();
 
       for (auto it2 = it1.UserData()->mJobQueues.Iter(); !it2.Done(); it2.Next()) {
         ServiceWorkerJobQueue* queue = it2.UserData();
-        queue->CancelJobs();
+        queue->CancelJobs(runningJobs);
       }
       it1.UserData()->mJobQueues.Clear();
     }
 
+    nsCOMPtr<nsIThread> currentThread = NS_GetCurrentThread();
+    MOZ_ASSERT(currentThread);
+
+    // Block shutdown until all of our cancelled, but still running jobs actually
+    // complete.  Without this we can leak the entire network stack on shutdown.
+    while (!runningJobs.IsEmpty()) {
+      for (int32_t i = runningJobs.Length() - 1; i >= 0; --i) {
+        if (!runningJobs[i]->IsDone()) {
+          break;
+        }
+        runningJobs.RemoveElementAt(i);
+      }
+
+      MOZ_ALWAYS_TRUE(NS_ProcessNextEvent(currentThread));
+    }
+
     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
     if (obs) {
       obs->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
 
       if (XRE_IsParentProcess()) {
         obs->RemoveObserver(this, PURGE_SESSION_HISTORY);
         obs->RemoveObserver(this, PURGE_DOMAIN_DATA);
         obs->RemoveObserver(this, CLEAR_ORIGIN_DATA);
