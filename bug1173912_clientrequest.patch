# HG changeset patch
# Parent 9c5d9028048b317497949657f7392d8af4709091
# User Ben Kelly <ben@wanderview.com>
# Parent  36fd57d83e3ee0d9e25bfa95e4c00454f4fc4f9b
Bug 1173912 Fail opaque responses for client requests. r=ehsan

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -5198,16 +5198,17 @@ nsDocShell::DisplayLoadError(nsresult aE
         // Broken Content Detected. e.g. Content-MD5 check failure.
         error.AssignLiteral("corruptedContentError");
         break;
       case NS_ERROR_INTERCEPTION_FAILED:
       case NS_ERROR_OPAQUE_INTERCEPTION_DISABLED:
       case NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE:
       case NS_ERROR_INTERCEPTED_ERROR_RESPONSE:
       case NS_ERROR_INTERCEPTED_USED_RESPONSE:
+      case NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION:
         // ServiceWorker intercepted request, but something went wrong.
         nsContentUtils::MaybeReportInterceptionErrorToConsole(GetDocument(),
                                                               aError);
         error.AssignLiteral("corruptedContentError");
         break;
       default:
         break;
     }
@@ -7835,16 +7836,17 @@ nsDocShell::EndPageLoad(nsIWebProgress* 
                aStatus == NS_ERROR_UNSAFE_CONTENT_TYPE ||
                aStatus == NS_ERROR_REMOTE_XUL ||
                aStatus == NS_ERROR_OFFLINE ||
                aStatus == NS_ERROR_INTERCEPTION_FAILED ||
                aStatus == NS_ERROR_OPAQUE_INTERCEPTION_DISABLED ||
                aStatus == NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE ||
                aStatus == NS_ERROR_INTERCEPTED_ERROR_RESPONSE ||
                aStatus == NS_ERROR_INTERCEPTED_USED_RESPONSE ||
+               aStatus == NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION ||
                NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {
       // Errors to be shown for any frame
       DisplayLoadError(aStatus, url, nullptr, aChannel);
     } else if (aStatus == NS_ERROR_DOCUMENT_NOT_CACHED) {
       // Non-caching channels will simply return NS_ERROR_OFFLINE.
       // Caching channels would have to look at their flags to work
       // out which error to return. Or we can fix up the error here.
       if (!(mLoadType & LOAD_CMD_HISTORY)) {
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -3426,16 +3426,18 @@ nsContentUtils::MaybeReportInterceptionE
   } else if (aError == NS_ERROR_OPAQUE_INTERCEPTION_DISABLED) {
     messageName = "OpaqueInterceptionDisabled";
   } else if (aError == NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE) {
     messageName = "BadOpaqueInterceptionRequestMode";
   } else if (aError == NS_ERROR_INTERCEPTED_ERROR_RESPONSE) {
     messageName = "InterceptedErrorResponse";
   } else if (aError == NS_ERROR_INTERCEPTED_USED_RESPONSE) {
     messageName = "InterceptedUsedResponse";
+  } else if (aError == NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION) {
+    messageName = "ClientRequestOpaqueInterception";
   }
 
   if (messageName) {
     return ReportToConsole(nsIScriptError::warningFlag,
                            NS_LITERAL_CSTRING("Service Worker Interception"),
                            aDocument,
                            nsContentUtils::eDOM_PROPERTIES,
                            messageName);
diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -190,10 +190,49 @@ InternalRequest::MapContentPolicyTypeToR
     break;
   default:
     MOZ_ASSERT(false, "Unhandled nsContentPolicyType value");
     break;
   }
   return context;
 }
 
+bool
+InternalRequest::IsNavigationRequest() const
+{
+  // https://fetch.spec.whatwg.org/#navigation-request-context
+  //
+  // A navigation request context is one of "form", "frame", "hyperlink",
+  // "iframe", "internal" (as long as context frame type is not "none"),
+  // "location", "metarefresh", and "prerender".
+  //
+  // TODO: include equivalent check for "form" context
+  // TODO: include equivalent check for "prerender" context
+  return mContentPolicyType == nsIContentPolicy::TYPE_DOCUMENT ||
+         mContentPolicyType == nsIContentPolicy::TYPE_SUBDOCUMENT ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_FRAME ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_IFRAME ||
+         mContentPolicyType == nsIContentPolicy::TYPE_REFRESH;
+}
+
+bool
+InternalRequest::IsWorkerRequest() const
+{
+  // https://fetch.spec.whatwg.org/#worker-request-context
+  //
+  // A worker request context is one of "serviceworker", "sharedworker", and
+  // "worker".
+  //
+  // Note, service workers are not included here because currently there is
+  // no way to generate a Request with a "serviceworker" RequestContext.
+  // ServiceWorker scripts cannot be intercepted.
+  return mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_WORKER ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_SHARED_WORKER;
+}
+
+bool
+InternalRequest::IsClientRequest() const
+{
+  return IsNavigationRequest() || IsWorkerRequest();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -351,16 +351,26 @@ public:
   }
 
   void
   ClearCreatedByFetchEvent()
   {
     mCreatedByFetchEvent = false;
   }
 
+  bool
+  IsNavigationRequest() const;
+
+  bool
+  IsWorkerRequest() const;
+
+  bool
+  IsClientRequest() const;
+
+
 private:
   // Does not copy mBodyStream.  Use fallible Clone() for complete copy.
   explicit InternalRequest(const InternalRequest& aOther);
 
   ~InternalRequest();
 
   static RequestContext
   MapContentPolicyTypeToRequestContext(nsContentPolicyType aContentPolicyType);
diff --git a/dom/locales/en-US/chrome/dom/dom.properties b/dom/locales/en-US/chrome/dom/dom.properties
--- a/dom/locales/en-US/chrome/dom/dom.properties
+++ b/dom/locales/en-US/chrome/dom/dom.properties
@@ -171,8 +171,10 @@ InterceptionFailed=ServiceWorker network
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "FetchEvent.respondWith()", "opaque", or "Response".
 OpaqueInterceptionDisabled=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while opaque interception is disabled.
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "FetchEvent.respondWith()", "FetchEvent.request.type", "same-origin", "cors", "no-cors", "opaque", "Response", or "RequestMode".
 BadOpaqueInterceptionRequestMode=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while the FetchEvent.request.type was either "same-origin" or "cors". Opaque Response objects are only valid when the RequestMode is "no-cors".
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "Error", "Response", "FetchEvent.respondWith()", or "fetch()".
 InterceptedErrorResponse=A ServiceWorker passed an Error Response to FetchEvent.respondWith(). This typically means the ServiceWorker performed an invalid fetch() call.
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "Response", "FetchEvent.respondWith()", or "Response.clone()".
 InterceptedUsedResponse=A ServiceWorker passed a used Response to FetchEvent.respondWith(). The body of a Response may only be read once. Use Response.clone() to access the body multiple times.
+# LOCALIZATION NOTE: Do not translate "ServiceWorker", "Response", "FetchEvent.respondWith()", "FetchEvent.request", or "Worker".
+ClientRequestOpaqueInterception=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while FetchEvent.request was a client request. A client request is generally a browser navigation or top-level Worker script.
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -144,25 +144,27 @@ public:
   }
 };
 
 class RespondWithHandler final : public PromiseNativeHandler
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
   nsMainThreadPtrHandle<ServiceWorker> mServiceWorker;
   RequestMode mRequestMode;
+  bool mIsClientRequest;
 public:
   NS_DECL_ISUPPORTS
 
   RespondWithHandler(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      nsMainThreadPtrHandle<ServiceWorker>& aServiceWorker,
-                     RequestMode aRequestMode)
+                     RequestMode aRequestMode, bool aIsClientRequest)
     : mInterceptedChannel(aChannel)
     , mServiceWorker(aServiceWorker)
     , mRequestMode(aRequestMode)
+    , mIsClientRequest(aIsClientRequest)
   {
   }
 
   void ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   void RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   void CancelRequest(nsresult aStatus);
@@ -257,25 +259,36 @@ RespondWithHandler::ResolvedCallback(JSC
   // Allow opaque response interception to be disabled until we can ensure the
   // security implications are not a complete disaster.
   if (response->Type() == ResponseType::Opaque &&
       !worker->OpaqueInterceptionEnabled()) {
     autoCancel.SetCancelStatus(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED);
     return;
   }
 
-  // Section 4.2, step 2.2 "If either response's type is "opaque" and request's
-  // mode is not "no-cors" or response's type is error, return a network error."
+  // Section 4.2, step 2.2:
+  //  If one of the following conditions is true, return a network error:
+  //    * response's type is "error".
+  //    * request's mode is not "no-cors" and response's type is "opaque".
+  //    * request is a client request and response's type is neither "basic"
+  //      nor "default".
+
+  if (response->Type() == ResponseType::Error) {
+    autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_ERROR_RESPONSE);
+    return;
+  }
+
   if (response->Type() == ResponseType::Opaque && mRequestMode != RequestMode::No_cors) {
     autoCancel.SetCancelStatus(NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE);
     return;
   }
 
-  if (response->Type() == ResponseType::Error) {
-    autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_ERROR_RESPONSE);
+  if (mIsClientRequest && response->Type() != ResponseType::Basic &&
+      response->Type() != ResponseType::Default) {
+    autoCancel.SetCancelStatus(NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION);
     return;
   }
 
   if (NS_WARN_IF(response->BodyUsed())) {
     autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_USED_RESPONSE);
     return;
   }
 
@@ -352,19 +365,21 @@ FetchEvent::RespondWith(const ResponseOr
     promise = Promise::Create(worker->GlobalScope(), aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
     promise->MaybeResolve(res);
   } else if (aArg.IsPromise()) {
     promise = &aArg.GetAsPromise();
   }
+  nsRefPtr<InternalRequest> ir = mRequest->GetInternalRequest();
   mWaitToRespond = true;
   nsRefPtr<RespondWithHandler> handler =
-    new RespondWithHandler(mChannel, mServiceWorker, mRequest->Mode());
+    new RespondWithHandler(mChannel, mServiceWorker, mRequest->Mode(),
+                           ir->IsClientRequest());
   promise->AppendNativeHandler(handler);
 }
 
 already_AddRefed<ServiceWorkerClient>
 FetchEvent::GetClient()
 {
   if (!mClient) {
     if (!mClientInfo) {
diff --git a/xpcom/base/ErrorList.h b/xpcom/base/ErrorList.h
--- a/xpcom/base/ErrorList.h
+++ b/xpcom/base/ErrorList.h
@@ -326,16 +326,18 @@
      dom.serviceWorkers.interception.opaque.enabled pref was set to false */
   ERROR(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED,         FAILURE(101)),
   /* Attempt to return opaque response for anything but "non-cors" request */
   ERROR(NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE, FAILURE(102)),
   /* Service worker intercepted with an error response */
   ERROR(NS_ERROR_INTERCEPTED_ERROR_RESPONSE,           FAILURE(103)),
   /* Service worker intercepted with a response with bodyUsed set to true */
   ERROR(NS_ERROR_INTERCEPTED_USED_RESPONSE,            FAILURE(104)),
+  /* Service worker intercepted a client request with an opaque response */
+  ERROR(NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION,   FAILURE(105)),
 #undef MODULE
 
 
   /* ======================================================================= */
   /* 7: NS_ERROR_MODULE_PLUGINS */
   /* ======================================================================= */
 #define MODULE NS_ERROR_MODULE_PLUGINS
   ERROR(NS_ERROR_PLUGINS_PLUGINSNOTCHANGED,        FAILURE(1000)),
