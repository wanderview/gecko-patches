# HG changeset patch
# Parent 496143db85643c256cd54c079ea81f54e7e22be0
# User Ben Kelly <ben@wanderview.com>
# Parent  36fd57d83e3ee0d9e25bfa95e4c00454f4fc4f9b
Bug 1173912 Fail opaque responses for client requests. r=ehsan

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -5198,16 +5198,17 @@ nsDocShell::DisplayLoadError(nsresult aE
         // Broken Content Detected. e.g. Content-MD5 check failure.
         error.AssignLiteral("corruptedContentError");
         break;
       case NS_ERROR_INTERCEPTION_FAILED:
       case NS_ERROR_OPAQUE_INTERCEPTION_DISABLED:
       case NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE:
       case NS_ERROR_INTERCEPTED_ERROR_RESPONSE:
       case NS_ERROR_INTERCEPTED_USED_RESPONSE:
+      case NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION:
         // ServiceWorker intercepted request, but something went wrong.
         nsContentUtils::MaybeReportInterceptionErrorToConsole(GetDocument(),
                                                               aError);
         error.AssignLiteral("corruptedContentError");
         break;
       default:
         break;
     }
@@ -7835,16 +7836,17 @@ nsDocShell::EndPageLoad(nsIWebProgress* 
                aStatus == NS_ERROR_UNSAFE_CONTENT_TYPE ||
                aStatus == NS_ERROR_REMOTE_XUL ||
                aStatus == NS_ERROR_OFFLINE ||
                aStatus == NS_ERROR_INTERCEPTION_FAILED ||
                aStatus == NS_ERROR_OPAQUE_INTERCEPTION_DISABLED ||
                aStatus == NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE ||
                aStatus == NS_ERROR_INTERCEPTED_ERROR_RESPONSE ||
                aStatus == NS_ERROR_INTERCEPTED_USED_RESPONSE ||
+               aStatus == NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION ||
                NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {
       // Errors to be shown for any frame
       DisplayLoadError(aStatus, url, nullptr, aChannel);
     } else if (aStatus == NS_ERROR_DOCUMENT_NOT_CACHED) {
       // Non-caching channels will simply return NS_ERROR_OFFLINE.
       // Caching channels would have to look at their flags to work
       // out which error to return. Or we can fix up the error here.
       if (!(mLoadType & LOAD_CMD_HISTORY)) {
diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -3426,16 +3426,18 @@ nsContentUtils::MaybeReportInterceptionE
   } else if (aError == NS_ERROR_OPAQUE_INTERCEPTION_DISABLED) {
     messageName = "OpaqueInterceptionDisabled";
   } else if (aError == NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE) {
     messageName = "BadOpaqueInterceptionRequestMode";
   } else if (aError == NS_ERROR_INTERCEPTED_ERROR_RESPONSE) {
     messageName = "InterceptedErrorResponse";
   } else if (aError == NS_ERROR_INTERCEPTED_USED_RESPONSE) {
     messageName = "InterceptedUsedResponse";
+  } else if (aError == NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION) {
+    messageName = "ClientRequestOpaqueInterception";
   }
 
   if (messageName) {
     return ReportToConsole(nsIScriptError::warningFlag,
                            NS_LITERAL_CSTRING("Service Worker Interception"),
                            aDocument,
                            nsContentUtils::eDOM_PROPERTIES,
                            messageName);
diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -190,10 +190,49 @@ InternalRequest::MapContentPolicyTypeToR
     break;
   default:
     MOZ_ASSERT(false, "Unhandled nsContentPolicyType value");
     break;
   }
   return context;
 }
 
+bool
+InternalRequest::IsNavigationRequest() const
+{
+  // https://fetch.spec.whatwg.org/#navigation-request-context
+  //
+  // A navigation request context is one of "form", "frame", "hyperlink",
+  // "iframe", "internal" (as long as context frame type is not "none"),
+  // "location", "metarefresh", and "prerender".
+  //
+  // TODO: include equivalent check for "form" context
+  // TODO: include equivalent check for "prerender" context
+  return mContentPolicyType == nsIContentPolicy::TYPE_DOCUMENT ||
+         mContentPolicyType == nsIContentPolicy::TYPE_SUBDOCUMENT ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_FRAME ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_IFRAME ||
+         mContentPolicyType == nsIContentPolicy::TYPE_REFRESH;
+}
+
+bool
+InternalRequest::IsWorkerRequest() const
+{
+  // https://fetch.spec.whatwg.org/#worker-request-context
+  //
+  // A worker request context is one of "serviceworker", "sharedworker", and
+  // "worker".
+  //
+  // Note, service workers are not included here because currently there is
+  // no way to generate a Request with a "serviceworker" RequestContext.
+  // ServiceWorker scripts cannot be intercepted.
+  return mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_WORKER ||
+         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_SHARED_WORKER;
+}
+
+bool
+InternalRequest::IsClientRequest() const
+{
+  return IsNavigationRequest() || IsWorkerRequest();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -351,16 +351,26 @@ public:
   }
 
   void
   ClearCreatedByFetchEvent()
   {
     mCreatedByFetchEvent = false;
   }
 
+  bool
+  IsNavigationRequest() const;
+
+  bool
+  IsWorkerRequest() const;
+
+  bool
+  IsClientRequest() const;
+
+
 private:
   // Does not copy mBodyStream.  Use fallible Clone() for complete copy.
   explicit InternalRequest(const InternalRequest& aOther);
 
   ~InternalRequest();
 
   static RequestContext
   MapContentPolicyTypeToRequestContext(nsContentPolicyType aContentPolicyType);
diff --git a/dom/locales/en-US/chrome/dom/dom.properties b/dom/locales/en-US/chrome/dom/dom.properties
--- a/dom/locales/en-US/chrome/dom/dom.properties
+++ b/dom/locales/en-US/chrome/dom/dom.properties
@@ -171,8 +171,10 @@ InterceptionFailed=ServiceWorker network
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "FetchEvent.respondWith()", "opaque", or "Response".
 OpaqueInterceptionDisabled=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while opaque interception is disabled.
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "FetchEvent.respondWith()", "FetchEvent.request.type", "same-origin", "cors", "no-cors", "opaque", "Response", or "RequestMode".
 BadOpaqueInterceptionRequestMode=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while the FetchEvent.request.type was either "same-origin" or "cors". Opaque Response objects are only valid when the RequestMode is "no-cors".
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "Error", "Response", "FetchEvent.respondWith()", or "fetch()".
 InterceptedErrorResponse=A ServiceWorker passed an Error Response to FetchEvent.respondWith(). This typically means the ServiceWorker performed an invalid fetch() call.
 # LOCALIZATION NOTE: Do not translate "ServiceWorker", "Response", "FetchEvent.respondWith()", or "Response.clone()".
 InterceptedUsedResponse=A ServiceWorker passed a used Response to FetchEvent.respondWith(). The body of a Response may only be read once. Use Response.clone() to access the body multiple times.
+# LOCALIZATION NOTE: Do not translate "ServiceWorker", "Response", "FetchEvent.respondWith()", "FetchEvent.request", or "Worker".
+ClientRequestOpaqueInterception=A ServiceWorker passed an opaque Response to FetchEvent.respondWith() while FetchEvent.request was a client request. A client request is generally a browser navigation or top-level Worker script.
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -144,25 +144,27 @@ public:
   }
 };
 
 class RespondWithHandler final : public PromiseNativeHandler
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
   nsMainThreadPtrHandle<ServiceWorker> mServiceWorker;
   RequestMode mRequestMode;
+  bool mIsClientRequest;
 public:
   NS_DECL_ISUPPORTS
 
   RespondWithHandler(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      nsMainThreadPtrHandle<ServiceWorker>& aServiceWorker,
-                     RequestMode aRequestMode)
+                     RequestMode aRequestMode, bool aIsClientRequest)
     : mInterceptedChannel(aChannel)
     , mServiceWorker(aServiceWorker)
     , mRequestMode(aRequestMode)
+    , mIsClientRequest(aIsClientRequest)
   {
   }
 
   void ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   void RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   void CancelRequest(nsresult aStatus);
@@ -257,25 +259,36 @@ RespondWithHandler::ResolvedCallback(JSC
   // Allow opaque response interception to be disabled until we can ensure the
   // security implications are not a complete disaster.
   if (response->Type() == ResponseType::Opaque &&
       !worker->OpaqueInterceptionEnabled()) {
     autoCancel.SetCancelStatus(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED);
     return;
   }
 
-  // Section 4.2, step 2.2 "If either response's type is "opaque" and request's
-  // mode is not "no-cors" or response's type is error, return a network error."
+  // Section 4.2, step 2.2:
+  //  If one of the following conditions is true, return a network error:
+  //    * response's type is "error".
+  //    * request's mode is not "no-cors" and response's type is "opaque".
+  //    * request is a client request and response's type is neither "basic"
+  //      nor "default".
+
+  if (response->Type() == ResponseType::Error) {
+    autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_ERROR_RESPONSE);
+    return;
+  }
+
   if (response->Type() == ResponseType::Opaque && mRequestMode != RequestMode::No_cors) {
     autoCancel.SetCancelStatus(NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE);
     return;
   }
 
-  if (response->Type() == ResponseType::Error) {
-    autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_ERROR_RESPONSE);
+  if (mIsClientRequest && response->Type() != ResponseType::Basic &&
+      response->Type() != ResponseType::Default) {
+    autoCancel.SetCancelStatus(NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION);
     return;
   }
 
   if (NS_WARN_IF(response->BodyUsed())) {
     autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_USED_RESPONSE);
     return;
   }
 
@@ -352,19 +365,21 @@ FetchEvent::RespondWith(const ResponseOr
     promise = Promise::Create(worker->GlobalScope(), aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return;
     }
     promise->MaybeResolve(res);
   } else if (aArg.IsPromise()) {
     promise = &aArg.GetAsPromise();
   }
+  nsRefPtr<InternalRequest> ir = mRequest->GetInternalRequest();
   mWaitToRespond = true;
   nsRefPtr<RespondWithHandler> handler =
-    new RespondWithHandler(mChannel, mServiceWorker, mRequest->Mode());
+    new RespondWithHandler(mChannel, mServiceWorker, mRequest->Mode(),
+                           ir->IsClientRequest());
   promise->AppendNativeHandler(handler);
 }
 
 already_AddRefed<ServiceWorkerClient>
 FetchEvent::GetClient()
 {
   if (!mClient) {
     if (!mClientInfo) {
diff --git a/dom/workers/test/serviceworkers/app-protocol/application.zip b/dom/workers/test/serviceworkers/app-protocol/application.zip
index f8669cd77e4a380a774e1672fd64fa37e2306777..7d4be7f4617e28c7a259cfda1a45e324135521db
GIT binary patch
literal 3451
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
F=s)2|iL?L!

diff --git a/dom/workers/test/serviceworkers/app-protocol/controlled.html b/dom/workers/test/serviceworkers/app-protocol/controlled.html
--- a/dom/workers/test/serviceworkers/app-protocol/controlled.html
+++ b/dom/workers/test/serviceworkers/app-protocol/controlled.html
@@ -16,19 +16,21 @@ function runTests() {
     .then(() => {
         return testFetchAppResource('foo.txt?fetch=1',
                                     'networkresponse', 'text/plain');
     })
     .then(() => {
         return testFetchAppResource('test_custom_content_type',
                                     'customContentType', 'text/html');
     })
-    .then(testRedirectedResponse)
-    .then(testRedirectedHttpsResponse)
-    .then(testCachedRedirectedResponse)
-    .then(testCachedRedirectedHttpsResponse)
+    // XXX: Cross-origin interceptions without CORS result in opaque responses
+    //      which are illegal for navigations like iframes. (bug 1183313)
+    //.then(testRedirectedResponse)
+    //.then(testRedirectedHttpsResponse)
+    //.then(testCachedRedirectedResponse)
+    //.then(testCachedRedirectedHttpsResponse)
     .then(done);
 }
   </script>
   </head>
   <body onload='runTests()'>
   </body>
 </html>
diff --git a/xpcom/base/ErrorList.h b/xpcom/base/ErrorList.h
--- a/xpcom/base/ErrorList.h
+++ b/xpcom/base/ErrorList.h
@@ -326,16 +326,18 @@
      dom.serviceWorkers.interception.opaque.enabled pref was set to false */
   ERROR(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED,         FAILURE(101)),
   /* Attempt to return opaque response for anything but "non-cors" request */
   ERROR(NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE, FAILURE(102)),
   /* Service worker intercepted with an error response */
   ERROR(NS_ERROR_INTERCEPTED_ERROR_RESPONSE,           FAILURE(103)),
   /* Service worker intercepted with a response with bodyUsed set to true */
   ERROR(NS_ERROR_INTERCEPTED_USED_RESPONSE,            FAILURE(104)),
+  /* Service worker intercepted a client request with an opaque response */
+  ERROR(NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION,   FAILURE(105)),
 #undef MODULE
 
 
   /* ======================================================================= */
   /* 7: NS_ERROR_MODULE_PLUGINS */
   /* ======================================================================= */
 #define MODULE NS_ERROR_MODULE_PLUGINS
   ERROR(NS_ERROR_PLUGINS_PLUGINSNOTCHANGED,        FAILURE(1000)),
