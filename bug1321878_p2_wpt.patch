# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  18b5a7a5d833f09b1f1e5cc45f4c0ff6235a1d5e
Bug 1321878 P2 Add a wpt test to verify Performance timing API accounts for service worker time. r=asuth

diff --git a/testing/web-platform/tests/service-workers/service-worker/performance-timeline.https.html b/testing/web-platform/tests/service-workers/service-worker/performance-timeline.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/performance-timeline.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/performance-timeline.https.html
@@ -3,9 +3,50 @@
 <script src="/resources/testharnessreport.js"></script>
 <script src="resources/test-helpers.sub.js"></script>
 <script>
 
 service_worker_test(
     'resources/performance-timeline-worker.js',
     'Test Performance Timeline API in Service Worker');
 
+// The purpose of this test is to verify that service worker overhead
+// is included in the Performance API's timing information.
+promise_test(t => {
+  let script = 'resources/empty-but-slow-worker.js';
+  let scope = 'resources/dummy.txt?slow-sw-timing';
+  let url = new URL(scope, window.location).href;
+  let slowURL = url + '&slow';
+  let frame;
+  return service_worker_unregister_and_register(t, script, scope)
+    .then(reg => wait_for_state(t, reg.installing, 'activated'))
+    .then(_ => with_iframe(scope))
+    .then(f => {
+      frame = f;
+      return Promise.all([
+        // This will get effectively an empty service worker FetchEvent
+        // handler.  It should have no additional delay.  Note that the
+        // text() call is necessary to complete the response and have the
+        // timings show up in the performance entries.
+        frame.contentWindow.fetch(url).then(r => r && r.text()),
+        // This will cause the service worker to spin for two seconds
+        // in its FetchEvent handler.
+        frame.contentWindow.fetch(slowURL).then(r => r && r.text())
+      ]);
+    })
+    .then(_ => {
+      function elapsed(u) {
+        let entry = frame.contentWindow.performance.getEntriesByName(u);
+        return entry[0] ? entry[0].duration : undefined;
+      }
+      let urlTime = elapsed(url);
+      let slowURLTime = elapsed(slowURL);
+      // Verify the request slowed by the service worker is indeed measured
+      // to be slower.  Note, we compare to smaller delay instead of the exact
+      // delay amount to avoid making the test racy under automation.
+      assert_true(slowURLTime >= urlTime + 1500,
+                  'Slow service worker request should measure increased delay.');
+      frame.remove();
+      return service_worker_unregister_and_done(t, scope);
+    })
+}, 'empty service worker fetch event included in performance timings');
+
 </script>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/empty-but-slow-worker.js b/testing/web-platform/tests/service-workers/service-worker/resources/empty-but-slow-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/empty-but-slow-worker.js
@@ -0,0 +1,8 @@
+addEventListener('fetch', evt => {
+  if (evt.request.url.endsWith('slow')) {
+    // Performance.now() might be a bit better here, but Date.now() has
+    // better compat in workers right now.
+    let start = Date.now();
+    while(Date.now() - start < 2000);
+  }
+});
