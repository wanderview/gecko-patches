# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  63dc5d2039db818c9d95c4a0cee849235bd0d645

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3638,30 +3638,30 @@ nsGlobalWindow::DefineArgumentsProperty(
 }
 
 void
 nsGlobalWindow::MaybeApplyBackPressure()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   // If we are already suspended, then we don't need to apply back
-  // pressure for TaskQueue reasons.  This also avoids repeatedly
+  // pressure for ThrottledEventQueue reasons.  This also avoids repeatedly
   // calling SuspendTimeout() if this routine is executed many times
   // before dropping below the backpressure threshold.
   if (IsSuspended()) {
     return;
   }
 
-  RefPtr<SelfClosingTaskQueueTarget> taskQueue = TabGroup()->GetTaskQueue();
+  RefPtr<ThrottledEventQueue> taskQueue = TabGroup()->GetThrottledEventQueue();
   if (!taskQueue) {
     return;
   }
 
-  static const uint32_t kTaskQueueBackPressure = 5000;
-  if (taskQueue->ImpreciseLengthForHeuristics() < kTaskQueueBackPressure) {
+  static const uint32_t kThrottledEventQueueBackPressure = 5000;
+  if (taskQueue->Length() < kThrottledEventQueueBackPressure) {
     return;
   }
 
   // First attempt to queue a runnable to resume running timeouts.  We do
   // this first in order to verify we can dispatch successfully.
   nsCOMPtr<nsIRunnable> r = NewRunnableMethod(this, &nsGlobalWindow::Resume);
   nsresult rv = taskQueue->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
   NS_ENSURE_SUCCESS_VOID(rv);
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1698,19 +1698,19 @@ private:
   // IsSecureContext() for the inner window that corresponds to aDocument.
   bool ComputeIsSecureContext(nsIDocument* aDocument);
 
   // nsPIDOMWindow<T> should be able to see these helper methods.
   friend class nsPIDOMWindow<mozIDOMWindowProxy>;
   friend class nsPIDOMWindow<mozIDOMWindow>;
   friend class nsPIDOMWindow<nsISupports>;
 
-  // Apply back pressure to the window if the main thread TaskQueue exists
-  // and has too many runnables waiting to run.  For example, suspend timers
-  // until we have a chance to catch up, etc.
+  // Apply back pressure to the window if the TabGroup ThrottledEventQueue
+  // exists and has too many runnables waiting to run.  For example, suspend
+  // timers until we have a chance to catch up, etc.
   void
   MaybeApplyBackPressure();
 
   mozilla::dom::TabGroup* TabGroupInner();
   mozilla::dom::TabGroup* TabGroupOuter();
 
 protected:
   // These members are only used on outer window objects. Make sure
