# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2b4583e4104f55fa76f64b22f4765889427050ed
Bug 1257977 P3 Track registration DOM instances in ServiceWorkerRegistrationInfo. r=jdm

diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -42,16 +42,23 @@ ServiceWorkerRegistrationInfo::ServiceWo
   , mLastUpdateCheckTime(0)
   , mScope(aScope)
   , mPrincipal(aPrincipal)
   , mPendingUninstall(false)
 {}
 
 ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
 {
+  AssertIsOnMainThread();
+
+  // Since Instance objects are required to hold a strong ref
+  // to us and remove themselves before they are destroyed, this
+  // must be empty during our own destruction.
+  MOZ_ASSERT(mInstanceList.IsEmpty());
+
   if (IsControllingDocuments()) {
     NS_WARNING("ServiceWorkerRegistrationInfo is still controlling documents. This can be a bug or a leak in ServiceWorker API or in any other API that takes the document alive.");
   }
 }
 
 NS_IMPL_ISUPPORTS(ServiceWorkerRegistrationInfo, nsIServiceWorkerRegistrationInfo)
 
 NS_IMETHODIMP
@@ -442,9 +449,27 @@ ServiceWorkerRegistrationInfo::Transitio
   // We are transitioning from waiting to active normally, so go to
   // the activating state.
   mActiveWorker = mWaitingWorker.forget();
   mActiveWorker->UpdateState(ServiceWorkerState::Activating);
   NotifyListenersOnChange(WhichServiceWorker::WAITING_WORKER |
                           WhichServiceWorker::ACTIVE_WORKER);
 }
 
+void
+ServiceWorkerRegistrationInfo::AddInstance(Instance* aInstance)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aInstance);
+  MOZ_ASSERT(!mInstanceList.Contains(aInstance));
+  mInstanceList.AppendElement(aInstance);
+}
+
+void
+ServiceWorkerRegistrationInfo::RemoveInstance(Instance* aInstance)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aInstance);
+  MOZ_ALWAYS_TRUE(mInstanceList.RemoveElement(aInstance));
+  MOZ_ASSERT(!mInstanceList.Contains(aInstance));
+}
+
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.h b/dom/workers/ServiceWorkerRegistrationInfo.h
--- a/dom/workers/ServiceWorkerRegistrationInfo.h
+++ b/dom/workers/ServiceWorkerRegistrationInfo.h
@@ -11,42 +11,58 @@
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
 class ServiceWorkerRegistrationInfo final
   : public nsIServiceWorkerRegistrationInfo
 {
+public:
+  // An abstract interface representing DOM instances of a registration.
+  // DOM instances must notify the underlying ServiceWorkerRegistrationInfo
+  // object of their presence using AddInstance() and RemoveInstance().
+  class Instance
+  {
+  public:
+    NS_IMETHOD_(MozExternalRefCountType) AddRef() = 0;
+    NS_IMETHOD_(MozExternalRefCountType) Release() = 0;
+  };
+
+private:
   uint32_t mControlledDocumentsCounter;
 
   enum
   {
     NoUpdate,
     NeedTimeCheckAndUpdate,
     NeedUpdate
   } mUpdateState;
 
   uint64_t mLastUpdateCheckTime;
 
   RefPtr<ServiceWorkerInfo> mActiveWorker;
   RefPtr<ServiceWorkerInfo> mWaitingWorker;
   RefPtr<ServiceWorkerInfo> mInstallingWorker;
 
+  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
+
+  // Hold weak references to our instance DOM objects.  Each DOM object will
+  // hold a strong reference to us and remove themselves before being
+  // destroyed.
+  nsTArray<Instance*> mInstanceList;
+
   virtual ~ServiceWorkerRegistrationInfo();
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
 
   const nsCString mScope;
-
-  nsCOMPtr<nsIPrincipal> mPrincipal;
-
-  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
+  const nsCOMPtr<nsIPrincipal> mPrincipal;
 
   // When unregister() is called on a registration, it is not immediately
   // removed since documents may be controlled. It is marked as
   // pendingUninstall and when all controlling documents go away, removed.
   bool mPendingUninstall;
 
   ServiceWorkerRegistrationInfo(const nsACString& aScope,
                                 nsIPrincipal* aPrincipal);
@@ -153,15 +169,27 @@ public:
   // The worker is transitioned to the Activated state.
   void
   SetActive(ServiceWorkerInfo* aServiceWorker);
 
   // Transition the current waiting worker to be the new active worker.  The
   // worker is updated to the Activating state.
   void
   TransitionWaitingToActive();
+
+  // This should be called by a class implementing Instance.  The caller is
+  // required to hold a strong ref to the ServiceWorkerRegistrationInfo.  The
+  // Instance must call RemoveInstance() before it is destroyed.
+  void
+  AddInstance(Instance* aInstance);
+
+  // Remove an Instance previously added by AddInstance().  This must be called
+  // before the Instance is destroyed.  The Instance may drop its strong
+  // reference to the ServiceWorkerRegistrationInfo after removing itself.
+  void
+  RemoveInstance(Instance* aInstance);
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkerregistrationinfo_h
