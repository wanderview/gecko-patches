# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e5aaf3554e2754939b6c641315dc3126a0f7c97b

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -8,25 +8,25 @@
 
 #include <algorithm>
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/Casting.h"
+#include "mozilla/dom/ClientChannelHelper.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
-#include "mozilla/dom/ReservedClientHelper.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/StartupTimeline.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/Unused.h"
@@ -11560,17 +11560,17 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
 
-  rv = ReserveClientForChannel(aChannel);
+  rv = AddClientChannelHelperToChannel(this, aChannel);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3500,19 +3500,23 @@ nsGlobalWindow::EnsureClientSource()
 
   nsCOMPtr<nsILoadInfo> loadInfo;
   nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
   if (channel) {
     loadInfo = channel->GetLoadInfo();
   }
 
   // Try to get the reserved client from the loading document
-  if (!mClientSource && loadInfo) {
-    mClientSource = loadInfo->TakeReservedClient();
-    newClientSource = true;
+  if (loadInfo) {
+    UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClient();
+    if (reservedClient) {
+      mClientSource.reset();
+      mClientSource = Move(reservedClient);
+      newClientSource = true;
+    }
   }
 
   // If we don't have a reserved client we need to create one now
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
diff --git a/dom/clients/manager/ReservedClientHelper.cpp b/dom/clients/manager/ClientChannelHelper.cpp
rename from dom/clients/manager/ReservedClientHelper.cpp
rename to dom/clients/manager/ClientChannelHelper.cpp
--- a/dom/clients/manager/ReservedClientHelper.cpp
+++ b/dom/clients/manager/ClientChannelHelper.cpp
@@ -1,37 +1,38 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "ReservedClientHelper.h"
+#include "ClientChannelHelper.h"
 
 #include "ClientManager.h"
 #include "ClientSource.h"
 #include "MainThreadUtils.h"
 #include "nsContentUtils.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsIChannel.h"
 #include "nsIChannelEventSink.h"
+#include "nsIDocShell.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 namespace {
 
-class ReserveClientHelper final : public nsIInterfaceRequestor
+class ClientChannelHelper final : public nsIInterfaceRequestor
                                 , public nsIChannelEventSink
 {
   nsCOMPtr<nsIInterfaceRequestor> mOuter;
 
-  ~ReserveClientHelper()
+  ~ClientChannelHelper()
   {
   }
 
   NS_IMETHOD
   GetInterface(const nsIID & aIID, void **aResultOut) override
   {
     if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
       *aResultOut = static_cast<nsIChannelEventSink*>(this);
@@ -71,109 +72,169 @@ class ReserveClientHelper final : public
       return rv;
     }
 
     UniquePtr<ClientSource> reservedClient = oldLoadInfo->TakeReservedClient();
 
     // If its a same-origin redirect we just move our reserved client to the
     // new channel.
     if (NS_SUCCEEDED(rv)) {
-      newLoadInfo->GiveReservedClient(Move(reservedClient));
+      if (reservedClient) {
+        newLoadInfo->GiveReservedClient(Move(reservedClient));
+      } else {
+        const Maybe<ClientInfo>& reservedClientInfo =
+          oldLoadInfo->GetReservedClientInfo();
+        if (reservedClientInfo.isSome()) {
+          newLoadInfo->SetReservedClientInfo(reservedClientInfo.ref());
+        } else {
+          const Maybe<ClientInfo>& initialClientInfo =
+            oldLoadInfo->GetInitialClientInfo();
+          if (initialClientInfo.isSome()) {
+            newLoadInfo->SetInitialClientInfo(initialClientInfo.ref());
+          }
+        }
+      }
     }
 
     // If its a cross-origin redirect then we discard the old reserved client
     // and create a new one.
     else {
       // If CheckSameOrigin() worked, then the security manager must exist.
       nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
       MOZ_DIAGNOSTIC_ASSERT(ssm);
 
       nsCOMPtr<nsIPrincipal> principal;
       rv = ssm->GetChannelResultPrincipal(aNewChannel, getter_AddRefs(principal));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
 
+      reservedClient.reset();
       reservedClient =
         ClientManager::CreateSource(ClientType::Window, principal);
 
       newLoadInfo->GiveReservedClient(Move(reservedClient));
     }
 
+    if (aFlags & (nsIChannelEventSink::REDIRECT_INTERNAL |
+                  nsIChannelEventSink::REDIRECT_STS_UPGRADE)) {
+      const Maybe<ServiceWorkerDescriptor>& controller = oldLoadInfo->GetController();
+      if (controller.isSome()) {
+        newLoadInfo->SetController(controller.ref());
+      }
+    }
+
+    // TODO: We need to do this for worker channels as well.
     nsCOMPtr<nsIChannelEventSink> outerSink = do_GetInterface(mOuter);
     if (outerSink) {
       return outerSink->AsyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags,
                                                aCallback);
     }
 
     aCallback->OnRedirectVerifyCallback(NS_OK);
     return NS_OK;
   }
 
 public:
-  explicit ReserveClientHelper(nsIInterfaceRequestor* aOuter)
+  explicit ClientChannelHelper(nsIInterfaceRequestor* aOuter)
     : mOuter(aOuter)
   {
   }
 
   NS_DECL_ISUPPORTS
 };
 
-NS_IMPL_ISUPPORTS(ReserveClientHelper, nsIInterfaceRequestor,
+NS_IMPL_ISUPPORTS(ClientChannelHelper, nsIInterfaceRequestor,
                                        nsIChannelEventSink);
 
 } // anonymous namespace
 
 nsresult
-ReserveClientForChannel(nsIChannel* aChannel)
+AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsCOMPtr<nsIInterfaceRequestor> outer;
-  nsresult rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outer));
+  nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
+  if (NS_WARN_IF(!loadInfo)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  Maybe<ClientInfo> initialClientInfo;
+  nsPIDOMWindowOuter* outerWindow = aDocShell->GetWindow();
+  if (outerWindow) {
+    nsPIDOMWindowInner* innerWindow = outerWindow->GetCurrentInnerWindow();
+    if (innerWindow) {
+      nsIDocument* doc = innerWindow->GetExtantDoc();
+      if (doc && doc->IsInitialDocument()) {
+        nsCOMPtr<nsIURI> channelURL;
+        nsresult rv = aChannel->GetURI(getter_AddRefs(channelURL));
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          return rv;
+        }
+
+        nsIPrincipal* initialPrincipal = doc->NodePrincipal();
+        initialPrincipal->CheckMayLoad(channelURL,
+                                       false /* report */,
+                                       false /* inherit */);
+        if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_DOM_BAD_URI)) {
+          return rv;
+        }
+
+        if (NS_SUCCEEDED(rv)) {
+          initialClientInfo = innerWindow->GetClientInfo();
+        }
+      }
+    }
+  }
+
+  nsCOMPtr<nsIInterfaceRequestor> outerCallbacks;
+  nsresult rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outerCallbacks));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
-  if (!ssm) {
-    return NS_ERROR_FAILURE;
+  UniquePtr<ClientSource> reservedClient;
+  if (initialClientInfo.isNothing()) {
+    nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
+    if (NS_WARN_IF(!ssm)) {
+      return NS_ERROR_FAILURE;
+    }
+
+    nsCOMPtr<nsIPrincipal> channelPrincipal;
+    rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(channelPrincipal));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    // Wait to reserve the client until we are reasonably sure this method
+    // will succeed.
+    reservedClient = ClientManager::CreateSource(ClientType::Window,
+                                                 channelPrincipal);
+    if (!reservedClient) {
+      return NS_ERROR_FAILURE;
+    }
   }
 
-  nsCOMPtr<nsIPrincipal> principal;
-  rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(principal));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  nsCOMPtr<nsILoadInfo> loadInfo;
-  rv = aChannel->GetLoadInfo(getter_AddRefs(loadInfo));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-
-  // Wait to reserve the client until we are reasonably sure this method
-  // will succeed.
-  UniquePtr<ClientSource> reservedClient =
-    ClientManager::CreateSource(ClientType::Window, principal);
-  if (!reservedClient) {
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<ReserveClientHelper> helper =
-    new ReserveClientHelper(outer);
+  RefPtr<ClientChannelHelper> helper =
+    new ClientChannelHelper(outerCallbacks);
 
   // Only set the callbacks helper if we are able to reserve the client
   // successfully.
   rv = aChannel->SetNotificationCallbacks(helper);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   // Finally preserve the reserved client on the nsILoadInfo once the
   // redirect helper has been added to the channel.
-  loadInfo->GiveReservedClient(Move(reservedClient));
+  if (reservedClient) {
+    loadInfo->GiveReservedClient(Move(reservedClient));
+  }
+
+  if (initialClientInfo.isSome()) {
+    loadInfo->SetInitialClientInfo(initialClientInfo.ref());
+  }
 
   return NS_OK;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ReservedClientHelper.h b/dom/clients/manager/ClientChannelHelper.h
rename from dom/clients/manager/ReservedClientHelper.h
rename to dom/clients/manager/ClientChannelHelper.h
--- a/dom/clients/manager/ReservedClientHelper.h
+++ b/dom/clients/manager/ClientChannelHelper.h
@@ -1,22 +1,23 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-#ifndef _mozilla_dom_ReservedClientHelper_h
-#define _mozilla_dom_ReservedClientHelper_h
+#ifndef _mozilla_dom_ClientChannelHelper_h
+#define _mozilla_dom_ClientChannelHelper_h
 
 #include "nsError.h"
 
 class nsIChannel;
+class nsIDocShell;
 
 namespace mozilla {
 namespace dom {
 
 nsresult
-ReserveClientForChannel(nsIChannel* aChannel);
+AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel);
 
 } // namespace dom
 } // namespace mozilla
 
-#endif // _mozilla_dom_ReservedClientHelper_h
+#endif // _mozilla_dom_ClientChannelHelper_h
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -1,29 +1,30 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
+  'ClientChannelHelper.h',
   'ClientHandle.h',
   'ClientInfo.h',
   'ClientIPCUtils.h',
   'ClientManager.h',
   'ClientManagerActors.h',
   'ClientOpenWindowOpActors.h',
   'ClientOpPromise.h',
   'ClientSource.h',
   'ClientState.h',
   'ClientThing.h',
-  'ReservedClientHelper.h',
 ]
 
 UNIFIED_SOURCES += [
+  'ClientChannelHelper.cpp',
   'ClientHandle.cpp',
   'ClientHandleChild.cpp',
   'ClientHandleOpChild.cpp',
   'ClientHandleOpParent.cpp',
   'ClientHandleParent.cpp',
   'ClientInfo.cpp',
   'ClientManager.cpp',
   'ClientManagerActors.cpp',
@@ -39,17 +40,16 @@ UNIFIED_SOURCES += [
   'ClientOpenWindowOpParent.cpp',
   'ClientOpenWindowUtils.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ClientState.cpp',
-  'ReservedClientHelper.cpp',
 ]
 
 IPDL_SOURCES += [
   'ClientIPCTypes.ipdlh',
   'PClientHandle.ipdl',
   'PClientHandleOp.ipdl',
   'PClientManager.ipdl',
   'PClientManagerOp.ipdl',
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2772,17 +2772,20 @@ ServiceWorkerManager::DispatchFetchEvent
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     // If there is a reserved client it should be marked as controlled before
     // the FetchEvent.
     nsCOMPtr<nsILoadInfo> loadInfo = internalChannel->GetLoadInfo();
     if (loadInfo) {
-      const Maybe<ClientInfo>& clientInfo = loadInfo->GetReservedClientInfo();
+      Maybe<ClientInfo> clientInfo = loadInfo->GetReservedClientInfo();
+      if (clientInfo.isNothing()) {
+        clientInfo = loadInfo->GetInitialClientInfo();
+      }
       if (clientInfo.isSome()) {
         // First, attempt to mark the reserved client controlled directly.  This
         // will update the controlled status in the ClientManagerService in the
         // parent.  It will also eventually propagate back to the ClientSource.
         RefPtr<ClientHandle> clientHandle =
           ClientManager::CreateHandle(clientInfo.ref());
         if (clientHandle) {
           RefPtr<GenericPromise> p =
@@ -2902,22 +2905,22 @@ ServiceWorkerManager::GetDocumentControl
   }
 
   Maybe<ServiceWorkerDescriptor> controller = aWindow->GetController();
   if (controller.isNothing()) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  if (!doc) {
+  if (NS_WARN_IF(!doc)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
-  if (!principal) {
+  if (NS_WARN_IF(!principal)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -895,26 +895,41 @@ LoadInfo::TakeReservedClient()
 {
   mReservedClientInfo.reset();
   return Move(mReservedClient);
 }
 
 void
 LoadInfo::SetReservedClientInfo(const ClientInfo& aClientInfo)
 {
+  MOZ_DIAGNOSTIC_ASSERT(mInitialClientInfo.isNothing());
   mReservedClientInfo.emplace(aClientInfo);
 }
 
 const Maybe<ClientInfo>&
 LoadInfo::GetReservedClientInfo() const
 {
   return mReservedClientInfo;
 }
 
 void
+LoadInfo::SetInitialClientInfo(const ClientInfo& aClientInfo)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mReservedClient);
+  MOZ_DIAGNOSTIC_ASSERT(mReservedClientInfo.isNothing());
+  mInitialClientInfo.emplace(aClientInfo);
+}
+
+const Maybe<ClientInfo>&
+LoadInfo::GetInitialClientInfo() const
+{
+  return mInitialClientInfo;
+}
+
+void
 LoadInfo::SetClientInfo(const ClientInfo& aClientInfo)
 {
   mClientInfo.emplace(aClientInfo);
 }
 
 const Maybe<ClientInfo>&
 LoadInfo::GetClientInfo() const
 {
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -86,16 +86,22 @@ public:
 
   void
   SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
 
   const Maybe<mozilla::dom::ClientInfo>&
   GetReservedClientInfo() const override;
 
   void
+  SetInitialClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
+
+  const Maybe<mozilla::dom::ClientInfo>&
+  GetInitialClientInfo() const override;
+
+  void
   SetClientInfo(const mozilla::dom::ClientInfo& aClientInfo) override;
 
   const Maybe<mozilla::dom::ClientInfo>&
   GetClientInfo() const override;
 
   void
   SetController(const mozilla::dom::ServiceWorkerDescriptor& aServiceWorker) override;
 
@@ -152,17 +158,19 @@ private:
 
   // if you add a member, please also update the copy constructor
   nsCOMPtr<nsIPrincipal>           mLoadingPrincipal;
   nsCOMPtr<nsIPrincipal>           mTriggeringPrincipal;
   nsCOMPtr<nsIPrincipal>           mPrincipalToInherit;
   nsCOMPtr<nsIPrincipal>           mSandboxedLoadingPrincipal;
   nsCOMPtr<nsIURI>                 mResultPrincipalURI;
   UniquePtr<mozilla::dom::ClientSource> mReservedClient;
+  // TODO: Make this a variant since we should never have both reserved and initial
   Maybe<mozilla::dom::ClientInfo>  mReservedClientInfo;
+  Maybe<mozilla::dom::ClientInfo>  mInitialClientInfo;
   Maybe<mozilla::dom::ClientInfo>  mClientInfo;
   Maybe<mozilla::dom::ServiceWorkerDescriptor> mController;
   nsWeakPtr                        mLoadingContext;
   nsSecurityFlags                  mSecurityFlags;
   nsContentPolicyType              mInternalContentPolicyType;
   LoadTainting                     mTainting;
   bool                             mUpgradeInsecureRequests;
   bool                             mVerifySignedContent;
diff --git a/netwerk/base/nsILoadInfo.idl b/netwerk/base/nsILoadInfo.idl
--- a/netwerk/base/nsILoadInfo.idl
+++ b/netwerk/base/nsILoadInfo.idl
@@ -777,16 +777,22 @@ interface nsILoadInfo : nsISupports
 
   virtual void
   SetReservedClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
 
   virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
   GetReservedClientInfo() const = 0;
 
   virtual void
+  SetInitialClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
+
+  virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
+  GetInitialClientInfo() const = 0;
+
+  virtual void
   SetClientInfo(const mozilla::dom::ClientInfo& aClientInfo) = 0;
 
   virtual const mozilla::Maybe<mozilla::dom::ClientInfo>&
   GetClientInfo() const = 0;
 
   virtual void
   SetController(const mozilla::dom::ServiceWorkerDescriptor& aServiceWorker) = 0;
 
