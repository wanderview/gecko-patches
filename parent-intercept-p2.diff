diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
index e5f1432..c900f7b 100644
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerManager.h"
+#include "ServiceWorkerManagerParent.h"
 
 #include "nsAutoPtr.h"
 #include "nsIConsoleService.h"
@@ -180,6 +181,8 @@ PopulateRegistrationData(nsIPrincipal* aPrincipal,
 
   aData.scope() = aRegistration->mScope;
 
+  ServiceWorkerManager::PrincipalToScopeKey(aPrincipal, aData.scopeKey());
+
   RefPtr<ServiceWorkerInfo> newest = aRegistration->Newest();
   if (NS_WARN_IF(!newest)) {
     return NS_ERROR_FAILURE;
@@ -257,6 +260,10 @@ ServiceWorkerManager::Init()
   }
 
   if (XRE_IsParentProcess()) {
+    // Unused, but needs to ensure that the service is created on the main thread.
+    RefPtr<ServiceWorkerRegistrarParent> swrp = ServiceWorkerRegistrarParent::Get();
+    MOZ_ASSERT(swrp);
+
     RefPtr<ServiceWorkerRegistrar> swr = ServiceWorkerRegistrar::Get();
     MOZ_ASSERT(swr);
 
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
index a54d929a..7984a50 100644
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -297,6 +297,12 @@ class ServiceWorkerManager final
   void
   WorkerIsIdle(ServiceWorkerInfo* aWorker);
 
+  // This method generates a key using appId and isInElementBrowser from the
+  // principal. We don't use the origin because it can change during the
+  // loading.
+  static nsresult
+  PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aKey);
+
 private:
   ServiceWorkerManager();
   ~ServiceWorkerManager();
@@ -366,12 +372,6 @@ class ServiceWorkerManager final
   GetServiceWorkerRegistrationInfo(const nsACString& aScopeKey,
                                    nsIURI* aURI);
 
-  // This method generates a key using appId and isInElementBrowser from the
-  // principal. We don't use the origin because it can change during the
-  // loading.
-  static nsresult
-  PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aKey);
-
   static void
   AddScopeAndRegistration(const nsACString& aScope,
                           ServiceWorkerRegistrationInfo* aRegistation);
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
index 676be4f..601198e 100644
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -27,6 +27,11 @@ namespace workers {
 
 StaticRefPtr<ServiceWorkerRegistrarParent> gRegistrarInstance;
 
+ServiceWorkerRegistrarParent::ServiceWorkerRegistrarParent()
+: mLock("ServiceWorkerRegistrarParent.mLock")
+{
+}
+
 ServiceWorkerRegistrarParent*
 ServiceWorkerRegistrarParent::Get()
 {
@@ -50,12 +55,6 @@ ServiceWorkerRegistrarParent::IsAvailable(/*const PrincipalOriginAttributes& aOr
     return false;
   }
 
-  printf("checking for `%s`\n", scopeKey.get());
-  const nsTArray<nsString>* scopes = mRegistrations.Get(scopeKey);
-  if (!scopes) {
-    return false;
-  }
-
   nsAutoCString spec;
   rv = aURI->GetSpec(spec);
   if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -64,6 +63,13 @@ ServiceWorkerRegistrarParent::IsAvailable(/*const PrincipalOriginAttributes& aOr
 
   nsAutoString wideSpec = NS_ConvertUTF8toUTF16(spec);
 
+  printf("checking for `%s`\n", scopeKey.get());
+  MutexAutoLock lock(mLock);
+  const nsTArray<nsString>* scopes = mRegistrations.Get(scopeKey);
+  if (!scopes) {
+    return false;
+  }
+
   printf("checking scopes\n");
   for (uint32_t i = 0; i < scopes->Length(); ++i) {
     const nsString& current = (*scopes)[i];
@@ -79,16 +85,17 @@ ServiceWorkerRegistrarParent::IsAvailable(/*const PrincipalOriginAttributes& aOr
 void
 ServiceWorkerRegistrarParent::PropagateRegistration(ServiceWorkerRegistrationData& aData)
 {
-  nsresult rv = NS_OK;
+  /*nsresult rv = NS_OK;
   nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aData.principal(), &rv);
   NS_ENSURE_SUCCESS_VOID(rv);
 
   nsAutoCString scopeKey;
   rv = ServiceWorkerManager::PrincipalToScopeKey(principal, scopeKey);
-  NS_ENSURE_SUCCESS_VOID(rv);
+  NS_ENSURE_SUCCESS_VOID(rv);*/
 
   nsString scope(NS_ConvertUTF8toUTF16(aData.scope()));
-  nsTArray<nsString>* scopes = mRegistrations.LookupOrAdd(scopeKey);
+  MutexAutoLock lock(mLock);
+  nsTArray<nsString>* scopes = mRegistrations.LookupOrAdd(aData.scopeKey());
   for (uint32_t i = 0; i < scopes->Length(); i++) {
     if ((*scopes)[i] == scope) {
       return;
@@ -96,22 +103,37 @@ ServiceWorkerRegistrarParent::PropagateRegistration(ServiceWorkerRegistrationDat
   }
   scopes->AppendElement(scope);
 
-  printf("registering %s for %s\n", aData.scope().get(), scopeKey.get());
+  printf("registering %s for %s\n", aData.scope().get(), aData.scopeKey().get());
 }
 
 void
 ServiceWorkerRegistrarParent::PropagateUnregister(const PrincipalInfo& aPrincipalInfo,
                                                   const nsAString& aScope)
 {
-  nsresult rv = NS_OK;
+  /*nsresult rv = NS_OK;
   nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo, &rv);
   NS_ENSURE_SUCCESS_VOID(rv);
 
   nsAutoCString scopeKey;
   rv = ServiceWorkerManager::PrincipalToScopeKey(principal, scopeKey);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
+  NS_ENSURE_SUCCESS_VOID(rv);*/
+  const ContentPrincipalInfo& info =
+      aPrincipalInfo.get_ContentPrincipalInfo();
+  
+  nsCString scopeKey = info.spec();
+  scopeKey.Append('!');
+  nsAutoCString suffix;
+  info.attrs().CreateSuffix(suffix);
+  scopeKey.Append(suffix);
+
+  printf("trying to unregister %s", scopeKey.get());
+
+  MutexAutoLock lock(mLock);
   nsTArray<nsString>* scopes = mRegistrations.Get(scopeKey);
+  if (!scopes) {
+    return;
+  }
+
   for (uint32_t i = 0; i < scopes->Length(); i++) {
     if ((*scopes)[i] == aScope) {
       scopes->RemoveElementAt(i);
@@ -125,48 +147,6 @@ namespace {
 
 uint64_t sServiceWorkerManagerParentID = 0;
 
-class RegisterOnMainThread final : public Runnable
-{
-public:
-  explicit RegisterOnMainThread(const ServiceWorkerRegistrationData& aData)
-      : mData(aData)
-  {
-    AssertIsInMainProcess();
-  }
-
-  NS_IMETHOD
-  Run()
-  {
-    AssertIsOnMainThread();
-    ServiceWorkerRegistrarParent::Get()->PropagateRegistration(mData);
-    return NS_OK;
-  }
-private:
-  ServiceWorkerRegistrationData mData;
-};
-
-class UnregisterOnMainThread final : public Runnable
-{
-public:
-  UnregisterOnMainThread(const PrincipalInfo& aPrincipalInfo, const nsAString& aScope)
-      : mPrincipalInfo(aPrincipalInfo)
-      , mScope(aScope)
-  {
-    AssertIsInMainProcess();
-  }
-
-  NS_IMETHOD
-  Run()
-  {
-    AssertIsOnMainThread();
-    ServiceWorkerRegistrarParent::Get()->PropagateUnregister(mPrincipalInfo, mScope);
-    return NS_OK;
-  }
-private:
-  PrincipalInfo mPrincipalInfo;
-  nsString mScope;
-};
-
 class RegisterServiceWorkerCallback final : public Runnable
 {
 public:
@@ -197,8 +177,7 @@ class RegisterServiceWorkerCallback final : public Runnable
       managerService->PropagateRegistration(mParentID, mData);
     }
 
-    RefPtr<RegisterOnMainThread> event = new RegisterOnMainThread(mData);
-    NS_DispatchToMainThread(event);
+    ServiceWorkerRegistrarParent::Get()->PropagateRegistration(mData);
 
     return NS_OK;
   }
@@ -242,8 +221,7 @@ class UnregisterServiceWorkerCallback final : public Runnable
                                           mScope);
     }
 
-    RefPtr<UnregisterOnMainThread> event = new UnregisterOnMainThread(mPrincipalInfo, mScope);
-    NS_DispatchToMainThread(event);
+    ServiceWorkerRegistrarParent::Get()->PropagateUnregister(mPrincipalInfo, mScope);
     return NS_OK;
   }
 
diff --git a/dom/workers/ServiceWorkerManagerParent.h b/dom/workers/ServiceWorkerManagerParent.h
index ca0e4b7..07dd29b 100644
--- a/dom/workers/ServiceWorkerManagerParent.h
+++ b/dom/workers/ServiceWorkerManagerParent.h
@@ -79,6 +79,8 @@ class ServiceWorkerRegistrarParent final
 public:
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::workers::ServiceWorkerRegistrarParent)
 
+  ServiceWorkerRegistrarParent();
+
   static ServiceWorkerRegistrarParent* Get();
   bool IsAvailable(/*const PrincipalOriginAttributes& aOriginAttributes*/nsIPrincipal* aPrincipal, nsIURI* aURI);
 
@@ -91,6 +93,7 @@ class ServiceWorkerRegistrarParent final
   {
   }
 
+  mozilla::Mutex mLock;
   nsClassHashtable<nsCStringHashKey, nsTArray<nsString>> mRegistrations;
 };
 
diff --git a/dom/workers/ServiceWorkerRegistrar.cpp b/dom/workers/ServiceWorkerRegistrar.cpp
index cd08172..425c711 100644
--- a/dom/workers/ServiceWorkerRegistrar.cpp
+++ b/dom/workers/ServiceWorkerRegistrar.cpp
@@ -349,6 +349,10 @@ ServiceWorkerRegistrar::ReadData()
       entry->principal() =
         mozilla::ipc::ContentPrincipalInfo(attrs, entry->scope());
 
+      entry->scopeKey() = entry->scope();
+      entry->scopeKey().Append('!');
+      entry->scopeKey().Append(suffix);
+
       GET_LINE(entry->currentWorkerURL());
 
       nsAutoCString cacheName;
diff --git a/dom/workers/ServiceWorkerRegistrarTypes.ipdlh b/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
index 7754a19..bb1b0bd 100644
--- a/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
+++ b/dom/workers/ServiceWorkerRegistrarTypes.ipdlh
@@ -17,6 +17,7 @@ struct ServiceWorkerRegistrationData
   nsString cacheName;
 
   PrincipalInfo principal;
+  nsCString scopeKey;
 };
 
 } // namespace dom
