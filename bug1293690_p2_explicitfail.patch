# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  057cd0ad2d24ed195643d9461e1e7bd2e0792701
Bug 1293690 P2 Set explicit status levels to fail at when calling WorkerHolder::HoldWorker. r=baku

diff --git a/dom/base/FileReader.cpp b/dom/base/FileReader.cpp
--- a/dom/base/FileReader.cpp
+++ b/dom/base/FileReader.cpp
@@ -696,17 +696,17 @@ FileReader::Abort(ErrorResult& aRv)
   DispatchProgressEvent(NS_LITERAL_STRING(ABORT_STR));
   DispatchProgressEvent(NS_LITERAL_STRING(LOADEND_STR));
 }
 
 nsresult
 FileReader::IncreaseBusyCounter()
 {
   if (mWorkerPrivate && mBusyCount++ == 0 &&
-      !HoldWorker(mWorkerPrivate)) {
+      !HoldWorker(mWorkerPrivate, Closing)) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
 void
 FileReader::DecreaseBusyCounter()
diff --git a/dom/base/WebSocket.cpp b/dom/base/WebSocket.cpp
--- a/dom/base/WebSocket.cpp
+++ b/dom/base/WebSocket.cpp
@@ -2265,17 +2265,17 @@ WebSocketImpl::ReleaseObject()
 
 bool
 WebSocketImpl::RegisterWorkerHolder()
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
   MOZ_ASSERT(!mWorkerHolder);
   mWorkerHolder = new WebSocketWorkerHolder(this);
 
-  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate))) {
+  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate, Canceling))) {
     mWorkerHolder = nullptr;
     return false;
   }
 
 #ifdef DEBUG
   SetHasWorkerHolderRegistered(true);
 #endif
 
diff --git a/dom/broadcastchannel/BroadcastChannel.cpp b/dom/broadcastchannel/BroadcastChannel.cpp
--- a/dom/broadcastchannel/BroadcastChannel.cpp
+++ b/dom/broadcastchannel/BroadcastChannel.cpp
@@ -390,17 +390,17 @@ BroadcastChannel::Constructor(const Glob
 
     // Register as observer for inner-window-destroyed.
     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
     if (obs) {
       obs->AddObserver(bc, "inner-window-destroyed", false);
     }
   } else {
     bc->mWorkerHolder = new BroadcastChannelWorkerHolder(bc);
-    if (NS_WARN_IF(!bc->mWorkerHolder->HoldWorker(workerPrivate))) {
+    if (NS_WARN_IF(!bc->mWorkerHolder->HoldWorker(workerPrivate, Closing))) {
       bc->mWorkerHolder = nullptr;
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
   }
 
   return bc.forget();
 }
diff --git a/dom/cache/CacheWorkerHolder.cpp b/dom/cache/CacheWorkerHolder.cpp
--- a/dom/cache/CacheWorkerHolder.cpp
+++ b/dom/cache/CacheWorkerHolder.cpp
@@ -19,17 +19,17 @@ using mozilla::dom::workers::WorkerPriva
 
 // static
 already_AddRefed<CacheWorkerHolder>
 CacheWorkerHolder::Create(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
 
   RefPtr<CacheWorkerHolder> workerHolder = new CacheWorkerHolder();
-  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate))) {
+  if (NS_WARN_IF(!workerHolder->HoldWorker(aWorkerPrivate, Terminating))) {
     return nullptr;
   }
 
   return workerHolder.forget();
 }
 
 void
 CacheWorkerHolder::AddActor(ActorChild* aActor)
diff --git a/dom/crypto/WebCryptoTask.cpp b/dom/crypto/WebCryptoTask.cpp
--- a/dom/crypto/WebCryptoTask.cpp
+++ b/dom/crypto/WebCryptoTask.cpp
@@ -35,16 +35,17 @@ const SEC_ASN1Template SGN_DigestInfoTem
     { SEC_ASN1_OCTET_STRING,
       offsetof(SGNDigestInfo,digest) },
     { 0, }
 };
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::dom::workers::Canceling;
 using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
 using mozilla::dom::workers::Status;
 using mozilla::dom::workers::WorkerHolder;
 using mozilla::dom::workers::WorkerPrivate;
 
 // Pre-defined identifiers for telemetry histograms
 
 enum TelemetryMethod {
@@ -156,17 +157,17 @@ class WebCryptoTask::InternalWorkerHolde
 public:
   static already_AddRefed<InternalWorkerHolder>
   Create()
   {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
     RefPtr<InternalWorkerHolder> ref = new InternalWorkerHolder();
-    if (NS_WARN_IF(!ref->HoldWorker(workerPrivate))) {
+    if (NS_WARN_IF(!ref->HoldWorker(workerPrivate, Canceling))) {
       return nullptr;
     }
     return ref.forget();
   }
 
   virtual bool
   Notify(Status aStatus) override
   {
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -913,17 +913,17 @@ template <class Derived>
 bool
 FetchBody<Derived>::RegisterWorkerHolder()
 {
   MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
   MOZ_ASSERT(!mWorkerHolder);
   mWorkerHolder = new FetchBodyWorkerHolder<Derived>(this);
 
-  if (!mWorkerHolder->HoldWorker(mWorkerPrivate)) {
+  if (!mWorkerHolder->HoldWorker(mWorkerPrivate, Closing)) {
     NS_WARNING("Failed to add workerHolder");
     mWorkerHolder = nullptr;
     return false;
   }
 
   return true;
 }
 
diff --git a/dom/indexedDB/IDBRequest.cpp b/dom/indexedDB/IDBRequest.cpp
--- a/dom/indexedDB/IDBRequest.cpp
+++ b/dom/indexedDB/IDBRequest.cpp
@@ -570,17 +570,17 @@ IDBOpenDBRequest::CreateForJS(JSContext*
 
   if (!NS_IsMainThread()) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
     workerPrivate->AssertIsOnWorkerThread();
 
     nsAutoPtr<WorkerHolder> workerHolder(new WorkerHolder(workerPrivate));
-    if (NS_WARN_IF(!workerHolder->HoldWorker(workerPrivate))) {
+    if (NS_WARN_IF(!workerHolder->HoldWorker(workerPrivate, Canceling))) {
       workerHolder->NoteAddWorkerHolderFailed();
       return nullptr;
     }
 
     request->mWorkerHolder = Move(workerHolder);
   }
 
   return request.forget();
diff --git a/dom/indexedDB/IDBTransaction.cpp b/dom/indexedDB/IDBTransaction.cpp
--- a/dom/indexedDB/IDBTransaction.cpp
+++ b/dom/indexedDB/IDBTransaction.cpp
@@ -235,17 +235,17 @@ IDBTransaction::Create(JSContext* aCx, I
 
   if (!NS_IsMainThread()) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
 
     workerPrivate->AssertIsOnWorkerThread();
 
     transaction->mWorkerHolder = new WorkerHolder(workerPrivate, transaction);
-    MOZ_ALWAYS_TRUE(transaction->mWorkerHolder->HoldWorker(workerPrivate));
+    MOZ_ALWAYS_TRUE(transaction->mWorkerHolder->HoldWorker(workerPrivate, Canceling));
   }
 
   return transaction.forget();
 }
 
 // static
 IDBTransaction*
 IDBTransaction::GetCurrent()
diff --git a/dom/messagechannel/MessagePort.cpp b/dom/messagechannel/MessagePort.cpp
--- a/dom/messagechannel/MessagePort.cpp
+++ b/dom/messagechannel/MessagePort.cpp
@@ -355,17 +355,17 @@ MessagePort::Initialize(const nsID& aUUI
   UpdateMustKeepAlive();
 
   if (!NS_IsMainThread()) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(workerPrivate);
     MOZ_ASSERT(!mWorkerHolder);
 
     nsAutoPtr<WorkerHolder> workerHolder(new MessagePortWorkerHolder(this));
-    if (NS_WARN_IF(!workerHolder->HoldWorker(workerPrivate))) {
+    if (NS_WARN_IF(!workerHolder->HoldWorker(workerPrivate, Closing))) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     mWorkerHolder = Move(workerHolder);
   } else if (GetOwner()) {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(GetOwner()->IsInnerWindow());
diff --git a/dom/notification/Notification.cpp b/dom/notification/Notification.cpp
--- a/dom/notification/Notification.cpp
+++ b/dom/notification/Notification.cpp
@@ -2559,17 +2559,17 @@ NotificationWorkerHolder::Notify(Status 
 
 bool
 Notification::RegisterWorkerHolder()
 {
   MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
   MOZ_ASSERT(!mWorkerHolder);
   mWorkerHolder = MakeUnique<NotificationWorkerHolder>(this);
-  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate))) {
+  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate, Canceling))) {
     return false;
   }
 
   return true;
 }
 
 void
 Notification::UnregisterWorkerHolder()
diff --git a/dom/promise/Promise.cpp b/dom/promise/Promise.cpp
--- a/dom/promise/Promise.cpp
+++ b/dom/promise/Promise.cpp
@@ -2763,17 +2763,17 @@ Promise::Settle(JS::Handle<JS::Value> aV
   if (aState == PromiseState::Rejected &&
       !mHadRejectCallback &&
       !NS_IsMainThread()) {
     WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(worker);
     worker->AssertIsOnWorkerThread();
 
     mWorkerHolder = new PromiseReportRejectWorkerHolder(this);
-    if (NS_WARN_IF(!mWorkerHolder->HoldWorker(worker))) {
+    if (NS_WARN_IF(!mWorkerHolder->HoldWorker(worker, Closing))) {
       mWorkerHolder = nullptr;
       // Worker is shutting down, report rejection immediately since it is
       // unlikely that reject callbacks will be added after this point.
       MaybeReportRejectedOnce();
     }
   }
 #endif // defined(DOM_PROMISE_DEPRECATED_REPORTING)
 
@@ -3020,17 +3020,17 @@ PromiseWorkerProxy::CleanProperties()
 bool
 PromiseWorkerProxy::AddRefObject()
 {
   MOZ_ASSERT(mWorkerPrivate);
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   MOZ_ASSERT(!mWorkerHolder);
   mWorkerHolder.reset(new PromiseWorkerHolder(this));
-  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate))) {
+  if (NS_WARN_IF(!mWorkerHolder->HoldWorker(mWorkerPrivate, Canceling))) {
     mWorkerHolder = nullptr;
     return false;
   }
 
   // Maintain a reference so that we have a valid object to clean up when
   // removing the feature.
   AddRef();
   return true;
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -2093,17 +2093,17 @@ LoadAllScripts(WorkerPrivate* aWorkerPri
     new ScriptLoaderRunnable(aWorkerPrivate, syncLoop.EventTarget(),
                              aLoadInfos, aIsMainScript, aWorkerScriptType,
                              aRv);
 
   NS_ASSERTION(aLoadInfos.IsEmpty(), "Should have swapped!");
 
   ScriptLoaderHolder workerHolder(loader);
 
-  if (NS_WARN_IF(!workerHolder.HoldWorker(aWorkerPrivate))) {
+  if (NS_WARN_IF(!workerHolder.HoldWorker(aWorkerPrivate, Terminating))) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
   }
 
   if (NS_FAILED(NS_DispatchToMainThread(loader))) {
     NS_ERROR("Failed to dispatch!");
     aRv.Throw(NS_ERROR_FAILURE);
     return;
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -264,17 +264,17 @@ class KeepAliveHandler final
     }
 
     bool
     UseWorkerHolder()
     {
       MOZ_ASSERT(mWorkerPrivate);
       mWorkerPrivate->AssertIsOnWorkerThread();
       MOZ_ASSERT(!mWorkerHolderAdded);
-      mWorkerHolderAdded = HoldWorker(mWorkerPrivate);
+      mWorkerHolderAdded = HoldWorker(mWorkerPrivate, Terminating);
       return mWorkerHolderAdded;
     }
 
     void
     MaybeCleanup()
     {
       MOZ_ASSERT(mWorkerPrivate);
       mWorkerPrivate->AssertIsOnWorkerThread();
@@ -596,17 +596,17 @@ public:
 
     // We need to listen for worker termination in case the event handler
     // never completes or never resolves the waitUntil promise. There are
     // two possible scenarios:
     // 1. The keepAlive token expires and the worker is terminated, in which
     //    case the registration/update promise will be rejected
     // 2. A new service worker is registered which will terminate the current
     //    installing worker.
-    if (NS_WARN_IF(!HoldWorker(mWorkerPrivate))) {
+    if (NS_WARN_IF(!HoldWorker(mWorkerPrivate, Terminating))) {
       NS_WARNING("LifeCycleEventWatcher failed to add feature.");
       ReportResult(false);
       return false;
     }
 
     return true;
   }
 
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -1187,17 +1187,17 @@ void
 ServiceWorkerRegistrationWorkerThread::InitListener()
 {
   MOZ_ASSERT(!mListener);
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
 
   mListener = new WorkerListener(worker, this);
-  if (!HoldWorker(worker)) {
+  if (!HoldWorker(worker, Closing)) {
     mListener = nullptr;
     NS_WARNING("Could not add feature");
     return;
   }
 
   RefPtr<StartListeningRunnable> r =
     new StartListeningRunnable(mListener);
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r));
diff --git a/dom/workers/WorkerRunnable.cpp b/dom/workers/WorkerRunnable.cpp
--- a/dom/workers/WorkerRunnable.cpp
+++ b/dom/workers/WorkerRunnable.cpp
@@ -760,17 +760,17 @@ WorkerProxyToMainThreadRunnable::HoldWor
     {
       // We don't care about the notification. We just want to keep the
       // mWorkerPrivate alive.
       return true;
     }
   };
 
   UniquePtr<WorkerHolder> workerHolder(new SimpleWorkerHolder());
-  if (NS_WARN_IF(!workerHolder->HoldWorker(mWorkerPrivate))) {
+  if (NS_WARN_IF(!workerHolder->HoldWorker(mWorkerPrivate, Canceling))) {
     return false;
   }
 
   mWorkerHolder = Move(workerHolder);
   return true;
 }
 
 void
diff --git a/dom/xhr/XMLHttpRequestWorker.cpp b/dom/xhr/XMLHttpRequestWorker.cpp
--- a/dom/xhr/XMLHttpRequestWorker.cpp
+++ b/dom/xhr/XMLHttpRequestWorker.cpp
@@ -1640,17 +1640,17 @@ void
 XMLHttpRequestWorker::MaybePin(ErrorResult& aRv)
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   if (mRooted) {
     return;
   }
 
-  if (!HoldWorker(mWorkerPrivate)) {
+  if (!HoldWorker(mWorkerPrivate, Canceling)) {
     aRv.Throw(NS_ERROR_FAILURE);
     return;
   }
 
   NS_ADDREF_THIS();
 
   mRooted = true;
 }
diff --git a/ipc/glue/SendStreamChild.cpp b/ipc/glue/SendStreamChild.cpp
--- a/ipc/glue/SendStreamChild.cpp
+++ b/ipc/glue/SendStreamChild.cpp
@@ -16,16 +16,17 @@
 #include "nsIRunnable.h"
 #include "nsIThread.h"
 #include "nsStreamUtils.h"
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::PContentChild;
+using mozilla::dom::workers::Canceling;
 using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
 using mozilla::dom::workers::Status;
 using mozilla::dom::workers::WorkerHolder;
 using mozilla::dom::workers::WorkerPrivate;
 
 namespace {
 
 class SendStreamChildImpl final : public SendStreamChild
@@ -179,17 +180,17 @@ SendStreamChildImpl::StartDestroy()
   OnEnd(NS_ERROR_ABORT);
 }
 
 bool
 SendStreamChildImpl::AddAsWorkerHolder(WorkerPrivate* aWorkerPrivate)
 {
   NS_ASSERT_OWNINGTHREAD(SendStreamChild);
   MOZ_ASSERT(aWorkerPrivate);
-  bool result = HoldWorker(aWorkerPrivate);
+  bool result = HoldWorker(aWorkerPrivate, Canceling);
   if (result) {
     mWorkerPrivate = aWorkerPrivate;
   }
   return result;
 }
 
 void
 SendStreamChildImpl::ActorDestroy(ActorDestroyReason aReason)
