# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  117040ba614438a4d6a6fa63e2a9d2436d78f229
Bug 1329006 Make RescheduleTimeouts() deadlines correctly for suspended windows. r=smaug

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -711,21 +711,30 @@ TimeoutManager::RescheduleTimeout(Timeou
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
   // time to run the callback.
   if (delay < TimeDuration(0)) {
     delay = TimeDuration(0);
   }
 
   if (!aTimeout->mTimer) {
-    NS_ASSERTION(mWindow.IsFrozen() || mWindow.IsSuspended(),
-                 "How'd our timer end up null if we're not frozen or "
-                 "suspended?");
-
-    aTimeout->mTimeRemaining = delay;
+    if (mWindow.IsFrozen()) {
+      // If we are frozen simply set timeout->mTimeRemaining to be the
+      // "time remaining" in the timeout (i.e., the interval itself).  This
+      // will be used to create a new mWhen time when the window is thawed.
+      // The end effect is that time does not appear to pass for frozen windows.
+      aTimeout->mTimeRemaining = delay;
+    } else if (mWindow.IsSuspended()) {
+    // Since we are not frozen we must set a precise mWhen target wakeup
+    // time.  Even if we are suspended we want to use this target time so
+    // that it appears time passes while suspended.
+      aTimeout->mWhen = currentNow + delay;
+    } else {
+      MOZ_ASSERT_UNREACHABLE("Window should be frozen or suspended.");
+    }
     return true;
   }
 
   aTimeout->mWhen = currentNow + delay;
 
   // Reschedule the OS timer. Don't bother returning any error codes if
   // this fails since the callers of this method don't care about them.
   nsresult rv = aTimeout->InitTimer(mWindow.EventTargetFor(TaskCategory::Timer),
