# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1c9d27f3d2faa3d7ca7d3cbbc2fef6c77e2bf36d
Bug 1423913 P1 Make ClientManager::CreateSource() and CreateHandle() infallible.  Errors result in a detached object instead of nullptr.  r=baku

diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -98,46 +98,58 @@ ClientManager::Shutdown()
 
 UniquePtr<ClientSource>
 ClientManager::CreateSourceInternal(ClientType aType,
                                     nsISerialEventTarget* aEventTarget,
                                     const PrincipalInfo& aPrincipal)
 {
   NS_ASSERT_OWNINGTHREAD(ClientManager);
 
-  if (IsShutdown()) {
-    return nullptr;
-  }
-
   nsID id;
   nsresult rv = nsContentUtils::GenerateUUIDInPlace(id);
+  MOZ_DIAGNOSTIC_ASSERT(NS_SUCCEEDED(rv));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return nullptr;
+    // If we can't even get a UUID, at least make sure not to use a garbage
+    // value.  Instead return a shutdown ClientSource with a zero'd id.
+    // This should be exceptionally rare, if it happens at all.
+    id.Clear();
+    ClientSourceConstructorArgs args(id, aType, aPrincipal, TimeStamp::Now());
+    UniquePtr<ClientSource> source(new ClientSource(this, aEventTarget, args));
+    source->Shutdown();
+    return Move(source);
   }
 
   ClientSourceConstructorArgs args(id, aType, aPrincipal, TimeStamp::Now());
   UniquePtr<ClientSource> source(new ClientSource(this, aEventTarget, args));
+
+  if (IsShutdown()) {
+    source->Shutdown();
+    return Move(source);
+  }
+
   source->Activate(GetActor());
 
   return Move(source);
 }
 
 already_AddRefed<ClientHandle>
 ClientManager::CreateHandleInternal(const ClientInfo& aClientInfo,
                                     nsISerialEventTarget* aSerialEventTarget)
 {
   NS_ASSERT_OWNINGTHREAD(ClientManager);
   MOZ_DIAGNOSTIC_ASSERT(aSerialEventTarget);
 
+  RefPtr<ClientHandle> handle = new ClientHandle(this, aSerialEventTarget,
+                                                 aClientInfo);
+
   if (IsShutdown()) {
-    return nullptr;
+    handle->Shutdown();
+    return handle.forget();
   }
 
-  RefPtr<ClientHandle> handle = new ClientHandle(this, aSerialEventTarget,
-                                                 aClientInfo);
   handle->Activate(GetActor());
 
   return handle.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientManager::StartOp(const ClientOpConstructorArgs& aArgs,
                        nsISerialEventTarget* aSerialEventTarget)
@@ -215,17 +227,17 @@ ClientManager::CreateSource(ClientType a
                             nsIPrincipal* aPrincipal)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   PrincipalInfo principalInfo;
   nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    return nullptr;
+    MOZ_CRASH("ClientManager::CreateSource() cannot serialize bad principal");
   }
 
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->CreateSourceInternal(aType, aEventTarget, principalInfo);
 }
 
 // static
 UniquePtr<ClientSource>
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -177,16 +177,20 @@ ClientSource::GetInnerWindow() const
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
+  if (IsShutdown()) {
+    return;
+  }
+
   // Its safe to store the WorkerPrivate* here because the ClientSource
   // is explicitly destroyed by WorkerPrivate before exiting its run loop.
   MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>());
   mOwner = AsVariant(aWorkerPrivate);
 
   ClientSourceExecutionReadyArgs args(
     aWorkerPrivate->GetLocationInfo().mHref,
     FrameType::None);
@@ -197,16 +201,20 @@ ClientSource::WorkerExecutionReady(Worke
 nsresult
 ClientSource::WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(aInnerWindow);
   MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->IsCurrentInnerWindow());
   MOZ_DIAGNOSTIC_ASSERT(aInnerWindow->HasActiveDocument());
 
+  if (IsShutdown()) {
+    return NS_OK;
+  }
+
   nsIDocument* doc = aInnerWindow->GetExtantDoc();
   if (NS_WARN_IF(!doc)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   // Don't use nsAutoCString here since IPC requires a full nsCString anyway.
   nsCString spec;
 
@@ -248,16 +256,20 @@ ClientSource::WindowExecutionReady(nsPID
 }
 
 nsresult
 ClientSource::DocShellExecutionReady(nsIDocShell* aDocShell)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(aDocShell);
 
+  if (IsShutdown()) {
+    return NS_OK;
+  }
+
   nsPIDOMWindowOuter* outer = aDocShell->GetWindow();
   if (NS_WARN_IF(!outer)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   // TODO: dedupe this with WindowExecutionReady
   FrameType frameType = FrameType::Top_level;
   if (!outer->IsTopLevelWindow()) {
@@ -301,19 +313,25 @@ ClientSource::Info() const
   return mClientInfo;
 }
 
 void
 ClientSource::WorkerSyncPing(WorkerPrivate* aWorkerPrivate)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+
+  if (IsShutdown()) {
+    return;
+  }
+
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate == mManager->GetWorkerPrivate());
   aWorkerPrivate->AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(GetActor());
+
   GetActor()->SendWorkerSyncPing();
 }
 
 void
 ClientSource::SetController(const ServiceWorkerDescriptor& aServiceWorker)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
