# HG changeset patch
# Parent  0502bd9e025edde29777ba1de4280f9b52af4663

diff --git a/dom/ipc/PBrowser.ipdl b/dom/ipc/PBrowser.ipdl
--- a/dom/ipc/PBrowser.ipdl
+++ b/dom/ipc/PBrowser.ipdl
@@ -564,16 +564,18 @@ parent:
                             OptionalShmem visualData,
                             uint32_t width, uint32_t height,
                             uint32_t stride, uint8_t format,
                             int32_t dragAreaX, int32_t dragAreaY);
 
     async AudioChannelActivityNotification(uint32_t aAudioChannel,
                                            bool aActive);
 
+    async MarkDocumentControlled(bool aIsControlled);
+
 child:
     /**
      * Notify the remote browser that it has been Show()n on this
      * side, with the given |visibleRect|.  This message is expected
      * to trigger creation of the remote browser's "widget".
      *
      * |Show()| and |Move()| take IntSizes rather than Rects because
      * content processes always render to a virtual <0, 0> top-left
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -291,16 +291,17 @@ TabParent::TabParent(nsIContentParent* a
   , mDragAreaY(0)
   , mInitedByParent(false)
   , mTabId(aTabId)
   , mCreatingWindow(false)
   , mNeedLayerTreeReadyNotification(false)
   , mCursor(nsCursor(-1))
   , mTabSetsCursor(false)
   , mHasContentOpener(false)
+  , mIsControlled(false)
 #ifdef DEBUG
   , mActiveSupressDisplayportCount(0)
 #endif
 {
   MOZ_ASSERT(aManager);
 }
 
 TabParent::~TabParent()
@@ -2678,16 +2679,24 @@ TabParent::RecvAudioChannelActivityNotif
     os->NotifyObservers(NS_ISUPPORTS_CAST(nsITabParent*, this),
                         topic.get(),
                         aActive ? u"active" : u"inactive");
   }
 
   return true;
 }
 
+bool
+TabParent::RecvMarkDocumentControlled(const bool& aIsControlled)
+{
+  printf("document is controlled: %s\n", aIsControlled ? "true" : "false");
+  mIsControlled = aIsControlled;
+  return true;
+}
+
 already_AddRefed<nsFrameLoader>
 TabParent::GetFrameLoader(bool aUseCachedFrameLoaderAfterDestroy) const
 {
   if (mIsDestroyed && !aUseCachedFrameLoaderAfterDestroy) {
     return nullptr;
   }
 
   if (mFrameLoader) {
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -614,16 +614,20 @@ public:
   void AudioChannelChangeNotification(nsPIDOMWindowOuter* aWindow,
                                       AudioChannel aAudioChannel,
                                       float aVolume,
                                       bool aMuted);
   bool SetRenderFrame(PRenderFrameParent* aRFParent);
   bool GetRenderFrameInfo(TextureFactoryIdentifier* aTextureFactoryIdentifier,
                           uint64_t* aLayersId);
 
+  bool DocumentIsControlled() {
+    return mIsControlled;
+  }
+
 protected:
   bool ReceiveMessage(const nsString& aMessage,
                       bool aSync,
                       ipc::StructuredCloneData* aData,
                       mozilla::jsipc::CpowHolder* aCpows,
                       nsIPrincipal* aPrincipal,
                       nsTArray<ipc::StructuredCloneData>* aJSONRetVal = nullptr);
 
@@ -648,16 +652,18 @@ protected:
                                  const int32_t& aX, const int32_t& aY,
                                  const int32_t& aCx, const int32_t& aCy) override;
 
   virtual bool RecvGetTabCount(uint32_t* aValue) override;
 
   virtual bool RecvAudioChannelActivityNotification(const uint32_t& aAudioChannel,
                                                     const bool& aActive) override;
 
+  virtual bool RecvMarkDocumentControlled(const bool& aIsControlled) override;
+
   ContentCacheInParent mContentCache;
 
   nsIntRect mRect;
   ScreenIntSize mDimensions;
   ScreenOrientationInternal mOrientation;
   float mDPI;
   CSSToLayoutDeviceScale mDefaultScale;
   bool mUpdatedDimensions;
@@ -775,16 +781,18 @@ private:
   // True if the cursor changes from the TabChild should change the widget
   // cursor.  This happens whenever the cursor is in the tab's region.
   bool mTabSetsCursor;
 
   RefPtr<nsIPresShell> mPresShellWithRefreshListener;
 
   bool mHasContentOpener;
 
+  bool mIsControlled;
+
 #ifdef DEBUG
   int32_t mActiveSupressDisplayportCount;
 #endif
 
   ShowInfo GetShowInfo();
 
 private:
   // This is used when APZ needs to find the TabParent associated with a layer
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -40,16 +40,17 @@
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/RootedDictionary.h"
+#include "mozilla/dom/TabChild.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/unused.h"
 #include "mozilla/EnumSet.h"
 
 #include "nsContentPolicyUtils.h"
 #include "nsContentSecurityManager.h"
@@ -1947,22 +1948,32 @@ ServiceWorkerManager::MaybeStartControll
 
 void
 ServiceWorkerManager::MaybeStopControlling(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   mControlledDocuments.Remove(aDoc, getter_AddRefs(registration));
+  printf("maybe stopped controlling: %p\n", registration.get());
   // A document which was uncontrolled does not maintain that state itself, so
   // it will always call MaybeStopControlling() even if there isn't an
   // associated registration. So this check is required.
   if (registration) {
     StopControllingADocument(registration);
   }
+
+  nsCOMPtr<nsIDocShell> docShell = aDoc->GetDocShell();
+  if (docShell) {
+    TabChild* tabChild = TabChild::GetFrom(docShell);
+    if (tabChild) {
+      tabChild->SendMarkDocumentControlled(false);
+    }
+  }
+
 }
 
 void
 ServiceWorkerManager::MaybeCheckNavigationUpdate(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
   // We perform these success path navigation update steps when the
@@ -1986,16 +1997,23 @@ ServiceWorkerManager::StartControllingAD
                                                 nsIDocument* aDoc,
                                                 const nsAString& aDocumentId)
 {
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(aDoc);
 
   aRegistration->StartControllingADocument();
   mControlledDocuments.Put(aDoc, aRegistration);
+  nsCOMPtr<nsIDocShell> docShell = aDoc->GetDocShell();
+  if (docShell) {
+    TabChild* tabChild = TabChild::GetFrom(docShell);
+    if (tabChild) {
+      tabChild->SendMarkDocumentControlled(true);
+    }
+  }
   if (!aDocumentId.IsEmpty()) {
     aDoc->SetId(aDocumentId);
   }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
 }
 
 void
 ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -478,15 +478,17 @@ private:
                         const nsAString& aTitle,
                         const nsAString& aDir,
                         const nsAString& aLang,
                         const nsAString& aBody,
                         const nsAString& aTag,
                         const nsAString& aIcon,
                         const nsAString& aData,
                         const nsAString& aBehavior);
+
+  friend class ServiceWorkerRegistrarParent;
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkermanager_h
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -1,35 +1,177 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerManagerParent.h"
 #include "ServiceWorkerManagerService.h"
+#include "ServiceWorkerManager.h"
 #include "mozilla/AppProcessChecker.h"
+#include "mozilla/ClearOnShutdown.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
+#include "mozilla/dom/workers/Workers.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/unused.h"
 #include "nsThreadUtils.h"
+#include "nsIURI.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 namespace workers {
 
+StaticRefPtr<ServiceWorkerRegistrarParent> gRegistrarInstance;
+
+ServiceWorkerRegistrarParent*
+ServiceWorkerRegistrarParent::Get()
+{
+  if (!gRegistrarInstance) {
+    ClearOnShutdown(&gRegistrarInstance);
+    gRegistrarInstance = new ServiceWorkerRegistrarParent();
+  }
+  return gRegistrarInstance;
+}
+
+bool
+ServiceWorkerRegistrarParent::IsAvailable(/*const PrincipalOriginAttributes& aOriginAttributes*/
+    nsIPrincipal* aPrincipal,
+    nsIURI* aURI)
+{
+  /*nsAutoCString originAttributesSuffix;
+    aOriginAttributes.CreateSuffix(originAttributesSuffix);*/
+  nsAutoCString scopeKey;
+  nsresult rv = ServiceWorkerManager::PrincipalToScopeKey(aPrincipal, scopeKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return false;
+  }
+
+  printf("checking for `%s`\n", scopeKey.get());
+  const nsTArray<nsString>* scopes = mRegistrations.Get(scopeKey);
+  if (!scopes) {
+    return false;
+  }
+
+  nsAutoCString spec;
+  rv = aURI->GetSpec(spec);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return false;
+  }
+
+  nsAutoString wideSpec = NS_ConvertUTF8toUTF16(spec);
+
+  printf("checking scopes\n");
+  for (uint32_t i = 0; i < scopes->Length(); ++i) {
+    const nsString& current = (*scopes)[i];
+    if (StringBeginsWith(wideSpec, current)) {
+      printf("found matching scope %s\n", NS_ConvertUTF16toUTF8(current).get());
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void
+ServiceWorkerRegistrarParent::PropagateRegistration(ServiceWorkerRegistrationData& aData)
+{
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aData.principal(), &rv);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsAutoCString scopeKey;
+  rv = ServiceWorkerManager::PrincipalToScopeKey(principal, scopeKey);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsString scope(NS_ConvertUTF8toUTF16(aData.scope()));
+  nsTArray<nsString>* scopes = mRegistrations.LookupOrAdd(scopeKey);
+  for (uint32_t i = 0; i < scopes->Length(); i++) {
+    if ((*scopes)[i] == scope) {
+      return;
+    }
+  }
+  scopes->AppendElement(scope);
+
+  printf("registering %s for %s\n", aData.scope().get(), scopeKey.get());
+}
+
+void
+ServiceWorkerRegistrarParent::PropagateUnregister(const PrincipalInfo& aPrincipalInfo,
+                                                  const nsAString& aScope)
+{
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo, &rv);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsAutoCString scopeKey;
+  rv = ServiceWorkerManager::PrincipalToScopeKey(principal, scopeKey);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsTArray<nsString>* scopes = mRegistrations.Get(scopeKey);
+  for (uint32_t i = 0; i < scopes->Length(); i++) {
+    if ((*scopes)[i] == aScope) {
+      scopes->RemoveElementAt(i);
+      printf("unregistering %s for %s\n", NS_ConvertUTF16toUTF8(aScope).get(), scopeKey.get());
+      break;
+    }
+  }
+}
+
 namespace {
 
 uint64_t sServiceWorkerManagerParentID = 0;
 
+class RegisterOnMainThread final : public Runnable
+{
+public:
+  explicit RegisterOnMainThread(const ServiceWorkerRegistrationData& aData)
+      : mData(aData)
+  {
+    AssertIsInMainProcess();
+  }
+
+  NS_IMETHOD
+  Run()
+  {
+    AssertIsOnMainThread();
+    ServiceWorkerRegistrarParent::Get()->PropagateRegistration(mData);
+    return NS_OK;
+  }
+private:
+  ServiceWorkerRegistrationData mData;
+};
+
+class UnregisterOnMainThread final : public Runnable
+{
+public:
+  UnregisterOnMainThread(const PrincipalInfo& aPrincipalInfo, const nsAString& aScope)
+      : mPrincipalInfo(aPrincipalInfo)
+      , mScope(aScope)
+  {
+    AssertIsInMainProcess();
+  }
+
+  NS_IMETHOD
+  Run()
+  {
+    AssertIsOnMainThread();
+    ServiceWorkerRegistrarParent::Get()->PropagateUnregister(mPrincipalInfo, mScope);
+    return NS_OK;
+  }
+private:
+  PrincipalInfo mPrincipalInfo;
+  nsString mScope;
+};
+
 class RegisterServiceWorkerCallback final : public Runnable
 {
 public:
   RegisterServiceWorkerCallback(const ServiceWorkerRegistrationData& aData,
                                 uint64_t aParentID)
     : mData(aData)
     , mParentID(aParentID)
   {
@@ -50,16 +192,19 @@ public:
     service->RegisterServiceWorker(mData);
 
     RefPtr<ServiceWorkerManagerService> managerService =
       ServiceWorkerManagerService::Get();
     if (managerService) {
       managerService->PropagateRegistration(mParentID, mData);
     }
 
+    RefPtr<RegisterOnMainThread> event = new RegisterOnMainThread(mData);
+    NS_DispatchToMainThread(event);
+
     return NS_OK;
   }
 
 private:
   ServiceWorkerRegistrationData mData;
   const uint64_t mParentID;
 };
 
@@ -92,16 +237,18 @@ public:
 
     RefPtr<ServiceWorkerManagerService> managerService =
       ServiceWorkerManagerService::Get();
     if (managerService) {
       managerService->PropagateUnregister(mParentID, mPrincipalInfo,
                                           mScope);
     }
 
+    RefPtr<UnregisterOnMainThread> event = new UnregisterOnMainThread(mPrincipalInfo, mScope);
+    NS_DispatchToMainThread(event);
     return NS_OK;
   }
 
 private:
   const PrincipalInfo mPrincipalInfo;
   nsString mScope;
   uint64_t mParentID;
 };
diff --git a/dom/workers/ServiceWorkerManagerParent.h b/dom/workers/ServiceWorkerManagerParent.h
--- a/dom/workers/ServiceWorkerManagerParent.h
+++ b/dom/workers/ServiceWorkerManagerParent.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerManagerParent_h
 #define mozilla_dom_ServiceWorkerManagerParent_h
 
 #include "mozilla/dom/PServiceWorkerManagerParent.h"
+#include "nsClassHashtable.h"
 
 namespace mozilla {
 
 class PrincipalOriginAttributes;
 
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
@@ -68,13 +69,33 @@ private:
 
   // We use this ID in the Service in order to avoid the sending of messages to
   // ourself.
   uint64_t mID;
 
   bool mActorDestroyed;
 };
 
+class ServiceWorkerRegistrarParent final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::workers::ServiceWorkerRegistrarParent)
+
+  static ServiceWorkerRegistrarParent* Get();
+  bool IsAvailable(/*const PrincipalOriginAttributes& aOriginAttributes*/nsIPrincipal* aPrincipal, nsIURI* aURI);
+
+  void PropagateRegistration(ServiceWorkerRegistrationData& aData);
+  void PropagateUnregister(const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
+                           const nsAString& aScope);
+
+private:
+  ~ServiceWorkerRegistrarParent()
+  {
+  }
+
+  nsClassHashtable<nsCStringHashKey, nsTArray<nsString>> mRegistrations;
+};
+
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerManagerParent_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -5,16 +5,17 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
     'FileReaderSync.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
     'ServiceWorkerEvents.h',
+    'ServiceWorkerManagerParent.h',
     'ServiceWorkerMessageEvent.h',
     'ServiceWorkerRegistrar.h',
     'ServiceWorkerRegistration.h',
     'WorkerLocation.h',
     'WorkerNavigator.h',
     'WorkerPrefs.h',
     'WorkerPrivate.h',
     'WorkerRunnable.h',
diff --git a/dom/workers/test/serviceworkers/fetch/fetch_tests.js b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
--- a/dom/workers/test/serviceworkers/fetch/fetch_tests.js
+++ b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
@@ -1,13 +1,12 @@
 var origin = 'http://mochi.test:8888';
 
 function fetchXHRWithMethod(name, method, onload, onerror, headers) {
   expectAsyncResult();
-
   onload = onload || function() {
     my_ok(false, "XHR load should not complete successfully");
     finish();
   };
   onerror = onerror || function() {
     my_ok(false, "XHR load for " + name + " should be intercepted successfully");
     finish();
   };
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -120,16 +120,17 @@ struct HttpChannelOpenArgs
   nsCString                   requestContextID;
   OptionalCorsPreflightArgs   preflightArgs;
   uint32_t                    initialRwin;
   bool                        blockAuthPrompt;
   bool                        suspendAfterSynthesizeResponse;
   bool                        allowStaleCacheContent;
   nsCString                   contentTypeHint;
   nsCString                   channelId;
+  uint32_t                    redirectMode;
 };
 
 struct HttpChannelConnectArgs
 {
   uint32_t registrarId;
   bool shouldIntercept;
 };
 
diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -286,16 +286,23 @@ HttpBaseChannel::GetLoadFlags(nsLoadFlag
   NS_ENSURE_ARG_POINTER(aLoadFlags);
   *aLoadFlags = mLoadFlags;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpBaseChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
 {
+  nsCOMPtr<nsISupports> raw = do_QueryInterface((nsIHttpChannel*)this);
+  printf("set load flags for %p, %s\n", raw.get(), aLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER ? "true" : "false");
+
+  if ((mLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER) && !(aLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER)) {
+    MOZ_ASSERT(false);
+  }
+
   bool synthesized = false;
   nsresult rv = GetResponseSynthesized(&synthesized);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // If this channel is marked as awaiting a synthesized response,
   // modifying certain load flags can interfere with the implementation
   // of the network interception logic. This takes care of a couple
   // known cases that attempt to mark channels as anonymous due
@@ -2614,20 +2621,25 @@ bool
 HttpBaseChannel::BypassServiceWorker() const
 {
   return mLoadFlags & LOAD_BYPASS_SERVICE_WORKER;
 }
 
 bool
 HttpBaseChannel::ShouldIntercept(nsIURI* aURI)
 {
+  nsCOMPtr<nsIURI> uri = aURI ? aURI : mURI.get();
   nsCOMPtr<nsINetworkInterceptController> controller;
   GetCallback(controller);
   bool shouldIntercept = false;
+  nsAutoCString spec;
+  uri->GetSpec(spec);
+  printf("%s: checking whether to prepare %s\n", XRE_IsParentProcess() ? "parent" : "child", spec.get());
   if (controller && !BypassServiceWorker() && mLoadInfo) {
+    printf("no bypass flag\n");
     nsresult rv = controller->ShouldPrepareForIntercept(aURI ? aURI : mURI.get(),
                                                         nsContentUtils::IsNonSubresourceRequest(this),
                                                         &shouldIntercept);
     if (NS_FAILED(rv)) {
       return false;
     }
   }
   return shouldIntercept;
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -165,16 +165,17 @@ HttpChannelChild::HttpChannelChild()
   , mSuspendSent(false)
   , mSynthesizedResponse(false)
   , mShouldInterceptSubsequentRedirect(false)
   , mRedirectingForSubsequentSynthesizedResponse(false)
   , mPostRedirectChannelShouldIntercept(false)
   , mPostRedirectChannelShouldUpgrade(false)
   , mShouldParentIntercept(false)
   , mSuspendParentAfterSynthesizeResponse(false)
+  , mResponseIsSynthesized(false)
 {
   LOG(("Creating HttpChannelChild @%x\n", this));
 
   mChannelCreationTime = PR_Now();
   mChannelCreationTimestamp = TimeStamp::Now();
   mAsyncOpenTime = TimeStamp::Now();
   mEventQ = new ChannelEventQueue(static_cast<nsIHttpChannel*>(this));
 }
@@ -294,16 +295,33 @@ HttpChannelChild::AssociateApplicationCa
   mApplicationCache = do_CreateInstance(NS_APPLICATIONCACHE_CONTRACTID, &rv);
   if (NS_FAILED(rv))
     return;
 
   mLoadedFromApplicationCache = true;
   mApplicationCache->InitAsHandle(groupID, clientID);
 }
 
+bool
+HttpChannelChild::RecvDispatchFetchEvent()
+{
+  mResponseCouldBeSynthesized = true;
+
+  nsCOMPtr<nsINetworkInterceptController> controller;
+  GetCallback(controller);
+
+  mInterceptListener = new InterceptStreamListener(this, mListenerContext);
+
+  RefPtr<InterceptedChannelContent> intercepted =
+      new InterceptedChannelContent(this, controller, mInterceptListener, false);
+  intercepted->NotifyController();
+
+  return true;
+}
+
 class StartRequestEvent : public ChannelEvent
 {
  public:
   StartRequestEvent(HttpChannelChild* aChild,
                     const nsresult& aChannelStatus,
                     const nsHttpResponseHead& aResponseHead,
                     const bool& aUseResponseHead,
                     const nsHttpHeaderArray& aRequestHeaders,
@@ -770,18 +788,19 @@ HttpChannelChild::DoOnProgress(nsIReques
   // block status/progress after Cancel or OnStopRequest has been called,
   // or if channel has LOAD_BACKGROUND set.
   if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending &&
       !(mLoadFlags & LOAD_BACKGROUND))
   {
     // OnProgress
     //
     if (progress > 0) {
-      MOZ_ASSERT((progressMax == -1) || (progress <= progressMax),
-                 "unexpected progress values");
+      if ((progressMax != -1) && (progress > progressMax)) {
+        NS_WARNING("unexpected progress values");
+      }
       mProgressSink->OnProgress(aRequest, nullptr, progress, progressMax);
     }
   }
 }
 
 void
 HttpChannelChild::DoOnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
                                     nsIInputStream* aStream,
@@ -1013,18 +1032,19 @@ HttpChannelChild::OnProgress(const int64
   }
 
   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
 
   // Block socket status event after Cancel or OnStopRequest has been called.
   if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending)
   {
     if (progress > 0) {
-      MOZ_ASSERT((progressMax == -1) || (progress <= progressMax),
-                 "unexpected progress values");
+      if ((progressMax != -1) && (progress > progressMax)) {
+        NS_WARNING("unexpected progress values");
+      }
       mProgressSink->OnProgress(this, nullptr, progress, progressMax);
     }
   }
 }
 
 class StatusEvent : public ChannelEvent
 {
  public:
@@ -1110,19 +1130,19 @@ HttpChannelChild::FailedAsyncOpen(const 
   mStatus = status;
 
   // We're already being called from IPDL, therefore already "async"
   HandleAsyncAbort();
 
   if (mIPCOpen) {
     PHttpChannelChild::Send__delete__(this);
   }
-  // WARNING:  DO NOT RELY ON |THIS| EXISTING ANY MORE! 
-  // 
-  // NeckoChild::DeallocPHttpChannelChild() may have been called, which deletes 
+  // WARNING:  DO NOT RELY ON |THIS| EXISTING ANY MORE!
+  //
+  // NeckoChild::DeallocPHttpChannelChild() may have been called, which deletes
   // |this| if IPDL holds the last reference.
 }
 
 void
 HttpChannelChild::DoNotifyListenerCleanup()
 {
   LOG(("HttpChannelChild::DoNotifyListenerCleanup [this=%p]\n", this));
 
@@ -1245,25 +1265,25 @@ HttpChannelChild::SetupRedirect(nsIURI* 
 
   rv = SetupReplacementChannel(uri, newChannel, !rewriteToGET, redirectFlags);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIHttpChannelChild> httpChannelChild = do_QueryInterface(newChannel);
   if (httpChannelChild) {
     bool shouldUpgrade = false;
     auto channelChild = static_cast<HttpChannelChild*>(httpChannelChild.get());
-    if (mShouldInterceptSubsequentRedirect) {
+    if (false && mShouldInterceptSubsequentRedirect) {
       // In the case where there was a synthesized response that caused a redirection,
       // we must force the new channel to intercept the request in the parent before a
       // network transaction is initiated.
       httpChannelChild->ForceIntercepted(false, false);
-    } else if (mRedirectMode == nsIHttpChannelInternal::REDIRECT_MODE_MANUAL &&
+    } else if (false && (mRedirectMode == nsIHttpChannelInternal::REDIRECT_MODE_MANUAL &&
                ((redirectFlags & (nsIChannelEventSink::REDIRECT_TEMPORARY |
                                   nsIChannelEventSink::REDIRECT_PERMANENT)) != 0) &&
-               channelChild->ShouldInterceptURI(uri, shouldUpgrade)) {
+                         channelChild->ShouldInterceptURI(uri, shouldUpgrade))) {
       // In the case where the redirect mode is manual, we need to check whether
       // the post-redirect channel needs to be intercepted.  If that is the
       // case, force the new channel to intercept the request in the parent
       // similar to the case above, but also remember that ShouldInterceptURI()
       // returned true to avoid calling it a second time.
       httpChannelChild->ForceIntercepted(true, shouldUpgrade);
     }
   }
@@ -1655,17 +1675,17 @@ HttpChannelChild::OnRedirectVerifyCallba
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::Cancel(nsresult status)
 {
-  LOG(("HttpChannelChild::Cancel [this=%p]\n", this));
+  LOG(("HttpChannelChild::Cancel [this=%p, status=%x, mCanceled=%d]\n", this, status, mCanceled));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!mCanceled) {
     // If this cancel occurs before nsHttpChannel has been set up, AsyncOpen
     // is responsible for cleaning up.
     mCanceled = true;
     mStatus = status;
     if (RemoteChannelExists())
@@ -1812,18 +1832,18 @@ HttpChannelChild::AsyncOpen(nsIStreamLis
   }
 
   // Set user agent override from docshell
   HttpBaseChannel::SetDocshellUserAgentOverride();
 
   MOZ_ASSERT_IF(mPostRedirectChannelShouldUpgrade,
                 mPostRedirectChannelShouldIntercept);
   bool shouldUpgrade = mPostRedirectChannelShouldUpgrade;
-  if (mPostRedirectChannelShouldIntercept ||
-      ShouldInterceptURI(mURI, shouldUpgrade)) {
+  if (false && (mPostRedirectChannelShouldIntercept ||
+                ShouldInterceptURI(mURI, shouldUpgrade))) {
     mResponseCouldBeSynthesized = true;
 
     nsCOMPtr<nsINetworkInterceptController> controller;
     GetCallback(controller);
 
     mInterceptListener = new InterceptStreamListener(this, mListenerContext);
 
     RefPtr<InterceptedChannelContent> intercepted =
@@ -1885,31 +1905,33 @@ HttpChannelChild::ContinueAsyncOpen()
   SerializeURI(mOriginalURI, openArgs.original());
   SerializeURI(mDocumentURI, openArgs.doc());
   SerializeURI(mReferrer, openArgs.referrer());
   openArgs.referrerPolicy() = mReferrerPolicy;
   SerializeURI(mAPIRedirectToURI, openArgs.apiRedirectTo());
   openArgs.loadFlags() = mLoadFlags;
   openArgs.requestHeaders() = mClientSetRequestHeaders;
   mRequestHead.Method(openArgs.requestMethod());
+  openArgs.redirectMode() = mRedirectMode;
 
   nsTArray<mozilla::ipc::FileDescriptor> fds;
   SerializeInputStream(mUploadStream, openArgs.uploadStream(), fds);
 
   if (mResponseHead) {
     openArgs.synthesizedResponseHead() = *mResponseHead;
     openArgs.suspendAfterSynthesizeResponse() =
       mSuspendParentAfterSynthesizeResponse;
   } else {
     openArgs.synthesizedResponseHead() = mozilla::void_t();
     openArgs.suspendAfterSynthesizeResponse() = false;
   }
 
   nsCOMPtr<nsISerializable> secInfoSer = do_QueryInterface(mSecurityInfo);
   if (secInfoSer) {
+    MOZ_ASSERT(false);
     NS_SerializeToString(secInfoSer, openArgs.synthesizedSecurityInfoSerialization());
   }
 
   OptionalFileDescriptorSet optionalFDs;
 
   if (fds.IsEmpty()) {
     optionalFDs = mozilla::void_t();
   } else if (fds.Length() <= kMaxFileDescriptorsPerMessage) {
@@ -2537,32 +2559,38 @@ HttpChannelChild::ResetInterception()
 {
   NS_ENSURE_TRUE_VOID(gNeckoChild != nullptr);
 
   if (mInterceptListener) {
     mInterceptListener->Cleanup();
   }
   mInterceptListener = nullptr;
 
+  printf("resetting interception for %s\n", mSpec.get());
+
   // The chance to intercept any further requests associated with this channel
   // (such as redirects) has passed.
-  mLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
+  //mLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
 
   // Continue with the original cross-process request
-  nsresult rv = ContinueAsyncOpen();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    AsyncAbort(rv);
+  //nsresult rv = ContinueAsyncOpen();
+  //if (NS_WARN_IF(NS_FAILED(rv))) {
+  //  AsyncAbort(rv);
+  //}
+  if (mIPCOpen) {
+    printf("actually resetting\n");
+    SendResetInterception();
   }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetResponseSynthesized(bool* aSynthesized)
 {
   NS_ENSURE_ARG_POINTER(aSynthesized);
-  *aSynthesized = mSynthesizedResponse;
+  *aSynthesized = mResponseIsSynthesized;
   return NS_OK;
 }
 
 void
 HttpChannelChild::OverrideWithSynthesizedResponse(nsAutoPtr<nsHttpResponseHead>& aResponseHead,
                                                   nsIInputStream* aSynthesizedInput,
                                                   InterceptStreamListener* aStreamListener)
 {
@@ -2652,20 +2680,48 @@ HttpChannelChild::RecvIssueDeprecationWa
   nsCOMPtr<nsIDeprecationWarner> warner;
   GetCallback(warner);
   if (warner) {
     warner->IssueWarning(warning, asError);
   }
   return true;
 }
 
+void
+HttpChannelChild::SynthesizeResponse(const nsHttpResponseHead& aSynthesizedResponseHead,
+                                     nsIInputStream* aSynthesizedBody,
+                                     const nsACString& aFinalURLSpec)
+{
+  nsTArray<mozilla::ipc::FileDescriptor> fds;
+  InputStreamParams synthesized;
+  SerializeInputStream(aSynthesizedBody, synthesized, fds);
+  MOZ_ASSERT(fds.Length() == 0);
+
+  nsCString serializedSecurityInfo;
+  nsCOMPtr<nsISerializable> secInfoSer = do_QueryInterface(mSecurityInfo);
+  if (secInfoSer) {
+    NS_SerializeToString(secInfoSer, serializedSecurityInfo);
+  }
+
+  mResponseIsSynthesized = true;
+
+  if (RemoteChannelExists())
+    SendSynthesizeResponse(aSynthesizedResponseHead,
+                           synthesized,
+                           serializedSecurityInfo,
+                           nsCString(aFinalURLSpec));
+}
+
 bool
 HttpChannelChild::ShouldInterceptURI(nsIURI* aURI,
                                      bool& aShouldUpgrade)
 {
+  aShouldUpgrade = false;
+  return false;
+
   bool isHttps = false;
   nsresult rv = aURI->SchemeIs("https", &isHttps);
   NS_ENSURE_SUCCESS(rv, false);
   nsCOMPtr<nsIPrincipal> resultPrincipal;
   if (!isHttps && mLoadInfo) {
       nsContentUtils::GetSecurityManager()->
         GetChannelResultPrincipal(this, getter_AddRefs(resultPrincipal));
   }
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -103,17 +103,22 @@ public:
   void AddIPDLReference();
   void ReleaseIPDLReference();
 
   bool IsSuspended();
 
   bool RecvNotifyTrackingProtectionDisabled() override;
   void FlushedForDiversion();
 
+  void SynthesizeResponse(const nsHttpResponseHead& aSynthesizedResponseHead,
+                          nsIInputStream* aSynthesizedBody,
+                          const nsACString& aFinalURLSpec);
+
 protected:
+  bool RecvDispatchFetchEvent() override;
   bool RecvOnStartRequest(const nsresult& channelStatus,
                           const nsHttpResponseHead& responseHead,
                           const bool& useResponseHead,
                           const nsHttpHeaderArray& requestHeaders,
                           const bool& isFromCache,
                           const bool& cacheEntryAvailable,
                           const uint32_t& cacheExpirationTime,
                           const nsCString& cachedCharset,
@@ -241,16 +246,18 @@ private:
   // Set if the corresponding parent channel should force an interception to occur
   // before the network transaction is initiated.
   bool mShouldParentIntercept;
 
   // Set if the corresponding parent channel should suspend after a response
   // is synthesized.
   bool mSuspendParentAfterSynthesizeResponse;
 
+  bool mResponseIsSynthesized;
+
   // true after successful AsyncOpen until OnStopRequest completes.
   bool RemoteChannelExists() { return mIPCOpen && !mKeptAlive; }
 
   void AssociateApplicationCache(const nsCString &groupID,
                                  const nsCString &clientID);
   void OnStartRequest(const nsresult& channelStatus,
                       const nsHttpResponseHead& responseHead,
                       const bool& useResponseHead,
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // HttpLog.h should generally be included first
 #include "HttpLog.h"
 
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/net/HttpChannelParent.h"
 #include "mozilla/dom/Element.h"
+#include "mozilla/dom/ServiceWorkerManagerParent.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/unused.h"
 #include "HttpChannelParentListener.h"
 #include "nsHttpHandler.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPriority.h"
 #include "nsIAuthPromptProvider.h"
@@ -38,16 +39,17 @@
 #include "nsIPrompt.h"
 #include "nsIWindowWatcher.h"
 #include "nsIDocument.h"
 #include "nsStringStream.h"
 #include "nsIExternalHelperAppService.h"
 
 using mozilla::BasePrincipal;
 using namespace mozilla::dom;
+using namespace mozilla::dom::workers;
 using namespace mozilla::ipc;
 
 namespace mozilla {
 namespace net {
 
 HttpChannelParent::HttpChannelParent(const PBrowserOrId& iframeEmbedding,
                                      nsILoadContext* aLoadContext,
                                      PBOverrideStatus aOverrideStatus)
@@ -103,17 +105,17 @@ HttpChannelParent::ActorDestroy(ActorDes
   // We may still have refcount>0 if nsHttpChannel hasn't called OnStopRequest
   // yet, but child process has crashed.  We must not try to send any more msgs
   // to child, or IPDL will kill chrome process, too.
   mIPCClosed = true;
 
   // If this is an intercepted channel, we need to make sure that any resources are
   // cleaned up to avoid leaks.
   if (mParentListener) {
-    mParentListener->ClearInterceptedChannel();
+    mParentListener->ClearInterceptedChannel(this);
   }
 }
 
 bool
 HttpChannelParent::Init(const HttpChannelCreationArgs& aArgs)
 {
   LOG(("HttpChannelParent::Init [this=%p]\n", this));
   switch (aArgs.type()) {
@@ -130,17 +132,17 @@ HttpChannelParent::Init(const HttpChanne
                        a.entityID(), a.chooseApplicationCache(),
                        a.appCacheClientID(), a.allowSpdy(), a.allowAltSvc(), a.fds(),
                        a.loadInfo(), a.synthesizedResponseHead(),
                        a.synthesizedSecurityInfoSerialization(),
                        a.cacheKey(), a.requestContextID(), a.preflightArgs(),
                        a.initialRwin(), a.blockAuthPrompt(),
                        a.suspendAfterSynthesizeResponse(),
                        a.allowStaleCacheContent(), a.contentTypeHint(),
-                       a.channelId());
+                       a.channelId(), a.redirectMode());
   }
   case HttpChannelCreationArgs::THttpChannelConnectArgs:
   {
     const HttpChannelConnectArgs& cArgs = aArgs.get_HttpChannelConnectArgs();
     return ConnectChannel(cArgs.registrarId(), cArgs.shouldIntercept());
   }
   default:
     NS_NOTREACHED("unknown open type");
@@ -262,17 +264,18 @@ HttpChannelParent::DoAsyncOpen(  const U
                                  const uint32_t&            aCacheKey,
                                  const nsCString&           aRequestContextID,
                                  const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                  const uint32_t&            aInitialRwin,
                                  const bool&                aBlockAuthPrompt,
                                  const bool&                aSuspendAfterSynthesizeResponse,
                                  const bool&                aAllowStaleCacheContent,
                                  const nsCString&           aContentTypeHint,
-                                 const nsCString&           aChannelId)
+                                 const nsCString&           aChannelId,
+                                 const uint32_t&            aRedirectMode)
 {
   nsCOMPtr<nsIURI> uri = DeserializeURI(aURI);
   if (!uri) {
     // URIParams does MOZ_ASSERT if null, but we need to protect opt builds from
     // null deref here.
     return false;
   }
   nsCOMPtr<nsIURI> originalUri = DeserializeURI(aOriginalURI);
@@ -384,32 +387,35 @@ HttpChannelParent::DoAsyncOpen(  const U
   }
 
   nsCOMPtr<nsIInputStream> stream = DeserializeInputStream(uploadStream, fds);
   if (stream) {
     mChannel->InternalSetUploadStream(stream);
     mChannel->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
+  MOZ_ASSERT(aSecurityInfoSerialization.IsEmpty());
+
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
+    MOZ_ASSERT(false);
     mParentListener->SetupInterception(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mWillSynthesizeResponse = true;
     mChannel->SetCouldBeSynthesized();
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
       mChannel->OverrideSecurityInfo(secInfo);
     }
-  } else {
+  } /*else {
     nsLoadFlags newLoadFlags;
     mChannel->GetLoadFlags(&newLoadFlags);
     newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
     mChannel->SetLoadFlags(newLoadFlags);
-  }
+    }*/
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   rv = cacheKey->SetData(aCacheKey);
@@ -432,16 +438,17 @@ HttpChannelParent::DoAsyncOpen(  const U
   mChannel->SetRedirectionLimit(redirectionLimit);
   mChannel->SetAllowPipelining(allowPipelining);
   mChannel->SetAllowSTS(allowSTS);
   mChannel->SetThirdPartyFlags(thirdPartyFlags);
   mChannel->SetAllowSpdy(allowSpdy);
   mChannel->SetAllowAltSvc(allowAltSvc);
   mChannel->SetInitialRwin(aInitialRwin);
   mChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  mChannel->SetRedirectMode(aRedirectMode);
 
   nsCOMPtr<nsIApplicationCacheChannel> appCacheChan =
     do_QueryObject(mChannel);
   nsCOMPtr<nsIApplicationCacheService> appCacheService =
     do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
 
   bool setChooseApplicationCache = chooseApplicationCache;
   if (appCacheChan && appCacheService) {
@@ -655,17 +662,23 @@ HttpChannelParent::RecvRedirect2Verify(c
                                            changedHeaders[i].mValue,
                                            changedHeaders[i].mMerge);
         }
       }
 
       // A successfully redirected channel must have the LOAD_REPLACE flag.
       MOZ_ASSERT(loadFlags & nsIChannel::LOAD_REPLACE);
       if (loadFlags & nsIChannel::LOAD_REPLACE) {
-        newHttpChannel->SetLoadFlags(loadFlags);
+        nsLoadFlags newLoadFlags = loadFlags;
+        nsLoadFlags oldLoadFlags;
+        newHttpChannel->GetLoadFlags(&oldLoadFlags);
+        if (oldLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER) {
+          newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+        }
+        newHttpChannel->SetLoadFlags(newLoadFlags);
       }
 
       if (aCorsPreflightArgs.type() == OptionalCorsPreflightArgs::TCorsPreflightArgs) {
         nsCOMPtr<nsIHttpChannelInternal> newInternalChannel =
           do_QueryInterface(newHttpChannel);
         MOZ_RELEASE_ASSERT(newInternalChannel);
         const CorsPreflightArgs& args = aCorsPreflightArgs.get_CorsPreflightArgs();
         newInternalChannel->SetCorsPreflightParameters(args.unsafeHeaders());
@@ -963,16 +976,20 @@ HttpChannelParent::ResponseSynthesized()
   // the synthesis, but not actually allow the nsHttpChannel to trigger
   // any OnStartRequests().
   if (mSuspendAfterSynthesizeResponse) {
     mChannel->Suspend();
   }
 
   mWillSynthesizeResponse = false;
 
+  /*bool synthesized = false;
+  mChannel->GetResponseSynthesized(&synthesized);
+  MOZ_ASSERT(synthesized);*/
+
   MaybeFlushPendingDiversion();
 }
 
 bool
 HttpChannelParent::RecvRemoveCorsPreflightCacheEntry(const URIParams& uri,
   const mozilla::ipc::PrincipalInfo& requestingPrincipal)
 {
   nsCOMPtr<nsIURI> deserializedURI = DeserializeURI(uri);
@@ -984,16 +1001,33 @@ HttpChannelParent::RecvRemoveCorsPreflig
   if (!principal) {
     return false;
   }
   nsCORSListenerProxy::RemoveFromCorsPreflightCache(deserializedURI,
                                                     principal);
   return true;
 }
 
+bool
+HttpChannelParent::RecvSynthesizeResponse(const nsHttpResponseHead& aHead,
+                                          const InputStreamParams& aBody,
+                                          const nsCString& aSerializedSecurityInfo,
+                                          const nsCString& aFinalURLSpec)
+{
+  mParentListener->SynthesizeResponse(aHead, aBody, aSerializedSecurityInfo, aFinalURLSpec);
+  return true;
+}
+
+bool
+HttpChannelParent::RecvResetInterception()
+{
+  mParentListener->ResetInterception();
+  return true;
+}
+
 //-----------------------------------------------------------------------------
 // HttpChannelParent::nsIRequestObserver
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::OnStartRequest(nsIRequest *aRequest, nsISupports *aContext)
 {
   LOG(("HttpChannelParent::OnStartRequest [this=%p, aRequest=%p]\n",
@@ -1708,10 +1742,17 @@ HttpChannelParent::ReportSecurityMessage
 
 NS_IMETHODIMP
 HttpChannelParent::IssueWarning(uint32_t aWarning, bool aAsError)
 {
   Unused << SendIssueDeprecationWarning(aWarning, aAsError);
   return NS_OK;
 }
 
+already_AddRefed<nsIChannel>
+HttpChannelParent::GetActiveChannel()
+{
+  nsCOMPtr<nsIChannel> active = mRedirectChannel ? mRedirectChannel.get() : mChannel.get();
+  return active.forget();
+}
+
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -93,16 +93,18 @@ public:
 
   // Forwarded to nsHttpChannel::SetApplyConversion.
   void SetApplyConversion(bool aApplyConversion) {
     if (mChannel) {
       mChannel->SetApplyConversion(aApplyConversion);
     }
   }
 
+  void FinishSynthesizeResponse();
+
 protected:
   // used to connect redirected-to channel in parent with just created
   // ChildChannel.  Used during redirects.
   bool ConnectChannel(const uint32_t& channelId, const bool& shouldIntercept);
 
   bool DoAsyncOpen(const URIParams&           uri,
                    const OptionalURIParams&   originalUri,
                    const OptionalURIParams&   docUri,
@@ -135,17 +137,18 @@ protected:
                    const uint32_t&            aCacheKey,
                    const nsCString&           aRequestContextID,
                    const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                    const uint32_t&            aInitialRwin,
                    const bool&                aBlockAuthPrompt,
                    const bool&                aSuspendAfterSynthesizeResponse,
                    const bool&                aAllowStaleCacheContent,
                    const nsCString&           aContentTypeHint,
-                   const nsCString&           aChannelId);
+                   const nsCString&           aChannelId,
+                   const uint32_t&            aRedirectMode);
 
   virtual bool RecvSetPriority(const uint16_t& priority) override;
   virtual bool RecvSetClassOfService(const uint32_t& cos) override;
   virtual bool RecvSetCacheTokenCachedCharset(const nsCString& charset) override;
   virtual bool RecvSuspend() override;
   virtual bool RecvResume() override;
   virtual bool RecvCancel(const nsresult& status) override;
   virtual bool RecvRedirect2Verify(const nsresult& result,
@@ -159,16 +162,21 @@ protected:
   virtual bool RecvMarkOfflineCacheEntryAsForeign() override;
   virtual bool RecvDivertOnDataAvailable(const nsCString& data,
                                          const uint64_t& offset,
                                          const uint32_t& count) override;
   virtual bool RecvDivertOnStopRequest(const nsresult& statusCode) override;
   virtual bool RecvDivertComplete() override;
   virtual bool RecvRemoveCorsPreflightCacheEntry(const URIParams& uri,
                                                  const mozilla::ipc::PrincipalInfo& requestingPrincipal) override;
+  virtual bool RecvSynthesizeResponse(const nsHttpResponseHead& aHead,
+                                      const InputStreamParams& aBody,
+                                      const nsCString& aSerializedSecurityInfo,
+                                      const nsCString& aFinalURLSpec) override;
+  virtual bool RecvResetInterception() override;
   virtual void ActorDestroy(ActorDestroyReason why) override;
 
   // Supporting function for ADivertableParentChannel.
   nsresult ResumeForDiversion();
 
   // Asynchronously calls NotifyDiversionFailed.
   void FailDiversion(nsresult aErrorCode, bool aSkipResume = true);
 
@@ -176,16 +184,18 @@ protected:
   RefPtr<mozilla::dom::TabParent> mTabParent;
 
   void OfflineDisconnect() override;
   uint32_t GetAppId() override;
 
   nsresult ReportSecurityMessage(const nsAString& aMessageTag,
                                  const nsAString& aMessageCategory) override;
 
+  already_AddRefed<nsIChannel> GetActiveChannel();
+
   // Calls SendDeleteSelf and sets mIPCClosed to true because we should not
   // send any more messages after that. Bug 1274886
   bool DoSendDeleteSelf();
 
 private:
   void UpdateAndSerializeSecurityInfo(nsACString& aSerializedSecurityInfoOut);
 
   void DivertOnDataAvailable(const nsCString& data,
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -246,17 +246,70 @@ HttpChannelParentListener::OnRedirectRes
 // HttpChannelParentListener::nsINetworkInterceptController
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParentListener::ShouldPrepareForIntercept(nsIURI* aURI,
                                                      bool aIsNonSubresourceRequest,
                                                      bool* aShouldIntercept)
 {
-  *aShouldIntercept = mShouldIntercept;
+  *aShouldIntercept = false;
+
+  nsAutoCString spec;
+  aURI->GetSpec(spec);
+
+  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+  if (mRedirectChannelId) {
+    nsresult rv = NS_OK;
+    nsCOMPtr<nsIRedirectChannelRegistrar> registrar =
+        do_GetService("@mozilla.org/redirectchannelregistrar;1", &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIParentChannel> redirectChannel;
+    rv = registrar->GetParentChannel(mRedirectChannelId,
+                                     getter_AddRefs(redirectChannel));
+    printf("finding actually channel parent: pre(%p) ", channel.get());
+    channel = do_QueryObject(redirectChannel);
+    printf("post(%p)\n", channel.get());
+  } else {
+    printf("not finding another parent: %p\n", channel.get());
+  }
+  /*nsCOMPtr<nsIChannel> channel = channelParent ? channelParent->GetActiveChannel() : nullptr;
+  nsCOMPtr<nsILoadContext> loadContext;
+  NS_QueryNotificationCallbacks(channel, loadContext);*/
+
+  if (aIsNonSubresourceRequest) {
+    printf("parent: non subresource request for %s\n", spec.get());
+
+    /*DocShellOriginAttributes docShellAttrs;
+    if (channel && channel->mLoadContext) {
+      printf("loadcontext: %p\n", channel->mLoadContext);
+      bool result = channel->mLoadContext->GetOriginAttributes(docShellAttrs);
+      if (NS_WARN_IF(!result)) {
+        return NS_ERROR_FAILURE;
+      }
+    } else {
+      printf("channel: %p\n", channel);
+    }
+
+    NeckoOriginAttributes neckoAttrs;
+    neckoAttrs.InheritFromDocShellToNecko(docShellAttrs);
+    PrincipalOriginAttributes attrs;
+    attrs.InheritFromNecko(neckoAttrs);*/
+
+    nsCOMPtr<nsIPrincipal> resultPrincipal;// = channel->mChannel->GetURIPrincipal();
+    nsContentUtils::GetSecurityManager()->
+        GetChannelResultPrincipal(channel->mChannel, getter_AddRefs(resultPrincipal));
+    *aShouldIntercept = ServiceWorkerRegistrarParent::Get()->IsAvailable(resultPrincipal, aURI);
+  } else {
+    printf("parent: subresource request for %s\n", spec.get());
+
+    *aShouldIntercept = channel && channel->mTabParent && channel->mTabParent->DocumentIsControlled();
+  }
+  printf("parent decision: %s\n", *aShouldIntercept ? "true" : "false");
   return NS_OK;
 }
 
 class HeaderVisitor final : public nsIHttpHeaderVisitor
 {
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   ~HeaderVisitor()
   {
@@ -275,57 +328,168 @@ public:
   }
 };
 
 NS_IMPL_ISUPPORTS(HeaderVisitor, nsIHttpHeaderVisitor)
 
 class FinishSynthesizedResponse : public Runnable
 {
   nsCOMPtr<nsIInterceptedChannel> mChannel;
+  nsCString mFinalURLSpec;
 public:
-  explicit FinishSynthesizedResponse(nsIInterceptedChannel* aChannel)
+  explicit FinishSynthesizedResponse(nsIInterceptedChannel* aChannel,
+                                     const nsACString& aFinalURLSpec)
   : mChannel(aChannel)
+  , mFinalURLSpec(aFinalURLSpec)
   {
   }
 
   NS_IMETHOD Run() override
   {
     // The URL passed as an argument here doesn't matter, since the child will
     // receive a redirection notification as a result of this synthesized response.
-    mChannel->FinishSynthesizedResponse(EmptyCString());
+    mChannel->FinishSynthesizedResponse(mFinalURLSpec);
     return NS_OK;
   }
 };
 
 NS_IMETHODIMP
 HttpChannelParentListener::ChannelIntercepted(nsIInterceptedChannel* aChannel)
 {
-  if (mShouldSuspendIntercept) {
-    mInterceptedChannel = aChannel;
+  mInterceptedChannel = aChannel;
+  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+  Unused << channel->SendDispatchFetchEvent();
+  return NS_OK;
+}
+
+void
+HttpChannelParentListener::ResetInterception()
+{
+  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+  MOZ_ASSERT(channel);
+  nsAutoCString spec;
+  channel->mChannel->GetName(spec);
+  printf("resetting for %s\n", spec.get());
+
+  //XXXjdm unsure why we receive a ReseTInterception message after ActorDestroy...
+  if (mInterceptedChannel) {
+    printf("actually resetting\n");
+    mInterceptedChannel->ResetInterception();
+    mInterceptedChannel = nullptr;
+  }
+}
+
+class FinishSynthesizeOnMainThread : public Runnable
+{
+  HttpChannelParentListener* mChannel;
+  nsCString mFinalURLSpec;
+  nsCString mSecurityInfoSerialization;
+public:
+  FinishSynthesizeOnMainThread(HttpChannelParentListener* aChannel,
+                               const nsACString& aFinalURLSpec,
+                               const nsACString& aSecurityInfoSerialization)
+  : mChannel(aChannel)
+  , mFinalURLSpec(aFinalURLSpec)
+  , mSecurityInfoSerialization(aSecurityInfoSerialization)
+  {
+  }
+
+  NS_IMETHOD Run()
+  {
+    mChannel->FinishSynthesizeResponse(mFinalURLSpec, mSecurityInfoSerialization);
     return NS_OK;
   }
+};
 
+struct CopyCompleteClosure {
+  nsCString mFinalURLSpec;
+  nsCString mSecurityInfoSerialization;
+  HttpChannelParentListener* mChannel;
+};
+
+void SynthesizedBodyCopyComplete(void* aClosure, nsresult aStatus)
+{
+  MOZ_ASSERT(NS_SUCCEEDED(aStatus));
+  nsAutoPtr<CopyCompleteClosure> closure(static_cast<CopyCompleteClosure*>(aClosure));
+  RefPtr<FinishSynthesizeOnMainThread> event =
+      new FinishSynthesizeOnMainThread(closure->mChannel,
+                                       closure->mFinalURLSpec,
+                                       closure->mSecurityInfoSerialization);
+  NS_DispatchToMainThread(event);
+}
+
+void
+HttpChannelParentListener::SynthesizeResponse(const nsHttpResponseHead& aHead,
+                                              const InputStreamParams& aBody,
+                                              const nsCString& aSerializedSecurityInfo,
+                                              const nsCString& aFinalURLSpec)
+{
+  /*if (mShouldSuspendIntercept) {
+    mInterceptedChannel = aChannel;
+    return;
+    }*/
+
+  MOZ_ASSERT(mInterceptedChannel);
+  if (!mInterceptedChannel) {
+    return;
+  }
+
+  mSynthesizedResponseHead = new nsHttpResponseHead(aHead);
+  nsTArray<mozilla::ipc::FileDescriptor> fds;
+  mSynthesizedBody = DeserializeInputStream(aBody, fds);
+  MOZ_ASSERT(fds.Length() == 0);
+
+  nsresult rv;
+  nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  if (NS_WARN_IF(!stsThread)) {
+    return;
+  }
+
+  nsCOMPtr<nsIOutputStream> body;
+  mInterceptedChannel->GetResponseBody(getter_AddRefs(body));
+
+  nsAutoPtr<CopyCompleteClosure> closure(new CopyCompleteClosure {
+      aFinalURLSpec, aSerializedSecurityInfo, this
+          });
+
+  rv = NS_AsyncCopy(mSynthesizedBody, body, stsThread, NS_ASYNCCOPY_VIA_READSEGMENTS, 4096,
+                    SynthesizedBodyCopyComplete, closure.forget());
+  NS_ENSURE_SUCCESS_VOID(rv);
+}
+
+void
+HttpChannelParentListener::FinishSynthesizeResponse(const nsACString& aFinalURLSpec,
+                                                    const nsACString& aSecurityInfoSerialization)
+{
   nsAutoCString statusText;
   mSynthesizedResponseHead->StatusText(statusText);
-  aChannel->SynthesizeStatus(mSynthesizedResponseHead->Status(), statusText);
-  nsCOMPtr<nsIHttpHeaderVisitor> visitor = new HeaderVisitor(aChannel);
-  mSynthesizedResponseHead->VisitHeaders(visitor,
-                                         nsHttpHeaderArray::eFilterResponse);
+  mInterceptedChannel->SynthesizeStatus(mSynthesizedResponseHead->Status(), statusText);
+  nsCOMPtr<nsIHttpHeaderVisitor> visitor = new HeaderVisitor(mInterceptedChannel);
+  mSynthesizedResponseHead->VisitHeaders(visitor, nsHttpHeaderArray::eFilterResponseOriginal);
 
-  nsCOMPtr<nsIRunnable> event = new FinishSynthesizedResponse(aChannel);
+  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+  MOZ_ASSERT(channel);
+
+  if (!aSecurityInfoSerialization.IsEmpty()) {
+    nsCOMPtr<nsISupports> secInfo;
+    NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
+    channel->mChannel->OverrideSecurityInfo(secInfo);
+  }
+
+  nsCOMPtr<nsIRunnable> event = new FinishSynthesizedResponse(mInterceptedChannel,
+                                                              aFinalURLSpec);
   NS_DispatchToCurrentThread(event);
 
   mSynthesizedResponseHead = nullptr;
+  mInterceptedChannel = nullptr;
 
   MOZ_ASSERT(mNextListener);
-  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
-  MOZ_ASSERT(channel);
+  //RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+  //MOZ_ASSERT(channel);
   channel->ResponseSynthesized();
-
-  return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 
 nsresult
 HttpChannelParentListener::SuspendForDiversion()
 {
   if (NS_WARN_IF(mSuspendedForDiversion)) {
@@ -376,18 +540,20 @@ HttpChannelParentListener::SetupIntercep
   if (mShouldIntercept) {
     // When an interception occurs, this channel should suspend all further activity.
     // It will be torn down and recreated if necessary.
     mShouldSuspendIntercept = true;
   }
 }
 
 void
-HttpChannelParentListener::ClearInterceptedChannel()
+HttpChannelParentListener::ClearInterceptedChannel(HttpChannelParent* caller)
 {
-  if (mInterceptedChannel) {
+  RefPtr<HttpChannelParent> channel = do_QueryObject(mNextListener);
+
+  if (mInterceptedChannel && channel == caller) {
     mInterceptedChannel->Cancel(NS_ERROR_INTERCEPTION_FAILED);
     mInterceptedChannel = nullptr;
   }
 }
 
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/HttpChannelParentListener.h b/netwerk/protocol/http/HttpChannelParentListener.h
--- a/netwerk/protocol/http/HttpChannelParentListener.h
+++ b/netwerk/protocol/http/HttpChannelParentListener.h
@@ -47,17 +47,25 @@ public:
   explicit HttpChannelParentListener(HttpChannelParent* aInitialChannel);
 
   // For channel diversion from child to parent.
   nsresult DivertTo(nsIStreamListener *aListener);
   nsresult SuspendForDiversion();
 
   void SetupInterception(const nsHttpResponseHead& aResponseHead);
   void SetupInterceptionAfterRedirect(bool aShouldIntercept);
-  void ClearInterceptedChannel();
+  void ClearInterceptedChannel(HttpChannelParent* caller);
+
+  void SynthesizeResponse(const nsHttpResponseHead& aHead,
+                          const InputStreamParams& aBody,
+                          const nsCString& aSerializedSecurityInfo,
+                          const nsCString& aFinalURLSpec);
+  void ResetInterception();
+  void FinishSynthesizeResponse(const nsACString& aFinalURLSpec,
+                                const nsACString& aSecurityInfoSerialization);
 
 private:
   virtual ~HttpChannelParentListener();
 
   // Private partner function to SuspendForDiversion.
   nsresult ResumeForDiversion();
 
   // Can be the original HttpChannelParent that created this object (normal
@@ -70,16 +78,17 @@ private:
   bool mSuspendedForDiversion;
 
   // Set if this channel should be intercepted before it sets up the HTTP transaction.
   bool mShouldIntercept;
   // Set if this channel should suspend on interception.
   bool mShouldSuspendIntercept;
 
   nsAutoPtr<nsHttpResponseHead> mSynthesizedResponseHead;
+  nsCOMPtr<nsIInputStream> mSynthesizedBody;
 
   // Handle to the channel wrapper if this channel has been intercepted.
   nsCOMPtr<nsIInterceptedChannel> mInterceptedChannel;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(HttpChannelParentListener,
                               HTTP_CHANNEL_PARENT_LISTENER_IID)
 
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -190,16 +190,18 @@ InterceptedChannelChrome::ResetIntercept
   mSynthesizedCacheEntry->AsyncDoom(nullptr);
   mSynthesizedCacheEntry = nullptr;
 
   mChannel->SetApplyConversion(mOldApplyConversion);
 
   nsCOMPtr<nsIURI> uri;
   mChannel->GetURI(getter_AddRefs(uri));
 
+  printf("redirecting reset channel\n");
+
   nsresult rv = mChannel->StartRedirectChannelToURI(uri, nsIChannelEventSink::REDIRECT_INTERNAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mResponseBody->Close();
   mResponseBody = nullptr;
 
   mReleaseHandle = nullptr;
   mChannel = nullptr;
@@ -361,19 +363,26 @@ InterceptedChannelContent::InterceptedCh
 , mStreamListener(aListener)
 , mSecureUpgrade(aSecureUpgrade)
 {
 }
 
 void
 InterceptedChannelContent::NotifyController()
 {
-  nsresult rv = NS_NewPipe(getter_AddRefs(mSynthesizedInput),
+  /*nsresult rv = NS_NewPipe(getter_AddRefs(mSynthesizedInput),
                            getter_AddRefs(mResponseBody),
-                           0, UINT32_MAX, true, true);
+                           0, UINT32_MAX, true, true);*/
+  nsresult rv = NS_NewStorageStream(4096, UINT32_MAX, getter_AddRefs(mStorageStream));
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  rv = mStorageStream->GetOutputStream(0, getter_AddRefs(mResponseBody));
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  rv = mStorageStream->NewInputStream(0, getter_AddRefs(mSynthesizedInput));
   NS_ENSURE_SUCCESS_VOID(rv);
 
   DoNotifyController();
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::GetChannel(nsIChannel** aChannel)
 {
@@ -388,16 +397,17 @@ InterceptedChannelContent::ResetIntercep
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   mResponseBody->Close();
   mResponseBody = nullptr;
   mSynthesizedInput = nullptr;
+  mStorageStream = nullptr;
 
   mChannel->ResetInterception();
   mReleaseHandle = nullptr;
   mChannel = nullptr;
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -431,46 +441,55 @@ InterceptedChannelContent::FinishSynthes
   // intercepted with a null-body response then its possible the synthesis
   // completed without a stream copy operation.
   mResponseBody->Close();
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   EnsureSynthesizedResponse();
 
-  nsCOMPtr<nsIURI> originalURI;
+  /*nsCOMPtr<nsIURI> originalURI;
   mChannel->GetURI(getter_AddRefs(originalURI));
 
   nsCOMPtr<nsIURI> responseURI;
   if (!aFinalURLSpec.IsEmpty()) {
     nsresult rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
     NS_ENSURE_SUCCESS(rv, rv);
   } else if (mSecureUpgrade) {
     nsresult rv = NS_GetSecureUpgradedURI(originalURI,
                                           getter_AddRefs(responseURI));
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     responseURI = originalURI;
-  }
+    }*/
 
-  bool equal = false;
+  /*bool equal = false;
   originalURI->Equals(responseURI, &equal);
   if (!equal) {
     mChannel->ForceIntercepted(mSynthesizedInput);
     mChannel->BeginNonIPCRedirect(responseURI, *mSynthesizedResponseHead.ptr());
   } else {
     mChannel->OverrideWithSynthesizedResponse(mSynthesizedResponseHead.ref(),
                                               mSynthesizedInput,
                                               mStreamListener);
+                                              }*/
+
+  if (!WillRedirect(mSynthesizedResponseHead.ref())) {
+    mChannel->SetApplyConversion(false);
   }
+ 
+  mChannel->SynthesizeResponse(*mSynthesizedResponseHead.ref(),
+                               mSynthesizedInput,
+                               aFinalURLSpec);
 
   mResponseBody = nullptr;
   mReleaseHandle = nullptr;
   mChannel = nullptr;
   mStreamListener = nullptr;
+  mStorageStream = nullptr;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::Cancel(nsresult aStatus)
 {
   MOZ_ASSERT(NS_FAILED(aStatus));
 
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -9,16 +9,17 @@
 
 #include "nsINetworkInterceptController.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/Maybe.h"
 
 class nsICacheEntry;
 class nsInputStreamPump;
 class nsIStreamListener;
+class nsIStorageStream;
 
 namespace mozilla {
 namespace net {
 
 class nsHttpChannel;
 class HttpChannelChild;
 class nsHttpResponseHead;
 class InterceptStreamListener;
@@ -96,16 +97,18 @@ public:
 class InterceptedChannelContent : public InterceptedChannelBase
 {
   // The actual channel being intercepted.
   RefPtr<HttpChannelChild> mChannel;
 
   // Reader-side of the response body when synthesizing in a child proces
   nsCOMPtr<nsIInputStream> mSynthesizedInput;
 
+  nsCOMPtr<nsIStorageStream> mStorageStream;
+
   // Listener for the synthesized response to fix up the notifications before they reach
   // the actual channel.
   RefPtr<InterceptStreamListener> mStreamListener;
 
   // Set for intercepted channels that have gone through a secure upgrade.
   bool mSecureUpgrade;
 public:
   InterceptedChannelContent(HttpChannelChild* aChannel,
diff --git a/netwerk/protocol/http/PHttpChannel.ipdl b/netwerk/protocol/http/PHttpChannel.ipdl
--- a/netwerk/protocol/http/PHttpChannel.ipdl
+++ b/netwerk/protocol/http/PHttpChannel.ipdl
@@ -79,19 +79,27 @@ parent:
   // Child has no more events/messages to divert to the parent.
   async DivertComplete();
 
   // Child has detected a CORS check failure, so needs to tell the parent
   // to remove any matching entry from the CORS preflight cache.
   async RemoveCorsPreflightCacheEntry(URIParams uri,
                                       PrincipalInfo requestingPrincipal);
 
+  async SynthesizeResponse(nsHttpResponseHead head,
+                           InputStreamParams body,
+                           nsCString securityInfoSerialization,
+                           nsCString finalURLSpec);
+  async ResetInterception();
+
   async __delete__();
 
 child:
+  async DispatchFetchEvent();
+
   async OnStartRequest(nsresult            channelStatus,
                        nsHttpResponseHead  responseHead,
                        bool                useResponseHead,
                        nsHttpHeaderArray   requestHeaders,
                        bool                isFromCache,
                        bool                cacheEntryAvailable,
                        uint32_t            cacheExpirationTime,
                        nsCString           cachedCharset,
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -2332,16 +2332,25 @@ nsHttpChannel::StartRedirectChannelToURI
         mInterceptCache == INTERCEPTED) {
         // Mark the channel as intercepted in order to propagate the response URL.
         nsCOMPtr<nsIHttpChannelInternal> httpRedirect = do_QueryInterface(mRedirectChannel);
         if (httpRedirect) {
             httpRedirect->ForceIntercepted(mInterceptionID);
         }
     }
 
+    /*if (mInterceptCache == INTERCEPTED &&
+        !(flags & (nsIChannelEventSink::REDIRECT_INTERNAL |
+                   nsIChannelEventSink::REDIRECT_STS_UPGRADE))) {
+        if (mRedirectMode == nsIHttpChannelInternal::REDIRECT_MODE_FOLLOW &&
+            !nsContentUtils::IsNonSubresourceRequest(this)) {
+            MarkIntercepted();
+        }
+        }*/
+
     PushRedirectAsyncFunc(
         &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
 
     if (NS_SUCCEEDED(rv))
         rv = WaitForRedirectCallback();
 
     if (NS_FAILED(rv)) {
@@ -3136,16 +3145,23 @@ nsHttpChannel::ProcessFallback(bool *wai
         do_QueryInterface(newChannel, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = httpInternal->SetupFallbackChannel(mFallbackKey.get());
     NS_ENSURE_SUCCESS(rv, rv);
 
     // ... and fallbacks should only load from the cache.
     uint32_t newLoadFlags = mLoadFlags | LOAD_REPLACE | LOAD_ONLY_FROM_CACHE;
+
+    uint32_t replacementLoadFlags;
+    newChannel->GetLoadFlags(&replacementLoadFlags);
+    if (replacementLoadFlags & LOAD_BYPASS_SERVICE_WORKER) {
+        newLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
+    }
+    
     rv = newChannel->SetLoadFlags(newLoadFlags);
 
     // Inform consumers about this fake redirect
     mRedirectChannel = newChannel;
 
     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
 
@@ -3210,16 +3226,32 @@ IsSubRangeRequest(nsHttpRequestHead &aRe
 {
     nsAutoCString byteRange;
     if (NS_FAILED(aRequestHead.GetHeader(nsHttp::Range, byteRange))) {
         return false;
     }
     return !byteRange.EqualsLiteral("bytes=0-");
 }
 
+class AsyncNotifyController : public Runnable
+{
+    RefPtr<InterceptedChannelChrome> mIntercepted;
+public:
+    explicit AsyncNotifyController(InterceptedChannelChrome* aIntercepted)
+    : mIntercepted(aIntercepted)
+    {
+    }
+
+    NS_IMETHODIMP Run()
+    {
+        mIntercepted->NotifyController();
+        return NS_OK;
+    }
+};
+
 nsresult
 nsHttpChannel::OpenCacheEntry(bool isHttps)
 {
     // Handle correctly mCacheEntriesToWaitFor
     AutoCacheWaitFlags waitFlags(this);
 
     // Drop this flag here
     mConcurrentCacheAccess = 0;
@@ -3382,17 +3414,18 @@ nsHttpChannel::OpenCacheEntry(bool isHtt
         rv = cacheStorage->OpenTruncate(openURI, extension, getter_AddRefs(entry));
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsINetworkInterceptController> controller;
         GetCallback(controller);
 
         RefPtr<InterceptedChannelChrome> intercepted =
                 new InterceptedChannelChrome(this, controller, entry);
-        intercepted->NotifyController();
+        RefPtr<AsyncNotifyController> event = new AsyncNotifyController(intercepted);
+        NS_DispatchToMainThread(event);
     } else {
         if (mInterceptCache == INTERCEPTED) {
             cacheEntryOpenFlags |= nsICacheStorage::OPEN_INTERCEPTED;
             // Clear OPEN_TRUNCATE for the fake cache entry, since otherwise
             // cache storage will close the current entry which breaks the
             // response synthesis.
             cacheEntryOpenFlags &= ~nsICacheStorage::OPEN_TRUNCATE;
             DebugOnly<bool> exists;
@@ -3845,16 +3878,17 @@ nsHttpChannel::OnCacheEntryCheck(nsICach
 
         // Append cacheKey if not in the chain already
         if (!doValidation)
             mRedirectedCachekeys->AppendElement(cacheKey);
     }
 
     if (doValidation && mInterceptCache == INTERCEPTED) {
         doValidation = false;
+        LOG(("Ignoring validation request for intercepted channel"));
     }
 
     mCachedContentIsValid = !doValidation;
 
     if (doValidation) {
         //
         // now, we are definitely going to issue a HTTP request to the server.
         // make it conditional if possible.
@@ -4319,16 +4353,19 @@ nsHttpChannel::OpenCacheInputStream(nsIC
     NS_ENSURE_SUCCESS(rv,rv);
 
     if (isHttps) {
         rv = cacheEntry->GetSecurityInfo(
                                       getter_AddRefs(mCachedSecurityInfo));
         if (NS_FAILED(rv)) {
             LOG(("failed to parse security-info [channel=%p, entry=%p]",
                  this, cacheEntry));
+            nsAutoCString spec;
+            mURI->GetSpec(spec);
+            printf("warning for %s:\n", spec.get());
             NS_WARNING("failed to parse security-info");
             cacheEntry->AsyncDoom(nullptr);
             return rv;
         }
 
         // XXX: We should not be skilling this check in the offline cache
         // case, but we have to do so now to work around bug 794507.
         bool mustHaveSecurityInfo = !mLoadedFromApplicationCache && !checkingAppCacheEntry;
@@ -4728,18 +4765,20 @@ DoAddCacheEntryHeaders(nsHttpChannel *se
                        nsHttpRequestHead *requestHead,
                        nsHttpResponseHead *responseHead,
                        nsISupports *securityInfo)
 {
     nsresult rv;
 
     LOG(("nsHttpChannel::AddCacheEntryHeaders [this=%p] begin", self));
     // Store secure data in memory only
-    if (securityInfo)
-        entry->SetSecurityInfo(securityInfo);
+    if (securityInfo) {
+        LOG(("setting cache entry security info"));
+        NS_WARN_IF(NS_FAILED(entry->SetSecurityInfo(securityInfo)));
+    }
 
     // Store the HTTP request method with the cache entry so we can distinguish
     // for example GET and HEAD responses.
     nsAutoCString method;
     requestHead->Method(method);
     rv = entry->SetMetaDataElement("request-method", method.get());
     if (NS_FAILED(rv)) return rv;
 
@@ -5074,16 +5113,22 @@ nsHttpChannel::SetupReplacementChannel(n
         // separate requests to the nsINetworkInterceptController.
         if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL ||
             (redirectFlags & (nsIChannelEventSink::REDIRECT_TEMPORARY |
                               nsIChannelEventSink::REDIRECT_PERMANENT)) == 0) {
             nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
             rv = newChannel->GetLoadFlags(&loadFlags);
             NS_ENSURE_SUCCESS(rv, rv);
             loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+            nsCOMPtr<nsISupports> raw = do_QueryInterface(newChannel);
+            nsCOMPtr<nsIURI> url;
+            newChannel->GetURI(getter_AddRefs(url));
+            nsAutoCString spec;
+            url->GetSpec(spec);
+            printf("marking SW bypass for %p (%s)\n", raw.get(), spec.get());
             rv = newChannel->SetLoadFlags(loadFlags);
             NS_ENSURE_SUCCESS(rv, rv);
         }
     }
 
     return NS_OK;
 }
 
@@ -5485,16 +5530,18 @@ nsHttpChannel::AsyncOpen(nsIStreamListen
     }
 
     rv = NS_CheckPortSafety(mURI);
     if (NS_FAILED(rv)) {
         ReleaseListeners();
         return rv;
     }
 
+    nsCOMPtr<nsISupports> raw = do_QueryInterface((nsIStreamListener*)this);
+    printf("shouldintercept for %p, %s\n", raw.get(), mLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER ? "true" : "false");
     if (mInterceptCache != INTERCEPTED && ShouldIntercept()) {
         mInterceptCache = MAYBE_INTERCEPT;
         SetCouldBeSynthesized();
     }
 
     // Remember the cookie header that was set, if any
     nsAutoCString cookieHeader;
     if (NS_SUCCEEDED(mRequestHead.GetHeader(nsHttp::Cookie, cookieHeader))) {
@@ -7541,17 +7588,20 @@ nsHttpChannel::SetNotificationCallbacks(
         UpdateAggregateCallbacks();
     }
     return rv;
 }
 
 void
 nsHttpChannel::MarkIntercepted()
 {
-    mInterceptCache = INTERCEPTED;
+    nsAutoCString spec;
+    mURI->GetSpec(spec);
+    printf("marking intercepted for %p (%s)\n", this, spec.get());
+   mInterceptCache = INTERCEPTED;
 }
 
 NS_IMETHODIMP
 nsHttpChannel::GetResponseSynthesized(bool* aSynthesized)
 {
     NS_ENSURE_ARG_POINTER(aSynthesized);
     *aSynthesized = (mInterceptCache == INTERCEPTED);
     return NS_OK;
