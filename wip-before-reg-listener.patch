# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8cccf8d5757f1cad6d711f3ac2a4b2daf36c26b9

diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -74,17 +74,16 @@
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerInfo.h"
 #include "ServiceWorkerJobQueue.h"
 #include "ServiceWorkerManagerChild.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerRegisterJob.h"
 #include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
-#include "ServiceWorkerRegistrationListener.h"
 #include "ServiceWorkerScriptCache.h"
 #include "ServiceWorkerEvents.h"
 #include "ServiceWorkerUnregisterJob.h"
 #include "ServiceWorkerUpdateJob.h"
 #include "ServiceWorkerUpdaterChild.h"
 #include "ServiceWorkerUtils.h"
 
 #ifdef PostMessage
@@ -1894,17 +1893,17 @@ ServiceWorkerManager::RemoveScopeAndRegi
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> info;
   data->mInfos.Remove(aRegistration->Scope(), getter_AddRefs(info));
   data->mOrderedScopes.RemoveElement(aRegistration->Scope());
   swm->NotifyListenersOnUnregister(info);
 
   swm->MaybeRemoveRegistrationInfo(scopeKey);
-  swm->NotifyServiceWorkerRegistrationRemoved(aRegistration);
+  aRegistration->NotifyRemoved();
 }
 
 void
 ServiceWorkerManager::MaybeRemoveRegistrationInfo(const nsACString& aScopeKey)
 {
   if (auto entry = mRegistrationInfos.Lookup(aScopeKey)) {
     if (entry.Data()->mOrderedScopes.IsEmpty() &&
         entry.Data()->mJobQueues.Count() == 0) {
@@ -1994,74 +1993,16 @@ ServiceWorkerManager::GetScopeForUrl(nsI
   if (!r) {
       return NS_ERROR_FAILURE;
   }
 
   aScope = NS_ConvertUTF8toUTF16(r->Scope());
   return NS_OK;
 }
 
-NS_IMETHODIMP
-ServiceWorkerManager::AddRegistrationEventListener(const nsAString& aScope,
-                                                   ServiceWorkerRegistrationListener* aListener)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aListener);
-#ifdef DEBUG
-  // Ensure a registration is only listening for it's own scope.
-  nsAutoString regScope;
-  aListener->GetScope(regScope);
-  MOZ_ASSERT(!regScope.IsEmpty());
-  MOZ_ASSERT(aScope.Equals(regScope));
-#endif
-
-  MOZ_ASSERT(!mServiceWorkerRegistrationListeners.Contains(aListener));
-  mServiceWorkerRegistrationListeners.AppendElement(aListener);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerManager::RemoveRegistrationEventListener(const nsAString& aScope,
-                                                      ServiceWorkerRegistrationListener* aListener)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aListener);
-#ifdef DEBUG
-  // Ensure a registration is unregistering for it's own scope.
-  nsAutoString regScope;
-  aListener->GetScope(regScope);
-  MOZ_ASSERT(!regScope.IsEmpty());
-  MOZ_ASSERT(aScope.Equals(regScope));
-#endif
-
-  MOZ_ASSERT(mServiceWorkerRegistrationListeners.Contains(aListener));
-  mServiceWorkerRegistrationListeners.RemoveElement(aListener);
-  return NS_OK;
-}
-
-void
-ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations(
-  ServiceWorkerRegistrationInfo* aRegistration)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-
-  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
-  while (it.HasMore()) {
-    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
-    nsAutoString regScope;
-    target->GetScope(regScope);
-    MOZ_ASSERT(!regScope.IsEmpty());
-
-    NS_ConvertUTF16toUTF8 utf8Scope(regScope);
-    if (utf8Scope.Equals(aRegistration->Scope())) {
-      target->UpdateFound();
-    }
-  }
-}
-
 namespace {
 
 class ContinueDispatchFetchEventRunnable : public Runnable
 {
   RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
   nsCOMPtr<nsIInterceptedChannel> mChannel;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
   bool mIsReload;
@@ -2354,48 +2295,16 @@ ServiceWorkerManager::GetClientRegistrat
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> ref = data->mRegistrationInfo;
   ref.forget(aRegistrationInfo);
   return NS_OK;
 }
 
 void
-ServiceWorkerManager::UpdateRegistrationListeners(ServiceWorkerRegistrationInfo* aReg)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
-  while (it.HasMore()) {
-    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
-    if (target->MatchesDescriptor(aReg->Descriptor())) {
-      target->UpdateState(aReg->Descriptor());
-    }
-  }
-}
-
-void
-ServiceWorkerManager::NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration)
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
-  while (it.HasMore()) {
-    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
-    nsAutoString regScope;
-    target->GetScope(regScope);
-    MOZ_ASSERT(!regScope.IsEmpty());
-
-    NS_ConvertUTF16toUTF8 utf8Scope(regScope);
-
-    if (utf8Scope.Equals(aRegistration->Scope())) {
-      target->RegistrationRemoved();
-    }
-  }
-}
-
-void
 ServiceWorkerManager::SoftUpdate(const OriginAttributes& aOriginAttributes,
                                  const nsACString& aScope)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mShuttingDown) {
     return;
   }
diff --git a/dom/serviceworkers/ServiceWorkerManager.h b/dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h
+++ b/dom/serviceworkers/ServiceWorkerManager.h
@@ -27,17 +27,16 @@
 #include "mozilla/dom/ServiceWorkerRegistrarTypes.h"
 #include "mozilla/dom/ServiceWorkerRegistrationInfo.h"
 #include "mozilla/dom/ServiceWorkerUtils.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsTArrayForwardDeclare.h"
-#include "nsTObserverArray.h"
 
 class nsIConsoleReportCollector;
 
 namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
@@ -46,17 +45,16 @@ class PrincipalInfo;
 
 namespace dom {
 
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 class ServiceWorkerRegistrar;
-class ServiceWorkerRegistrationListener;
 
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
   virtual ~ServiceWorkerUpdateFinishCallback()
   {}
 
 public:
@@ -97,18 +95,16 @@ class ServiceWorkerManager final
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERMANAGER
   NS_DECL_NSIOBSERVER
 
   struct RegistrationDataPerPrincipal;
   nsClassHashtable<nsCStringHashKey, RegistrationDataPerPrincipal> mRegistrationInfos;
 
-  nsTObserverArray<ServiceWorkerRegistrationListener*> mServiceWorkerRegistrationListeners;
-
   struct ControlledClientData
   {
     RefPtr<ClientHandle> mClientHandle;
     RefPtr<ServiceWorkerRegistrationInfo> mRegistrationInfo;
 
     ControlledClientData(ClientHandle* aClientHandle,
                          ServiceWorkerRegistrationInfo* aRegistrationInfo)
       : mClientHandle(aClientHandle)
@@ -306,24 +302,16 @@ public:
   LoadRegistrations(const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   // Used by remove() and removeAll() when clearing history.
   // MUST ONLY BE CALLED FROM UnregisterIfMatchesHost!
   void
   ForceUnregister(RegistrationDataPerPrincipal* aRegistrationData,
                   ServiceWorkerRegistrationInfo* aRegistration);
 
-  NS_IMETHOD
-  AddRegistrationEventListener(const nsAString& aScope,
-                               ServiceWorkerRegistrationListener* aListener);
-
-  NS_IMETHOD
-  RemoveRegistrationEventListener(const nsAString& aScope,
-                                  ServiceWorkerRegistrationListener* aListener);
-
   void
   MaybeCheckNavigationUpdate(const ClientInfo& aClientInfo);
 
   nsresult
   SendPushEvent(const nsACString& aOriginAttributes,
                 const nsACString& aScope,
                 const nsAString& aMessageId,
                 const Maybe<nsTArray<uint8_t>>& aData);
@@ -389,22 +377,16 @@ private:
   ServiceWorkerInfo*
   GetActiveWorkerInfoForScope(const OriginAttributes& aOriginAttributes,
                               const nsACString& aScope);
 
   ServiceWorkerInfo*
   GetActiveWorkerInfoForDocument(nsIDocument* aDocument);
 
   void
-  UpdateRegistrationListeners(ServiceWorkerRegistrationInfo* aReg);
-
-  void
-  NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
-
-  void
   StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow) const;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc) const;
 
@@ -443,19 +425,16 @@ private:
   static void
   RemoveScopeAndRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   QueueFireEventOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration,
                                              const nsAString& aName);
 
   void
-  FireUpdateFoundOnServiceWorkerRegistrations(ServiceWorkerRegistrationInfo* aRegistration);
-
-  void
   UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   MaybeRemoveRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   // Removes all service worker registrations that matches the given pattern.
   void
   RemoveAllRegistrations(OriginAttributesPattern* aPattern);
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -56,35 +56,41 @@ ServiceWorkerRegistrationMainThread::~Se
 
 // XXXnsm, maybe this can be optimized to only add when a event handler is
 // registered.
 void
 ServiceWorkerRegistrationMainThread::StartListeningForEvents()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mListeningForEvents);
+  MOZ_DIAGNOSTIC_ASSERT(!mInfo);
+
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (swm) {
-    swm->AddRegistrationEventListener(mScope, this);
-    mListeningForEvents = true;
-  }
+  NS_ENSURE_TRUE_VOID(swm);
+
+  mInfo = swm->GetRegistration(mDescriptor.PrincipalInfo(),
+                               mDescriptor.Scope());
+  NS_ENSURE_TRUE_VOID(mInfo);
+
+  mInfo->AddInstance(this);
+  mListeningForEvents = true;
 }
 
 void
 ServiceWorkerRegistrationMainThread::StopListeningForEvents()
 {
   MOZ_ASSERT(NS_IsMainThread());
   if (!mListeningForEvents) {
     return;
   }
 
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (swm) {
-    swm->RemoveRegistrationEventListener(mScope, this);
-  }
+  MOZ_DIAGNOSTIC_ASSERT(mInfo);
+  mInfo->RemoveInstance(this);
+  mInfo = nullptr;
+
   mListeningForEvents = false;
 }
 
 void
 ServiceWorkerRegistrationMainThread::RegistrationRemovedInternal()
 {
   MOZ_ASSERT(NS_IsMainThread());
   // Its possible for the binding object to be collected while we the
@@ -622,87 +628,90 @@ ServiceWorkerRegistrationMainThread::Unr
     })->Track(*holder);
 }
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
-  const nsString mScope;
+  ServiceWorkerRegistrationDescriptor mDescriptor;
+  RefPtr<ServiceWorkerRegistrationInfo> mInfo;
   bool mListeningForEvents;
 
   // Set and unset on worker thread, used on main-thread and protected by mutex.
   ServiceWorkerRegistrationWorkerThread* mRegistration;
 
   Mutex mMutex;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(WorkerListener, override)
 
   WorkerListener(ServiceWorkerRegistrationWorkerThread* aReg,
-                 const nsAString& aScope)
-    : mScope(aScope)
+                 const ServiceWorkerRegistrationDescriptor& aDescriptor)
+    : mDescriptor(aDescriptor)
     , mListeningForEvents(false)
     , mRegistration(aReg)
     , mMutex("WorkerListener::mMutex")
   {
     MOZ_ASSERT(IsCurrentThreadRunningWorker());
     MOZ_ASSERT(mRegistration);
   }
 
   void
   StartListeningForEvents()
   {
     MOZ_ASSERT(NS_IsMainThread());
-    MOZ_ASSERT(!mListeningForEvents);
+    MOZ_DIAGNOSTIC_ASSERT(!mListeningForEvents);
+    MOZ_DIAGNOSTIC_ASSERT(!mInfo);
+
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-    if (swm) {
-      // FIXME(nsm): Maybe the function shouldn't take an explicit scope.
-      swm->AddRegistrationEventListener(mScope, this);
-      mListeningForEvents = true;
-    }
+    NS_ENSURE_TRUE_VOID(swm);
+
+    mInfo = swm->GetRegistration(mDescriptor.PrincipalInfo(),
+                                 mDescriptor.Scope());
+    NS_ENSURE_TRUE_VOID(mInfo);
+
+    mInfo->AddInstance(this);
+    mListeningForEvents = true;
   }
 
   void
   StopListeningForEvents()
   {
     MOZ_ASSERT(NS_IsMainThread());
 
     if (!mListeningForEvents) {
       return;
     }
 
-    RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-
-    if (swm) {
-      // FIXME(nsm): Maybe the function shouldn't take an explicit scope.
-      swm->RemoveRegistrationEventListener(mScope, this);
-      mListeningForEvents = false;
-    }
+    MOZ_DIAGNOSTIC_ASSERT(mInfo);
+    mInfo->RemoveInstance(this);
+    mListeningForEvents = false;
   }
 
   // ServiceWorkerRegistrationListener
   void
   UpdateFound() override;
 
   void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) override
   {
     MOZ_ASSERT(NS_IsMainThread());
+    mDescriptor = aDescriptor;
     // TODO: Not implemented
   }
 
   void
   RegistrationRemoved() override;
 
   void
   GetScope(nsAString& aScope) const override
   {
-    aScope = mScope;
+    CopyUTF8toUTF16(mDescriptor.Scope(), aScope);
   }
 
   bool
   MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) override
   {
     // TODO: Not implemented
     return false;
   }
@@ -898,17 +907,17 @@ ServiceWorkerRegistrationWorkerThread::I
     // late.
     self->mOuter = nullptr;
   });
 
   if (NS_WARN_IF(!mWorkerRef)) {
     return;
   }
 
-  mListener = new WorkerListener(this, mScope);
+  mListener = new WorkerListener(this, mDescriptor);
 
   nsCOMPtr<nsIRunnable> r =
     NewRunnableMethod("dom::WorkerListener::StartListeningForEvents",
                       mListener,
                       &WorkerListener::StartListeningForEvents);
   MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(r.forget()));
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
@@ -78,16 +78,17 @@ private:
   void
   StopListeningForEvents();
 
   void
   RegistrationRemovedInternal();
 
   ServiceWorkerRegistration* mOuter;
   ServiceWorkerRegistrationDescriptor mDescriptor;
+  RefPtr<ServiceWorkerRegistrationInfo> mInfo;
   const nsString mScope;
   bool mListeningForEvents;
 };
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener;
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerRegistrationInfo.h"
 
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
+#include "ServiceWorkerRegistrationListener.h"
 
 namespace mozilla {
 namespace dom {
 
 namespace {
 
 class ContinueActivateRunnable final : public LifeCycleEventCallback
 {
@@ -109,16 +110,32 @@ ServiceWorkerRegistrationInfo::ServiceWo
   , mCorrupt(false)
 {}
 
 ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
 {
   MOZ_DIAGNOSTIC_ASSERT(!IsControllingClients());
 }
 
+void
+ServiceWorkerRegistrationInfo::AddInstance(ServiceWorkerRegistrationListener* aInstance)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aInstance);
+  MOZ_ASSERT(!mInstanceList.Contains(aInstance));
+  mInstanceList.AppendElement(aInstance);
+}
+
+void
+ServiceWorkerRegistrationInfo::RemoveInstance(ServiceWorkerRegistrationListener* aInstance)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aInstance);
+  DebugOnly<bool> removed = mInstanceList.RemoveElement(aInstance);
+  MOZ_ASSERT(removed);
+}
+
 const nsCString&
 ServiceWorkerRegistrationInfo::Scope() const
 {
   return mDescriptor.Scope();
 }
 
 nsIPrincipal*
 ServiceWorkerRegistrationInfo::Principal() const
@@ -425,20 +442,21 @@ ServiceWorkerRegistrationInfo::UpdateReg
   mDescriptor.SetVersion(GetNextVersion());
 
   // Note, this also sets the new version number on the ServiceWorkerInfo
   // objects before we copy over their updated descriptors.
   mDescriptor.SetWorkers(mInstallingWorker, mWaitingWorker, mActiveWorker);
 
   mDescriptor.SetUpdateViaCache(aUpdateViaCache);
 
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  NS_ENSURE_TRUE_VOID(swm);
-
-  swm->UpdateRegistrationListeners(this);
+  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
+  while (it.HasMore()) {
+    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
+    target->UpdateState(mDescriptor);
+  }
 }
 
 void
 ServiceWorkerRegistrationInfo::NotifyChromeRegistrationListeners()
 {
   nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> listeners(mListeners);
   for (size_t index = 0; index < listeners.Length(); ++index) {
     listeners[index]->OnChange();
@@ -752,16 +770,36 @@ ServiceWorkerRegistrationInfo::GetUpdate
 
   if (!mControlledClientsCounter && mDelayMultiplier < (INT_MAX / 30)) {
     mDelayMultiplier = (mDelayMultiplier ? mDelayMultiplier : 1) * 30;
   }
 
   return delay;
 }
 
+void
+ServiceWorkerRegistrationInfo::FireUpdateFound()
+{
+  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
+  while (it.HasMore()) {
+    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
+    target->UpdateFound();
+  }
+}
+
+void
+ServiceWorkerRegistrationInfo::NotifyRemoved()
+{
+  nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
+  while (it.HasMore()) {
+    RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
+    target->RegistrationRemoved();
+  }
+}
+
 // static
 uint64_t
 ServiceWorkerRegistrationInfo::GetNextId()
 {
   MOZ_ASSERT(NS_IsMainThread());
   static uint64_t sNextId = 0;
   return ++sNextId;
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
@@ -6,26 +6,30 @@
 
 #ifndef mozilla_dom_serviceworkerregistrationinfo_h
 #define mozilla_dom_serviceworkerregistrationinfo_h
 
 #include "mozilla/dom/ServiceWorkerInfo.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationDescriptor.h"
 #include "nsProxyRelease.h"
+#include "nsTObserverArray.h"
 
 namespace mozilla {
 namespace dom {
 
+class ServiceWorkerRegistrationListener;
+
 class ServiceWorkerRegistrationInfo final
   : public nsIServiceWorkerRegistrationInfo
 {
   nsCOMPtr<nsIPrincipal> mPrincipal;
   ServiceWorkerRegistrationDescriptor mDescriptor;
   nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
+  nsTObserverArray<ServiceWorkerRegistrationListener*> mInstanceList;
 
   uint32_t mControlledClientsCounter;
   uint32_t mDelayMultiplier;
 
   enum
   {
     NoUpdate,
     NeedTimeCheckAndUpdate,
@@ -55,16 +59,22 @@ class ServiceWorkerRegistrationInfo fina
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
 
   ServiceWorkerRegistrationInfo(const nsACString& aScope,
                                 nsIPrincipal* aPrincipal,
                                 ServiceWorkerUpdateViaCache aUpdateViaCache);
 
+  void
+  AddInstance(ServiceWorkerRegistrationListener* aInstance);
+
+  void
+  RemoveInstance(ServiceWorkerRegistrationListener* aInstance);
+
   const nsCString&
   Scope() const;
 
   nsIPrincipal*
   Principal() const;
 
   bool
   IsPendingUninstall() const;
@@ -225,16 +235,22 @@ public:
   Id() const;
 
   uint64_t
   Version() const;
 
   uint32_t
   GetUpdateDelay();
 
+  void
+  FireUpdateFound();
+
+  void
+  NotifyRemoved();
+
 private:
   // Roughly equivalent to [[Update Registration State algorithm]]. Make sure
   // this is called *before* updating SW instances' state, otherwise they
   // may get CC-ed.
   void
   UpdateRegistrationState();
 
   void
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -516,48 +516,44 @@ ServiceWorkerUpdateJob::ContinueUpdateAf
 
     NS_ConvertUTF8toUTF16 scriptSpec(mScriptSpec);
     NS_ConvertUTF8toUTF16 scope(mRegistration->Scope());
     error.ThrowTypeError<MSG_SW_SCRIPT_THREW>(scriptSpec, scope);
     FailUpdateJob(error);
     return;
   }
 
-  Install(swm);
+  Install();
 }
 
 void
-ServiceWorkerUpdateJob::Install(ServiceWorkerManager* aSWM)
+ServiceWorkerUpdateJob::Install()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(!Canceled());
-  MOZ_DIAGNOSTIC_ASSERT(aSWM);
 
   MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin step 2 of the Install algorithm.
   //
   //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
 
   mRegistration->TransitionEvaluatingToInstalling();
 
   // Step 6 of the Install algorithm resolving the job promise.
   InvokeResultCallbacks(NS_OK);
 
   // The job promise cannot be rejected after this point, but the job can
   // still fail; e.g. if the install event handler throws, etc.
 
   // fire the updatefound event
-  nsCOMPtr<nsIRunnable> upr =
-    NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      "dom::ServiceWorkerManager::"
-      "FireUpdateFoundOnServiceWorkerRegistrations",
-      aSWM,
-      &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
-      mRegistration);
+  nsCOMPtr<nsIRunnable> upr = NewRunnableMethod(
+      "ServiceWorkerRegistrationInfo::FireUpdateFound",
+      mRegistration,
+      &ServiceWorkerRegistrationInfo::FireUpdateFound);
   NS_DispatchToMainThread(upr);
 
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
     new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(
       "ServiceWorkerUpdateJob", this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
 
   // Send the install event to the worker thread
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.h b/dom/serviceworkers/ServiceWorkerUpdateJob.h
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.h
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.h
@@ -94,17 +94,17 @@ private:
                    nsLoadFlags aLoadFlags);
 
   // Utility method called after evaluating the worker script.
   void
   ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult);
 
   // Utility method corresponding to the spec Install algorithm.
   void
-  Install(ServiceWorkerManager* aSWM);
+  Install();
 
   // Utility method called after the install event is handled.
   void
   ContinueAfterInstallEvent(bool aInstallEventSuccess);
 
   RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
   ServiceWorkerUpdateViaCache mUpdateViaCache;
