# HG changeset patch
# Parent 0b9c507b5858267fefdb29b959cfa259fa80c502
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/AutoRestore.h"
 #include "mozilla/DebugOnly.h"
+#include "mozilla/TimeStamp.h"
 #include "mozilla/dom/cache/Action.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/OfflineStorage.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsIFile.h"
 #include "nsIPrincipal.h"
@@ -395,16 +396,17 @@ public:
                  const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
+    , mStart(TimeStamp::Now())
     , mExecutingRunOnTarget(false)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     MOZ_ASSERT(mQuotaInfo.mDir);
     MOZ_ASSERT(mInitiatingThread);
   }
@@ -493,16 +495,17 @@ private:
 
   nsRefPtr<Context> mContext;
   nsCOMPtr<nsIEventTarget> mTarget;
   nsRefPtr<Action> mAction;
   const QuotaInfo mQuotaInfo;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   nsresult mResult;
+  const TimeStamp mStart;
 
   // Only accessible on target thread;
   bool mExecutingRunOnTarget;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
@@ -540,23 +543,27 @@ NS_IMPL_ISUPPORTS(mozilla::dom::cache::C
 //
 // Its important to note that synchronous actions will effectively Resolve()
 // out of the Running state immediately.  Asynchronous Actions may remain
 // in the Running state for some time, but normally the ActionRunnable itself
 // does not see any execution there.  Its all handled internal to the Action.
 NS_IMETHODIMP
 Context::ActionRunnable::Run()
 {
+  TimeDuration delta = TimeStamp::Now() - mStart;
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       MOZ_ASSERT(!mExecutingRunOnTarget);
 
+      printf_stderr("### ### [%p] ActionRunnable took %0.3g ms to start\n",
+                    this, delta.ToMilliseconds());
+
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
       mState = STATE_RUNNING;
       mAction->RunOnTarget(this, mQuotaInfo);
 
@@ -584,16 +591,18 @@ Context::ActionRunnable::Run()
       MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+      printf_stderr("### ### [%p] ActionRunnable took %0.3g ms to complete\n",
+                    this, delta.ToMilliseconds());
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
     // -----------------
