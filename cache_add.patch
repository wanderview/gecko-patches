# HG changeset patch
# Parent 25519f7f4fb91b26498a53548f3d681b4138a60d
# User Ben Kelly <ben@wanderview.com>
Implement Cache Add()/AddAll().

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -16,22 +16,67 @@
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/unused.h"
 #include "nsIGlobalObject.h"
 #include "nsNetUtil.h"
 
+namespace {
+
+using mozilla::ErrorResult;
+using mozilla::dom::MSG_INVALID_REQUEST_METHOD;
+using mozilla::dom::OwningRequestOrScalarValueString;
+using mozilla::dom::Request;
+using mozilla::dom::RequestOrScalarValueString;
+
+static bool
+IsValidPutRequestMethod(const Request& aRequest, ErrorResult& aRv)
+{
+  nsAutoCString method;
+  aRequest.GetMethod(method);
+  bool valid = method.LowerCaseEqualsLiteral("get");
+  if (!valid) {
+    NS_ConvertUTF8toUTF16 label(method);
+    aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
+  }
+  return valid;
+}
+
+static bool
+IsValidPutRequestMethod(const RequestOrScalarValueString& aRequest,
+                        ErrorResult& aRv)
+{
+  if (!aRequest.IsRequest()) {
+    return true;
+  }
+  return IsValidPutRequestMethod(aRequest.GetAsRequest(), aRv);
+}
+
+static bool
+IsValidPutRequestMethod(const OwningRequestOrScalarValueString& aRequest,
+                        ErrorResult& aRv)
+{
+  if (!aRequest.IsRequest()) {
+    return true;
+  }
+  return IsValidPutRequestMethod(*aRequest.GetAsRequest().get(), aRv);
+}
+
+} // anonymous namespace
+
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::ErrorResult;
 using mozilla::unused;
+using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+using mozilla::dom::workers::WorkerPrivate;
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::Cache);
 NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::Cache);
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mOwner, mGlobal)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Cache)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
@@ -53,17 +98,17 @@ Cache::Match(const RequestOrScalarValueS
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  ToPCacheRequest(request, aRequest, false, aRv);
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
   ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
@@ -80,17 +125,18 @@ Cache::MatchAll(const Optional<RequestOr
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequestOrVoid request;
-  ToPCacheRequestOrVoid(request, aRequest, false, aRv);
+  ToPCacheRequestOrVoid(request, aRequest, IgnoreBody, PassThroughReferrer,
+                        aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
   ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
@@ -100,143 +146,141 @@ Cache::MatchAll(const Optional<RequestOr
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::Add(const RequestOrScalarValueString& aRequest, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
-  if (aRequest.IsRequest()) {
-    nsAutoCString method;
-    aRequest.GetAsRequest().GetMethod(method);
-    if (!method.LowerCaseEqualsLiteral("get")) {
-      NS_ConvertUTF8toUTF16 label(method);
-      aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
-      return nullptr;
-    }
+  if (!IsValidPutRequestMethod(aRequest, aRv)) {
+    return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
-  PCacheRequest request;
-  ToPCacheRequest(request, aRequest, true, aRv);
-  if (aRv.Failed()) {
+
+  nsTArray<PCacheRequest> requests(1);
+  PCacheRequest* request = requests.AppendElement();
+  ToPCacheRequest(*request, aRequest, ReadBody, ExpandReferrer, aRv);
+  if (!aRv.Failed()) {
     return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
-  unused << mActor->SendAdd(requestId, request);
+  unused << mActor->SendAddAll(requestId, requests);
 
-  CleanupChildFds(request.body());
+  CleanupChildFds(request->body());
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(const Sequence<OwningRequestOrScalarValueString>& aRequests,
               ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  // Be careful not to early exist after this point to avoid leaking
+  // file descriptor resources from stream serialization.
+
   nsTArray<PCacheRequest> requests;
   for(uint32_t i = 0; i < aRequests.Length(); ++i) {
-    if (aRequests[i].IsRequest()) {
-      nsAutoCString method;
-      aRequests[i].GetAsRequest().get()->GetMethod(method);
-      if (!method.LowerCaseEqualsLiteral("get")) {
-        NS_ConvertUTF8toUTF16 label(method);
-        aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
-        return nullptr;
-      }
+    if (!IsValidPutRequestMethod(aRequests[i], aRv)) {
+      break;
     }
 
     PCacheRequest* request = requests.AppendElement();
-    ToPCacheRequest(*request, aRequests[i], true, aRv);
+    ToPCacheRequest(*request, aRequests[i], ReadBody, ExpandReferrer, aRv);
     if (aRv.Failed()) {
-      return nullptr;
+      break;
     }
   }
 
-  RequestId requestId = AddRequestPromise(promise, aRv);
+  if (!aRv.Failed()) {
+    RequestId requestId = AddRequestPromise(promise, aRv);
 
-  unused << mActor->SendAddAll(requestId, requests);
+    unused << mActor->SendAddAll(requestId, requests);
+  }
 
   for (uint32_t i = 0; i < requests.Length(); ++i) {
     CleanupChildFds(requests[i].body());
   }
 
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::Put(const RequestOrScalarValueString& aRequest, Response& aResponse,
            ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
-  if (aRequest.IsRequest()) {
-    nsAutoCString method;
-    aRequest.GetAsRequest().GetMethod(method);
-    if (!method.LowerCaseEqualsLiteral("get")) {
-      NS_ConvertUTF8toUTF16 label(method);
-      aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
-      return nullptr;
-    }
+  if (!IsValidPutRequestMethod(aRequest, aRv)) {
+    return nullptr;
   }
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
-  PCacheRequest request;
-  ToPCacheRequest(request, aRequest, true, aRv);
+  CacheRequestResponse put;
+
+  // Be careful not to early exist after this point to avoid leaking
+  // file descriptor resources from stream serialization.
+
+  ToPCacheRequest(put.request(), aRequest, ReadBody, PassThroughReferrer, aRv);
+
+  if (!aRv.Failed()) {
+    ToPCacheResponse(put.response(), aResponse, aRv);
+  }
+
+  if (!aRv.Failed()) {
+    RequestId requestId = AddRequestPromise(promise, aRv);
+
+    unused << mActor->SendPut(requestId, put);
+  }
+
+  CleanupChildFds(put.request().body());
+  CleanupChildFds(put.response().body());
+
   if (aRv.Failed()) {
     return nullptr;
   }
 
-  PCacheResponse response;
-  ToPCacheResponse(response, aResponse, aRv);
-  if (aRv.Failed()) {
-    return nullptr;
-  }
-
-  RequestId requestId = AddRequestPromise(promise, aRv);
-
-  unused << mActor->SendPut(requestId, request, response);
-
-  CleanupChildFds(request.body());
-  CleanupChildFds(response.body());
-
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::Delete(const RequestOrScalarValueString& aRequest,
               const QueryParams& aParams, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  ToPCacheRequest(request, aRequest, false, aRv);
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
   ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
@@ -253,17 +297,18 @@ Cache::Keys(const Optional<RequestOrScal
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequestOrVoid request;
-  ToPCacheRequestOrVoid(request, aRequest, false, aRv);
+  ToPCacheRequestOrVoid(request, aRequest, IgnoreBody, PassThroughReferrer,
+                        aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   PCacheQueryParams params;
   ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
@@ -363,32 +408,16 @@ Cache::RecvMatchAllResponse(RequestId aR
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     nsRefPtr<Response> response = ToResponse(aResponses[i]);
     responses.AppendElement(response.forget());
   }
   promise->MaybeResolve(responses);
 }
 
 void
-Cache::RecvAddResponse(RequestId aRequestId, nsresult aRv)
-{
-  nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
-  if (NS_WARN_IF(!promise)) {
-    return;
-  }
-
-  if (NS_FAILED(aRv)) {
-    promise->MaybeReject(aRv);
-    return;
-  }
-
-  promise->MaybeResolve(JS::UndefinedHandleValue);
-}
-
-void
 Cache::RecvAddAllResponse(RequestId aRequestId, nsresult aRv)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -77,31 +77,31 @@ public:
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                     const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                        const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
   virtual void
-  RecvAddResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
-  virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
 
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess) MOZ_OVERRIDE;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                    const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
 
   // TypeUtils methods
-  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+  virtual nsIGlobalObject*
+  GetGlobalObject() const MOZ_OVERRIDE;
+
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
 private:
   virtual ~Cache();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -60,24 +60,16 @@ CacheChild::RecvMatchAllResponse(const R
                                  const nsTArray<PCacheResponse>& responses)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvMatchAllResponse(requestId, aRv, responses);
   return true;
 }
 
 bool
-CacheChild::RecvAddResponse(const RequestId& requestId, const nsresult& aRv)
-{
-  MOZ_ASSERT(mListener);
-  mListener->RecvAddResponse(requestId, aRv);
-  return true;
-}
-
-bool
 CacheChild::RecvAddAllResponse(const RequestId& requestId, const nsresult& aRv)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvAddAllResponse(requestId, aRv);
   return true;
 }
 
 bool
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -31,19 +31,16 @@ public:
   // PCacheChild methods
   virtual bool
   RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
                     const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
                        const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
   virtual bool
-  RecvAddResponse(const RequestId& requestId, const nsresult& aRv) MOZ_OVERRIDE;
-
-  virtual bool
   RecvAddAllResponse(const RequestId& requestId,
                      const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvPutResponse(const RequestId& aRequestId,
                   const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -32,19 +32,16 @@ public:
 
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                     const PCacheResponseOrVoid& aResponse)=0;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                        const nsTArray<PCacheResponse>& aResponses)=0;
   virtual void
-  RecvAddResponse(RequestId aRequestId, nsresult aRv)=0;
-
-  virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv)=0;
 
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv)=0;
 
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess)=0;
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -33,22 +33,27 @@ CacheParent::CacheParent(const CacheInit
 {
   MOZ_ASSERT(mManager);
   mManager->AddRefCacheId(mCacheId);
 }
 
 CacheParent::~CacheParent()
 {
   MOZ_ASSERT(!mManager);
+  MOZ_ASSERT(mFetchPutList.IsEmpty());
 }
 
 void
 CacheParent::ActorDestroy(ActorDestroyReason aReason)
 {
   MOZ_ASSERT(mManager);
+  for (uint32_t i = 0; i < mFetchPutList.Length(); ++i) {
+    mFetchPutList[i]->ClearListener();
+  }
+  mFetchPutList.Clear();
   mManager->RemoveListener(this);
   mManager->ReleaseCacheId(mCacheId);
   mManager = nullptr;
 }
 
 bool
 CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams)
@@ -65,45 +70,59 @@ CacheParent::RecvMatchAll(const RequestI
                           const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
   mManager->CacheMatchAll(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 bool
-CacheParent::RecvAdd(const RequestId& aRequestId, const PCacheRequest& aRequest)
+CacheParent::RecvAddAll(const RequestId& aRequestId,
+                        const nsTArray<PCacheRequest>& aRequests)
 {
-  unused << SendAddResponse(aRequestId, NS_ERROR_NOT_IMPLEMENTED);
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreams;
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    requestStreams.AppendElement(DeserializeCacheStream(aRequests[i].body()));
+  }
+
+  nsRefPtr<FetchPut> fetchPut;
+  nsresult rv = FetchPut::Create(this, mManager, aRequestId, mCacheId,
+                                 aRequests, requestStreams,
+                                 getter_AddRefs(fetchPut));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << SendAddAllResponse(aRequestId, rv);
+    return true;
+  }
+
+  mFetchPutList.AppendElement(fetchPut.forget());
+
   return true;
 }
 
 bool
-CacheParent::RecvAddAll(const RequestId& aRequestId,
-                        const nsTArray<PCacheRequest>& aRequests)
-{
-  nsTArray<PCacheResponse> responses;
-  unused << SendAddAllResponse(aRequestId, NS_ERROR_NOT_IMPLEMENTED);
-  return true;
-}
-
-bool
-CacheParent::RecvPut(const RequestId& aRequestId, const PCacheRequest& aRequest,
-                     const PCacheResponse& aResponse)
+CacheParent::RecvPut(const RequestId& aRequestId,
+                     const CacheRequestResponse& aPut)
 {
   MOZ_ASSERT(mManager);
 
-  nsCOMPtr<nsIInputStream> requestStream =
-    DeserializeCacheStream(aRequest.body());
+  nsTArray<CacheRequestResponse> putList(1);
+  putList.AppendElement(aPut);
 
-  nsCOMPtr<nsIInputStream> responseStream =
-    DeserializeCacheStream(aResponse.body());
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreamList(1);
+  nsTArray<nsCOMPtr<nsIInputStream>> responseStreamList(1);
 
-  mManager->CachePut(this, aRequestId, mCacheId, aRequest, requestStream,
-                     aResponse, responseStream);
+  requestStreamList.AppendElement(
+    DeserializeCacheStream(aPut.request().body()));
+  responseStreamList.AppendElement(
+    DeserializeCacheStream(aPut.response().body()));
+
+
+  mManager->CachePutAll(this, aRequestId, mCacheId, putList, requestStreamList,
+                        responseStreamList);
+
   return true;
 }
 
 bool
 CacheParent::RecvDelete(const RequestId& aRequestId,
                         const PCacheRequest& aRequest,
                         const PCacheQueryParams& aParams)
 {
@@ -177,20 +196,19 @@ CacheParent::OnCacheMatchAll(RequestId a
                           aStreamList, &readStream);
     res->body() = readStream;
   }
 
   unused << SendMatchAllResponse(aRequestId, aRv, responses);
 }
 
 void
-CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv)
+CacheParent::OnCachePutAll(RequestId aRequestId, nsresult aRv)
 {
   unused << SendPutResponse(aRequestId, aRv);
-  return;
 }
 
 void
 CacheParent::OnCacheDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
 }
 
@@ -216,16 +234,23 @@ CacheParent::OnCacheKeys(RequestId aRequ
       SerializeReadStream(streamControl, aSavedRequests[i].mBodyId,
                           aStreamList, &readStream);
     req->body() = readStream;
   }
 
   unused << SendKeysResponse(aRequestId, aRv, requests);
 }
 
+void
+CacheParent::OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId, nsresult aRv)
+{
+  mFetchPutList.RemoveElement(aFetchPut);
+  unused << SendAddAllResponse(aRequestId, aRv);
+}
+
 Manager::StreamControl*
 CacheParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
                                  const nsID& aId,
                                  Manager::StreamList* aStreamList,
                                  PCacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(aStreamList);
   MOZ_ASSERT(aReadStreamOut);
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheParent_h
 #define mozilla_dom_cache_CacheParent_h
 
+#include "mozilla/dom/cache/FetchPut.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/PCacheParent.h"
 #include "mozilla/dom/cache/Types.h"
 
 struct nsID;
 template <class T> class nsRefPtr;
 
 namespace mozilla {
@@ -20,69 +21,71 @@ namespace cache {
 
 class CacheInitData;
 class CacheDBConnection;
 struct SavedResponse;
 struct StreamHolder;
 
 class CacheParent MOZ_FINAL : public PCacheParent
                             , public Manager::Listener
+                            , public FetchPut::Listener
 {
 public:
   CacheParent(const CacheInitData& aInitData, CacheId aCacheId);
   virtual ~CacheParent();
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   // PCacheParent method
   virtual bool
   RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
             const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAll(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
                const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
-  RecvAdd(const RequestId& aRequestId,
-          const PCacheRequest& aRequest) MOZ_OVERRIDE;
-  virtual bool
   RecvAddAll(const RequestId& aRequestId,
              const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
   virtual bool
-  RecvPut(const RequestId& aRequestId, const PCacheRequest& aRequest,
-          const PCacheResponse& aResponse) MOZ_OVERRIDE;
+  RecvPut(const RequestId& aRequestId, const CacheRequestResponse& aPut);
   virtual bool
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse,
                             Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                                const nsTArray<SavedResponse>& aSavedResponses,
                                Manager::StreamList* aStreamList) MOZ_OVERRIDE;
-  virtual void OnCachePut(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+  virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
   virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                            const nsTArray<SavedRequest>& aSavedRequests,
                            Manager::StreamList* aStreamList) MOZ_OVERRIDE;
 
+  // FetchPut::Listener methods
+  virtual void OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId,
+                          nsresult aRv) MOZ_OVERRIDE;
+
 private:
   Manager::StreamControl*
   SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
                       Manager::StreamList* aStreamList,
                       PCacheReadStream* aReadStreamOut);
 
   already_AddRefed<nsIInputStream>
   DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
 
   const CacheId mCacheId;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
+  nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheParent_h
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -107,17 +107,17 @@ CacheStorage::Match(const RequestOrScala
       entry->mRequest.SetAsRequest() =
         &aRequest.GetAsRequest();
     }
 
     return promise.forget();
   }
 
   PCacheRequest request;
-  ToPCacheRequest(request, aRequest, false, aRv);
+  ToPCacheRequest(request, aRequest, IgnoreBody, PassThroughReferrer, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     nsRefPtr<Promise> unused = RemoveRequestPromise(requestId);
     return nullptr;
   }
 
   PCacheQueryParams params;
   ToPCacheQueryParams(params, aParams);
 
@@ -296,17 +296,18 @@ CacheStorage::ActorCreated(PBackgroundCh
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     Entry& entry = mPendingRequests[i];
     RequestId requestId = entry.mRequestId;
     switch(entry.mOp) {
       case OP_MATCH:
       {
         PCacheRequest request;
         ErrorResult rv;
-        ToPCacheRequest(request, entry.mRequest, false, rv);
+        ToPCacheRequest(request, entry.mRequest, IgnoreBody,
+                        PassThroughReferrer, rv);
         if (NS_WARN_IF(rv.Failed())) {
           nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
           if (promise) {
             promise->MaybeReject(rv);
           }
           return;
         }
 
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -740,36 +740,39 @@ DBSchema::MatchByVaryHeader(mozIStorageC
 
     cachedHeaders->Append(name, value, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsRefPtr<InternalHeaders> queryHeaders = new InternalHeaders(aRequest.headers());
 
+  // Assume the vary headers match until we find a conflict
+  bool varyHeadersMatch = true;
+
   for (uint32_t i = 0; i < varyValues.Length(); ++i) {
     if (varyValues[i].EqualsLiteral("*")) {
       continue;
     }
 
     nsAutoCString queryValue;
     queryHeaders->Get(varyValues[i], queryValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
     nsAutoCString cachedValue;
     cachedHeaders->Get(varyValues[i], cachedValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
     if (queryValue != cachedValue) {
-      *aSuccessOut = false;
-      return rv;
+      varyHeadersMatch = false;
+      break;
     }
   }
 
-  *aSuccessOut = true;
+  *aSuccessOut = varyHeadersMatch;
   return rv;
 }
 
 // static
 nsresult
 DBSchema::DeleteEntries(mozIStorageConnection* aConn,
                         const nsTArray<EntryId>& aEntryIdList,
                         nsTArray<nsID>& aDeletedBodyIdListOut,
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.cpp
@@ -0,0 +1,389 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FetchPut.h"
+
+#include "mozilla/dom/Fetch.h"
+#include "mozilla/dom/FetchDriver.h"
+#include "mozilla/dom/Headers.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/PromiseNativeHandler.h"
+#include "mozilla/dom/Request.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/ResponseBinding.h"
+#include "mozilla/dom/UnionTypes.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "nsContentUtils.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FetchPut::FetchObserver MOZ_FINAL : public FetchDriverObserver
+{
+public:
+  FetchObserver(FetchPut* aFetchPut)
+    : mFetchPut(aFetchPut)
+  {
+  }
+
+  virtual void OnResponseAvailable(InternalResponse* aResponse) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(!mInternalResponse);
+    mInternalResponse = aResponse;
+  }
+
+  virtual void OnResponseEnd() MOZ_OVERRIDE
+  {
+    mFetchPut->FetchComplete(this, mInternalResponse);
+  }
+
+protected:
+  virtual ~FetchObserver() { }
+
+private:
+  nsRefPtr<FetchPut> mFetchPut;
+  nsRefPtr<InternalResponse> mInternalResponse;
+};
+
+// static
+nsresult
+FetchPut::Create(Listener* aListener, Manager* aManager,
+                 RequestId aRequestId, CacheId aCacheId,
+                 const nsTArray<PCacheRequest>& aRequests,
+                 const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
+                 FetchPut** aFetchPutOut)
+{
+  MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
+
+  // The FetchDriver requires that all requests have a referrer already set.
+#ifdef DEBUG
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    if (aRequests[i].referrer() == EmptyString()) {
+      return NS_ERROR_UNEXPECTED;
+    }
+  }
+#endif
+
+  nsRefPtr<FetchPut> ref = new FetchPut(aListener, aManager, aCacheId, aRequestId,
+                                        aRequests, aRequestStreams);
+
+  nsresult rv = NS_DispatchToMainThread(ref, nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  ref.forget(aFetchPutOut);
+
+  return NS_OK;
+}
+
+void
+FetchPut::ClearListener()
+{
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+FetchPut::FetchPut(Listener* aListener, Manager* aManager,
+                   RequestId aRequestId, CacheId aCacheId,
+                   const nsTArray<PCacheRequest>& aRequests,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams)
+  : mListener(aListener)
+  , mManager(aManager)
+  , mRequestId(aRequestId)
+  , mCacheId(aCacheId)
+  , mInitiatingThread(NS_GetCurrentThread())
+  , mStateList(aRequests.Length())
+  , mPendingCount(0)
+  , mResult(NS_OK)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
+
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    State* s = mStateList.AppendElement();
+    s->mPCacheRequest = aRequests[i];
+    s->mRequestStream = aRequestStreams[i];
+  }
+
+  mManager->AddRefCacheId(mCacheId);
+}
+
+FetchPut::~FetchPut()
+{
+  MOZ_ASSERT(!mListener);
+  mManager->RemoveListener(this);
+  mManager->ReleaseCacheId(mCacheId);
+}
+
+void
+FetchPut::FetchComplete(FetchObserver* aObserver,
+                        InternalResponse* aInternalResponse)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (aInternalResponse->IsError() && NS_SUCCEEDED(mResult)) {
+    MaybeSetError(NS_ERROR_FAILURE);
+  }
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    if (mStateList[i].mFetchObserver == aObserver) {
+      ErrorResult rv;
+      ToPCacheResponseWithoutBody(mStateList[i].mPCacheResponse,
+                                  *aInternalResponse, rv);
+      if (rv.Failed()) {
+        MaybeSetError(rv.ErrorCode());
+        return;
+      }
+      aInternalResponse->GetBody(getter_AddRefs(mStateList[i].mResponseStream));
+      mStateList[i].mFetchObserver = nullptr;
+      MOZ_ASSERT(mPendingCount > 0);
+      mPendingCount -= 1;
+      MaybeCompleteMainThread();
+      return;
+    }
+  }
+
+  MOZ_ASSERT_UNREACHABLE("Should never get called by unknown fetch observer.");
+}
+
+void
+FetchPut::MaybeCompleteMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (mPendingCount > 0) {
+    return;
+  }
+
+  nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch to worker thread after fetch completion.");
+  }
+}
+
+void
+FetchPut::DoPutWorkerThread()
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+
+  if (NS_FAILED(mResult)) {
+    MaybeNotifyListener();
+    return;
+  }
+
+  nsTArray<CacheRequestResponse> putList(mStateList.Length());
+  nsTArray<nsCOMPtr<nsIInputStream>> requestStreamList(mStateList.Length());
+  nsTArray<nsCOMPtr<nsIInputStream>> responseStreamList(mStateList.Length());
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    // The spec requires us to catch if content tries to insert a set of
+    // requests that would overwrite each other.
+    if (MatchInPutList(mStateList[i].mPCacheRequest, putList)) {
+      MaybeSetError(NS_ERROR_DOM_INVALID_STATE_ERR);
+      MaybeNotifyListener();
+      return;
+    }
+
+    CacheRequestResponse* entry = putList.AppendElement();
+    entry->request() = mStateList[i].mPCacheRequest;
+    entry->response() = mStateList[i].mPCacheResponse;
+    requestStreamList.AppendElement(mStateList[i].mRequestStream.forget());
+    responseStreamList.AppendElement(mStateList[i].mResponseStream.forget());
+  }
+  mStateList.Clear();
+
+  mManager->CachePutAll(this, mRequestId, mCacheId, putList, requestStreamList,
+                        responseStreamList);
+}
+
+// static
+bool
+FetchPut::MatchInPutList(const PCacheRequest& aRequest,
+                         const nsTArray<CacheRequestResponse>& aPutList)
+{
+  // This method implements the SW spec QueryCache algorithm against an
+  // in memory array of Request/Response objects.  This essentially the
+  // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
+  // we cannot unify them because when operating against the real database
+  // we don't want to load all request/response objects into memory.
+
+  if (!aRequest.method().LowerCaseEqualsLiteral("get") &&
+      !aRequest.method().LowerCaseEqualsLiteral("head")) {
+    return false;
+  }
+
+  nsRefPtr<InternalHeaders> requestHeaders =
+    new InternalHeaders(aRequest.headers());
+
+  for (uint32_t i = 0; i < aPutList.Length(); ++i) {
+    const PCacheRequest& cachedRequest = aPutList[i].request();
+    const PCacheResponse& cachedResponse = aPutList[i].response();
+
+    // If the URLs don't match, then just skip to the next entry.
+    if (aRequest.url() != cachedRequest.url()) {
+      continue;
+    }
+
+    nsRefPtr<InternalHeaders> cachedRequestHeaders =
+      new InternalHeaders(cachedRequest.headers());
+
+    nsRefPtr<InternalHeaders> cachedResponseHeaders =
+      new InternalHeaders(cachedResponse.headers());
+
+    // TODO: headers Has/Get/GetAll should not take an ErrorResult
+    ErrorResult rv;
+
+    nsTArray<nsCString> varyHeaders;
+    cachedResponseHeaders->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders,
+                                       rv);
+    MOZ_ASSERT(!rv.Failed());
+
+    // Assume the vary headers match until we find a conflict
+    bool varyHeadersMatch = true;
+
+    for (uint32_t j = 0; j < varyHeaders.Length(); ++j) {
+      if (varyHeaders[i].EqualsLiteral("*")) {
+        continue;
+      }
+
+      nsAutoCString value;
+      requestHeaders->Get(varyHeaders[j], value, rv);
+      MOZ_ASSERT(!rv.Failed());
+
+      nsAutoCString cachedValue;
+      cachedRequestHeaders->Get(varyHeaders[j], value, rv);
+      MOZ_ASSERT(!rv.Failed());
+
+      if (value != cachedValue) {
+        varyHeadersMatch = false;
+        break;
+      }
+    }
+
+    // URL was equal and all vary headers match!
+    if (varyHeadersMatch) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void
+FetchPut::OnCachePutAll(RequestId aRequestId, nsresult aRv)
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+  MaybeSetError(aRv);
+  MaybeNotifyListener();
+}
+
+void
+FetchPut::MaybeSetError(nsresult aRv)
+{
+  if (NS_FAILED(mResult) || NS_SUCCEEDED(aRv)) {
+    return;
+  }
+  mResult = aRv;
+}
+
+void
+FetchPut::MaybeNotifyListener()
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+  if (!mListener) {
+    return;
+  }
+  mListener->OnFetchPut(this, mRequestId, mResult);
+}
+
+nsIGlobalObject*
+FetchPut::GetGlobalObject() const
+{
+  MOZ_CRASH("No global object in parent-size FetchPut operation!");
+}
+
+#ifdef DEBUG
+void
+FetchPut::AssertOwningThread() const
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+}
+#endif
+
+NS_IMETHODIMP
+FetchPut::Run()
+{
+  if (mInitiatingThread == NS_GetCurrentThread()) {
+    DoPutWorkerThread();
+    return NS_OK;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIURI> uri;
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), mManager->Origin());
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    MaybeSetError(rv);
+    MaybeCompleteMainThread();
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIScriptSecurityManager> ssm = nsContentUtils::GetSecurityManager();
+  if (!ssm) {
+    MaybeSetError(NS_ERROR_UNEXPECTED);
+    MaybeCompleteMainThread();
+    return NS_OK;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal;
+  rv = ssm->GetSimpleCodebasePrincipal(uri, getter_AddRefs(principal));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    MaybeSetError(rv);
+    MaybeCompleteMainThread();
+    return NS_OK;
+  }
+
+  mPendingCount = mStateList.Length();
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    nsRefPtr<InternalRequest> internalRequest =
+      ToInternalRequest(mStateList[i].mPCacheRequest);
+
+    // If there is a stream we must clone it so that its still available
+    // to store in the cache later;
+    if (mStateList[i].mRequestStream) {
+      internalRequest->SetBody(mStateList[i].mRequestStream);
+      nsRefPtr<InternalRequest> clone = new InternalRequest(*internalRequest);
+
+      // The copy construction clone above can change the source stream,
+      // so get it back out to use when we put this in the cache.
+      internalRequest->GetBody(getter_AddRefs(mStateList[i].mRequestStream));
+
+      internalRequest = clone;
+    }
+
+    nsRefPtr<FetchDriver> fetchDriver = new FetchDriver(internalRequest,
+                                                        principal);
+
+    mStateList[i].mFetchObserver = new FetchObserver(this);
+    rv = fetchDriver->Fetch(mStateList[i].mFetchObserver);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      MaybeSetError(rv);
+      mStateList[i].mFetchObserver = nullptr;
+      mPendingCount -= 1;
+      continue;
+    }
+  }
+
+  // If they all failed, then we might need to complete main thread immediately
+  MaybeCompleteMainThread();
+
+  return NS_OK;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.h
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FetchPut_h
+#define mozilla_dom_cache_FetchPut_h
+
+#include "AlreadyAddRefed.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/TypeUtils.h"
+#include "nsRefPtr.h"
+#include "nsTArray.h"
+#include "nsThreadUtils.h"
+#include <utility>
+
+class nsIInputStream;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class OwningRequestOrScalarValueString;
+class Promise;
+class Request;
+class RequestOrScalarValueString;
+class Response;
+template<typename T> class Sequence;
+
+namespace cache {
+
+class FetchPut MOZ_FINAL : public nsRunnable
+                         , public Manager::Listener
+                         , public TypeUtils
+{
+public:
+  typedef std::pair<nsRefPtr<Request>, nsRefPtr<Response>> PutPair;
+
+  class Listener
+  {
+  public:
+    virtual void
+    OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId, nsresult aRv)=0;
+  };
+
+  static nsresult
+  Create(Listener* aListener, Manager* mManager,
+         RequestId aRequestId, CacheId aCacheId,
+         const nsTArray<PCacheRequest>& aRequests,
+         const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
+         FetchPut** aFetchPutOut);
+
+  void ClearListener();
+
+private:
+  class FetchObserver;
+  struct State
+  {
+    PCacheRequest mPCacheRequest;
+    nsCOMPtr<nsIInputStream> mRequestStream;
+    nsRefPtr<FetchObserver> mFetchObserver;
+    PCacheResponse mPCacheResponse;
+    nsCOMPtr<nsIInputStream> mResponseStream;
+
+    nsRefPtr<Request> mRequest;
+    nsRefPtr<Response> mResponse;
+  };
+
+  FetchPut(Listener* aListener, Manager* aManager,
+           RequestId aRequestId, CacheId aCacheId,
+           const nsTArray<PCacheRequest>& aRequests,
+           const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams);
+  ~FetchPut();
+
+  void FetchComplete(FetchObserver* aObserver,
+                     InternalResponse* aInternalResponse);
+  void MaybeCompleteMainThread();
+
+  void DoPutWorkerThread();
+  static bool MatchInPutList(const PCacheRequest& aRequest,
+                             const nsTArray<CacheRequestResponse>& aPutList);
+  virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
+
+  void MaybeSetError(nsresult aRv);
+  void MaybeNotifyListener();
+
+  // TypeUtils methods
+  virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
+#ifdef DEBUG
+  virtual void AssertOwningThread() const MOZ_OVERRIDE;
+#endif
+
+  // TODO remove ref counting on owner since its an actor
+  Listener* mListener;
+  nsRefPtr<Manager> mManager;
+  const RequestId mRequestId;
+  const CacheId mCacheId;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsTArray<State> mStateList;
+  uint32_t mPendingCount;
+  nsresult mResult;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FetchPut_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -367,76 +367,87 @@ protected:
   virtual ~CacheMatchAllAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
   nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
-class Manager::CachePutAction MOZ_FINAL : public DBAction
+class Manager::CachePutAllAction MOZ_FINAL : public DBAction
 {
 public:
-  CachePutAction(Manager* aManager, ListenerId aListenerId,
-                 RequestId aRequestId, CacheId aCacheId,
-                 const PCacheRequest& aRequest,
-                 nsIInputStream* aRequestBodyStream,
-                 const PCacheResponse& aResponse,
-                 nsIInputStream* aResponseBodyStream)
+  CachePutAllAction(Manager* aManager, ListenerId aListenerId,
+                    RequestId aRequestId, CacheId aCacheId,
+                    const nsTArray<CacheRequestResponse>& aPutList,
+                    const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                    const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
     : DBAction(DBAction::Existing, aManager->mInitData)
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId(aRequestId)
     , mCacheId(aCacheId)
-    , mRequest(aRequest)
-    , mRequestBodyStream(aRequestBodyStream)
-    , mResponse(aResponse)
-    , mResponseBodyStream(aResponseBodyStream)
+    , mList(aPutList.Length())
     , mExpectedAsyncCopyCompletions(0)
-  { }
+  {
+    MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
+    MOZ_ASSERT(aPutList.Length() == aResponseStreamList.Length());
+
+    for (uint32_t i = 0; i < aPutList.Length(); ++i) {
+      Entry* entry = mList.AppendElement();
+      entry->mRequest = aPutList[i].request();
+      entry->mRequestStream = aRequestStreamList[i];
+      entry->mResponse = aPutList[i].response();
+      entry->mResponseStream = aResponseStreamList[i];
+
+      mExpectedAsyncCopyCompletions += entry->mRequestStream ? 1 : 0;
+      mExpectedAsyncCopyCompletions += entry->mResponseStream ? 1 : 0;
+    }
+  }
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
                     mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
     MOZ_ASSERT(aDBDir);
     MOZ_ASSERT(aConn);
     MOZ_ASSERT(!mResolver);
     MOZ_ASSERT(!mDBDir);
     MOZ_ASSERT(!mConn);
 
     mResolver = aResolver;
     mDBDir = aDBDir;
     mConn = aConn;
 
-    mExpectedAsyncCopyCompletions = mRequestBodyStream ? 1 : 0;
-    mExpectedAsyncCopyCompletions += mResponseBodyStream ? 1 : 0;
-
     if (mExpectedAsyncCopyCompletions < 1) {
       mExpectedAsyncCopyCompletions = 1;
       OnAsyncCopyComplete(NS_OK);
       return;
     }
 
-    nsresult rv = StartStreamCopy(mRequestBodyStream, &mRequestBodyId,
-                                  getter_AddRefs(mRequestBodyCopyContext));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      DoResolve(rv);
-      return;
-    }
+    nsresult rv = NS_OK;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      rv = StartStreamCopy(mList[i].mRequestStream,
+                           &mList[i].mRequestBodyId,
+                           getter_AddRefs(mList[i].mRequestCopyContext));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        CancelAllStreamCopying();
+        DoResolve(rv);
+        return;
+      }
 
-    rv = StartStreamCopy(mResponseBodyStream, &mResponseBodyId,
-                         getter_AddRefs(mResponseBodyCopyContext));
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
-                       mRequestBodyId);
-      mRequestBodyCopyContext = nullptr;
-      DoResolve(rv);
-      return;
+      rv = StartStreamCopy(mList[i].mResponseStream,
+                           &mList[i].mResponseBodyId,
+                           getter_AddRefs(mList[i].mResponseCopyContext));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        CancelAllStreamCopying();
+        DoResolve(rv);
+        return;
+      }
     }
   }
 
   void
   OnAsyncCopyComplete(nsresult aRv)
   {
     MOZ_ASSERT(mConn);
     MOZ_ASSERT(mResolver);
@@ -452,101 +463,94 @@ public:
       return;
     }
 
     mExpectedAsyncCopyCompletions -= 1;
     if (mExpectedAsyncCopyCompletions > 0) {
       return;
     }
 
-    mRequestBodyCopyContext = nullptr;
-    mResponseBodyCopyContext = nullptr;
+    mozStorageTransaction trans(mConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = NS_OK;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      Entry& e = mList[i];
+      if (e.mRequestStream) {
+        e.mRequestCopyContext = nullptr;
+        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mRequestBodyId);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          DoResolve(rv);
+          return;
+        }
+      }
+      if (e.mResponseStream) {
+        e.mResponseCopyContext = nullptr;
+        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mResponseBodyId);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          DoResolve(rv);
+          return;
+        }
+      }
 
-    if (mRequestBodyStream) {
-      rv = FileUtils::BodyFinalizeWrite(mDBDir, mRequestBodyId);
+      rv = DBSchema::CachePut(mConn, mCacheId, e.mRequest,
+                              e.mRequestStream ? &e.mRequestBodyId : nullptr,
+                              e.mResponse,
+                              e.mResponseStream ? &e.mResponseBodyId : nullptr,
+                              mDeletedBodyIdList);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         DoResolve(rv);
         return;
       }
     }
 
-    if (mResponseBodyStream) {
-      rv = FileUtils::BodyFinalizeWrite(mDBDir, mResponseBodyId);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        DoResolve(rv);
-        return;
-      }
-    }
-
-    mozStorageTransaction trans(mConn, false,
-                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-    rv = DBSchema::CachePut(mConn, mCacheId, mRequest,
-                            mRequestBodyStream ? &mRequestBodyId : nullptr,
-                            mResponse,
-                            mResponseBodyStream ? &mResponseBodyId : nullptr,
-                            mDeletedBodyIdList);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      DoResolve(rv);
-      return;
-    }
-
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
       return;
     }
 
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
 
-    mRequestBodyStream = nullptr;
-    mResponseBodyStream = nullptr;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      mList[i].mRequestStream = nullptr;
+      mList[i].mResponseStream = nullptr;
+    }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (!listener) {
       return;
     }
-    if (NS_FAILED(aRv)) {
-      listener->OnCachePut(mRequestId, aRv);
-    } else {
-      listener->OnCachePut(mRequestId, aRv);
-    }
+    listener->OnCachePutAll(mRequestId, aRv);
   }
 
   virtual void
   CancelOnTarget() MOZ_OVERRIDE
   {
-    CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
-                     mRequestBodyId);
-    mRequestBodyCopyContext = nullptr;
-    CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
-                     mResponseBodyId);
-    mResponseBodyCopyContext = nullptr;
+    CancelAllStreamCopying();
     mConn = nullptr;
     mResolver = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 private:
-  virtual ~CachePutAction() { }
+  virtual ~CachePutAllAction() { }
 
   nsresult
   StartStreamCopy(nsIInputStream* aSource, nsID* aIdOut,
                   nsISupports** aCopyContextOut)
   {
     MOZ_ASSERT(aIdOut);
     MOZ_ASSERT(aCopyContextOut);
     MOZ_ASSERT(mDBDir);
@@ -563,73 +567,92 @@ private:
                                                   aIdOut,
                                                   aCopyContextOut);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
   void
+  CancelAllStreamCopying()
+  {
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      Entry& e = mList[i];
+      if (e.mRequestStream && e.mRequestCopyContext) {
+        CancelStreamCopy(e.mRequestStream, e.mRequestCopyContext,
+                         e.mRequestBodyId);
+        e.mRequestCopyContext = nullptr;
+      }
+      if (e.mResponseStream && e.mResponseCopyContext) {
+        CancelStreamCopy(e.mResponseStream, e.mResponseCopyContext,
+                         e.mResponseBodyId);
+        e.mResponseCopyContext = nullptr;
+      }
+    }
+  }
+
+  void
   CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
                    const nsID& aId)
   {
     if (!aSource || !aCopyContext) {
       return;
     }
     FileUtils::BodyCancelWrite(mDBDir, aId, aCopyContext);
   }
 
   static void
   AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
   {
     MOZ_ASSERT(aClosure);
-    CachePutAction* action = static_cast<CachePutAction*>(aClosure);
+    CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
     action->OnAsyncCopyComplete(aRv);
   }
 
   void
   DoResolve(nsresult aRv)
   {
     if (NS_FAILED(aRv)) {
-      CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
-                       mRequestBodyId);
-      CancelStreamCopy(mResponseBodyStream, mResponseBodyCopyContext,
-                       mResponseBodyId);
+      CancelAllStreamCopying();
     }
 
     mConn = nullptr;
-    mRequestBodyCopyContext = nullptr;
-    mResponseBodyCopyContext = nullptr;
 
     nsRefPtr<Resolver> resolver;
     mResolver.swap(resolver);
 
     if (resolver) {
-      // This can trigger self desctruction if a self-ref is not held by the
+      // This can trigger self destruction if a self-ref is not held by the
       // caller.
       resolver->Resolve(aRv);
     }
   }
 
+  struct Entry
+  {
+    PCacheRequest mRequest;
+    nsCOMPtr<nsIInputStream> mRequestStream;
+    nsID mRequestBodyId;
+    nsCOMPtr<nsISupports> mRequestCopyContext;
+
+    PCacheResponse mResponse;
+    nsCOMPtr<nsIInputStream> mResponseStream;
+    nsID mResponseBodyId;
+    nsCOMPtr<nsISupports> mResponseCopyContext;
+  };
+
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
   const CacheId mCacheId;
-  const PCacheRequest mRequest;
-  nsCOMPtr<nsIInputStream> mRequestBodyStream;
-  const PCacheResponse mResponse;
-  nsCOMPtr<nsIInputStream> mResponseBodyStream;
+  nsTArray<Entry> mList;
   nsRefPtr<Resolver> mResolver;
   nsCOMPtr<nsIFile> mDBDir;
   nsCOMPtr<mozIStorageConnection> mConn;
   uint32_t mExpectedAsyncCopyCompletions;
-  nsID mRequestBodyId;
-  nsCOMPtr<nsISupports> mRequestBodyCopyContext;
-  nsID mResponseBodyId;
-  nsCOMPtr<nsISupports> mResponseBodyCopyContext;
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
@@ -1256,33 +1279,32 @@ Manager::CacheMatchAll(Listener* aListen
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
                                                     aCacheId, aRequest, aParams,
                                                     streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
-Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
-                  const PCacheRequest& aRequest,
-                  nsIInputStream* aRequestBodyStream,
-                  const PCacheResponse& aResponse,
-                  nsIInputStream* aResponseBodyStream)
+Manager::CachePutAll(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                     const nsTArray<CacheRequestResponse>& aPutList,
+                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   MOZ_ASSERT(aListener);
   if (mShuttingDown) {
-    aListener->OnCachePut(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
+    aListener->OnCachePutAll(aRequestId, NS_ERROR_ILLEGAL_DURING_SHUTDOWN);
     return;
   }
   ListenerId listenerId = SaveListener(aListener);
-  nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
-                                               aCacheId,
-                                               aRequest, aRequestBodyStream,
-                                               aResponse, aResponseBodyStream);
+  nsRefPtr<Action> action = new CachePutAllAction(this, listenerId, aRequestId,
+                                                  aCacheId, aPutList,
+                                                  aRequestStreamList,
+                                                  aResponseStreamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -19,16 +19,17 @@
 class nsIInputStream;
 class nsIOutputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class CacheRequestResponse;
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
@@ -89,17 +90,17 @@ public:
     virtual ~Listener() { }
 
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                                  const nsTArray<SavedResponse>& aSavedResponses,
                                  StreamList* aStreamList) { }
-    virtual void OnCachePut(RequestId aRequestId, nsresult aRv) { }
+    virtual void OnCachePutAll(RequestId aRequestId, nsresult aRv) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
     virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedRequest>& aSavedRequests,
                              StreamList* aStreamList) { }
 
     virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                                 const SavedResponse* aResponse,
@@ -125,21 +126,20 @@ public:
 
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
-  void CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
-                const PCacheRequest& aRequest,
-                nsIInputStream* aRequestBodyStream,
-                const PCacheResponse& aResponse,
-                nsIInputStream* aResponseBodyStream);
+  void CachePutAll(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                   const nsTArray<CacheRequestResponse>& aPutList,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
+                   const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList);
   void CacheDelete(Listener* aListener, RequestId aRequestId,
                    CacheId aCacheId, const PCacheRequest& aRequest,
                    const PCacheQueryParams& aParams);
   void CacheKeys(Listener* aListener, RequestId aRequestId,
                  CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                  const PCacheQueryParams& aParams);
 
   void StorageMatch(Listener* aListener, RequestId aRequestId,
@@ -162,17 +162,17 @@ public:
 private:
   class Factory;
   class BaseAction;
   class DeleteOrphanedBodyAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
-  class CachePutAction;
+  class CachePutAllAction;
   class CacheDeleteAction;
   class CacheKeysAction;
 
   class StorageMatchAction;
   class StorageHasAction;
   class StorageOpenAction;
   class StorageDeleteAction;
   class StorageKeysAction;
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -17,26 +17,24 @@ namespace cache {
 
 protocol PCache
 {
   manager PBackground;
 
 parent:
   Match(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
-  Add(RequestId requestId, PCacheRequest request);
   AddAll(RequestId requestId, PCacheRequest[] requests);
-  Put(RequestId requestId, PCacheRequest request, PCacheResponse response);
+  Put(RequestId requestId, CacheRequestResponse aPut);
   Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
 
 child:
   MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse);
   MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
-  AddResponse(RequestId requestId, nsresult aRv);
   AddAllResponse(RequestId requestId, nsresult aRv);
   PutResponse(RequestId requestId, nsresult aRv);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
   KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
 
 both:
   __delete__();
 };
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -72,11 +72,17 @@ struct PCacheResponse
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
+struct CacheRequestResponse
+{
+  PCacheRequest request;
+  PCacheResponse response;
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -111,205 +111,237 @@ using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::OptionalFileDescriptorSet;
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
-                           const RequestOrScalarValueString& aIn, bool aReadBody,
-                           ErrorResult& aRv)
+                           const RequestOrScalarValueString& aIn,
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(GetGlobalObject());
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
+  ToPCacheRequest(global, aOut, aIn, aBodyAction, aReferrerAction, aRv);
 }
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const OwningRequestOrScalarValueString& aIn,
-                           bool aReadBody, ErrorResult& aRv)
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(GetGlobalObject());
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
+  return ToPCacheRequest(global, aOut, aIn, aBodyAction, aReferrerAction, aRv);
 }
 
 void
 TypeUtils::ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
                                  const Optional<RequestOrScalarValueString>& aIn,
-                                 bool aReadBody, ErrorResult& aRv)
+                                 BodyAction aBodyAction,
+                                 ReferrerAction aReferrerAction,
+                                 ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(GetGlobalObject());
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, GetGlobalObject()->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return ToPCacheRequestOrVoid(global, aOut, aIn, aReadBody, aRv);
+  return ToPCacheRequestOrVoid(global, aOut, aIn, aBodyAction, aReferrerAction,
+                               aRv);
 }
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut, Request& aIn,
-                           bool aReadBody, ErrorResult& aRv)
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
 {
   aIn.GetMethod(aOut.method());
   aIn.GetUrl(aOut.url());
 
   bool schemeValid;
   ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
   if (aRv.Failed()) {
     return;
   }
+  // TODO: wrong scheme should trigger different behavior in Match vs Put, etc.
   if (!schemeValid) {
     NS_NAMED_LITERAL_STRING(label, "Request");
     aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
     return;
   }
 
-  aIn.GetReferrer(aOut.referrer());
+  nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
+
+  if (aReferrerAction == ExpandReferrer &&
+      internalRequest->ReferrerIsClient()) {
+    nsAutoCString referrer;
+    GetRequestReferrer(GetGlobalObject(), internalRequest, referrer);
+    aOut.referrer() = NS_ConvertUTF8toUTF16(referrer);
+  } else {
+    aIn.GetReferrer(aOut.referrer());
+  }
+
   nsRefPtr<InternalHeaders> headers = aIn.GetInternalHeaders();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn.Mode();
   aOut.credentials() = aIn.Credentials();
 
-  if (!aReadBody) {
+  if (aBodyAction == IgnoreBody) {
     aOut.body() = void_t();
     return;
   }
 
   if (aIn.BodyUsed()) {
     aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
     return;
   }
 
-  nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
-  MOZ_ASSERT(internalRequest);
   nsCOMPtr<nsIInputStream> stream;
-
   internalRequest->GetBody(getter_AddRefs(stream));
   if (stream) {
     aIn.SetBodyUsed();
   }
 
   SerializeCacheStream(stream, &aOut.body(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 }
 
 // static
 void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal,
                            PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn,
-                           bool aReadBody, ErrorResult& aRv)
+                           BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                           ErrorResult& aRv)
 {
   if (aIn.IsRequest()) {
-    ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aBodyAction, aReferrerAction, aRv);
     return;
   }
 
   RequestInit init;
   nsRefPtr<Request> request = Request::Constructor(aGlobal, aIn, init, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
-  ToPCacheRequest(aOut, *request, aReadBody, aRv);
+  ToPCacheRequest(aOut, *request, aBodyAction, aReferrerAction, aRv);
 }
 
 void
-TypeUtils::ToPCacheRequestOrVoid(const GlobalObject& aGlobal, PCacheRequestOrVoid& aOut,
+TypeUtils::ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
+                                 PCacheRequestOrVoid& aOut,
                                  const Optional<RequestOrScalarValueString>& aIn,
-                                 bool aReadBody, ErrorResult& aRv)
+                                 BodyAction aBodyAction,
+                                 ReferrerAction aReferrerAction,
+                                 ErrorResult& aRv)
 {
   if (!aIn.WasPassed()) {
     aOut = void_t();
     return;
   }
   PCacheRequest request;
-  ToPCacheRequest(aGlobal, request, aIn.Value(), aReadBody, aRv);
+  ToPCacheRequest(aGlobal, request, aIn.Value(), aBodyAction, aReferrerAction,
+                  aRv);
   if (aRv.Failed()) {
     return;
   }
   aOut = request;
 }
 
 void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                            const OwningRequestOrScalarValueString& aIn,
-                           bool aReadBody, ErrorResult& aRv)
+                           BodyAction aBodyAction,
+                           ReferrerAction aReferrerAction, ErrorResult& aRv)
 {
   if (aIn.IsRequest()) {
-    ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aBodyAction, aReferrerAction,
+                    aRv);
     return;
   }
 
   RequestOrScalarValueString input;
   RequestInit init;
   nsString str;
   str.Assign(aIn.GetAsScalarValueString());
   input.SetAsScalarValueString().Rebind(str.Data(), str.Length());
 
   nsRefPtr<Request> request = Request::Constructor(aGlobal, input, init, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
-  ToPCacheRequest(aOut, *request, aReadBody, aRv);
+  ToPCacheRequest(aOut, *request, aBodyAction, aReferrerAction, aRv);
 }
 
 void
-TypeUtils::ToPCacheResponse(PCacheResponse& aOut, Response& aIn,
-                            ErrorResult& aRv)
+TypeUtils::ToPCacheResponseWithoutBody(PCacheResponse& aOut,
+                                       InternalResponse& aIn, ErrorResult& aRv)
 {
   aOut.type() = aIn.Type();
-  aIn.GetUrl(aOut.url());
+
+  nsAutoCString url;
+  aIn.GetUrl(url);
+  aOut.url() = NS_ConvertUTF8toUTF16(url);
 
   if (aOut.url() != EmptyString()) {
     bool schemeValid;
     ProcessURL(aOut.url(), &schemeValid, nullptr, aRv);
     if (aRv.Failed()) {
       return;
     }
+    // TODO: wrong scheme should trigger different behavior in Match vs Put, etc.
     if (!schemeValid) {
       NS_NAMED_LITERAL_STRING(label, "Response");
       aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
       return;
     }
   }
 
-  aOut.status() = aIn.Status();
-  aIn.GetStatusText(aOut.statusText());
-  nsRefPtr<InternalHeaders> headers = aIn.GetInternalHeaders();
+  aOut.status() = aIn.GetStatus();
+  aOut.statusText() = aIn.GetStatusText();
+  nsRefPtr<InternalHeaders> headers = aIn.Headers();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
+}
 
+void
+TypeUtils::ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv)
+{
   if (aIn.BodyUsed()) {
     aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
     return;
   }
 
+  nsRefPtr<InternalResponse> ir = aIn.GetInternalResponse();
+  ToPCacheResponseWithoutBody(aOut, *ir, aRv);
+
   nsCOMPtr<nsIInputStream> stream;
   aIn.GetBody(getter_AddRefs(stream));
   if (stream) {
     aIn.SetBodyUsed();
   }
 
   SerializeCacheStream(stream, &aOut.body(), aRv);
   if (NS_WARN_IF(aRv.Failed())) {
@@ -382,18 +414,18 @@ TypeUtils::ToResponse(const PCacheRespon
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
   ir->SetBody(stream);
 
   nsRefPtr<Response> ref = new Response(GetGlobalObject(), ir);
   return ref.forget();
 }
 
-already_AddRefed<Request>
-TypeUtils::ToRequest(const PCacheRequest& aIn)
+already_AddRefed<InternalRequest>
+TypeUtils::ToInternalRequest(const PCacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
@@ -404,16 +436,23 @@ TypeUtils::ToRequest(const PCacheRequest
   internalRequest->Headers()->SetGuard(aIn.headersGuard(), result);
   internalRequest->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
 
   internalRequest->SetBody(stream);
 
+  return internalRequest.forget();
+}
+
+already_AddRefed<Request>
+TypeUtils::ToRequest(const PCacheRequest& aIn)
+{
+  nsRefPtr<InternalRequest> internalRequest = ToInternalRequest(aIn);
   nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
   return request.forget();
 }
 
 void
 TypeUtils::CleanupChildFds(PCacheReadStreamOrVoid& aReadStreamOrVoid)
 {
   if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -16,16 +16,17 @@ class nsIGlobalObject;
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 
 class OwningRequestOrScalarValueString;
 struct QueryParams;
 class InternalRequest;
+class InternalResponse;
 class Request;
 class RequestOrScalarValueString;
 class Response;
 template<typename T> class Optional;
 
 namespace cache {
 
 class PCacheQueryParams;
@@ -34,74 +35,98 @@ class PCacheReadStreamOrVoid;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheStreamControlChild;
 
 class TypeUtils
 {
 protected:
+  enum BodyAction
+  {
+    IgnoreBody,
+    ReadBody
+  };
+
+  enum ReferrerAction
+  {
+    PassThroughReferrer,
+    ExpandReferrer
+  };
+
   virtual ~TypeUtils() { }
   virtual nsIGlobalObject* GetGlobalObject() const=0;
 #ifdef DEBUG
   virtual void AssertOwningThread() const=0;
 #else
-  inline void AssertOwningThread() { }
+  inline void AssertOwningThread() const { }
 #endif
 
   void
   ToPCacheRequest(PCacheRequest& aOut,
-                  const RequestOrScalarValueString& aIn, bool aReadBody,
-                  ErrorResult& aRv);
+                  const RequestOrScalarValueString& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
 
   void
   ToPCacheRequest(PCacheRequest& aOut,
                   const OwningRequestOrScalarValueString& aIn,
-                  bool aReadBody, ErrorResult& aRv);
+                  BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                  ErrorResult& aRv);
 
   void
   ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
                         const Optional<RequestOrScalarValueString>& aIn,
-                        bool aReadBody, ErrorResult& aRv);
+                        BodyAction aBodyAction,
+                        ReferrerAction aReferrerAction,
+                        ErrorResult& aRv);
 
   void
-  ToPCacheRequest(PCacheRequest& aOut, Request& aIn, bool aReadBody,
-                  ErrorResult& aRv);
+  ToPCacheRequest(PCacheRequest& aOut, Request& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
+
+  void
+  ToPCacheResponseWithoutBody(PCacheResponse& aOut, InternalResponse& aIn,
+                              ErrorResult& aRv);
 
   void
   ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
 
   void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   already_AddRefed<Response>
   ToResponse(const PCacheResponse& aIn);
 
+  already_AddRefed<InternalRequest>
+  ToInternalRequest(const PCacheRequest& aIn);
+
   already_AddRefed<Request>
   ToRequest(const PCacheRequest& aIn);
 
   void CleanupChildFds(PCacheReadStreamOrVoid& aRequest);
   void CleanupChildFds(PCacheReadStream& aReadStream);
 
 private:
   void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
-                  const RequestOrScalarValueString& aIn, bool aReadBody,
-                  ErrorResult& aRv);
+                  const RequestOrScalarValueString& aIn, BodyAction aBodyAction,
+                  ReferrerAction aReferrerAction, ErrorResult& aRv);
 
   void
   ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
                         PCacheRequestOrVoid& aOut,
                         const Optional<RequestOrScalarValueString>& aIn,
-                        bool aReadBody, ErrorResult& aRv);
+                        BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                        ErrorResult& aRv);
 
   void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                   const OwningRequestOrScalarValueString& aIn,
-                  bool aReadBody, ErrorResult& aRv);
+                  BodyAction aBodyAction, ReferrerAction aReferrerAction,
+                  ErrorResult& aRv);
 
   void
   SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut,
                        ErrorResult& aRv);
 
   nsIThread* GetStreamThread();
 
   nsCOMPtr<nsIThread> mStreamThread;
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -15,16 +15,17 @@ EXPORTS.mozilla.dom.cache += [
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlListener.h',
     'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
+    'FetchPut.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ReadStream.h',
     'SavedTypes.h',
     'ShutdownObserver.h',
     'Types.h',
     'TypeUtils.h',
@@ -38,16 +39,17 @@ SOURCES += [
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
+    'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ReadStream.cpp',
     'ShutdownObserver.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -393,17 +393,17 @@ WorkerFetchResolver::OnResponseEnd()
   }
 }
 
 // Empty string for no-referrer. FIXME(nsm): Does returning empty string
 // actually lead to no-referrer in the base channel?
 // The actual referrer policy and stripping is dealt with by HttpBaseChannel,
 // this always returns the full API referrer URL of the relevant global.
 nsresult
-GetRequestReferrer(nsIGlobalObject* aGlobal, const InternalRequest* aRequest, nsCString& aReferrer)
+GetRequestReferrer(nsIGlobalObject* aGlobal, const InternalRequest* aRequest, nsACString& aReferrer)
 {
   if (aRequest->ReferrerIsURL()) {
     aReferrer = aRequest->ReferrerAsURL();
     return NS_OK;
   }
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal);
   if (window) {
     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -29,17 +29,17 @@ namespace workers {
 class WorkerPrivate;
 } // namespace workers
 
 already_AddRefed<Promise>
 FetchRequest(nsIGlobalObject* aGlobal, const RequestOrScalarValueString& aInput,
              const RequestInit& aInit, ErrorResult& aRv);
 
 nsresult
-GetRequestReferrer(nsIGlobalObject* aGlobal, const InternalRequest* aRequest, nsCString& aReferrer);
+GetRequestReferrer(nsIGlobalObject* aGlobal, const InternalRequest* aRequest, nsACString& aReferrer);
 
 /*
  * Creates an nsIInputStream based on the fetch specifications 'extract a byte
  * stream algorithm' - http://fetch.spec.whatwg.org/#concept-bodyinit-extract.
  * Stores content type in out param aContentType.
  */
 nsresult
 ExtractByteStreamFromBody(const OwningArrayBufferOrArrayBufferViewOrBlobOrScalarValueStringOrURLSearchParams& aBodyInit,
diff --git a/dom/fetch/Response.cpp b/dom/fetch/Response.cpp
--- a/dom/fetch/Response.cpp
+++ b/dom/fetch/Response.cpp
@@ -156,10 +156,17 @@ Response::Headers_()
 
 void
 Response::SetBody(nsIInputStream* aBody)
 {
   // FIXME(nsm): Do we flip bodyUsed here?
   mInternalResponse->SetBody(aBody);
 }
 
+already_AddRefed<InternalResponse>
+Response::GetInternalResponse() const
+{
+  nsRefPtr<InternalResponse> ref = mInternalResponse;
+  return ref.forget();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/Response.h b/dom/fetch/Response.h
--- a/dom/fetch/Response.h
+++ b/dom/fetch/Response.h
@@ -101,16 +101,19 @@ public:
     return mOwner;
   }
 
   already_AddRefed<Response>
   Clone();
 
   void
   SetBody(nsIInputStream* aBody);
+
+  already_AddRefed<InternalResponse>
+  GetInternalResponse() const;
 private:
   ~Response();
 
   nsCOMPtr<nsIGlobalObject> mOwner;
   nsRefPtr<InternalResponse> mInternalResponse;
   // Lazily created
   nsRefPtr<Headers> mHeaders;
 };
