# HG changeset patch
# Parent 25519f7f4fb91b26498a53548f3d681b4138a60d
# User Ben Kelly <ben@wanderview.com>
Implement Cache Add()/AddAll().

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -740,36 +740,39 @@ DBSchema::MatchByVaryHeader(mozIStorageC
 
     cachedHeaders->Append(name, value, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsRefPtr<InternalHeaders> queryHeaders = new InternalHeaders(aRequest.headers());
 
+  // Assume the vary headers match until we find a conflict
+  bool varyHeadersMatch = true;
+
   for (uint32_t i = 0; i < varyValues.Length(); ++i) {
     if (varyValues[i].EqualsLiteral("*")) {
       continue;
     }
 
     nsAutoCString queryValue;
     queryHeaders->Get(varyValues[i], queryValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
     nsAutoCString cachedValue;
     cachedHeaders->Get(varyValues[i], cachedValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
     if (queryValue != cachedValue) {
-      *aSuccessOut = false;
-      return rv;
+      varyHeadersMatch = false;
+      break;
     }
   }
 
-  *aSuccessOut = true;
+  *aSuccessOut = varyHeadersMatch;
   return rv;
 }
 
 // static
 nsresult
 DBSchema::DeleteEntries(mozIStorageConnection* aConn,
                         const nsTArray<EntryId>& aEntryIdList,
                         nsTArray<nsID>& aDeletedBodyIdListOut,
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.cpp
@@ -0,0 +1,375 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/FetchPut.h"
+
+#include "mozilla/dom/Fetch.h"
+#include "mozilla/dom/Headers.h"
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/PromiseNativeHandler.h"
+#include "mozilla/dom/Request.h"
+#include "mozilla/dom/Response.h"
+#include "mozilla/dom/ResponseBinding.h"
+#include "mozilla/dom/UnionTypes.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class FetchPut::FetchPromiseHandler MOZ_FINAL : public PromiseNativeHandler
+{
+public:
+  FetchPromiseHandler(FetchPut* aFetchPut, Promise* aPromise)
+    : mFetchPut(aFetchPut)
+    , mPromise(aPromise)
+  {
+    MOZ_ASSERT(mFetchPut);
+    MOZ_ASSERT(mPromise);
+  }
+
+  virtual void ResolvedCallback(JSContext* aCx,
+                                JS::Handle<JS::Value> aValue) MOZ_OVERRIDE {
+    JS::Rooted<JSObject*> obj(aCx, &aValue.toObject());
+    if (!obj) {
+      mFetchPut->FetchRejected(mPromise);
+      return;
+    }
+    Response* response;
+    UNWRAP_OBJECT(Response, obj, response);
+    if (!response) {
+      mFetchPut->FetchRejected(mPromise);
+      return;
+    }
+
+    mFetchPut->FetchResolved(mPromise, response);
+  }
+
+  virtual void RejectedCallback(JSContext* aCx,
+                                JS::Handle<JS::Value> aValue) MOZ_OVERRIDE {
+    // TODO: pass on rejected error code
+    mFetchPut->FetchRejected(mPromise);
+  }
+
+private:
+  virtual ~FetchPromiseHandler() { }
+
+  nsRefPtr<FetchPut> mFetchPut;
+  nsRefPtr<Promise> mPromise;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+};
+
+NS_IMPL_ISUPPORTS_INHERITED0(mozilla::dom::cache::FetchPut::FetchPromiseHandler,
+                             PromiseNativeHandler);
+
+class FetchPut::PutPromiseHandler MOZ_FINAL : public PromiseNativeHandler
+{
+public:
+  PutPromiseHandler(FetchPut* aFetchPut)
+    : mFetchPut(aFetchPut)
+  {
+    MOZ_ASSERT(mFetchPut);
+  }
+
+  virtual void ResolvedCallback(JSContext*, JS::Handle<JS::Value>) MOZ_OVERRIDE {
+    mFetchPut->PutResolved();
+  }
+
+  virtual void RejectedCallback(JSContext*, JS::Handle<JS::Value>) MOZ_OVERRIDE {
+    // TODO: pass on rejected error code
+    mFetchPut->PutRejected();
+  }
+
+private:
+  virtual ~PutPromiseHandler() { }
+
+  nsRefPtr<FetchPut> mFetchPut;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+};
+
+NS_IMPL_ISUPPORTS_INHERITED0(mozilla::dom::cache::FetchPut::PutPromiseHandler,
+                             PromiseNativeHandler);
+
+// static
+already_AddRefed<FetchPut>
+FetchPut::Create(Owner* aOwner, RequestId aRequestId,
+                        const RequestOrScalarValueString& aRequest,
+                        ErrorResult& aRv)
+{
+  Sequence<OwningRequestOrScalarValueString> seq;
+  OwningRequestOrScalarValueString* elem = seq.AppendElement();
+  if (aRequest.IsRequest()) {
+    elem->SetAsRequest() = aRequest.GetAsRequest();
+  } else {
+    MOZ_ASSERT(aRequest.IsScalarValueString());
+    elem->SetAsScalarValueString() = aRequest.GetAsScalarValueString();
+  }
+  return Create(aOwner, aRequestId, seq, aRv);
+}
+
+// static
+already_AddRefed<FetchPut>
+FetchPut::Create(Owner* aOwner, RequestId aRequestId,
+                        const Sequence<OwningRequestOrScalarValueString>& aRequests,
+                        ErrorResult& aRv)
+{
+  MOZ_ASSERT(aOwner);
+
+  AutoJSAPI jsapi;
+  jsapi.Init(aOwner->GetGlobalObject());
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> jsGlobal(cx, aOwner->GetGlobalObject()->GetGlobalJSObject());
+  JSAutoCompartment ac(cx, jsGlobal);
+  GlobalObject global(cx, jsGlobal);
+
+  nsTArray<State> stateList(aRequests.Length());
+  for (uint32_t i = 0; i < aRequests.Length(); ++i) {
+    nsRefPtr<Request> request;
+    if (aRequests[i].IsRequest()) {
+      request = aRequests[i].GetAsRequest();
+    } else {
+      RequestInit init;
+
+      RequestOrScalarValueString requestOrSvs;
+      requestOrSvs.SetAsScalarValueString().Rebind(
+        aRequests[i].GetAsScalarValueString().Data(),
+        aRequests[i].GetAsScalarValueString().Length());
+
+      request = Request::Constructor(global, requestOrSvs, init, aRv);
+      if (aRv.Failed()) {
+        return nullptr;
+      }
+    }
+
+    // Defensively clone here to avoid trying to access the request
+    // body twice with fetch+put operations.
+    nsRefPtr<Request> clone = request->Clone();
+
+    RequestOrScalarValueString requestOrSvs;
+    requestOrSvs.SetAsRequest() = clone;
+
+    RequestInit init;
+    nsRefPtr<Promise> promise = FetchRequest(aOwner->GetGlobalObject(),
+                                             requestOrSvs, init, aRv);
+    if (aRv.Failed()) {
+      return nullptr;
+    }
+
+    State* state = stateList.AppendElement();
+    state->mRequest = request.forget();
+    state->mPromise = promise.forget();
+  }
+
+  nsRefPtr<FetchPut> ref = new FetchPut(aOwner, aRequestId, stateList);
+  return ref.forget();
+}
+
+FetchPut::FetchPut(Owner* aOwner, RequestId aRequestId,
+                   const nsTArray<State>& aStateList)
+  : mOwner(aOwner)
+  , mRequestId(aRequestId)
+  , mStateList(aStateList)
+  , mPendingCount(aStateList.Length())
+  , mResult(NS_OK)
+{
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    nsRefPtr<FetchPromiseHandler> handler =
+      new FetchPromiseHandler(this, aStateList[i].mPromise);
+    mStateList[i].mPromise->AppendNativeHandler(handler);
+  }
+
+  // If we got an empty list, then we might complete immediately
+  if (mStateList.IsEmpty()) {
+    nsCOMPtr<nsIRunnable> r =
+      NS_NewRunnableMethod(this, &FetchPut::MaybeCompleteFetch);
+    nsresult rv = NS_DispatchToCurrentThread(r);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch immediate Cache FetchPut completion.");
+    }
+  }
+}
+
+FetchPut::~FetchPut()
+{
+}
+
+void
+FetchPut::FetchResolved(Promise* aPromise, Response* aResponse)
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    if (mStateList[i].mPromise == aPromise) {
+      mStateList[i].mResponse = aResponse;
+      mStateList[i].mPromise = nullptr;
+      MOZ_ASSERT(mPendingCount > 0);
+      mPendingCount -= 1;
+      MaybeCompleteFetch();
+      return;
+    }
+  }
+
+  MOZ_ASSERT_UNREACHABLE("Should never resolve unknown promise.");
+}
+
+void
+FetchPut::FetchRejected(Promise* aPromise)
+{
+  NS_ASSERT_OWNINGTHREAD(FetchPut);
+
+  if (NS_SUCCEEDED(mResult)) {
+    mResult = NS_ERROR_FAILURE;
+  }
+
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    if (mStateList[i].mPromise == aPromise) {
+      mStateList[i].mPromise = nullptr;
+      MOZ_ASSERT(mPendingCount > 0);
+      mPendingCount -= 1;
+      MaybeCompleteFetch();
+      return;
+    }
+  }
+
+  MOZ_ASSERT_UNREACHABLE("Should never reject unknown promise.");
+}
+
+void
+FetchPut::MaybeCompleteFetch()
+{
+  if (mPendingCount > 0) {
+    return;
+  }
+
+  if (NS_FAILED(mResult)) {
+    mOwner->FetchPutComplete(this, mRequestId, mResult);
+    return;
+  }
+
+  nsTArray<PutPair> putList(mStateList.Length());
+  for (uint32_t i = 0; i < mStateList.Length(); ++i) {
+    // The spec requires us to catch if content tries to insert a set of
+    // requests that would overwrite each other.
+    if (MatchInPutList(mStateList[i].mRequest, putList)) {
+      mOwner->FetchPutComplete(this, mRequestId,
+                               NS_ERROR_DOM_INVALID_STATE_ERR);
+      return;
+    }
+
+    PutPair* pair = putList.AppendElement();
+    pair->first = mStateList[i].mRequest.forget();
+    pair->second = mStateList[i].mResponse.forget();
+  }
+  mStateList.Clear();
+
+  ErrorResult rv;
+  nsRefPtr<Promise> promise = mOwner->PutAll(putList, rv);
+  if (rv.Failed()) {
+    PutRejected();
+    return;
+  }
+
+  nsRefPtr<PutPromiseHandler> handler = new PutPromiseHandler(this);
+  promise->AppendNativeHandler(handler);
+}
+
+// static
+bool
+FetchPut::MatchInPutList(Request* aRequest, nsTArray<PutPair>& aPutList)
+{
+  // This method implements the SW spec QueryCache algorithm against an
+  // in memory array of Request/Response objects.  This essentially the
+  // same algorithm that is implemented in DBSchema.cpp.  Unfortunately
+  // we cannot unify them because when operating against the real database
+  // we don't want to load all request/response objects into memory.
+
+  nsAutoCString method;
+  aRequest->GetMethod(method);
+  if (!method.LowerCaseEqualsLiteral("get") &&
+      !method.LowerCaseEqualsLiteral("head")) {
+    return false;
+  }
+
+  nsString url;
+  aRequest->GetUrl(url);
+
+  for (uint32_t i = 0; i < aPutList.Length(); ++i) {
+    Request* cachedRequest = aPutList[i].first;
+    Response* cachedResponse = aPutList[i].second;
+
+    // If the URLs don't match, then just skip to the next entry.
+    nsString cachedUrl;
+    cachedRequest->GetUrl(cachedUrl);
+    if (url != cachedUrl) {
+      continue;
+    }
+
+    // TODO: headers Has/Get/GetAll should not take an ErrorResult
+    ErrorResult rv;
+
+    // URL is equal and vary headers are not present.  We have a match!
+    if (!cachedResponse->Headers_()->Has(NS_LITERAL_CSTRING("vary"), rv)) {
+      return true;
+    }
+    MOZ_ASSERT(!rv.Failed());
+
+    nsTArray<nsCString> varyHeaders;
+    cachedResponse->Headers_()->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders,
+                                       rv);
+    MOZ_ASSERT(!rv.Failed());
+
+    // Assume the vary headers match until we find a conflict
+    bool varyHeadersMatch = true;
+
+    for (uint32_t j = 0; j < varyHeaders.Length(); ++j) {
+      if (varyHeaders[i].EqualsLiteral("*")) {
+        continue;
+      }
+
+      nsAutoCString value;
+      aRequest->Headers_()->Get(varyHeaders[j], value, rv);
+      MOZ_ASSERT(!rv.Failed());
+
+      nsAutoCString cachedValue;
+      cachedRequest->Headers_()->Get(varyHeaders[j], value, rv);
+      MOZ_ASSERT(!rv.Failed());
+
+      if (value != cachedValue) {
+        varyHeadersMatch = false;
+        break;
+      }
+    }
+
+    // URL was equal and all vary headers match!
+    if (varyHeadersMatch) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void
+FetchPut::PutResolved()
+{
+  mOwner->FetchPutComplete(this, mRequestId, mResult);
+}
+
+void
+FetchPut::PutRejected()
+{
+  if (NS_SUCCEEDED(mResult)) {
+    mResult = NS_ERROR_FAILURE;
+  }
+  mOwner->FetchPutComplete(this, mRequestId, mResult);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/FetchPut.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_FetchPut_h
+#define mozilla_dom_cache_FetchPut_h
+
+#include "AlreadyAddRefed.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsRefPtr.h"
+#include "nsTArray.h"
+#include <utility>
+
+class nsIGlobalObject;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+class OwningRequestOrScalarValueString;
+class Promise;
+class Request;
+class RequestOrScalarValueString;
+class Response;
+template<typename T> class Sequence;
+
+namespace cache {
+
+class FetchPut MOZ_FINAL
+{
+public:
+  typedef std::pair<nsRefPtr<Request>, nsRefPtr<Response>> PutPair;
+
+  class Owner : public nsISupports
+  {
+  public:
+    virtual ~Owner() { }
+
+    virtual nsIGlobalObject*
+    GetGlobalObject() const=0;
+
+    virtual already_AddRefed<Promise>
+    PutAll(const nsTArray<PutPair>& aPutList, ErrorResult& aRv)=0;
+
+    virtual void
+    FetchPutComplete(FetchPut* aContext, RequestId aRequestId,
+                     nsresult aRv)=0;
+  };
+
+  static already_AddRefed<FetchPut>
+  Create(Owner* aOwner, RequestId aRequestId,
+         const RequestOrScalarValueString& aRequest, ErrorResult& aRv);
+
+  static already_AddRefed<FetchPut>
+  Create(Owner* aOwner, RequestId aRequestId,
+         const Sequence<OwningRequestOrScalarValueString>& aRequests,
+         ErrorResult& aRv);
+
+private:
+  class FetchPromiseHandler;
+  class PutPromiseHandler;
+  struct State
+  {
+    nsRefPtr<Request> mRequest;
+    nsRefPtr<Promise> mPromise;
+    nsRefPtr<Response> mResponse;
+  };
+
+  FetchPut(Owner* aOwner, RequestId aRequestId,
+           const nsTArray<State>& aStateList);
+  ~FetchPut();
+
+  void FetchResolved(Promise* aPromise, Response* aResponse);
+  void FetchRejected(Promise* aPromise);
+  void MaybeCompleteFetch();
+
+  static bool MatchInPutList(Request* aRequest, nsTArray<PutPair>& aPutList);
+
+  void PutResolved();
+  void PutRejected();
+
+  nsRefPtr<Owner> mOwner;
+  const RequestId mRequestId;
+  nsTArray<State> mStateList;
+  uint32_t mPendingCount;
+  nsresult mResult;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::FetchPut);
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_FetchPut_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -15,16 +15,17 @@ EXPORTS.mozilla.dom.cache += [
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlListener.h',
     'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
+    'FetchPut.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ReadStream.h',
     'SavedTypes.h',
     'ShutdownObserver.h',
     'Types.h',
     'TypeUtils.h',
@@ -38,16 +39,17 @@ SOURCES += [
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
+    'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ReadStream.cpp',
     'ShutdownObserver.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
