# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f600632626c3dbe42bef53d9ebdf6d79d60daf5e

diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
--- a/dom/clients/manager/ClientOpenWindowUtils.cpp
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -29,33 +29,28 @@ namespace {
 
 class WebProgressListener final : public nsIWebProgressListener
                                 , public nsSupportsWeakReference
 {
 public:
   NS_DECL_ISUPPORTS
 
   WebProgressListener(nsPIDOMWindowOuter* aWindow,
-                      nsIURI* aBaseURI)
-  : mPromise(new ClientOpPromise::Private(__func__))
+                      nsIURI* aBaseURI,
+                      already_AddRefed<ClientOpPromise::Private> aPromise)
+  : mPromise(aPromise)
   , mWindow(aWindow)
   , mBaseURI(aBaseURI)
   {
     MOZ_ASSERT(aWindow);
     MOZ_ASSERT(aWindow->IsOuterWindow());
     MOZ_ASSERT(aBaseURI);
     MOZ_ASSERT(NS_IsMainThread());
   }
 
-  ClientOpPromise*
-  Promise() const
-  {
-    return mPromise;
-  }
-
   NS_IMETHOD
   OnStateChange(nsIWebProgress* aWebProgress,
                 nsIRequest* aRequest,
                 uint32_t aStateFlags, nsresult aStatus) override
   {
     if (!(aStateFlags & STATE_IS_DOCUMENT) ||
          !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
       return NS_OK;
@@ -258,73 +253,185 @@ OpenWindow(const ClientOpenWindowArgs& a
 
   nsCOMPtr<nsPIDOMWindowOuter> pWin = nsPIDOMWindowOuter::From(win);
   pWin.forget(aWindow);
   MOZ_DIAGNOSTIC_ASSERT(*aWindow);
 
   return NS_OK;
 }
 
-} // anonymous namespace
+void
+WaitForLoad(const ClientOpenWindowArgs& aArgs,
+            nsPIDOMWindowOuter* aOuterWindow,
+            ClientOpPromise::Private* aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aOuterWindow);
 
-already_AddRefed<ClientOpPromise>
-ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs& aArgs)
-{
-  RefPtr<ClientOpPromise> ref;
+  RefPtr<ClientOpPromise::Private> promise = aPromise;
 
-#ifdef MOZ_WIDGET_ANDROID
-  // This fires an intent that will start launching Fennec and foreground it,
-  // if necessary.
-  java::GeckoAppShell::LaunchOrBringToFront();
-#endif
-
-  nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
-  nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(aOuterWindow);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
-  }
-
-  MOZ_DIAGNOSTIC_ASSERT(outerWindow);
-
-  rv = nsContentUtils::DispatchFocusChromeEvent(outerWindow);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
+    promise->Reject(rv, __func__);
+    return;
   }
 
   nsCOMPtr<nsIURI> baseURI;
   rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
+    promise->Reject(rv, __func__);
+    return;
   }
 
-  nsCOMPtr<nsIDocShell> docShell = outerWindow->GetDocShell();
+  nsCOMPtr<nsIDocShell> docShell = aOuterWindow->GetDocShell();
   nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
 
   if (NS_WARN_IF(!webProgress)) {
-    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
-    return ref.forget();
+    promise->Reject(NS_ERROR_FAILURE, __func__);
+    return;
   }
 
+  RefPtr<ClientOpPromise> ref = promise;
+
   RefPtr<WebProgressListener> listener =
-    new WebProgressListener(outerWindow, baseURI);
+    new WebProgressListener(aOuterWindow, baseURI, promise.forget());
 
-  ref = listener->Promise();
 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    ref = ClientOpPromise::CreateAndReject(rv, __func__);
-    return ref.forget();
+    promise->Reject(rv, __func__);
+    return;
   }
 
   // Hold the listener alive until the promise settles
   ref->Then(AbstractThread::GetCurrent(), __func__,
     [listener] (const ClientOpResult& aResult) { },
     [listener] (nsresult aResult) { });
+}
+
+#ifdef MOZ_WIDGET_ANDROID
+
+class LaunchObserver final : public nsIObserver
+{
+  RefPtr<GenericPromise::Private> mPromise;
+
+  LaunchObserver()
+    : mPromise(new GenericPromise::Private(__func__))
+  {
+  }
+
+  ~LaunchObserver() = default;
+
+  NS_IMETHOD
+  Observe(nsISupports* aSubject, const char* aTopic, const char16_t * aData) override
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (os) {
+      os->RemoveObserver(this, "BrowserChrome:Ready");
+    }
+    mPromise->Resolve(true, __func__);
+    return NS_OK;
+  }
+
+public:
+  static already_AddRefed<LaunchObserver>
+  Create()
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (NS_WARN_IF(!os)) {
+      return nullptr;
+    }
+
+    RefPtr<LaunchObserver> ref = new LaunchObserver();
+
+    nsresult rv = os->AddObserver(ref, "BrowserChrome:Ready", /* weakRef */ false);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    return ref.forget();
+  }
+
+  void
+  Cancel()
+  {
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (os) {
+      os->RemoveObserver(this, "BrowserChrome:Ready");
+    }
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+  }
+
+  GenericPromise*
+  Promise()
+  {
+    return mPromise;
+  }
+
+  NS_DECL_ISUPPORTS
+};
+
+NS_IMPL_ISUPPORTS(LaunchObserver, nsIObserver);
+
+#endif // MOZ_WIDGET_ANDROID
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+  RefPtr<ClientOpPromise> ref = promise;
+
+#ifdef MOZ_WIDGET_ANDROID
+  // This fires an intent that will start launching Fennec and foreground it,
+  // if necessary.  We create an observer so that we can determine when
+  // the launch has completed.
+  RefPtr<LaunchObserver> launchObserver = LaunchObserver::Create();
+  java::GeckoAppShell::LaunchOrBringToFront();
+#endif // MOZ_WIDGET_ANDROID
+
+  nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
+  nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+
+#ifdef MOZ_WIDGET_ANDROID
+  // If we get the NOT_AVAILABLE error that means the browser is still
+  // launching on android.  Use the observer we created above to wait
+  // until the launch completes and then try to open the window again.
+  if (rv == NS_ERROR_NOT_AVAILABLE && launchObserver) {
+    RefPtr<GenericPromise> p = launchObserver->Promise();
+    p->Then(AbstractThread::GetCurrent(), __func__,
+      [aArgs, promise] (bool aResult) {
+        nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
+        nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          promise->Reject(rv, __func__);
+        }
+
+        WaitForLoad(aArgs, outerWindow, promise);
+      }, [promise] (nsresult aResult) {
+        promise->Reject(aResult, __func__);
+      });
+    return ref.forget();
+  }
+
+  // If we didn't get the NOT_AVAILABLE error then there is no need
+  // wait for the browser to launch.  Cancel the observer so that it
+  // will release.
+  if (launchObserver) {
+    launchObserver->Cancel();
+  }
+#endif // MOZ_WIDGET_ANDROID
+
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    promise->Reject(rv, __func__);
+    return ref.forget();
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(outerWindow);
+  WaitForLoad(aArgs, outerWindow, promise);
 
   return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
