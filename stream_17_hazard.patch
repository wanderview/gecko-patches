# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  45946b40711a017dc967d6a4ed84caddc729c64e
Bug 1128959 - Implement the WHATWG Streams spec - part 17 - Creating FetchStream as a out param in order to avoid JS hazards, r=bz

diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -1111,22 +1111,19 @@ FetchBody<Derived>::GetBody(JSContext* a
   nsCOMPtr<nsIInputStream> inputStream;
   DerivedClass()->GetBody(getter_AddRefs(inputStream));
 
   if (!inputStream) {
     aBodyOut.set(nullptr);
     return;
   }
 
-  JS::Rooted<JSObject*> body(aCx,
-                             FetchStream::Create(aCx,
-                                                 this,
-                                                 DerivedClass()->GetParentObject(),
-                                                 inputStream,
-                                                 aRv));
+  JS::Rooted<JSObject*> body(aCx);
+  FetchStream::Create(aCx, this, DerivedClass()->GetParentObject(),
+                      inputStream, &body, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   MOZ_ASSERT(body);
 
   // If the body has been already consumed, we lock the stream.
   if (BodyUsed()) {
diff --git a/dom/fetch/FetchStream.cpp b/dom/fetch/FetchStream.cpp
--- a/dom/fetch/FetchStream.cpp
+++ b/dom/fetch/FetchStream.cpp
@@ -96,49 +96,49 @@ private:
   RefPtr<FetchStreamHolder> mStreamHolder;
 };
 
 } // anonymous
 
 NS_IMPL_ISUPPORTS(FetchStream, nsIInputStreamCallback, nsIObserver,
                   nsISupportsWeakReference)
 
-/* static */ JSObject*
+/* static */ void
 FetchStream::Create(JSContext* aCx, FetchStreamHolder* aStreamHolder,
                     nsIGlobalObject* aGlobal, nsIInputStream* aInputStream,
-                    ErrorResult& aRv)
+                    JS::MutableHandle<JSObject*> aStream, ErrorResult& aRv)
 {
   MOZ_DIAGNOSTIC_ASSERT(aCx);
   MOZ_DIAGNOSTIC_ASSERT(aStreamHolder);
   MOZ_DIAGNOSTIC_ASSERT(aInputStream);
 
   RefPtr<FetchStream> stream =
     new FetchStream(aGlobal, aStreamHolder, aInputStream);
 
   if (NS_IsMainThread()) {
     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     if (NS_WARN_IF(!os)) {
       aRv.Throw(NS_ERROR_FAILURE);
-      return nullptr;
+      return;
     }
 
     aRv = os->AddObserver(stream, DOM_WINDOW_DESTROYED_TOPIC, true);
     if (NS_WARN_IF(aRv.Failed())) {
-      return nullptr;
+      return;
     }
 
   } else {
     WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
     MOZ_ASSERT(workerPrivate);
 
     UniquePtr<FetchStreamWorkerHolder> holder(
       new FetchStreamWorkerHolder(stream));
     if (NS_WARN_IF(!holder->HoldWorker(workerPrivate, Closing))) {
       aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
-      return nullptr;
+      return;
     }
 
     // Note, this will create a ref-cycle between the holder and the stream.
     // The cycle is broken when the stream is closed or the worker begins
     // shutting down.
     stream->mWorkerHolder = Move(holder);
   }
 
@@ -151,24 +151,25 @@ FetchStream::Create(JSContext* aCx, Fetc
                                    &FetchStream::ErroredCallback,
                                    &FetchStream::FinalizeCallback);
   }
 
   JS::Rooted<JSObject*> body(aCx,
     JS::NewReadableExternalSourceStreamObject(aCx, stream, FETCH_STREAM_FLAG));
   if (!body) {
     aRv.StealExceptionFromJSContext(aCx);
-    return nullptr;
+    return;
   }
 
   stream->mReadableStream = body;
 
   // JS engine will call the finalize callback.
   NS_ADDREF(stream.get());
-  return body;
+
+  aStream.set(body);
 }
 
 /* static */ void
 FetchStream::RequestDataCallback(JSContext* aCx,
                                  JS::HandleObject aStream,
                                  void* aUnderlyingSource,
                                  uint8_t aFlags,
                                  size_t aDesiredSize)
@@ -302,17 +303,19 @@ FetchStream::WriteIntoReadRequestCallbac
 /* static */ JS::Value
 FetchStream::CancelCallback(JSContext* aCx, JS::HandleObject aStream,
                             void* aUnderlyingSource, uint8_t aFlags,
                             JS::HandleValue aReason)
 {
   MOZ_DIAGNOSTIC_ASSERT(aUnderlyingSource);
   MOZ_DIAGNOSTIC_ASSERT(aFlags == FETCH_STREAM_FLAG);
 
-  RefPtr<FetchStream> stream = static_cast<FetchStream*>(aUnderlyingSource);
+  // This is safe because ReadableStreamControllerCancelSteps() roots
+  // the underlying source on the stack while calling this method.
+  FetchStream* stream = static_cast<FetchStream*>(aUnderlyingSource);
 
   if (stream->mInputStream) {
     stream->mInputStream->CloseWithStatus(NS_BASE_STREAM_CLOSED);
   }
 
   stream->ReleaseObjects();
   return JS::UndefinedValue();
 }
diff --git a/dom/fetch/FetchStream.h b/dom/fetch/FetchStream.h
--- a/dom/fetch/FetchStream.h
+++ b/dom/fetch/FetchStream.h
@@ -31,20 +31,20 @@ class FetchStream final : public nsIInpu
                         , public nsIObserver
                         , public nsSupportsWeakReference
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAMCALLBACK
   NS_DECL_NSIOBSERVER
 
-  static JSObject*
+  static void
   Create(JSContext* aCx, FetchStreamHolder* aStreamHolder,
          nsIGlobalObject* aGlobal, nsIInputStream* aInputStream,
-         ErrorResult& aRv);
+         JS::MutableHandle<JSObject*> aStream, ErrorResult& aRv);
 
   void
   Close();
 
   static nsresult
   RetrieveInputStream(void* aUnderlyingReadableStreamSource,
                       nsIInputStream** aInputStream);
 
