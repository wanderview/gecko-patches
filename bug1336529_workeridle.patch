# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1ac998be4f4df44740552a900ab5f35af80727e6
Bug 1336529 Handle ServiceWorkerInfo destruction while released KeepAliveToken. r=asuth

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1369,17 +1369,17 @@ ServiceWorkerManager::NotifyUnregister(n
   queue->ScheduleJob(job);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::WorkerIsIdle(ServiceWorkerInfo* aWorker)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(aWorker);
+  MOZ_DIAGNOSTIC_ASSERT(aWorker);
 
   RefPtr<ServiceWorkerRegistrationInfo> reg =
     GetRegistration(aWorker->GetPrincipal(), aWorker->Scope());
   if (!reg) {
     return;
   }
 
   if (reg->GetActive() != aWorker) {
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -2071,17 +2071,21 @@ void
 ServiceWorkerPrivate::ReleaseToken()
 {
   AssertIsOnMainThread();
 
   MOZ_ASSERT(mTokenCount > 0);
   --mTokenCount;
   if (!mTokenCount) {
     TerminateWorker();
-  } else if (IsIdle()) {
+  }
+
+  // mInfo can be nullptr here if NoteDeadServiceWorkerInfo() is called while
+  // the KeepAliveToken is being proxy released as a runnable.
+  else if (mInfo && IsIdle()) {
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (swm) {
       swm->WorkerIsIdle(mInfo);
     }
   }
 }
 
 already_AddRefed<KeepAliveToken>
