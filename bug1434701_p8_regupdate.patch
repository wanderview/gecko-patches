# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a771f7d8e7b27be9e5d6b7c31af656b6266a5188
Bug 1434701 P8 Make ServiceWorkerRegistration own the ServiceWorker references itself and handle the descriptor update. r=catalinb

diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -60,10 +60,75 @@ ServiceWorkerRegistration::CreateForWork
   NS_ConvertUTF8toUTF16 scope(aDescriptor.Scope());
 
   RefPtr<ServiceWorkerRegistration> registration =
     new ServiceWorkerRegistrationWorkerThread(aWorkerPrivate, aDescriptor);
 
   return registration.forget();
 }
 
+already_AddRefed<ServiceWorker>
+ServiceWorkerRegistration::GetInstalling() const
+{
+  RefPtr<ServiceWorker> ref = mInstallingWorker;
+  return ref.forget();
+}
+
+already_AddRefed<ServiceWorker>
+ServiceWorkerRegistration::GetWaiting() const
+{
+  RefPtr<ServiceWorker> ref = mWaitingWorker;
+  return ref.forget();
+}
+
+already_AddRefed<ServiceWorker>
+ServiceWorkerRegistration::GetActive() const
+{
+  RefPtr<ServiceWorker> ref = mActiveWorker;
+  return ref.forget();
+}
+
+void
+ServiceWorkerRegistration::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
+{
+  MOZ_DIAGNOSTIC_ASSERT(MatchesDescriptor(aDescriptor));
+
+  mDescriptor = aDescriptor;
+
+  nsCOMPtr<nsIGlobalObject> global = GetParentObject();
+  if (!global) {
+    mInstallingWorker = nullptr;
+    mWaitingWorker = nullptr;
+    mActiveWorker = nullptr;
+    return;
+  }
+
+  Maybe<ServiceWorkerDescriptor> active = aDescriptor.GetActive();
+  if (active.isSome()) {
+    mActiveWorker = global->GetOrCreateServiceWorker(active.ref());
+  } else {
+    mActiveWorker = nullptr;
+  }
+
+  Maybe<ServiceWorkerDescriptor> waiting = aDescriptor.GetWaiting();
+  if (waiting.isSome()) {
+    mWaitingWorker = global->GetOrCreateServiceWorker(waiting.ref());
+  } else {
+    mWaitingWorker = nullptr;
+  }
+
+  Maybe<ServiceWorkerDescriptor> installing = aDescriptor.GetInstalling();
+  if (installing.isSome()) {
+    mInstallingWorker = global->GetOrCreateServiceWorker(installing.ref());
+  } else {
+    mInstallingWorker = nullptr;
+  }
+}
+
+bool
+ServiceWorkerRegistration::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) const
+{
+  return aDescriptor.PrincipalInfo() == mDescriptor.PrincipalInfo() &&
+         aDescriptor.Scope() == mDescriptor.Scope();
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerRegistration_h
 #define mozilla_dom_ServiceWorkerRegistration_h
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/DOMPrefs.h"
+#include "mozilla/dom/ServiceWorker.h"
 #include "mozilla/dom/ServiceWorkerBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationDescriptor.h"
 
 // Support for Notification API extension.
 #include "mozilla/dom/NotificationBinding.h"
 
 class nsPIDOMWindowInner;
@@ -38,24 +39,30 @@ public:
 
   static already_AddRefed<ServiceWorkerRegistration>
   CreateForWorker(WorkerPrivate* aWorkerPrivate,
                   const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
-  virtual already_AddRefed<ServiceWorker>
-  GetInstalling() = 0;
+  already_AddRefed<ServiceWorker>
+  GetInstalling() const;
+
+  already_AddRefed<ServiceWorker>
+  GetWaiting() const;
 
-  virtual already_AddRefed<ServiceWorker>
-  GetWaiting() = 0;
+  already_AddRefed<ServiceWorker>
+  GetActive() const;
 
-  virtual already_AddRefed<ServiceWorker>
-  GetActive() = 0;
+  void
+  UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor);
+
+  bool
+  MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) const;
 
   virtual void
   GetScope(nsAString& aScope) const = 0;
 
   virtual ServiceWorkerUpdateViaCache
   GetUpdateViaCache(ErrorResult& aRv) const = 0;
 
   virtual already_AddRefed<Promise>
@@ -80,15 +87,18 @@ public:
 protected:
   ServiceWorkerRegistration(nsPIDOMWindowInner* aWindow,
                             const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
   virtual ~ServiceWorkerRegistration()
   { }
 
   ServiceWorkerRegistrationDescriptor mDescriptor;
+  RefPtr<ServiceWorker> mInstallingWorker;
+  RefPtr<ServiceWorker> mWaitingWorker;
+  RefPtr<ServiceWorker> mActiveWorker;
 };
 
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_ServiceWorkerRegistration_h */
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -92,99 +92,43 @@ ServiceWorkerRegistrationMainThread::Sto
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (swm) {
     swm->RemoveRegistrationEventListener(mScope, this);
   }
   mListeningForEvents = false;
 }
 
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationMainThread::GetInstalling()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  RefPtr<ServiceWorker> ret = mInstallingWorker;
-  return ret.forget();
-}
-
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationMainThread::GetWaiting()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  RefPtr<ServiceWorker> ret = mWaitingWorker;
-  return ret.forget();
-}
-
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationMainThread::GetActive()
-{
-  MOZ_ASSERT(NS_IsMainThread());
-  RefPtr<ServiceWorker> ret = mActiveWorker;
-  return ret.forget();
-}
-
 void
 ServiceWorkerRegistrationMainThread::UpdateFound()
 {
   DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
 }
 
 void
 ServiceWorkerRegistrationMainThread::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  MOZ_DIAGNOSTIC_ASSERT(MatchesDescriptor(aDescriptor));
-
-  mDescriptor = aDescriptor;
-
-  nsCOMPtr<nsIGlobalObject> global = GetParentObject();
-  if (!global) {
-    mInstallingWorker = nullptr;
-    mWaitingWorker = nullptr;
-    mActiveWorker = nullptr;
-    return;
-  }
-
-  Maybe<ServiceWorkerDescriptor> active = aDescriptor.GetActive();
-  if (active.isSome()) {
-    mActiveWorker = global->GetOrCreateServiceWorker(active.ref());
-  } else {
-    mActiveWorker = nullptr;
-  }
-
-  Maybe<ServiceWorkerDescriptor> waiting = aDescriptor.GetWaiting();
-  if (waiting.isSome()) {
-    mWaitingWorker = global->GetOrCreateServiceWorker(waiting.ref());
-  } else {
-    mWaitingWorker = nullptr;
-  }
-
-  Maybe<ServiceWorkerDescriptor> installing = aDescriptor.GetInstalling();
-  if (installing.isSome()) {
-    mInstallingWorker = global->GetOrCreateServiceWorker(installing.ref());
-  } else {
-    mInstallingWorker = nullptr;
-  }
+  ServiceWorkerRegistration::UpdateState(aDescriptor);
 }
 
 void
 ServiceWorkerRegistrationMainThread::RegistrationRemoved()
 {
   // If the registration is being removed completely, remove it from the
   // window registration hash table so that a new registration would get a new
   // wrapper JS object.
   if (nsCOMPtr<nsPIDOMWindowInner> window = GetOwner()) {
     window->InvalidateServiceWorkerRegistration(mScope);
   }
 }
 
 bool
 ServiceWorkerRegistrationMainThread::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  return aDescriptor.PrincipalInfo() == mDescriptor.PrincipalInfo() &&
-         aDescriptor.Scope() == mDescriptor.Scope();
+  return ServiceWorkerRegistration::MatchesDescriptor(aDescriptor);
 }
 
 namespace {
 
 void
 UpdateInternal(nsIPrincipal* aPrincipal,
                const nsAString& aScope,
                ServiceWorkerUpdateFinishCallback* aCallback)
@@ -878,37 +822,16 @@ ServiceWorkerRegistrationWorkerThread::S
 }
 
 ServiceWorkerRegistrationWorkerThread::~ServiceWorkerRegistrationWorkerThread()
 {
   ReleaseListener();
   MOZ_ASSERT(!mListener);
 }
 
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationWorkerThread::GetInstalling()
-{
-  // FIXME(nsm): Will be implemented after Bug 1113522.
-  return nullptr;
-}
-
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationWorkerThread::GetWaiting()
-{
-  // FIXME(nsm): Will be implemented after Bug 1113522.
-  return nullptr;
-}
-
-already_AddRefed<ServiceWorker>
-ServiceWorkerRegistrationWorkerThread::GetActive()
-{
-  // FIXME(nsm): Will be implemented after Bug 1113522.
-  return nullptr;
-}
-
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::Update(ErrorResult& aRv)
 {
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
 
   RefPtr<Promise> promise = Promise::Create(worker->GlobalScope(), aRv);
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
@@ -47,25 +47,16 @@ public:
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
-  already_AddRefed<ServiceWorker>
-  GetInstalling() override;
-
-  already_AddRefed<ServiceWorker>
-  GetWaiting() override;
-
-  already_AddRefed<ServiceWorker>
-  GetActive() override;
-
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
 
   // DOMEventTargethelper
   void DisconnectFromOwner() override
   {
     StopListeningForEvents();
     ServiceWorkerRegistration::DisconnectFromOwner();
@@ -136,24 +127,16 @@ private:
   StartListeningForEvents();
 
   void
   StopListeningForEvents();
 
   const nsString mScope;
   bool mListeningForEvents;
 
-  // The following properties are cached here to ensure JS equality is satisfied
-  // instead of acquiring a new worker instance from the ServiceWorkerManager
-  // for every access. A null value is considered a cache miss.
-  // These three may change to a new worker at any time.
-  RefPtr<ServiceWorker> mInstallingWorker;
-  RefPtr<ServiceWorker> mWaitingWorker;
-  RefPtr<ServiceWorker> mActiveWorker;
-
   RefPtr<PushManager> mPushManager;
 };
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener;
 
@@ -180,25 +163,16 @@ public:
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
-  already_AddRefed<ServiceWorker>
-  GetInstalling() override;
-
-  already_AddRefed<ServiceWorker>
-  GetWaiting() override;
-
-  already_AddRefed<ServiceWorker>
-  GetActive() override;
-
   void
   GetScope(nsAString& aScope) const override
   {
     aScope = mScope;
   }
 
   ServiceWorkerUpdateViaCache
   GetUpdateViaCache(ErrorResult& aRv) const override
