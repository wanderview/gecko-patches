# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dd85a06da49aa4d1b93cefff5be2b4d8f5f0d695
Bug 1237455 P4 Create helper method to set fetch request headers. r=ehsan

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -244,35 +244,17 @@ FetchDriver::HttpFetch()
   if (httpChan) {
     // Copy the method.
     nsAutoCString method;
     mRequest->GetMethod(method);
     rv = httpChan->SetRequestMethod(method);
     NS_ENSURE_SUCCESS(rv, rv);
 
     // Set the same headers.
-    nsAutoTArray<InternalHeaders::Entry, 5> headers;
-    mRequest->Headers()->GetEntries(headers);
-    bool hasAccept = false;
-    for (uint32_t i = 0; i < headers.Length(); ++i) {
-      if (!hasAccept && headers[i].mName.EqualsLiteral("accept")) {
-        hasAccept = true;
-      }
-      if (headers[i].mValue.IsEmpty()) {
-        httpChan->SetEmptyRequestHeader(headers[i].mName);
-      } else {
-        httpChan->SetRequestHeader(headers[i].mName, headers[i].mValue, false /* merge */);
-      }
-    }
-
-    if (!hasAccept) {
-      httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept"),
-                                 NS_LITERAL_CSTRING("*/*"),
-                                 false /* merge */);
-    }
+    SetRequestHeaders(httpChan);
 
     // Step 2. Set the referrer.
     nsAutoString referrer;
     mRequest->GetReferrer(referrer);
     if (referrer.EqualsLiteral(kFETCH_CLIENT_REFERRER_STR)) {
       rv = nsContentUtils::SetFetchReferrerURIWithPolicy(mPrincipal,
                                                          mDocument,
                                                          httpChan);
@@ -295,26 +277,16 @@ FetchDriver::HttpFetch()
 
       rv =
         httpChan->SetReferrerWithPolicy(referrerURI,
                                         mDocument ? mDocument->GetReferrerPolicy() :
                                                     net::RP_Default);
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
-    // Step 3 "If HTTPRequest's force Origin header flag is set..."
-    if (mRequest->ForceOriginHeader()) {
-      nsAutoString origin;
-      rv = nsContentUtils::GetUTFOrigin(mPrincipal, origin);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      httpChan->SetRequestHeader(NS_LITERAL_CSTRING("origin"),
-                                 NS_ConvertUTF16toUTF8(origin),
-                                 false /* merge */);
-    }
     // Bug 1120722 - Authorization will be handled later.
     // Auth may require prompting, we don't support it yet.
     // The next patch in this same bug prevents this from aborting the request.
     // Credentials checks for CORS are handled by nsCORSListenerProxy,
 
     nsCOMPtr<nsIHttpChannelInternal> internalChan = do_QueryInterface(httpChan);
 
     // Conversion between enumerations is safe due to static asserts in
@@ -709,10 +681,45 @@ FetchDriver::GetInterface(const nsIID& a
 void
 FetchDriver::SetDocument(nsIDocument* aDocument)
 {
   // Cannot set document after Fetch() has been called.
   MOZ_ASSERT(!mFetchCalled);
   mDocument = aDocument;
 }
 
+void
+FetchDriver::SetRequestHeaders(nsIHttpChannel* aChannel) const
+{
+  MOZ_ASSERT(aChannel);
+
+  nsAutoTArray<InternalHeaders::Entry, 5> headers;
+  mRequest->Headers()->GetEntries(headers);
+  bool hasAccept = false;
+  for (uint32_t i = 0; i < headers.Length(); ++i) {
+    if (!hasAccept && headers[i].mName.EqualsLiteral("accept")) {
+      hasAccept = true;
+    }
+    if (headers[i].mValue.IsEmpty()) {
+      aChannel->SetEmptyRequestHeader(headers[i].mName);
+    } else {
+      aChannel->SetRequestHeader(headers[i].mName, headers[i].mValue, false /* merge */);
+    }
+  }
+
+  if (!hasAccept) {
+    aChannel->SetRequestHeader(NS_LITERAL_CSTRING("accept"),
+                               NS_LITERAL_CSTRING("*/*"),
+                               false /* merge */);
+  }
+
+  if (mRequest->ForceOriginHeader()) {
+    nsAutoString origin;
+    if (NS_SUCCEEDED(nsContentUtils::GetUTFOrigin(mPrincipal, origin))) {
+      aChannel->SetRequestHeader(NS_LITERAL_CSTRING("origin"),
+                                 NS_ConvertUTF16toUTF8(origin),
+                                 false /* merge */);
+    }
+  }
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/FetchDriver.h b/dom/fetch/FetchDriver.h
--- a/dom/fetch/FetchDriver.h
+++ b/dom/fetch/FetchDriver.h
@@ -94,14 +94,16 @@ private:
   // Returns the filtered response sent to the observer.
   // Callers who don't have access to a channel can pass null for aFinalURI.
   already_AddRefed<InternalResponse>
   BeginAndGetFilteredResponse(InternalResponse* aResponse, nsIURI* aFinalURI,
                               bool aFoundOpaqueRedirect);
   // Utility since not all cases need to do any post processing of the filtered
   // response.
   nsresult FailWithNetworkError();
+
+  void SetRequestHeaders(nsIHttpChannel* aChannel) const;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_FetchDriver_h
