# HG changeset patch
# Parent 2f54c9ec3de088f27db8e7b2d756dfb5e6442bc6
# User Ben Kelly <ben@wanderview.com>
Improve worker LoadContext patch.  Unbreak non-unified build.


diff --git a/docshell/base/LoadContext.cpp b/docshell/base/LoadContext.cpp
--- a/docshell/base/LoadContext.cpp
+++ b/docshell/base/LoadContext.cpp
@@ -5,16 +5,35 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/LoadContext.h"
 
 namespace mozilla {
 
 NS_IMPL_ISUPPORTS(LoadContext, nsILoadContext, nsIInterfaceRequestor)
 
+// static
+nsresult
+LoadContext::ForPrincipal(nsIPrincipal* aPrincipal,
+                          LoadContext** aLoadContextOut)
+{
+  uint32_t appId;
+  nsresult rv = aPrincipal->GetAppId(&appId);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsRefPtr<LoadContext> ref = new LoadContext(appId, inBrowserElement);
+  ref.forget(aLoadContextOut);
+
+  return NS_OK;
+}
+
 //-----------------------------------------------------------------------------
 // LoadContext::nsILoadContext
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 LoadContext::GetAssociatedWindow(nsIDOMWindow**)
 {
   MOZ_ASSERT(mIsNotNull);
diff --git a/docshell/base/LoadContext.h b/docshell/base/LoadContext.h
--- a/docshell/base/LoadContext.h
+++ b/docshell/base/LoadContext.h
@@ -100,30 +100,36 @@ public:
     , mUsePrivateBrowsing(false)
     , mUseRemoteTabs(false)
     , mIsInBrowserElement(false)
 #ifdef DEBUG
     , mIsNotNull(true)
 #endif
   {}
 
-  // Constructor taking appId/inBrowsingElement for use in fetch()
+  // Constructor taking appId and browser flag for creating a context
+  // for a specific principal.
   LoadContext(uint32_t aAppId, bool aIsInBrowserElement)
     : mTopFrameElement(nullptr)
     , mNestedFrameId(0)
     , mAppId(aAppId)
     , mIsContent(false)
     , mUsePrivateBrowsing(false)
     , mUseRemoteTabs(false)
     , mIsInBrowserElement(aIsInBrowserElement)
 #ifdef DEBUG
     , mIsNotNull(true)
 #endif
   {}
 
+  // Convenience factory method to create a load context with the
+  // principal's appID and browser flag.
+  static nsresult
+  ForPrincipal(nsIPrincipal* aPrincipal, LoadContext** aLoadContextOut);
+
 private:
   ~LoadContext() {}
 
   nsWeakPtr     mTopFrameElement;
   uint64_t      mNestedFrameId;
   uint32_t      mAppId;
   bool          mIsContent;
   bool          mUsePrivateBrowsing;
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -39,16 +39,18 @@
 #define MAX_CONCURRENT_SCRIPTS 1000
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::dom::workers::exceptions::ThrowDOMExceptionForNSResult;
 
 namespace {
 
+using mozilla::LoadContext;
+
 nsresult
 ChannelFromScriptURL(nsIPrincipal* principal,
                      nsIURI* baseURI,
                      nsIDocument* parentDoc,
                      nsILoadGroup* loadGroup,
                      nsIIOService* ios,
                      nsIScriptSecurityManager* secMan,
                      const nsAString& aScriptURL,
@@ -98,42 +100,49 @@ ChannelFromScriptURL(nsIPrincipal* princ
     rv = principal->CheckMayLoad(uri, false, true);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
   else {
     rv = secMan->CheckLoadURIWithPrincipal(principal, uri, 0);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
 
+  // Try to determine if the load group already has a load context
+  nsCOMPtr<nsILoadContext> existingLoadContext;
+  if (loadGroup) {
+    nsCOMPtr<nsIInterfaceRequestor> callbacks;
+    rv = loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    existingLoadContext = do_QueryInterface(callbacks);
+  }
+
+  // If there is no load context then we need to set one in order for the
+  // principal to make it through the channel successfully.
+  nsRefPtr<LoadContext> loadContext;
+  if (!existingLoadContext) {
+    rv = LoadContext::ForPrincipal(principal, getter_AddRefs(loadContext));
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   uint32_t flags = nsIRequest::LOAD_NORMAL | nsIChannel::LOAD_CLASSIFY_URI;
 
   nsCOMPtr<nsIChannel> channel;
   // If we have the document, use it
   if (parentDoc) {
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        parentDoc,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
-                       nullptr, // aCallbacks
+                       loadContext,
                        flags,
                        ios);
   } else {
-    uint32_t appId;
-    rv = principal->GetAppId(&appId);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    bool inBrowserElement;
-    rv = principal->GetIsInBrowserElement(&inBrowserElement);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    nsRefPtr<LoadContext> loadContext = new LoadContext(appId,
-                                                        inBrowserElement);
-
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        principal,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
                        loadContext,
                        flags,
