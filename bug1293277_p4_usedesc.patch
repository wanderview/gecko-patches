# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a42e3165b0c39eae8bc9d03b725b9499f4a02d42
Bug 1293277 P4 Use the ServiceWorkerDescriptor in existing WorkerPrivate and ServiceWorkerInfo code. r=baku

diff --git a/dom/workers/ServiceWorkerInfo.cpp b/dom/workers/ServiceWorkerInfo.cpp
--- a/dom/workers/ServiceWorkerInfo.cpp
+++ b/dom/workers/ServiceWorkerInfo.cpp
@@ -43,17 +43,17 @@ ServiceWorkerInfo::GetCacheName(nsAStrin
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetState(uint16_t* aState)
 {
   MOZ_ASSERT(aState);
   AssertIsOnMainThread();
-  *aState = static_cast<uint16_t>(mState);
+  *aState = static_cast<uint16_t>(State());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetDebugger(nsIWorkerDebugger** aResult)
 {
   if (NS_WARN_IF(!aResult)) {
     return NS_ERROR_FAILURE;
@@ -179,71 +179,78 @@ private:
 void
 ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
 {
   AssertIsOnMainThread();
 #ifdef DEBUG
   // Any state can directly transition to redundant, but everything else is
   // ordered.
   if (aState != ServiceWorkerState::Redundant) {
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::EndGuard_, aState == ServiceWorkerState::Installing);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installing, aState == ServiceWorkerState::Installed);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installed, aState == ServiceWorkerState::Activating);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Activating, aState == ServiceWorkerState::Activated);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::EndGuard_,
+                  aState == ServiceWorkerState::Installing);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Installing,
+                  aState == ServiceWorkerState::Installed);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Installed,
+                  aState == ServiceWorkerState::Activating);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Activating,
+                  aState == ServiceWorkerState::Activated);
   }
   // Activated can only go to redundant.
-  MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
+  MOZ_ASSERT_IF(State() == ServiceWorkerState::Activated,
+                aState == ServiceWorkerState::Redundant);
 #endif
   // Flush any pending functional events to the worker when it transitions to the
   // activated state.
   // TODO: Do we care that these events will race with the propagation of the
   //       state change?
-  if (aState == ServiceWorkerState::Activated && mState != aState) {
-    mServiceWorkerPrivate->Activated();
+  if (State() == aState) {
+    mServiceWorkerPrivate->UpdateState(aState);
   }
-  mState = aState;
-  nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
+  mDescriptor.SetState(aState);
+  nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, State());
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
-  if (mState == ServiceWorkerState::Redundant) {
+  if (State() == ServiceWorkerState::Redundant) {
     serviceWorkerScriptCache::PurgeCache(mPrincipal, mCacheName);
   }
 }
 
 ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                                      const nsACString& aScope,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName,
                                      nsLoadFlags aImportsLoadFlags)
   : mPrincipal(aPrincipal)
-  , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mCacheName(aCacheName)
-  , mState(ServiceWorkerState::EndGuard_)
   , mImportsLoadFlags(aImportsLoadFlags)
-  , mServiceWorkerID(GetNextID())
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mInstalledTime(0)
   , mActivatedTime(0)
   , mRedundantTime(0)
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
   , mSkipWaitingFlag(false)
   , mHandlesFetch(Unknown)
 {
   MOZ_ASSERT(mPrincipal);
   // cache origin attributes so we can use them off main thread
   mOriginAttributes = mPrincipal->OriginAttributesRef();
-  MOZ_ASSERT(!mScope.IsEmpty());
   MOZ_ASSERT(!mScriptSpec.IsEmpty());
   MOZ_ASSERT(!mCacheName.IsEmpty());
 
   // Scripts of a service worker should always be loaded bypass service workers.
   // Otherwise, we might not be able to update a service worker correctly, if
   // there is a service worker generating the script.
   MOZ_DIAGNOSTIC_ASSERT(mImportsLoadFlags & nsIChannel::LOAD_BYPASS_SERVICE_WORKER);
+
+  PrincipalInfo principalInfo;
+  MOZ_ALWAYS_SUCCEEDS(PrincipalToPrincipalInfo(aPrincipal, &principalInfo));
+
+  mDescriptor = ServiceWorkerDescriptor(GetNextID(), principalInfo, aScope,
+                                        ServiceWorkerState::Parsed);
 }
 
 ServiceWorkerInfo::~ServiceWorkerInfo()
 {
   MOZ_ASSERT(mServiceWorkerPrivate);
   mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
 }
 
@@ -276,39 +283,39 @@ ServiceWorkerInfo::GetOrCreateInstance(n
   }
 
   return ref.forget();
 }
 
 void
 ServiceWorkerInfo::UpdateInstalledTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Installed);
+  MOZ_ASSERT(State() == ServiceWorkerState::Installed);
   MOZ_ASSERT(mInstalledTime == 0);
 
   mInstalledTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 void
 ServiceWorkerInfo::UpdateActivatedTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Activated);
+  MOZ_ASSERT(State() == ServiceWorkerState::Activated);
   MOZ_ASSERT(mActivatedTime == 0);
 
   mActivatedTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 void
 ServiceWorkerInfo::UpdateRedundantTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Redundant);
+  MOZ_ASSERT(State() == ServiceWorkerState::Redundant);
   MOZ_ASSERT(mRedundantTime == 0);
 
   mRedundantTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -23,36 +23,31 @@ class ServiceWorkerPrivate;
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
 class ServiceWorkerInfo final : public nsIServiceWorkerInfo
 {
 private:
   nsCOMPtr<nsIPrincipal> mPrincipal;
-  const nsCString mScope;
+  ServiceWorkerDescriptor mDescriptor;
   const nsCString mScriptSpec;
   const nsString mCacheName;
-  ServiceWorkerState mState;
   OriginAttributes mOriginAttributes;
 
   // This LoadFlags is only applied to imported scripts, since the main script
   // has already been downloaded when performing the bytecheck. This LoadFlag is
   // composed of three parts:
   //   1. nsIChannel::LOAD_BYPASS_SERVICE_WORKER
   //   2. (Optional) nsIRequest::VALIDATE_ALWAYS
   //      depends on ServiceWorkerUpdateViaCache of its registration.
   //   3. (optional) nsIRequest::LOAD_BYPASS_CACHE
   //      depends on whether the update timer is expired.
   const nsLoadFlags mImportsLoadFlags;
 
-  // This id is shared with WorkerPrivate to match requests issued by service
-  // workers to their corresponding serviceWorkerInfo.
-  uint64_t mServiceWorkerID;
-
   // Timestamp to track SW's state
   PRTime mCreationTime;
   TimeStamp mCreationTimeStamp;
 
   // The time of states are 0, if SW has not reached that state yet. Besides, we
   // update each of them after UpdateState() is called in SWRegistrationInfo.
   PRTime mInstalledTime;
   PRTime mActivatedTime;
@@ -101,17 +96,17 @@ public:
   ScriptSpec() const
   {
     return mScriptSpec;
   }
 
   const nsCString&
   Scope() const
   {
-    return mScope;
+    return mDescriptor.Scope();
   }
 
   bool SkipWaitingFlag() const
   {
     AssertIsOnMainThread();
     return mSkipWaitingFlag;
   }
 
@@ -125,17 +120,17 @@ public:
                     const nsACString& aScope,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName,
                     nsLoadFlags aLoadFlags);
 
   ServiceWorkerState
   State() const
   {
-    return mState;
+    return mDescriptor.State();
   }
 
   const OriginAttributes&
   GetOriginAttributes() const
   {
     return mOriginAttributes;
   }
 
@@ -149,28 +144,34 @@ public:
   GetImportsLoadFlags() const
   {
     return mImportsLoadFlags;
   }
 
   uint64_t
   ID() const
   {
-    return mServiceWorkerID;
+    return mDescriptor.Id();
+  }
+
+  const ServiceWorkerDescriptor&
+  Descriptor() const
+  {
+    return mDescriptor;
   }
 
   void
   UpdateState(ServiceWorkerState aState);
 
   // Only used to set initial state when loading from disk!
   void
   SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
   {
     AssertIsOnMainThread();
-    mState = aState;
+    mDescriptor.SetState(aState);
   }
 
   void
   SetHandlesFetch(bool aHandlesFetch)
   {
     AssertIsOnMainThread();
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch == Unknown);
     mHandlesFetch = aHandlesFetch ? Enabled : Disabled;
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -1801,17 +1801,26 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   info.mResolvedScriptURI = info.mBaseURI;
   MOZ_ASSERT(!mInfo->CacheName().IsEmpty());
   info.mServiceWorkerCacheName = mInfo->CacheName();
-  info.mServiceWorkerID = mInfo->ID();
+
+  PrincipalInfo principalInfo;
+  rv = PrincipalToPrincipalInfo(mInfo->Principal(), &principalInfo);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  info.mServiceWorkerDescriptor.emplace(ServiceWorkerDescriptor(mInfo->ID(),
+                                                                principalInfo,
+                                                                mInfo->Scope(),
+                                                                mInfo->State()));
+
   info.mLoadGroup = aLoadGroup;
   info.mLoadFailedAsyncRunnable = aLoadFailedRunnable;
 
   // If we are loading a script for a ServiceWorker then we must not
   // try to intercept it.  If the interception matches the current
   // ServiceWorker's scope then we could deadlock the load.
   info.mLoadFlags = mInfo->GetImportsLoadFlags() |
                     nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
@@ -1939,25 +1948,58 @@ ServiceWorkerPrivate::TerminateWorker()
 void
 ServiceWorkerPrivate::NoteDeadServiceWorkerInfo()
 {
   AssertIsOnMainThread();
   mInfo = nullptr;
   TerminateWorker();
 }
 
+namespace {
+
+class UpdateStateControlRunnable final : public MainThreadWorkerControlRunnable
+{
+  const ServiceWorkerState mState;
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->UpdateServiceWorkerState(mState);
+    return true;
+  }
+
+public:
+  UpdateStateControlRunnable(WorkerPrivate* aWorkerPrivate,
+                             ServiceWorkerState aState)
+    : MainThreadWorkerControlRunnable(aWorkerPrivate)
+    , mState(aState)
+  {
+  }
+};
+
+} // anonymous namespace
+
 void
-ServiceWorkerPrivate::Activated()
+ServiceWorkerPrivate::UpdateState(ServiceWorkerState aState)
 {
   AssertIsOnMainThread();
 
-  // If we had to queue up events due to the worker activating, that means
-  // the worker must be currently running.  We should be called synchronously
-  // when the worker becomes activated.
-  MOZ_ASSERT_IF(!mPendingFunctionalEvents.IsEmpty(), mWorkerPrivate);
+  if (!mWorkerPrivate) {
+    MOZ_DIAGNOSTIC_ASSERT(mPendingFunctionalEvents.IsEmpty());
+    return;
+  }
+
+  RefPtr<WorkerRunnable> r =
+    new UpdateStateControlRunnable(mWorkerPrivate, aState);
+  Unused << r->Dispatch();
+
+  if (aState != ServiceWorkerState::Activated) {
+    return;
+  }
 
   nsTArray<RefPtr<WorkerRunnable>> pendingEvents;
   mPendingFunctionalEvents.SwapElements(pendingEvents);
 
   for (uint32_t i = 0; i < pendingEvents.Length(); ++i) {
     RefPtr<WorkerRunnable> r = pendingEvents[i].forget();
     if (NS_WARN_IF(!r->Dispatch())) {
       NS_WARNING("Failed to dispatch pending functional event!");
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -140,17 +140,17 @@ public:
 
   void
   NoteDeadServiceWorkerInfo();
 
   void
   NoteStoppedControllingDocuments();
 
   void
-  Activated();
+  UpdateState(ServiceWorkerState aState);
 
   nsresult
   GetDebugger(nsIWorkerDebugger** aResult);
 
   nsresult
   AttachDebugger();
 
   nsresult
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -1782,17 +1782,16 @@ public:
 NS_IMPL_ISUPPORTS(WorkerEventTarget, nsIEventTarget,
                                             nsISerialEventTarget)
 
 END_WORKERS_NAMESPACE
 
 WorkerLoadInfo::WorkerLoadInfo()
   : mLoadFlags(nsIRequest::LOAD_NORMAL)
   , mWindowID(UINT64_MAX)
-  , mServiceWorkerID(0)
   , mReferrerPolicy(net::RP_Unset)
   , mFromWindow(false)
   , mEvalAllowed(false)
   , mReportCSPViolations(false)
   , mXHRParamsAllowed(false)
   , mPrincipalIsSystem(false)
   , mStorageAllowed(false)
   , mServiceWorkersTestingInWindow(false)
@@ -1839,19 +1838,19 @@ WorkerLoadInfo::StealFrom(WorkerLoadInfo
   aOther.mInterfaceRequestor.swap(mInterfaceRequestor);
 
   MOZ_ASSERT(!mPrincipalInfo);
   mPrincipalInfo = aOther.mPrincipalInfo.forget();
 
   mDomain = aOther.mDomain;
   mOrigin = aOther.mOrigin;
   mServiceWorkerCacheName = aOther.mServiceWorkerCacheName;
+  mServiceWorkerDescriptor = aOther.mServiceWorkerDescriptor;
   mLoadFlags = aOther.mLoadFlags;
   mWindowID = aOther.mWindowID;
-  mServiceWorkerID = aOther.mServiceWorkerID;
   mReferrerPolicy = aOther.mReferrerPolicy;
   mFromWindow = aOther.mFromWindow;
   mEvalAllowed = aOther.mEvalAllowed;
   mReportCSPViolations = aOther.mReportCSPViolations;
   mXHRParamsAllowed = aOther.mXHRParamsAllowed;
   mPrincipalIsSystem = aOther.mPrincipalIsSystem;
   mStorageAllowed = aOther.mStorageAllowed;
   mServiceWorkersTestingInWindow = aOther.mServiceWorkersTestingInWindow;
@@ -2822,17 +2821,17 @@ WorkerPrivateParent<Derived>::WorkerPriv
                                            bool aIsChromeWorker,
                                            WorkerType aWorkerType,
                                            const nsAString& aWorkerName,
                                            const nsACString& aServiceWorkerScope,
                                            WorkerLoadInfo& aLoadInfo)
 : mMutex("WorkerPrivateParent Mutex"),
   mCondVar(mMutex, "WorkerPrivateParent CondVar"),
   mParent(aParent), mScriptURL(aScriptURL),
-  mWorkerName(aWorkerName), mServiceWorkerScope(aServiceWorkerScope),
+  mWorkerName(aWorkerName),
   mLoadingWorkerScript(false), mBusyCount(0), mParentWindowPausedDepth(0),
   mParentStatus(Pending), mParentFrozen(false),
   mIsChromeWorker(aIsChromeWorker), mMainThreadObjectsForgotten(false),
   mIsSecureContext(false), mWorkerType(aWorkerType),
   mCreationTimeStamp(TimeStamp::Now()),
   mCreationTimeHighRes((double)PR_Now() / PR_USEC_PER_MSEC)
 {
   MOZ_ASSERT_IF(!IsDedicatedWorker(), NS_IsMainThread());
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -214,18 +214,16 @@ protected:
   // Protected by mMutex.
   nsTArray<RefPtr<WorkerRunnable>> mPreStartRunnables;
 
 private:
   WorkerPrivate* mParent;
   nsString mScriptURL;
   // This is the worker name for shared workers and dedicated workers.
   nsString mWorkerName;
-  // This is the worker scope for service workers.
-  nsCString mServiceWorkerScope;
   LocationInfo mLocationInfo;
   // The lifetime of these objects within LoadInfo is managed explicitly;
   // they do not need to be cycle collected.
   WorkerLoadInfo mLoadInfo;
 
   Atomic<bool> mLoadingWorkerScript;
 
   // Only used for top level workers.
@@ -518,24 +516,23 @@ public:
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
   uint64_t
   ServiceWorkerID() const
   {
-    return mLoadInfo.mServiceWorkerID;
+    return GetServiceWorkerDescriptor().Id();
   }
 
   const nsCString&
   ServiceWorkerScope() const
   {
-    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
-    return mServiceWorkerScope;
+    return GetServiceWorkerDescriptor().Scope();
   }
 
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
@@ -548,21 +545,37 @@ public:
   {
     AssertIsOnMainThread();
     return mLoadInfo.mResolvedScriptURI;
   }
 
   const nsString&
   ServiceWorkerCacheName() const
   {
-    MOZ_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
     AssertIsOnMainThread();
     return mLoadInfo.mServiceWorkerCacheName;
   }
 
+  const ServiceWorkerDescriptor&
+  GetServiceWorkerDescriptor() const
+  {
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
+    return mLoadInfo.mServiceWorkerDescriptor.ref();
+  }
+
+  void
+  UpdateServiceWorkerState(ServiceWorkerState aState)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
+    MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
+    return mLoadInfo.mServiceWorkerDescriptor.ref().SetState(aState);
+  }
+
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mLoadInfo.mChannelInfo;
   }
 
   void
   SetChannelInfo(const ChannelInfo& aChannelInfo)
diff --git a/dom/workers/Workers.h b/dom/workers/Workers.h
--- a/dom/workers/Workers.h
+++ b/dom/workers/Workers.h
@@ -17,16 +17,17 @@
 #include "nsDebug.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 #include "nsILoadContext.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsIInterfaceRequestor.h"
 #include "mozilla/dom/ChannelInfo.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/net/ReferrerPolicy.h"
 
 #define BEGIN_WORKERS_NAMESPACE \
   namespace mozilla { namespace dom { namespace workers {
 #define END_WORKERS_NAMESPACE \
   } /* namespace workers */ } /* namespace dom */ } /* namespace mozilla */
 #define USING_WORKERS_NAMESPACE \
   using namespace mozilla::dom::workers;
@@ -240,22 +241,22 @@ struct WorkerLoadInfo
   // Only set if we have a custom overriden load group
   RefPtr<InterfaceRequestor> mInterfaceRequestor;
 
   nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
   nsCString mDomain;
   nsString mOrigin; // Derived from mPrincipal; can be used on worker thread.
 
   nsString mServiceWorkerCacheName;
+  Maybe<ServiceWorkerDescriptor> mServiceWorkerDescriptor;
 
   ChannelInfo mChannelInfo;
   nsLoadFlags mLoadFlags;
 
   uint64_t mWindowID;
-  uint64_t mServiceWorkerID;
 
   net::ReferrerPolicy mReferrerPolicy;
   bool mFromWindow;
   bool mEvalAllowed;
   bool mReportCSPViolations;
   bool mXHRParamsAllowed;
   bool mPrincipalIsSystem;
   bool mStorageAllowed;
