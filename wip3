# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  782ae3cc4cc4a468aa5016fd97964257fb760b91

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -60,60 +60,47 @@ namespace {
 void
 TimerCallback(nsITimer*, void* aClosure)
 {
   RefPtr<Timeout> timeout = (Timeout*)aClosure;
   timeout->mWindow->RunTimeout(timeout);
 }
 
 void
-TimerTaskQueueCallback(nsITimer* aTimer, void* aClosure)
-{
-  RefPtr<Timeout> timeout = (Timeout*)aClosure;
-  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction([timeout] {
-    TimerCallback(nullptr, timeout);
-  });
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
-}
-
-void
 TimerNameCallback(nsITimer* aTimer, void* aClosure, char* aBuf, size_t aLen)
 {
   RefPtr<Timeout> timeout = (Timeout*)aClosure;
 
   const char* filename;
   uint32_t lineNum, column;
   timeout->mScriptHandler->GetLocation(&filename, &lineNum, &column);
   snprintf(aBuf, aLen, "[content] %s:%u:%u", filename, lineNum, column);
 }
 
 } // anonymous namespace
 
 nsresult
-Timeout::InitTimer(nsIEventTarget* aTaskQueue, uint32_t aDelay)
+Timeout::InitTimer(nsIEventTarget* aTarget, uint32_t aDelay)
 {
   // If the given target does not match the timer's current target
   // then we need to override it before the Init.  Note that GetTarget()
   // will return the current thread after setting the target to nullptr.
   // So we need to special case the nullptr target comparison.
   nsCOMPtr<nsIEventTarget> currentTarget;
   MOZ_ALWAYS_SUCCEEDS(mTimer->GetTarget(getter_AddRefs(currentTarget)));
-  if ((aTaskQueue && currentTarget != aTaskQueue) ||
-      (!aTaskQueue && currentTarget != NS_GetCurrentThread())) {
+  if ((aTarget && currentTarget != aTarget) ||
+      (!aTarget && currentTarget != NS_GetCurrentThread())) {
     // Always call Cancel() in case we are re-using a timer.  Otherwise
     // the subsequent SetTarget() may fail.
     MOZ_ALWAYS_SUCCEEDS(mTimer->Cancel());
-    MOZ_ALWAYS_SUCCEEDS(mTimer->SetTarget(aTaskQueue));
+    MOZ_ALWAYS_SUCCEEDS(mTimer->SetTarget(aTarget));
   }
 
-  nsTimerCallbackFunc callback =
-    aTaskQueue ? TimerTaskQueueCallback : TimerCallback;
-
   return mTimer->InitWithNameableFuncCallback(
-    callback, this, aDelay, nsITimer::TYPE_ONE_SHOT, TimerNameCallback);
+    TimerCallback, this, aDelay, nsITimer::TYPE_ONE_SHOT, TimerNameCallback);
 }
 
 // Return true if this timeout has a refcount of 1. This is used to check
 // that dummy_timeout doesn't leak from nsGlobalWindow::RunTimeout.
 #ifdef DEBUG
 bool
 Timeout::HasRefCntOne() const
 {
diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -29,20 +29,20 @@ class Timeout final
   : public LinkedListElement<Timeout>
 {
 public:
   Timeout();
 
   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(Timeout)
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(Timeout)
 
-  // The target may be specified to use a particular task queue for the
-  // resulting timer runnable.  A nullptr task queue will result in the
+  // The target may be specified to use a particular event queue for the
+  // resulting timer runnable.  A nullptr target will result in the
   // default main thread being used.
-  nsresult InitTimer(nsIEventTarget* aTaskQueue, uint32_t aDelay);
+  nsresult InitTimer(nsIEventTarget* aTarget, uint32_t aDelay);
 
   enum class Reason { eTimeoutOrInterval, eIdleCallbackTimeout };
 
 #ifdef DEBUG
   bool HasRefCntOne() const;
 #endif // DEBUG
 
   // Window for which this timeout fires
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -11879,17 +11879,17 @@ nsGlobalWindow::Resume()
     uint32_t delay = std::max(remaining, DOMMinTimeoutValue());
 
     t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!t->mTimer) {
       t->remove();
       continue;
     }
 
-    nsresult rv = t->InitTimer(GetTaskQueue(), delay);
+    nsresult rv = t->InitTimer(GetThrottledEventQueue(), delay);
     if (NS_FAILED(rv)) {
       t->mTimer = nullptr;
       t->remove();
       continue;
     }
 
     // Add a reference for the new timer's closure.
     t->AddRef();
@@ -12598,17 +12598,17 @@ nsGlobalWindow::SetTimeoutOrInterval(nsI
     nsresult rv;
     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     RefPtr<Timeout> copy = timeout;
 
-    rv = timeout->InitTimer(GetTaskQueue(), realInterval);
+    rv = timeout->InitTimer(GetThrottledEventQueue(), realInterval);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     // The timeout is now also held in the timer's closure.
     Unused << copy.forget();
   }
 
@@ -12871,17 +12871,17 @@ nsGlobalWindow::RescheduleTimeout(Timeou
     aTimeout->mTimeRemaining = delay;
     return true;
   }
 
   aTimeout->mWhen = currentNow + delay;
 
   // Reschedule the OS timer. Don't bother returning any error codes if
   // this fails since the callers of this method don't care about them.
-  nsresult rv = aTimeout->InitTimer(GetTaskQueue(),
+  nsresult rv = aTimeout->InitTimer(GetThrottledEventQueue(),
                                     delay.ToMilliseconds());
 
   if (NS_FAILED(rv)) {
     NS_ERROR("Error initializing timer for DOM timeout!");
 
     // We failed to initialize the new OS timer, this timer does
     // us no good here so we just cancel it (just in case) and
     // null out the pointer to the OS timer, this will release the
@@ -13197,17 +13197,17 @@ nsresult nsGlobalWindow::ResetTimersForN
       timeout->remove();
       // InsertTimeoutIntoList will addref |timeout| and reset
       // mFiringDepth.  Make sure to undo that after calling it.
       uint32_t firingDepth = timeout->mFiringDepth;
       InsertTimeoutIntoList(timeout);
       timeout->mFiringDepth = firingDepth;
       timeout->Release();
 
-      nsresult rv = timeout->InitTimer(GetTaskQueue(),
+      nsresult rv = timeout->InitTimer(GetThrottledEventQueue(),
                                        delay.ToMilliseconds());
 
       if (NS_FAILED(rv)) {
         NS_WARNING("Error resetting non background timer for DOM timeout!");
         return rv;
       }
 
       timeout = nextTimeout;
