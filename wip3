# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c4d678228926bd2982a895601f520940e2863871

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -56,76 +56,39 @@ CleanupChild(CacheReadStreamOrVoid& aRea
 {
   if (aReadStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
     return;
   }
 
   CleanupChild(aReadStreamOrVoid.get_CacheReadStream(), aAction);
 }
 
-void
-CleanupParentFds(CacheReadStream& aReadStream, CleanupAction aAction)
-{
-  if (aReadStream.stream().type() ==
-      InputStreamParamsWithFdsOrSendStream::T__None) {
-    return;
-  }
-
-  MOZ_ASSERT(aReadStream.stream().type() ==
-             InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds);
-
-  InputStreamParamsWithFds& streamWithFds =
-    aReadStream.stream().get_InputStreamParamsWithFds();
-
-  if (streamWithFds.optionalFds().type() !=
-      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
-    return;
-  }
-
-  AutoTArray<FileDescriptor, 4> fds;
-
-  FileDescriptorSetParent* fdSetActor =
-    static_cast<FileDescriptorSetParent*>(streamWithFds.optionalFds().get_PFileDescriptorSetParent());
-  MOZ_ASSERT(fdSetActor);
-
-  if (aAction == Delete) {
-    Unused << fdSetActor->Send__delete__(fdSetActor);
-  }
-
-  // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
-  // unconditionally forget them here.  The fds themselves are auto-closed in
-  // ~FileDescriptor since they originated in this process.
-  fdSetActor->ForgetFileDescriptors(fds);
-}
-
-void
-CleanupParentFds(CacheReadStreamOrVoid& aReadStreamOrVoid, CleanupAction aAction)
-{
-  if (aReadStreamOrVoid.type() == CacheReadStreamOrVoid::Tvoid_t) {
-    return;
-  }
-
-  CleanupParentFds(aReadStreamOrVoid.get_CacheReadStream(), aAction);
-}
-
 } // namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // --------------------------------------------
 
 AutoChildOpArgs::AutoChildOpArgs(TypeUtils* aTypeUtils,
-                                 const CacheOpArgs& aOpArgs)
+                                 const CacheOpArgs& aOpArgs,
+                                 uint32_t aEntryCount)
   : mTypeUtils(aTypeUtils)
   , mOpArgs(aOpArgs)
   , mSent(false)
 {
   MOZ_ASSERT(mTypeUtils);
+  MOZ_RELEASE_ASSERT(aEntryCount != 0);
+  if (mOpArgs.type() == CacheOpArgs::TCachePutAllArgs) {
+    CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
+    args.requestResponseList().SetCapacity(aEntryCount);
+  } else {
+    MOZ_ASSERT(aEntryCount == 1);
+  }
 }
 
 AutoChildOpArgs::~AutoChildOpArgs()
 {
   CleanupAction action = mSent ? Forget : Delete;
 
   switch(mOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
@@ -173,16 +136,18 @@ AutoChildOpArgs::~AutoChildOpArgs()
       StorageMatchArgs& args = mOpArgs.get_StorageMatchArgs();
       CleanupChild(args.request().body(), action);
       break;
     }
     default:
       // Other types do not need cleanup
       break;
   }
+
+  mStreamCleanupList.Clear();
 }
 
 void
 AutoChildOpArgs::Add(InternalRequest* aRequest, BodyAction aBodyAction,
                      SchemeAction aSchemeAction, ErrorResult& aRv)
 {
   MOZ_ASSERT(!mSent);
 
@@ -353,16 +318,19 @@ AutoChildOpArgs::Add(InternalRequest* aR
       // Throw an error if a request/response pair would mask another
       // request/response pair in the same PutAll operation.  This is
       // step 2.3.2.3 from the "Batch Cache Operations" spec algorithm.
       if (MatchInPutList(aRequest, args.requestResponseList())) {
         aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
         return;
       }
 
+      MOZ_RELEASE_ASSERT(args.requestResponseList().Length() <
+                         args.requestResponseList().Capacity());
+
       // The FileDescriptorSetChild asserts in its destructor that all fds have
       // been removed.  The copy constructor, however, simply duplicates the
       // fds without removing any.  This means each temporary and copy must be
       // explicitly cleaned up.
       //
       // Avoid a lot of this hassle by making sure we only create one here.  On
       // error we remove it.
       CacheRequestResponse& pair = *args.requestResponseList().AppendElement();
@@ -398,83 +366,60 @@ AutoChildOpArgs::SendAsOpArgs()
     autoStream->TakeValue();
   }
   return mOpArgs;
 }
 
 // --------------------------------------------
 
 AutoParentOpResult::AutoParentOpResult(mozilla::ipc::PBackgroundParent* aManager,
-                                       const CacheOpResult& aOpResult)
+                                       const CacheOpResult& aOpResult,
+                                       uint32_t aEntryCount)
   : mManager(aManager)
   , mOpResult(aOpResult)
   , mStreamControl(nullptr)
   , mSent(false)
 {
   MOZ_ASSERT(mManager);
+  MOZ_RELEASE_ASSERT(aEntryCount != 0);
+  if (mOpResult.type() == CacheOpResult::TCacheMatchAllResult) {
+    CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
+    result.responseList().SetCapacity(aEntryCount);
+  } else if (mOpResult.type() == CacheOpResult::TCacheKeysResult) {
+    CacheKeysResult& result = mOpResult.get_CacheKeysResult();
+    result.requestList().SetCapacity(aEntryCount);
+  } else {
+    MOZ_ASSERT(aEntryCount == 1);
+  }
 }
 
 AutoParentOpResult::~AutoParentOpResult()
 {
   CleanupAction action = mSent ? Forget : Delete;
 
   switch (mOpResult.type()) {
-    case CacheOpResult::TCacheMatchResult:
-    {
-      CacheMatchResult& result = mOpResult.get_CacheMatchResult();
-      if (result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t) {
-        break;
-      }
-      CleanupParentFds(result.responseOrVoid().get_CacheResponse().body(),
-                       action);
-      break;
-    }
-    case CacheOpResult::TCacheMatchAllResult:
-    {
-      CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
-      for (uint32_t i = 0; i < result.responseList().Length(); ++i) {
-        CleanupParentFds(result.responseList()[i].body(), action);
-      }
-      break;
-    }
-    case CacheOpResult::TCacheKeysResult:
-    {
-      CacheKeysResult& result = mOpResult.get_CacheKeysResult();
-      for (uint32_t i = 0; i < result.requestList().Length(); ++i) {
-        CleanupParentFds(result.requestList()[i].body(), action);
-      }
-      break;
-    }
-    case CacheOpResult::TStorageMatchResult:
-    {
-      StorageMatchResult& result = mOpResult.get_StorageMatchResult();
-      if (result.responseOrVoid().type() == CacheResponseOrVoid::Tvoid_t) {
-        break;
-      }
-      CleanupParentFds(result.responseOrVoid().get_CacheResponse().body(),
-                       action);
-      break;
-    }
     case CacheOpResult::TStorageOpenResult:
     {
       StorageOpenResult& result = mOpResult.get_StorageOpenResult();
       if (action == Forget || result.actorParent() == nullptr) {
         break;
       }
       Unused << PCacheParent::Send__delete__(result.actorParent());
       break;
     }
     default:
-      // other types do not need clean up
+      // other types do not need additional clean up
       break;
   }
 
   if (action == Delete && mStreamControl) {
     Unused << PCacheStreamControlParent::Send__delete__(mStreamControl);
   }
+
+  mStreamCleanupList.Clear();
 }
 
 void
 AutoParentOpResult::Add(CacheId aOpenedCacheId, Manager* aManager)
 {
   MOZ_ASSERT(mOpResult.type() == CacheOpResult::TStorageOpenResult);
   MOZ_ASSERT(mOpResult.get_StorageOpenResult().actorParent() == nullptr);
   mOpResult.get_StorageOpenResult().actorParent() =
@@ -495,16 +440,18 @@ AutoParentOpResult::Add(const SavedRespo
       result.responseOrVoid() = aSavedResponse.mValue;
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseOrVoid().get_CacheResponse());
       break;
     }
     case CacheOpResult::TCacheMatchAllResult:
     {
       CacheMatchAllResult& result = mOpResult.get_CacheMatchAllResult();
+      MOZ_RELEASE_ASSERT(result.responseList().Length() <
+                         result.responseList().Capacity());
       result.responseList().AppendElement(aSavedResponse.mValue);
       SerializeResponseBody(aSavedResponse, aStreamList,
                             &result.responseList().LastElement());
       break;
     }
     case CacheOpResult::TStorageMatchResult:
     {
       StorageMatchResult& result = mOpResult.get_StorageMatchResult();
@@ -524,16 +471,18 @@ AutoParentOpResult::Add(const SavedReque
                         StreamList* aStreamList)
 {
   MOZ_ASSERT(!mSent);
 
   switch (mOpResult.type()) {
     case CacheOpResult::TCacheKeysResult:
     {
       CacheKeysResult& result = mOpResult.get_CacheKeysResult();
+      MOZ_RELEASE_ASSERT(result.requestList().Length() <
+                         result.requestList().Capacity());
       result.requestList().AppendElement(aSavedRequest.mValue);
       CacheRequest& request = result.requestList().LastElement();
 
       if (!aSavedRequest.mHasBodyId) {
         request.body() = void_t();
         break;
       }
 
@@ -547,16 +496,19 @@ AutoParentOpResult::Add(const SavedReque
   }
 }
 
 const CacheOpResult&
 AutoParentOpResult::SendAsOpResult()
 {
   MOZ_ASSERT(!mSent);
   mSent = true;
+  for (UniquePtr<AutoIPCStream>& autoStream : mStreamCleanupList) {
+    autoStream->TakeValue();
+  }
   return mOpResult;
 }
 
 void
 AutoParentOpResult::SerializeResponseBody(const SavedResponse& aSavedResponse,
                                           StreamList* aStreamList,
                                           CacheResponse* aResponseOut)
 {
@@ -592,18 +544,17 @@ AutoParentOpResult::SerializeReadStream(
     if (!mStreamControl) {
       NS_WARNING("Cache failed to create stream control actor.");
       return;
     }
   }
 
   aStreamList->SetStreamControl(mStreamControl);
 
-  RefPtr<ReadStream> readStream = ReadStream::Create(mStreamControl,
-                                                       aId, stream);
-  // TODO: fix this
-  nsTArray<UniquePtr<AutoIPCStream>> fakeList;
-  readStream->Serialize(aReadStreamOut, fakeList);
+  RefPtr<ReadStream> readStream = ReadStream::Create(mStreamControl, aId,
+                                                     stream);
+
+  readStream->Serialize(aReadStreamOut, mStreamCleanupList);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/AutoUtils.h b/dom/cache/AutoUtils.h
--- a/dom/cache/AutoUtils.h
+++ b/dom/cache/AutoUtils.h
@@ -45,17 +45,18 @@ class StreamList;
 // deserialization case is handled by creating a ReadStream object.
 
 class MOZ_STACK_CLASS AutoChildOpArgs final
 {
 public:
   typedef TypeUtils::BodyAction BodyAction;
   typedef TypeUtils::SchemeAction SchemeAction;
 
-  AutoChildOpArgs(TypeUtils* aTypeUtils, const CacheOpArgs& aOpArgs);
+  AutoChildOpArgs(TypeUtils* aTypeUtils, const CacheOpArgs& aOpArgs,
+                  uint32_t aEntryCount);
   ~AutoChildOpArgs();
 
   void Add(InternalRequest* aRequest, BodyAction aBodyAction,
            SchemeAction aSchemeAction, ErrorResult& aRv);
   void Add(InternalRequest* aRequest, BodyAction aBodyAction,
            SchemeAction aSchemeAction, Response& aResponse, ErrorResult& aRv);
 
   const CacheOpArgs& SendAsOpArgs();
@@ -66,17 +67,18 @@ private:
   nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>> mStreamCleanupList;
   bool mSent;
 };
 
 class MOZ_STACK_CLASS AutoParentOpResult final
 {
 public:
   AutoParentOpResult(mozilla::ipc::PBackgroundParent* aManager,
-                     const CacheOpResult& aOpResult);
+                     const CacheOpResult& aOpResult,
+                     uint32_t aEntryCount);
   ~AutoParentOpResult();
 
   void Add(CacheId aOpenedCacheId, Manager* aManager);
   void Add(const SavedResponse& aSavedResponse, StreamList* aStreamList);
   void Add(const SavedRequest& aSavedRequest, StreamList* aStreamList);
 
   const CacheOpResult& SendAsOpResult();
 
@@ -86,16 +88,17 @@ private:
                              CacheResponse* aResponseOut);
 
   void SerializeReadStream(const nsID& aId, StreamList* aStreamList,
                            CacheReadStream* aReadStreamOut);
 
   mozilla::ipc::PBackgroundParent* mManager;
   CacheOpResult mOpResult;
   CacheStreamControlParent* mStreamControl;
+  nsTArray<UniquePtr<mozilla::ipc::AutoIPCStream>> mStreamCleanupList;
   bool mSent;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_AutoUtils_h
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -259,17 +259,17 @@ Cache::Match(const RequestOrUSVString& a
   RefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheMatchArgs(CacheRequest(), params));
+  AutoChildOpArgs args(this, CacheMatchArgs(CacheRequest(), params), 1);
 
   args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
@@ -283,17 +283,17 @@ Cache::MatchAll(const Optional<RequestOr
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheMatchAllArgs(void_t(), params));
+  AutoChildOpArgs args(this, CacheMatchAllArgs(void_t(), params), 1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir = ToInternalRequest(aRequest.Value(),
                                                      IgnoreBody, aRv);
     if (aRv.Failed()) {
       return nullptr;
     }
 
@@ -405,17 +405,17 @@ Cache::Put(const RequestOrUSVString& aRe
     return nullptr;
   }
 
   RefPtr<InternalRequest> ir = ToInternalRequest(aRequest, ReadBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  AutoChildOpArgs args(this, CachePutAllArgs());
+  AutoChildOpArgs args(this, CachePutAllArgs(), 1);
 
   args.Add(ir, ReadBody, TypeErrorOnInvalidScheme,
            aResponse, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
@@ -435,17 +435,17 @@ Cache::Delete(const RequestOrUSVString& 
   RefPtr<InternalRequest> ir = ToInternalRequest(aRequest, IgnoreBody, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheDeleteArgs(CacheRequest(), params));
+  AutoChildOpArgs args(this, CacheDeleteArgs(CacheRequest(), params), 1);
 
   args.Add(ir, IgnoreBody, IgnoreInvalidScheme, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return ExecuteOp(args, aRv);
 }
@@ -459,17 +459,17 @@ Cache::Keys(const Optional<RequestOrUSVS
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
   CacheQueryParams params;
   ToCacheQueryParams(params, aOptions);
 
-  AutoChildOpArgs args(this, CacheKeysArgs(void_t(), params));
+  AutoChildOpArgs args(this, CacheKeysArgs(void_t(), params), 1);
 
   if (aRequest.WasPassed()) {
     RefPtr<InternalRequest> ir = ToInternalRequest(aRequest.Value(),
                                                      IgnoreBody, aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
@@ -635,17 +635,17 @@ Cache::PutAll(const nsTArray<RefPtr<Requ
 
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   CacheChild::AutoLock actorLock(mActor);
 
-  AutoChildOpArgs args(this, CachePutAllArgs());
+  AutoChildOpArgs args(this, CachePutAllArgs(), aRequestList.Length());
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     RefPtr<InternalRequest> ir = aRequestList[i]->GetInternalRequest();
     args.Add(ir, ReadBody, TypeErrorOnInvalidScheme, *aResponseList[i], aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   }
diff --git a/dom/cache/CacheOpParent.cpp b/dom/cache/CacheOpParent.cpp
--- a/dom/cache/CacheOpParent.cpp
+++ b/dom/cache/CacheOpParent.cpp
@@ -166,23 +166,26 @@ CacheOpParent::OnOpComplete(ErrorResult&
   // Never send an op-specific result if we have an error.  Instead, send
   // void_t() to ensure that we don't leak actors on the child side.
   if (NS_WARN_IF(aRv.Failed())) {
     Unused << Send__delete__(this, aRv, void_t());
     aRv.SuppressException(); // We serialiazed it, as best we could.
     return;
   }
 
+  uint32_t entryCount = std::max(1lu, std::max(aSavedResponseList.Length(),
+                                             aSavedRequestList.Length()));
+
   // The result must contain the appropriate type at this point.  It may
   // or may not contain the additional result data yet.  For types that
   // do not need special processing, it should already be set.  If the
   // result requires actor-specific operations, then we do that below.
   // If the type and data types don't match, then we will trigger an
   // assertion in AutoParentOpResult::Add().
-  AutoParentOpResult result(mIpcManager, aResult);
+  AutoParentOpResult result(mIpcManager, aResult, entryCount);
 
   if (aOpenedCacheId != INVALID_CACHE_ID) {
     result.Add(aOpenedCacheId, mManager);
   }
 
   for (uint32_t i = 0; i < aSavedResponseList.Length(); ++i) {
     result.Add(aSavedResponseList[i], aStreamList);
   }
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -602,17 +602,17 @@ CacheStorage::MaybeRunPendingRequests()
 {
   if (!mActor) {
     return;
   }
 
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     ErrorResult rv;
     nsAutoPtr<Entry> entry(mPendingRequests[i].forget());
-    AutoChildOpArgs args(this, entry->mArgs);
+    AutoChildOpArgs args(this, entry->mArgs, 1);
     if (entry->mRequest) {
       args.Add(entry->mRequest, IgnoreBody, IgnoreInvalidScheme, rv);
     }
     if (NS_WARN_IF(rv.Failed())) {
       entry->mPromise->MaybeReject(rv);
       continue;
     }
     mActor->ExecuteOp(mGlobal, entry->mPromise, this, args.SendAsOpArgs());
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -97,17 +97,17 @@ void
 CacheStreamControlChild::SerializeStream(CacheReadStream* aReadStreamOut,
                                          nsIInputStream* aStream,
                                          nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(aStream);
   UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(aReadStreamOut->stream()));
-  autoStream->SerializeOrSend(aStream, Manager());
+  autoStream->Serialize(aStream, Manager());
   aStreamCleanupList.AppendElement(Move(autoStream));
 }
 
 void
 CacheStreamControlChild::NoteClosedAfterForget(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   Unused << SendNoteClosed(aId);
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -50,21 +50,23 @@ CacheStreamControlParent::SerializeContr
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   aReadStreamOut->controlChild() = nullptr;
   aReadStreamOut->controlParent() = this;
 }
 
 void
 CacheStreamControlParent::SerializeStream(CacheReadStream* aReadStreamOut,
                                           nsIInputStream* aStream,
-                                          nsTArray<UniquePtr<AutoIPCStream>>&)
+                                          nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(aStream);
-  SerializeInputStream(aStream, aReadStreamOut->stream(), Manager());
+  UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(aReadStreamOut->stream()));
+  autoStream->Serialize(aStream, Manager());
+  aStreamCleanupList.AppendElement(Move(autoStream));
 }
 
 void
 CacheStreamControlParent::NoteClosedAfterForget(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   RecvNoteClosed(aId);
 }
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -199,19 +199,18 @@ ReadStream::Inner::Inner(StreamControl* 
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStreamOrVoid* aReadStreamOut,
                              nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
-  CacheReadStream stream;
-  Serialize(&stream, aStreamCleanupList);
-  *aReadStreamOut = stream;
+  *aReadStreamOut = CacheReadStream();
+  Serialize(&aReadStreamOut->get_CacheReadStream(), aStreamCleanupList);
 }
 
 void
 ReadStream::Inner::Serialize(CacheReadStream* aReadStreamOut,
                              nsTArray<UniquePtr<AutoIPCStream>>& aStreamCleanupList)
 {
   MOZ_ASSERT(NS_GetCurrentThread() == mOwningThread);
   MOZ_ASSERT(aReadStreamOut);
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -486,26 +486,28 @@ TypeUtils::SerializeCacheStream(nsIInput
   *aStreamOut = void_t();
   if (!aStream) {
     return;
   }
 
   // Option 1: Send a cache-specific ReadStream if we can.
   RefPtr<ReadStream> controlled = do_QueryObject(aStream);
   if (controlled) {
+    printf_stderr("### ### create a controlled stream\n");
     controlled->Serialize(aStreamOut, aStreamCleanupList);
     return;
   }
 
-  CacheReadStream readStream;
-  readStream.controlChild() = nullptr;
-  readStream.controlParent() = nullptr;
+  *aStreamOut = CacheReadStream();
+  CacheReadStream& cacheStream = aStreamOut->get_CacheReadStream();
 
-  UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(readStream.stream()));
-  autoStream->SerializeOrSend(aStream, GetIPCManager());
+  cacheStream.controlChild() = nullptr;
+  cacheStream.controlParent() = nullptr;
+
+  UniquePtr<AutoIPCStream> autoStream(new AutoIPCStream(cacheStream.stream()));
+  autoStream->Serialize(aStream, GetIPCManager());
 
   aStreamCleanupList.AppendElement(Move(autoStream));
-  *aStreamOut = readStream;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -315,39 +315,61 @@ SerializeOrSendInputStream(nsIInputStrea
   SerializeOrSendInputStream(aStream, aValue.get_InputStreamParamsWithFdsOrSendStream(),
                              aManager);
 }
 
 void
 CleanupInputStreamParamsWithFdsOrSendStream(InputStreamParamsWithFdsOrSendStream& aValue,
                                             bool aConsumedByIPC)
 {
+  if (aValue.type() == InputStreamParamsWithFdsOrSendStream::T__None) {
+    return;
+  }
+
   if (aValue.type() == InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds) {
 
     InputStreamParamsWithFds& streamWithFds =
       aValue.get_InputStreamParamsWithFds();
 
     // Cleanup file descriptors if necessary
     if (streamWithFds.optionalFds().type() ==
         OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
 
       AutoTArray<FileDescriptor, 4> fds;
 
-      FileDescriptorSetChild* fdSetActor = static_cast<FileDescriptorSetChild*>(
+      auto fdSetActor = static_cast<FileDescriptorSetChild*>(
         streamWithFds.optionalFds().get_PFileDescriptorSetChild());
       MOZ_ASSERT(fdSetActor);
 
       if (!aConsumedByIPC) {
         Unused << fdSetActor->Send__delete__(fdSetActor);
       }
 
       // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
       // unconditionally forget them here.  The fds themselves are auto-closed in
       // ~FileDescriptor since they originated in this process.
       fdSetActor->ForgetFileDescriptors(fds);
+
+    } else if (streamWithFds.optionalFds().type() ==
+               OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+      AutoTArray<FileDescriptor, 4> fds;
+
+      auto fdSetActor = static_cast<FileDescriptorSetParent*>(
+        streamWithFds.optionalFds().get_PFileDescriptorSetParent());
+      MOZ_ASSERT(fdSetActor);
+
+      if (!aConsumedByIPC) {
+        Unused << fdSetActor->Send__delete__(fdSetActor);
+      }
+
+      // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
+      // unconditionally forget them here.  The fds themselves are auto-closed in
+      // ~FileDescriptor since they originated in this process.
+      fdSetActor->ForgetFileDescriptors(fds);
     }
 
     return;
   }
 
   MOZ_ASSERT(aValue.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamChild);
 
   auto sendStream =
@@ -462,16 +484,37 @@ SerializeInputStream(nsIInputStream* aIn
 void
 SerializeInputStream(nsIInputStream* aInputStream,
                      InputStreamParamsWithFdsOrSendStream& aValue,
                      PBackgroundParent* aManager)
 {
   SerializeInputStreamWithFdsParent(aInputStream, aValue, aManager);
 }
 
+namespace {
+
+void
+AssertValidValueToTake(const InputStreamParamsWithFdsOrSendStream& aVal)
+{
+  MOZ_ASSERT(aVal.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamChild ||
+             aVal.type() == InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds);
+}
+
+void
+AssertValidValueToTake(const OptionalInputStreamParamsWithFdsOrSendStream& aVal)
+{
+  MOZ_ASSERT(aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t ||
+             aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream);
+  if (aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream) {
+    AssertValidValueToTake(aVal.get_InputStreamParamsWithFdsOrSendStream());
+  }
+}
+
+} // anonymous namespace
+
 AutoIPCStream::AutoIPCStream()
   : mInlineValue(void_t())
   , mValue(nullptr)
   , mOptionalValue(&mInlineValue)
   , mTaken(false)
 {
 }
 
@@ -498,81 +541,100 @@ AutoIPCStream::~AutoIPCStream()
   if (mValue && IsSet()) {
     CleanupInputStreamParamsWithFdsOrSendStream(*mValue, mTaken);
   } else {
     CleanupInputStreamParamsWithFdsOrSendStream(*mOptionalValue, mTaken);
   }
 }
 
 void
-AutoIPCStream::SerializeOrSend(nsIInputStream* aStream, PContentChild* aManager)
+AutoIPCStream::Serialize(nsIInputStream* aStream, PContentChild* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
   }
 }
 
 void
-AutoIPCStream::SerializeOrSend(nsIInputStream* aStream,
+AutoIPCStream::Serialize(nsIInputStream* aStream,
                                PBackgroundChild* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, dom::PContentParent* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStreamWithFdsParent(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStreamWithFdsParent(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, PBackgroundParent* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStreamWithFdsParent(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStreamWithFdsParent(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
   }
 }
 
 bool
 AutoIPCStream::IsSet() const
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   if (mValue) {
     return mValue->type() != InputStreamParamsWithFdsOrSendStream::T__None;
   } else {
     return mOptionalValue->type() !=
            OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t;
   }
 }
 
-namespace {
-
-void
-AssertValidValueToTake(const InputStreamParamsWithFdsOrSendStream& aVal)
-{
-  MOZ_ASSERT(aVal.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamChild ||
-             aVal.type() == InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds);
-}
-
-void
-AssertValidValueToTake(const OptionalInputStreamParamsWithFdsOrSendStream& aVal)
-{
-  MOZ_ASSERT(aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t ||
-             aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream);
-  if (aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream) {
-    AssertValidValueToTake(aVal.get_InputStreamParamsWithFdsOrSendStream());
-  }
-}
-
-} // anonymous namespace
-
 InputStreamParamsWithFdsOrSendStream&
 AutoIPCStream::TakeValue()
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(IsSet());
 
   mTaken = true;
diff --git a/ipc/glue/InputStreamUtils.h b/ipc/glue/InputStreamUtils.h
--- a/ipc/glue/InputStreamUtils.h
+++ b/ipc/glue/InputStreamUtils.h
@@ -43,50 +43,16 @@ DeserializeInputStream(const OptionalInp
                        const nsTArray<FileDescriptor>& aFileDescriptors);
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const InputStreamParamsWithFdsOrSendStream& aValue);
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const OptionalInputStreamParamsWithFdsOrSendStream& aValue);
 
-// These serialization methods do not support sending as a PSendStream.  Use
-// AutoIPCStream::SerializeOrSend() if you need to support non-serializable
-// streams.
-void
-SerializeInputStream(nsIInputStream* aInputStream,
-                     InputStreamParamsWithFdsOrSendStream& aValue,
-                     dom::PContentChild* aManager);
-
-void
-SerializeInputStream(nsIInputStream* aInputStream,
-                     InputStreamParamsWithFdsOrSendStream& aValue,
-                     PBackgroundChild* aManager);
-void
-SerializeInputStream(nsIInputStream* aInputStream,
-                     InputStreamParamsWithFdsOrSendStream& aValue,
-                     dom::PContentParent* aManager);
-
-void
-SerializeInputStream(nsIInputStream* aInputStream,
-                     InputStreamParamsWithFdsOrSendStream& aValue,
-                     PBackgroundParent* aManager);
-
-template<typename M>
-void
-SerializeInputStream(nsIInputStream* aStream,
-                     OptionalInputStreamParamsWithFdsOrSendStream& aValue,
-                     M* aManager)
-{
-  aValue = InputStreamParamsWithFdsOrSendStream();
-  SerializeInputStream(aStream,
-                       aValue.get_InputStreamParamsWithFdsOrSendStream(),
-                       aManager);
-}
-
 // RAII helper class that serializes an nsIInputStream into an
 // InputStreamParamsWithFdsOrSendStream IPC struct.  Any SendStreamChild actors
 // are automatically managed correctly.
 //
 // Use the TakeValue() method when passing the value (or just after passing the
 // value) to the IPC Send*() method.
 //
 // For example:
@@ -142,23 +108,33 @@ public:
   explicit AutoIPCStream(OptionalInputStreamParamsWithFdsOrSendStream& aTarget);
 
   ~AutoIPCStream();
 
   // Serialize the input stream or create a SendStream actor using the PContent
   // manager.  If neither of these succeed, then crash.  This should only be
   // used on the main thread.
   void
-  SerializeOrSend(nsIInputStream* aStream, dom::PContentChild* aManager);
+  Serialize(nsIInputStream* aStream, dom::PContentChild* aManager);
 
   // Serialize the input stream or create a SendStream actor using the
   // PBackground manager.  If neither of these succeed, then crash.  This can
   // be called on the main thread or Worker threads.
   void
-  SerializeOrSend(nsIInputStream* aStream, PBackgroundChild* aManager);
+  Serialize(nsIInputStream* aStream, PBackgroundChild* aManager);
+
+  // Serialize the input stream.  A PSendStream cannot be used when going
+  // from parent-to-child.
+  void
+  Serialize(nsIInputStream* aStream, dom::PContentParent* aManager);
+
+  // Serialize the input stream.  A PSendStream cannot be used when going
+  // from parent-to-child.
+  void
+  Serialize(nsIInputStream* aStream, PBackgroundParent* aManager);
 
   // Get the InputStreamParamsWithFdsOrSendStream as a non-optional value.  This will
   // assert if a stream has not been serialized or if it has already been taken.
   // This should only be called if the value is being, or has already been, sent
   // to the parent
   InputStreamParamsWithFdsOrSendStream&
   TakeValue();
 
