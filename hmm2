# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fdd43f28c8ce70005656eb79af0898242b2e8a1f

diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -197,20 +197,23 @@ template<typename M>
 void
 SerializeOrSendInputStream(nsIInputStream* aStream,
                            InputStreamParamsOrSendStream& aValue,
                            M* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
 
+  printf_stderr("### ### SerializeOrSendInputStream() non-optional\n");
+
   // First attempt simple stream serialization
   nsCOMPtr<nsIIPCSerializableInputStream> serializable =
     do_QueryInterface(aStream);
   if (serializable) {
+    printf_stderr("### ### SerializeOrSendInputStream() serializable\n");
     InputStreamParams params;
     nsAutoTArray<FileDescriptor, 4> fds;
 
     serializable->Serialize(params, fds);
 
     if (params.type() == InputStreamParams::T__None) {
       MOZ_CRASH("Serialize failed!");
     }
@@ -225,16 +228,18 @@ SerializeOrSendInputStream(nsIInputStrea
       }
 
       aValue.optionalFds() = fdSet;
     }
 
     return;
   }
 
+  printf_stderr("### ### SerializeOrSendInputStream() not serializable\n");
+
   // As a fallback, attempt to stream the data across using a SendStream
   // actor.  This will fail for blocking streams.
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(aStream);
   aValue.optionalSendStreamChild() =
     SendStreamChild::Create(asyncStream, aManager);
 
   if (!aValue.optionalSendStreamChild()) {
     MOZ_CRASH("SendStream creation failed!");
@@ -242,23 +247,28 @@ SerializeOrSendInputStream(nsIInputStrea
 }
 
 template<typename M>
 void
 SerializeOrSendInputStream(nsIInputStream* aStream,
                            OptionalInputStreamParamsOrSendStream& aValue,
                            M* aManager)
 {
+  printf_stderr("### ### SerializeOrSendInputStream() optional\n");
   if (!aStream) {
+    printf_stderr("### ### SerializeOrSendInputStream() optional: null stream\n");
     aValue = void_t();
     return;
   }
 
+  printf_stderr("### ### SerializeOrSendInputStream() optional - setting empty value\n");
   aValue = InputStreamParamsOrSendStream(void_t(), void_t(), nullptr, nullptr);
-  SerializeOrSendInputStream(aStream, aValue, aManager);
+  printf_stderr("### ### SerializeOrSendInputStream() optional - calling non-optional\n");
+  SerializeOrSendInputStream(aStream, aValue.get_InputStreamParamsOrSendStream(),
+                             aManager);
 }
 
 void
 CleanupInputStreamParamsOrSendStream(InputStreamParamsOrSendStream& aValue,
                                      bool aConsumedByIPC)
 {
   // Cleanup file descriptors if necessary
   if (aValue.optionalFds().type() ==
@@ -306,46 +316,51 @@ CleanupInputStreamParamsOrSendStream(Opt
   CleanupInputStreamParamsOrSendStream(aValue, aConsumedByIPC);
 }
 
 } // anonymous namespace
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const InputStreamParamsOrSendStream& aValue)
 {
+  printf_stderr("### ### DeserializeInputStream() - non optional\n");
   auto sendStream =
     static_cast<SendStreamParent*>(aValue.optionalSendStreamParent());
   if (sendStream) {
+    printf_stderr("### ### DeserializeInputStream() - non optional - send stream\n");
     nsCOMPtr<nsIInputStream> stream = sendStream->TakeReader();
     return stream.forget();
   }
 
   nsAutoTArray<FileDescriptor, 4> fds;
   if (aValue.optionalFds().type() ==
       OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+    printf_stderr("### ### DeserializeInputStream() - non optional - fds\n");
 
     FileDescriptorSetParent* fdSetActor = static_cast<FileDescriptorSetParent*>(
       aValue.optionalFds().get_PFileDescriptorSetParent());
     MOZ_ASSERT(fdSetActor);
 
     fdSetActor->ForgetFileDescriptors(fds);
     MOZ_ASSERT(!fds.IsEmpty());
 
     if (!fdSetActor->Send__delete__(fdSetActor)) {
       // child process is gone, warn and allow actor to clean up normally
       NS_WARNING("Failed to delete fd set actor.");
     }
   }
 
+  printf_stderr("### ### DeserializeInputStream() - non optional - call deserialize\n");
   return DeserializeInputStream(aValue.optionalStream(), fds);
 }
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const OptionalInputStreamParamsOrSendStream& aValue)
 {
+  printf_stderr("### ### DeserializeInputStream() - optional\n");
   if (aValue.type() == OptionalInputStreamParamsOrSendStream::Tvoid_t) {
     return nullptr;
   }
 
   return DeserializeInputStream(aValue.get_InputStreamParamsOrSendStream());
 }
 
 AutoIPCStreamChild::AutoIPCStreamChild()
@@ -367,38 +382,41 @@ AutoIPCStreamChild::AutoIPCStreamChild(I
 
 AutoIPCStreamChild::AutoIPCStreamChild(OptionalInputStreamParamsOrSendStream& aTarget)
   : mInlineValue(void_t())
   , mValue(nullptr)
   , mOptionalValue(&aTarget)
   , mTaken(false)
 {
   *mOptionalValue = void_t();
+  printf_stderr("### ### AutoIPCStreamChild()\n");
 }
 
 AutoIPCStreamChild::~AutoIPCStreamChild()
 {
   MOZ_ASSERT(mValue || mOptionalValue);
   if (mValue) {
     CleanupInputStreamParamsOrSendStream(*mValue, mTaken);
   } else {
     CleanupInputStreamParamsOrSendStream(*mOptionalValue, mTaken);
   }
 }
 
 void
 AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
                                     PContentChild* aManager)
 {
-  MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
+  printf_stderr("### ### SerializeOrSend(PContent) mValue:%p mOptionalValue:%p stream:%p\n",
+                mValue, mOptionalValue, aStream);
+
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
   }
 }
 
 void
@@ -406,16 +424,18 @@ AutoIPCStreamChild::SerializeOrSend(nsII
                                     PBackgroundChild* aManager)
 {
   MOZ_ASSERT(aStream);
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(mValue || mOptionalValue);
   MOZ_ASSERT(!mTaken);
   MOZ_ASSERT(!IsSet());
 
+  printf_stderr("### ### SerializeOrSend(PBackground) %p\n", aStream);
+
   if (mValue) {
     SerializeOrSendInputStream(aStream, *mValue, aManager);
   } else {
     SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
   }
 }
 
 bool
diff --git a/ipc/glue/SendStreamChild.cpp b/ipc/glue/SendStreamChild.cpp
--- a/ipc/glue/SendStreamChild.cpp
+++ b/ipc/glue/SendStreamChild.cpp
@@ -72,16 +72,17 @@ class SendStreamChildImpl::Callback fina
                                           , public nsICancelableRunnable
 {
 public:
   explicit Callback(SendStreamChildImpl* aActor)
     : mActor(aActor)
     , mOwningThread(NS_GetCurrentThread())
   {
     MOZ_ASSERT(mActor);
+    printf_stderr("### ### SendStreamChildImpl()\n");
   }
 
   NS_IMETHOD
   OnInputStreamReady(nsIAsyncInputStream* aStream) override
   {
     // any thread
     if (mOwningThread == NS_GetCurrentThread()) {
       return Run();
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -1617,18 +1617,21 @@ HttpChannelChild::ContinueAsyncOpen()
   SerializeURI(mDocumentURI, openArgs.doc());
   SerializeURI(mReferrer, openArgs.referrer());
   openArgs.referrerPolicy() = mReferrerPolicy;
   SerializeURI(mAPIRedirectToURI, openArgs.apiRedirectTo());
   openArgs.loadFlags() = mLoadFlags;
   openArgs.requestHeaders() = mClientSetRequestHeaders;
   openArgs.requestMethod() = mRequestHead.Method();
 
+  printf_stderr("### ### creating AutoIPCStreamChild\n");
   AutoIPCStreamChild uploadStreamChild(openArgs.uploadStream());
-  uploadStreamChild.SerializeOrSend(mUploadStream, Manager()->Manager());
+  printf_stderr("### ### calling AutoIPCStreamChild::SerializeOrSend\n");
+  uploadStreamChild.SerializeOrSend(mUploadStream, gNeckoChild->Manager());
+  printf_stderr("### ### after serialize or send\n");
 
   if (mResponseHead) {
     openArgs.synthesizedResponseHead() = *mResponseHead;
   } else {
     openArgs.synthesizedResponseHead() = mozilla::void_t();
   }
 
   nsCOMPtr<nsISerializable> secInfoSer = do_QueryInterface(mSecurityInfo);
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -364,17 +364,19 @@ HttpChannelParent::DoAsyncOpen(  const U
   }
 
   mParentListener = new HttpChannelParentListener(this);
 
   mChannel->SetNotificationCallbacks(mParentListener);
 
   mChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
 
+  printf_stderr("### ### HTTP parent calling DeserializeInputStream()\n");
   nsCOMPtr<nsIInputStream> stream = DeserializeInputStream(uploadStream);
+  printf_stderr("### ### HTTP parent DeserializeInputStream() returned %p\n", stream.get());
   if (stream) {
     mChannel->InternalSetUploadStream(stream);
     mChannel->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
     mSynthesizedResponseHead = new nsHttpResponseHead(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mShouldIntercept = true;
