
# HG changeset patch
# User Nikhil Marathe <nsm.nikhil@gmail.com>
# Date 1423620538 28800
# Node ID af3e6e9cf883ffb50ba6b10c2ee53a6c3e171278
# Parent  4055d0104e77e3ec0146f917d7928f308b6eb8bd
Bug 1131874 - ServiceWorker persistence activation fixes. r=baku

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1124,17 +1124,16 @@ ServiceWorkerRegistrationInfo::Activate(
 
   mActiveWorker = activatingWorker.forget();
   mWaitingWorker = nullptr;
   mActiveWorker->UpdateState(ServiceWorkerState::Activating);
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   swm->CheckPendingReadyPromises();
-  swm->StoreRegistration(mPrincipal, this);
 
   // "Queue a task to fire a simple event named controllerchange..."
   nsCOMPtr<nsIRunnable> controllerChangeRunnable =
     NS_NewRunnableMethodWithArg<ServiceWorkerRegistrationInfo*>(swm,
                                                                 &ServiceWorkerManager::FireControllerChange,
                                                                 this);
   NS_DispatchToMainThread(controllerChangeRunnable);
 
@@ -1661,16 +1660,18 @@ void
 ServiceWorkerRegistrationInfo::FinishActivate(bool aSuccess)
 {
   if (mPendingUninstall || !mActiveWorker) {
     return;
   }
 
   if (aSuccess) {
     mActiveWorker->UpdateState(ServiceWorkerState::Activated);
+    nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+    swm->StoreRegistration(mPrincipal, this);
   } else {
     mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
     mActiveWorker = nullptr;
   }
 }
 
 void
 ServiceWorkerRegistrationInfo::QueueStateChangeEvent(ServiceWorkerInfo* aInfo,
@@ -1754,18 +1755,22 @@ ServiceWorkerManager::LoadRegistrations(
       continue;
     }
 
     ServiceWorkerRegistrationInfo* registration =
       CreateNewRegistration(aRegistrations[i].scope(), principal);
 
     registration->mScriptSpec = aRegistrations[i].scriptSpec();
 
-    registration->mActiveWorker =
-      new ServiceWorkerInfo(registration, aRegistrations[i].currentWorkerURL());
+    const nsCString& currentWorkerURL = aRegistrations[i].currentWorkerURL();
+    if (!currentWorkerURL.IsEmpty()) {
+      registration->mActiveWorker =
+        new ServiceWorkerInfo(registration, currentWorkerURL);
+      registration->mActiveWorker->SetActivateStateUncheckedWithoutEvent(ServiceWorkerState::Activated);
+    }
   }
 }
 
 void
 ServiceWorkerManager::ActorFailed()
 {
   MOZ_CRASH("Failed to create a PBackgroundChild actor!");
 }
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -265,16 +265,23 @@ public:
       MOZ_ASSERT_IF(mState == ServiceWorkerState::Activating, aState == ServiceWorkerState::Activated);
     }
     // Activated can only go to redundant.
     MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
 #endif
     mState = aState;
     mRegistration->QueueStateChangeEvent(this, mState);
   }
+
+  // Only used to set initial state when loading from disk!
+  void
+  SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
+  {
+    mState = aState;
+  }
 };
 
 #define NS_SERVICEWORKERMANAGER_IMPL_IID                 \
 { /* f4f8755a-69ca-46e8-a65d-775745535990 */             \
   0xf4f8755a,                                            \
   0x69ca,                                                \
   0x46e8,                                                \
   { 0xa6, 0x5d, 0x77, 0x57, 0x45, 0x53, 0x59, 0x90 }     \

