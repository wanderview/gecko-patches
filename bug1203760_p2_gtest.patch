# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  49d1a1b4584d5f56f93ca8908c1e3aa65627768f
Bug 1203760 P2 Add gtests for nsPipeInputStream AsyncRead(). r=froydnj

diff --git a/xpcom/tests/gtest/Helpers.cpp b/xpcom/tests/gtest/Helpers.cpp
--- a/xpcom/tests/gtest/Helpers.cpp
+++ b/xpcom/tests/gtest/Helpers.cpp
@@ -107,9 +107,27 @@ OutputStreamCallback::~OutputStreamCallb
 
 NS_IMETHODIMP
 OutputStreamCallback::OnOutputStreamReady(nsIAsyncOutputStream* aStream)
 {
   mCalled = true;
   return NS_OK;
 }
 
+NS_IMPL_ISUPPORTS(InputStreamCallback, nsIInputStreamCallback);
+
+InputStreamCallback::InputStreamCallback()
+  : mCalled(false)
+{
+}
+
+InputStreamCallback::~InputStreamCallback()
+{
+}
+
+NS_IMETHODIMP
+InputStreamCallback::OnInputStreamReady(nsIAsyncInputStream* aStream)
+{
+  mCalled = true;
+  return NS_OK;
+}
+
 } // namespace testing
diff --git a/xpcom/tests/gtest/Helpers.h b/xpcom/tests/gtest/Helpers.h
--- a/xpcom/tests/gtest/Helpers.h
+++ b/xpcom/tests/gtest/Helpers.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef __Helpers_h
 #define __Helpers_h
 
+#include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsString.h"
 #include <stdint.h>
 
 class nsIInputStream;
 class nsIOutputStream;
 template <class T> class nsTArray;
 
@@ -46,11 +47,27 @@ private:
   ~OutputStreamCallback();
 
   bool mCalled;
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOUTPUTSTREAMCALLBACK
 };
 
+class InputStreamCallback final : public nsIInputStreamCallback
+{
+public:
+  InputStreamCallback();
+
+  bool Called() const { return mCalled; }
+
+private:
+  ~InputStreamCallback();
+
+  bool mCalled;
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAMCALLBACK
+};
+
 } // namespace testing
 
 #endif // __Helpers_h
diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -781,16 +781,98 @@ TEST(Pipes, Write_AsyncWait_Clone_CloseO
 
   ASSERT_FALSE(cb->Called());
 
   reader->Close();
 
   ASSERT_TRUE(cb->Called());
 }
 
+TEST(Pipes, Read_AsyncWait)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  const uint32_t segmentSize = 1024;
+  const uint32_t numSegments = 1;
+
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+  testing::CreateData(segmentSize, inputData);
+
+  nsRefPtr<testing::InputStreamCallback> cb =
+    new testing::InputStreamCallback();
+
+  rv = reader->AsyncWait(cb, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb->Called());
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_TRUE(cb->Called());
+
+  testing::ConsumeAndValidateStream(reader, inputData);
+}
+
+TEST(Pipes, Read_AsyncWait_Clone)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  const uint32_t segmentSize = 1024;
+  const uint32_t numSegments = 1;
+
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIInputStream> clone;
+  rv = NS_CloneInputStream(reader, getter_AddRefs(clone));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIAsyncInputStream> asyncClone = do_QueryInterface(clone);
+  ASSERT_TRUE(asyncClone);
+
+  nsTArray<char> inputData;
+  testing::CreateData(segmentSize, inputData);
+
+  nsRefPtr<testing::InputStreamCallback> cb =
+    new testing::InputStreamCallback();
+
+  nsRefPtr<testing::InputStreamCallback> cb2 =
+    new testing::InputStreamCallback();
+
+  rv = reader->AsyncWait(cb, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb->Called());
+
+  rv = asyncClone->AsyncWait(cb2, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb2->Called());
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_TRUE(cb->Called());
+  ASSERT_TRUE(cb2->Called());
+
+  testing::ConsumeAndValidateStream(reader, inputData);
+}
+
 namespace {
 
 NS_METHOD
 CloseDuringReadFunc(nsIInputStream *aReader,
                     void* aClosure,
                     const char* aFromSegment,
                     uint32_t aToOffset,
                     uint32_t aCount,
