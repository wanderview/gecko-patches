# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  cd4e257605e7499d7a538dbb45c8ebe216f78f6c
Bug 1462466 P2 Make ServiceWorker::PostMessage() code use the ServiceWorkerCloneData class. r=baku

diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -3,27 +3,27 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerImpl.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/WorkerPrivate.h"
-#include "mozilla/dom/ipc/StructuredCloneData.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
 using namespace mozilla::dom;
 
@@ -174,18 +174,18 @@ ServiceWorker::PostMessage(JSContext* aC
 
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
   aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                           &transferable);
   if (aRv.Failed()) {
     return;
   }
 
-  ipc::StructuredCloneData data;
-  data.Write(aCx, aMessage, transferable, aRv);
+  RefPtr<ServiceWorkerCloneData> data = new ServiceWorkerCloneData();
+  data->Write(aCx, aMessage, transferable, aRv);
   if (aRv.Failed()) {
     return;
   }
 
   mInner->PostMessage(std::move(data), clientInfo.ref(), clientState.ref());
 }
 
 
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -15,19 +15,17 @@
 #undef PostMessage
 #endif
 
 class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
-namespace ipc {
-class StructuredCloneData;
-} // namespace ipc
+class ServiceWorkerCloneData;
 
 #define NS_DOM_SERVICEWORKER_IID \
   {0xd42e0611, 0x3647, 0x4319, {0xae, 0x05, 0x19, 0x89, 0x59, 0xba, 0x99, 0x5e}}
 
 bool
 ServiceWorkerVisible(JSContext* aCx, JSObject* aObj);
 
 class ServiceWorker final : public DOMEventTargetHelper
@@ -53,17 +51,17 @@ public:
     AddServiceWorker(ServiceWorker* aWorker) = 0;
 
     // This is called when the DOM ServiceWorker object is
     // destroyed and drops its ref to the Inner object.
     virtual void
     RemoveServiceWorker(ServiceWorker* aWorker) = 0;
 
     virtual void
-    PostMessage(ipc::StructuredCloneData&& aData,
+    PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                 const ClientInfo& aClientInfo,
                 const ClientState& aClientState) = 0;
 
     NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
   };
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_SERVICEWORKER_IID)
   NS_DECL_ISUPPORTS_INHERITED
diff --git a/dom/serviceworkers/ServiceWorkerImpl.cpp b/dom/serviceworkers/ServiceWorkerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerImpl.cpp
@@ -32,17 +32,17 @@ void
 ServiceWorkerImpl::RemoveServiceWorker(ServiceWorker* aWorker)
 {
   MOZ_DIAGNOSTIC_ASSERT(mOuter);
   MOZ_DIAGNOSTIC_ASSERT(mOuter == aWorker);
   mOuter = nullptr;
 }
 
 void
-ServiceWorkerImpl::PostMessage(ipc::StructuredCloneData&& aData,
+ServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mInfo->PostMessage(std::move(aData), aClientInfo, aClientState);
 }
 
 void
 ServiceWorkerImpl::SetState(ServiceWorkerState aState)
diff --git a/dom/serviceworkers/ServiceWorkerImpl.h b/dom/serviceworkers/ServiceWorkerImpl.h
--- a/dom/serviceworkers/ServiceWorkerImpl.h
+++ b/dom/serviceworkers/ServiceWorkerImpl.h
@@ -26,17 +26,17 @@ class ServiceWorkerImpl final : public S
   // ServiceWorker::Inner interface
   void
   AddServiceWorker(ServiceWorker* aWorker) override;
 
   void
   RemoveServiceWorker(ServiceWorker* aWorker) override;
 
   void
-  PostMessage(ipc::StructuredCloneData&& aData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState) override;
 
   // ServiceWorkerInfo::Listener interface
   void
   SetState(ServiceWorkerState aState) override;
 
 public:
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -238,17 +238,17 @@ void
 ServiceWorkerInfo::RemoveListener(Listener* aListener)
 {
   MOZ_DIAGNOSTIC_ASSERT(aListener);
   DebugOnly<bool> removed = mInstances.RemoveElement(aListener);
   MOZ_ASSERT(removed);
 }
 
 void
-ServiceWorkerInfo::PostMessage(ipc::StructuredCloneData&& aData,
+ServiceWorkerInfo::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mServiceWorkerPrivate->SendMessageEvent(std::move(aData),
                                           ClientInfoAndState(aClientInfo.ToIPC(),
                                                              aClientState.ToIPC()));
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -13,16 +13,17 @@
 #include "mozilla/OriginAttributes.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientInfoAndState;
 class ClientState;
+class ServiceWorkerCloneData;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
@@ -93,17 +94,17 @@ public:
 
   void
   AddListener(Listener* aListener);
 
   void
   RemoveListener(Listener* aListener);
 
   void
-  PostMessage(ipc::StructuredCloneData&& aData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState);
 
   class ServiceWorkerPrivate*
   WorkerPrivate() const
   {
     MOZ_ASSERT(mServiceWorkerPrivate);
     return mServiceWorkerPrivate;
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.cpp b/dom/serviceworkers/ServiceWorkerPrivate.cpp
--- a/dom/serviceworkers/ServiceWorkerPrivate.cpp
+++ b/dom/serviceworkers/ServiceWorkerPrivate.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerPrivate.h"
 
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerManager.h"
 #include "nsContentUtils.h"
 #include "nsICacheInfoChannel.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPushErrorReporter.h"
@@ -30,17 +31,16 @@
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
-#include "mozilla/dom/StructuredCloneHolder.h"
 #include "mozilla/dom/WorkerDebugger.h"
 #include "mozilla/dom/WorkerRef.h"
 #include "mozilla/dom/WorkerRunnable.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
@@ -523,45 +523,46 @@ public:
       return NS_ERROR_XPC_JS_THREW_EXCEPTION;
     }
 
     return NS_OK;
   }
 };
 
 class SendMessageEventRunnable final : public ExtendableEventWorkerRunnable
-                                     , public StructuredCloneHolder
 {
   const ClientInfoAndState mClientInfoAndState;
+  RefPtr<ServiceWorkerCloneData> mData;
 
 public:
   SendMessageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                            KeepAliveToken* aKeepAliveToken,
-                           const ClientInfoAndState& aClientInfoAndState)
+                           const ClientInfoAndState& aClientInfoAndState,
+                           RefPtr<ServiceWorkerCloneData>&& aData)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
-    , StructuredCloneHolder(CloningSupported, TransferringSupported,
-                            JS::StructuredCloneScope::SameProcessDifferentThread)
     , mClientInfoAndState(aClientInfoAndState)
+    , mData(std::move(aData))
   {
     MOZ_ASSERT(NS_IsMainThread());
+    MOZ_DIAGNOSTIC_ASSERT(mData);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
-    Read(sgo, aCx, &messageData, rv);
+    mData->Read(aCx, &messageData, rv);
     if (NS_WARN_IF(rv.Failed())) {
       return true;
     }
 
     Sequence<OwningNonNull<MessagePort>> ports;
-    if (!TakeTransferredPortsAsSequence(ports)) {
+    if (!mData->TakeTransferredPortsAsSequence(ports)) {
       return true;
     }
 
     RootedDictionary<ExtendableMessageEventInit> init(aCx);
 
     init.mBubbles = false;
     init.mCancelable = false;
 
@@ -586,83 +587,28 @@ public:
                                                              extendableEvent,
                                                              nullptr));
   }
 };
 
 } // anonymous namespace
 
 nsresult
-ServiceWorkerPrivate::SendMessageEvent(ipc::StructuredCloneData&& aData,
+ServiceWorkerPrivate::SendMessageEvent(RefPtr<ServiceWorkerCloneData>&& aData,
                                        const ClientInfoAndState& aClientInfoAndState)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  ErrorResult rv;
-
-  // Ideally we would simply move the StructuredCloneData to the
-  // SendMessageEventRunnable, but we cannot because it uses non-threadsafe
-  // ref-counting.  The following gnarly code unpacks the IPC-friendly
-  // StructuredCloneData and re-packs it into the thread-friendly
-  // StructuredCloneHolder.  In the future we should remove this and make
-  // it easier to simple move the data to the other thread.  See bug 1458936.
-
-  AutoSafeJSContext cx;
-  JS::Rooted<JSObject*> global(cx);
-  GetOrCreateSandbox(cx, &global);
-  NS_ENSURE_TRUE(global, NS_ERROR_FAILURE);
-
-  // The CreateSandbox call returns a proxy to the actual sandbox object.  We
-  // don't need a proxy here.
-  global = js::UncheckedUnwrap(global);
-
-  JSAutoRealm ar(cx, global);
-
-  JS::Rooted<JS::Value> messageData(cx);
-  aData.Read(cx, &messageData, rv);
-  if (rv.Failed()) {
-    return rv.StealNSResult();
-  }
-
-  Sequence<OwningNonNull<MessagePort>> ports;
-  if (!aData.TakeTransferredPortsAsSequence(ports)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  JS::Rooted<JSObject*> array(cx, JS_NewArrayObject(cx, ports.Length()));
-  NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);
-
-  for (uint32_t i = 0; i < ports.Length(); ++i) {
-    JS::Rooted<JS::Value> value(cx);
-    if (!GetOrCreateDOMReflector(cx, ports[i], &value)) {
-      JS_ClearPendingException(cx);
-      return NS_ERROR_FAILURE;
-    }
-
-    if (!JS_DefineElement(cx, array, i, value, JSPROP_ENUMERATE)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-
-  JS::Rooted<JS::Value> transferable(cx);
-  transferable.setObject(*array);
-
-  rv = SpawnWorkerIfNeeded(MessageEvent);
-  if (NS_WARN_IF(rv.Failed())) {
-    return rv.StealNSResult();
-  }
+  nsresult rv = SpawnWorkerIfNeeded(MessageEvent);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
   RefPtr<SendMessageEventRunnable> runnable =
-    new SendMessageEventRunnable(mWorkerPrivate, token, aClientInfoAndState);
-
-  runnable->Write(cx, messageData, transferable, JS::CloneDataPolicy(), rv);
-  if (rv.Failed()) {
-    return rv.StealNSResult();
-  }
+    new SendMessageEventRunnable(mWorkerPrivate, token, aClientInfoAndState,
+                                 std::move(aData));
 
   if (!runnable->Dispatch()) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.h b/dom/serviceworkers/ServiceWorkerPrivate.h
--- a/dom/serviceworkers/ServiceWorkerPrivate.h
+++ b/dom/serviceworkers/ServiceWorkerPrivate.h
@@ -18,16 +18,17 @@ class nsIInterceptedChannel;
 namespace mozilla {
 
 class JSObjectHolder;
 
 namespace dom {
 
 class ClientInfoAndState;
 class KeepAliveToken;
+class ServiceWorkerCloneData;
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
 
 namespace ipc {
 class StructuredCloneData;
 } // namespace ipc
 
 class LifeCycleEventCallback : public Runnable
@@ -84,17 +85,17 @@ public:
 protected:
   nsCycleCollectingAutoRefCnt mRefCnt;
   NS_DECL_OWNINGTHREAD
 
 public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
   nsresult
-  SendMessageEvent(ipc::StructuredCloneData&& aData,
+  SendMessageEvent(RefPtr<ServiceWorkerCloneData>&& aData,
                    const ClientInfoAndState& aClientInfoAndState);
 
   // This is used to validate the worker script and continue the installation
   // process.
   nsresult
   CheckScriptEvaluation(LifeCycleEventCallback* aCallback);
 
   nsresult
