# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0c73d430d22facef13a49b80a2acb6d66995647a
Bug 1462466 P2 Make ServiceWorker::PostMessage() code use the ServiceWorkerCloneData class. r=baku

diff --git a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerImpl.cpp
@@ -6,16 +6,17 @@
 
 #include "RemoteServiceWorkerImpl.h"
 
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "ServiceWorkerChild.h"
+#include "ServiceWorkerCloneData.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
 
 RemoteServiceWorkerImpl::~RemoteServiceWorkerImpl()
@@ -53,28 +54,28 @@ RemoteServiceWorkerImpl::RemoveServiceWo
 {
   NS_ASSERT_OWNINGTHREAD(RemoteServiceWorkerImpl);
   MOZ_DIAGNOSTIC_ASSERT(mWorker);
   MOZ_DIAGNOSTIC_ASSERT(aWorker == mWorker);
   mWorker = nullptr;
 }
 
 void
-RemoteServiceWorkerImpl::PostMessage(ipc::StructuredCloneData&& aData,
+RemoteServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                      const ClientInfo& aClientInfo,
                                      const ClientState& aClientState)
 {
   NS_ASSERT_OWNINGTHREAD(RemoteServiceWorkerImpl);
   if (!mActor) {
     return;
   }
 
   ClonedMessageData data;
-  if (!aData.BuildClonedMessageDataForBackgroundChild(mActor->Manager(),
-                                                      data)) {
+  if (!aData->BuildClonedMessageDataForBackgroundChild(mActor->Manager(),
+                                                       data)) {
     return;
   }
 
   mActor->SendPostMessage(data, ClientInfoAndState(aClientInfo.ToIPC(),
                                                    aClientState.ToIPC()));
 }
 
 RemoteServiceWorkerImpl::RemoteServiceWorkerImpl(const ServiceWorkerDescriptor& aDescriptor)
diff --git a/dom/serviceworkers/RemoteServiceWorkerImpl.h b/dom/serviceworkers/RemoteServiceWorkerImpl.h
--- a/dom/serviceworkers/RemoteServiceWorkerImpl.h
+++ b/dom/serviceworkers/RemoteServiceWorkerImpl.h
@@ -28,17 +28,17 @@ class RemoteServiceWorkerImpl final : pu
   // ServiceWorker::Inner implementation
   void
   AddServiceWorker(ServiceWorker* aWorker) override;
 
   void
   RemoveServiceWorker(ServiceWorker* aWorker) override;
 
   void
-  PostMessage(ipc::StructuredCloneData&& aData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState) override;
 public:
   explicit RemoteServiceWorkerImpl(const ServiceWorkerDescriptor& aDescriptor);
 
   void
   RevokeActor(ServiceWorkerChild* aActor);
 
diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -4,28 +4,28 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorker.h"
 
 #include "nsIDocument.h"
 #include "nsPIDOMWindow.h"
 #include "RemoteServiceWorkerImpl.h"
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerImpl.h"
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerUtils.h"
 
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/WorkerPrivate.h"
-#include "mozilla/dom/ipc/StructuredCloneData.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
 using namespace mozilla::dom;
 
@@ -179,18 +179,18 @@ ServiceWorker::PostMessage(JSContext* aC
 
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
   aRv = nsContentUtils::CreateJSValueFromSequenceOfObject(aCx, aTransferable,
                                                           &transferable);
   if (aRv.Failed()) {
     return;
   }
 
-  ipc::StructuredCloneData data;
-  data.Write(aCx, aMessage, transferable, aRv);
+  RefPtr<ServiceWorkerCloneData> data = new ServiceWorkerCloneData();
+  data->Write(aCx, aMessage, transferable, aRv);
   if (aRv.Failed()) {
     return;
   }
 
   mInner->PostMessage(Move(data), clientInfo.ref(), clientState.ref());
 }
 
 
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -15,19 +15,17 @@
 #undef PostMessage
 #endif
 
 class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
-namespace ipc {
-class StructuredCloneData;
-} // namespace ipc
+class ServiceWorkerCloneData;
 
 #define NS_DOM_SERVICEWORKER_IID \
   {0xd42e0611, 0x3647, 0x4319, {0xae, 0x05, 0x19, 0x89, 0x59, 0xba, 0x99, 0x5e}}
 
 bool
 ServiceWorkerVisible(JSContext* aCx, JSObject* aObj);
 
 class ServiceWorker final : public DOMEventTargetHelper
@@ -53,17 +51,17 @@ public:
     AddServiceWorker(ServiceWorker* aWorker) = 0;
 
     // This is called when the DOM ServiceWorker object is
     // destroyed and drops its ref to the Inner object.
     virtual void
     RemoveServiceWorker(ServiceWorker* aWorker) = 0;
 
     virtual void
-    PostMessage(ipc::StructuredCloneData&& aData,
+    PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                 const ClientInfo& aClientInfo,
                 const ClientState& aClientState) = 0;
 
     NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
   };
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_SERVICEWORKER_IID)
   NS_DECL_ISUPPORTS_INHERITED
diff --git a/dom/serviceworkers/ServiceWorkerImpl.cpp b/dom/serviceworkers/ServiceWorkerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerImpl.cpp
@@ -32,17 +32,17 @@ void
 ServiceWorkerImpl::RemoveServiceWorker(ServiceWorker* aWorker)
 {
   MOZ_DIAGNOSTIC_ASSERT(mOuter);
   MOZ_DIAGNOSTIC_ASSERT(mOuter == aWorker);
   mOuter = nullptr;
 }
 
 void
-ServiceWorkerImpl::PostMessage(ipc::StructuredCloneData&& aData,
+ServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mInfo->PostMessage(Move(aData), aClientInfo, aClientState);
 }
 
 void
 ServiceWorkerImpl::SetState(ServiceWorkerState aState)
diff --git a/dom/serviceworkers/ServiceWorkerImpl.h b/dom/serviceworkers/ServiceWorkerImpl.h
--- a/dom/serviceworkers/ServiceWorkerImpl.h
+++ b/dom/serviceworkers/ServiceWorkerImpl.h
@@ -26,17 +26,17 @@ class ServiceWorkerImpl final : public S
   // ServiceWorker::Inner interface
   void
   AddServiceWorker(ServiceWorker* aWorker) override;
 
   void
   RemoveServiceWorker(ServiceWorker* aWorker) override;
 
   void
-  PostMessage(ipc::StructuredCloneData&& aData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState) override;
 
   // ServiceWorkerInfo::Listener interface
   void
   SetState(ServiceWorkerState aState) override;
 
 public:
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -238,17 +238,17 @@ void
 ServiceWorkerInfo::RemoveListener(Listener* aListener)
 {
   MOZ_DIAGNOSTIC_ASSERT(aListener);
   DebugOnly<bool> removed = mInstances.RemoveElement(aListener);
   MOZ_ASSERT(removed);
 }
 
 void
-ServiceWorkerInfo::PostMessage(ipc::StructuredCloneData&& aData,
+ServiceWorkerInfo::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mServiceWorkerPrivate->SendMessageEvent(Move(aData),
                                           ClientInfoAndState(aClientInfo.ToIPC(),
                                                              aClientState.ToIPC()));
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -13,16 +13,17 @@
 #include "mozilla/OriginAttributes.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientInfoAndState;
 class ClientState;
+class ServiceWorkerCloneData;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
@@ -93,17 +94,17 @@ public:
 
   void
   AddListener(Listener* aListener);
 
   void
   RemoveListener(Listener* aListener);
 
   void
-  PostMessage(ipc::StructuredCloneData&& aData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState);
 
   class ServiceWorkerPrivate*
   WorkerPrivate() const
   {
     MOZ_ASSERT(mServiceWorkerPrivate);
     return mServiceWorkerPrivate;
diff --git a/dom/serviceworkers/ServiceWorkerParent.cpp b/dom/serviceworkers/ServiceWorkerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerParent.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerParent.h"
 
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerProxy.h"
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 
 namespace mozilla {
 namespace dom {
 
@@ -32,20 +33,20 @@ ServiceWorkerParent::RecvTeardown()
   MaybeSendDelete();
   return IPC_OK();
 }
 
 IPCResult
 ServiceWorkerParent::RecvPostMessage(const ClonedMessageData& aClonedData,
                                      const ClientInfoAndState& aSource)
 {
-  StructuredCloneData clonedData;
-  clonedData.CopyFromClonedMessageDataForBackgroundParent(aClonedData);
+  RefPtr<ServiceWorkerCloneData> data = new ServiceWorkerCloneData();
+  data->CopyFromClonedMessageDataForBackgroundParent(aClonedData);
 
-  mProxy->PostMessage(Move(clonedData), ClientInfo(aSource.info()),
+  mProxy->PostMessage(Move(data), ClientInfo(aSource.info()),
                       ClientState::FromIPC(aSource.state()));
 
   return IPC_OK();
 }
 
 ServiceWorkerParent::ServiceWorkerParent()
   : mDeleteSent(false)
 {
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.cpp b/dom/serviceworkers/ServiceWorkerPrivate.cpp
--- a/dom/serviceworkers/ServiceWorkerPrivate.cpp
+++ b/dom/serviceworkers/ServiceWorkerPrivate.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerPrivate.h"
 
+#include "ServiceWorkerCloneData.h"
 #include "ServiceWorkerManager.h"
 #include "nsContentUtils.h"
 #include "nsICacheInfoChannel.h"
 #include "nsIHttpChannelInternal.h"
 #include "nsIHttpHeaderVisitor.h"
 #include "nsINamed.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIPushErrorReporter.h"
@@ -29,17 +30,16 @@
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
-#include "mozilla/dom/StructuredCloneHolder.h"
 #include "mozilla/dom/WorkerDebugger.h"
 #include "mozilla/dom/WorkerRef.h"
 #include "mozilla/dom/WorkerRunnable.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
@@ -516,45 +516,46 @@ public:
       return NS_ERROR_XPC_JS_THREW_EXCEPTION;
     }
 
     return NS_OK;
   }
 };
 
 class SendMessageEventRunnable final : public ExtendableEventWorkerRunnable
-                                     , public StructuredCloneHolder
 {
   const ClientInfoAndState mClientInfoAndState;
+  RefPtr<ServiceWorkerCloneData> mData;
 
 public:
   SendMessageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                            KeepAliveToken* aKeepAliveToken,
-                           const ClientInfoAndState& aClientInfoAndState)
+                           const ClientInfoAndState& aClientInfoAndState,
+                           RefPtr<ServiceWorkerCloneData>&& aData)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
-    , StructuredCloneHolder(CloningSupported, TransferringSupported,
-                            JS::StructuredCloneScope::SameProcessDifferentThread)
     , mClientInfoAndState(aClientInfoAndState)
+    , mData(Move(aData))
   {
     MOZ_ASSERT(NS_IsMainThread());
+    MOZ_DIAGNOSTIC_ASSERT(mData);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
-    Read(sgo, aCx, &messageData, rv);
+    mData->Read(aCx, &messageData, rv);
     if (NS_WARN_IF(rv.Failed())) {
       return true;
     }
 
     Sequence<OwningNonNull<MessagePort>> ports;
-    if (!TakeTransferredPortsAsSequence(ports)) {
+    if (!mData->TakeTransferredPortsAsSequence(ports)) {
       return true;
     }
 
     RootedDictionary<ExtendableMessageEventInit> init(aCx);
 
     init.mBubbles = false;
     init.mCancelable = false;
 
@@ -579,85 +580,28 @@ public:
                                                              extendableEvent,
                                                              nullptr));
   }
 };
 
 } // anonymous namespace
 
 nsresult
-ServiceWorkerPrivate::SendMessageEvent(ipc::StructuredCloneData&& aData,
+ServiceWorkerPrivate::SendMessageEvent(RefPtr<ServiceWorkerCloneData>&& aData,
                                        const ClientInfoAndState& aClientInfoAndState)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  ErrorResult rv;
-
-  // Ideally we would simply move the StructuredCloneData to the
-  // SendMessageEventRunnable, but we cannot because it uses non-threadsafe
-  // ref-counting.  The following gnarly code unpacks the IPC-friendly
-  // StructuredCloneData and re-packs it into the thread-friendly
-  // StructuredCloneHolder.  In the future we should remove this and make
-  // it easier to simple move the data to the other thread.  See bug 1458936.
-
-  AutoSafeJSContext cx;
-  JSObject* sandbox = GetOrCreateSandbox(cx);
-  NS_ENSURE_TRUE(sandbox, NS_ERROR_FAILURE);
-
-  JS::Rooted<JSObject*> global(cx, sandbox);
-  NS_ENSURE_TRUE(sandbox, NS_ERROR_FAILURE);
-
-  // The CreateSandbox call returns a proxy to the actual sandbox object.  We
-  // don't need a proxy here.
-  global = js::UncheckedUnwrap(global);
-
-  JSAutoRealm ar(cx, global);
-
-  JS::Rooted<JS::Value> messageData(cx);
-  aData.Read(cx, &messageData, rv);
-  if (rv.Failed()) {
-    return rv.StealNSResult();
-  }
-
-  Sequence<OwningNonNull<MessagePort>> ports;
-  if (!aData.TakeTransferredPortsAsSequence(ports)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  JS::Rooted<JSObject*> array(cx, JS_NewArrayObject(cx, ports.Length()));
-  NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);
-
-  for (uint32_t i = 0; i < ports.Length(); ++i) {
-    JS::Rooted<JS::Value> value(cx);
-    if (!GetOrCreateDOMReflector(cx, ports[i], &value)) {
-      JS_ClearPendingException(cx);
-      return NS_ERROR_FAILURE;
-    }
-
-    if (!JS_DefineElement(cx, array, i, value, JSPROP_ENUMERATE)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-
-  JS::Rooted<JS::Value> transferable(cx);
-  transferable.setObject(*array);
-
-  rv = SpawnWorkerIfNeeded(MessageEvent);
-  if (NS_WARN_IF(rv.Failed())) {
-    return rv.StealNSResult();
-  }
+  nsresult rv = SpawnWorkerIfNeeded(MessageEvent);
+  NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
   RefPtr<SendMessageEventRunnable> runnable =
-    new SendMessageEventRunnable(mWorkerPrivate, token, aClientInfoAndState);
-
-  runnable->Write(cx, messageData, transferable, JS::CloneDataPolicy(), rv);
-  if (rv.Failed()) {
-    return rv.StealNSResult();
-  }
+    new SendMessageEventRunnable(mWorkerPrivate, token, aClientInfoAndState,
+                                 Move(aData));
 
   if (!runnable->Dispatch()) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.h b/dom/serviceworkers/ServiceWorkerPrivate.h
--- a/dom/serviceworkers/ServiceWorkerPrivate.h
+++ b/dom/serviceworkers/ServiceWorkerPrivate.h
@@ -19,16 +19,17 @@ class nsIWorkerDebugger;
 namespace mozilla {
 
 class JSObjectHolder;
 
 namespace dom {
 
 class ClientInfoAndState;
 class KeepAliveToken;
+class ServiceWorkerCloneData;
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
 
 namespace ipc {
 class StructuredCloneData;
 } // namespace ipc
 
 class LifeCycleEventCallback : public Runnable
@@ -85,17 +86,17 @@ public:
 protected:
   nsCycleCollectingAutoRefCnt mRefCnt;
   NS_DECL_OWNINGTHREAD
 
 public:
   explicit ServiceWorkerPrivate(ServiceWorkerInfo* aInfo);
 
   nsresult
-  SendMessageEvent(ipc::StructuredCloneData&& aData,
+  SendMessageEvent(RefPtr<ServiceWorkerCloneData>&& aData,
                    const ClientInfoAndState& aClientInfoAndState);
 
   // This is used to validate the worker script and continue the installation
   // process.
   nsresult
   CheckScriptEvaluation(LifeCycleEventCallback* aCallback);
 
   nsresult
diff --git a/dom/serviceworkers/ServiceWorkerProxy.cpp b/dom/serviceworkers/ServiceWorkerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerProxy.cpp
@@ -137,26 +137,26 @@ ServiceWorkerProxy::RevokeActor(ServiceW
 
   nsCOMPtr<nsIRunnable> r =
     NewRunnableMethod(__func__, this,
                       &ServiceWorkerProxy::StopListeningOnMainThread);
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 }
 
 void
-ServiceWorkerProxy::PostMessage(StructuredCloneData&& aClonedData,
+ServiceWorkerProxy::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                 const ClientInfo& aClientInfo,
                                 const ClientState& aClientState)
 {
   AssertIsOnBackgroundThread();
   RefPtr<ServiceWorkerProxy> self = this;
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
-    [self, aClonedData = Move(aClonedData), aClientInfo, aClientState] () mutable {
+    [self, data = Move(aData), aClientInfo, aClientState] () mutable {
       if (!self->mInfo) {
         return;
       }
-      self->mInfo->PostMessage(Move(aClonedData), aClientInfo, aClientState);
+      self->mInfo->PostMessage(Move(data), aClientInfo, aClientState);
     });
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerProxy.h b/dom/serviceworkers/ServiceWorkerProxy.h
--- a/dom/serviceworkers/ServiceWorkerProxy.h
+++ b/dom/serviceworkers/ServiceWorkerProxy.h
@@ -9,20 +9,17 @@
 
 #include "nsProxyRelease.h"
 #include "ServiceWorkerDescriptor.h"
 #include "ServiceWorkerInfo.h"
 
 namespace mozilla {
 namespace dom {
 
-namespace ipc {
-class StructuredCloneData;
-} // namespace ipc
-
+class ServiceWorkerCloneData;
 class ServiceWorkerInfo;
 class ServiceWorkerParent;
 
 class ServiceWorkerProxy final : public ServiceWorkerInfo::Listener
 {
   // Background thread only
   ServiceWorkerParent* mActor;
 
@@ -59,17 +56,17 @@ class ServiceWorkerProxy final : public 
 public:
   ServiceWorkerProxy(ServiceWorkerParent* aActor,
                      const ServiceWorkerDescriptor& aDescriptor);
 
   void
   RevokeActor(ServiceWorkerParent* aActor);
 
   void
-  PostMessage(ipc::StructuredCloneData&& aClonedData,
+  PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aState);
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerProxy, override);
 };
 
 } // namespace dom
 } // namespace mozilla
