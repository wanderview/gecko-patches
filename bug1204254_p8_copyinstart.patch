# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  21667c7e9578c36eb574e0b75ab68f2e6315bead
Bug 1204254 P8 Move the body stream copying into the nsIInterceptedChannel::StartSynthesizedResponse() method. r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -159,18 +159,126 @@ FetchEvent::Constructor(const GlobalObje
   e->mRequest = aOptions.mRequest;
   e->mClientId = aOptions.mClientId;
   e->mIsReload = aOptions.mIsReload;
   return e.forget();
 }
 
 namespace {
 
-struct RespondWithClosure;
-void RespondWithCopyComplete(void* aClosure, nsresult aStatus);
+struct RespondWithClosure
+{
+  nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
+  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
+  const nsString mRequestURL;
+  const nsCString mRespondWithScriptSpec;
+  const uint32_t mRespondWithLineNumber;
+  const uint32_t mRespondWithColumnNumber;
+
+  RespondWithClosure(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
+                     nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
+                     const nsAString& aRequestURL,
+                     const nsACString& aRespondWithScriptSpec,
+                     uint32_t aRespondWithLineNumber,
+                     uint32_t aRespondWithColumnNumber)
+    : mInterceptedChannel(aChannel)
+    , mRegistration(aRegistration)
+    , mRequestURL(aRequestURL)
+    , mRespondWithScriptSpec(aRespondWithScriptSpec)
+    , mRespondWithLineNumber(aRespondWithLineNumber)
+    , mRespondWithColumnNumber(aRespondWithColumnNumber)
+  {
+  }
+};
+
+class FinishResponse final : public Runnable
+{
+  nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
+
+public:
+  explicit FinishResponse(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel)
+    : Runnable("dom::workers::FinishResponse")
+    , mChannel(aChannel)
+  {
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnMainThread();
+
+    nsresult rv = mChannel->FinishSynthesizedResponse();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
+      return NS_OK;
+    }
+
+    TimeStamp timeStamp = TimeStamp::Now();
+    mChannel->SetHandleFetchEventEnd(timeStamp);
+    mChannel->SetFinishSynthesizedResponseEnd(timeStamp);
+    mChannel->SaveTimeStamps();
+
+    nsCOMPtr<nsIObserverService> obsService = services::GetObserverService();
+    if (obsService) {
+      nsCOMPtr<nsIChannel> underlyingChannel;
+      nsresult rv = mChannel->GetChannel(getter_AddRefs(underlyingChannel));
+      NS_ENSURE_SUCCESS(rv, rv);
+      NS_ENSURE_TRUE(underlyingChannel, NS_ERROR_UNEXPECTED);
+
+      obsService->NotifyObservers(underlyingChannel, "service-worker-synthesized-response", nullptr);
+    }
+
+    return rv;
+  }
+};
+
+class BodyCopyHandle final : public nsIInterceptedBodyCallback
+{
+  UniquePtr<RespondWithClosure> mClosure;
+
+  ~BodyCopyHandle()
+  {
+  }
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  explicit BodyCopyHandle(UniquePtr<RespondWithClosure>&& aClosure)
+    : mClosure(Move(aClosure))
+  {
+  }
+
+  NS_IMETHOD
+  BodyComplete(nsresult aRv) override
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    nsCOMPtr<nsIRunnable> event;
+    if (NS_WARN_IF(NS_FAILED(aRv))) {
+      AsyncLog(mClosure->mInterceptedChannel, mClosure->mRespondWithScriptSpec,
+               mClosure->mRespondWithLineNumber,
+               mClosure->mRespondWithColumnNumber,
+               NS_LITERAL_CSTRING("InterceptionFailedWithURL"),
+               mClosure->mRequestURL);
+      event = new CancelChannelRunnable(mClosure->mInterceptedChannel,
+                                        mClosure->mRegistration,
+                                        NS_ERROR_INTERCEPTION_FAILED);
+    } else {
+      event = new FinishResponse(mClosure->mInterceptedChannel);
+    }
+
+    mClosure.reset();
+
+    event->Run();
+
+    return NS_OK;
+  }
+};
+
+NS_IMPL_ISUPPORTS(BodyCopyHandle, nsIInterceptedBodyCallback)
 
 class StartResponse final : public Runnable
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
   RefPtr<InternalResponse> mInternalResponse;
   ChannelInfo mWorkerChannelInfo;
   const nsCString mScriptSpec;
   const nsCString mResponseURLSpec;
@@ -234,71 +342,31 @@ public:
     mInternalResponse->UnfilteredHeaders()->GetEntries(entries);
     for (uint32_t i = 0; i < entries.Length(); ++i) {
        mChannel->SynthesizeHeader(entries[i].mName, entries[i].mValue);
     }
 
     auto castLoadInfo = static_cast<LoadInfo*>(loadInfo.get());
     castLoadInfo->SynthesizeServiceWorkerTainting(mInternalResponse->GetTainting());
 
-    rv = mChannel->StartSynthesizedResponse(nullptr, nullptr,
+    nsCOMPtr<nsIInputStream> body;
+    mInternalResponse->GetUnfilteredBody(getter_AddRefs(body));
+    RefPtr<BodyCopyHandle> copyHandle;
+    // Errors and redirects may not have a body.
+    if (body) {
+      copyHandle = new BodyCopyHandle(Move(mClosure));
+    }
+
+    rv = mChannel->StartSynthesizedResponse(body, copyHandle,
                                             mResponseURLSpec);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
-    // Only start copying after we have begun synthesizing the response.
-    // Some of the necko invariants can fail if we trigger an OnDataAvailable
-    // too early.
-    nsCOMPtr<nsIInputStream> body;
-    mInternalResponse->GetUnfilteredBody(getter_AddRefs(body));
-    // Errors and redirects may not have a body.
-    if (body) {
-      nsCOMPtr<nsIOutputStream> responseBody;
-      rv = mChannel->GetResponseBody(getter_AddRefs(responseBody));
-      if (NS_WARN_IF(NS_FAILED(rv)) || !responseBody) {
-        return rv;
-      }
-
-      const uint32_t kCopySegmentSize = 4096;
-
-      // Depending on how the Response passed to .respondWith() was created, we may
-      // get a non-buffered input stream.  In addition, in some configurations the
-      // destination channel's output stream can be unbuffered.  We wrap the output
-      // stream side here so that NS_AsyncCopy() works.  Wrapping the output side
-      // provides the most consistent operation since there are fewer stream types
-      // we are writing to.  The input stream can be a wide variety of concrete
-      // objects which may or many not play well with NS_InputStreamIsBuffered().
-      if (!NS_OutputStreamIsBuffered(responseBody)) {
-        nsCOMPtr<nsIOutputStream> buffered;
-        rv = NS_NewBufferedOutputStream(getter_AddRefs(buffered), responseBody,
-             kCopySegmentSize);
-        if (NS_WARN_IF(NS_FAILED(rv))) {
-          return rv;
-        }
-        responseBody = buffered;
-      }
-
-      nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
-      if (NS_WARN_IF(!stsThread)) {
-        return NS_ERROR_FAILURE;
-      }
-
-      // XXXnsm, Fix for Bug 1141332 means that if we decide to make this
-      // streaming at some point, we'll need a different solution to that bug.
-      rv = NS_AsyncCopy(body, responseBody, stsThread, NS_ASYNCCOPY_VIA_WRITESEGMENTS,
-                        kCopySegmentSize, RespondWithCopyComplete, mClosure.release());
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        return rv;
-      }
-    } else {
-      RespondWithCopyComplete(mClosure.release(), NS_OK);
-    }
-
     return rv;
   }
 
   bool CSPPermitsResponse(nsILoadInfo* aLoadInfo)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aLoadInfo);
     nsresult rv;
@@ -315,57 +383,16 @@ public:
                                    aLoadInfo->LoadingPrincipal(),
                                    aLoadInfo->LoadingNode(), EmptyCString(),
                                    nullptr, &decision);
     NS_ENSURE_SUCCESS(rv, false);
     return decision == nsIContentPolicy::ACCEPT;
   }
 };
 
-class FinishResponse final : public Runnable
-{
-  nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
-
-public:
-  explicit FinishResponse(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel)
-    : Runnable("dom::workers::FinishResponse")
-    , mChannel(aChannel)
-  {
-  }
-
-  NS_IMETHOD
-  Run() override
-  {
-    AssertIsOnMainThread();
-
-    nsresult rv = mChannel->FinishSynthesizedResponse();
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
-      return NS_OK;
-    }
-
-    TimeStamp timeStamp = TimeStamp::Now();
-    mChannel->SetHandleFetchEventEnd(timeStamp);
-    mChannel->SetFinishSynthesizedResponseEnd(timeStamp);
-    mChannel->SaveTimeStamps();
-
-    nsCOMPtr<nsIObserverService> obsService = services::GetObserverService();
-    if (obsService) {
-      nsCOMPtr<nsIChannel> underlyingChannel;
-      nsresult rv = mChannel->GetChannel(getter_AddRefs(underlyingChannel));
-      NS_ENSURE_SUCCESS(rv, rv);
-      NS_ENSURE_TRUE(underlyingChannel, NS_ERROR_UNEXPECTED);
-
-      obsService->NotifyObservers(underlyingChannel, "service-worker-synthesized-response", nullptr);
-    }
-
-    return rv;
-  }
-};
-
 class RespondWithHandler final : public PromiseNativeHandler
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
   const RequestMode mRequestMode;
   const RequestRedirect mRequestRedirectMode;
 #ifdef DEBUG
   const bool mIsClientRequest;
@@ -430,66 +457,16 @@ private:
       ::AsyncLog(mInterceptedChannel, mRespondWithScriptSpec,
                  mRespondWithLineNumber, mRespondWithColumnNumber,
                  NS_LITERAL_CSTRING("InterceptionFailedWithURL"), mRequestURL);
       CancelRequest(NS_ERROR_INTERCEPTION_FAILED);
     }
   }
 };
 
-struct RespondWithClosure
-{
-  nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
-  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
-  const nsString mRequestURL;
-  const nsCString mRespondWithScriptSpec;
-  const uint32_t mRespondWithLineNumber;
-  const uint32_t mRespondWithColumnNumber;
-
-  RespondWithClosure(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
-                     nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
-                     const nsAString& aRequestURL,
-                     const nsACString& aRespondWithScriptSpec,
-                     uint32_t aRespondWithLineNumber,
-                     uint32_t aRespondWithColumnNumber)
-    : mInterceptedChannel(aChannel)
-    , mRegistration(aRegistration)
-    , mRequestURL(aRequestURL)
-    , mRespondWithScriptSpec(aRespondWithScriptSpec)
-    , mRespondWithLineNumber(aRespondWithLineNumber)
-    , mRespondWithColumnNumber(aRespondWithColumnNumber)
-  {
-  }
-};
-
-void RespondWithCopyComplete(void* aClosure, nsresult aStatus)
-{
-  UniquePtr<RespondWithClosure> data(static_cast<RespondWithClosure*>(aClosure));
-  nsCOMPtr<nsIRunnable> event;
-  if (NS_WARN_IF(NS_FAILED(aStatus))) {
-    AsyncLog(data->mInterceptedChannel, data->mRespondWithScriptSpec,
-             data->mRespondWithLineNumber, data->mRespondWithColumnNumber,
-             NS_LITERAL_CSTRING("InterceptionFailedWithURL"),
-             data->mRequestURL);
-    event = new CancelChannelRunnable(data->mInterceptedChannel,
-                                      data->mRegistration,
-                                      NS_ERROR_INTERCEPTION_FAILED);
-  } else {
-    event = new FinishResponse(data->mInterceptedChannel);
-  }
-
-  // In theory this can happen after the worker thread is terminated.
-  if (NS_IsMainThread()) {
-    event->Run();
-    return;
-  }
-
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(event.forget()));
-}
-
 class MOZ_STACK_CLASS AutoCancel
 {
   RefPtr<RespondWithHandler> mOwner;
   nsCString mSourceSpec;
   uint32_t mLine;
   uint32_t mColumn;
   nsCString mMessageName;
   nsTArray<nsString> mParams;
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -2,43 +2,144 @@
 /* vim:set expandtab ts=2 sw=2 sts=2 cin: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "HttpLog.h"
 
 #include "InterceptedChannel.h"
+#include "nsICancelable.h"
 #include "nsInputStreamPump.h"
 #include "nsIPipe.h"
 #include "nsIStreamListener.h"
 #include "nsITimedChannel.h"
 #include "nsHttpChannel.h"
 #include "HttpChannelChild.h"
 #include "nsHttpResponseHead.h"
 #include "nsNetUtil.h"
 #include "mozilla/ConsoleReportCollector.h"
 #include "mozilla/dom/ChannelInfo.h"
 #include "nsIChannelEventSink.h"
+#include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace net {
 
 extern nsresult
 DoUpdateExpirationTime(nsHttpChannel* aSelf,
                        nsICacheEntry* aCacheEntry,
                        nsHttpResponseHead* aResponseHead,
                        uint32_t& aExpirationTime);
 extern nsresult
 DoAddCacheEntryHeaders(nsHttpChannel *self,
                        nsICacheEntry *entry,
                        nsHttpRequestHead *requestHead,
                        nsHttpResponseHead *responseHead,
                        nsISupports *securityInfo);
 
+namespace {
+
+struct StreamCopyClosure
+{
+  nsCOMPtr<nsIInterceptedBodyCallback> mCallback;
+  nsCOMPtr<nsIEventTarget> mTarget;
+
+  explicit StreamCopyClosure(nsIInterceptedBodyCallback* aCallback)
+    : mCallback(aCallback)
+    , mTarget(GetCurrentThreadSerialEventTarget())
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mCallback);
+  }
+
+  StreamCopyClosure() = delete;
+  StreamCopyClosure(const StreamCopyClosure&) = delete;
+};
+
+void
+StreamCopyComplete(void* aClosure, nsresult aStatus)
+{
+  UniquePtr<StreamCopyClosure> closure(static_cast<StreamCopyClosure*>(aClosure));
+
+  if (!closure) {
+    return;
+  }
+
+  nsCOMPtr<nsIEventTarget> target = closure->mTarget.forget();
+
+  // We need to be careful to only run/addref the provided callbacks on the
+  // original thread.  The xpcshell tests pass js runnables which cannot
+  // be used from a separate thread.  Therefore we pass the closure pointer
+  // to our runnable by forgetting it and re-acquiring it in the lambda.
+  StreamCopyClosure* dispatchedClosure = closure.release();
+
+  nsCOMPtr<nsIRunnable> runnable =
+    NS_NewRunnableFunction("InterceptedChannel::StreamCopyCompelte",
+                           [aStatus, dispatchedClosure]() {
+      UniquePtr<StreamCopyClosure> closure(dispatchedClosure);
+      if (closure->mCallback) {
+        closure->mCallback->BodyComplete(aStatus);
+      }
+    });
+
+  MOZ_ALWAYS_SUCCEEDS(
+    target->Dispatch(runnable.forget(), nsIThread::DISPATCH_NORMAL));
+}
+
+nsresult
+StreamCopyStart(nsIOutputStream* aWriter,
+                nsIInputStream* aReader,
+                nsIInterceptedBodyCallback* aCallback)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWriter);
+  MOZ_DIAGNOSTIC_ASSERT(aReader);
+
+  // Use a strong ref because we might need to hold a new stream
+  // alive if we decide to wrap the one passed to us.
+  nsCOMPtr<nsIOutputStream> writer(aWriter);
+
+  const uint32_t kCopySegmentSize = 4096;
+  nsresult rv = NS_OK;
+
+  // Depending on how the Response passed to .respondWith() was created, we may
+  // get a non-buffered input stream.  In addition, in some configurations the
+  // destination channel's output stream can be unbuffered.  We wrap the output
+  // stream side here so that NS_AsyncCopy() works.  Wrapping the output side
+  // provides the most consistent operation since there are fewer stream types
+  // we are writing to.  The input stream can be a wide variety of concrete
+  // objects which may or many not play well with NS_InputStreamIsBuffered().
+  if (!NS_OutputStreamIsBuffered(writer)) {
+    nsCOMPtr<nsIOutputStream> buffered;
+    rv = NS_NewBufferedOutputStream(getter_AddRefs(buffered), writer,
+                                    kCopySegmentSize);
+    NS_ENSURE_SUCCESS(rv, rv);
+    NS_ENSURE_TRUE(buffered, rv);
+
+    writer = buffered.forget();
+  }
+
+  nsCOMPtr<nsIEventTarget> stsThread =
+    do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(stsThread, NS_ERROR_FAILURE);
+
+  UniquePtr<StreamCopyClosure> closure;
+  if (aCallback) {
+    closure = MakeUnique<StreamCopyClosure>(aCallback);
+  }
+
+  rv = NS_AsyncCopy(aReader, writer, stsThread, NS_ASYNCCOPY_VIA_WRITESEGMENTS,
+                    kCopySegmentSize, StreamCopyComplete, closure.release());
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+} // anonymous namespace
+
 NS_IMPL_ISUPPORTS(InterceptedChannelBase, nsIInterceptedChannel)
 
 InterceptedChannelBase::InterceptedChannelBase(nsINetworkInterceptController* aController)
   : mController(aController)
   , mReportCollector(new ConsoleReportCollector())
   , mClosed(false)
   , mSynthesizedOrReset(Invalid)
 {
@@ -314,16 +415,26 @@ InterceptedChannelContent::StartSynthesi
     mChannel->ForceIntercepted(mSynthesizedInput);
     mChannel->BeginNonIPCRedirect(responseURI, *mSynthesizedResponseHead.ptr());
   } else {
     mChannel->OverrideWithSynthesizedResponse(mSynthesizedResponseHead.ref(),
                                               mSynthesizedInput,
                                               mStreamListener);
   }
 
+  if (!aBody) {
+    if (aBodyCallback) {
+      aBodyCallback->BodyComplete(NS_OK);
+    }
+  } else {
+    nsresult rv = StreamCopyStart(mResponseBody, aBody,
+                                  aBodyCallback);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::FinishSynthesizedResponse()
 {
   if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -42,16 +42,17 @@ InterceptedHttpChannel::ReleaseListeners
   }
   HttpBaseChannel::ReleaseListeners();
   mSynthesizedResponseHead.reset();
   mRedirectChannel = nullptr;
   mBodyReader = nullptr;
   mBodyWriter = nullptr;
   mReleaseHandle = nullptr;
   mProgressSink = nullptr;
+  mBodyCallback = nullptr;
   mPump = nullptr;
   mParentChannel = nullptr;
 
   MOZ_DIAGNOSTIC_ASSERT(!mIsPending);
 }
 
 nsresult
 InterceptedHttpChannel::SetupReplacementChannel(nsIURI *aURI,
@@ -159,18 +160,23 @@ InterceptedHttpChannel::RedirectForOpaqu
   // Perform an internal redirect to another InterceptedHttpChannel using
   // the given cross-origin response URL.  The resulting channel will then
   // process the synthetic response as normal.  This extra redirect is
   // performed so that listeners treat the result as unsafe cross-origin
   // data.
 
   nsresult rv = NS_OK;
 
+  // We want to pass ownership of the body callback to the new synthesized
+  // channel.  We need to hold a reference to the callbacks on the stack
+  // as well, though, so we can call them if a failure occurs.
+  nsCOMPtr<nsIInterceptedBodyCallback> bodyCallback = mBodyCallback.forget();
+
   RefPtr<InterceptedHttpChannel> newChannel =
-    CreateForSynthesis(mResponseHead, mBodyReader);
+    CreateForSynthesis(mResponseHead, mBodyReader, bodyCallback);
 
   rv = newChannel->Init(aResponseURI, mCaps,
                         static_cast<nsProxyInfo*>(mProxyInfo.get()),
                         mProxyResolveFlags, mProxyURI, mChannelId);
 
   uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
 
   nsCOMPtr<nsILoadInfo> redirectLoadInfo =
@@ -181,16 +187,21 @@ InterceptedHttpChannel::RedirectForOpaqu
   rv = SetupReplacementChannel(aResponseURI, newChannel, true, flags);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mRedirectChannel = newChannel;
 
   rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
 
   if (NS_FAILED(rv)) {
+    // Make sure to call the body callback since we took ownership
+    // above.  Neither the new channel or our standard
+    // OnRedirectVerifyCallback() code will invoke the callback.  Do it here.
+    bodyCallback->BodyComplete(rv);
+
     OnRedirectVerifyCallback(rv);
   }
 
   return rv;
 }
 
 nsresult
 InterceptedHttpChannel::StartPump()
@@ -319,40 +330,51 @@ InterceptedHttpChannel::MaybeCallStatusA
                           mStatusHost.get());
 
   mProgressSink->OnProgress(this, mListenerContext, progress,
                             mSynthesizedStreamLength);
 
   mProgressReported = progress;
 }
 
+void
+InterceptedHttpChannel::MaybeCallBodyCallback()
+{
+  nsCOMPtr<nsIInterceptedBodyCallback> callback = mBodyCallback.forget();
+  if (callback) {
+    callback->BodyComplete(mStatus);
+  }
+}
+
 // static
 already_AddRefed<InterceptedHttpChannel>
 InterceptedHttpChannel::CreateForInterception()
 {
   // Create an InterceptedHttpChannel that will trigger a FetchEvent
   // in a ServiceWorker when opened.
   RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
   return ref.forget();
 }
 
 // static
 already_AddRefed<InterceptedHttpChannel>
 InterceptedHttpChannel::CreateForSynthesis(const nsHttpResponseHead* aHead,
-                                           nsIInputStream* aBody)
+                                           nsIInputStream* aBody,
+                                           nsIInterceptedBodyCallback* aBodyCallback)
 {
   MOZ_DIAGNOSTIC_ASSERT(aHead);
   MOZ_DIAGNOSTIC_ASSERT(aBody);
 
   // Create an InterceptedHttpChannel that already has a synthesized response.
   // The synthetic response will be processed when opened.  A FetchEvent
   // will not be triggered.
   RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+  ref->mResponseHead = new nsHttpResponseHead(*aHead);
   ref->mBodyReader = aBody;
-  ref->mResponseHead = new nsHttpResponseHead(*aHead);
+  ref->mBodyCallback = aBodyCallback;
 
   return ref.forget();
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::Cancel(nsresult aStatus)
 {
   return CancelInterception(aStatus);
@@ -617,31 +639,43 @@ InterceptedHttpChannel::SynthesizeHeader
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::StartSynthesizedResponse(nsIInputStream* aBody,
                                                  nsIInterceptedBodyCallback* aBodyCallback,
                                                  const nsACString& aFinalURLSpec)
 {
   if (mCanceled) {
+    if (aBodyCallback) {
+      aBodyCallback->BodyComplete(mStatus);
+    }
     return mStatus;
   }
 
+  // Take ownership of the body callbacks  We expect that if a failure
+  // occurs here our caller will call Cancel().  This will then invoke
+  // OnStopRequest() which will invoke the correct callback.  We also
+  // invoke callbacks if we skip reading the body due to following a
+  // redirect, etc.  In the case of an opaque response redirect we pass
+  // ownership of the callbacks to the new channel.
+  mBodyCallback = aBodyCallback;
+
   if (!mSynthesizedResponseHead) {
     mSynthesizedResponseHead.reset(new nsHttpResponseHead());
   }
 
   mResponseHead = mSynthesizedResponseHead.release();
 
   if (ShouldRedirect()) {
     return FollowSyntheticRedirect();
   }
 
   SetApplyConversion(false);
 
+  mBodyReader = aBody;
   if (!mBodyReader) {
     nsresult rv = NS_NewCStringInputStream(getter_AddRefs(mBodyReader),
                                            EmptyCString());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIURI> responseURI;
   if (!aFinalURLSpec.IsEmpty()) {
@@ -873,16 +907,18 @@ InterceptedHttpChannel::OnRedirectVerify
   if (hook) {
     hook->OnRedirectResult(NS_SUCCEEDED(rv));
   }
 
   if (NS_FAILED(rv)) {
     Cancel(rv);
   }
 
+  MaybeCallBodyCallback();
+
   mIsPending = false;
   ReleaseListeners();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnStartRequest(nsIRequest* aRequest,
@@ -905,16 +941,18 @@ InterceptedHttpChannel::OnStopRequest(ns
                                       nsresult aStatus)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_SUCCEEDED(mStatus)) {
     mStatus = aStatus;
   }
 
+  MaybeCallBodyCallback();
+
   // Its possible that we have any async runnable queued to report some
   // progress when OnStopRequest() is triggered.  Report any left over
   // progress immediately.  The extra runnable will then do nothing thanks
   // to the ReleaseListeners() call below.
   MaybeCallStatusAndProgress();
 
   mIsPending = false;
 
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -59,16 +59,17 @@ class InterceptedHttpChannel final : pub
   friend class HttpAsyncAborter<InterceptedHttpChannel>;
 
   UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIInputStream> mBodyReader;
   nsCOMPtr<nsIOutputStream> mBodyWriter;
   nsCOMPtr<nsISupports> mReleaseHandle;
   nsCOMPtr<nsIProgressEventSink> mProgressSink;
+  nsCOMPtr<nsIInterceptedBodyCallback> mBodyCallback;
   RefPtr<nsInputStreamPump> mPump;
   RefPtr<ADivertableParentChannel> mParentChannel;
   TimeStamp mFinishResponseStart;
   TimeStamp mFinishResponseEnd;
   Atomic<int64_t> mProgress;
   int64_t mProgressReported;
   int64_t mSynthesizedStreamLength;
   uint64_t mResumeStartPos;
@@ -105,22 +106,26 @@ class InterceptedHttpChannel final : pub
   StartPump();
 
   nsresult
   OpenRedirectChannel();
 
   void
   MaybeCallStatusAndProgress();
 
+  void
+  MaybeCallBodyCallback();
+
 public:
   static already_AddRefed<InterceptedHttpChannel>
   CreateForInterception();
 
   static already_AddRefed<InterceptedHttpChannel>
-  CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody);
+  CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody,
+                     nsIInterceptedBodyCallback* aBodyCallback);
 
   NS_IMETHOD
   Cancel(nsresult aStatus) override;
 
   NS_IMETHOD
   Suspend(void) override;
 
   NS_IMETHOD
diff --git a/netwerk/test/unit/test_synthesized_response.js b/netwerk/test/unit/test_synthesized_response.js
--- a/netwerk/test/unit/test_synthesized_response.js
+++ b/netwerk/test/unit/test_synthesized_response.js
@@ -50,17 +50,17 @@ function make_channel(url, body, cb) {
     channelIntercepted: function(channel) {
       channel.QueryInterface(Ci.nsIInterceptedChannel);
       if (body) {
         var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                             .createInstance(Ci.nsIStringInputStream);
         synthesized.data = body;
 
         NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
-          channel.startSynthesizedResponse('');
+          channel.startSynthesizedResponse(null, null, null, '');
           channel.finishSynthesizedResponse();
         });
       }
       if (cb) {
         cb(channel);
       }
       return {
         dispatch: function() { }
@@ -141,17 +141,17 @@ add_test(function() {
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(channel) {
     do_timeout(100, function() {
       var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                           .createInstance(Ci.nsIStringInputStream);
       synthesized.data = NON_REMOTE_BODY;
       NetUtil.asyncCopy(synthesized, channel.responseBody, function() {
         channel.synthesizeHeader("Content-Length", NON_REMOTE_BODY.length);
-        channel.startSynthesizedResponse('');
+        channel.startSynthesizedResponse(null, null, null, '');
         channel.finishSynthesizedResponse();
       });
     });
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null));
 });
 
 // ensure that the channel waits for a decision
@@ -170,17 +170,17 @@ add_test(function() {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       // set the content-type to ensure that the stream converter doesn't hold up notifications
       // and cause the test to fail
       intercepted.synthesizeHeader("Content-Type", "text/plain");
-      intercepted.startSynthesizedResponse('');
+      intercepted.startSynthesizedResponse(null, null, null, '');
       intercepted.finishSynthesizedResponse();
     });
   });
   chan.asyncOpen2(new ChannelListener(handle_synthesized_response, null,
 				     CL_ALLOW_UNKNOWN_CL | CL_SUSPEND | CL_EXPECT_3S_DELAY));
 });
 
 // ensure that the intercepted channel can be cancelled
@@ -212,17 +212,17 @@ add_test(function() {
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       let channel = intercepted.channel;
-      intercepted.startSynthesizedResponse('');
+      intercepted.startSynthesizedResponse(null, null, null, '');
       intercepted.finishSynthesizedResponse();
       channel.cancel(Cr.NS_BINDING_ABORTED);
     });
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
@@ -230,17 +230,17 @@ add_test(function() {
 add_test(function() {
   var chan = make_channel(URL + '/body', null, function(intercepted) {
     var synthesized = Cc["@mozilla.org/io/string-input-stream;1"]
                         .createInstance(Ci.nsIStringInputStream);
     synthesized.data = NON_REMOTE_BODY;
 
     NetUtil.asyncCopy(synthesized, intercepted.responseBody, function() {
       intercepted.channel.cancel(Cr.NS_BINDING_ABORTED);
-      intercepted.startSynthesizedResponse('');
+      intercepted.startSynthesizedResponse(null, null, null, '');
       intercepted.finishSynthesizedResponse();
     });
   });
   chan.asyncOpen2(new ChannelListener(run_next_test, null,
                                      CL_EXPECT_FAILURE | CL_ALLOW_UNKNOWN_CL));
 });
 
 add_test(function() {
