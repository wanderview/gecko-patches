# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  19323169adcbd9cb3eab39d260cb80644e80eacb
Bug 1436812 P6 Implement ServiceWorkerContainer::GetReady() via the inner class. r=baku

diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -113,29 +113,16 @@ interface nsIServiceWorkerManagerListene
 
   void onUnregister(in nsIServiceWorkerRegistrationInfo aInfo);
 };
 
 [scriptable, builtinclass, uuid(7404c8e8-4d47-4449-8ed1-47d1261d4e33)]
 interface nsIServiceWorkerManager : nsISupports
 {
   /**
-   * Registers a ServiceWorker with script loaded from `aScriptURI` to act as
-   * the ServiceWorker for aScope.  Requires a valid entry settings object on
-   * the stack. This means you must call this from content code 'within'
-   * a window.
-   *
-   * Returns a Promise.
-   */
-  nsISupports register(in mozIDOMWindow aWindow,
-                       in nsIURI aScope,
-                       in nsIURI aScriptURI,
-                       in uint16_t aUpdateViaCache);
-
-  /**
    * Unregister an existing ServiceWorker registration for `aScope`.
    * It keeps aCallback alive until the operation is concluded.
    */
   void unregister(in nsIPrincipal aPrincipal,
                   in nsIServiceWorkerUnregisterCallback aCallback,
                   in DOMString aScope);
 
   nsIServiceWorkerRegistrationInfo getRegistrationByPrincipal(in nsIPrincipal aPrincipal,
diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -105,16 +105,17 @@ ServiceWorkerContainer::ControllerChange
 }
 
 JSObject*
 ServiceWorkerContainer::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return ServiceWorkerContainerBinding::Wrap(aCx, this, aGivenProto);
 }
 
+/* TODO
 static nsresult
 CheckForSlashEscapedCharsInPath(nsIURI* aURI)
 {
   MOZ_ASSERT(aURI);
 
   // A URL that can't be downcast to a standard URL is an invalid URL and should
   // be treated as such and fail with SecurityError.
   nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
@@ -131,22 +132,26 @@ CheckForSlashEscapedCharsInPath(nsIURI* 
   ToLowerCase(path);
   if (path.Find("%2f") != kNotFound ||
       path.Find("%5c") != kNotFound) {
     return NS_ERROR_DOM_TYPE_ERR;
   }
 
   return NS_OK;
 }
+*/
 
 already_AddRefed<Promise>
 ServiceWorkerContainer::Register(const nsAString& aScriptURL,
                                  const RegistrationOptions& aOptions,
                                  ErrorResult& aRv)
 {
+  // TODO
+  return nullptr;
+  /*
   nsCOMPtr<nsISupports> promise;
 
   nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
   if (!swm) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
@@ -214,16 +219,17 @@ ServiceWorkerContainer::Register(const n
                       getter_AddRefs(promise));
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   RefPtr<Promise> ret = static_cast<Promise*>(promise.get());
   MOZ_ASSERT(ret);
   return ret.forget();
+  */
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerContainer::GetController()
 {
   RefPtr<ServiceWorker> ref = mControllerWorker;
   return ref.forget();
 }
diff --git a/dom/serviceworkers/ServiceWorkerContainer.h b/dom/serviceworkers/ServiceWorkerContainer.h
--- a/dom/serviceworkers/ServiceWorkerContainer.h
+++ b/dom/serviceworkers/ServiceWorkerContainer.h
@@ -22,18 +22,20 @@ class ServiceWorker;
 // Lightweight serviceWorker APIs collection.
 class ServiceWorkerContainer final : public DOMEventTargetHelper
 {
 public:
   class Inner
   {
   public:
     virtual RefPtr<ServiceWorkerRegistrationPromise>
-    Register(const nsAString& aScriptURL,
-             const RegistrationOptions& aOptions) = 0;
+    Register(const ClientInfo& aClientInfo,
+             const nsACString& aScopeURL,
+             const nsACString& aScriptURL,
+             ServiceWorkerUpdateViaCache aUpdateViaCache) const = 0;
 
     virtual RefPtr<ServiceWorkerRegistrationPromise>
     GetRegistration(const ClientInfo& aClientInfo,
                     const nsACString& aURL) const = 0;
 
     virtual RefPtr<ServiceWorkerRegistrationListPromise>
     GetRegistrations(const ClientInfo& aClientInfo) const = 0;
 
diff --git a/dom/serviceworkers/ServiceWorkerContainerImpl.cpp b/dom/serviceworkers/ServiceWorkerContainerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerContainerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainerImpl.cpp
@@ -5,21 +5,28 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerContainerImpl.h"
 
 namespace mozilla {
 namespace dom {
 
 RefPtr<ServiceWorkerRegistrationPromise>
-ServiceWorkerContainerImpl::Register(const nsAString& aScriptURL,
-                                     const RegistrationOptions& aOptions)
+ServiceWorkerContainerImpl::Register(const ClientInfo& aClientInfo,
+                                     const nsACString& aScopeURL,
+                                     const nsACString& aScriptURL,
+                                     ServiceWorkerUpdateViaCache aUpdateViaCache) const
 {
-  // TODO
-  return nullptr;
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (NS_WARN_IF(!swm)) {
+    return ServiceWorkerRegistrationPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                                             __func__);
+  }
+
+  return swm->Register(aClientInfo, aScopeURL, aScriptURL, aUpdateViaCache);
 }
 
 RefPtr<ServiceWorkerRegistrationPromise>
 ServiceWorkerContainerImpl::GetRegistration(const ClientInfo& aClientInfo,
                                             const nsACString& aURL) const
 {
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(!swm)) {
diff --git a/dom/serviceworkers/ServiceWorkerContainerImpl.h b/dom/serviceworkers/ServiceWorkerContainerImpl.h
--- a/dom/serviceworkers/ServiceWorkerContainerImpl.h
+++ b/dom/serviceworkers/ServiceWorkerContainerImpl.h
@@ -16,18 +16,20 @@ namespace dom {
 class ServiceWorkerContainerImpl final : public ServiceWorkerContainer::Inner
 {
   ~ServiceWorkerContainerImpl() = default;
 
 public:
   ServiceWorkerContainerImpl() = default;
 
   RefPtr<ServiceWorkerRegistrationPromise>
-  Register(const nsAString& aScriptURL,
-           const RegistrationOptions& aOptions) override;
+  Register(const ClientInfo& aClientInfo,
+           const nsACString& aScopeURL,
+           const nsACString& aScriptURL,
+           ServiceWorkerUpdateViaCache aUpdateViaCache) const override;
 
   RefPtr<ServiceWorkerRegistrationPromise>
   GetRegistration(const ClientInfo& aClientInfo,
                   const nsACString& aURL) const override;
 
   RefPtr<ServiceWorkerRegistrationListPromise>
   GetRegistrations(const ClientInfo& aClientInfo) const override;
 
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -756,16 +756,17 @@ private:
 
   RefPtr<GenericPromise::Private> mPromise;
 };
 
 } // namespace
 
 // This function implements parts of the step 3 of the following algorithm:
 // https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-secure
+/* TODO
 static bool
 IsFromAuthenticatedOrigin(nsIDocument* aDoc)
 {
   MOZ_ASSERT(aDoc);
   nsCOMPtr<nsIDocument> doc(aDoc);
   nsCOMPtr<nsIContentSecurityManager> csm = do_GetService(NS_CONTENTSECURITYMANAGER_CONTRACTID);
   if (NS_WARN_IF(!csm)) {
     return false;
@@ -786,26 +787,28 @@ IsFromAuthenticatedOrigin(nsIDocument* a
     if (!trustworthyOrigin) {
       return false;
     }
 
     doc = doc->GetParentDocument();
   }
   return true;
 }
+*/
 
 // If we return an error code here, the ServiceWorkerContainer will
 // automatically reject the Promise.
-NS_IMETHODIMP
-ServiceWorkerManager::Register(mozIDOMWindow* aWindow,
-                               nsIURI* aScopeURI,
-                               nsIURI* aScriptURI,
-                               uint16_t aUpdateViaCache,
-                               nsISupports** aPromise)
+RefPtr<ServiceWorkerRegistrationPromise>
+ServiceWorkerManager::Register(const ClientInfo& aClientInfo,
+                               const nsACString& aScopeURL,
+                               const nsACString& aScriptURl,
+                               ServiceWorkerUpdateViaCache aUpdateViaCache)
 {
+  // TODO
+  #if 0
   MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
@@ -947,16 +950,18 @@ ServiceWorkerManager::Register(mozIDOMWi
   job->AppendResultCallback(cb);
   queue->ScheduleJob(job);
 
   MOZ_ASSERT(NS_IsMainThread());
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
+  #endif
+  return nullptr;
 }
 
 /*
  * Implements the async aspects of the getRegistrations algorithm.
  */
 class GetRegistrationsRunnable final : public Runnable
 {
   const ClientInfo mClientInfo;
diff --git a/dom/serviceworkers/ServiceWorkerManager.h b/dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h
+++ b/dom/serviceworkers/ServiceWorkerManager.h
@@ -189,16 +189,21 @@ public:
 
   void
   PropagateRemoveAll();
 
   void
   RemoveAll();
 
   RefPtr<ServiceWorkerRegistrationPromise>
+  Register(const ClientInfo& aClientInfo, const nsACString& aScopeURL,
+           const nsACString& aScriptURl,
+           ServiceWorkerUpdateViaCache aUpdateViaCache);
+
+  RefPtr<ServiceWorkerRegistrationPromise>
   GetRegistration(const ClientInfo& aClientInfo, const nsACString& aURL) const;
 
   RefPtr<ServiceWorkerRegistrationListPromise>
   GetRegistrations(const ClientInfo& aClientInfo) const;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetRegistration(nsIPrincipal* aPrincipal, const nsACString& aScope) const;
 
