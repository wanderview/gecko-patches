# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9546cfa26eac517fff834111dc76c0bdb5ccaf28

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -2201,16 +2201,21 @@ WorkerPrivateParent<Derived>::WorkerPriv
   if (aParent) {
     aParent->AssertIsOnWorkerThread();
 
     aParent->CopyJSSettings(mJSSettings);
 
     MOZ_ASSERT(IsDedicatedWorker());
     mNowBaseTimeStamp = aParent->NowBaseTimeStamp();
     mNowBaseTimeHighRes = aParent->NowBaseTime();
+
+    // XXX: We should probably Suspend() or Freeze() the new worker
+    //      if the parent worker is suspended or frozen.  We don't,
+    //      though, because our current suspend and freeze code don't
+    //      propagate to nested workers.  See bug 1304489.
   }
   else {
     AssertIsOnMainThread();
 
     RuntimeService::GetDefaultJSSettings(mJSSettings);
 
     if (IsDedicatedWorker() && mLoadInfo.mWindow &&
         mLoadInfo.mWindow->GetPerformance()) {
@@ -2218,16 +2223,26 @@ WorkerPrivateParent<Derived>::WorkerPriv
         GetNavigationStartTimeStamp();
       mNowBaseTimeHighRes =
       mLoadInfo.mWindow->GetPerformance()->GetDOMTiming()->
         GetNavigationStartHighRes();
     } else {
       mNowBaseTimeStamp = CreationTimeStamp();
       mNowBaseTimeHighRes = CreationTime();
     }
+
+    // Our parent can get suspended after it initiates the async creation
+    // of a new worker thread.  In this case suspend the new worker as well.
+    if (mLoadInfo.mWindow && mLoadInfo.mWindow->NewIsSuspended()) {
+      Suspend();
+    }
+
+    if (mLoadInfo.mWindow && mLoadInfo.mWindow->NewIsFrozen()) {
+      Freeze(mLoadInfo.mWindow);
+    }
   }
 }
 
 template <class Derived>
 WorkerPrivateParent<Derived>::~WorkerPrivateParent()
 {
   DropJSObjects(this);
 }
@@ -2579,22 +2594,17 @@ WorkerPrivateParent<Derived>::Freeze(nsP
 }
 
 template <class Derived>
 bool
 WorkerPrivateParent<Derived>::Thaw(nsPIDOMWindowInner* aWindow)
 {
   AssertIsOnParentThread();
 
-  if (IsDedicatedWorker() && !mParentFrozen) {
-    // If we are in here, it means that this worker has been created when the
-    // parent was actually suspended (maybe during a sync XHR), and in this case
-    // we don't need to thaw.
-    return true;
-  }
+  MOZ_ASSERT(mParentFrozen);
 
   // Shared workers are resumed if any of their owning documents are thawed.
   // It can happen that mSharedWorkers is empty but this thread has not been
   // unregistered yet.
   if ((IsSharedWorker() || IsServiceWorker()) && !mSharedWorkers.IsEmpty()) {
     AssertIsOnMainThread();
 
     bool anyRunning = false;
@@ -3090,17 +3100,17 @@ WorkerPrivateParent<Derived>::RegisterSh
       return false;
     }
   }
 
   mSharedWorkers.AppendElement(aSharedWorker);
 
   // If there were other SharedWorker objects attached to this worker then they
   // may all have been frozen and this worker would need to be thawed.
-  if (mSharedWorkers.Length() > 1 && !Thaw(nullptr)) {
+  if (mSharedWorkers.Length() > 1 && IsFrozen() && !Thaw(nullptr)) {
     return false;
   }
 
   return true;
 }
 
 template <class Derived>
 void
