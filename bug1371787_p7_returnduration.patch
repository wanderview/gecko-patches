# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  87bb26fe6ccc9bee67261fe3936fd7156ce83841
Bug 1371787 P7 Make CalculateDelay() return a TimeDuration. r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -227,28 +227,30 @@ TimeoutManager::IsInvalidFiringId(uint32
   // and a lot of sync XHRs within those timers could be slow here.
   return !mFiringIdStack.Contains(aFiringId);
 }
 
 // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
 // uses 5.
 #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
 
-int32_t
+TimeDuration
 TimeoutManager::CalculateDelay(Timeout* aTimeout) const {
   MOZ_DIAGNOSTIC_ASSERT(aTimeout);
-  int32_t result = aTimeout->mInterval;
+  TimeDuration result = TimeDuration::FromMilliseconds(aTimeout->mInterval);
 
   if (aTimeout->mIsInterval ||
       aTimeout->mNestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
-    result = std::max(result, gMinClampTimeoutValue);
+    result = TimeDuration::Max(
+      result, TimeDuration::FromMilliseconds(gMinClampTimeoutValue));
   }
 
   if (aTimeout->mIsTracking && mThrottleTrackingTimeouts) {
-    result = std::max(result, gMinTrackingTimeoutValue);
+    result = TimeDuration::Max(
+      result, TimeDuration::FromMilliseconds(gMinTrackingTimeoutValue));
   }
 
   return result;
 }
 
 #define TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY 0 // Consider all timeouts coming from tracking scripts as tracking
 // These strategies are useful for testing.
 #define ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY        1 // Consider all timeouts as normal
@@ -425,20 +427,18 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   uint32_t nestingLevel = sNestingLevel + 1;
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
 
   // Now clamp the actual interval we will use for the timer based on
-  uint32_t realInterval = CalculateDelay(timeout);
-
-  TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
-  timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
+  TimeDuration realInterval = CalculateDelay(timeout);
+  timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), realInterval);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     nsresult rv = mExecutor->MaybeSchedule(timeout->When(),
                                            MinSchedulingDelay());
     if (NS_FAILED(rv)) {
       return rv;
     }
@@ -470,25 +470,25 @@ TimeoutManager::SetTimeout(nsITimeoutHan
     mNormalTimeouts.Insert(timeout, sort);
   }
 
   timeout->mTimeoutId = GetTimeoutId(aReason);
   *aReturn = timeout->mTimeoutId;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Set%s(TimeoutManager=%p, timeout=%p, delay=%i, "
-           "minimum=%i, throttling=%s, background=%d, realInterval=%i) "
+           "minimum=%f, throttling=%s, background=%d, realInterval=%f) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
            this, timeout.get(), interval,
-           (CalculateDelay(timeout) - interval),
+           (CalculateDelay(timeout) - TimeDuration::FromMilliseconds(interval)).ToMilliseconds(),
            mThrottleTrackingTimeouts ? "yes"
                                      : (mThrottleTrackingTimeoutsTimer ?
                                           "pending" : "no"),
-           int(IsBackground()), realInterval,
+           int(IsBackground()), realInterval.ToMilliseconds(),
            timeout->mIsTracking ? "" : "non-",
            timeout->mTimeoutId));
 
   return NS_OK;
 }
 
 void
 TimeoutManager::ClearTimeout(int32_t aTimerId, Timeout::Reason aReason)
@@ -800,18 +800,17 @@ bool
 TimeoutManager::RescheduleTimeout(Timeout* aTimeout, const TimeStamp& now)
 {
   if (!aTimeout->mIsInterval) {
     return false;
   }
 
   // Compute time to next timeout for interval timer.
   // Make sure nextInterval is at least CalculateDelay().
-  TimeDuration nextInterval =
-    TimeDuration::FromMilliseconds(CalculateDelay(aTimeout));
+  TimeDuration nextInterval = CalculateDelay(aTimeout);
 
   TimeStamp firingTime = now + nextInterval;
 
   TimeStamp currentNow = TimeStamp::Now();
   TimeDuration delay = firingTime - currentNow;
 
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -50,17 +50,17 @@ public:
   // The timeout implementation functions.
   void RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline);
   // Return true if |aTimeout| needs to be reinserted into the timeout list.
   bool RescheduleTimeout(mozilla::dom::Timeout* aTimeout, const TimeStamp& now);
 
   void ClearAllTimeouts();
   uint32_t GetTimeoutId(mozilla::dom::Timeout::Reason aReason);
 
-  int32_t CalculateDelay(Timeout* aTimeout) const;
+  TimeDuration CalculateDelay(Timeout* aTimeout) const;
 
   // aTimeout is the timeout that we're about to start running.  This function
   // returns the current timeout.
   mozilla::dom::Timeout* BeginRunningTimeout(mozilla::dom::Timeout* aTimeout);
   // aTimeout is the last running timeout.
   void EndRunningTimeout(mozilla::dom::Timeout* aTimeout);
 
   void UnmarkGrayTimers();
