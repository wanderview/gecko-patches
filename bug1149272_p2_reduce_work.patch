# HG changeset patch
# Parent bfacc4c7e3385a004a69aa611ba322828ba727ea
# User Ben Kelly <ben@wanderview.com>
Bug 1149272 P2 Don't iterate known empty slots in nsSegmentArray.  Don't use nsMemory. r=froydnj


diff --git a/xpcom/io/nsSegmentedBuffer.cpp b/xpcom/io/nsSegmentedBuffer.cpp
--- a/xpcom/io/nsSegmentedBuffer.cpp
+++ b/xpcom/io/nsSegmentedBuffer.cpp
@@ -1,16 +1,15 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsSegmentedBuffer.h"
-#include "nsMemory.h"
 
 nsresult
 nsSegmentedBuffer::Init(uint32_t aSegmentSize, uint32_t aMaxSize)
 {
   if (mSegmentArrayCount != 0) {
     return NS_ERROR_FAILURE;  // initialized more than once
   }
   mSegmentSize = aSegmentSize;
@@ -27,27 +26,27 @@ char*
 nsSegmentedBuffer::AppendNewSegment()
 {
   if (GetSize() >= mMaxSize) {
     return nullptr;
   }
 
   if (!mSegmentArray) {
     uint32_t bytes = mSegmentArrayCount * sizeof(char*);
-    mSegmentArray = (char**)nsMemory::Alloc(bytes);
+    mSegmentArray = (char**)moz_malloc(bytes);
     if (!mSegmentArray) {
       return nullptr;
     }
     memset(mSegmentArray, 0, bytes);
   }
 
   if (IsFull()) {
     uint32_t newArraySize = mSegmentArrayCount * 2;
     uint32_t bytes = newArraySize * sizeof(char*);
-    char** newSegArray = (char**)nsMemory::Realloc(mSegmentArray, bytes);
+    char** newSegArray = (char**)moz_realloc(mSegmentArray, bytes);
     if (!newSegArray) {
       return nullptr;
     }
     mSegmentArray = newSegArray;
     // copy wrapped content to new extension
     if (mFirstSegmentIndex > mLastSegmentIndex) {
       // deal with wrap around case
       memcpy(&mSegmentArray[mSegmentArrayCount],
@@ -112,22 +111,22 @@ nsSegmentedBuffer::ReallocLastSegment(si
   }
   return false;
 }
 
 void
 nsSegmentedBuffer::Empty()
 {
   if (mSegmentArray) {
-    for (uint32_t i = 0; i < mSegmentArrayCount; i++) {
-      if (mSegmentArray[i]) {
-        moz_free(mSegmentArray[i]);
-      }
+    while (mFirstSegmentIndex != mLastSegmentIndex) {
+      MOZ_ASSERT(mSegmentArray[mFirstSegmentIndex]);
+      moz_free(mSegmentArray[mFirstSegmentIndex]);
+      mFirstSegmentIndex = ModSegArraySize(mFirstSegmentIndex + 1);
     }
-    nsMemory::Free(mSegmentArray);
+    moz_free(mSegmentArray);
     mSegmentArray = nullptr;
   }
   mSegmentArrayCount = NS_SEGMENTARRAY_INITIAL_COUNT;
   mFirstSegmentIndex = mLastSegmentIndex = 0;
 }
 
 #if 0
 void
diff --git a/xpcom/io/nsSegmentedBuffer.h b/xpcom/io/nsSegmentedBuffer.h
--- a/xpcom/io/nsSegmentedBuffer.h
+++ b/xpcom/io/nsSegmentedBuffer.h
@@ -2,18 +2,16 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsSegmentedBuffer_h__
 #define nsSegmentedBuffer_h__
 
-#include "nsIMemory.h"
-
 class nsSegmentedBuffer
 {
 public:
   nsSegmentedBuffer()
     : mSegmentSize(0)
     , mMaxSize(0)
     , mSegmentArray(nullptr)
     , mSegmentArrayCount(0)
