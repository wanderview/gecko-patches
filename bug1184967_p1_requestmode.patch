# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  363f6ee5fa9b706e3aa4059c419af81d980aaedc
Bug 1184967 P1 Set RequestMode based on LoadInfo securityMode and client request content policy. r=ehsan

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -833,17 +833,16 @@ FetchDriver::AsyncOnChannelRedirect(nsIC
 
   if (mRequest->GetRedirectMode() == RequestRedirect::Manual) {
     mRequest->SetResponseTainting(InternalRequest::RESPONSETAINT_OPAQUEREDIRECT);
     return NS_BINDING_FAILED;
   }
 
   MOZ_ASSERT(mRequest->GetRedirectMode() == RequestRedirect::Follow);
 
-  //
   // Requests that require preflight are not permitted to redirect.
   // Fetch spec section 4.2 "HTTP Fetch", step 4.9 just uses the manual
   // redirect flag to decide whether to execute step 4.10 or not. We do not
   // represent it in our implementation.
   // The only thing we do is to check if the request requires a preflight (part
   // of step 4.9), in which case we abort. This part cannot be done by
   // nsCORSListenerProxy since it does not have access to mRequest.
   // which case. Step 4.10.3 is handled by OnRedirectVerifyCallback(), and all
diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -198,49 +198,127 @@ InternalRequest::MapContentPolicyTypeToR
     break;
   default:
     MOZ_ASSERT(false, "Unhandled nsContentPolicyType value");
     break;
   }
   return context;
 }
 
+// static
 bool
-InternalRequest::IsNavigationRequest() const
+InternalRequest::IsNavigationContentPolicy(nsContentPolicyType aContentPolicyType)
 {
   // https://fetch.spec.whatwg.org/#navigation-request-context
   //
   // A navigation request context is one of "form", "frame", "hyperlink",
   // "iframe", "internal" (as long as context frame type is not "none"),
   // "location", "metarefresh", and "prerender".
   //
   // TODO: include equivalent check for "form" context
   // TODO: include equivalent check for "prerender" context
-  return mContentPolicyType == nsIContentPolicy::TYPE_DOCUMENT ||
-         mContentPolicyType == nsIContentPolicy::TYPE_SUBDOCUMENT ||
-         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_FRAME ||
-         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_IFRAME ||
-         mContentPolicyType == nsIContentPolicy::TYPE_REFRESH;
+  return aContentPolicyType == nsIContentPolicy::TYPE_DOCUMENT ||
+         aContentPolicyType == nsIContentPolicy::TYPE_SUBDOCUMENT ||
+         aContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_FRAME ||
+         aContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_IFRAME ||
+         aContentPolicyType == nsIContentPolicy::TYPE_REFRESH;
 }
 
+// static
 bool
-InternalRequest::IsWorkerRequest() const
+InternalRequest::IsWorkerContentPolicy(nsContentPolicyType aContentPolicyType)
 {
   // https://fetch.spec.whatwg.org/#worker-request-context
   //
   // A worker request context is one of "serviceworker", "sharedworker", and
   // "worker".
   //
   // Note, service workers are not included here because currently there is
   // no way to generate a Request with a "serviceworker" RequestContext.
   // ServiceWorker scripts cannot be intercepted.
-  return mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_WORKER ||
-         mContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_SHARED_WORKER;
+  return aContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_WORKER ||
+         aContentPolicyType == nsIContentPolicy::TYPE_INTERNAL_SHARED_WORKER;
+}
+
+bool
+InternalRequest::IsNavigationRequest() const
+{
+  return IsNavigationContentPolicy(mContentPolicyType);
+}
+
+bool
+InternalRequest::IsWorkerRequest() const
+{
+  return IsWorkerContentPolicy(mContentPolicyType);
 }
 
 bool
 InternalRequest::IsClientRequest() const
 {
   return IsNavigationRequest() || IsWorkerRequest();
 }
 
+// static
+RequestMode
+InternalRequest::MapChannelToRequestMode(nsIChannel* aChannel)
+{
+  MOZ_ASSERT(aChannel);
+
+  nsCOMPtr<nsILoadInfo> loadInfo;
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(aChannel->GetLoadInfo(getter_AddRefs(loadInfo))));
+
+  // RequestMode deviates from our internal security mode for navigations.
+  // While navigations normally allow cross origin we must set a same-origin
+  // RequestMode to get the correct service worker interception restrictions
+  // in place.
+  // TODO: remove the worker override once securityMode is fully implemented (bug 1189945)
+  nsContentPolicyType contentPolicy = loadInfo->InternalContentPolicyType();
+  if (IsNavigationContentPolicy(contentPolicy) ||
+      IsWorkerContentPolicy(contentPolicy)) {
+    return RequestMode::Same_origin;
+  }
+
+  uint32_t securityMode;
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(loadInfo->GetSecurityMode(&securityMode)));
+
+  switch(securityMode) {
+    case nsILoadInfo::SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS:
+    case nsILoadInfo::SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED:
+      return RequestMode::Same_origin;
+    case nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS:
+    case nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL:
+      return RequestMode::No_cors;
+    case nsILoadInfo::SEC_REQUIRE_CORS_DATA_INHERITS:
+      return RequestMode::Cors;
+    default:
+      // TODO: assert never reached after CorsMode flag removed (bug 1189945)
+      MOZ_ASSERT(securityMode == nsILoadInfo::SEC_NORMAL);
+      break;
+  }
+
+  // TODO: remove following code once securityMode is fully implemented (bug 1189945)
+
+  nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(aChannel);
+  if (jarChannel) {
+    return RequestMode::No_cors;
+  }
+
+  nsCOMPtr<nsIHttpChannelInternal> httpChannel = do_QueryInterface(aChannel);
+
+  uint32_t corsMode;
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(httpChannel->GetCorsMode(&corsMode)));
+  switch (corsMode) {
+    case nsIHttpChannelInternal::CORS_MODE_SAME_ORIGIN:
+      return RequestMode::Same_origin;
+    case nsIHttpChannelInternal::CORS_MODE_NO_CORS:
+      return RequestMode::No_cors;
+    case nsIHttpChannelInternal::CORS_MODE_CORS:
+    case nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT:
+      return RequestMode::Cors;
+    default:
+      MOZ_CRASH("Unexpected CORS mode");
+  }
+
+  MOZ_ASSERT_UNREACHABLE("unexpected CORS mode");
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -372,26 +372,34 @@ public:
   IsNavigationRequest() const;
 
   bool
   IsWorkerRequest() const;
 
   bool
   IsClientRequest() const;
 
+  static RequestMode
+  MapChannelToRequestMode(nsIChannel* aChannel);
 
 private:
   // Does not copy mBodyStream.  Use fallible Clone() for complete copy.
   explicit InternalRequest(const InternalRequest& aOther);
 
   ~InternalRequest();
 
   static RequestContext
   MapContentPolicyTypeToRequestContext(nsContentPolicyType aContentPolicyType);
 
+  static bool
+  IsNavigationContentPolicy(nsContentPolicyType aContentPolicyType);
+
+  static bool
+  IsWorkerContentPolicy(nsContentPolicyType aContentPolicyType);
+
   nsCString mMethod;
   nsCString mURL;
   nsRefPtr<InternalHeaders> mHeaders;
   nsCOMPtr<nsIInputStream> mBodyStream;
 
   nsContentPolicyType mContentPolicyType;
 
   // Empty string: no-referrer
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -267,39 +267,31 @@ RespondWithHandler::ResolvedCallback(JSC
     autoCancel.SetCancelStatus(NS_ERROR_OPAQUE_INTERCEPTION_DISABLED);
     return;
   }
 
   // Section 4.2, step 2.2:
   //  If one of the following conditions is true, return a network error:
   //    * response's type is "error".
   //    * request's mode is not "no-cors" and response's type is "opaque".
-  //    * request is a client request and response's type is neither "basic"
-  //      nor "default".
   //    * request is not a navigation request and response's type is
   //      "opaqueredirect".
 
   if (response->Type() == ResponseType::Error) {
     autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_ERROR_RESPONSE);
     return;
   }
 
+  MOZ_ASSERT_IF(mIsClientRequest, mRequestMode == RequestMode::Same_origin);
+
   if (response->Type() == ResponseType::Opaque && mRequestMode != RequestMode::No_cors) {
     autoCancel.SetCancelStatus(NS_ERROR_BAD_OPAQUE_INTERCEPTION_REQUEST_MODE);
     return;
   }
 
-  // TODO: remove this case as its no longer in the spec (bug 1184967)
-  if (mIsClientRequest && response->Type() != ResponseType::Basic &&
-      response->Type() != ResponseType::Default &&
-      response->Type() != ResponseType::Opaqueredirect) {
-    autoCancel.SetCancelStatus(NS_ERROR_CLIENT_REQUEST_OPAQUE_INTERCEPTION);
-    return;
-  }
-
   if (!mIsNavigationRequest && response->Type() == ResponseType::Opaqueredirect) {
     autoCancel.SetCancelStatus(NS_ERROR_BAD_OPAQUE_REDIRECT_INTERCEPTION);
     return;
   }
 
   if (NS_WARN_IF(response->BodyUsed())) {
     autoCancel.SetCancelStatus(NS_ERROR_INTERCEPTED_USED_RESPONSE);
     return;
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -3548,32 +3548,17 @@ public:
     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
     if (httpChannel) {
       rv = httpChannel->GetRequestMethod(mMethod);
       NS_ENSURE_SUCCESS(rv, rv);
 
       nsCOMPtr<nsIHttpChannelInternal> internalChannel = do_QueryInterface(httpChannel);
       NS_ENSURE_TRUE(internalChannel, NS_ERROR_NOT_AVAILABLE);
 
-      uint32_t mode;
-      internalChannel->GetCorsMode(&mode);
-      switch (mode) {
-        case nsIHttpChannelInternal::CORS_MODE_SAME_ORIGIN:
-          mRequestMode = RequestMode::Same_origin;
-          break;
-        case nsIHttpChannelInternal::CORS_MODE_NO_CORS:
-          mRequestMode = RequestMode::No_cors;
-          break;
-        case nsIHttpChannelInternal::CORS_MODE_CORS:
-        case nsIHttpChannelInternal::CORS_MODE_CORS_WITH_FORCED_PREFLIGHT:
-          mRequestMode = RequestMode::Cors;
-          break;
-        default:
-          MOZ_CRASH("Unexpected CORS mode");
-      }
+      mRequestMode = InternalRequest::MapChannelToRequestMode(channel);
 
       if (loadFlags & nsIRequest::LOAD_ANONYMOUS) {
         mRequestCredentials = RequestCredentials::Omit;
       } else {
         bool includeCrossOrigin;
         internalChannel->GetCorsIncludeCredentials(&includeCrossOrigin);
         if (includeCrossOrigin) {
           mRequestCredentials = RequestCredentials::Include;
@@ -3591,16 +3576,18 @@ public:
       }
     } else {
       nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(channel);
       // If it is not an HTTP channel it must be a JAR one.
       NS_ENSURE_TRUE(jarChannel, NS_ERROR_NOT_AVAILABLE);
 
       mMethod = "GET";
 
+      mRequestMode = InternalRequest::MapChannelToRequestMode(channel);
+
       if (loadFlags & nsIRequest::LOAD_ANONYMOUS) {
         mRequestCredentials = RequestCredentials::Omit;
       }
     }
 
     return NS_OK;
   }
 
