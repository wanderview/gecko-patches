# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9cb85c488d28f255111884bb7e9e8ed839cc6f3e
Bug 1300659 P2 Make sure window TaskQueues are drained before allowing browser to shutdown. r=bz

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3617,47 +3617,78 @@ nsGlobalWindow::MaybeCreateMainThreadTas
     target = mainThread;
   }
 
   mMainThreadTaskQueue = new TaskQueue(target.forget());
 }
 
 namespace {
 
-class TaskQueueShutdownHandler final
+class TaskQueueShutdownHandler final : public nsIObserver
 {
   RefPtr<TaskQueue> mTaskQueue;
 
   ~TaskQueueShutdownHandler()
   {
     MOZ_ASSERT(!mTaskQueue);
   }
 
 public:
   explicit TaskQueueShutdownHandler(already_AddRefed<TaskQueue> aTaskQueue)
     : mTaskQueue(aTaskQueue)
   {
     MOZ_ASSERT(mTaskQueue);
+
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (os) {
+      os->AddObserver(this, "xpcom-shutdown-thread", false /* weak ref */);
+    }
   }
 
   void
   Done(bool aResult)
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mTaskQueue);
+
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (os) {
+      os->RemoveObserver(this, "xpcom-shutdown-thread");
+    }
+
+    // Free the TaskQueue after its shutdown promise has returned from its
+    // callback processing.
     NS_ProxyRelease(NS_GetCurrentThread(), mTaskQueue.forget(),
                     true /* always proxy */);
   }
 
-  // TODO: Do we need a browser shutdown observer to spin the event loop
-  //       if this isn't complete when we teardown the browser?
-
-  NS_INLINE_DECL_REFCOUNTING(TaskQueueShutdownHandler)
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOBSERVER
 };
 
+NS_IMPL_ISUPPORTS(TaskQueueShutdownHandler, nsIObserver);
+
+NS_IMETHODIMP
+TaskQueueShutdownHandler::Observe(nsISupports* aSubject, const char *aTopic,
+                                  const char16_t* aData)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!strcmp(aTopic, "xpcom-shutdown-threads"));
+
+  // Spin the event loop to delay shutdown until the TaskQueue is empty.
+  // The promise will call Done() which will then clear our mTaskQueue ref.
+  while (mTaskQueue) {
+    if (!NS_ProcessNextEvent()) {
+      break;
+    }
+  }
+
+  return NS_OK;
+}
+
 } // anonymous namespace
 
 void
 nsGlobalWindow::MaybeShutdownMainThreadTaskQueue()
 {
   if (!mMainThreadTaskQueue) {
     return;
   }
