# HG changeset patch
# Parent 14c664bd31605501bd7722aa7c65b66957badb9e
# User Ben Kelly <ben@wanderview.com>
Return file stream contained in an IPC stream controlled wrapper.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -6,16 +6,17 @@
 
 #include "mozilla/dom/cache/Cache.h"
 
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/unused.h"
 #include "nsIGlobalObject.h"
 #include "nsNetUtil.h"
 
 namespace mozilla {
@@ -283,17 +284,18 @@ Cache::ActorDestroy(mozilla::ipc::IProto
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 Cache::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                         const PCacheResponseOrVoid& aResponse)
+                         const PCacheResponseOrVoid& aResponse,
+                         PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
@@ -301,125 +303,119 @@ Cache::RecvMatchResponse(RequestId aRequ
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
   nsRefPtr<Response> response = new Response(mOwner);
-  if (!response) {
-    promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-    return;
-  }
-  TypeUtils::ToResponse(*response, aResponse);
+  nsCOMPtr<nsIInputStream> stream =
+    ReadStream::Create(aStreamControl, aResponse.get_PCacheResponse().body());
+  TypeUtils::ToResponse(*response, aResponse, stream);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                            const nsTArray<PCacheResponse>& aResponses)
+                            const nsTArray<PCacheResponse>& aResponses,
+                            PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     nsRefPtr<Response> response = new Response(mOwner);
-    if (!response) {
-      promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
-    TypeUtils::ToResponse(*response, aResponses[i]);
+    nsCOMPtr<nsIInputStream> stream =
+      ReadStream::Create(aStreamControl, aResponses[i].body());
+    TypeUtils::ToResponse(*response, aResponses[i], stream);
     responses.AppendElement(response);
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvAddResponse(RequestId aRequestId, nsresult aRv,
-                       const PCacheResponse& aResponse)
+                       const PCacheResponseOrVoid& aResponse,
+                       PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsRefPtr<Response> response = new Response(mOwner);
-  if (!response) {
-    promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-    return;
-  }
-  TypeUtils::ToResponse(*response, aResponse);
+  nsCOMPtr<nsIInputStream> stream =
+    ReadStream::Create(aStreamControl, aResponse.get_PCacheResponse().body());
+  TypeUtils::ToResponse(*response, aResponse, stream);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
-                          const nsTArray<PCacheResponse>& aResponses)
+                          const nsTArray<PCacheResponse>& aResponses,
+                          PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     nsRefPtr<Response> response = new Response(mOwner);
-    if (!response) {
-      promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
-    TypeUtils::ToResponse(*response, aResponses[i]);
+    nsCOMPtr<nsIInputStream> stream =
+      ReadStream::Create(aStreamControl, aResponses[i].body());
+    TypeUtils::ToResponse(*response, aResponses[i], stream);
     responses.AppendElement(response);
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvPutResponse(RequestId aRequestId, nsresult aRv,
-                       const PCacheResponseOrVoid& aResponse)
+                       const PCacheResponseOrVoid& aResponse,
+                       PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeResolve(nullptr);
     return;
   }
   nsRefPtr<Response> response = new Response(mOwner);
-  if (!response) {
-    promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-    return;
-  }
-  TypeUtils::ToResponse(*response, aResponse);
+  nsCOMPtr<nsIInputStream> stream =
+    ReadStream::Create(aStreamControl, aResponse.get_PCacheResponse().body());
+  TypeUtils::ToResponse(*response, aResponse, stream);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
@@ -431,32 +427,35 @@ Cache::RecvDeleteResponse(RequestId aReq
     return;
   }
 
   promise->MaybeResolve(aSuccess);
 }
 
 void
 Cache::RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                        const nsTArray<PCacheRequest>& aRequests)
+                        const nsTArray<PCacheRequest>& aRequests,
+                        PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Request>> requests;
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
     nsRefPtr<InternalRequest> internalRequest = new InternalRequest(mGlobal);
-    TypeUtils::ToInternalRequest(*internalRequest, aRequests[i]);
+    nsCOMPtr<nsIInputStream> stream =
+      ReadStream::Create(aStreamControl, aRequests[i].body());
+    TypeUtils::ToInternalRequest(*internalRequest, aRequests[i], stream);
     // TODO: Should mOwner and mGlobal be just one field? Right now mOwner can
     //       be null (when on a worker), but mGlobal is always provided.
     nsCOMPtr<nsIGlobalObject> owner = do_QueryInterface(mOwner);
     nsRefPtr<Request> request = new Request(owner, internalRequest);
     requests.AppendElement(request);
   }
   promise->MaybeResolve(requests);
 }
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -69,35 +69,41 @@ public:
 
   virtual nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // CacheChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& aResponses,
+                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv,
-                  const PCacheResponse& aResponse) MOZ_OVERRIDE;
+                  const PCacheResponseOrVoid& aResponse,
+                  PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
-                     const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+                     const nsTArray<PCacheResponse>& aResponses,
+                     PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv,
-                  const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+                  const PCacheResponseOrVoid& aResponse,
+                  PCacheStreamControlChild* aStreamControl);
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess) MOZ_OVERRIDE;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
+                   const nsTArray<PCacheRequest>& aRequests,
+                   PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
 
 private:
   virtual ~Cache();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
 private:
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -43,72 +43,78 @@ void
 CacheChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
 bool
 CacheChild::RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                              const PCacheResponseOrVoid& response)
+                              const PCacheResponseOrVoid& aResponse,
+                              PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchResponse(requestId, aRv, response);
+  mListener->RecvMatchResponse(requestId, aRv, aResponse, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                                 const nsTArray<PCacheResponse>& responses)
+                                 const nsTArray<PCacheResponse>& responses,
+                                 PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchAllResponse(requestId, aRv, responses);
+  mListener->RecvMatchAllResponse(requestId, aRv, responses, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvAddResponse(const RequestId& requestId, const nsresult& aRv,
-                            const PCacheResponse& response)
+                            const PCacheResponseOrVoid& response,
+                            PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvAddResponse(requestId, aRv, response);
+  mListener->RecvAddResponse(requestId, aRv, response, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvAddAllResponse(const RequestId& requestId, const nsresult& aRv,
-                               const nsTArray<PCacheResponse>& responses)
+                               const nsTArray<PCacheResponse>& responses,
+                               PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvAddAllResponse(requestId, aRv, responses);
+  mListener->RecvAddAllResponse(requestId, aRv, responses, aStreamControl);
   return true;
 }
 
 bool
-CacheChild::RecvPutResponse(const RequestId& requestId, const nsresult& aRv,
-                            const PCacheResponseOrVoid& response)
+CacheChild::RecvPutResponse(const RequestId& aRequestId, const nsresult& aRv,
+                            const PCacheResponseOrVoid& aResponse,
+                            PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvPutResponse(requestId, aRv, response);
+  mListener->RecvPutResponse(aRequestId, aRv, aResponse, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                                const bool& result)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvDeleteResponse(requestId, aRv, result);
   return true;
 }
 
 bool
 CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
-                             const nsTArray<PCacheRequest>& requests)
+                             const nsTArray<PCacheRequest>& requests,
+                             PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvKeysResponse(requestId, aRv, requests);
+  mListener->RecvKeysResponse(requestId, aRv, requests, aStreamControl);
   return true;
 }
 
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -26,34 +26,40 @@ public:
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   void SetListener(CacheChildListener& aListener);
   void ClearListener();
 
   // PCacheChild methods
   virtual bool
   RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                    const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                       const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& responses,
+                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvAddResponse(const RequestId& requestId, const nsresult& aRv,
-                  const PCacheResponse& response) MOZ_OVERRIDE;
+                  const PCacheResponseOrVoid& response,
+                  PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvAddAllResponse(const RequestId& requestId, const nsresult& aRv,
-                     const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
+                     const nsTArray<PCacheResponse>& responses,
+                     PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
-  RecvPutResponse(const RequestId& requestId, const nsresult& aRv,
-                  const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
+  RecvPutResponse(const RequestId& aRequestId, const nsresult& aRv,
+                  const PCacheResponseOrVoid& aResponse,
+                  PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
-                   const nsTArray<PCacheRequest>& requests) MOZ_OVERRIDE;
+                   const nsTArray<PCacheRequest>& requests,
+                   PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheChild_h
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -17,43 +17,50 @@ namespace ipc {
 }
 
 namespace dom {
 namespace cache {
 
 class PCacheRequest;
 class PCacheResponse;
 class PCacheResponseOrVoid;
+class PCacheStreamControlChild;
 
 class CacheChildListener
 {
 public:
   virtual ~CacheChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
 
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse)=0;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses)=0;
+                       const nsTArray<PCacheResponse>& aResponses,
+                       PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv,
-                  const PCacheResponse& aResponse)=0;
+                  const PCacheResponseOrVoid& aResponse,
+                  PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
-                     const nsTArray<PCacheResponse>& aResponses)=0;
+                     const nsTArray<PCacheResponse>& aResponses,
+                     PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv,
-                  const PCacheResponseOrVoid& aResponse)=0;
+                  const PCacheResponseOrVoid& aResponse,
+                  PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess)=0;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<PCacheRequest>& aRequests)=0;
+                   const nsTArray<PCacheRequest>& aRequests,
+                   PCacheStreamControlChild* aStreamControl)=0;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_CacheChildListener_h
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -2,29 +2,34 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsCOMPtr.h"
 
 // TODO: remove testing only headers
 #include "../../dom/filehandle/MemoryStreams.h"
 #include "nsStringStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
+using mozilla::ipc::PFileDescriptorSetParent;
 
 CacheParent::CacheParent(const nsACString& aOrigin,
                          const nsACString& aBaseDomain,
                          CacheId aCacheId)
   : mCacheId(aCacheId)
   , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
   MOZ_ASSERT(mManager);
@@ -45,63 +50,71 @@ CacheParent::ActorDestroy(ActorDestroyRe
   mManager = nullptr;
 }
 
 bool
 CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
-  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest, aParams);
+  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest,
+                       aParams);
   return true;
 }
 
 bool
 CacheParent::RecvMatchAll(const RequestId& aRequestId,
                           const PCacheRequestOrVoid& aRequest,
                           const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
   mManager->CacheMatchAll(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 bool
 CacheParent::RecvAdd(const RequestId& aRequestId, const PCacheRequest& aRequest)
 {
-  return false;
+  PCacheResponseOrVoid responseOrVoid;
+  responseOrVoid = void_t();
+  unused << SendAddResponse(aRequestId, NS_ERROR_NOT_IMPLEMENTED,
+                            responseOrVoid, nullptr);
+  return true;
 }
 
 bool
 CacheParent::RecvAddAll(const RequestId& aRequestId,
                         const nsTArray<PCacheRequest>& aRequests)
 {
-  return false;
+  nsTArray<PCacheResponse> responses;
+  unused << SendAddAllResponse(aRequestId, NS_ERROR_NOT_IMPLEMENTED, responses,
+                               nullptr);
+  return true;
 }
 
 bool
 CacheParent::RecvPut(const RequestId& aRequestId, const PCacheRequest& aRequest,
                      const PCacheResponse& aResponse)
 {
   MOZ_ASSERT(mManager);
 
   // TODO: remove stream test code
   nsCOMPtr<nsIInputStream> requestStream;
   nsresult rv = NS_NewCStringInputStream(getter_AddRefs(requestStream),
                 NS_LITERAL_CSTRING("request body stream beep beep boop!"));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    OnCachePut(aRequestId, rv, nullptr);
+    OnCachePut(aRequestId, rv, nullptr, nullptr);
     return true;
   }
 
   nsCOMPtr<nsIInputStream> responseStream;
   rv = NS_NewCStringInputStream(getter_AddRefs(responseStream),
                 NS_LITERAL_CSTRING("response body stream hooray!"));
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    OnCachePut(aRequestId, rv, nullptr);
+    OnCachePut(aRequestId, rv, nullptr, nullptr);
     return true;
   }
 
   mManager->CachePut(this, aRequestId, mCacheId,
                      aRequest, requestStream, aResponse, responseStream);
   return true;
 }
 
@@ -122,115 +135,177 @@ CacheParent::RecvKeys(const RequestId& a
 {
   MOZ_ASSERT(mManager);
   mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                          const SavedResponse* aSavedResponse)
+                          const SavedResponse* aSavedResponse,
+                          Manager::StreamList* aStreamList)
+{
+  PCacheResponseOrVoid responseOrVoid;
+
+  // no match
+  if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
+    responseOrVoid = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    return;
+  }
+
+  // match without body data to stream
+  if (!aSavedResponse->mHasBodyId) {
+    responseOrVoid = aSavedResponse->mValue;
+    responseOrVoid.get_PCacheResponse().body() = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    return;
+  }
+
+  PCacheReadStream readStream;
+  Manager::StreamControl* streamControl =
+    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                        &readStream);
+
+  responseOrVoid = aSavedResponse->mValue;
+  responseOrVoid.get_PCacheResponse().body() = readStream;
+
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, streamControl);
+}
+
+void
+CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<SavedResponse>& aSavedResponses,
+                             Manager::StreamList* aStreamList)
+{
+  Manager::StreamControl* streamControl = nullptr;
+  nsTArray<PCacheResponse> responses;
+
+  for (uint32_t i = 0; i < aSavedResponses.Length(); ++i) {
+    PCacheResponse* res = responses.AppendElement();
+    *res = aSavedResponses[i].mValue;
+
+    if (!aSavedResponses[i].mHasBodyId) {
+      res->body() = void_t();
+      continue;
+    }
+
+    PCacheReadStream readStream;
+    streamControl =
+      SerializeReadStream(streamControl, aSavedResponses[i].mBodyId,
+                          aStreamList, &readStream);
+    res->body() = readStream;
+  }
+
+  unused << SendMatchAllResponse(aRequestId, aRv, responses, streamControl);
+}
+
+void
+CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv,
+                        const SavedResponse* aSavedResponse,
+                        Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
     responseOrVoid = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    unused << SendPutResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    responseOrVoid.get_PCacheResponse().body() = void_t();
+    unused << SendPutResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
-  // TODO: remove stream test code
-  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+  PCacheReadStream readStream;
+  Manager::StreamControl* streamControl =
+    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                        &readStream);
 
-  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
   responseOrVoid = aSavedResponse->mValue;
-  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
-}
+  responseOrVoid.get_PCacheResponse().body() = readStream;
 
-void
-CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<SavedResponse>& aSavedResponses)
-{
-  nsTArray<PCacheResponse> responses;
-  nsTArray<nsCOMPtr<nsIOutputStream>> responseStreams;
-  for (uint32_t i = 0; i < aSavedResponses.Length(); ++i) {
-    responses.AppendElement(aSavedResponses[i].mValue);
-
-    if (!aSavedResponses[i].mHasBodyId) {
-      responseStreams.AppendElement();
-    } else {
-      // TODO: remove stream test code
-      responseStreams.AppendElement(MemoryOutputStream::Create(4096));
-      mManager->CacheReadBody(mCacheId, aSavedResponses[i].mBodyId,
-                              responseStreams[i]);
-    }
-  }
-
-  unused << SendMatchAllResponse(aRequestId, aRv, responses);
-}
-
-void
-CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv,
-                        const SavedResponse* aSavedResponse)
-{
-  PCacheResponseOrVoid responseOrVoid;
-
-  // no match
-  if (NS_FAILED(aRv) || !aSavedResponse) {
-    responseOrVoid = void_t();
-    unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
-    return;
-  }
-
-  // match without body data to stream
-  if (!aSavedResponse->mHasBodyId) {
-    responseOrVoid = aSavedResponse->mValue;
-    unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
-    return;
-  }
-
-  // TODO: remove stream test code
-  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
-
-  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
-  responseOrVoid = aSavedResponse->mValue;
-  unused << SendPutResponse(aRequestId, aRv, responseOrVoid);
+  unused << SendPutResponse(aRequestId, aRv, responseOrVoid, streamControl);
 }
 
 void
 CacheParent::OnCacheDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
 }
 
 void
 CacheParent::OnCacheKeys(RequestId aRequestId, nsresult aRv,
-                         const nsTArray<SavedRequest>& aSavedRequests)
+                         const nsTArray<SavedRequest>& aSavedRequests,
+                         Manager::StreamList* aStreamList)
 {
+  Manager::StreamControl* streamControl = nullptr;
   nsTArray<PCacheRequest> requests;
-  nsTArray<nsCOMPtr<nsIOutputStream>> requestStreams;
+
   for (uint32_t i = 0; i < aSavedRequests.Length(); ++i) {
-    requests.AppendElement(aSavedRequests[i].mValue);
+    PCacheRequest* req = requests.AppendElement();
+    *req = aSavedRequests[i].mValue;
 
     if (!aSavedRequests[i].mHasBodyId) {
-      requestStreams.AppendElement();
-    } else {
-      // TODO: remove stream test code
-      requestStreams.AppendElement(MemoryOutputStream::Create(4096));
-      mManager->CacheReadBody(mCacheId, aSavedRequests[i].mBodyId,
-                              requestStreams[i]);
+      req->body() = void_t();
+      continue;
+    }
+
+    PCacheReadStream readStream;
+    streamControl =
+      SerializeReadStream(streamControl, aSavedRequests[i].mBodyId,
+                          aStreamList, &readStream);
+    req->body() = readStream;
+  }
+
+  unused << SendKeysResponse(aRequestId, aRv, requests, streamControl);
+}
+
+Manager::StreamControl*
+CacheParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
+                                 const nsID& aId,
+                                 Manager::StreamList* aStreamList,
+                                 PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aStreamList);
+  MOZ_ASSERT(aReadStreamOut);
+
+  aReadStreamOut->id() = aId;
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
+  MOZ_ASSERT(stream);
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(stream, aReadStreamOut->params(), fds);
+
+  PFileDescriptorSetParent* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
     }
   }
 
-  unused << SendKeysResponse(aRequestId, aRv, requests);
+  if (fdSet) {
+    aReadStreamOut->fds() = fdSet;
+  } else {
+    aReadStreamOut->fds() = void_t();
+  }
+
+  if (!aStreamControl) {
+    aStreamControl = new CacheStreamControlParent();
+    PCacheStreamControlParent* actor =
+      Manager()->SendPCacheStreamControlConstructor(aStreamControl);
+    MOZ_ASSERT(aStreamControl == actor);
+  }
+
+  aStreamList->SetStreamControl(aStreamControl);
+
+  return aStreamControl;
 }
 
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -51,27 +51,36 @@ public:
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                            const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
+                            const SavedResponse* aSavedResponse,
+                            Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
+                               const nsTArray<SavedResponse>& aSavedResponses,
+                               Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
-                          const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
+                          const SavedResponse* aSavedResponse,
+                          Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
   virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
-                     const nsTArray<SavedRequest>& aSavedRequests) MOZ_OVERRIDE;
+                           const nsTArray<SavedRequest>& aSavedRequests,
+                           Manager::StreamList* aStreamList) MOZ_OVERRIDE;
 
 private:
+  Manager::StreamControl*
+  SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
+                      Manager::StreamList* aStreamList,
+                      PCacheReadStream* aReadStreamOut);
+
   const CacheId mCacheId;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -6,18 +6,19 @@
 
 #include "mozilla/dom/cache/CacheStorage.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/CacheStorageBinding.h"
 #include "mozilla/dom/cache/Cache.h"
+#include "mozilla/dom/cache/CacheStorageChild.h"
 #include "mozilla/dom/cache/PCacheChild.h"
-#include "mozilla/dom/cache/CacheStorageChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "nsIGlobalObject.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
@@ -256,17 +257,18 @@ CacheStorage::ActorDestroy(IProtocol& aA
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 CacheStorage::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                                const PCacheResponseOrVoid& aResponse)
+                                const PCacheResponseOrVoid& aResponse,
+                                PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
@@ -274,17 +276,19 @@ CacheStorage::RecvMatchResponse(RequestI
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
   nsRefPtr<Response> response = new Response(mOwner);
-  TypeUtils::ToResponse(*response, aResponse);
+  nsCOMPtr<nsIInputStream> stream =
+    ReadStream::Create(aStreamControl, aResponse.get_PCacheResponse().body());
+  TypeUtils::ToResponse(*response, aResponse, stream);
   promise->MaybeResolve(response);
 }
 
 void
 CacheStorage::RecvGetResponse(RequestId aRequestId, nsresult aRv,
                               PCacheChild* aActor)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -64,17 +64,18 @@ public:
 
   // nsIIPCbackgroundChildCreateCallback methods
   virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
   virtual void ActorFailed() MOZ_OVERRIDE;
 
   // CacheStorageChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                           const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+                           const PCacheResponseOrVoid& aResponse,
+                           PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void RecvGetResponse(RequestId aRequestId, nsresult aRv,
                                PCacheChild* aActor) MOZ_OVERRIDE;
   virtual void RecvHasResponse(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) MOZ_OVERRIDE;
   virtual void RecvCreateResponse(RequestId aRequestId, nsresult aRv,
                                   PCacheChild* aActor) MOZ_OVERRIDE;
   virtual void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                   bool aSuccess) MOZ_OVERRIDE;
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -30,20 +30,21 @@ CacheStorageChild::ActorDestroy(ActorDes
   if (mListener) {
     mListener->ActorDestroy(*this);
   }
 }
 
 bool
 CacheStorageChild::RecvMatchResponse(const RequestId& aRequestId,
                                      const nsresult& aRv,
-                                     const PCacheResponseOrVoid& aResponseOrVoid)
+                                     const PCacheResponseOrVoid& aResponseOrVoid,
+                                     PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid);
+  mListener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid, aStreamControl);
   return true;
 }
 
 bool
 CacheStorageChild::RecvGetResponse(const RequestId& aRequestId,
                                    const nsresult& aRv,
                                    PCacheChild* aActor)
 {
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -20,17 +20,18 @@ class PCacheChild;
 class CacheStorageChild MOZ_FINAL : public PCacheStorageChild
 {
 public:
   CacheStorageChild(CacheStorageChildListener& aListener);
   virtual ~CacheStorageChild();
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvMatchResponse(const RequestId& requestId,
                              const nsresult& aRv,
-                             const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
+                             const PCacheResponseOrVoid& response,
+                             PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool RecvGetResponse(const cache::RequestId& aRequestId,
                                const nsresult& aRv,
                                PCacheChild* aActor) MOZ_OVERRIDE;
   virtual bool RecvHasResponse(const cache::RequestId& aRequestId,
                                const nsresult& aRv,
                                const bool& aSuccess) MOZ_OVERRIDE;
   virtual bool RecvCreateResponse(const cache::RequestId& aRequestId,
                                   const nsresult& aRv,
diff --git a/dom/cache/CacheStorageChildListener.h b/dom/cache/CacheStorageChildListener.h
--- a/dom/cache/CacheStorageChildListener.h
+++ b/dom/cache/CacheStorageChildListener.h
@@ -19,24 +19,26 @@ namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
 namespace cache {
 
 class PCacheChild;
 class PCacheResponseOrVoid;
+class PCacheStreamControlChild;
 
 class CacheStorageChildListener
 {
 public:
   virtual ~CacheStorageChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
   virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                                 const PCacheResponseOrVoid& aResponse)=0;
+                                 const PCacheResponseOrVoid& aResponse,
+                                 PCacheStreamControlChild* aStreamControl)=0;
   virtual void RecvGetResponse(cache::RequestId aRequestId,
                                nsresult aRv, PCacheChild* aActor)=0;
   virtual void RecvHasResponse(cache::RequestId aRequestId, nsresult aRv,
                                bool aSuccess)=0;
   virtual void RecvCreateResponse(cache::RequestId aRequestId, nsresult aRv,
                                   PCacheChild* aActor)=0;
   virtual void RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
                                   bool aSuccess)=0;
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -2,29 +2,36 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorageParent.h"
 
 #include "mozilla/dom/cache/CacheParent.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
 // TODO: remove testing only headers
 #include "../../dom/filehandle/MemoryStreams.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+using mozilla::unused;
+using mozilla::void_t;
+using mozilla::ipc::PFileDescriptorSetParent;
+
 CacheStorageParent::CacheStorageParent(Namespace aNamespace,
                                        const nsACString& aOrigin,
                                        const nsACString& aBaseDomain)
   : mNamespace(aNamespace)
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
   , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
@@ -87,41 +94,44 @@ bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
   mManager->StorageKeys(this, aRequestId, mNamespace);
   return true;
 }
 
 void
 CacheStorageParent::OnStorageMatch(RequestId aRequestId, nsresult aRv,
-                                   const SavedResponse* aSavedResponse)
+                                   const SavedResponse* aSavedResponse,
+                                   Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
     responseOrVoid = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
-  // TODO: remove stream test code
-  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+  PCacheReadStream readStream;
+  Manager::StreamControl* streamControl =
+    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                        &readStream);
 
-  mManager->CacheReadBody(aSavedResponse->mCacheId, aSavedResponse->mBodyId,
-                          stream);
   responseOrVoid = aSavedResponse->mValue;
-  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+  responseOrVoid.get_PCacheResponse().body() = readStream;
+
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, streamControl);
 }
 
 void
 CacheStorageParent::OnStorageGet(RequestId aRequestId, nsresult aRv,
                                  bool aCacheFound, CacheId aCacheId)
 {
   if (NS_FAILED(aRv) || !aCacheFound) {
     unused << SendGetResponse(aRequestId, aRv, nullptr);
@@ -165,11 +175,53 @@ CacheStorageParent::OnStorageDelete(Requ
 
 void
 CacheStorageParent::OnStorageKeys(RequestId aRequestId, nsresult aRv,
                                   const nsTArray<nsString>& aKeys)
 {
   unused << SendKeysResponse(aRequestId, aRv, aKeys);
 }
 
+Manager::StreamControl*
+CacheStorageParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
+                                        const nsID& aId,
+                                        Manager::StreamList* aStreamList,
+                                        PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aStreamList);
+  MOZ_ASSERT(aReadStreamOut);
+
+  aReadStreamOut->id() = aId;
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
+  MOZ_ASSERT(stream);
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(stream, aReadStreamOut->params(), fds);
+
+  PFileDescriptorSetParent* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+  }
+
+  if (fdSet) {
+    aReadStreamOut->fds() = fdSet;
+  } else {
+    aReadStreamOut->fds() = void_t();
+  }
+
+  if (!aStreamControl) {
+    aStreamControl = new CacheStreamControlParent();
+    PCacheStreamControlParent* actor =
+      Manager()->SendPCacheStreamControlConstructor(aStreamControl);
+    MOZ_ASSERT(aStreamControl == actor);
+  }
+
+  aStreamList->SetStreamControl(aStreamControl);
+
+  return aStreamControl;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -37,30 +37,36 @@ public:
   virtual bool RecvCreate(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvDelete(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
-                              const SavedResponse* aResponse) MOZ_OVERRIDE;
+                              const SavedResponse* aResponse,
+                              Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound,
                             CacheId aCacheId) MOZ_OVERRIDE;
   virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound) MOZ_OVERRIDE;
   virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
                                CacheId aCacheId) MOZ_OVERRIDE;
   virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                bool aCacheDeleted) MOZ_OVERRIDE;
   virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
                              const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
+  Manager::StreamControl*
+  SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
+                      Manager::StreamList* aStreamList,
+                      PCacheReadStream* aReadStreamOut);
+
   const Namespace mNamespace;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
 } // namesapce cache
 } // namespace dom
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+void
+CacheStreamControlChild::AddListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlChild::RemoveListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlChild::NoteClosed(const nsID& aId)
+{
+  unused << SendNoteClosed(aId);
+}
+
+void
+CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  RecvCloseAll();
+}
+
+bool
+CacheStreamControlChild::RecvClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+  return true;
+}
+
+bool
+CacheStreamControlChild::RecvCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlChild_h
+#define mozilla_dom_cache_CacheStreamControlChild_h
+
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlChild : public PCacheStreamControlChild
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void CloseStream()=0;
+    virtual bool MatchId(const nsID& aId)=0;
+  };
+
+  void AddListener(Listener* aListener);
+  void RemoveListener(Listener* aListener);
+
+  void NoteClosed(const nsID& aId);
+
+  // PCacheStreamControlChild methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
+  virtual bool RecvCloseAll() MOZ_OVERRIDE;
+
+private:
+  nsTArray<Listener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+CacheStreamControlParent::CacheStreamControlParent()
+{
+}
+
+CacheStreamControlParent::~CacheStreamControlParent()
+{
+  MOZ_ASSERT(!mStreamList);
+}
+
+void
+CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  MOZ_ASSERT(mStreamList);
+  mStreamList->RemoveStreamControl(this);
+  mStreamList = nullptr;
+}
+
+bool
+CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
+{
+  MOZ_ASSERT(mStreamList);
+  mStreamList->NoteClosed(aId);
+  return true;
+}
+
+void
+CacheStreamControlParent::SetStreamList(Manager::StreamList* aStreamList)
+{
+  MOZ_ASSERT(!mStreamList);
+  mStreamList = aStreamList;
+}
+
+void
+CacheStreamControlParent::Close(const nsID& aId)
+{
+  unused << SendClose(aId);
+}
+
+void
+CacheStreamControlParent::CloseAll()
+{
+  unused << SendCloseAll();
+}
+
+void
+CacheStreamControlParent::Shutdown()
+{
+  unused << Send__delete__(this);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlParent_h
+#define mozilla_dom_cache_CacheStreamControlParent_h
+
+#include "mozilla/dom/cache/Manager.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlParent : public Manager::StreamControl
+{
+public:
+  CacheStreamControlParent();
+  ~CacheStreamControlParent();
+
+  // PCacheStreamControlParent methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
+
+  // Manager::StreamControl methods
+  virtual void SetStreamList(Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void Close(const nsID& aId) MOZ_OVERRIDE;
+  virtual void CloseAll() MOZ_OVERRIDE;
+  virtual void Shutdown() MOZ_OVERRIDE;
+
+private:
+  nsRefPtr<Manager::StreamList> mStreamList;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlParent_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -294,16 +294,45 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   rv = tmpFile->RenameTo(finalDir, finalFileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
+FileUtils::BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                    nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                    nsIInputStream** aStreamOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aStreamOut);
+
+  nsCOMPtr<nsIFile> finalFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIInputStream> fileStream =
+    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aBaseDomain, aOrigin,
+                            finalFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  fileStream.forget(aStreamOut);
+
+  return rv;
+}
+
+// static
+nsresult
 FileUtils::BodyStartReadStream(const nsACString& aOrigin,
                                const nsACString& aBaseDomain,
                                nsIFile* aBaseDir, CacheId aCacheId,
                                const nsID& aId, nsIOutputStream* aDest,
                                void* aClosure,
                                nsAsyncCopyCallbackFun aCallback,
                                nsISupports** aCopyContextOut)
 {
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -47,16 +47,21 @@ public:
   static void
   BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                   nsISupports* aCopyContext);
 
   static nsresult
   BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId);
 
   static nsresult
+  BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+           nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+           nsIInputStream** aStreamOut);
+
+  static nsresult
   BodyStartReadStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
                       nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                       nsIOutputStream* aDest, void* aClosure,
                       nsAsyncCopyCallbackFun aCallback,
                       nsISupports** aCopyContextOut);
 
   static void BodyCancelRead(nsISupports* aCopyContext);
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -236,114 +236,154 @@ private:
 };
 
 class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
-                   const PCacheQueryParams& aParams)
+                   const PCacheQueryParams& aParams,
+                   StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
+    , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
-                                &mFoundResponse, &mResponse);
+    nsresult rv = DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
+                                       &mFoundResponse, &mResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                             aDBDir, mCacheId, mResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mResponse.mBodyId, stream);
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     if (!mFoundResponse) {
-      aListener->OnCacheMatch(mRequestId, aRv, nullptr);
+      aListener->OnCacheMatch(mRequestId, aRv, nullptr, nullptr);
     } else {
-      aListener->OnCacheMatch(mRequestId, aRv, &mResponse);
+      mStreamList->Activate(mCacheId);
+      aListener->OnCacheMatch(mRequestId, aRv, &mResponse, mStreamList);
     }
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
 };
 
 class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, CacheId aCacheId,
                       const PCacheRequestOrVoid& aRequestOrVoid,
-                      const PCacheQueryParams& aParams)
+                      const PCacheQueryParams& aParams,
+                      StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
+    , mStreamList(aStreamList)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid, mParams,
-                                   mSavedResponses);
+    nsresult rv = DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid,
+                                          mParams, mSavedResponses);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
+      nsCOMPtr<nsIInputStream> stream;
+      rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                               aDBDir, mCacheId, mSavedResponses[i].mBodyId,
+                               getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+      mStreamList->Add(mSavedResponses[i].mBodyId, stream);
+    }
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses);
+    mStreamList->Activate(mCacheId);
+    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses, mStreamList);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAllAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
 class Manager::CachePutAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAction(Manager* aManager, ListenerId aListenerId,
                  RequestId aRequestId, CacheId aCacheId,
                  const PCacheRequest& aRequest,
                  nsIInputStream* aRequestBodyStream,
                  const PCacheResponse& aResponse,
-                 nsIInputStream* aResponseBodyStream)
+                 nsIInputStream* aResponseBodyStream,
+                 StreamList* aStreamList)
     : DBAction(DBAction::Existing, aManager->Origin(), aManager->BaseDomain())
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mRequestBodyStream(aRequestBodyStream)
     , mResponse(aResponse)
     , mResponseBodyStream(aResponseBodyStream)
+    , mStreamList(aStreamList)
     , mExpectedAsyncCopyCompletions(0)
   { }
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
                     mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
@@ -443,16 +483,36 @@ public:
     }
 
     rv = FileUtils::BodyDeleteFiles(mDBDir, mCacheId, deletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
       return;
     }
 
+    if (!mSavedResponse.mHasBodyId) {
+      DoResolve(rv);
+      return;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                             mDBDir, mCacheId, mSavedResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      DoResolve(rv);
+      return;
+    }
+    if (NS_WARN_IF(!stream)) {
+      DoResolve(NS_ERROR_FILE_NOT_FOUND);
+      return;
+    }
+
+    mStreamList->Add(mSavedResponse.mBodyId, stream);
+
     rv = trans.Commit();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
       return;
     }
 
     DoResolve(rv);
   }
@@ -462,19 +522,20 @@ public:
   {
     NS_ASSERT_OWNINGTHREAD(Action);
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (!listener) {
       return;
     }
     if (NS_FAILED(aRv)) {
-      listener->OnCachePut(mRequestId, aRv, nullptr);
+      listener->OnCachePut(mRequestId, aRv, nullptr, nullptr);
     } else {
-      listener->OnCachePut(mRequestId, aRv, &mSavedResponse);
+      mStreamList->Activate(mCacheId);
+      listener->OnCachePut(mRequestId, aRv, &mSavedResponse, mStreamList);
     }
   }
 
   virtual void
   CancelOnTarget() MOZ_OVERRIDE
   {
     CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
                      mRequestBodyId);
@@ -565,16 +626,17 @@ private:
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   nsCOMPtr<nsIInputStream> mRequestBodyStream;
   const PCacheResponse mResponse;
   nsCOMPtr<nsIInputStream> mResponseBodyStream;
+  nsRefPtr<StreamList> mStreamList;
   nsRefPtr<Resolver> mResolver;
   nsCOMPtr<nsIFile> mDBDir;
   nsCOMPtr<mozIStorageConnection> mConn;
   uint32_t mExpectedAsyncCopyCompletions;
   nsID mRequestBodyId;
   nsCOMPtr<nsISupports> mRequestBodyCopyContext;
   nsID mResponseBodyId;
   nsCOMPtr<nsISupports> mResponseBodyCopyContext;
@@ -639,47 +701,65 @@ protected:
 };
 
 class Manager::CacheKeysAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheKeysAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequestOrVoid& aRequestOrVoid,
-                    const PCacheQueryParams& aParams)
+                    const PCacheQueryParams& aParams,
+                    StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
+    , mStreamList(aStreamList)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheKeys(aConn, mCacheId, mRequestOrVoid, mParams,
-                               mSavedRequests);
+    nsresult rv = DBSchema::CacheKeys(aConn, mCacheId, mRequestOrVoid, mParams,
+                                      mSavedRequests);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
+      nsCOMPtr<nsIInputStream> stream;
+      rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                               aDBDir, mCacheId, mSavedRequests[i].mBodyId,
+                               getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+      mStreamList->Add(mSavedRequests[i].mBodyId, stream);
+    }
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    aListener->OnCacheKeys(mRequestId, aRv, mSavedRequests);
+    mStreamList->Activate(mCacheId);
+    aListener->OnCacheKeys(mRequestId, aRv, mSavedRequests, mStreamList);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheKeysAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedRequest> mSavedRequests;
 };
 
 class Manager::CacheReadBodyAction MOZ_FINAL : public Action
 {
 public:
   CacheReadBodyAction(Manager* aManager, CacheId aCacheId,
                       const nsID& aBodyId,
@@ -791,47 +871,67 @@ private:
 };
 
 class Manager::StorageMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   StorageMatchAction(Manager* aManager, ListenerId aListenerId,
                      RequestId aRequestId, Namespace aNamespace,
                      const PCacheRequest& aRequest,
-                     const PCacheQueryParams& aParams)
+                     const PCacheQueryParams& aParams,
+                     StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mRequest(aRequest)
     , mParams(aParams)
+    , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::StorageMatch(aConn, mNamespace, mRequest, mParams,
-                                  &mFoundResponse, &mSavedResponse);
+    nsresult rv = DBSchema::StorageMatch(aConn, mNamespace, mRequest, mParams,
+                                         &mFoundResponse, &mSavedResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mSavedResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                             aDBDir, mSavedResponse.mCacheId,
+                             mSavedResponse.mBodyId, getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mSavedResponse.mBodyId, stream);
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     if (!mFoundResponse) {
-      aListener->OnStorageMatch(mRequestId, aRv, nullptr);
+      aListener->OnStorageMatch(mRequestId, aRv, nullptr, nullptr);
     } else {
-      aListener->OnStorageMatch(mRequestId, aRv, &mSavedResponse);
+      mStreamList->Activate(mSavedResponse.mCacheId);
+      aListener->OnStorageMatch(mRequestId, aRv, &mSavedResponse, mStreamList);
     }
   }
 
 protected:
   virtual ~StorageMatchAction() { }
   const Namespace mNamespace;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mSavedResponse;
 };
 
 class Manager::StorageGetAction : public Manager::BaseAction
 {
 public:
   StorageGetAction(Manager* aManager, ListenerId aListenerId,
@@ -1021,16 +1121,125 @@ public:
   }
 
 private:
   virtual ~StorageKeysAction() { }
   const Namespace mNamespace;
   nsTArray<nsString> mKeys;
 };
 
+Manager::StreamList::StreamList(Manager* aManager, Context* aContext)
+  : mManager(aManager)
+  , mContext(aContext)
+  , mCacheId(0)
+  , mStreamControl(nullptr)
+  , mActivated(false)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mContext);
+}
+
+void
+Manager::StreamList::SetStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+  MOZ_ASSERT(aStreamControl);
+  mStreamControl = aStreamControl;
+  mStreamControl->SetStreamList(this);
+}
+
+void
+Manager::StreamList::RemoveStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(mStreamControl);
+  mStreamControl = nullptr;
+}
+
+void
+Manager::StreamList::Activate(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mActivated);
+  MOZ_ASSERT(!mCacheId);
+  mActivated = true;
+  mCacheId = aCacheId;
+  mManager->AddRefCacheId(mCacheId);
+  mManager->AddStreamList(this);
+}
+
+void
+Manager::StreamList::Add(const nsID& aId, nsIInputStream* aStream)
+{
+  // All streams should be added on IO thread before we set the stream
+  // control on the owning IPC thread.
+  MOZ_ASSERT(!mStreamControl);
+  MOZ_ASSERT(aStream);
+  Entry* entry = mList.AppendElement();
+  entry->mId = aId;
+  entry->mStream = aStream;
+}
+
+already_AddRefed<nsIInputStream>
+Manager::StreamList::Extract(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      return mList[i].mStream.forget();
+    }
+  }
+  return nullptr;
+}
+
+void
+Manager::StreamList::NoteClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      mList.RemoveElementAt(i);
+      break;
+    }
+  }
+
+  if (mList.IsEmpty() && mStreamControl) {
+    mStreamControl->Shutdown();
+  }
+}
+
+void
+Manager::StreamList::Close(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->Close(aId);
+  }
+}
+
+void
+Manager::StreamList::CloseAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->CloseAll();
+  }
+}
+
+Manager::StreamList::~StreamList()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+  if (mActivated) {
+    mManager->RemoveStreamList(this);
+    mManager->ReleaseCacheId(mCacheId);
+  }
+}
+
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
 }
 
@@ -1084,56 +1293,75 @@ Manager::GetCacheIdRefCount(CacheId aCac
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
       return mCacheIdRefs[i].mCount;
     }
   }
   return 0;
 }
 
+// TODO: figure out how to call Manager::Shutdown from observer on main thread
+void
+Manager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
+    mStreamLists[i]->CloseAll();
+  }
+  if (mContext) {
+    mContext->CancelAll();
+  }
+}
+
 void
 Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
-                                                 aCacheId, aRequest, aParams);
+                                                 aCacheId, aRequest, aParams,
+                                                 streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
                        CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
                        const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
-                                                    aCacheId, aRequest, aParams);
+                                                    aCacheId, aRequest, aParams,
+                                                    streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   nsIInputStream* aRequestBodyStream,
                   const PCacheResponse& aResponse,
                   nsIInputStream* aResponseBodyStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CachePutAction(this, listenerId, aRequestId,
                                                aCacheId,
                                                aRequest, aRequestBodyStream,
-                                               aResponse, aResponseBodyStream);
+                                               aResponse, aResponseBodyStream,
+                                               streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheDelete(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequest& aRequest,
                      const PCacheQueryParams& aParams)
 {
@@ -1147,20 +1375,21 @@ Manager::CacheDelete(Listener* aListener
 
 void
 Manager::CacheKeys(Listener* aListener, RequestId aRequestId,
                    CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                    const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheKeysAction(this, listenerId, aRequestId,
                                                 aCacheId, aRequestOrVoid,
-                                                aParams);
+                                                aParams, streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheReadBody(CacheId aCacheId, const nsID& aBodyId,
                        nsIOutputStream* aStream)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
@@ -1172,20 +1401,21 @@ Manager::CacheReadBody(CacheId aCacheId,
 
 void
 Manager::StorageMatch(Listener* aListener, RequestId aRequestId,
                       Namespace aNamespace, const PCacheRequest& aRequest,
                       const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext());
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new StorageMatchAction(this, listenerId, aRequestId,
                                                    aNamespace, aRequest,
-                                                   aParams);
+                                                   aParams, streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::StorageGet(Listener* aListener, RequestId aRequestId,
                     Namespace aNamespace, const nsAString& aKey)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
@@ -1307,11 +1537,27 @@ Manager::GetListener(ListenerId aListene
   for (uint32_t i = 0; i < mListeners.Length(); ++i) {
     if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
       return mListeners[i];
     }
   }
   return nullptr;
 }
 
+void
+Manager::AddStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.AppendElement(aStreamList);
+}
+
+void
+Manager::RemoveStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.RemoveElement(aStreamList);
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIOutputStream;
@@ -27,34 +28,88 @@ class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
 {
 public:
+  class StreamList;
+
+  class StreamControl : public PCacheStreamControlParent
+  {
+  public:
+    virtual ~StreamControl() { }
+
+    virtual void SetStreamList(StreamList* aStreamList)=0;
+
+    virtual void Close(const nsID& aId)=0;
+    virtual void CloseAll()=0;
+    virtual void Shutdown()=0;
+  };
+
+  class StreamList
+  {
+  public:
+    StreamList(Manager* aManager, Context* aContext);
+
+    void SetStreamControl(StreamControl* aStreamControl);
+    void RemoveStreamControl(StreamControl* aStreamControl);
+
+    void Activate(CacheId aCacheId);
+
+    void Add(const nsID& aId, nsIInputStream* aStream);
+    already_AddRefed<nsIInputStream> Extract(const nsID& aId);
+
+    void NoteClosed(const nsID& aId);
+    void Close(const nsID& aId);
+    void CloseAll();
+
+  private:
+    ~StreamList();
+    struct Entry
+    {
+      nsID mId;
+      nsCOMPtr<nsIInputStream> mStream;
+    };
+    nsRefPtr<Manager> mManager;
+    nsRefPtr<Context> mContext;
+    CacheId mCacheId;
+    StreamControl* mStreamControl;
+    nsTArray<Entry> mList;
+    bool mActivated;
+
+  public:
+    NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager::StreamList)
+  };
+
   class Listener
   {
   public:
     virtual ~Listener() { }
 
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                              const SavedResponse* aResponse) { }
+                              const SavedResponse* aResponse,
+                              StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<SavedResponse>& aSavedResponses) { }
+                                 const nsTArray<SavedResponse>& aSavedResponses,
+                                 StreamList* aStreamList) { }
     virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
-                            const SavedResponse* aSavedResponse) { }
+                            const SavedResponse* aSavedResponse,
+                            StreamList* aStreamList) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
     virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<SavedRequest>& aSavedRequests) { }
+                             const nsTArray<SavedRequest>& aSavedRequests,
+                             StreamList* aStreamList) { }
 
     virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
-                                const SavedResponse* aResponse) { }
+                                const SavedResponse* aResponse,
+                                StreamList* aStreamList) { }
     virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound, CacheId aCacheId) { }
     virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                               bool aCacheFound) { }
     virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
                                  CacheId aCacheId) { }
     virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                  bool aCacheDeleted) { }
@@ -64,16 +119,17 @@ public:
 
   static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
                                              const nsACString& aBaseDomain);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   uint32_t GetCacheIdRefCount(CacheId aCacheId);
+  void Shutdown();
 
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
@@ -135,20 +191,24 @@ private:
 
   Manager(const nsACString& aOrigin, const nsACString& aBaseDomain);
   ~Manager();
   Context* CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
+  void AddStreamList(StreamList* aStreamList);
+  void RemoveStreamList(StreamList* aStreamList);
+
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
+  nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
   {
     CacheId mCacheId;
     uint32_t mCount;
   };
   nsTArray<CacheIdRefCounter> mCacheIdRefs;
 
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,16 +1,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
+include protocol PCacheStreamControl;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
+include protocol PBlob; // FIXME: bug 792908
+
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
 {
   manager PBackground;
@@ -20,23 +24,29 @@ parent:
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
   Add(RequestId requestId, PCacheRequest request);
   AddAll(RequestId requestId, PCacheRequest[] requests);
   Put(RequestId requestId, PCacheRequest request, PCacheResponse response);
   Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
 
 child:
-  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
-  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
-  AddResponse(RequestId requestId, nsresult aRv, PCacheResponse response);
-  AddAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
-  PutResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
+  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse,
+                nullable PCacheStreamControl aStreamControl);
+  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses,
+                   nullable PCacheStreamControl aStreamControl);
+  AddResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response,
+              nullable PCacheStreamControl aStreamControl);
+  AddAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses,
+                 nullable PCacheStreamControl aStreamControl);
+  PutResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response,
+              nullable PCacheStreamControl aStreamControl);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
-  KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
+  KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests,
+               nullable PCacheStreamControl aStreamControl);
 
 both:
   __delete__();
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,15 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
+include protocol PCacheStreamControl;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
+
+include protocol PBlob; // FIXME: bug 792908
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
@@ -22,17 +26,18 @@ parent:
   Get(RequestId aRequestId, nsString aKey);
   Has(RequestId aRequestId, nsString aKey);
   Create(RequestId aRequestId, nsString aKey);
   Delete(RequestId aRequestId, nsString aKey);
   Keys(RequestId aRequestId);
 
 child:
   MatchResponse(RequestId aRequestId, nsresult aRv,
-                PCacheResponseOrVoid aResponseOrVoid);
+                PCacheResponseOrVoid aResponseOrVoid,
+                nullable PCacheStreamControl aStreamControl);
   GetResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   HasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   CreateResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
 
 both:
   __delete__();
diff --git a/dom/cache/PCacheStreamControl.ipdl b/dom/cache/PCacheStreamControl.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStreamControl.ipdl
@@ -0,0 +1,30 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStreamControl
+{
+  manager PBackground;
+
+parent:
+  NoteClosed(nsID aStreamId);
+
+child:
+  Close(nsID aStreamId);
+  CloseAll();
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,60 +1,77 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PHeaders;
+include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
+using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct PCacheQueryParams
 {
   bool ignoreSearch;
   bool ignoreMethod;
   bool ignoreVary;
   bool prefixMatch;
   bool cacheNameSet;
   nsString cacheName;
 };
 
+struct PCacheReadStream
+{
+  nsID id;
+  OptionalInputStreamParams params;
+  OptionalFileDescriptorSet fds;
+};
+
+union PCacheReadStreamOrVoid
+{
+  void_t;
+  PCacheReadStream;
+};
+
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
+  PCacheReadStreamOrVoid body;
 };
 
 union PCacheRequestOrVoid
 {
   void_t;
   PCacheRequest;
 };
 
 struct PCacheResponse
 {
   ResponseType type;
   nsString url;
   uint32_t status;
   nsCString statusText;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
+  PCacheReadStreamOrVoid body;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.cpp
@@ -0,0 +1,200 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ReadStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/InputStreamParams.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::InputStreamParams;
+using mozilla::ipc::OptionalFileDescriptorSet;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream,
+                                                   nsIIPCSerializableInputStream);
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlChild* aControl,
+                   const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  MOZ_ASSERT(aControl);
+
+  if (!aControl || aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  return Create(aControl, aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlChild* aControl,
+                   const PCacheReadStream& aReadStream)
+{
+  MOZ_ASSERT(aControl);
+
+  nsTArray<FileDescriptor> fds;
+  if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetChild* fdSetActor =
+      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  nsCOMPtr<nsIInputStream> stream =
+    DeserializeInputStream(aReadStream.params(), fds);
+
+  if (!stream) {
+    return nullptr;
+  }
+
+  // Currently we expect all cache read streams to be blocking file streams.
+#ifdef DEBUG
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+  MOZ_ASSERT(!asyncStream);
+#endif
+
+  nsRefPtr<ReadStream> ref = new ReadStream(aControl, aReadStream.id(), stream);
+  return ref.forget();
+}
+
+void
+ReadStream::CloseStream()
+{
+  Close();
+}
+
+bool
+ReadStream::MatchId(const nsID& aId)
+{
+  return mId.Equals(aId);
+}
+
+ReadStream::ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
+                       nsIInputStream* aStream)
+  : mControl(static_cast<CacheStreamControlChild*>(aControl))
+  , mId(aId)
+  , mStream(aStream)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mControl);
+  MOZ_ASSERT(mStream);
+
+  mSerializable = do_QueryInterface(mStream);
+  MOZ_ASSERT(mSerializable);
+
+  mControl->AddListener(this);
+}
+
+ReadStream::~ReadStream()
+{
+  NoteClosed();
+}
+
+void
+ReadStream::NoteClosed()
+{
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+  mControl->NoteClosed(mId);
+  mControl->RemoveListener(this);
+}
+
+NS_IMETHODIMP
+ReadStream::Close()
+{
+  NoteClosed();
+  return mStream->Close();
+}
+
+NS_IMETHODIMP
+ReadStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                         uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mStream->IsNonBlocking(aNonBlockingOut);
+}
+
+void
+ReadStream::Serialize(InputStreamParams& aParams, FileDescriptorArray& aFds)
+{
+  // TODO: will lose track of when stream underlying fd closes... must we accept this?
+  mSerializable->Serialize(aParams, aFds);
+}
+
+bool
+ReadStream::Deserialize(const InputStreamParams& aParams,
+                        const FileDescriptorArray& aFds)
+{
+  return mSerializable->Deserialize(aParams, aFds);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ReadStream_h
+#define mozilla_dom_cache_ReadStream_h
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIInputStream.h"
+#include "nsIIPCSerializableInputStream.h"
+#include "nsISupportsImpl.h"
+
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+
+class ReadStream : public nsIInputStream
+                 , public nsIIPCSerializableInputStream
+                 , public CacheStreamControlChild::Listener
+{
+public:
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlChild* aControl,
+         const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlChild* aControl,
+         const PCacheReadStream& aReadStream);
+
+  // CacheStreamControlChild::Listener methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
+
+private:
+  ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
+             nsIInputStream* aStream);
+  virtual ~ReadStream();
+
+  void NoteClosed();
+
+  CacheStreamControlChild* mControl;
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  nsCOMPtr<nsIIPCSerializableInputStream> mSerializable;
+  bool mClosed;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+  NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
--- a/dom/cache/SavedTypes.h
+++ b/dom/cache/SavedTypes.h
@@ -22,26 +22,26 @@ namespace cache {
 
 struct StreamHolder
 {
   nsCOMPtr<nsIOutputStream> mValue;
 };
 
 struct SavedRequest
 {
-  SavedRequest() : mHasBodyId(false) { }
+  SavedRequest() : mHasBodyId(false) { mValue.body() = void_t(); }
   PCacheRequest mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 struct SavedResponse
 {
-  SavedResponse() : mHasBodyId(false) { }
+  SavedResponse() : mHasBodyId(false) { mValue.body() = void_t(); }
   PCacheResponse mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -79,16 +79,17 @@ TypeUtils::ToPCacheRequest(PCacheRequest
   }
   aIn.GetReferrer(aOut.referrer());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn.Mode();
   aOut.credentials() = aIn.Credentials();
+  aOut.body() = void_t();
 }
 
 // static
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn)
 {
   nsRefPtr<Request> request;
@@ -138,16 +139,17 @@ TypeUtils::ToPCacheResponse(PCacheRespon
   aOut.type() = aIn.Type();
   aIn.GetUrl(aOut.url());
   aOut.status() = aIn.Status();
   aIn.GetStatusText(aOut.statusText());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
+  aOut.body() = void_t();
 }
 
 // static
 void
 TypeUtils:: ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
@@ -162,31 +164,35 @@ TypeUtils:: ToPCacheQueryParams(PCacheQu
     aOut.cacheName() = aIn.mCacheName.Value();
   } else {
     aOut.cacheName() = NS_LITERAL_STRING("");
   }
 }
 
 // static
 void
-TypeUtils::ToResponse(Response& aOut, const PCacheResponse& aIn)
+TypeUtils::ToResponse(Response& aOut, const PCacheResponse& aIn,
+                      nsIInputStream* aStream)
 {
   // TODO: implement once real Request/Response are available
   NS_WARNING("Not filling in contents of Response returned from Cache.");
 }
 
 // static
 void
-TypeUtils::ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn)
+TypeUtils::ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn,
+                             nsIInputStream* aStream)
 {
   aOut.SetMethod(aIn.method());
   aOut.SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   aOut.SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   aOut.SetMode(aIn.mode());
   aOut.SetCredentialsMode(aIn.credentials());
   nsRefPtr<Headers> headers = new Headers(aOut.GetClient(), aIn.headers(),
                                           aIn.headersGuard());
   aOut.SetHeaders(headers);
+  aOut.SetBody(aStream);
+  // TODO: clear request bodyRead flag
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -4,16 +4,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_TypesUtils_h
 #define mozilla_dom_cache_TypesUtils_h
 
 #include "mozilla/Attributes.h"
 
+class nsIInputStream;
+
 namespace mozilla {
 namespace dom {
 
 class OwningRequestOrScalarValueString;
 struct QueryParams;
 class InternalRequest;
 class Request;
 class RequestOrScalarValueString;
@@ -46,20 +48,22 @@ public:
 
   static void
   ToPCacheResponse(PCacheResponse& aOut, const Response& aIn);
 
   static void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   static void
-  ToResponse(Response& aOut, const PCacheResponse& aIn);
+  ToResponse(Response& aOut, const PCacheResponse& aIn,
+             nsIInputStream* aStream);
 
   static void
-  ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn);
+  ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn,
+                    nsIInputStream* aStream);
 
 private:
   TypeUtils() MOZ_DELETE;
   ~TypeUtils() MOZ_DELETE;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -10,47 +10,54 @@ EXPORTS.mozilla.dom.cache += [
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
+    'CacheStreamControlChild.h',
+    'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'ReadStream.h',
     'SavedTypes.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
+    'CacheStreamControlChild.cpp',
+    'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
+    'ReadStream.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheStorage.ipdl',
+    'PCacheStreamControl.ipdl',
     'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -6,22 +6,25 @@
 
 #include "FileDescriptorSetChild.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/dom/cache/PCacheStorageChild.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::CacheChild;
 using mozilla::dom::cache::PCacheChild;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlChild;
 
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
   nsCString mTestArg;
@@ -189,16 +192,29 @@ bool
 BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
 {
   // The CacheChild actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlChild*
+BackgroundChildImpl::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 // -----------------------------------------------------------------------------
 // MessageChannel/MessagePort API
 // -----------------------------------------------------------------------------
 
 dom::PMessagePortChild*
 BackgroundChildImpl::AllocPMessagePortChild()
 {
   nsRefPtr<dom::MessagePortChild> agent = new dom::MessagePortChild();
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -11,16 +11,17 @@
 template <class> class nsAutoPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheChild;
 class PCacheStorageChild;
+class PCacheStreamControlChild;
 
 } // namespace cache
 namespace indexedDB {
 
 class IDBTransaction;
 
 } // namespace indexedDB
 } // namespace dom
@@ -84,16 +85,22 @@ protected:
   virtual bool
   DeallocPCacheStorageChild(mozilla::dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheChild(mozilla::dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlChild*
+  AllocPCacheStreamControlChild();
+
+  virtual bool
+  DeallocPCacheStreamControlChild(mozilla::dom::cache::PCacheStreamControlChild* aActor);
+
   virtual PMessagePortChild*
   AllocPMessagePortChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortChild(PMessagePortChild* aActor) MOZ_OVERRIDE;
 };
 
 class BackgroundChildImpl::ThreadLocal MOZ_FINAL
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -7,16 +7,17 @@
 #include "FileDescriptorSetParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/dom/MessagePortParent.h"
 #include "mozilla/dom/cache/CacheStorageParent.h"
 #include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
@@ -25,16 +26,17 @@
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
 using namespace mozilla::dom;
 using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::CacheStorageParent;
 using mozilla::dom::cache::PCacheStorageParent;
+using mozilla::dom::cache::PCacheStreamControlParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -239,16 +241,32 @@ bool
 BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
 {
   // The CacheParent actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlParent*
+BackgroundParentImpl::AllocPCacheStreamControlParent()
+{
+  MOZ_CRASH("CacheStreamControlParent actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  // The CacheStreamControlParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
 PMessagePortParent*
 BackgroundParentImpl::AllocPMessagePortParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   return new MessagePortParent();
 }
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -8,16 +8,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
   class PCacheParent;
   class PCacheStorageParent;
+  class PCacheStreamControlParent;
 }
 }
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundParentImpl : public PBackgroundParent
 {
@@ -74,16 +75,22 @@ protected:
   virtual bool
   DeallocPCacheStorageParent(mozilla::dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheParent(mozilla::dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlParent*
+  AllocPCacheStreamControlParent();
+
+  virtual bool
+  DeallocPCacheStreamControlParent(mozilla::dom::cache::PCacheStreamControlParent* aActor);
+
   virtual PMessagePortParent*
   AllocPMessagePortParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortParent(PMessagePortParent* aActor) MOZ_OVERRIDE;
 };
 
 } // namespace ipc
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,18 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PFileDescriptorSet;
+include protocol PCache;
 include protocol PCacheStorage;
-include protocol PCache;
+include protocol PCacheStreamControl;
 include protocol PMessagePort;
 
 include DOMTypes;
 
 using struct mozilla::void_t
   from "ipc/IPCMessageUtils.h";
 using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
@@ -32,18 +33,19 @@ union OptionalWindowId
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
   manages PBackgroundTest;
   manages PBlob;
   manages PFileDescriptorSet;
+  manages PCache;
   manages PCacheStorage;
-  manages PCache;
+  manages PCacheStreamControl;
   manages PMessagePort;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(OptionalWindowId optionalWindowId);
 
@@ -53,12 +55,13 @@ parent:
 
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 
 child:
   PCache();
+  PCacheStreamControl();
 };
 
 } // namespace ipc
 } // namespace mozilla
