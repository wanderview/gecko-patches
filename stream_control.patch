# HG changeset patch
# Parent b841f71aaae7866f980d94727f74a1014c4b058f
# User Ben Kelly <ben@wanderview.com>
Return file stream contained in an IPC stream controlled wrapper.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -6,16 +6,17 @@
 
 #include "mozilla/dom/cache/Cache.h"
 
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheChild.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/unused.h"
 #include "nsIGlobalObject.h"
 #include "nsNetUtil.h"
 
 namespace mozilla {
@@ -283,64 +284,63 @@ Cache::ActorDestroy(mozilla::ipc::IProto
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 Cache::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                         const PCacheResponseOrVoid& aResponse)
+                         const PCacheResponseOrVoid& aResponse,
+                         PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
+
   nsRefPtr<Response> response = new Response(mOwner);
-  if (!response) {
-    promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-    return;
-  }
-  TypeUtils::ToResponse(*response, aResponse);
+  nsCOMPtr<nsIInputStream> stream =
+    ReadStream::Create(aStreamControl, aResponse.get_PCacheResponse().body());
+  TypeUtils::ToResponse(*response, aResponse, stream);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                            const nsTArray<PCacheResponse>& aResponses)
+                            const nsTArray<PCacheResponse>& aResponses,
+                            PCacheStreamControlChild* aStreamControl)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     nsRefPtr<Response> response = new Response(mOwner);
-    if (!response) {
-      promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
-      return;
-    }
-    TypeUtils::ToResponse(*response, aResponses[i]);
+    nsCOMPtr<nsIInputStream> stream =
+      ReadStream::Create(aStreamControl, aResponses[i].body());
+    TypeUtils::ToResponse(*response, aResponses[i], stream);
     responses.AppendElement(response);
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvAddResponse(RequestId aRequestId, nsresult aRv,
                        const PCacheResponse& aResponse)
@@ -355,17 +355,18 @@ Cache::RecvAddResponse(RequestId aReques
     return;
   }
 
   nsRefPtr<Response> response = new Response(mOwner);
   if (!response) {
     promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
     return;
   }
-  TypeUtils::ToResponse(*response, aResponse);
+  // TODO: pass real stream
+  TypeUtils::ToResponse(*response, aResponse, nullptr);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
                           const nsTArray<PCacheResponse>& aResponses)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
@@ -380,17 +381,18 @@ Cache::RecvAddAllResponse(RequestId aReq
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
     nsRefPtr<Response> response = new Response(mOwner);
     if (!response) {
       promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
       return;
     }
-    TypeUtils::ToResponse(*response, aResponses[i]);
+    // TODO: pass real stream
+    TypeUtils::ToResponse(*response, aResponses[i], nullptr);
     responses.AppendElement(response);
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvPutResponse(RequestId aRequestId, nsresult aRv,
                        const PCacheResponseOrVoid& aResponse)
@@ -409,17 +411,18 @@ Cache::RecvPutResponse(RequestId aReques
     promise->MaybeResolve(nullptr);
     return;
   }
   nsRefPtr<Response> response = new Response(mOwner);
   if (!response) {
     promise->MaybeReject(NS_ERROR_OUT_OF_MEMORY);
     return;
   }
-  TypeUtils::ToResponse(*response, aResponse);
+  // TODO: pass real stream
+  TypeUtils::ToResponse(*response, aResponse, nullptr);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -69,20 +69,22 @@ public:
 
   virtual nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // CacheChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& aResponses,
+                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponse& aResponse) MOZ_OVERRIDE;
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
                      const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv,
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -43,29 +43,31 @@ void
 CacheChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
 bool
 CacheChild::RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                              const PCacheResponseOrVoid& response)
+                              const PCacheResponseOrVoid& aResponse,
+                              PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchResponse(requestId, aRv, response);
+  mListener->RecvMatchResponse(requestId, aRv, aResponse, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                                 const nsTArray<PCacheResponse>& responses)
+                                 const nsTArray<PCacheResponse>& responses,
+                                 PCacheStreamControlChild* aStreamControl)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchAllResponse(requestId, aRv, responses);
+  mListener->RecvMatchAllResponse(requestId, aRv, responses, aStreamControl);
   return true;
 }
 
 bool
 CacheChild::RecvAddResponse(const RequestId& requestId, const nsresult& aRv,
                             const PCacheResponse& response)
 {
   MOZ_ASSERT(mListener);
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -26,20 +26,22 @@ public:
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   void SetListener(CacheChildListener& aListener);
   void ClearListener();
 
   // PCacheChild methods
   virtual bool
   RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                    const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                       const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& responses,
+                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
   virtual bool
   RecvAddResponse(const RequestId& requestId, const nsresult& aRv,
                   const PCacheResponse& response) MOZ_OVERRIDE;
   virtual bool
   RecvAddAllResponse(const RequestId& requestId, const nsresult& aRv,
                      const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
   virtual bool
   RecvPutResponse(const RequestId& requestId, const nsresult& aRv,
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -17,29 +17,32 @@ namespace ipc {
 }
 
 namespace dom {
 namespace cache {
 
 class PCacheRequest;
 class PCacheResponse;
 class PCacheResponseOrVoid;
+class PCacheStreamControlChild;
 
 class CacheChildListener
 {
 public:
   virtual ~CacheChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
 
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse)=0;
+                    const PCacheResponseOrVoid& aResponse,
+                    PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses)=0;
+                       const nsTArray<PCacheResponse>& aResponses,
+                       PCacheStreamControlChild* aStreamControl)=0;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponse& aResponse)=0;
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
                      const nsTArray<PCacheResponse>& aResponses)=0;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv,
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -2,29 +2,34 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsCOMPtr.h"
 
 // TODO: remove testing only headers
 #include "../../dom/filehandle/MemoryStreams.h"
 #include "nsStringStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
+using mozilla::ipc::PFileDescriptorSetParent;
 
 CacheParent::CacheParent(const nsACString& aOrigin,
                          const nsACString& aBaseDomain,
                          CacheId aCacheId)
   : mCacheId(aCacheId)
   , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
   MOZ_ASSERT(mManager);
@@ -45,17 +50,18 @@ CacheParent::ActorDestroy(ActorDestroyRe
   mManager = nullptr;
 }
 
 bool
 CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
-  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest, aParams);
+  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest,
+                       aParams);
   return true;
 }
 
 bool
 CacheParent::RecvMatchAll(const RequestId& aRequestId,
                           const PCacheRequestOrVoid& aRequest,
                           const PCacheQueryParams& aParams)
 {
@@ -122,62 +128,72 @@ CacheParent::RecvKeys(const RequestId& a
 {
   MOZ_ASSERT(mManager);
   mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                          const SavedResponse* aSavedResponse)
+                          const SavedResponse* aSavedResponse,
+                          Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
-  if (NS_FAILED(aRv) || !aSavedResponse) {
+  if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
     responseOrVoid = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+    responseOrVoid.get_PCacheResponse().body() = void_t();
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
     return;
   }
 
-  // TODO: remove stream test code
-  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+  PCacheReadStream readStream;
+  Manager::StreamControl* streamControl =
+    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                        &readStream);
 
-  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
   responseOrVoid = aSavedResponse->mValue;
-  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
+  responseOrVoid.get_PCacheResponse().body() = readStream;
+
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, streamControl);
 }
 
 void
 CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<SavedResponse>& aSavedResponses)
+                             const nsTArray<SavedResponse>& aSavedResponses,
+                             Manager::StreamList* aStreamList)
 {
+  Manager::StreamControl* streamControl = nullptr;
   nsTArray<PCacheResponse> responses;
-  nsTArray<nsCOMPtr<nsIOutputStream>> responseStreams;
+
   for (uint32_t i = 0; i < aSavedResponses.Length(); ++i) {
-    responses.AppendElement(aSavedResponses[i].mValue);
+    PCacheResponse* res = responses.AppendElement();
+    *res = aSavedResponses[i].mValue;
 
     if (!aSavedResponses[i].mHasBodyId) {
-      responseStreams.AppendElement();
-    } else {
-      // TODO: remove stream test code
-      responseStreams.AppendElement(MemoryOutputStream::Create(4096));
-      mManager->CacheReadBody(mCacheId, aSavedResponses[i].mBodyId,
-                              responseStreams[i]);
+      res->body() = void_t();
+      continue;
     }
+
+    PCacheReadStream readStream;
+    streamControl =
+      SerializeReadStream(streamControl, aSavedResponses[i].mBodyId,
+                          aStreamList, &readStream);
+    res->body() = readStream;
   }
 
-  unused << SendMatchAllResponse(aRequestId, aRv, responses);
+  unused << SendMatchAllResponse(aRequestId, aRv, responses, streamControl);
 }
 
 void
 CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv,
                         const SavedResponse* aSavedResponse)
 {
   PCacheResponseOrVoid responseOrVoid;
 
@@ -226,11 +242,53 @@ CacheParent::OnCacheKeys(RequestId aRequ
       mManager->CacheReadBody(mCacheId, aSavedRequests[i].mBodyId,
                               requestStreams[i]);
     }
   }
 
   unused << SendKeysResponse(aRequestId, aRv, requests);
 }
 
+Manager::StreamControl*
+CacheParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
+                                 const nsID& aId,
+                                 Manager::StreamList* aStreamList,
+                                 PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aStreamList);
+  MOZ_ASSERT(aReadStreamOut);
+
+  aReadStreamOut->id() = aId;
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
+  MOZ_ASSERT(stream);
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(stream, aReadStreamOut->params(), fds);
+
+  PFileDescriptorSetParent* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+  }
+
+  if (fdSet) {
+    aReadStreamOut->fds() = fdSet;
+  } else {
+    aReadStreamOut->fds() = void_t();
+  }
+
+  if (!aStreamControl) {
+    aStreamControl = new CacheStreamControlParent();
+    PCacheStreamControlParent* actor =
+      Manager()->SendPCacheStreamControlConstructor(aStreamControl);
+    MOZ_ASSERT(aStreamControl == actor);
+  }
+
+  aStreamList->SetStreamControl(aStreamControl);
+
+  return aStreamControl;
+}
+
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -51,27 +51,34 @@ public:
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                            const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
+                            const SavedResponse* aSavedResponse,
+                            Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
+                               const nsTArray<SavedResponse>& aSavedResponses,
+                               Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
   virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                      const nsTArray<SavedRequest>& aSavedRequests) MOZ_OVERRIDE;
 
 private:
+  Manager::StreamControl*
+  SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
+                      Manager::StreamList* aStreamList,
+                      PCacheReadStream* aReadStreamOut);
+
   const CacheId mCacheId;
   nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -274,17 +274,18 @@ CacheStorage::RecvMatchResponse(RequestI
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
   nsRefPtr<Response> response = new Response(mOwner);
-  TypeUtils::ToResponse(*response, aResponse);
+  // TODO: pass real stream
+  TypeUtils::ToResponse(*response, aResponse, nullptr);
   promise->MaybeResolve(response);
 }
 
 void
 CacheStorage::RecvGetResponse(RequestId aRequestId, nsresult aRv,
                               PCacheChild* aActor)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+void
+CacheStreamControlChild::AddListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlChild::RemoveListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlChild::NoteClosed(const nsID& aId)
+{
+  unused << SendNoteClosed(aId);
+}
+
+void
+CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  RecvCloseAll();
+}
+
+bool
+CacheStreamControlChild::RecvClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+  return true;
+}
+
+bool
+CacheStreamControlChild::RecvCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlChild_h
+#define mozilla_dom_cache_CacheStreamControlChild_h
+
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlChild : public PCacheStreamControlChild
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void CloseStream()=0;
+    virtual bool MatchId(const nsID& aId)=0;
+  };
+
+  void AddListener(Listener* aListener);
+  void RemoveListener(Listener* aListener);
+
+  void NoteClosed(const nsID& aId);
+
+  // PCacheStreamControlChild methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
+  virtual bool RecvCloseAll() MOZ_OVERRIDE;
+
+private:
+  nsTArray<Listener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+CacheStreamControlParent::CacheStreamControlParent()
+{
+}
+
+CacheStreamControlParent::~CacheStreamControlParent()
+{
+  MOZ_ASSERT(!mStreamList);
+}
+
+void
+CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  MOZ_ASSERT(mStreamList);
+  mStreamList->RemoveStreamControl(this);
+  mStreamList = nullptr;
+}
+
+bool
+CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
+{
+  MOZ_ASSERT(mStreamList);
+  mStreamList->NoteClosed(aId);
+  return true;
+}
+
+void
+CacheStreamControlParent::SetStreamList(Manager::StreamList* aStreamList)
+{
+  MOZ_ASSERT(!mStreamList);
+  mStreamList = aStreamList;
+}
+
+void
+CacheStreamControlParent::Close(const nsID& aId)
+{
+  unused << SendClose(aId);
+}
+
+void
+CacheStreamControlParent::CloseAll()
+{
+  unused << SendCloseAll();
+}
+
+void
+CacheStreamControlParent::Shutdown()
+{
+  unused << Send__delete__(this);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlParent_h
+#define mozilla_dom_cache_CacheStreamControlParent_h
+
+#include "mozilla/dom/cache/Manager.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlParent : public Manager::StreamControl
+{
+public:
+  CacheStreamControlParent();
+  ~CacheStreamControlParent();
+
+  // PCacheStreamControlParent methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
+
+  // Manager::StreamControl methods
+  virtual void SetStreamList(Manager::StreamList* aStreamList) MOZ_OVERRIDE;
+  virtual void Close(const nsID& aId) MOZ_OVERRIDE;
+  virtual void CloseAll() MOZ_OVERRIDE;
+  virtual void Shutdown() MOZ_OVERRIDE;
+
+private:
+  nsRefPtr<Manager::StreamList> mStreamList;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlParent_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -294,16 +294,45 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   rv = tmpFile->RenameTo(finalDir, finalFileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
+FileUtils::BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                    nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                    nsIInputStream** aStreamOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aStreamOut);
+
+  nsCOMPtr<nsIFile> finalFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIInputStream> fileStream =
+    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aBaseDomain, aOrigin,
+                            finalFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  fileStream.forget(aStreamOut);
+
+  return rv;
+}
+
+// static
+nsresult
 FileUtils::BodyStartReadStream(const nsACString& aOrigin,
                                const nsACString& aBaseDomain,
                                nsIFile* aBaseDir, CacheId aCacheId,
                                const nsID& aId, nsIOutputStream* aDest,
                                void* aClosure,
                                nsAsyncCopyCallbackFun aCallback,
                                nsISupports** aCopyContextOut)
 {
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -47,16 +47,21 @@ public:
   static void
   BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                   nsISupports* aCopyContext);
 
   static nsresult
   BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId);
 
   static nsresult
+  BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+           nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+           nsIInputStream** aStreamOut);
+
+  static nsresult
   BodyStartReadStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
                       nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                       nsIOutputStream* aDest, void* aClosure,
                       nsAsyncCopyCallbackFun aCallback,
                       nsISupports** aCopyContextOut);
 
   static void BodyCancelRead(nsISupports* aCopyContext);
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -236,93 +236,131 @@ private:
 };
 
 class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
-                   const PCacheQueryParams& aParams)
+                   const PCacheQueryParams& aParams,
+                   StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
+    , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
-                                &mFoundResponse, &mResponse);
+    nsresult rv = DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
+                                       &mFoundResponse, &mResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                             aDBDir, mCacheId, mResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mResponse.mBodyId, stream);
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     if (!mFoundResponse) {
-      aListener->OnCacheMatch(mRequestId, aRv, nullptr);
+      aListener->OnCacheMatch(mRequestId, aRv, nullptr, nullptr);
     } else {
-      aListener->OnCacheMatch(mRequestId, aRv, &mResponse);
+      mStreamList->Activate();
+      aListener->OnCacheMatch(mRequestId, aRv, &mResponse, mStreamList);
     }
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
 };
 
 class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, CacheId aCacheId,
                       const PCacheRequestOrVoid& aRequestOrVoid,
-                      const PCacheQueryParams& aParams)
+                      const PCacheQueryParams& aParams,
+                      StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
+    , mStreamList(aStreamList)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid, mParams,
-                                   mSavedResponses);
+    nsresult rv = DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid,
+                                          mParams, mSavedResponses);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
+      nsCOMPtr<nsIInputStream> stream;
+      rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                               aDBDir, mCacheId, mSavedResponses[i].mBodyId,
+                               getter_AddRefs(stream));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+      mStreamList->Add(mSavedResponses[i].mBodyId, stream);
+    }
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
-    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses);
+    mStreamList->Activate();
+    aListener->OnCacheMatchAll(mRequestId, aRv, mSavedResponses, mStreamList);
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAllAction() { }
   const CacheId mCacheId;
   const PCacheRequestOrVoid mRequestOrVoid;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
 class Manager::CachePutAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAction(Manager* aManager, ListenerId aListenerId,
                  RequestId aRequestId, CacheId aCacheId,
@@ -1021,16 +1059,124 @@ public:
   }
 
 private:
   virtual ~StorageKeysAction() { }
   const Namespace mNamespace;
   nsTArray<nsString> mKeys;
 };
 
+Manager::StreamList::StreamList(Manager* aManager, Context* aContext,
+                                CacheId aCacheId)
+  : mManager(aManager)
+  , mContext(aContext)
+  , mCacheId(aCacheId)
+  , mStreamControl(nullptr)
+  , mActivated(false)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mContext);
+}
+
+void
+Manager::StreamList::SetStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+  MOZ_ASSERT(aStreamControl);
+  mStreamControl = aStreamControl;
+  mStreamControl->SetStreamList(this);
+}
+
+void
+Manager::StreamList::RemoveStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(mStreamControl);
+  mStreamControl = nullptr;
+}
+
+void
+Manager::StreamList::Activate()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mActivated);
+  mActivated = true;
+  mManager->AddRefCacheId(mCacheId);
+  mManager->AddStreamList(this);
+}
+
+void
+Manager::StreamList::Add(const nsID& aId, nsIInputStream* aStream)
+{
+  // All streams should be added on IO thread before we set the stream
+  // control on the owning IPC thread.
+  MOZ_ASSERT(!mStreamControl);
+  MOZ_ASSERT(aStream);
+  Entry* entry = mList.AppendElement();
+  entry->mId = aId;
+  entry->mStream = aStream;
+}
+
+already_AddRefed<nsIInputStream>
+Manager::StreamList::Extract(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      return mList[i].mStream.forget();
+    }
+  }
+  return nullptr;
+}
+
+void
+Manager::StreamList::NoteClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      mList.RemoveElementAt(i);
+      break;
+    }
+  }
+
+  if (mList.IsEmpty() && mStreamControl) {
+    mStreamControl->Shutdown();
+  }
+}
+
+void
+Manager::StreamList::Close(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->Close(aId);
+  }
+}
+
+void
+Manager::StreamList::CloseAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->CloseAll();
+  }
+}
+
+Manager::StreamList::~StreamList()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+  if (mActivated) {
+    mManager->RemoveStreamList(this);
+    mManager->ReleaseCacheId(mCacheId);
+  }
+}
+
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
 }
 
@@ -1084,39 +1230,58 @@ Manager::GetCacheIdRefCount(CacheId aCac
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
       return mCacheIdRefs[i].mCount;
     }
   }
   return 0;
 }
 
+// TODO: figure out how to call Manager::Shutdown from observer on main thread
+void
+Manager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
+    mStreamLists[i]->CloseAll();
+  }
+  if (mContext) {
+    mContext->CancelAll();
+  }
+}
+
 void
 Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext(),
+                                                   aCacheId);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
-                                                 aCacheId, aRequest, aParams);
+                                                 aCacheId, aRequest, aParams,
+                                                 streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
                        CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
                        const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext(),
+                                                   aCacheId);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
-                                                    aCacheId, aRequest, aParams);
+                                                    aCacheId, aRequest, aParams,
+                                                    streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   nsIInputStream* aRequestBodyStream,
                   const PCacheResponse& aResponse,
@@ -1307,11 +1472,27 @@ Manager::GetListener(ListenerId aListene
   for (uint32_t i = 0; i < mListeners.Length(); ++i) {
     if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
       return mListeners[i];
     }
   }
   return nullptr;
 }
 
+void
+Manager::AddStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.AppendElement(aStreamList);
+}
+
+void
+Manager::RemoveStreamList(StreamList* aStreamList)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aStreamList);
+  mStreamLists.RemoveElement(aStreamList);
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIOutputStream;
@@ -27,25 +28,76 @@ class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
 {
 public:
+  class StreamList;
+
+  class StreamControl : public PCacheStreamControlParent
+  {
+  public:
+    virtual ~StreamControl() { }
+
+    virtual void SetStreamList(StreamList* aStreamList)=0;
+
+    virtual void Close(const nsID& aId)=0;
+    virtual void CloseAll()=0;
+    virtual void Shutdown()=0;
+  };
+
+  class StreamList
+  {
+  public:
+    StreamList(Manager* aManager, Context* aContext, CacheId aCacheId);
+
+    void SetStreamControl(StreamControl* aStreamControl);
+    void RemoveStreamControl(StreamControl* aStreamControl);
+
+    void Activate();
+
+    void Add(const nsID& aId, nsIInputStream* aStream);
+    already_AddRefed<nsIInputStream> Extract(const nsID& aId);
+
+    void NoteClosed(const nsID& aId);
+    void Close(const nsID& aId);
+    void CloseAll();
+
+  private:
+    ~StreamList();
+    struct Entry
+    {
+      nsID mId;
+      nsCOMPtr<nsIInputStream> mStream;
+    };
+    nsRefPtr<Manager> mManager;
+    nsRefPtr<Context> mContext;
+    const CacheId mCacheId;
+    StreamControl* mStreamControl;
+    nsTArray<Entry> mList;
+    bool mActivated;
+
+  public:
+    NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager::StreamList)
+  };
+
   class Listener
   {
   public:
     virtual ~Listener() { }
 
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                              const SavedResponse* aResponse) { }
+                              const SavedResponse* aResponse,
+                              StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
-                             const nsTArray<SavedResponse>& aSavedResponses) { }
+                                 const nsTArray<SavedResponse>& aSavedResponses,
+                                 StreamList* aStreamList) { }
     virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
     virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedRequest>& aSavedRequests) { }
 
     virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
@@ -64,16 +116,17 @@ public:
 
   static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
                                              const nsACString& aBaseDomain);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   uint32_t GetCacheIdRefCount(CacheId aCacheId);
+  void Shutdown();
 
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
@@ -135,20 +188,24 @@ private:
 
   Manager(const nsACString& aOrigin, const nsACString& aBaseDomain);
   ~Manager();
   Context* CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
+  void AddStreamList(StreamList* aStreamList);
+  void RemoveStreamList(StreamList* aStreamList);
+
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
+  nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
   {
     CacheId mCacheId;
     uint32_t mCount;
   };
   nsTArray<CacheIdRefCounter> mCacheIdRefs;
 
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,16 +1,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
+include protocol PCacheStreamControl;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
+include protocol PBlob; // FIXME: bug 792908
+
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
 {
   manager PBackground;
@@ -20,18 +24,20 @@ parent:
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
   Add(RequestId requestId, PCacheRequest request);
   AddAll(RequestId requestId, PCacheRequest[] requests);
   Put(RequestId requestId, PCacheRequest request, PCacheResponse response);
   Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
 
 child:
-  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
-  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
+  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse,
+                nullable PCacheStreamControl aStreamControl);
+  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses,
+                   nullable PCacheStreamControl aStreamControl);
   AddResponse(RequestId requestId, nsresult aRv, PCacheResponse response);
   AddAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
   PutResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
   KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
 
 both:
   __delete__();
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,15 +1,18 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
+
+include protocol PBlob; // FIXME: bug 792908
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
diff --git a/dom/cache/PCacheStreamControl.ipdl b/dom/cache/PCacheStreamControl.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStreamControl.ipdl
@@ -0,0 +1,30 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStreamControl
+{
+  manager PBackground;
+
+parent:
+  NoteClosed(nsID aStreamId);
+
+child:
+  Close(nsID aStreamId);
+  CloseAll();
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,34 +1,49 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PHeaders;
+include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
+using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct PCacheQueryParams
 {
   bool ignoreSearch;
   bool ignoreMethod;
   bool ignoreVary;
   bool prefixMatch;
   bool cacheNameSet;
   nsString cacheName;
 };
 
+struct PCacheReadStream
+{
+  nsID id;
+  OptionalInputStreamParams params;
+  OptionalFileDescriptorSet fds;
+};
+
+union PCacheReadStreamOrVoid
+{
+  void_t;
+  PCacheReadStream;
+};
+
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
@@ -45,16 +60,17 @@ union PCacheRequestOrVoid
 struct PCacheResponse
 {
   ResponseType type;
   nsString url;
   uint32_t status;
   nsCString statusText;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
+  PCacheReadStreamOrVoid body;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.cpp
@@ -0,0 +1,182 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ReadStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/InputStreamParams.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIInputStream.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::OptionalFileDescriptorSet;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream);
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlChild* aControl,
+                   const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  MOZ_ASSERT(aControl);
+
+  if (!aControl || aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  return Create(aControl, aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlChild* aControl,
+                   const PCacheReadStream& aReadStream)
+{
+  MOZ_ASSERT(aControl);
+
+  nsTArray<FileDescriptor> fds;
+  if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetChild* fdSetActor =
+      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  nsCOMPtr<nsIInputStream> stream =
+    DeserializeInputStream(aReadStream.params(), fds);
+
+  if (!stream) {
+    return nullptr;
+  }
+
+  // Currently we expect all cache read streams to be blocking file streams.
+#ifdef DEBUG
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+  MOZ_ASSERT(!asyncStream);
+#endif
+
+  nsRefPtr<ReadStream> ref = new ReadStream(aControl, aReadStream.id(), stream);
+  return ref.forget();
+}
+
+void
+ReadStream::CloseStream()
+{
+  Close();
+}
+
+bool
+ReadStream::MatchId(const nsID& aId)
+{
+  return mId.Equals(aId);
+}
+
+ReadStream::ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
+                       nsIInputStream* aStream)
+  : mControl(static_cast<CacheStreamControlChild*>(aControl))
+  , mId(aId)
+  , mStream(aStream)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mControl);
+  MOZ_ASSERT(mStream);
+
+  mControl->AddListener(this);
+}
+
+ReadStream::~ReadStream()
+{
+  NoteClosed();
+}
+
+void
+ReadStream::NoteClosed()
+{
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+  mControl->NoteClosed(mId);
+  mControl->RemoveListener(this);
+}
+
+NS_IMETHODIMP
+ReadStream::Close()
+{
+  NoteClosed();
+  return mStream->Close();
+}
+
+NS_IMETHODIMP
+ReadStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                         uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mStream->IsNonBlocking(aNonBlockingOut);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ReadStream_h
+#define mozilla_dom_cache_ReadStream_h
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIInputStream.h"
+#include "nsISupportsImpl.h"
+
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+
+class ReadStream : public nsIInputStream
+                 , public CacheStreamControlChild::Listener
+{
+public:
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlChild* aControl,
+         const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlChild* aControl,
+         const PCacheReadStream& aReadStream);
+
+  // CacheStreamControlChild::Listener methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
+
+private:
+  ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
+             nsIInputStream* aStream);
+  virtual ~ReadStream();
+
+  void NoteClosed();
+
+  CacheStreamControlChild* mControl;
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  bool mClosed;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/SavedTypes.h b/dom/cache/SavedTypes.h
--- a/dom/cache/SavedTypes.h
+++ b/dom/cache/SavedTypes.h
@@ -31,17 +31,17 @@ struct SavedRequest
   PCacheRequest mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 struct SavedResponse
 {
-  SavedResponse() : mHasBodyId(false) { }
+  SavedResponse() : mHasBodyId(false) { mValue.body() = void_t(); }
   PCacheResponse mValue;
   bool mHasBodyId;
   nsID mBodyId;
   CacheId mCacheId;
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -138,16 +138,17 @@ TypeUtils::ToPCacheResponse(PCacheRespon
   aOut.type() = aIn.Type();
   aIn.GetUrl(aOut.url());
   aOut.status() = aIn.Status();
   aIn.GetStatusText(aOut.statusText());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
+  aOut.body() = void_t();
 }
 
 // static
 void
 TypeUtils:: ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
@@ -162,17 +163,18 @@ TypeUtils:: ToPCacheQueryParams(PCacheQu
     aOut.cacheName() = aIn.mCacheName.Value();
   } else {
     aOut.cacheName() = NS_LITERAL_STRING("");
   }
 }
 
 // static
 void
-TypeUtils::ToResponse(Response& aOut, const PCacheResponse& aIn)
+TypeUtils::ToResponse(Response& aOut, const PCacheResponse& aIn,
+                      nsIInputStream* aStream)
 {
   // TODO: implement once real Request/Response are available
   NS_WARNING("Not filling in contents of Response returned from Cache.");
 }
 
 // static
 void
 TypeUtils::ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn)
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -4,16 +4,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_TypesUtils_h
 #define mozilla_dom_cache_TypesUtils_h
 
 #include "mozilla/Attributes.h"
 
+class nsIInputStream;
+
 namespace mozilla {
 namespace dom {
 
 class OwningRequestOrScalarValueString;
 struct QueryParams;
 class InternalRequest;
 class Request;
 class RequestOrScalarValueString;
@@ -46,17 +48,17 @@ public:
 
   static void
   ToPCacheResponse(PCacheResponse& aOut, const Response& aIn);
 
   static void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   static void
-  ToResponse(Response& aOut, const PCacheResponse& aIn);
+  ToResponse(Response& aOut, const PCacheResponse& aIn, nsIInputStream* aStream);
 
   static void
   ToInternalRequest(InternalRequest& aOut, const PCacheRequest& aIn);
 
 private:
   TypeUtils() MOZ_DELETE;
   ~TypeUtils() MOZ_DELETE;
 };
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -10,47 +10,54 @@ EXPORTS.mozilla.dom.cache += [
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
+    'CacheStreamControlChild.h',
+    'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'ReadStream.h',
     'SavedTypes.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
+    'CacheStreamControlChild.cpp',
+    'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
+    'ReadStream.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheStorage.ipdl',
+    'PCacheStreamControl.ipdl',
     'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -6,22 +6,25 @@
 
 #include "FileDescriptorSetChild.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/dom/cache/PCacheStorageChild.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::CacheChild;
 using mozilla::dom::cache::PCacheChild;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlChild;
 
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
   nsCString mTestArg;
@@ -189,16 +192,29 @@ bool
 BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
 {
   // The CacheChild actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlChild*
+BackgroundChildImpl::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 // -----------------------------------------------------------------------------
 // MessageChannel/MessagePort API
 // -----------------------------------------------------------------------------
 
 dom::PMessagePortChild*
 BackgroundChildImpl::AllocPMessagePortChild()
 {
   nsRefPtr<dom::MessagePortChild> agent = new dom::MessagePortChild();
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -11,16 +11,17 @@
 template <class> class nsAutoPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheChild;
 class PCacheStorageChild;
+class PCacheStreamControlChild;
 
 } // namespace cache
 namespace indexedDB {
 
 class IDBTransaction;
 
 } // namespace indexedDB
 } // namespace dom
@@ -84,16 +85,22 @@ protected:
   virtual bool
   DeallocPCacheStorageChild(mozilla::dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheChild(mozilla::dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlChild*
+  AllocPCacheStreamControlChild();
+
+  virtual bool
+  DeallocPCacheStreamControlChild(mozilla::dom::cache::PCacheStreamControlChild* aActor);
+
   virtual PMessagePortChild*
   AllocPMessagePortChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortChild(PMessagePortChild* aActor) MOZ_OVERRIDE;
 };
 
 class BackgroundChildImpl::ThreadLocal MOZ_FINAL
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -7,16 +7,17 @@
 #include "FileDescriptorSetParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/dom/MessagePortParent.h"
 #include "mozilla/dom/cache/CacheStorageParent.h"
 #include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
@@ -25,16 +26,17 @@
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
 using namespace mozilla::dom;
 using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::CacheStorageParent;
 using mozilla::dom::cache::PCacheStorageParent;
+using mozilla::dom::cache::PCacheStreamControlParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -239,16 +241,32 @@ bool
 BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
 {
   // The CacheParent actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlParent*
+BackgroundParentImpl::AllocPCacheStreamControlParent()
+{
+  MOZ_CRASH("CacheStreamControlParent actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  // The CacheStreamControlParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
 PMessagePortParent*
 BackgroundParentImpl::AllocPMessagePortParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   return new MessagePortParent();
 }
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -8,16 +8,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
   class PCacheParent;
   class PCacheStorageParent;
+  class PCacheStreamControlParent;
 }
 }
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundParentImpl : public PBackgroundParent
 {
@@ -74,16 +75,22 @@ protected:
   virtual bool
   DeallocPCacheStorageParent(mozilla::dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheParent(mozilla::dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlParent*
+  AllocPCacheStreamControlParent();
+
+  virtual bool
+  DeallocPCacheStreamControlParent(mozilla::dom::cache::PCacheStreamControlParent* aActor);
+
   virtual PMessagePortParent*
   AllocPMessagePortParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortParent(PMessagePortParent* aActor) MOZ_OVERRIDE;
 };
 
 } // namespace ipc
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,18 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PFileDescriptorSet;
+include protocol PCache;
 include protocol PCacheStorage;
-include protocol PCache;
+include protocol PCacheStreamControl;
 include protocol PMessagePort;
 
 include DOMTypes;
 
 using struct mozilla::void_t
   from "ipc/IPCMessageUtils.h";
 using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
@@ -32,18 +33,19 @@ union OptionalWindowId
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
   manages PBackgroundTest;
   manages PBlob;
   manages PFileDescriptorSet;
+  manages PCache;
   manages PCacheStorage;
-  manages PCache;
+  manages PCacheStreamControl;
   manages PMessagePort;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(OptionalWindowId optionalWindowId);
 
@@ -53,12 +55,13 @@ parent:
 
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 
 child:
   PCache();
+  PCacheStreamControl();
 };
 
 } // namespace ipc
 } // namespace mozilla
