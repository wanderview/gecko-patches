# HG changeset patch
# Parent 9f07ce148db52147baf9c394b17609968f8e9d3f
# User Ben Kelly <ben@wanderview.com>
Return file stream contained in an IPC stream controlled wrapper.

diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheChild.h"
 
 #include "mozilla/dom/cache/CacheChildListener.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 CacheChild::CacheChild()
   : mListener(nullptr)
 {
@@ -104,11 +105,24 @@ bool
 CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                              const nsTArray<PCacheRequest>& requests)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvKeysResponse(requestId, aRv, requests);
   return true;
 }
 
+PCacheStreamControlChild*
+CacheChild::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+CacheChild::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -45,15 +45,21 @@ public:
   RecvPutResponse(const RequestId& requestId, const nsresult& aRv,
                   const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                    const nsTArray<PCacheRequest>& requests) MOZ_OVERRIDE;
+
+  virtual PCacheStreamControlChild*
+  AllocPCacheStreamControlChild();
+
+  virtual bool
+  DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor);
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheChild_h
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -120,16 +120,28 @@ CacheParent::RecvKeys(const RequestId& a
                       const PCacheRequestOrVoid& aRequest,
                       const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
   mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
+PCacheStreamControlParent*
+CacheParent::AllocPCacheStreamControlParent()
+{
+  return nullptr;
+}
+
+bool
+CacheParent::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  return false;
+}
+
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -49,16 +49,22 @@ public:
           const PCacheResponse& aResponse) MOZ_OVERRIDE;
   virtual bool
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
+  virtual PCacheStreamControlParent*
+  AllocPCacheStreamControlParent();
+
+  virtual bool
+  DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor);
+
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                    const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorageChild.h"
 
 #include "mozilla/dom/cache/CacheStorageChildListener.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 CacheStorageChild::CacheStorageChild(CacheStorageChildListener& aListener)
   : mListener(&aListener)
 {
@@ -87,16 +88,29 @@ CacheStorageChild::RecvKeysResponse(cons
                                     const nsresult& aRv,
                                     const nsTArray<nsString>& aKeys)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvKeysResponse(aRequestId, aRv, aKeys);
   return true;
 }
 
+PCacheStreamControlChild*
+CacheStorageChild::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+CacheStorageChild::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 void
 CacheStorageChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
 } // namespace cache
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -37,16 +37,19 @@ public:
                                   PCacheChild* aActor) MOZ_OVERRIDE;
   virtual bool RecvDeleteResponse(const cache::RequestId& aRequestId,
                                   const nsresult& aRv,
                                   const bool& aResult) MOZ_OVERRIDE;
   virtual bool RecvKeysResponse(const cache::RequestId& aRequestId,
                                 const nsresult& aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
+  virtual PCacheStreamControlChild* AllocPCacheStreamControlChild();
+  virtual bool DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor);
+
   void ClearListener();
 private:
   CacheStorageChildListener* mListener;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -85,16 +85,28 @@ CacheStorageParent::RecvDelete(const Req
 
 bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
   mManager->StorageKeys(this, aRequestId, mNamespace);
   return true;
 }
 
+PCacheStreamControlParent*
+CacheStorageParent::AllocPCacheStreamControlParent()
+{
+  return nullptr;
+}
+
+bool
+CacheStorageParent::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  return false;
+}
+
 void
 CacheStorageParent::OnStorageMatch(RequestId aRequestId, nsresult aRv,
                                    const SavedResponse* aSavedResponse)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -35,16 +35,19 @@ public:
   virtual bool RecvHas(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvCreate(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvDelete(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
+  virtual PCacheStreamControlParent* AllocPCacheStreamControlParent();
+  virtual bool DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor);
+
   // Manager::Listener methods
   virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse) MOZ_OVERRIDE;
   virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound,
                             CacheId aCacheId) MOZ_OVERRIDE;
   virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound) MOZ_OVERRIDE;
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+void
+CacheStreamControlChild::AddListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlChild::RemoveListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlChild::NoteClosed(const nsID& aId)
+{
+  unused << SendNoteClosed(aId);
+}
+
+void
+CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  RecvCloseAll();
+}
+
+bool
+CacheStreamControlChild::RecvClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+  return true;
+}
+
+bool
+CacheStreamControlChild::RecvCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlChild_h
+#define mozilla_dom_cache_CacheStreamControlChild_h
+
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlChild : public PCacheStreamControlChild
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void CloseStream()=0;
+    virtual bool MatchId(const nsID& aId)=0;
+  };
+
+  void AddListener(Listener* aListener);
+  void RemoveListener(Listener* aListener);
+
+  void NoteClosed(const nsID& aId);
+
+  // PCacheStreamControlChild methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
+  virtual bool RecvCloseAll() MOZ_OVERRIDE;
+
+private:
+  nsTArray<Listener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,37 +1,41 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
+include protocol PCacheStreamControl;
 include PCacheTypes;
 
 include protocol PBlob; // FIXME: bug 792908
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
 {
   manager PBackground;
+  manages PCacheStreamControl;
 
 parent:
   Match(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
   Add(RequestId requestId, PCacheRequest request);
   AddAll(RequestId requestId, PCacheRequest[] requests);
   Put(RequestId requestId, PCacheRequest request, PCacheResponse response);
   Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
 
 child:
+  PCacheStreamControl();
+
   MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
   MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
   AddResponse(RequestId requestId, nsresult aRv, PCacheResponse response);
   AddAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
   PutResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
   KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
 
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,38 +1,42 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
+include protocol PCacheStreamControl;
 include PCacheTypes;
 
 include protocol PBlob; // FIXME: bug 792908
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
 {
   manager PBackground;
+  manages PCacheStreamControl;
 
 parent:
   Match(RequestId aRequestId, PCacheRequest aRequest,
         PCacheQueryParams aParams);
   Get(RequestId aRequestId, nsString aKey);
   Has(RequestId aRequestId, nsString aKey);
   Create(RequestId aRequestId, nsString aKey);
   Delete(RequestId aRequestId, nsString aKey);
   Keys(RequestId aRequestId);
 
 child:
+  PCacheStreamControl();
+
   MatchResponse(RequestId aRequestId, nsresult aRv,
                 PCacheResponseOrVoid aResponseOrVoid);
   GetResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   HasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   CreateResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
 
diff --git a/dom/cache/PCacheStreamControl.ipdl b/dom/cache/PCacheStreamControl.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStreamControl.ipdl
@@ -0,0 +1,31 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PCache;
+include protocol PCacheStorage;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStreamControl
+{
+  manager PCache or PCacheStorage;
+
+parent:
+  NoteClosed(nsID aStreamId);
+
+child:
+  Close(nsID aStreamId);
+  CloseAll();
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -5,16 +5,17 @@
 include PHeaders;
 include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
+using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct PCacheQueryParams
 {
   bool ignoreSearch;
@@ -58,11 +59,24 @@ struct PCacheResponse
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
+struct PCacheReadStream
+{
+  nsID id;
+  OptionalInputStreamParams params;
+  // TODO: OptionalFileDescriptorSet fds;
+};
+
+union PCacheReadStreamOrVoid
+{
+  void_t;
+  PCacheReadStream;
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.cpp
@@ -0,0 +1,178 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ReadStream.h"
+
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIInputStream.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ipc::FileDescriptor;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream);
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(CacheStreamControlChild* aControl,
+                   const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  MOZ_ASSERT(aControl);
+
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  return Create(aControl, aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(CacheStreamControlChild* aControl,
+                   const PCacheReadStream& aReadStream)
+{
+  MOZ_ASSERT(aControl);
+
+  nsTArray<FileDescriptor> fds;
+  /* TODO: read out file descriptors
+  if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetChild* fdSetActor =
+      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDesciptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete(fdSetActor);
+  }
+  */
+
+  nsCOMPtr<nsIInputStream> stream =
+    DeserializeInputStream(aReadStream.params(), fds);
+
+  if (!stream) {
+    return nullptr;
+  }
+
+  // Currently we expect all cache read streams to be blocking file streams.
+#ifdef DEBUG
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+  MOZ_ASSERT(!asyncStream);
+#endif
+
+  nsRefPtr<ReadStream> ref = new ReadStream(aControl, aReadStream.id(), stream);
+  return ref.forget();
+}
+
+void
+ReadStream::CloseStream()
+{
+  Close();
+}
+
+bool
+ReadStream::MatchId(const nsID& aId)
+{
+  return mId.Equals(aId);
+}
+
+ReadStream::ReadStream(CacheStreamControlChild* aControl, const nsID& aId,
+                       nsIInputStream* aStream)
+  : mControl(aControl)
+  , mId(aId)
+  , mStream(aStream)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mControl);
+  MOZ_ASSERT(mStream);
+
+  mControl->AddListener(this);
+}
+
+ReadStream::~ReadStream()
+{
+  NoteClosed();
+}
+
+void
+ReadStream::NoteClosed()
+{
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+  mControl->NoteClosed(mId);
+  mControl->RemoveListener(this);
+}
+
+NS_IMETHODIMP
+ReadStream::Close()
+{
+  NoteClosed();
+  return mStream->Close();
+}
+
+NS_IMETHODIMP
+ReadStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                         uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mStream->IsNonBlocking(aNonBlockingOut);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ReadStream_h
+#define mozilla_dom_cache_ReadStream_h
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIInputStream.h"
+#include "nsISupportsImpl.h"
+
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+
+class ReadStream : public nsIInputStream
+                 , public CacheStreamControlChild::Listener
+{
+public:
+  static already_AddRefed<ReadStream>
+  Create(CacheStreamControlChild* aControl,
+         const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+
+  static already_AddRefed<ReadStream>
+  Create(CacheStreamControlChild* aControl,
+         const PCacheReadStream& aReadStream);
+
+  // CacheStreamControlChild::Listener methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
+
+private:
+  ReadStream(CacheStreamControlChild* aControl, const nsID& aId,
+             nsIInputStream* aStream);
+  virtual ~ReadStream();
+
+  void NoteClosed();
+
+  CacheStreamControlChild* mControl;
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  bool mClosed;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -10,47 +10,52 @@ EXPORTS.mozilla.dom.cache += [
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
+    'CacheStreamControlChild.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'ReadStream.h',
     'SavedTypes.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
+    'CacheStreamControlChild.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
+    'ReadStream.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheStorage.ipdl',
+    'PCacheStreamControl.ipdl',
     'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
