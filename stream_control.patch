# HG changeset patch
# Parent b841f71aaae7866f980d94727f74a1014c4b058f
# User Ben Kelly <ben@wanderview.com>
Return file stream contained in an IPC stream controlled wrapper.

diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -3,28 +3,32 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsCOMPtr.h"
 
 // TODO: remove testing only headers
 #include "../../dom/filehandle/MemoryStreams.h"
 #include "nsStringStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
+using mozilla::ipc::PFileDescriptorSetParent;
 
 CacheParent::CacheParent(const nsACString& aOrigin,
                          const nsACString& aBaseDomain,
                          CacheId aCacheId)
   : mCacheId(aCacheId)
   , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
   MOZ_ASSERT(mManager);
@@ -45,17 +49,20 @@ CacheParent::ActorDestroy(ActorDestroyRe
   mManager = nullptr;
 }
 
 bool
 CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams)
 {
   MOZ_ASSERT(mManager);
-  mManager->CacheMatch(this, aRequestId, mCacheId, aRequest, aParams);
+  // TODO: implement real stream control
+  Manager::StreamControl* streamControl = nullptr;
+  mManager->CacheMatch(this, streamControl, aRequestId, mCacheId, aRequest,
+                       aParams);
   return true;
 }
 
 bool
 CacheParent::RecvMatchAll(const RequestId& aRequestId,
                           const PCacheRequestOrVoid& aRequest,
                           const PCacheQueryParams& aParams)
 {
@@ -122,39 +129,59 @@ CacheParent::RecvKeys(const RequestId& a
 {
   MOZ_ASSERT(mManager);
   mManager->CacheKeys(this, aRequestId, mCacheId, aRequest, aParams);
   return true;
 }
 
 void
 CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                          const SavedResponse* aSavedResponse)
+                          const SavedResponse* aSavedResponse,
+                          Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
-  if (NS_FAILED(aRv) || !aSavedResponse) {
+  if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
     responseOrVoid = void_t();
     unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
+    responseOrVoid.get_PCacheResponse().body() = void_t();
     unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
-  // TODO: remove stream test code
-  nsCOMPtr<nsIOutputStream> stream = MemoryOutputStream::Create(4096);
+  PCacheReadStream readStream;
+  nsTArray<FileDescriptor> fds;
 
-  mManager->CacheReadBody(mCacheId, aSavedResponse->mBodyId, stream);
+  readStream.id() = aSavedResponse->mBodyId;
+  nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(readStream.id());
+  SerializeInputStream(stream, readStream.params(), fds);
+
+  PFileDescriptorSetParent* fdSet = nullptr;
+  if (!fds.IsEmpty()) {
+    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+  }
+
+  if (fdSet) {
+    readStream.fds() = fdSet;
+  } else {
+    readStream.fds() = void_t();
+  }
+
   responseOrVoid = aSavedResponse->mValue;
+  responseOrVoid.get_PCacheResponse().body() = readStream;
   unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedResponse>& aSavedResponses)
 {
   nsTArray<PCacheResponse> responses;
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -51,17 +51,18 @@ public:
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                            const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
+                            const SavedResponse* aSavedResponse,
+                            Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                    const nsTArray<SavedResponse>& aSavedResponses) MOZ_OVERRIDE;
   virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                           const SavedResponse* aSavedResponse) MOZ_OVERRIDE;
   virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                              bool aSuccess) MOZ_OVERRIDE;
   virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                      const nsTArray<SavedRequest>& aSavedRequests) MOZ_OVERRIDE;
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+
+#include "mozilla/unused.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+
+void
+CacheStreamControlChild::AddListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlChild::RemoveListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+CacheStreamControlChild::NoteClosed(const nsID& aId)
+{
+  unused << SendNoteClosed(aId);
+}
+
+void
+CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  RecvCloseAll();
+}
+
+bool
+CacheStreamControlChild::RecvClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+  return true;
+}
+
+bool
+CacheStreamControlChild::RecvCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<Listener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlChild.h
@@ -0,0 +1,45 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlChild_h
+#define mozilla_dom_cache_CacheStreamControlChild_h
+
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlChild : public PCacheStreamControlChild
+{
+public:
+  class Listener
+  {
+  public:
+    virtual void CloseStream()=0;
+    virtual bool MatchId(const nsID& aId)=0;
+  };
+
+  void AddListener(Listener* aListener);
+  void RemoveListener(Listener* aListener);
+
+  void NoteClosed(const nsID& aId);
+
+  // PCacheStreamControlChild methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
+  virtual bool RecvCloseAll() MOZ_OVERRIDE;
+
+private:
+  nsTArray<Listener*> mListeners;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -0,0 +1,26 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+void
+CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
+{
+}
+
+bool
+CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
+{
+  return true;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStreamControlParent.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_CacheStreamControlParent_h
+#define mozilla_dom_cache_CacheStreamControlParent_h
+
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class CacheStreamControlParent : public PCacheStreamControlParent
+{
+public:
+  // PCacheStreamControlParent methods
+  virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
+  virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_CacheStreamControlParent_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -294,16 +294,45 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   rv = tmpFile->RenameTo(finalDir, finalFileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
+FileUtils::BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+                    nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+                    nsIInputStream** aStreamOut)
+{
+  MOZ_ASSERT(aBaseDir);
+  MOZ_ASSERT(aStreamOut);
+
+  nsCOMPtr<nsIFile> finalFile;
+  nsresult rv = BodyIdToFile(aBaseDir, aCacheId, aId, BODY_FILE_FINAL,
+                    getter_AddRefs(finalFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = finalFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+  nsCOMPtr<nsIInputStream> fileStream =
+    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aBaseDomain, aOrigin,
+                            finalFile);
+  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
+
+  fileStream.forget(aStreamOut);
+
+  return rv;
+}
+
+// static
+nsresult
 FileUtils::BodyStartReadStream(const nsACString& aOrigin,
                                const nsACString& aBaseDomain,
                                nsIFile* aBaseDir, CacheId aCacheId,
                                const nsID& aId, nsIOutputStream* aDest,
                                void* aClosure,
                                nsAsyncCopyCallbackFun aCallback,
                                nsISupports** aCopyContextOut)
 {
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -47,16 +47,21 @@ public:
   static void
   BodyCancelWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                   nsISupports* aCopyContext);
 
   static nsresult
   BodyFinalizeWrite(nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId);
 
   static nsresult
+  BodyOpen(const nsACString& aOrigin, const nsACString& aBaseDomain,
+           nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
+           nsIInputStream** aStreamOut);
+
+  static nsresult
   BodyStartReadStream(const nsACString& aOrigin, const nsACString& aBaseDomain,
                       nsIFile* aBaseDir, CacheId aCacheId, const nsID& aId,
                       nsIOutputStream* aDest, void* aClosure,
                       nsAsyncCopyCallbackFun aCallback,
                       nsISupports** aCopyContextOut);
 
   static void BodyCancelRead(nsISupports* aCopyContext);
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -236,52 +236,71 @@ private:
 };
 
 class Manager::CacheMatchAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAction(Manager* aManager, ListenerId aListenerId,
                    RequestId aRequestId, CacheId aCacheId,
                    const PCacheRequest& aRequest,
-                   const PCacheQueryParams& aParams)
+                   const PCacheQueryParams& aParams,
+                   StreamList* aStreamList)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
+    , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
   RunSyncWithDBOnTarget(nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
-    return DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
-                                &mFoundResponse, &mResponse);
+    nsresult rv = DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
+                                       &mFoundResponse, &mResponse);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!mFoundResponse || !mResponse.mHasBodyId) {
+      return rv;
+    }
+
+    nsCOMPtr<nsIInputStream> stream;
+    rv = FileUtils::BodyOpen(mManager->Origin(), mManager->BaseDomain(),
+                             aDBDir, mCacheId, mResponse.mBodyId,
+                             getter_AddRefs(stream));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
+
+    mStreamList->Add(mResponse.mBodyId, stream);
+
+    return rv;
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
     if (!mFoundResponse) {
-      aListener->OnCacheMatch(mRequestId, aRv, nullptr);
+      aListener->OnCacheMatch(mRequestId, aRv, nullptr, nullptr);
     } else {
-      aListener->OnCacheMatch(mRequestId, aRv, &mResponse);
+      aListener->OnCacheMatch(mRequestId, aRv, &mResponse, mStreamList);
     }
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 protected:
   virtual ~CacheMatchAction() { }
   const CacheId mCacheId;
   const PCacheRequest mRequest;
   const PCacheQueryParams mParams;
+  nsRefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
 };
 
 class Manager::CacheMatchAllAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
@@ -1021,16 +1040,98 @@ public:
   }
 
 private:
   virtual ~StorageKeysAction() { }
   const Namespace mNamespace;
   nsTArray<nsString> mKeys;
 };
 
+Manager::StreamList::StreamList(Manager* aManager, Context* aContext,
+                                CacheId aCacheId,
+                                StreamControl* aStreamControl)
+  : mManager(aManager)
+  , mContext(aContext)
+  , mCacheId(aCacheId)
+  , mStreamControl(aStreamControl)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mStreamControl);
+}
+
+void
+Manager::StreamList::RemoveStreamControl(StreamControl* aStreamControl)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(mStreamControl);
+  mStreamControl = nullptr;
+}
+
+void
+Manager::StreamList::Add(const nsID& aId, nsIInputStream* aStream)
+{
+  MOZ_ASSERT(aStream);
+  Entry* entry = mList.AppendElement();
+  entry->mId = aId;
+  entry->mStream = aStream;
+}
+
+already_AddRefed<nsIInputStream>
+Manager::StreamList::Extract(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      return mList[i].mStream.forget();
+    }
+  }
+  return nullptr;
+}
+
+void
+Manager::StreamList::NotifyClosed(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (mList[i].mId == aId) {
+      mList.RemoveElementAt(i);
+      break;
+    }
+  }
+
+  if (mList.IsEmpty() && mStreamControl) {
+    mStreamControl->Shutdown();
+  }
+}
+
+void
+Manager::StreamList::Close(const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->Close(aId);
+  }
+}
+
+void
+Manager::StreamList::CloseAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  if (mStreamControl) {
+    mStreamControl->CloseAll();
+  }
+}
+
+Manager::StreamList::~StreamList()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager::StreamList);
+  MOZ_ASSERT(!mStreamControl);
+}
+
 // static
 already_AddRefed<Manager>
 Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
   return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
 }
 
@@ -1085,25 +1186,30 @@ Manager::GetCacheIdRefCount(CacheId aCac
       MOZ_ASSERT(mCacheIdRefs[i].mCount > 0);
       return mCacheIdRefs[i].mCount;
     }
   }
   return 0;
 }
 
 void
-Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+Manager::CacheMatch(Listener* aListener, StreamControl* aStreamControl,
+                    RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
+  MOZ_ASSERT(aStreamControl);
+  nsRefPtr<StreamList> streamList = new StreamList(this, CurrentContext(),
+                                                   aCacheId, aStreamControl);
   ListenerId listenerId = SaveListener(aListener);
   nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
-                                                 aCacheId, aRequest, aParams);
+                                                 aCacheId, aRequest, aParams,
+                                                 streamList);
   CurrentContext()->Dispatch(mIOThread, action);
 }
 
 void
 Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
                        CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
                        const PCacheQueryParams& aParams)
 {
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -27,23 +27,66 @@ class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
 {
 public:
+  class StreamControl
+  {
+  public:
+    virtual ~StreamControl() { }
+
+    virtual void Close(const nsID& aId)=0;
+    virtual void CloseAll()=0;
+    virtual void Shutdown()=0;
+  };
+
+  class StreamList
+  {
+  public:
+    StreamList(Manager* aManager, Context* aContext, CacheId aCacheId,
+               StreamControl* aStreamControl);
+
+    void RemoveStreamControl(StreamControl* aStreamControl);
+
+    void Add(const nsID& aId, nsIInputStream* aStream);
+    already_AddRefed<nsIInputStream> Extract(const nsID& aId);
+
+    void NotifyClosed(const nsID& aId);
+    void Close(const nsID& aId);
+    void CloseAll();
+
+  private:
+    ~StreamList();
+    struct Entry
+    {
+      nsID mId;
+      nsCOMPtr<nsIInputStream> mStream;
+    };
+    nsRefPtr<Manager> mManager;
+    nsRefPtr<Context> mContext;
+    const CacheId mCacheId;
+    StreamControl* mStreamControl;
+    nsTArray<Entry> mList;
+
+  public:
+    NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager::StreamList)
+  };
+
   class Listener
   {
   public:
     virtual ~Listener() { }
 
     virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
-                              const SavedResponse* aResponse) { }
+                              const SavedResponse* aResponse,
+                              StreamList* aStreamList) { }
     virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedResponse>& aSavedResponses) { }
     virtual void OnCachePut(RequestId aRequestId, nsresult aRv,
                             const SavedResponse* aSavedResponse) { }
     virtual void OnCacheDelete(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) { }
     virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedRequest>& aSavedRequests) { }
@@ -66,17 +109,18 @@ public:
                                              const nsACString& aBaseDomain);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   uint32_t GetCacheIdRefCount(CacheId aCacheId);
 
   // TODO: consider moving CacheId up in the argument lists below
-  void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+  void CacheMatch(Listener* aListener, StreamControl* aStreamControl,
+                  RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
   void CachePut(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                 const PCacheRequest& aRequest,
                 nsIInputStream* aRequestBodyStream,
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,16 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
+include protocol PBlob; // FIXME: bug 792908
+
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
 {
   manager PBackground;
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,15 +1,18 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
 include PCacheTypes;
+include protocol PFileDescriptorSet;
+
+include protocol PBlob; // FIXME: bug 792908
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
diff --git a/dom/cache/PCacheStreamControl.ipdl b/dom/cache/PCacheStreamControl.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/cache/PCacheStreamControl.ipdl
@@ -0,0 +1,30 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+protocol PCacheStreamControl
+{
+  manager PBackground;
+
+parent:
+  NoteClosed(nsID aStreamId);
+
+child:
+  Close(nsID aStreamId);
+  CloseAll();
+
+both:
+  __delete__();
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,34 +1,49 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PHeaders;
+include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
+using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct PCacheQueryParams
 {
   bool ignoreSearch;
   bool ignoreMethod;
   bool ignoreVary;
   bool prefixMatch;
   bool cacheNameSet;
   nsString cacheName;
 };
 
+struct PCacheReadStream
+{
+  nsID id;
+  OptionalInputStreamParams params;
+  OptionalFileDescriptorSet fds;
+};
+
+union PCacheReadStreamOrVoid
+{
+  void_t;
+  PCacheReadStream;
+};
+
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
@@ -45,16 +60,17 @@ union PCacheRequestOrVoid
 struct PCacheResponse
 {
   ResponseType type;
   nsString url;
   uint32_t status;
   nsCString statusText;
   PHeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
+  PCacheReadStreamOrVoid body;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.cpp
@@ -0,0 +1,182 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ReadStream.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/dom/cache/PCacheTypes.h"
+#include "mozilla/ipc/FileDescriptor.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/InputStreamParams.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIInputStream.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::unused;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::OptionalFileDescriptorSet;
+
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream);
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(CacheStreamControlChild* aControl,
+                   const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  MOZ_ASSERT(aControl);
+
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return nullptr;
+  }
+
+  return Create(aControl, aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(CacheStreamControlChild* aControl,
+                   const PCacheReadStream& aReadStream)
+{
+  MOZ_ASSERT(aControl);
+
+  nsTArray<FileDescriptor> fds;
+  if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    FileDescriptorSetChild* fdSetActor =
+      static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  nsCOMPtr<nsIInputStream> stream =
+    DeserializeInputStream(aReadStream.params(), fds);
+
+  if (!stream) {
+    return nullptr;
+  }
+
+  // Currently we expect all cache read streams to be blocking file streams.
+#ifdef DEBUG
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+  MOZ_ASSERT(!asyncStream);
+#endif
+
+  nsRefPtr<ReadStream> ref = new ReadStream(aControl, aReadStream.id(), stream);
+  return ref.forget();
+}
+
+void
+ReadStream::CloseStream()
+{
+  Close();
+}
+
+bool
+ReadStream::MatchId(const nsID& aId)
+{
+  return mId.Equals(aId);
+}
+
+ReadStream::ReadStream(CacheStreamControlChild* aControl, const nsID& aId,
+                       nsIInputStream* aStream)
+  : mControl(aControl)
+  , mId(aId)
+  , mStream(aStream)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mControl);
+  MOZ_ASSERT(mStream);
+
+  mControl->AddListener(this);
+}
+
+ReadStream::~ReadStream()
+{
+  NoteClosed();
+}
+
+void
+ReadStream::NoteClosed()
+{
+  if (mClosed) {
+    return;
+  }
+
+  mClosed = true;
+  mControl->NoteClosed(mId);
+  mControl->RemoveListener(this);
+}
+
+NS_IMETHODIMP
+ReadStream::Close()
+{
+  NoteClosed();
+  return mStream->Close();
+}
+
+NS_IMETHODIMP
+ReadStream::Available(uint64_t* aNumAvailableOut)
+{
+  nsresult rv = mStream->Available(aNumAvailableOut);
+
+  if (NS_FAILED(rv)) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::Read(char* aBuf, uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->Read(aBuf, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK) ||
+      *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                         uint32_t aCount, uint32_t* aNumReadOut)
+{
+  MOZ_ASSERT(aNumReadOut);
+
+  nsresult rv = mStream->ReadSegments(aWriter, aClosure, aCount, aNumReadOut);
+
+  if ((NS_FAILED(rv) && rv != NS_BASE_STREAM_WOULD_BLOCK &&
+                        rv != NS_ERROR_NOT_IMPLEMENTED) || *aNumReadOut == 0) {
+    NoteClosed();
+  }
+
+  return rv;
+}
+
+NS_IMETHODIMP
+ReadStream::IsNonBlocking(bool* aNonBlockingOut)
+{
+  return mStream->IsNonBlocking(aNonBlockingOut);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ReadStream.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ReadStream_h
+#define mozilla_dom_cache_ReadStream_h
+
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "nsCOMPtr.h"
+#include "nsID.h"
+#include "nsIInputStream.h"
+#include "nsISupportsImpl.h"
+
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheReadStream;
+class PCacheReadStreamOrVoid;
+
+class ReadStream : public nsIInputStream
+                 , public CacheStreamControlChild::Listener
+{
+public:
+  static already_AddRefed<ReadStream>
+  Create(CacheStreamControlChild* aControl,
+         const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+
+  static already_AddRefed<ReadStream>
+  Create(CacheStreamControlChild* aControl,
+         const PCacheReadStream& aReadStream);
+
+  // CacheStreamControlChild::Listener methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
+
+private:
+  ReadStream(CacheStreamControlChild* aControl, const nsID& aId,
+             nsIInputStream* aStream);
+  virtual ~ReadStream();
+
+  void NoteClosed();
+
+  CacheStreamControlChild* mControl;
+  const nsID mId;
+  nsCOMPtr<nsIInputStream> mStream;
+  bool mClosed;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -10,47 +10,54 @@ EXPORTS.mozilla.dom.cache += [
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
+    'CacheStreamControlChild.h',
+    'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'ReadStream.h',
     'SavedTypes.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
     'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
+    'CacheStreamControlChild.cpp',
+    'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
+    'ReadStream.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheStorage.ipdl',
+    'PCacheStreamControl.ipdl',
     'PCacheTypes.ipdlh',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
     '../workers',
 ]
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -6,22 +6,25 @@
 
 #include "FileDescriptorSetChild.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/dom/cache/PCacheStorageChild.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::CacheChild;
 using mozilla::dom::cache::PCacheChild;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlChild;
 
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
   nsCString mTestArg;
@@ -189,16 +192,29 @@ bool
 BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
 {
   // The CacheChild actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlChild*
+BackgroundChildImpl::AllocPCacheStreamControlChild()
+{
+  return new CacheStreamControlChild();
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
 // -----------------------------------------------------------------------------
 // MessageChannel/MessagePort API
 // -----------------------------------------------------------------------------
 
 dom::PMessagePortChild*
 BackgroundChildImpl::AllocPMessagePortChild()
 {
   nsRefPtr<dom::MessagePortChild> agent = new dom::MessagePortChild();
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -11,16 +11,17 @@
 template <class> class nsAutoPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheChild;
 class PCacheStorageChild;
+class PCacheStreamControlChild;
 
 } // namespace cache
 namespace indexedDB {
 
 class IDBTransaction;
 
 } // namespace indexedDB
 } // namespace dom
@@ -84,16 +85,22 @@ protected:
   virtual bool
   DeallocPCacheStorageChild(mozilla::dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheChild(mozilla::dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlChild*
+  AllocPCacheStreamControlChild();
+
+  virtual bool
+  DeallocPCacheStreamControlChild(mozilla::dom::cache::PCacheStreamControlChild* aActor);
+
   virtual PMessagePortChild*
   AllocPMessagePortChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortChild(PMessagePortChild* aActor) MOZ_OVERRIDE;
 };
 
 class BackgroundChildImpl::ThreadLocal MOZ_FINAL
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -7,16 +7,17 @@
 #include "FileDescriptorSetParent.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/dom/MessagePortParent.h"
 #include "mozilla/dom/cache/CacheStorageParent.h"
 #include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
@@ -25,16 +26,17 @@
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
 using namespace mozilla::dom;
 using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::CacheStorageParent;
 using mozilla::dom::cache::PCacheStorageParent;
+using mozilla::dom::cache::PCacheStreamControlParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -239,16 +241,32 @@ bool
 BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
 {
   // The CacheParent actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+PCacheStreamControlParent*
+BackgroundParentImpl::AllocPCacheStreamControlParent()
+{
+  MOZ_CRASH("CacheStreamControlParent actor must be provided to PBackground manager");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
+{
+  // The CacheStreamControlParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
+  delete aActor;
+  return true;
+}
+
 PMessagePortParent*
 BackgroundParentImpl::AllocPMessagePortParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   return new MessagePortParent();
 }
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -8,16 +8,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
   class PCacheParent;
   class PCacheStorageParent;
+  class PCacheStreamControlParent;
 }
 }
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundParentImpl : public PBackgroundParent
 {
@@ -74,16 +75,22 @@ protected:
   virtual bool
   DeallocPCacheStorageParent(mozilla::dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheParent(mozilla::dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
 
+  virtual mozilla::dom::cache::PCacheStreamControlParent*
+  AllocPCacheStreamControlParent();
+
+  virtual bool
+  DeallocPCacheStreamControlParent(mozilla::dom::cache::PCacheStreamControlParent* aActor);
+
   virtual PMessagePortParent*
   AllocPMessagePortParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortParent(PMessagePortParent* aActor) MOZ_OVERRIDE;
 };
 
 } // namespace ipc
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,18 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PFileDescriptorSet;
+include protocol PCache;
 include protocol PCacheStorage;
-include protocol PCache;
+include protocol PCacheStreamControl;
 include protocol PMessagePort;
 
 include DOMTypes;
 
 using struct mozilla::void_t
   from "ipc/IPCMessageUtils.h";
 using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
@@ -32,18 +33,19 @@ union OptionalWindowId
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
   manages PBackgroundTest;
   manages PBlob;
   manages PFileDescriptorSet;
+  manages PCache;
   manages PCacheStorage;
-  manages PCache;
+  manages PCacheStreamControl;
   manages PMessagePort;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(OptionalWindowId optionalWindowId);
 
@@ -53,12 +55,13 @@ parent:
 
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 
 child:
   PCache();
+  PCacheStreamControl();
 };
 
 } // namespace ipc
 } // namespace mozilla
