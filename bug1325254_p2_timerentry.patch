# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8ad957276880d0e34c6d92cf1b2b2d615601d1d4
Bug 1325254 P2 Make TimerThread list store an entry struct and just drop nsTimerImpl ref on cancel. r=froydnj

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -358,17 +358,17 @@ nsresult
 TimerThread::Shutdown()
 {
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown begin\n"));
 
   if (!mThread) {
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-  nsTArray<RefPtr<nsTimerImpl>> timers;
+  nsTArray<Entry> timers;
   {
     // lock scope
     MonitorAutoLock lock(mMonitor);
 
     mShutdown = true;
 
     // notify the cond var so that Run() can return
     if (mWaiting) {
@@ -382,18 +382,20 @@ TimerThread::Shutdown()
     // might potentially call some code reentering the same lock
     // that leads to unexpected behavior or deadlock.
     // See bug 422472.
     mTimers.SwapElements(timers);
   }
 
   uint32_t timersCount = timers.Length();
   for (uint32_t i = 0; i < timersCount; i++) {
-    RefPtr<nsTimerImpl> timer = timers[i].forget();
-    timer->ReleaseCallback();
+    RefPtr<nsTimerImpl> timer = timers[i].mTimerImpl.forget();
+    if (timer) {
+      timer->ReleaseCallback();
+    }
   }
 
   mThread->Shutdown();    // wait for the thread to die
 
   nsTimerEvent::Shutdown();
 
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown end\n"));
   return NS_OK;
@@ -456,29 +458,34 @@ TimerThread::Run()
         milliseconds = ChaosMode::randomUint32LessThan(200);
       }
       waitFor = PR_MillisecondsToInterval(milliseconds);
     } else {
       waitFor = PR_INTERVAL_NO_TIMEOUT;
       TimeStamp now = TimeStamp::Now();
       nsTimerImpl* timer = nullptr;
 
+      // skip any canceled timers
+      while(!mTimers.IsEmpty() && !mTimers[0].mTimerImpl) {
+        mTimers.RemoveElementAt(0);
+      }
+
       if (!mTimers.IsEmpty()) {
-        timer = mTimers[0];
+        timer = mTimers[0].mTimerImpl;
 
         if (now >= timer->mTimeout || forceRunThisTimer) {
     next:
           // NB: AddRef before the Release under RemoveTimerInternal to avoid
           // mRefCnt passing through zero, in case all other refs than the one
           // from mTimers have gone away (the last non-mTimers[i]-ref's Release
           // must be racing with us, blocked in gThread->RemoveTimer waiting
           // for TimerThread::mMonitor, under nsTimerImpl::Release.
 
           RefPtr<nsTimerImpl> timerRef(timer);
-          RemoveTimerInternal(timer);
+          mTimers.RemoveElementAt(0);
           timer = nullptr;
 
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
                  ("Timer thread woke up %fms from when it was supposed to\n",
                   fabs((now - timerRef->mTimeout).ToMilliseconds())));
 
           // We are going to let the call to PostTimerEvent here handle the
           // release of the timer so that we don't end up releasing the timer
@@ -511,18 +518,23 @@ TimerThread::Run()
           }
 
           // Update now, as PostTimerEvent plus the locking may have taken a
           // tick or two, and we may goto next below.
           now = TimeStamp::Now();
         }
       }
 
+      // skip any canceled timers
+      while(!mTimers.IsEmpty() && !mTimers[0].mTimerImpl) {
+        mTimers.RemoveElementAt(0);
+      }
+
       if (!mTimers.IsEmpty()) {
-        timer = mTimers[0];
+        timer = mTimers[0].mTimerImpl;
 
         TimeStamp timeout = timer->mTimeout;
 
         // Don't wait at all (even for PR_INTERVAL_NO_WAIT) if the next timer
         // is due now or overdue.
         //
         // Note that we can only sleep for integer values of a certain
         // resolution. We use halfMicrosecondsIntervalResolution, calculated
@@ -630,18 +642,18 @@ TimerThread::AddTimerInternal(nsTimerImp
 {
   mMonitor.AssertCurrentThreadOwns();
   if (mShutdown) {
     return -1;
   }
 
   TimeStamp now = TimeStamp::Now();
 
-  TimerAdditionComparator c(now, aTimer);
-  RefPtr<nsTimerImpl>* insertSlot = mTimers.InsertElementSorted(aTimer, c);
+  Entry* insertSlot = mTimers.InsertElementSorted(
+    Entry(now, aTimer->mTimeout, aTimer));
 
   if (!insertSlot) {
     return -1;
   }
 
 #ifdef MOZ_TASK_TRACER
   // Caller of AddTimer is the parent task of its timer event, so we store the
   // TraceInfo here for later used.
@@ -650,17 +662,23 @@ TimerThread::AddTimerInternal(nsTimerImp
 
   return insertSlot - mTimers.Elements();
 }
 
 bool
 TimerThread::RemoveTimerInternal(nsTimerImpl* aTimer)
 {
   mMonitor.AssertCurrentThreadOwns();
-  mTimers.RemoveElement(aTimer);
+  for (uint32_t i = 0; i < mTimers.Length(); ++i) {
+    if (mTimers[i].mTimerImpl == aTimer) {
+      mTimers[i].mTimerImpl = nullptr;
+      return true;
+    }
+  }
+  return false;
 }
 
 already_AddRefed<nsTimerImpl>
 TimerThread::PostTimerEvent(already_AddRefed<nsTimerImpl> aTimerRef)
 {
   mMonitor.AssertCurrentThreadOwns();
 
   RefPtr<nsTimerImpl> timer(aTimerRef);
diff --git a/xpcom/threads/TimerThread.h b/xpcom/threads/TimerThread.h
--- a/xpcom/threads/TimerThread.h
+++ b/xpcom/threads/TimerThread.h
@@ -15,16 +15,18 @@
 #include "nsThreadUtils.h"
 
 #include "nsTArray.h"
 
 #include "mozilla/Atomics.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/Monitor.h"
 
+#include <algorithm>
+
 namespace mozilla {
 class TimeStamp;
 } // namespace mozilla
 
 class TimerThread final
   : public nsIRunnable
   , public nsIObserver
 {
@@ -72,17 +74,39 @@ private:
   nsCOMPtr<nsIThread> mThread;
   Monitor mMonitor;
 
   bool mShutdown;
   bool mWaiting;
   bool mNotified;
   bool mSleeping;
 
-  nsTArray<RefPtr<nsTimerImpl>> mTimers;
+  struct Entry
+  {
+    const TimeStamp mTimeout;
+    RefPtr<nsTimerImpl> mTimerImpl;
+
+    Entry(const TimeStamp& aMinTimeout, const TimeStamp& aTimeout,
+          nsTimerImpl* aTimerImpl)
+      : mTimeout(std::max(aMinTimeout, aTimeout)),
+      mTimerImpl(aTimerImpl)
+    { }
+
+    bool operator<(const Entry& aRight) const
+    {
+      return mTimeout < aRight.mTimeout;
+    }
+
+    bool operator==(const Entry& aRight) const
+    {
+      return mTimeout == aRight.mTimeout;
+    }
+  };
+
+  nsTArray<Entry> mTimers;
 };
 
 struct TimerAdditionComparator
 {
   TimerAdditionComparator(const mozilla::TimeStamp& aNow,
                           nsTimerImpl* aTimerToInsert) :
     now(aNow)
 #ifdef DEBUG
