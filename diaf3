# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fd878c46a51a4e0a90cf38393cff2f8103cdb4b1

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13,16 +13,17 @@
 // Local Includes
 #include "Navigator.h"
 #include "nsContentSecurityManager.h"
 #include "nsScreen.h"
 #include "nsHistory.h"
 #include "nsDOMNavigationTiming.h"
 #include "nsIDOMStorageManager.h"
 #include "mozilla/dom/Storage.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/IdleRequest.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/StorageEvent.h"
 #include "mozilla/dom/StorageEventBinding.h"
 #include "mozilla/dom/Timeout.h"
 #include "mozilla/dom/TimeoutHandler.h"
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -1,18 +1,18 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Client.h"
 
-#include "mozilla/dom/ClientBinding.h"
 #include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "nsIGlobalObject.h"
 
 namespace mozilla {
 namespace dom {
@@ -34,17 +34,17 @@ Client::~Client()
 {
 }
 
 void
 Client::EnsureHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Client);
   if (!mHandle) {
-    mHandle = ClientManager::CreateHandle(ClientInfo(mData.info()));
+    mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()));
   }
 }
 
 // TODO: unify this with code in Clients
 nsresult
 Client::GetEndPoint(ClientEndPoint& aEndPointOut)
 {
   nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
@@ -68,78 +68,78 @@ Client::GetEndPoint(ClientEndPoint& aEnd
     }
   }
 
   return NS_ERROR_DOM_INVALID_STATE_ERR;
 }
 
 Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
   : mGlobal(aGlobal)
-  , mData(aData)
+  , mData(MakeUnique<ClientInfoAndState>(aData))
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
 }
 
 TimeStamp
 Client::CreationTime() const
 {
-  return mData.info().creationTime();
+  return mData->info().creationTime();
 }
 
 TimeStamp
 Client::LastFocusTime() const
 {
-  if (mData.info().type() != ClientType::Window) {
+  if (mData->info().type() != ClientType::Window) {
     return TimeStamp();
   }
-  return mData.state().get_ClientWindowState().lastFocusTime();
+  return mData->state().get_ClientWindowState().lastFocusTime();
 }
 
 JSObject*
 Client::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
-  if (mData.info().type() == ClientType::Window) {
+  if (mData->info().type() == ClientType::Window) {
     return WindowClientBinding::Wrap(aCx, this, aGivenProto);
   }
   return ClientBinding::Wrap(aCx, this, aGivenProto);
 }
 
 nsIGlobalObject*
 Client::GetParentObject() const
 {
   return mGlobal;
 }
 
 void
 Client::GetUrl(nsAString& aUrlOut) const
 {
-  CopyUTF8toUTF16(mData.info().url(), aUrlOut);
+  CopyUTF8toUTF16(mData->info().url(), aUrlOut);
 }
 
 void
 Client::GetId(nsAString& aIdOut) const
 {
   char buf[NSID_LENGTH];
-  mData.info().id().ToProvidedString(buf);
+  mData->info().id().ToProvidedString(buf);
   NS_ConvertASCIItoUTF16 uuid(buf);
 
   // Remove {} and the null terminator
   aIdOut.Assign(Substring(uuid, 1, NSID_LENGTH - 3));
 }
 
 ClientType
 Client::Type() const
 {
-  return mData.info().type();
+  return mData->info().type();
 }
 
 FrameType
 Client::GetFrameType() const
 {
-  return mData.info().frameType();
+  return mData->info().frameType();
 }
 
 void
 Client::PostMessage(JSContext* aCx, JS::Handle<JS::Value> aMessage,
                     const Sequence<JSObject*>& aTransferable,
                     ErrorResult& aRv)
 {
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedValue());
@@ -163,23 +163,23 @@ Client::PostMessage(JSContext* aCx, JS::
 
   EnsureHandle();
   RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
 }
 
 VisibilityState
 Client::GetVisibilityState() const
 {
-  return mData.state().get_ClientWindowState().visibilityState();
+  return mData->state().get_ClientWindowState().visibilityState();
 }
 
 bool
 Client::Focused() const
 {
-  return mData.state().get_ClientWindowState().focused();
+  return mData->state().get_ClientWindowState().focused();
 }
 
 already_AddRefed<Promise>
 Client::Focus(ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
@@ -203,17 +203,17 @@ Client::Focus(ErrorResult& aRv)
   EnsureHandle();
 
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
-        new Client(self->mGlobal, ClientInfoAndState(self->mData.info(), aResult));
+        new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult));
       outerPromise->MaybeResolve(newClient);
     }, [self, outerPromise] (nsresult aResult) {
       outerPromise->MaybeReject(aResult);
     });
 
   return outerPromise.forget();
 }
 
@@ -237,17 +237,17 @@ Client::Navigate(const nsAString& aURL, 
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       baseURL = workerPrivate->GetLocationInfo().mHref;
     }
   }
 
   RefPtr<Client> self = this;
 
-  ClientNavigateArgs args(mData.info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
+  ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
 
   RefPtr<ClientOpPromise> innerPromise = ClientManager::Navigate(args);
 
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
--- a/dom/clients/api/Client.h
+++ b/dom/clients/api/Client.h
@@ -1,38 +1,41 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_Client_h
 #define _mozilla_dom_Client_h
 
-#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientBinding.h"
 #include "nsCOMPtr.h"
 #include "nsISupports.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
+class ClientEndPoint;
 class ClientHandle;
+class ClientInfoAndState;
 class Promise;
+
 template <typename t> class Sequence;
 
 class Client final : public nsISupports
                    , public nsWrapperCache
 {
   nsCOMPtr<nsIGlobalObject> mGlobal;
-  const ClientInfoAndState mData;
+  UniquePtr<ClientInfoAndState> mData;
   RefPtr<ClientHandle> mHandle;
 
   ~Client();
 
   void
   EnsureHandle();
 
   nsresult
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -9,16 +9,20 @@
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
 #include "mozilla/dom/PClientManagerChild.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
+#ifdef XP_WIN
+#undef PostMessage
+#endif
+
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
 
 ClientHandle::~ClientHandle()
 {
   Shutdown();
diff --git a/dom/clients/manager/ClientInfo.h b/dom/clients/manager/ClientInfo.h
--- a/dom/clients/manager/ClientInfo.h
+++ b/dom/clients/manager/ClientInfo.h
@@ -14,17 +14,17 @@ namespace mozilla {
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class IPCClientInfo;
 
-struct ClientInfo
+class ClientInfo final
 {
   UniquePtr<IPCClientInfo> mData;
 
 public:
   ClientInfo(const nsID& aId,
              ClientType aType,
              const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
              const TimeStamp& aCreationTime);
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -1,33 +1,38 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientManager_h
 #define _mozilla_dom_ClientManager_h
 
-#include "mozilla/dom/PClientManager.h"
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/ClientThing.h"
 #include "nsTArray.h"
 
 class nsIPrincipal;
 class nsIURI;
 
 namespace mozilla {
 namespace ipc {
 class PBackgroundChild;
 class PrincipalInfo;
 } // namespace ipc
 namespace dom {
 
+class ClientClaimArgs;
+class ClientGetInfoAndStateArgs;
 class ClientHandle;
+class ClientInfo;
 class ClientManagerChild;
+class ClientMatchAllArgs;
+class ClientNavigateArgs;
+class ClientOpConstructorArgs;
 class ClientSource;
 enum class ClientType : uint8_t;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
 class ClientManager final : public ClientThing<ClientManagerChild>
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -81,17 +81,16 @@ ClientSource::SnapshotWindowState(Client
   aStateOut->visibilityState() = doc->VisibilityState();
 
   return NS_OK;
 }
 
 ClientSource::ClientSource(ClientManager* aManager,
                            const ClientSourceConstructorArgs& aArgs)
   : mManager(aManager)
-  , mOwner(void_t())
   , mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
 {
   MOZ_ASSERT(mManager);
 }
 
 void
 ClientSource::Activate(PClientManagerChild* aActor)
 {
@@ -119,42 +118,42 @@ ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
 nsPIDOMWindowInner*
 ClientSource::GetInnerWindow() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
+  if (mOwner.isNothing() && !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
     return nullptr;
   }
-  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
+  return mOwner.ref().as<RefPtr<nsPIDOMWindowInner>>();
 }
 
 WorkerPrivate*
 ClientSource::GetWorkerPrivate() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (!mOwner.is<WorkerPrivate*>()) {
+  if (mOwner.isNothing() && !mOwner.ref().is<WorkerPrivate*>()) {
     return nullptr;
   }
-  return mOwner.as<WorkerPrivate*>();
+  return mOwner.ref().as<WorkerPrivate*>();
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   // Its safe to store the WorkerPrivate* here because the ClientSource
   // is explicitly destroyed by WorkerPrivate before exiting its run loop.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<void_t>());
-  mOwner = AsVariant(aWorkerPrivate);
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing());
+  mOwner.emplace(AsVariant(aWorkerPrivate));
 
   ClientSourceExecutionReadyArgs args(
     aWorkerPrivate->GetLocationInfo().mHref,
     FrameType::None);
 
   ExecutionReady(args);
 }
 
@@ -194,22 +193,22 @@ ClientSource::WindowExecutionReady(nsPID
   }
 
   ClientSourceExecutionReadyArgs args(spec, frameType);
   ExecutionReady(args);
 
   // We should either be setting a window execution ready for the
   // first time or setting the same window execution ready again.
   // The secondary calls are due to initial about:blank replacement.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<void_t>() ||
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing() ||
                         GetInnerWindow() == aInnerWindow);
 
   // This creates a cycle with the window.  It is broken when
   // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
-  mOwner = AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow));
+  mOwner.emplace(AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow)));
 
   return NS_OK;
 }
 
 void
 ClientSource::Freeze()
 {
   MaybeExecute([](PClientSourceChild* aActor) {
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -39,19 +39,18 @@ class ClientSource final : public Client
 {
   friend class ClientManager;
   friend class ClientSourceChild;
 
   NS_DECL_OWNINGTHREAD
 
   RefPtr<ClientManager> mManager;
 
-  Variant<void_t,
-          RefPtr<nsPIDOMWindowInner>,
-          mozilla::dom::workers::WorkerPrivate*> mOwner;
+  Maybe<Variant<RefPtr<nsPIDOMWindowInner>,
+                mozilla::dom::workers::WorkerPrivate*>> mOwner;
 
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
   void
   Shutdown();
 
   void
diff --git a/dom/workers/ServiceWorkerDescriptor.h b/dom/workers/ServiceWorkerDescriptor.h
--- a/dom/workers/ServiceWorkerDescriptor.h
+++ b/dom/workers/ServiceWorkerDescriptor.h
@@ -12,17 +12,17 @@ namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class IPCServiceWorkerDescriptor;
 enum class ServiceWorkerState : uint8_t;
 
-struct ServiceWorkerDescriptor
+class ServiceWorkerDescriptor final
 {
   UniquePtr<IPCServiceWorkerDescriptor> mData;
 
 public:
   ServiceWorkerDescriptor();
 
   ServiceWorkerDescriptor(uint64_t aId,
                           const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -19,16 +19,17 @@
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/Client.h"
+#include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/FetchUtil.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -51,16 +51,17 @@
 #include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ErrorEvent.h"
 #include "mozilla/dom/ErrorEventBinding.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/IndexedDatabaseManager.h"
+#include "mozilla/dom/IPCServiceWorkerDescriptor.h"
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/MessagePortBinding.h"
 #include "mozilla/dom/nsCSPUtils.h"
 #include "mozilla/dom/Performance.h"
 #include "mozilla/dom/PMessagePort.h"
 #include "mozilla/dom/Promise.h"
