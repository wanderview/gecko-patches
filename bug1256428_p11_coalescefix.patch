# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  42550241b3d360efdb870e8208c2d65e306669b3
Bug 1256428 P11 Don't coalesce SW jobs after the existing job has already resolved its promise. r=jdm

diff --git a/dom/workers/ServiceWorkerJob.cpp b/dom/workers/ServiceWorkerJob.cpp
--- a/dom/workers/ServiceWorkerJob.cpp
+++ b/dom/workers/ServiceWorkerJob.cpp
@@ -28,16 +28,22 @@ ServiceWorkerJob2::GetState() const
 
 bool
 ServiceWorkerJob2::Canceled() const
 {
   return mCanceled;
 }
 
 bool
+ServiceWorkerJob2::ResultCallbacksInvoked() const
+{
+  return mResultCallbacksInvoked;
+}
+
+bool
 ServiceWorkerJob2::IsEquivalentTo(ServiceWorkerJob2* aJob) const
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
   return mType == aJob->mType &&
          mScope.Equals(aJob->mScope) &&
          mScriptSpec.Equals(aJob->mScriptSpec) &&
          mPrincipal->Equals(aJob->mPrincipal);
@@ -46,17 +52,17 @@ ServiceWorkerJob2::IsEquivalentTo(Servic
 void
 ServiceWorkerJob2::AppendResultCallback(Callback* aCallback)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mState != State::Finished);
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(mFinalCallback != aCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aCallback));
-  // TODO: handle the case where InvokeResultCallback() has already been called
+  MOZ_ASSERT(!mResultCallbacksInvoked);
   mResultCallbackList.AppendElement(aCallback);
 }
 
 void
 ServiceWorkerJob2::StealResultCallbacksFrom(ServiceWorkerJob2* aJob)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aJob);
@@ -118,37 +124,42 @@ ServiceWorkerJob2::ServiceWorkerJob2(Typ
                                      const nsACString& aScope,
                                      const nsACString& aScriptSpec)
   : mType(aType)
   , mPrincipal(aPrincipal)
   , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mState(State::Initial)
   , mCanceled(false)
+  , mResultCallbacksInvoked(false)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mPrincipal);
   MOZ_ASSERT(!mScope.IsEmpty());
   // Some job types may have an empty script spec
 }
 
 ServiceWorkerJob2::~ServiceWorkerJob2()
 {
   AssertIsOnMainThread();
   // Jobs must finish or never be started.  Destroying an actively running
   // job is an error.
   MOZ_ASSERT(mState != State::Started);
+  MOZ_ASSERT_IF(mState == State::Finished, mResultCallbacksInvoked);
 }
 
 void
 ServiceWorkerJob2::InvokeResultCallbacks(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mState == State::Started);
 
+  MOZ_ASSERT(!mResultCallbacksInvoked);
+  mResultCallbacksInvoked = true;
+
   nsTArray<RefPtr<Callback>> callbackList;
   callbackList.SwapElements(mResultCallbackList);
 
   for (RefPtr<Callback>& callback : callbackList) {
     // The callback might consume an exception on the ErrorResult, so we need
     // to clone in order to maintain the error for the next callback.
     ErrorResult rv;
     aRv.CloneTo(rv);
@@ -186,17 +197,19 @@ ServiceWorkerJob2::Finish(ErrorResult& a
 
     // Throw the type error with a generic error message.
     aRv.ThrowTypeError<MSG_SW_INSTALL_ERROR>(scriptSpec, scope);
   }
 
   // The final callback may drop the last ref to this object.
   RefPtr<ServiceWorkerJob2> kungFuDeathGrip = this;
 
-  InvokeResultCallbacks(aRv);
+  if (!mResultCallbacksInvoked) {
+    InvokeResultCallbacks(aRv);
+  }
 
   mState = State::Finished;
 
   mFinalCallback->JobFinished(this, aRv);
   mFinalCallback = nullptr;
 
   // The callback might not consume the error.
   aRv.SuppressException();
diff --git a/dom/workers/ServiceWorkerJob.h b/dom/workers/ServiceWorkerJob.h
--- a/dom/workers/ServiceWorkerJob.h
+++ b/dom/workers/ServiceWorkerJob.h
@@ -61,16 +61,21 @@ public:
   GetState() const;
 
   // Determine if the job has been canceled.  This does not change the
   // current State, but indicates that the job should progress to Finished
   // as soon as possible.
   bool
   Canceled() const;
 
+  // Determine if the result callbacks have already been called.  This is
+  // equivalent to the spec checked to see if the job promise has settled.
+  bool
+  ResultCallbacksInvoked() const;
+
   bool
   IsEquivalentTo(ServiceWorkerJob2* aJob) const;
 
   // Add a callback that will be invoked when the job's result is available.
   // Some job types will invoke this before the job is actually finished.
   // If an early callback does not occur, then it will be called automatically
   // when Finish() is called.  These callbacks will be invoked while the job
   // state is Started.
@@ -132,16 +137,17 @@ protected:
   const nsCString mScope;
   const nsCString mScriptSpec;
 
 private:
   RefPtr<Callback> mFinalCallback;
   nsTArray<RefPtr<Callback>> mResultCallbackList;
   State mState;
   bool mCanceled;
+  bool mResultCallbacksInvoked;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJob2)
 };
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerJobQueue.cpp b/dom/workers/ServiceWorkerJobQueue.cpp
--- a/dom/workers/ServiceWorkerJobQueue.cpp
+++ b/dom/workers/ServiceWorkerJobQueue.cpp
@@ -93,17 +93,17 @@ ServiceWorkerJobQueue2::ScheduleJob(Serv
     mJobList.AppendElement(aJob);
     RunJob();
     return;
   }
 
   MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob2::State::Started);
 
   RefPtr<ServiceWorkerJob2>& tailJob = mJobList[mJobList.Length() - 1];
-  if (aJob->IsEquivalentTo(tailJob)) {
+  if (!tailJob->ResultCallbacksInvoked() && aJob->IsEquivalentTo(tailJob)) {
     tailJob->StealResultCallbacksFrom(aJob);
     return;
   }
 
   mJobList.AppendElement(aJob);
 }
 
 void
