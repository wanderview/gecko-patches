# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6b180266ac16e3226be33319ff710ddfa85f5836
Bug 1287547 Don't leak HTMLScriptElement wrapper when page is closed during off-thread script parsing. r=bz

diff --git a/dom/base/nsScriptLoader.cpp b/dom/base/nsScriptLoader.cpp
--- a/dom/base/nsScriptLoader.cpp
+++ b/dom/base/nsScriptLoader.cpp
@@ -82,25 +82,53 @@ NS_INTERFACE_MAP_END
 NS_IMPL_CYCLE_COLLECTION_0(nsScriptLoadRequest)
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsScriptLoadRequest)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsScriptLoadRequest)
 
 nsScriptLoadRequest::~nsScriptLoadRequest()
 {
   js_free(mScriptTextBuf);
+
+  // We should always clean up any off-thread script parsing resources.
+  MOZ_ASSERT(!mOffThreadToken);
+
+  // But play it safe in release builds and try to clean them up here
+  // as a fail safe.
+  MaybeCancelOffThreadScript();
 }
 
 void
 nsScriptLoadRequest::SetReady()
 {
   MOZ_ASSERT(mProgress != Progress::Ready);
   mProgress = Progress::Ready;
 }
 
+void
+nsScriptLoadRequest::Cancel()
+{
+  MaybeCancelOffThreadScript();
+  mIsCanceled = true;
+}
+
+void
+nsScriptLoadRequest::MaybeCancelOffThreadScript()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (!mOffThreadToken) {
+    return;
+  }
+
+  JSContext* cx = JS_GetContext(xpc::GetJSRuntime());
+  JS::CancelOffThreadScript(cx, mOffThreadToken);
+  mOffThreadToken = nullptr;
+}
+
 //////////////////////////////////////////////////////////////
 // nsModuleLoadRequest
 //////////////////////////////////////////////////////////////
 
 // A load request for a module, created for every top level module script and
 // every module import.  Load request can share an nsModuleScript if there are
 // multiple imports of the same module.
 
@@ -1824,19 +1852,17 @@ nsScriptLoader::ProcessRequest(nsScriptL
   }
 
   if (aRequest->mOffThreadToken) {
     // The request was parsed off-main-thread, but the result of the off
     // thread parse was not actually needed to process the request
     // (disappearing window, some other error, ...). Finish the
     // request to avoid leaks in the JS engine.
     MOZ_ASSERT(!aRequest->IsModuleRequest());
-    JSContext* cx = JS_GetContext(xpc::GetJSRuntime());
-    JS::CancelOffThreadScript(cx, aRequest->mOffThreadToken);
-    aRequest->mOffThreadToken = nullptr;
+    aRequest->MaybeCancelOffThreadScript();
   }
 
   // Free any source data.
   free(aRequest->mScriptTextBuf);
   aRequest->mScriptTextBuf = nullptr;
   aRequest->mScriptTextLength = 0;
 
   return rv;
diff --git a/dom/base/nsScriptLoader.h b/dom/base/nsScriptLoader.h
--- a/dom/base/nsScriptLoader.h
+++ b/dom/base/nsScriptLoader.h
@@ -113,20 +113,17 @@ public:
     mElement->ScriptEvaluated(aResult, mElement, mIsInline);
   }
 
   bool IsPreload()
   {
     return mElement == nullptr;
   }
 
-  virtual void Cancel()
-  {
-    mIsCanceled = true;
-  }
+  virtual void Cancel();
 
   bool IsCanceled() const
   {
     return mIsCanceled;
   }
 
   virtual void SetReady();
 
@@ -147,16 +144,18 @@ public:
   bool IsLoading() const {
     return mProgress == Progress::Loading;
   }
   bool InCompilingStage() const {
     return mProgress == Progress::Compiling ||
            (IsReadyToRun() && mWasCompiledOMT);
   }
 
+  void MaybeCancelOffThreadScript();
+
   using super::getNext;
   using super::isInList;
 
   const nsScriptKind mKind;
   nsCOMPtr<nsIScriptElement> mElement;
   Progress mProgress;     // Are we still waiting for a load to complete?
   bool mIsInline;         // Is the script inline or loaded?
   bool mHasSourceMapURL;  // Does the HTTP header have a source map url?
