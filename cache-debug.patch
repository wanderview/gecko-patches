# HG changeset patch
# Parent d4d19da3466857edafb80a5bfd5ba1799ce3d244
# User Ben Kelly <ben@wanderview.com>

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -297,16 +297,19 @@ DBSchema::CachePut(mozIStorageConnection
                    const PCacheRequest& aRequest,
                    const nsID* aRequestBodyId,
                    const PCacheResponse& aResponse,
                    const nsID* aResponseBodyId,
                    nsTArray<nsID>& aDeletedBodyIdListOut)
 {
   MOZ_ASSERT(aConn);
 
+  printf_stderr("### ### DBSchema::CachePut() url:%s\n",
+                NS_ConvertUTF16toUTF8(aRequest.url()).get());
+
   PCacheQueryParams params(false, false, false, false, false,
                            NS_LITERAL_STRING(""));
   nsTArray<EntryId> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, params, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = DeleteEntries(aConn, matches, aDeletedBodyIdListOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -323,16 +326,19 @@ nsresult
 DBSchema::CacheDelete(mozIStorageConnection* aConn, CacheId aCacheId,
                       const PCacheRequest& aRequest,
                       const PCacheQueryParams& aParams,
                       nsTArray<nsID>& aDeletedBodyIdListOut, bool* aSuccessOut)
 {
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aSuccessOut);
 
+  printf_stderr("### ### DBSchema::CacheDelete() url:%s\n",
+                NS_ConvertUTF16toUTF8(aRequest.url()).get());
+
   nsTArray<EntryId> matches;
   nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (matches.Length() < 1) {
     *aSuccessOut = false;
     return rv;
   }
@@ -639,37 +645,49 @@ DBSchema::QueryCache(mozIStorageConnecti
 
   rv = state->BindInt32Parameter(0, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (aParams.prefixMatch()) {
     nsAutoString escapedUrlToMatch;
     rv = state->EscapeStringForLIKE(urlToMatch, '\\', escapedUrlToMatch);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    printf_stderr("### ### DBSchema::QueryCache() escaped string from:%s to:%s\n",
+                  NS_ConvertUTF16toUTF8(urlToMatch).get(),
+                  NS_ConvertUTF16toUTF8(escapedUrlToMatch).get());
     urlToMatch = escapedUrlToMatch;
     urlToMatch.AppendLiteral("%");
   }
 
   rv = state->BindStringParameter(1, urlToMatch);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  printf_stderr("### ### DBSchema::QueryCache() ignoreSearch:%s urlToMatch:%s query:%s\n",
+                (aParams.ignoreSearch() ? "true" : "false"),
+                NS_ConvertUTF16toUTF8(urlToMatch).get(),
+                query.get());
+
   bool hasMoreData;
   while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
     EntryId entryId;
     rv = state->GetInt32(0, &entryId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     int32_t varyCount;
     rv = state->GetInt32(1, &varyCount);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+    printf_stderr("### ### DBSchema::QueryCache() found entry id:%d ignoreVary:%s varyCount:%d\n",
+                  entryId, (aParams.ignoreVary() ? "true" : "false"), varyCount);
     if (!aParams.ignoreVary() && varyCount > 0) {
       bool matchedByVary;
       rv = MatchByVaryHeader(aConn, aRequest, entryId, &matchedByVary);
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      printf_stderr("### ### DBSchema::QueryCache() got %s from MatchByVaryHeader()\n",
+                    (matchedByVary ? "true" : "false"));
       if (!matchedByVary) {
         continue;
       }
     }
 
     aEntryIdListOut.AppendElement(entryId);
   }
 
@@ -733,27 +751,31 @@ DBSchema::MatchByVaryHeader(mozIStorageC
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsRefPtr<InternalHeaders> queryHeaders = new InternalHeaders(aRequest.headers());
 
   for (uint32_t i = 0; i < varyValues.Length(); ++i) {
     if (varyValues[i].EqualsLiteral("*")) {
+      printf_stderr("### ### DBSchema::MatchByVaryHeader() auto-match wildcard\n");
       continue;
     }
 
     nsAutoCString queryValue;
     queryHeaders->Get(varyValues[i], queryValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
     nsAutoCString cachedValue;
     cachedHeaders->Get(varyValues[i], cachedValue, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
 
+    printf_stderr("### ### DBSchema::MatchByVaryHeader() vary:%s query:%s cached:%s\n",
+                  varyValues[i].get(), queryValue.get(), cachedValue.get());
+
     if (queryValue != cachedValue) {
       *aSuccessOut = false;
       return rv;
     }
   }
 
   *aSuccessOut = true;
   return rv;
@@ -838,16 +860,28 @@ DBSchema::DeleteEntries(mozIStorageConne
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindListParamsToQuery(state, aEntryIdList, aPos, aLen);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  nsAutoCString debug("### ### DBSchema::DeleteEntries() ids: ");
+  for (uint32_t i = 0; i < aEntryIdList.Length(); ++i) {
+    if (i == 0) {
+      debug.AppendInt(aEntryIdList[i]);
+      continue;
+    }
+    debug.Append(", ");
+    debug.AppendInt(aEntryIdList[i]);
+  }
+  debug.Append("\n");
+  printf_stderr("%s", debug.get());
+
   return rv;
 }
 
 // static
 nsresult
 DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
                       const PCacheRequest& aRequest,
                       const nsID* aRequestBodyId,
@@ -985,16 +1019,19 @@ DBSchema::InsertEntry(mozIStorageConnect
 
     rv = state->BindInt32Parameter(2, entryId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->Execute();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
+  printf_stderr("### ### DBSchema::InsertEntry() url:%s id:%d\n",
+                NS_ConvertUTF16toUTF8(aRequest.url()).get(), entryId);
+
   return rv;
 }
 
 // static
 nsresult
 DBSchema::ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
                        SavedResponse* aSavedResponseOut)
 {
