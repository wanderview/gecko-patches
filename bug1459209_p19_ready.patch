# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a18268cdecfd9e88455d6634b7dfba0816ad6a68
Bug 1459209 P19 Implement RemoteServiceWorkerContainerImpl::GetReady() across IPC to the parent-side SWM. r=baku

diff --git a/dom/serviceworkers/PServiceWorkerContainer.ipdl b/dom/serviceworkers/PServiceWorkerContainer.ipdl
--- a/dom/serviceworkers/PServiceWorkerContainer.ipdl
+++ b/dom/serviceworkers/PServiceWorkerContainer.ipdl
@@ -22,14 +22,17 @@ parent:
         returns (IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult aResult);
 
   async GetRegistration(IPCClientInfo aClientInfo, nsCString aURL)
         returns (IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult aResult);
 
   async GetRegistrations(IPCClientInfo aClientInfo)
         returns (IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult aResult);
 
+  async GetReady(IPCClientInfo aClientInfo)
+        returns (IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult aResult);
+
 child:
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
@@ -152,17 +152,38 @@ RemoteServiceWorkerContainerImpl::GetReg
     });
 }
 
 void
 RemoteServiceWorkerContainerImpl::GetReady(const ClientInfo& aClientInfo,
                                            ServiceWorkerRegistrationCallback&& aSuccessCB,
                                            ServiceWorkerFailureCallback&& aFailureCB) const
 {
-  // TODO
+  if (!mActor) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
+  mActor->SendGetReady(aClientInfo.ToIPC(),
+    [successCB = std::move(aSuccessCB), aFailureCB]
+    (const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aResult) {
+      if (aResult.type() == IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::TCopyableErrorResult) {
+        // application layer error
+        auto& rv = aResult.get_CopyableErrorResult();
+        MOZ_DIAGNOSTIC_ASSERT(rv.Failed());
+        aFailureCB(CopyableErrorResult(rv));
+        return;
+      }
+      // success
+      auto& ipcDesc = aResult.get_IPCServiceWorkerRegistrationDescriptor();
+      successCB(ServiceWorkerRegistrationDescriptor(ipcDesc));
+    }, [aFailureCB] (ResponseRejectReason aReason) {
+      // IPC layer error
+      aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    });
 }
 
 RemoteServiceWorkerContainerImpl::RemoteServiceWorkerContainerImpl()
   : mActor(nullptr)
   , mOuter(nullptr)
   , mShutdown(false)
 {
   PBackgroundChild* parentActor = BackgroundChild::GetOrCreateForCurrentThread();
diff --git a/dom/serviceworkers/ServiceWorkerContainerParent.cpp b/dom/serviceworkers/ServiceWorkerContainerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerContainerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainerParent.cpp
@@ -92,16 +92,36 @@ ServiceWorkerContainerParent::RecvGetReg
       aResolver(std::move(ipcList));
     }, [aResolver] (const CopyableErrorResult& aResult) {
       aResolver(aResult);
     });
 
   return IPC_OK();
 }
 
+IPCResult
+ServiceWorkerContainerParent::RecvGetReady(const IPCClientInfo& aClientInfo,
+                                           GetReadyResolver&& aResolver)
+{
+  if (!mProxy) {
+    aResolver(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return IPC_OK();
+  }
+
+  mProxy->GetReady(ClientInfo(aClientInfo))->Then(
+    GetCurrentThreadSerialEventTarget(), __func__,
+    [aResolver] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+      aResolver(aDescriptor.ToIPC());
+    }, [aResolver] (const CopyableErrorResult& aResult) {
+      aResolver(aResult);
+    });
+
+  return IPC_OK();
+}
+
 ServiceWorkerContainerParent::ServiceWorkerContainerParent()
 {
 }
 
 ServiceWorkerContainerParent::~ServiceWorkerContainerParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mProxy);
 }
diff --git a/dom/serviceworkers/ServiceWorkerContainerParent.h b/dom/serviceworkers/ServiceWorkerContainerParent.h
--- a/dom/serviceworkers/ServiceWorkerContainerParent.h
+++ b/dom/serviceworkers/ServiceWorkerContainerParent.h
@@ -36,16 +36,20 @@ class ServiceWorkerContainerParent final
   RecvGetRegistration(const IPCClientInfo& aClientInfo,
                       const nsCString& aURL,
                       GetRegistrationResolver&& aResolver) override;
 
   mozilla::ipc::IPCResult
   RecvGetRegistrations(const IPCClientInfo& aClientInfo,
                        GetRegistrationsResolver&& aResolver) override;
 
+  mozilla::ipc::IPCResult
+  RecvGetReady(const IPCClientInfo& aClientInfo,
+               GetReadyResolver&& aResolver) override;
+
 public:
   ServiceWorkerContainerParent();
   ~ServiceWorkerContainerParent();
 
   void
   Init();
 };
 
diff --git a/dom/serviceworkers/ServiceWorkerContainerProxy.cpp b/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
@@ -121,10 +121,37 @@ ServiceWorkerContainerProxy::GetRegistra
       scopeExit.release();
     });
 
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 
   return promise;
 }
 
+RefPtr<ServiceWorkerRegistrationPromise>
+ServiceWorkerContainerProxy::GetReady(const ClientInfo& aClientInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ServiceWorkerRegistrationPromise::Private> promise =
+    new ServiceWorkerRegistrationPromise::Private(__func__);
+
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
+    [aClientInfo, promise] () mutable {
+      auto scopeExit = MakeScopeExit([&] {
+        promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      });
+
+      RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+      NS_ENSURE_TRUE_VOID(swm);
+
+      swm->WhenReady(aClientInfo)->ChainTo(promise.forget(), __func__);
+
+      scopeExit.release();
+    });
+
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+  return promise;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerContainerProxy.h b/dom/serviceworkers/ServiceWorkerContainerProxy.h
--- a/dom/serviceworkers/ServiceWorkerContainerProxy.h
+++ b/dom/serviceworkers/ServiceWorkerContainerProxy.h
@@ -31,15 +31,18 @@ public:
            ServiceWorkerUpdateViaCache aUpdateViaCache);
 
   RefPtr<ServiceWorkerRegistrationPromise>
   GetRegistration(const ClientInfo& aClientInfo, const nsCString& aURL);
 
   RefPtr<ServiceWorkerRegistrationListPromise>
   GetRegistrations(const ClientInfo& aClientInfo);
 
+  RefPtr<ServiceWorkerRegistrationPromise>
+  GetReady(const ClientInfo& aClientInfo);
+
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerContainerProxy);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // moz_dom_ServiceWorkerContainerProxy_h
