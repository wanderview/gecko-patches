# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e571c913e77299325209ce1f37cd3c1bee3a847a
Bug 1462466 P1 Add a ServiceWorkerCloneData type with threadsafe ref-counting. r=baku

diff --git a/dom/ipc/StructuredCloneData.cpp b/dom/ipc/StructuredCloneData.cpp
--- a/dom/ipc/StructuredCloneData.cpp
+++ b/dom/ipc/StructuredCloneData.cpp
@@ -457,11 +457,17 @@ bool
 StructuredCloneData::StealExternalData(JSStructuredCloneData& aData)
 {
   MOZ_ASSERT(!mInitialized);
   mSharedData = new SharedJSAllocatedData(Move(aData));
   mInitialized = true;
   return true;
 }
 
+already_AddRefed<SharedJSAllocatedData>
+StructuredCloneData::TakeSharedData()
+{
+  return mSharedData.forget();
+}
+
 } // namespace ipc
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/StructuredCloneData.h b/dom/ipc/StructuredCloneData.h
--- a/dom/ipc/StructuredCloneData.h
+++ b/dom/ipc/StructuredCloneData.h
@@ -288,16 +288,19 @@ public:
 
   // For IPC serialization
   void WriteIPCParams(IPC::Message* aMessage) const;
   bool ReadIPCParams(const IPC::Message* aMessage, PickleIterator* aIter);
 
 protected:
   explicit StructuredCloneData(TransferringSupport aSupportsTransferring);
 
+  already_AddRefed<SharedJSAllocatedData>
+  TakeSharedData();
+
 private:
   JSStructuredCloneData mExternalData;
   RefPtr<SharedJSAllocatedData> mSharedData;
 
   // This array is needed because AutoIPCStream DTOR must be executed after the
   // sending of the data via IPC. This will be fixed by bug 1353475.
   FallibleTArray<mozilla::ipc::AutoIPCStream> mIPCStreams;
   bool mInitialized;
diff --git a/dom/serviceworkers/ServiceWorkerCloneData.cpp b/dom/serviceworkers/ServiceWorkerCloneData.cpp
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerCloneData.cpp
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerCloneData.h"
+
+#include "nsProxyRelease.h"
+
+namespace mozilla {
+namespace dom {
+
+ServiceWorkerCloneData::~ServiceWorkerCloneData()
+{
+  RefPtr<ipc::SharedJSAllocatedData> sharedData = TakeSharedData();
+  if (sharedData) {
+    NS_ProxyRelease(__func__, mEventTarget, sharedData.forget());
+  }
+}
+
+ServiceWorkerCloneData::ServiceWorkerCloneData()
+  : mEventTarget(GetCurrentThreadSerialEventTarget())
+{
+  MOZ_DIAGNOSTIC_ASSERT(mEventTarget);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerCloneData.h b/dom/serviceworkers/ServiceWorkerCloneData.h
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerCloneData.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ServiceWorkerCloneData_h__
+#define mozilla_dom_ServiceWorkerCloneData_h__
+
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+
+namespace mozilla {
+namespace dom {
+
+// Helper class used to pack structured clone data so that it can be
+// passed across thread and process boundaries.  Currently the raw
+// StructuredCloneData and StructureCloneHolder APIs both make it
+// difficult to meet this needs directly.  This helper class improves
+// the situation by:
+//
+//  1. Provides a ref-counted version of StructuredCloneData.  We need
+//     StructuredCloneData so we can serialize/deserialize across IPC.
+//     The move constructor problems in StructuredCloneData (bug 1462676),
+//     though, makes it hard to pass it around.  Passing a ref-counted
+//     pointer addresses this problem.
+//  2. Normally StructuredCloneData runs into problems if you try to move
+//     it across thread boundaries because it releases its SharedJSAllocatedData
+//     on the wrong thread.  This helper will correctly proxy release the
+//     shared data on the correct thread.
+//
+// This helper class should really just be used to serialize on one thread
+// and then move the reference across thread/process boundries to the
+// target worker thread.  This class is not intended to support simultaneous
+// read/write operations from different threads at the same time.
+class ServiceWorkerCloneData final : public ipc::StructuredCloneData
+{
+  nsCOMPtr<nsISerialEventTarget> mEventTarget;
+
+  ~ServiceWorkerCloneData();
+
+public:
+  ServiceWorkerCloneData();
+
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerCloneData)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ServiceWorkerCloneData_h__
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -12,16 +12,17 @@
 #include "mozilla/dom/WorkerCommon.h"
 #include "mozilla/OriginAttributes.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientInfoAndState;
+class ClientState;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
diff --git a/dom/serviceworkers/moz.build b/dom/serviceworkers/moz.build
--- a/dom/serviceworkers/moz.build
+++ b/dom/serviceworkers/moz.build
@@ -29,16 +29,17 @@ EXPORTS.mozilla.dom += [
 
 UNIFIED_SOURCES += [
     'RemoteServiceWorkerContainerImpl.cpp',
     'RemoteServiceWorkerImpl.cpp',
     'RemoteServiceWorkerRegistrationImpl.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerActors.cpp',
     'ServiceWorkerChild.cpp',
+    'ServiceWorkerCloneData.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerContainerChild.cpp',
     'ServiceWorkerContainerImpl.cpp',
     'ServiceWorkerContainerParent.cpp',
     'ServiceWorkerContainerProxy.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerImpl.cpp',
