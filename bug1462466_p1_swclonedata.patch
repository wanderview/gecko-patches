# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  018572ddc1ddb61c3ce558bb5079466b670384cd
Bug 1462466 P1 Add a ServiceWorkerCloneData type with threadsafe ref-counting. r=baku

diff --git a/dom/ipc/StructuredCloneData.cpp b/dom/ipc/StructuredCloneData.cpp
--- a/dom/ipc/StructuredCloneData.cpp
+++ b/dom/ipc/StructuredCloneData.cpp
@@ -458,11 +458,17 @@ bool
 StructuredCloneData::StealExternalData(JSStructuredCloneData& aData)
 {
   MOZ_ASSERT(!mInitialized);
   mSharedData = new SharedJSAllocatedData(std::move(aData));
   mInitialized = true;
   return true;
 }
 
+already_AddRefed<SharedJSAllocatedData>
+StructuredCloneData::TakeSharedData()
+{
+  return mSharedData.forget();
+}
+
 } // namespace ipc
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/StructuredCloneData.h b/dom/ipc/StructuredCloneData.h
--- a/dom/ipc/StructuredCloneData.h
+++ b/dom/ipc/StructuredCloneData.h
@@ -292,16 +292,19 @@ public:
 
   // For IPC serialization
   void WriteIPCParams(IPC::Message* aMessage) const;
   bool ReadIPCParams(const IPC::Message* aMessage, PickleIterator* aIter);
 
 protected:
   explicit StructuredCloneData(TransferringSupport aSupportsTransferring);
 
+  already_AddRefed<SharedJSAllocatedData>
+  TakeSharedData();
+
 private:
   JSStructuredCloneData mExternalData;
   RefPtr<SharedJSAllocatedData> mSharedData;
 
   // This array is needed because AutoIPCStream DTOR must be executed after the
   // sending of the data via IPC. This will be fixed by bug 1353475.
   FallibleTArray<mozilla::ipc::AutoIPCStream> mIPCStreams;
   bool mInitialized;
diff --git a/dom/serviceworkers/ServiceWorkerCloneData.cpp b/dom/serviceworkers/ServiceWorkerCloneData.cpp
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerCloneData.cpp
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerCloneData.h"
+
+#include "nsProxyRelease.h"
+
+namespace mozilla {
+namespace dom {
+
+ServiceWorkerCloneData::~ServiceWorkerCloneData()
+{
+  RefPtr<ipc::SharedJSAllocatedData> sharedData = TakeSharedData();
+  if (sharedData) {
+    NS_ProxyRelease(__func__, mEventTarget, sharedData.forget());
+  }
+}
+
+ServiceWorkerCloneData::ServiceWorkerCloneData()
+  : mEventTarget(GetCurrentThreadSerialEventTarget())
+{
+  MOZ_DIAGNOSTIC_ASSERT(mEventTarget);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerCloneData.h b/dom/serviceworkers/ServiceWorkerCloneData.h
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerCloneData.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ServiceWorkerCloneData_h__
+#define mozilla_dom_ServiceWorkerCloneData_h__
+
+#include "mozilla/dom/ipc/StructuredCloneData.h"
+
+namespace mozilla {
+namespace dom {
+
+// Helper class used to pack structured clone data so that it can be
+// passed across thread and process boundaries.  Currently the raw
+// StructuredCloneData and StructureCloneHolder APIs both make it
+// difficult to meet this needs directly.  This helper class improves
+// the situation by:
+//
+//  1. Provides a ref-counted version of StructuredCloneData.  We need
+//     StructuredCloneData so we can serialize/deserialize across IPC.
+//     The move constructor problems in StructuredCloneData (bug 1462676),
+//     though, makes it hard to pass it around.  Passing a ref-counted
+//     pointer addresses this problem.
+//  2. Normally StructuredCloneData runs into problems if you try to move
+//     it across thread boundaries because it releases its SharedJSAllocatedData
+//     on the wrong thread.  This helper will correctly proxy release the
+//     shared data on the correct thread.
+//
+// This helper class should really just be used to serialize on one thread
+// and then move the reference across thread/process boundries to the
+// target worker thread.  This class is not intended to support simultaneous
+// read/write operations from different threads at the same time.
+class ServiceWorkerCloneData final : public ipc::StructuredCloneData
+{
+  nsCOMPtr<nsISerialEventTarget> mEventTarget;
+
+  ~ServiceWorkerCloneData();
+
+public:
+  ServiceWorkerCloneData();
+
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerCloneData)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ServiceWorkerCloneData_h__
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -12,16 +12,17 @@
 #include "mozilla/dom/WorkerCommon.h"
 #include "mozilla/OriginAttributes.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 
 class ClientInfoAndState;
+class ClientState;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
  * by this class and spawn a ServiceWorker in the right global when required.
  */
diff --git a/dom/serviceworkers/ServiceWorkerRegisterJob.cpp b/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
--- a/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerRegisterJob.h"
 
 #include "mozilla/dom/WorkerCommon.h"
+#include "ServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
 
 ServiceWorkerRegisterJob::ServiceWorkerRegisterJob(
     nsIPrincipal* aPrincipal,
     const nsACString& aScope,
     const nsACString& aScriptSpec,
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.h b/dom/serviceworkers/ServiceWorkerUpdateJob.h
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.h
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.h
@@ -13,16 +13,17 @@
 namespace mozilla {
 namespace dom {
 
 namespace serviceWorkerScriptCache {
 enum class OnFailure : uint8_t;
 } // namespace serviceWorkerScriptCache
 
 class ServiceWorkerManager;
+class ServiceWorkerRegistrationInfo;
 
 // A job class that performs the Update and Install algorithms from the
 // service worker spec.  This class is designed to be inherited and customized
 // as a different job type.  This is necessary because the register job
 // performs largely the same operations as the update job, but has a few
 // different starting steps.
 class ServiceWorkerUpdateJob : public ServiceWorkerJob
 {
diff --git a/dom/serviceworkers/moz.build b/dom/serviceworkers/moz.build
--- a/dom/serviceworkers/moz.build
+++ b/dom/serviceworkers/moz.build
@@ -23,16 +23,17 @@ EXPORTS.mozilla.dom += [
     'ServiceWorkerRegistration.h',
     'ServiceWorkerRegistrationDescriptor.h',
     'ServiceWorkerRegistrationInfo.h',
     'ServiceWorkerUtils.h',
 ]
 
 UNIFIED_SOURCES += [
     'ServiceWorker.cpp',
+    'ServiceWorkerCloneData.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerContainerImpl.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerImpl.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerInterceptController.cpp',
     'ServiceWorkerJob.cpp',
