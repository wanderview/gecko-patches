# HG changeset patch
# Parent 80447ebaee7e5feb18818f3f6ebea69546a550b0
# User Ben Kelly <ben@wanderview.com>
Cache should pass PrincipalInfo to parent process.

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -178,17 +178,16 @@
 #include "prenv.h"
 #include "prprf.h"
 
 #include "mozilla/dom/MessageChannel.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/MessagePortBinding.h"
 #include "mozilla/dom/indexedDB/IDBFactory.h"
 #include "mozilla/dom/Promise.h"
-#include "mozilla/dom/quota/QuotaManager.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 
 #include "mozilla/dom/StructuredCloneTags.h"
 
 #ifdef MOZ_GAMEPAD
 #include "mozilla/dom/GamepadService.h"
 #endif
@@ -10836,40 +10835,24 @@ void
 nsGlobalWindow::GetInterface(JSContext* aCx, nsIJSID* aIID,
                              JS::MutableHandle<JS::Value> aRetval,
                              ErrorResult& aError)
 {
   dom::GetInterface(aCx, this, aIID, aRetval, aError);
 }
 
 already_AddRefed<CacheStorage>
-nsGlobalWindow::Caches()
-{
-  using mozilla::dom::quota::QuotaManager;
-  using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
-
+nsGlobalWindow::GetCaches(ErrorResult& aRv)
+{
   if (!mCacheStorage) {
-    nsAutoCString origin;
-    nsAutoCString quotaGroup;
-    bool isApp;
-    bool hasUnlimStoragePerm;
-    nsCOMPtr<nsIPrincipal> principal = GetPrincipal();
-    if (!principal ||
-        NS_FAILED(QuotaManager::GetInfoFromPrincipal(principal,
-                                                     PERSISTENCE_TYPE_PERSISTENT,
-                                                     &origin, &quotaGroup,
-                                                     &isApp, &hasUnlimStoragePerm))) {
-      origin.AssignLiteral("null");
-      quotaGroup.AssignLiteral("");
-      isApp = false;
-      hasUnlimStoragePerm = false;
-    }
-    mCacheStorage = new CacheStorage(cache::DEFAULT_NAMESPACE,
-                                     ToSupports(this), this, origin,
-                                     quotaGroup, isApp, hasUnlimStoragePerm);
+    mCacheStorage = CacheStorage::CreateOnMainThread(cache::DEFAULT_NAMESPACE,
+                                                   this, GetPrincipal(), aRv);
+    if (aRv.Failed()) {
+      return nullptr;
+    }
   }
 
   nsRefPtr<CacheStorage> ref = mCacheStorage;
   return ref.forget();
 }
 
 void
 nsGlobalWindow::FireOfflineStatusEventIfChanged()
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -855,17 +855,17 @@ public:
 
 protected:
   bool AlertOrConfirm(bool aAlert, const nsAString& aMessage,
                       mozilla::ErrorResult& aError);
 
 public:
   void Alert(mozilla::ErrorResult& aError);
   void Alert(const nsAString& aMessage, mozilla::ErrorResult& aError);
-  already_AddRefed<mozilla::dom::cache::CacheStorage> Caches();
+  already_AddRefed<mozilla::dom::cache::CacheStorage> GetCaches(mozilla::ErrorResult& aRv);
   bool Confirm(const nsAString& aMessage, mozilla::ErrorResult& aError);
   already_AddRefed<mozilla::dom::Promise> Fetch(const mozilla::dom::RequestOrScalarValueString& aInput,
                                                 const mozilla::dom::RequestInit& aInit,
                                                 mozilla::ErrorResult& aRv);
   void Prompt(const nsAString& aMessage, const nsAString& aInitial,
               nsAString& aReturn, mozilla::ErrorResult& aError);
   void Print(mozilla::ErrorResult& aError);
   void ShowModalDialog(JSContext* aCx, const nsAString& aUrl,
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
--- a/dom/cache/Action.h
+++ b/dom/cache/Action.h
@@ -34,17 +34,17 @@ public:
     virtual void Resolve(nsresult aRv)=0;
 
     NS_DECL_THREADSAFE_ISUPPORTS
   };
 
   // Execute operations on target thread. Once complete call
   // Resolver::Resolve().  This can be done sync or async.
   // Note: Action should hold Resolver ref until its ready to call Resolve().
-  virtual void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)=0;
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)=0;
 
   // Called on target thread if the Action is being canceled.  Simply
   // clean up and do not call Resolver::Resolve() in this case.
   // Note: Action must drop Resolver ref if CancelOnTarget() is called!
   virtual void CancelOnTarget() { }
 
   // Executed on the initiating thread and is passed the nsresult given to
   // Resolver::Resolve().
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -70,27 +70,26 @@ namespace cache {
 
 using mozilla::ErrorResult;
 using mozilla::unused;
 using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
 using mozilla::dom::workers::WorkerPrivate;
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::Cache);
 NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::Cache);
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mOwner, mGlobal)
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mGlobal)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Cache)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
-Cache::Cache(nsISupports* aOwner, nsIGlobalObject* aGlobal,
-             const nsACString& aOrigin, PCacheChild* aActor)
-  : mOwner(aOwner)
-  , mGlobal(aGlobal)
+Cache::Cache(nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+             PCacheChild* aActor)
+  : mGlobal(aGlobal)
   , mOrigin(aOrigin)
   , mActor(static_cast<CacheChild*>(aActor))
 {
   MOZ_ASSERT(mActor);
   mActor->SetListener(*this);
 }
 
 already_AddRefed<Promise>
@@ -345,17 +344,17 @@ Cache::PrefEnabled(JSContext* aCx, JSObj
   // Otherwise expose on ServiceWorkers.  Also expose on others workers if
   // pref enabled.
   return workerPrivate->IsServiceWorker() || workerPrivate->DOMCachesEnabled();
 }
 
 nsISupports*
 Cache::GetParentObject() const
 {
-  return mOwner;
+  return mGlobal;
 }
 
 JSObject*
 Cache::WrapObject(JSContext* aContext)
 {
   return CacheBinding::Wrap(aContext, this);
 }
 
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -38,18 +38,18 @@ class PCacheRequest;
 class PCacheRequestOrVoid;
 
 class Cache MOZ_FINAL : public nsISupports
                       , public nsWrapperCache
                       , public CacheChildListener
                       , public TypeUtils
 {
 public:
-  Cache(nsISupports* aOwner, nsIGlobalObject* aGlobal,
-        const nsACString& aOrigin, PCacheChild* aActor);
+  Cache(nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+        PCacheChild* aActor);
 
   // webidl interface methods
   already_AddRefed<Promise>
   Match(const RequestOrScalarValueString& aRequest, const QueryParams& aParams,
         ErrorResult& aRv);
   already_AddRefed<Promise>
   MatchAll(const Optional<RequestOrScalarValueString>& aRequest,
            const QueryParams& aParams, ErrorResult& aRv);
@@ -105,18 +105,16 @@ public:
 
 private:
   virtual ~Cache();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
 private:
-  // TODO: remove separate mOwner
-  nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   CacheChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Cache)
diff --git a/dom/cache/CacheInitData.ipdlh b/dom/cache/CacheInitData.ipdlh
--- a/dom/cache/CacheInitData.ipdlh
+++ b/dom/cache/CacheInitData.ipdlh
@@ -1,25 +1,24 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+include PBackgroundSharedTypes;
+
 using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 // Data needed to initialize a CacheStorage or Cache backend.  Don't put
 // this with the other types in PCacheTypes.ipdlh since we want to import
 // it into PBackground.ipdl.
 struct CacheInitData
 {
   Namespace namespaceEnum;
-  nsCString origin;
-  nsCString quotaGroup;
-  bool isApp;
-  bool hasUnlimStoragePerm;
+  PrincipalInfo principalInfo;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -21,20 +21,19 @@ namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::ipc::FileDescriptorSetParent;
 using mozilla::ipc::PFileDescriptorSetParent;
 
-CacheParent::CacheParent(const CacheInitData& aInitData,
-                         CacheId aCacheId)
-  : mCacheId(aCacheId)
-  , mManager(Manager::ForOrigin(aInitData))
+CacheParent::CacheParent(cache::Manager* aManager, CacheId aCacheId)
+  : mManager(aManager)
+  , mCacheId(aCacheId)
 {
   MOZ_ASSERT(mManager);
   mManager->AddRefCacheId(mCacheId);
 }
 
 CacheParent::~CacheParent()
 {
   MOZ_ASSERT(!mManager);
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -14,27 +14,26 @@
 
 struct nsID;
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class CacheInitData;
 class CacheDBConnection;
 struct SavedResponse;
 struct StreamHolder;
 
 class CacheParent MOZ_FINAL : public PCacheParent
                             , public Manager::Listener
                             , public FetchPut::Listener
 {
 public:
-  CacheParent(const CacheInitData& aInitData, CacheId aCacheId);
+  CacheParent(cache::Manager* aManager, CacheId aCacheId);
   virtual ~CacheParent();
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   // PCacheParent method
   virtual bool
   RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
             const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
@@ -74,18 +73,18 @@ private:
   Manager::StreamControl*
   SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
                       Manager::StreamList* aStreamList,
                       PCacheReadStream* aReadStreamOut);
 
   already_AddRefed<nsIInputStream>
   DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
 
+  nsRefPtr<cache::Manager> mManager;
   const CacheId mCacheId;
-  nsRefPtr<mozilla::dom::cache::Manager> mManager;
   nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheParent_h
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -6,70 +6,132 @@
 
 #include "mozilla/dom/cache/CacheStorage.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheStorageBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/Cache.h"
-#include "mozilla/dom/cache/CacheInitData.h"
 #include "mozilla/dom/cache/CacheStorageChild.h"
 #include "mozilla/dom/cache/PCacheChild.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "nsIGlobalObject.h"
+#include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ErrorResult;
+using mozilla::dom::workers::WorkerPrivate;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::IProtocol;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalToPrincipalInfo;
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::CacheStorage);
 NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::CacheStorage);
-NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CacheStorage, mOwner,
-                                                    mGlobal,
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CacheStorage, mGlobal,
                                                     mRequestPromises)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(CacheStorage)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
 NS_INTERFACE_MAP_END
 
+// static
+already_AddRefed<CacheStorage>
+CacheStorage::CreateOnMainThread(Namespace aNamespace,
+                                 nsIGlobalObject* aGlobal,
+                                 nsIPrincipal* aPrincipal,
+                                 ErrorResult& aRv)
+{
+  MOZ_ASSERT(aGlobal);
+  MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(NS_IsMainThread());
+
+  bool nullPrincipal;
+  nsresult rv = aPrincipal->GetIsNullPrincipal(&nullPrincipal);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  if (nullPrincipal) {
+    NS_WARNING("CacheStorage is not supported on this principal.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  nsAutoCString origin;
+  rv = aPrincipal->GetOrigin(getter_Copies(origin));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  PrincipalInfo principalInfo;
+  rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return nullptr;
+  }
+
+  nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal, origin,
+                                                principalInfo);
+  return ref.forget();
+}
+
+// static
+already_AddRefed<CacheStorage>
+CacheStorage::CreateOnWorker(Namespace aNamespace,
+                             nsIGlobalObject* aGlobal,
+                             WorkerPrivate* aWorkerPrivate,
+                             ErrorResult& aRv)
+{
+  MOZ_ASSERT(aGlobal);
+  MOZ_ASSERT(aWorkerPrivate);
+  aWorkerPrivate->AssertIsOnWorkerThread();
+
+  const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
+  if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
+    NS_WARNING("CacheStorage is not supported on this principal.");
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  NS_ConvertUTF16toUTF8 origin(aWorkerPrivate->GetLocationInfo().mOrigin);
+
+  nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal, origin,
+                                                principalInfo);
+  return ref.forget();
+}
+
 CacheStorage::CacheStorage(Namespace aNamespace,
-                           nsISupports* aOwner,
                            nsIGlobalObject* aGlobal,
                            const nsACString& aOrigin,
-                           const nsACString& aQuotaGroup,
-                           bool aIsApp, bool aHasUnlimStoragePerm)
+                           const PrincipalInfo& aPrincipalInfo)
   : mNamespace(aNamespace)
-  , mOwner(aOwner)
   , mGlobal(aGlobal)
   , mOrigin(aOrigin)
-  , mQuotaGroup(aQuotaGroup)
-  , mIsApp(aIsApp)
-  , mHasUnlimStoragePerm(aHasUnlimStoragePerm)
+  , mPrincipalInfo(aPrincipalInfo)
   , mActor(nullptr)
   , mFailedActor(false)
 {
   MOZ_ASSERT(mGlobal);
 
-  if (mOrigin.EqualsLiteral("null") || mQuotaGroup.EqualsLiteral("")) {
-    ActorFailed();
-    return;
-  }
-
   PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
   if (actor) {
     ActorCreated(actor);
   } else {
     bool ok = BackgroundChild::GetOrCreateForCurrentThread(this);
     if (!ok) {
       ActorFailed();
     }
@@ -254,17 +316,17 @@ bool
 CacheStorage::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   return Cache::PrefEnabled(aCx, aObj);
 }
 
 nsISupports*
 CacheStorage::GetParentObject() const
 {
-  return mOwner;
+  return mGlobal;
 }
 
 JSObject*
 CacheStorage::WrapObject(JSContext* aContext)
 {
   return mozilla::dom::CacheStorageBinding::Wrap(aContext, this);
 }
 
@@ -275,20 +337,18 @@ CacheStorage::ActorCreated(PBackgroundCh
   MOZ_ASSERT(aActor);
 
   CacheStorageChild* newActor = new CacheStorageChild(*this);
   if (NS_WARN_IF(!newActor)) {
     ActorFailed();
     return;
   }
 
-  CacheInitData initData(mNamespace, mOrigin, mQuotaGroup,
-                         mIsApp, mHasUnlimStoragePerm);
   PCacheStorageChild* constructedActor =
-    aActor->SendPCacheStorageConstructor(newActor, initData);
+    aActor->SendPCacheStorageConstructor(newActor, mNamespace, mPrincipalInfo);
 
   if (NS_WARN_IF(!constructedActor)) {
     ActorFailed();
     return;
   }
 
   MOZ_ASSERT(constructedActor == newActor);
   mActor = newActor;
@@ -356,16 +416,20 @@ CacheStorage::ActorFailed()
 void
 CacheStorage::ActorDestroy(IProtocol& aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
+
+  // Note that we will never get an actor again in case another request is
+  // made before this object is destructed.
+  ActorFailed();
 }
 
 void
 CacheStorage::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                                 const PCacheResponseOrVoid& aResponse)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
@@ -426,17 +490,17 @@ CacheStorage::RecvOpenResponse(RequestId
     return;
   }
 
   if (!aActor) {
     promise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
     return;
   }
 
-  nsRefPtr<Cache> cache = new Cache(mOwner, mGlobal, mOrigin, aActor);
+  nsRefPtr<Cache> cache = new Cache(mGlobal, mOrigin, aActor);
   promise->MaybeResolve(cache);
 }
 
 void
 CacheStorage::RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                  bool aSuccess)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -6,16 +6,17 @@
 
 #ifndef mozilla_dom_cache_CacheStorage_h
 #define mozilla_dom_cache_CacheStorage_h
 
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheStorageChildListener.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/cache/TypeUtils.h"
+#include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 
 class nsIGlobalObject;
@@ -26,36 +27,41 @@ class ErrorResult;
 
 namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
 
 class Promise;
-//struct QueryParams;
-//class RequestOrScalarValueString;
+
+namespace workers {
+  class WorkerPrivate;
+}
 
 namespace cache {
 
 class CacheStorageChild;
 class PCacheRequest;
 
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public CacheStorageChildListener
                              , public TypeUtils
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
-  CacheStorage(Namespace aNamespace, nsISupports* aOwner,
-               nsIGlobalObject* aGlobal, const nsACString& aOrigin,
-               const nsACString& aQuotaGroup, bool aIsApp,
-               bool aHasUnlimStoragePerm);
+  static already_AddRefed<CacheStorage>
+  CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
+                     nsIPrincipal* aPrincipal, ErrorResult& aRv);
+
+  static already_AddRefed<CacheStorage>
+  CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
+                 workers::WorkerPrivate* aWorkerPrivate, ErrorResult& aRv);
 
   // webidl interface methods
   already_AddRefed<Promise> Match(const RequestOrScalarValueString& aRequest,
                                   const QueryParams& aParams, ErrorResult& aRv);
   already_AddRefed<Promise> Has(const nsAString& aKey, ErrorResult& aRv);
   already_AddRefed<Promise> Open(const nsAString& aKey, ErrorResult& aRv);
   already_AddRefed<Promise> Delete(const nsAString& aKey, ErrorResult& aRv);
   already_AddRefed<Promise> Keys(ErrorResult& aRv);
@@ -86,31 +92,30 @@ public:
   // TypeUtils method
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
   virtual const nsACString& Origin() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
 private:
+  CacheStorage(Namespace aNamespace,
+               nsIGlobalObject* aGlobal, const nsACString& aOrigin,
+               const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
   virtual ~CacheStorage();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
   // Would like to use CacheInitData here, but we cannot because
   // its an IPC struct which breaks webidl by including windows.h.
   const Namespace mNamespace;
-  // TODO: remove separate mOwner
-  nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
-  const nsCString mQuotaGroup;
-  const bool mIsApp;
-  const bool mHasUnlimStoragePerm;
+  const mozilla::ipc::PrincipalInfo mPrincipalInfo;
   CacheStorageChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
   enum Op
   {
     OP_MATCH,
     OP_HAS,
     OP_OPEN,
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -1,103 +1,185 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorageParent.h"
 
+#include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/cache/CacheParent.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/InputStreamUtils.h"
-#include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-using mozilla::unused;
-using mozilla::void_t;
+using mozilla::ipc::PBackgroundParent;
 using mozilla::ipc::PFileDescriptorSetParent;
+using mozilla::ipc::PrincipalInfo;
 
-CacheStorageParent::CacheStorageParent(const CacheInitData& aInitData)
-  : mInitData(aInitData)
-  , mManager(Manager::ForOrigin(aInitData))
+CacheStorageParent::CacheStorageParent(PBackgroundParent* aManagingActor,
+                                       Namespace aNamespace,
+                                       const PrincipalInfo& aPrincipalInfo)
+  : mNamespace(aNamespace)
 {
-  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(aManagingActor);
+
+  nsresult rv = PrincipalVerifier::Create(this, aManagingActor, aPrincipalInfo,
+                                          getter_AddRefs(mVerifier));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    unused << Send__delete__(this);
+  }
 }
 
 CacheStorageParent::~CacheStorageParent()
 {
   MOZ_ASSERT(!mManager);
 }
 
 void
 CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  MOZ_ASSERT(mManager);
-  mManager->RemoveListener(this);
-  mManager = nullptr;
+  if (mManager) {
+    MOZ_ASSERT(mActiveRequests.Length() > 1);
+    mManager->RemoveListener(this);
+    mManager = nullptr;
+  }
 }
 
 bool
 CacheStorageParent::RecvMatch(const RequestId& aRequestId,
                               const PCacheRequest& aRequest,
                               const PCacheQueryParams& aParams)
 {
-  mManager->StorageMatch(this, aRequestId, mInitData.namespaceEnum(), aRequest,
-                         aParams);
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_MATCH;
+    entry->mRequestId = aRequestId;
+    entry->mRequest = aRequest;
+    entry->mParams = aParams;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageMatch(this, aRequestId, mNamespace, aRequest,
+                        aParams);
+
   return true;
 }
 
 bool
 CacheStorageParent::RecvHas(const RequestId& aRequestId, const nsString& aKey)
 {
-  mManager->StorageHas(this, aRequestId, mInitData.namespaceEnum(), aKey);
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_HAS;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageHas(this, aRequestId, mNamespace, aKey);
+
   return true;
 }
 
 bool
-CacheStorageParent::RecvOpen(const RequestId& aRequestId,
-                               const nsString& aKey)
+CacheStorageParent::RecvOpen(const RequestId& aRequestId, const nsString& aKey)
 {
-  mManager->StorageOpen(this, aRequestId, mInitData.namespaceEnum(), aKey);
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_OPEN;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageOpen(this, aRequestId, mNamespace, aKey);
+
   return true;
 }
 
 bool
 CacheStorageParent::RecvDelete(const RequestId& aRequestId,
                                const nsString& aKey)
 {
-  mManager->StorageDelete(this, aRequestId, mInitData.namespaceEnum(), aKey);
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_DELETE;
+    entry->mRequestId = aRequestId;
+    entry->mKey = aKey;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageDelete(this, aRequestId, mNamespace, aKey);
+
   return true;
 }
 
 bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
-  mManager->StorageKeys(this, aRequestId, mInitData.namespaceEnum());
+  if (!mManagerId) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mOp = OP_DELETE;
+    entry->mRequestId = aRequestId;
+    return true;
+  }
+
+  cache::Manager* manager = RequestManager(aRequestId);
+  manager->StorageKeys(this, aRequestId, mNamespace);
+
   return true;
 }
 
 void
+CacheStorageParent::OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)
+{
+  if (NS_WARN_IF(NS_FAILED(aRv))) {
+    FailPendingRequests(aRv);
+    unused << Send__delete__(this);
+    return;
+  }
+
+  MOZ_ASSERT(mVerifier);
+  MOZ_ASSERT(!mManagerId);
+  MOZ_ASSERT(!mManager);
+
+  mManagerId = aManagerId;
+  mVerifier->ClearListener();
+  mVerifier = nullptr;
+
+  RetryPendingRequests();
+}
+
+void
 CacheStorageParent::OnStorageMatch(RequestId aRequestId, nsresult aRv,
                                    const SavedResponse* aSavedResponse,
                                    Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
+  ReleaseManager(aRequestId);
+
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
     responseOrVoid = void_t();
     unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   // match without body data to stream
@@ -116,45 +198,53 @@ CacheStorageParent::OnStorageMatch(Reque
 
   unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheStorageParent::OnStorageHas(RequestId aRequestId, nsresult aRv,
                                  bool aCacheFound)
 {
+  ReleaseManager(aRequestId);
   unused << SendHasResponse(aRequestId, aRv, aCacheFound);
 }
 
 void
 CacheStorageParent::OnStorageOpen(RequestId aRequestId, nsresult aRv,
                                   CacheId aCacheId)
 {
   if (NS_FAILED(aRv)) {
+    ReleaseManager(aRequestId);
     unused << SendOpenResponse(aRequestId, aRv, nullptr);
     return;
   }
 
-  CacheParent* actor = new CacheParent(mInitData, aCacheId);
+  MOZ_ASSERT(mManager);
+  CacheParent* actor = new CacheParent(mManager, aCacheId);
+
+  ReleaseManager(aRequestId);
+
   PCacheParent* base = Manager()->SendPCacheConstructor(actor);
   actor = static_cast<CacheParent*>(base);
   unused << SendOpenResponse(aRequestId, aRv, actor);
 }
 
 void
 CacheStorageParent::OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                     bool aCacheDeleted)
 {
+  ReleaseManager(aRequestId);
   unused << SendDeleteResponse(aRequestId, aRv, aCacheDeleted);
 }
 
 void
 CacheStorageParent::OnStorageKeys(RequestId aRequestId, nsresult aRv,
                                   const nsTArray<nsString>& aKeys)
 {
+  ReleaseManager(aRequestId);
   unused << SendKeysResponse(aRequestId, aRv, aKeys);
 }
 
 Manager::StreamControl*
 CacheStorageParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
                                         const nsID& aId,
                                         Manager::StreamList* aStreamList,
                                         PCacheReadStream* aReadStreamOut)
@@ -176,11 +266,109 @@ CacheStorageParent::SerializeReadStream(
 
   nsRefPtr<ReadStream> readStream = ReadStream::Create(aStreamControl,
                                                        aId, stream);
   readStream->Serialize(aReadStreamOut);
 
   return aStreamControl;
 }
 
+void
+CacheStorageParent::RetryPendingRequests()
+{
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    switch(entry.mOp) {
+      case OP_MATCH:
+        RecvMatch(entry.mRequestId, entry.mRequest, entry.mParams);
+        break;
+      case OP_HAS:
+        RecvHas(entry.mRequestId, entry.mKey);
+        break;
+      case OP_OPEN:
+        RecvOpen(entry.mRequestId, entry.mKey);
+        break;
+      case OP_DELETE:
+        RecvDelete(entry.mRequestId, entry.mKey);
+        break;
+      case OP_KEYS:
+        RecvKeys(entry.mRequestId);
+        break;
+      default:
+        MOZ_ASSERT_UNREACHABLE("Pending request within unknown op");
+    }
+  }
+  mPendingRequests.Clear();
+}
+
+void
+CacheStorageParent::FailPendingRequests(nsresult aRv)
+{
+  MOZ_ASSERT(NS_FAILED(aRv));
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    switch(entry.mOp) {
+      case OP_MATCH:
+      {
+        PCacheResponseOrVoid responseOrVoid;
+        responseOrVoid = void_t();
+        unused << SendMatchResponse(entry.mRequestId, aRv, responseOrVoid);
+        break;
+      }
+      case OP_HAS:
+        unused << SendHasResponse(entry.mRequestId, aRv, false);
+        break;
+      case OP_OPEN:
+        unused << SendOpenResponse(entry.mRequestId, aRv, nullptr);
+        break;
+      case OP_DELETE:
+        unused << SendDeleteResponse(entry.mRequestId, aRv, false);
+        break;
+      case OP_KEYS:
+      {
+        const nsTArray<nsString> emptyKeys;
+        unused << SendKeysResponse(entry.mRequestId, aRv, emptyKeys);
+        break;
+      }
+      default:
+        MOZ_ASSERT_UNREACHABLE("Pending request within unknown op");
+    }
+  }
+  mPendingRequests.Clear();
+}
+
+cache::Manager*
+CacheStorageParent::RequestManager(RequestId aRequestId)
+{
+  MOZ_ASSERT(!mActiveRequests.Contains(aRequestId));
+  if (!mManager) {
+    MOZ_ASSERT(mActiveRequests.Length() < 1);
+    mManager = Manager::GetOrCreate(mManagerId);
+    MOZ_ASSERT(mManager);
+  }
+  mActiveRequests.AppendElement(aRequestId);
+  return mManager;
+}
+
+void
+CacheStorageParent::ReleaseManager(RequestId aRequestId)
+{
+  // Note that if the child process dies we also clean up the mManager in
+  // ActorDestroy().  There is no race with this method, however, because
+  // ActorDestroy removes this object from the Manager's listener list.
+  // Therefore ReleaseManager() should never be called after ActorDestroy()
+  // runs.
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mActiveRequests.Length() > 0);
+
+  DebugOnly<bool> removed = mActiveRequests.RemoveElement(aRequestId);
+  MOZ_ASSERT(removed);
+
+  if (mActiveRequests.Length() < 1) {
+    mManager->RemoveListener(this);
+    mManager = nullptr;
+  }
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -5,44 +5,53 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorageParent_h
 #define mozilla_dom_cache_CacheStorageParent_h
 
 #include "mozilla/dom/cache/CacheInitData.h"
 #include "mozilla/dom/cache/PCacheStorageParent.h"
 #include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PrincipalVerifier.h"
 #include "mozilla/dom/cache/Types.h"
 
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class ManagerId;
+
 class CacheStorageParent MOZ_FINAL : public PCacheStorageParent
+                                   , public PrincipalVerifier::Listener
                                    , public Manager::Listener
 {
 public:
-  CacheStorageParent(const CacheInitData& aInitData);
+  CacheStorageParent(PBackgroundParent* aManagingActor, Namespace aNamespace,
+                     const ipc::PrincipalInfo& aPrincipalInfo);
   virtual ~CacheStorageParent();
 
   // PCacheStorageParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvMatch(const RequestId& aRequestId,
                          const PCacheRequest& aRequest,
                          const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool RecvHas(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvOpen(const RequestId& aRequestId,
                         const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvDelete(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
+  // PrincipalVerifier::Listener methods
+  virtual void OnPrincipalVerified(nsresult aRv,
+                                   ManagerId* aManagerId) MOZ_OVERRIDE;
+
   // Manager::Listener methods
   virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
                             bool aCacheFound) MOZ_OVERRIDE;
   virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
                              CacheId aCacheId) MOZ_OVERRIDE;
@@ -52,17 +61,46 @@ public:
                              const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
   Manager::StreamControl*
   SerializeReadStream(Manager::StreamControl *aStreamControl, const nsID& aId,
                       Manager::StreamList* aStreamList,
                       PCacheReadStream* aReadStreamOut);
 
-  const CacheInitData mInitData;
-  nsRefPtr<mozilla::dom::cache::Manager> mManager;
+  void RetryPendingRequests();
+  void FailPendingRequests(nsresult aRv);
+
+  cache::Manager* RequestManager(RequestId aRequestId);
+  void ReleaseManager(RequestId aRequestId);
+
+  const Namespace mNamespace;
+  nsRefPtr<PrincipalVerifier> mVerifier;
+  nsRefPtr<ManagerId> mManagerId;
+  nsRefPtr<cache::Manager> mManager;
+
+  enum Op
+  {
+    OP_MATCH,
+    OP_HAS,
+    OP_OPEN,
+    OP_DELETE,
+    OP_KEYS
+  };
+
+  struct Entry
+  {
+    Op mOp;
+    RequestId mRequestId;
+    nsString mKey;
+    PCacheRequest mRequest;
+    PCacheQueryParams mParams;
+  };
+
+  nsTArray<Entry> mPendingRequests;
+  nsTArray<RequestId> mActiveRequests;
 };
 
 } // namesapce cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorageParent_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -3,61 +3,61 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Action.h"
-#include "mozilla/dom/cache/CacheInitData.h"
+#include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsIFile.h"
+#include "nsIPrincipal.h"
 #include "nsIRunnable.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::dom::Nullable;
+using mozilla::dom::cache::QuotaInfo;
 using mozilla::dom::quota::OriginOrPatternString;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
 using mozilla::dom::quota::PersistenceType;
 
 class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
 {
 public:
-  QuotaReleaseRunnable(const nsACString& aOrigin, const nsACString& aQuotaId)
-    : mOrigin(aOrigin)
+  QuotaReleaseRunnable(const QuotaInfo& aQuotaInfo, const nsACString& aQuotaId)
+    : mQuotaInfo(aQuotaInfo)
     , mQuotaId(aQuotaId)
-  {
-  }
+  { }
 
 private:
-  ~QuotaReleaseRunnable()
-  {}
+  ~QuotaReleaseRunnable() { }
 
-  const nsCString mOrigin;
+  const QuotaInfo mQuotaInfo;
   const nsCString mQuotaId;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
 
 NS_IMETHODIMP
 QuotaReleaseRunnable::Run()
 {
   MOZ_ASSERT(NS_IsMainThread());
   QuotaManager* qm = QuotaManager::Get();
   MOZ_ASSERT(qm);
-  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mOrigin),
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                               Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
                               mQuotaId);
   return NS_OK;
 }
 
 } // anonymous namespace
 
 namespace mozilla {
@@ -70,28 +70,29 @@ using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
 using mozilla::dom::quota::PersistenceType;
 
 class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
                                            , public Action::Resolver
 {
 public:
   QuotaInitRunnable(Context* aContext,
-                    const CacheInitData& aInitData,
+                    ManagerId* aManagerId,
                     const nsACString& aQuotaId,
                     Action* aQuotaIOThreadAction)
     : mContext(aContext)
-    , mInitData(aInitData)
+    , mManagerId(aManagerId)
     , mQuotaId(aQuotaId)
     , mQuotaIOThreadAction(aQuotaIOThreadAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
   {
     MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mManagerId);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mState == STATE_INIT);
 
@@ -139,131 +140,151 @@ private:
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
     mContext = nullptr;
     mQuotaIOThreadAction = nullptr;
   }
 
   nsRefPtr<Context> mContext;
-  const CacheInitData mInitData;
+  nsRefPtr<ManagerId> mManagerId;
   const nsCString mQuotaId;
   nsRefPtr<Action> mQuotaIOThreadAction;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   nsresult mResult;
-  nsCOMPtr<nsIFile> mQuotaDir;
+  QuotaInfo mQuotaInfo;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
                             Action::Resolver, nsIRunnable);
 
 NS_IMETHODIMP
 Context::QuotaInitRunnable::Run()
 {
-  QuotaManager* qm;
-  nsresult rv;
-
   switch(mState) {
     case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+    {
       MOZ_ASSERT(NS_IsMainThread());
-      qm = QuotaManager::GetOrCreate();
+      QuotaManager* qm = QuotaManager::GetOrCreate();
       if (!qm) {
         Resolve(NS_ERROR_FAILURE);
         return NS_OK;
       }
+
+      nsCOMPtr<nsIPrincipal> principal = mManagerId->Principal();
+      nsresult rv = qm->GetInfoFromPrincipal(principal,
+                                             PERSISTENCE_TYPE_PERSISTENT,
+                                             &mQuotaInfo.mGroup,
+                                             &mQuotaInfo.mOrigin,
+                                             &mQuotaInfo.mIsApp,
+                                             &mQuotaInfo.mHasUnlimStoragePerm);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+
       mState = STATE_WAIT_FOR_OPEN_ALLOWED;
-      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mInitData.origin()),
+      // TODO: use default storage instead of persistent
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                   Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
                                   mQuotaId, this);
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
       break;
+    }
     case STATE_WAIT_FOR_OPEN_ALLOWED:
+    {
       MOZ_ASSERT(NS_IsMainThread());
-      qm = QuotaManager::Get();
+      QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       mState = STATE_ENSURE_ORIGIN_INITIALIZED;
-      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         Resolve(rv);
         return NS_OK;
       }
       break;
+    }
     case STATE_ENSURE_ORIGIN_INITIALIZED:
-      // TODO: MOZ_ASSERT(NS_GetCurrentThread() == QuotaManager::Get()->IOThread());
-      qm = QuotaManager::Get();
+    {
+      // Can't assert quota IO thread because its an idle thread that can get
+      // recreated.
+      QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
-      rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
-                                         mInitData.quotaGroup(),
-                                         mInitData.origin(),
-                                         mInitData.isApp(),
-                                         mInitData.hasUnlimStoragePerm(),
-                                         getter_AddRefs(mQuotaDir));
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+                                                  mQuotaInfo.mGroup,
+                                                  mQuotaInfo.mOrigin,
+                                                  mQuotaInfo.mIsApp,
+                                                  mQuotaInfo.mHasUnlimStoragePerm,
+                                                  getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
+
       mState = STATE_RUNNING;
-      if (mQuotaIOThreadAction) {
-        nsCOMPtr<nsIFile> quotaDir;
-        rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
-        if (NS_FAILED(rv)) {
-          Resolve(rv);
-          return NS_OK;
-        }
-        mQuotaIOThreadAction->RunOnTarget(this, quotaDir);
-      } else {
+
+      if (!mQuotaIOThreadAction) {
         Resolve(NS_OK);
+        return NS_OK;
       }
+
+      mQuotaIOThreadAction->RunOnTarget(this, mQuotaInfo);
+
       break;
+    }
     case STATE_COMPLETING:
+    {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       if (mQuotaIOThreadAction) {
         mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
       }
-      mContext->OnQuotaInit(mResult, mQuotaDir);
+      mContext->OnQuotaInit(mResult, mQuotaInfo);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
+    }
     default:
+    {
       MOZ_CRASH("unexpected state in QuotaInitRunnable");
       break;
+    }
   }
 
   return NS_OK;
 }
 
 class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
                                         , public Action::Resolver
 {
 public:
   ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
-                 nsIFile* aQuotaDir)
+                 const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
-    , mQuotaDir(aQuotaDir)
+    , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mCanceled(false)
     , mResult(NS_OK)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
-    MOZ_ASSERT(mQuotaDir);
+    MOZ_ASSERT(mQuotaInfo.mDir);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mState == STATE_INIT);
 
@@ -348,17 +369,17 @@ private:
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   nsRefPtr<Context> mContext;
   nsCOMPtr<nsIEventTarget> mTarget;
   nsRefPtr<Action> mAction;
-  nsCOMPtr<nsIFile> mQuotaDir;
+  const QuotaInfo mQuotaInfo;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   bool mCanceled;
   nsresult mResult;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
@@ -378,17 +399,17 @@ Context::ActionRunnable::Run()
         mState = STATE_COMPLETING;
         rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
         if (NS_FAILED(rv)) {
           MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
         }
         break;
       }
       mState = STATE_RUNNING;
-      mAction->RunOnTarget(this, mQuotaDir);
+      mAction->RunOnTarget(this, mQuotaInfo);
       break;
     case STATE_RUNNING:
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       // We only re-enter the RUNNING state if we are canceling.  Normally we
       // should transition out of RUNNING via Resolve() instead.
       MOZ_ASSERT(mCanceled);
       mState = STATE_COMPLETING;
       mAction->CancelOnTarget();
@@ -414,26 +435,27 @@ Context::ActionRunnable::Run()
       break;
     default:
       MOZ_CRASH("unexpected state in ActionRunnable");
       break;
   }
   return NS_OK;
 }
 
-Context::Context(Listener* aListener, const CacheInitData& aInitData,
+Context::Context(Listener* aListener, ManagerId* aManagerId,
                  Action* aQuotaIOThreadAction)
   : mListener(aListener)
-  , mOrigin(aInitData.origin())
+  , mManagerId(aManagerId)
   , mState(STATE_CONTEXT_INIT)
 {
   MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mManagerId);
 
   nsRefPtr<QuotaInitRunnable> runnable =
-    new QuotaInitRunnable(this, aInitData, NS_LITERAL_CSTRING("Cache"),
+    new QuotaInitRunnable(this, mManagerId, NS_LITERAL_CSTRING("Cache"),
                           aQuotaIOThreadAction);
   nsresult rv = runnable->Dispatch();
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
   }
 }
 
 void
@@ -485,63 +507,55 @@ Context::CancelForCacheId(CacheId aCache
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mListener);
 
   // Unlock the quota dir as we go out of scope.
   nsCOMPtr<nsIRunnable> runnable =
-    new QuotaReleaseRunnable(mOrigin, NS_LITERAL_CSTRING("Cache"));
+    new QuotaReleaseRunnable(mQuotaInfo, NS_LITERAL_CSTRING("Cache"));
   nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
   }
 
   mListener->RemoveContext(this);
 }
 
 void
 Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
-  nsCOMPtr<nsIFile> quotaDir;
-  nsresult rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aAction->CompleteOnInitiatingThread(rv);
-    return;
-  }
-
   nsRefPtr<ActionRunnable> runnable =
-    new ActionRunnable(this, aTarget, aAction, quotaDir);
+    new ActionRunnable(this, aTarget, aAction, mQuotaInfo);
   mActionRunnables.AppendElement(runnable);
-  rv = runnable->Dispatch();
+  nsresult rv = runnable->Dispatch();
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
   }
 }
 
 void
-Context::OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir)
+Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
 
   if (NS_FAILED(aRv)) {
     for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
     // Context will destruct after return here and last ref is released.
     return;
   }
 
-  mQuotaDir = aQuotaDir;
-  MOZ_ASSERT(mQuotaDir);
+  mQuotaInfo = aQuotaInfo;
   mState = STATE_CONTEXT_READY;
 
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
   }
   mPendingActions.Clear();
 }
 
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
--- a/dom/cache/Context.h
+++ b/dom/cache/Context.h
@@ -17,34 +17,34 @@
 class nsIEventTarget;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Action;
-class CacheInitData;
+class ManagerId;
 
 class Context MOZ_FINAL
 {
 public:
   class Listener
   {
   protected:
     virtual ~Listener() { }
   public:
     // Called from the Context destructor on the thread that originally
     // created the Context.
     virtual void RemoveContext(Context* aContext)=0;
 
     NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context::Listener)
   };
 
-  Context(Listener* aListener, const CacheInitData& aInitData,
+  Context(Listener* aListener, ManagerId* aManagerId,
           Action* aQuotaIOThreadAction);
 
   // Execute given action on the target once the quota manager has been
   // initialized.
   //
   // Only callable from the thread that created the Context.
   void Dispatch(nsIEventTarget* aTarget, Action* aAction);
 
@@ -75,23 +75,23 @@ private:
   struct PendingAction
   {
     nsCOMPtr<nsIEventTarget> mTarget;
     nsRefPtr<Action> mAction;
   };
 
   ~Context();
   void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
-  void OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo);
   void OnActionRunnableComplete(ActionRunnable* const aAction);
 
   nsRefPtr<Listener> mListener;
-  const nsCString mOrigin;
+  nsRefPtr<ManagerId> mManagerId;
   State mState;
-  nsCOMPtr<nsIFile> mQuotaDir;
+  QuotaInfo mQuotaInfo;
   nsTArray<PendingAction> mPendingActions;
 
   // weak refs since ~ActionRunnable() removes itself from this list
   nsTArray<ActionRunnable*> mActionRunnables;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context)
 };
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -16,47 +16,58 @@
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
 using mozilla::dom::quota::PersistenceType;
 
-DBAction::DBAction(Mode aMode, const CacheInitData& aInitData)
+DBAction::DBAction(Mode aMode)
   : mMode(aMode)
-  , mInitData(aInitData)
+{
+}
+
+DBAction::~DBAction()
 {
 }
 
 void
-DBAction::RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)
+DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)
 {
   MOZ_ASSERT(aResolver);
-  MOZ_ASSERT(aQuotaDir);
+  MOZ_ASSERT(aQuotaInfo.mDir);
 
-  nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+  nsCOMPtr<nsIFile> dbDir;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  rv = dbDir->Append(NS_LITERAL_STRING("cache"));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
 
   nsCOMPtr<mozIStorageConnection> conn;
-  rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
+  rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
   MOZ_ASSERT(conn);
 
-  RunWithDBOnTarget(aResolver, aQuotaDir, conn);
+  RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
-DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
+DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                         mozIStorageConnection** aConnOut)
 {
   MOZ_ASSERT(aDBDir);
   MOZ_ASSERT(aConnOut);
 
   bool exists;
   nsresult rv = aDBDir->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -81,30 +92,32 @@ DBAction::OpenConnection(nsIFile* aDBDir
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = dbTmpDir->Append(NS_LITERAL_STRING("db"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
   //      but this is what IDB does to access mozIStorageConnection so
   //      it seems at least this corner case mostly works.
+  // TODO: move this to main thread where GetInfoFromPrincipal() is executed
   nsCOMPtr<nsIURI> uri;
   rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
   if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
 
+  // TODO: use default storage
   nsAutoCString type;
   PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
 
   rv = dbFileUrl->SetQuery(
     NS_LITERAL_CSTRING("persistenceType=") + type +
-    NS_LITERAL_CSTRING("&group=") + mInitData.quotaGroup() +
-    NS_LITERAL_CSTRING("&origin=") + mInitData.origin());
+    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
+    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<mozIStorageService> ss =
     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
   if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
 
   rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
   if (rv == NS_ERROR_FILE_CORRUPTED) {
@@ -125,28 +138,33 @@ DBAction::OpenConnection(nsIFile* aDBDir
 
     rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   MOZ_ASSERT(*aConnOut);
   return rv;
 }
 
-SyncDBAction::SyncDBAction(Mode aMode, const CacheInitData& aInitData)
-  : DBAction(aMode, aInitData)
+SyncDBAction::SyncDBAction(Mode aMode)
+  : DBAction(aMode)
+{
+}
+
+SyncDBAction::~SyncDBAction()
 {
 }
 
 void
-SyncDBAction::RunWithDBOnTarget(Resolver* aResolver, nsIFile* aQuotaDir,
+SyncDBAction::RunWithDBOnTarget(Resolver* aResolver,
+                                const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                                 mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(aResolver);
-  MOZ_ASSERT(aQuotaDir);
+  MOZ_ASSERT(aDBDir);
   MOZ_ASSERT(aConn);
 
-  nsresult rv = RunSyncWithDBOnTarget(aQuotaDir, aConn);
+  nsresult rv = RunSyncWithDBOnTarget(aQuotaInfo, aDBDir, aConn);
   aResolver->Resolve(rv);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_DBAction_h
 #define mozilla_dom_cache_DBAction_h
 
 #include "mozilla/dom/cache/Action.h"
 #include "mozilla/dom/cache/CacheInitData.h"
+#include "nsRefPtr.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
@@ -22,47 +23,48 @@ class DBAction : public Action
 {
 protected:
   enum Mode
   {
     Existing,
     Create
   };
 
-  DBAction(Mode aMode, const CacheInitData& aInitData);
+  DBAction(Mode aMode);
+  virtual ~DBAction();
 
   // Just as the resolver must be ref'd until cancel or resolve, you may also
   // ref the DB connection.  The connection can only be referenced from the
   // target thread and must be released upon cancel or resolve.
-  virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
-                                 mozIStorageConnection* aConn)=0;
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn)=0;
 
-  virtual
-  void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
-
-  virtual ~DBAction() { }
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE;
 
 private:
-  nsresult OpenConnection(nsIFile* aQuotaDir, mozIStorageConnection** aConnOut);
+  nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
+                          mozIStorageConnection** aConnOut);
 
   const Mode mMode;
-  const CacheInitData mInitData;
 };
 
 class SyncDBAction : public DBAction
 {
 protected:
-  SyncDBAction(Mode aMode, const CacheInitData& aInitData);
+  SyncDBAction(Mode aMode);
+  virtual ~SyncDBAction();
 
-  virtual ~SyncDBAction() { }
+  virtual nsresult
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                        mozIStorageConnection* aConn)=0;
 
-  virtual nsresult RunSyncWithDBOnTarget(nsIFile* aDBDir,
-                                         mozIStorageConnection* aConn)=0;
-
-  virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
-                                 mozIStorageConnection* aConn) MOZ_OVERRIDE;
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
--- a/dom/cache/FetchPut.cpp
+++ b/dom/cache/FetchPut.cpp
@@ -10,16 +10,17 @@
 #include "mozilla/dom/FetchDriver.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/ResponseBinding.h"
 #include "mozilla/dom/UnionTypes.h"
+#include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "nsContentUtils.h"
 #include "nsNetUtil.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
@@ -131,16 +132,17 @@ FetchPut::FetchPut(Listener* aListener, 
   , mRequestId(aRequestId)
   , mCacheId(aCacheId)
   , mInitiatingThread(NS_GetCurrentThread())
   , mStateList(aRequests.Length())
   , mPendingCount(0)
   , mResult(NS_OK)
 {
   MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mManager);
   MOZ_ASSERT(aRequests.Length() == aRequestStreams.Length());
 
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
     State* s = mStateList.AppendElement();
     s->mPCacheRequest = aRequests[i];
     s->mRequestStream = aRequestStreams[i];
   }
 
@@ -187,39 +189,18 @@ FetchPut::DispatchToInitiatingThread()
   mRunnable = nullptr;
 }
 
 void
 FetchPut::DoFetchOnMainThread()
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsCOMPtr<nsIURI> uri;
-  nsresult rv = NS_NewURI(getter_AddRefs(uri), mManager->Origin());
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    MaybeSetError(rv);
-    MaybeCompleteOnMainThread();
-    return;
-  }
-
-  nsCOMPtr<nsIScriptSecurityManager> ssm = nsContentUtils::GetSecurityManager();
-  if (!ssm) {
-    MaybeSetError(NS_ERROR_UNEXPECTED);
-    MaybeCompleteOnMainThread();
-    return;
-  }
-
-  nsCOMPtr<nsIPrincipal> principal;
-  rv = ssm->GetSimpleCodebasePrincipal(uri, getter_AddRefs(principal));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    MaybeSetError(rv);
-    MaybeCompleteOnMainThread();
-    return;
-  }
-
+  nsRefPtr<ManagerId> managerId = mManager->GetManagerId();
+  nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
   mPendingCount = mStateList.Length();
 
   for (uint32_t i = 0; i < mStateList.Length(); ++i) {
     nsRefPtr<InternalRequest> internalRequest =
       ToInternalRequest(mStateList[i].mPCacheRequest);
 
     // If there is a stream we must clone it so that its still available
     // to store in the cache later;
@@ -233,17 +214,17 @@ FetchPut::DoFetchOnMainThread()
 
       internalRequest = clone;
     }
 
     nsRefPtr<FetchDriver> fetchDriver = new FetchDriver(internalRequest,
                                                         principal);
 
     mStateList[i].mFetchObserver = new FetchObserver(this);
-    rv = fetchDriver->Fetch(mStateList[i].mFetchObserver);
+    nsresult rv = fetchDriver->Fetch(mStateList[i].mFetchObserver);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       MaybeSetError(rv);
       mStateList[i].mFetchObserver = nullptr;
       mPendingCount -= 1;
       continue;
     }
   }
 
@@ -432,17 +413,18 @@ nsIGlobalObject*
 FetchPut::GetGlobalObject() const
 {
   MOZ_CRASH("No global object in parent-size FetchPut operation!");
 }
 
 const nsACString&
 FetchPut::Origin() const
 {
-  return mManager->Origin();
+  nsRefPtr<ManagerId> managerId = mManager->GetManagerId();
+  return managerId->Origin();
 }
 
 #ifdef DEBUG
 void
 FetchPut::AssertOwningThread() const
 {
   MOZ_ASSERT(mInitiatingThread == NS_GetCurrentThread());
 }
diff --git a/dom/cache/FetchPut.h b/dom/cache/FetchPut.h
--- a/dom/cache/FetchPut.h
+++ b/dom/cache/FetchPut.h
@@ -45,17 +45,17 @@ public:
   class Listener
   {
   public:
     virtual void
     OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId, nsresult aRv)=0;
   };
 
   static nsresult
-  Create(Listener* aListener, Manager* mManager,
+  Create(Listener* aListener, Manager* aManager,
          RequestId aRequestId, CacheId aCacheId,
          const nsTArray<PCacheRequest>& aRequests,
          const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreams,
          FetchPut** aFetchPutOut);
 
   void ClearListener();
 
 private:
@@ -97,17 +97,16 @@ private:
 
   // TypeUtils methods
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
   virtual const nsACString& Origin() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
-  // TODO remove ref counting on owner since its an actor
   Listener* mListener;
   nsRefPtr<Manager> mManager;
   const RequestId mRequestId;
   const CacheId mCacheId;
   nsCOMPtr<nsIThread> mInitiatingThread;
   nsTArray<State> mStateList;
   uint32_t mPendingCount;
   nsresult mResult;
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -1,17 +1,16 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/FileUtils.h"
 
-#include "mozilla/dom/cache/CacheInitData.h"
 #include "mozilla/dom/quota/FileStreams.h"
 #include "mozilla/unused.h"
 #include "nsIFile.h"
 #include "nsIUUIDGenerator.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
@@ -134,17 +133,17 @@ FileUtils::BodyIdToFile(nsIFile* aBaseDi
   rv = (*aBodyFileOut)->Append(fileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyStartWriteStream(const CacheInitData& aInitData,
+FileUtils::BodyStartWriteStream(const QuotaInfo& aQuotaInfo,
                                 nsIFile* aBaseDir, nsIInputStream* aSource,
                                 void* aClosure,
                                 nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
                                 nsISupports** aCopyContextOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aSource);
   MOZ_ASSERT(aClosure);
@@ -173,20 +172,20 @@ FileUtils::BodyStartWriteStream(const Ca
   nsCOMPtr<nsIFile> tmpFile;
   rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = tmpFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
+  // TODO: use default storage
   nsCOMPtr<nsIOutputStream> fileStream =
-    FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
-                             aInitData.quotaGroup(), aInitData.origin(),
-                             tmpFile);
+    FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aQuotaInfo.mGroup,
+                             aQuotaInfo.mOrigin, tmpFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
   // By default we would prefer to just use ReadSegments to copy buffers.
   nsAsyncCopyMode mode = NS_ASYNCCOPY_VIA_READSEGMENTS;
 
   // But first we must check to see if the source stream provides ReadSegments.
   // If it does not, use a buffered output stream to write to the file.  We don't
   // wrap the input because because that can lead to it being closed on the wrong
@@ -195,16 +194,18 @@ FileUtils::BodyStartWriteStream(const Ca
     nsCOMPtr<nsIOutputStream> buffered;
     rv = NS_NewBufferedOutputStream(getter_AddRefs(buffered), fileStream, 4096);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     fileStream = buffered.forget();
     mode = NS_ASYNCCOPY_VIA_WRITESEGMENTS;
   }
 
+  // TODO: we should be able to auto-close now...
+
   // Note, we cannot auto-close the source stream here because some of
   // our source streams must be closed on the PBackground worker thread.
   rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(), mode,
                     4096, // chunk size
                     aCallback, aClosure,
                     false, true, // close streams
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -265,97 +266,45 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   rv = tmpFile->RenameTo(finalDir, finalFileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyOpen(const CacheInitData& aInitData, nsIFile* aBaseDir,
+FileUtils::BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
                     const nsID& aId, nsIInputStream** aStreamOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aStreamOut);
 
   nsCOMPtr<nsIFile> finalFile;
   nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
                              getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
 
+  // TODO: use default storage
   nsCOMPtr<nsIInputStream> fileStream =
-    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aInitData.quotaGroup(),
-                            aInitData.origin(), finalFile);
+    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aQuotaInfo.mGroup,
+                            aQuotaInfo.mOrigin, finalFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
   fileStream.forget(aStreamOut);
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyStartReadStream(const CacheInitData& aInitData,
-                               nsIFile* aBaseDir,
-                               const nsID& aId, nsIOutputStream* aDest,
-                               void* aClosure,
-                               nsAsyncCopyCallbackFun aCallback,
-                               nsISupports** aCopyContextOut)
-{
-  MOZ_ASSERT(aBaseDir);
-  MOZ_ASSERT(aDest);
-  MOZ_ASSERT(aClosure);
-  MOZ_ASSERT(aCallback);
-  MOZ_ASSERT(aCopyContextOut);
-
-  nsCOMPtr<nsIFile> finalFile;
-  nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
-                             getter_AddRefs(finalFile));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool exists;
-  rv = finalFile->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
-
-  nsCOMPtr<nsIInputStream> fileStream =
-    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aInitData.quotaGroup(),
-                            aInitData.origin(), finalFile);
-  if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
-
-  rv = NS_AsyncCopy(fileStream, aDest, NS_GetCurrentThread(),
-                    NS_ASYNCCOPY_VIA_READSEGMENTS,
-                    4096, // chunk size
-                    aCallback, aClosure,
-                    true, true, // close streams
-                    aCopyContextOut);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    fileStream->Close();
-    return rv;
-  }
-
-  return rv;
-}
-
-// static
-void
-FileUtils::BodyCancelRead(nsISupports* aCopyContext)
-{
-  MOZ_ASSERT(aCopyContext);
-  nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
-  unused << NS_WARN_IF(NS_FAILED(rv));
-}
-
-// static
-nsresult
 FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList)
 {
   nsresult rv = NS_OK;
 
   for (uint32_t i = 0; i < aIdList.Length(); ++i) {
     nsCOMPtr<nsIFile> finalFile;
     rv = BodyIdToFile(aBaseDir, aIdList[i], BODY_FILE_FINAL,
                       getter_AddRefs(finalFile));
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -14,18 +14,16 @@
 struct nsID;
 class nsIFile;
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class CacheInitData;
-
 class FileUtils MOZ_FINAL
 {
 public:
   enum BodyFileType
   {
     BODY_FILE_FINAL,
     BODY_FILE_TMP
   };
@@ -34,41 +32,33 @@ public:
   static nsresult BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
                                   nsIFile** aCacheDirOut);
 
   static nsresult
   BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
                nsIFile** aBodyFileOut);
 
   static nsresult
-  BodyStartWriteStream(const CacheInitData& aInitData, nsIFile* aBaseDir,
+  BodyStartWriteStream(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
                        nsIInputStream* aSource, void* aClosure,
                        nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
                        nsISupports** aCopyContextOut);
 
   static void
   BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
                   nsISupports* aCopyContext);
 
   static nsresult
   BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
 
   static nsresult
-  BodyOpen(const CacheInitData& aInitData, nsIFile* aBaseDir, const nsID& aId,
+  BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
            nsIInputStream** aStreamOut);
 
   static nsresult
-  BodyStartReadStream(const CacheInitData& aInitData, nsIFile* aBaseDir,
-                      const nsID& aId, nsIOutputStream* aDest, void* aClosure,
-                      nsAsyncCopyCallbackFun aCallback,
-                      nsISupports** aCopyContextOut);
-
-  static void BodyCancelRead(nsISupports* aCopyContext);
-
-  static nsresult
   BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
 
 private:
   FileUtils() MOZ_DELETE;
   ~FileUtils() MOZ_DELETE;
 };
 
 } // namespace cache
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -4,44 +4,45 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
+#include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/ShutdownObserver.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsAutoPtr.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
 
 namespace {
 
-using mozilla::dom::cache::CacheInitData;
 using mozilla::dom::cache::DBSchema;
 using mozilla::dom::cache::FileUtils;
+using mozilla::dom::cache::QuotaInfo;
 using mozilla::dom::cache::SyncDBAction;
 
 class SetupAction MOZ_FINAL : public SyncDBAction
 {
 public:
-  SetupAction(const CacheInitData& aInitData)
-    : SyncDBAction(DBAction::Create, aInitData)
+  SetupAction()
+    : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     // TODO: init maintainance marker
     // TODO: perform maintainance if necessary
     // TODO: find orphaned caches in database
     // TODO: have Context create/delete marker files in constructor/destructor
     //       and only do expensive maintenance if that marker is present
 
@@ -82,35 +83,35 @@ public:
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
       sFactory = new Factory();
     }
     return *sFactory;
   }
 
-  already_AddRefed<Manager> GetOrCreate(const CacheInitData& aInitData)
+  already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
-    nsRefPtr<Manager> ref = Get(aInitData.origin());
+    nsRefPtr<Manager> ref = Get(aManagerId);
     if (!ref) {
-      ref = new Manager(aInitData);
+      ref = new Manager(aManagerId);
       mManagerList.AppendElement(ref);
     }
 
     return ref.forget();
   }
 
-  already_AddRefed<Manager> Get(const nsACString& aOrigin)
+  already_AddRefed<Manager> Get(ManagerId* aManagerId)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
-      if (mManagerList[i]->Origin() == aOrigin) {
+      if (*mManagerList[i]->mManagerId == *aManagerId) {
         nsRefPtr<Manager> ref = mManagerList[i];
         return ref.forget();
       }
     }
 
     return nullptr;
   }
 
@@ -135,17 +136,17 @@ public:
 
 // static
 Manager::Factory* Manager::Factory::sFactory = nullptr;
 
 class Manager::BaseAction : public SyncDBAction
 {
 protected:
   BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
-    : SyncDBAction(DBAction::Existing, aManager->mInitData)
+    : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId (aRequestId)
   { }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv)=0;
 
@@ -174,28 +175,35 @@ public:
   { }
 
   DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
     mDeletedBodyIdList.AppendElement(aBodyId);
   }
 
   virtual void
-  RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
-    MOZ_ASSERT(aQuotaDir);
+    MOZ_ASSERT(aQuotaInfo.mDir);
 
-    nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+    nsCOMPtr<nsIFile> dbDir;
+    nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
-    rv = FileUtils::BodyDeleteFiles(aQuotaDir, mDeletedBodyIdList);
+    rv = dbDir->Append(NS_LITERAL_STRING("cache"));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+
+    rv = FileUtils::BodyDeleteFiles(dbDir, mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
     aResolver->Resolve(rv);
   }
 
@@ -203,23 +211,23 @@ private:
   virtual ~DeleteOrphanedBodyAction() { }
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
 class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
-    : SyncDBAction(DBAction::Existing, aManager->mInitData)
+    : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mCacheId(aCacheId)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = DBSchema::DeleteCache(aConn, mCacheId, mDeletedBodyIdList);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -255,29 +263,29 @@ public:
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
     , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     nsresult rv = DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
                                        &mFoundResponse, &mResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = FileUtils::BodyOpen(mManager->mInitData, aDBDir, mResponse.mBodyId,
+    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId,
                              getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mResponse.mBodyId, stream);
 
     return rv;
   }
@@ -320,30 +328,30 @@ public:
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
     , mStreamList(aStreamList)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     nsresult rv = DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid,
                                           mParams, mSavedResponses);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
       if (!mSavedResponses[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = FileUtils::BodyOpen(mManager->mInitData, aDBDir,
+      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
                                mSavedResponses[i].mBodyId,
                                getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedResponses[i].mBodyId, stream);
     }
 
@@ -375,17 +383,17 @@ protected:
 class Manager::CachePutAllAction MOZ_FINAL : public DBAction
 {
 public:
   CachePutAllAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const nsTArray<CacheRequestResponse>& aPutList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
-    : DBAction(DBAction::Existing, aManager->mInitData)
+    : DBAction(DBAction::Existing)
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mList(aPutList.Length())
     , mExpectedAsyncCopyCompletions(0)
   {
     MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
@@ -399,18 +407,18 @@ public:
       entry->mResponseStream = aResponseStreamList[i];
 
       mExpectedAsyncCopyCompletions += entry->mRequestStream ? 1 : 0;
       mExpectedAsyncCopyCompletions += entry->mResponseStream ? 1 : 0;
     }
   }
 
   virtual void
-  RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
-                    mozIStorageConnection* aConn) MOZ_OVERRIDE
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
     MOZ_ASSERT(aDBDir);
     MOZ_ASSERT(aConn);
     MOZ_ASSERT(!mResolver);
     MOZ_ASSERT(!mDBDir);
     MOZ_ASSERT(!mConn);
 
@@ -421,26 +429,26 @@ public:
     if (mExpectedAsyncCopyCompletions < 1) {
       mExpectedAsyncCopyCompletions = 1;
       OnAsyncCopyComplete(NS_OK);
       return;
     }
 
     nsresult rv = NS_OK;
     for (uint32_t i = 0; i < mList.Length(); ++i) {
-      rv = StartStreamCopy(mList[i].mRequestStream,
+      rv = StartStreamCopy(aQuotaInfo, mList[i].mRequestStream,
                            &mList[i].mRequestBodyId,
                            getter_AddRefs(mList[i].mRequestCopyContext));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         CancelAllStreamCopying();
         DoResolve(rv);
         return;
       }
 
-      rv = StartStreamCopy(mList[i].mResponseStream,
+      rv = StartStreamCopy(aQuotaInfo, mList[i].mResponseStream,
                            &mList[i].mResponseBodyId,
                            getter_AddRefs(mList[i].mResponseCopyContext));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         CancelAllStreamCopying();
         DoResolve(rv);
         return;
       }
     }
@@ -543,34 +551,30 @@ public:
   {
     return aCacheId == mCacheId;
   }
 
 private:
   virtual ~CachePutAllAction() { }
 
   nsresult
-  StartStreamCopy(nsIInputStream* aSource, nsID* aIdOut,
-                  nsISupports** aCopyContextOut)
+  StartStreamCopy(const QuotaInfo& aQuotaInfo, nsIInputStream* aSource,
+                  nsID* aIdOut, nsISupports** aCopyContextOut)
   {
     MOZ_ASSERT(aIdOut);
     MOZ_ASSERT(aCopyContextOut);
     MOZ_ASSERT(mDBDir);
 
     if (!aSource) {
       return NS_OK;
     }
 
-    nsresult rv = FileUtils::BodyStartWriteStream(mManager->mInitData,
-                                                  mDBDir,
-                                                  aSource,
-                                                  this,
-                                                  AsyncCopyCompleteFunc,
-                                                  aIdOut,
-                                                  aCopyContextOut);
+    nsresult rv = FileUtils::BodyStartWriteStream(aQuotaInfo, mDBDir, aSource,
+                                                  this, AsyncCopyCompleteFunc,
+                                                  aIdOut, aCopyContextOut);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
   void
   CancelAllStreamCopying()
   {
@@ -661,17 +665,17 @@ public:
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequest(aRequest)
     , mParams(aParams)
     , mSuccess(false)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = DBSchema::CacheDelete(aConn, mCacheId, mRequest, mParams,
                                         mDeletedBodyIdList, &mSuccess);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -717,30 +721,30 @@ public:
     : BaseAction(aManager, aListenerId, aRequestId)
     , mCacheId(aCacheId)
     , mRequestOrVoid(aRequestOrVoid)
     , mParams(aParams)
     , mStreamList(aStreamList)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     nsresult rv = DBSchema::CacheKeys(aConn, mCacheId, mRequestOrVoid, mParams,
                                       mSavedRequests);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
       if (!mSavedRequests[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = FileUtils::BodyOpen(mManager->mInitData, aDBDir,
+      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
                                mSavedRequests[i].mBodyId,
                                getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedRequests[i].mBodyId, stream);
     }
 
@@ -781,30 +785,30 @@ public:
     , mNamespace(aNamespace)
     , mRequest(aRequest)
     , mParams(aParams)
     , mStreamList(aStreamList)
     , mFoundResponse(false)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     nsresult rv = DBSchema::StorageMatch(aConn, mNamespace, mRequest, mParams,
                                          &mFoundResponse, &mSavedResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mSavedResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = FileUtils::BodyOpen(mManager->mInitData, aDBDir,
-                             mSavedResponse.mBodyId, getter_AddRefs(stream));
+    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
+                             getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mSavedResponse.mBodyId, stream);
 
     return rv;
   }
 
@@ -838,17 +842,17 @@ public:
                    const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mKey(aKey)
     , mCacheFound(false)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     CacheId cacheId;
     return DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
                                        &mCacheFound, &cacheId);
   }
 
   virtual void
@@ -872,17 +876,17 @@ public:
                     const nsAString& aKey)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mKey(aKey)
     , mCacheId(0)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     // Look for existing cache
     bool cacheFound;
     nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
                                               &cacheFound, &mCacheId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (cacheFound) {
@@ -927,17 +931,17 @@ public:
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
     , mKey(aKey)
     , mCacheDeleted(false)
     , mCacheId(0)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     bool exists;
     nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey, &exists,
                                               &mCacheId);
@@ -990,17 +994,17 @@ class Manager::StorageKeysAction MOZ_FIN
 public:
   StorageKeysAction(Manager* aManager, ListenerId aListenerId,
                       RequestId aRequestId, Namespace aNamespace)
     : BaseAction(aManager, aListenerId, aRequestId)
     , mNamespace(aNamespace)
   { }
 
   virtual nsresult
-  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+  RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     return DBSchema::StorageGetKeys(aConn, mNamespace, mKeys);
   }
 
   virtual void
   Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
   {
@@ -1138,28 +1142,28 @@ Manager::StreamList::~StreamList()
       mManager->ReleaseBodyId(mList[i].mId);
     }
     mManager->ReleaseCacheId(mCacheId);
   }
 }
 
 // static
 already_AddRefed<Manager>
-Manager::ForOrigin(const CacheInitData& aInitData)
+Manager::GetOrCreate(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-  return Factory::Instance().GetOrCreate(aInitData);
+  return Factory::Instance().GetOrCreate(aManagerId);
 }
 
 // static
 already_AddRefed<Manager>
-Manager::ForExistingOrigin(const nsACString& aOrigin)
+Manager::Get(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
-  return Factory::Instance().Get(aOrigin);
+  return Factory::Instance().Get(aManagerId);
 }
 
 void
 Manager::RemoveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   mListeners.RemoveElement(aListener);
 }
@@ -1229,25 +1233,32 @@ Manager::Shutdown()
   for (uint32_t i = 0; i < mStreamLists.Length(); ++i) {
     mStreamLists[i]->CloseAll();
   }
 
   // If there is no context, then note that we're done shutting down
   if (!mContext) {
     nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
     if (so) {
-      so->RemoveOrigin(mInitData.origin());
+      so->RemoveManagerId(mManagerId);
     }
 
   // Otherwise, cancel the context and note complete when it cleans up
   } else {
     mContext->CancelAll();
   }
 }
 
+already_AddRefed<ManagerId>
+Manager::GetManagerId() const
+{
+  nsRefPtr<ManagerId> ref = mManagerId;
+  return ref.forget();
+}
+
 void
 Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                     const PCacheRequest& aRequest,
                     const PCacheQueryParams& aParams)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   MOZ_ASSERT(aListener);
   if (mShuttingDown) {
@@ -1433,35 +1444,37 @@ Manager::RemoveContext(Context* aContext
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
   mContext = nullptr;
 
   if (mShuttingDown) {
     nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
     if (so) {
-      so->RemoveOrigin(mInitData.origin());
+      so->RemoveManagerId(mManagerId);
     }
   }
 }
 
-Manager::Manager(const CacheInitData& aInitData)
-  : mInitData(aInitData)
+Manager::Manager(ManagerId* aManagerId)
+  : mManagerId(aManagerId)
   , mContext(nullptr)
   , mShuttingDown(false)
 {
+  MOZ_ASSERT(mManagerId);
+
   nsresult rv = NS_NewNamedThread("DOMCacheThread",
                                   getter_AddRefs(mIOThread));
   if (NS_FAILED(rv)) {
     MOZ_CRASH("Failed to spawn cache manager IO thread.");
   }
 
   nsRefPtr<ShutdownObserver> so = ShutdownObserver::Instance();
   if (so) {
-    so->AddOrigin(mInitData.origin());
+    so->AddManagerId(mManagerId);
   } else {
     Shutdown();
   }
 }
 
 Manager::~Manager()
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
@@ -1471,18 +1484,18 @@ Manager::~Manager()
 }
 
 Context*
 Manager::CurrentContext()
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
   if (!mContext) {
     MOZ_ASSERT(!mShuttingDown);
-    nsRefPtr<Action> setupAction = new SetupAction(mInitData);
-    mContext = new Context(this, mInitData, setupAction);
+    nsRefPtr<Action> setupAction = new SetupAction();
+    mContext = new Context(this, mManagerId, setupAction);
   }
   return mContext;
 }
 
 Manager::ListenerId
 Manager::SaveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Context::Listener);
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -20,16 +20,17 @@ class nsIInputStream;
 class nsIOutputStream;
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheRequestResponse;
+class ManagerId;
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 struct SavedRequest;
 struct SavedResponse;
 
 class Manager MOZ_FINAL : public Context::Listener
@@ -110,24 +111,25 @@ public:
     virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
                                CacheId aCacheId) { }
     virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                  bool aCacheDeleted) { }
     virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
                                const nsTArray<nsString>& aKeys) { }
   };
 
-  static already_AddRefed<Manager> ForOrigin(const CacheInitData& aInitData);
-  static already_AddRefed<Manager> ForExistingOrigin(const nsACString& aOrigin);
+  static already_AddRefed<Manager> GetOrCreate(ManagerId* aManagerId);
+  static already_AddRefed<Manager> Get(ManagerId* aManagerId);
 
   void RemoveListener(Listener* aListener);
   void AddRefCacheId(CacheId aCacheId);
   void ReleaseCacheId(CacheId aCacheId);
   bool SetCacheIdOrphanedIfRefed(CacheId aCacheId);
   void Shutdown();
+  already_AddRefed<ManagerId> GetManagerId() const;
 
   // TODO: consider moving CacheId up in the argument lists below
   void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
                   const PCacheRequest& aRequest,
                   const PCacheQueryParams& aParams);
   void CacheMatchAll(Listener* aListener, RequestId aRequestId,
                      CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
                      const PCacheQueryParams& aParams);
@@ -149,18 +151,16 @@ public:
                   Namespace aNamespace, const nsAString& aKey);
   void StorageOpen(Listener* aListener, RequestId aRequestId,
                    Namespace aNamespace, const nsAString& aKey);
   void StorageDelete(Listener* aListener, RequestId aRequestId,
                      Namespace aNamespace, const nsAString& aKey);
   void StorageKeys(Listener* aListener, RequestId aRequestId,
                    Namespace aNamespace);
 
-  const nsCString& Origin() const { return mInitData.origin(); }
-
   // Context::Listener methods
   virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
 
 private:
   class Factory;
   class BaseAction;
   class DeleteOrphanedBodyAction;
   class DeleteOrphanedCacheAction;
@@ -174,32 +174,32 @@ private:
   class StorageMatchAction;
   class StorageHasAction;
   class StorageOpenAction;
   class StorageDeleteAction;
   class StorageKeysAction;
 
   typedef uintptr_t ListenerId;
 
-  Manager(const CacheInitData& aInitData);
+  Manager(ManagerId* aManagerId);
   ~Manager();
   Context* CurrentContext();
 
   ListenerId SaveListener(Listener* aListener);
   Listener* GetListener(ListenerId aListenerId) const;
 
   void AddStreamList(StreamList* aStreamList);
   void RemoveStreamList(StreamList* aStreamList);
 
   void AddRefBodyId(const nsID& aBodyId);
   void ReleaseBodyId(const nsID& aBodyId);
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
 
-  const CacheInitData mInitData;
+  nsRefPtr<ManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
   nsTArray<Listener*> mListeners;
   nsTArray<StreamList*> mStreamLists;
 
   struct CacheIdRefCounter
   {
     CacheId mCacheId;
     uint32_t mCount;
diff --git a/dom/cache/ManagerId.cpp b/dom/cache/ManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/ManagerId.cpp
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/ManagerId.h"
+#include "nsIPrincipal.h"
+#include "nsRefPtr.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+class ReleasePrincipalRunnable : public nsRunnable
+{
+public:
+  ReleasePrincipalRunnable(already_AddRefed<nsIPrincipal> aPrincipal)
+    : mPrincipal(aPrincipal)
+  { }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    mPrincipal = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~ReleasePrincipalRunnable() { }
+
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// static
+nsresult
+ManagerId::Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We currently don't need the system principal logic
+  // because ManagerId only uses the origin for in memory comparisons.  We
+  // also don't do any special logic to host the same Cache for different about:
+  // pages, so we don't need those checks either.
+
+  nsAutoCString origin;
+  nsresult rv = aPrincipal->GetOrigin(getter_Copies(origin));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  uint32_t appId;
+  rv = aPrincipal->GetAppId(&appId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool inBrowserElement;
+  rv = aPrincipal->GetIsInBrowserElement(&inBrowserElement);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<ManagerId> ref = new ManagerId(aPrincipal, origin, appId,
+                                          inBrowserElement);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+ManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+ManagerId::ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
+                     uint32_t aAppId, bool aInBrowserElement)
+    : mPrincipal(aPrincipal)
+    , mOrigin(aOrigin)
+    , mAppId(aAppId)
+    , mInBrowserElement(aInBrowserElement)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+ManagerId::~ManagerId()
+{
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new ReleasePrincipalRunnable(mPrincipal.forget());
+
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ManagerId release runnable.");
+  }
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/ManagerId.h b/dom/cache/ManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/ManagerId.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_ManagerId_h
+#define mozilla_dom_cache_ManagerId_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsError.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+
+class nsIPrincipal;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class ManagerId MOZ_FINAL
+{
+public:
+  // Main thread only
+  static nsresult Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut);
+
+  // Main thread only
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& Origin() const { return mOrigin; }
+
+  bool operator==(const ManagerId& aOther) const
+  {
+    return mOrigin == aOther.mOrigin &&
+           mAppId == aOther.mAppId &&
+           mInBrowserElement == aOther.mInBrowserElement;
+  }
+
+private:
+  ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
+            uint32_t aAppId, bool aInBrowserElement);
+  ~ManagerId();
+
+  ManagerId(const ManagerId&) MOZ_DELETE;
+  ManagerId& operator=(const ManagerId&) MOZ_DELETE;
+
+  // only accessible on main thread
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // immutable to allow threadsfe access
+  const nsCString mOrigin;
+  const uint32_t mAppId;
+  const bool mInBrowserElement;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(mozilla::dom::cache::ManagerId)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_ManagerId_h
diff --git a/dom/cache/PrincipalVerifier.cpp b/dom/cache/PrincipalVerifier.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/PrincipalVerifier.cpp
@@ -0,0 +1,170 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/PrincipalVerifier.h"
+
+#include "mozilla/AppProcessChecker.h"
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/cache/ManagerId.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/BackgroundUtils.h"
+#include "nsIPrincipal.h"
+
+namespace {
+
+using mozilla::dom::ContentParent;
+
+class ReleaseContentParentRunnable : public nsRunnable
+{
+public:
+  ReleaseContentParentRunnable(already_AddRefed<ContentParent> aActor)
+    : mActor(aActor)
+  { }
+
+  NS_IMETHOD Run() MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    mActor = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~ReleaseContentParentRunnable() { }
+
+  nsRefPtr<ContentParent> mActor;
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::ipc::BackgroundParent;
+using mozilla::ipc::PBackgroundParent;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalInfoToPrincipal;
+
+// static
+nsresult
+PrincipalVerifier::Create(Listener* aListener, PBackgroundParent* aActor,
+                          const PrincipalInfo& aPrincipalInfo,
+                          PrincipalVerifier** aVerifierOut)
+{
+  nsRefPtr<PrincipalVerifier> verifier = new PrincipalVerifier(aListener,
+                                                               aActor,
+                                                               aPrincipalInfo);
+
+  nsresult rv = NS_DispatchToMainThread(verifier);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  verifier.forget(aVerifierOut);
+
+  return NS_OK;
+}
+
+void
+PrincipalVerifier::ClearListener()
+{
+  MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+PrincipalVerifier::PrincipalVerifier(Listener* aListener,
+                                     PBackgroundParent* aActor,
+                                     const PrincipalInfo& aPrincipalInfo)
+  : mListener(aListener)
+  , mActor(BackgroundParent::GetContentParent(aActor))
+  , mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+  , mResult(NS_OK)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mInitiatingThread);
+}
+
+PrincipalVerifier::~PrincipalVerifier()
+{
+  MOZ_ASSERT(!mListener);
+
+  if (!mActor || NS_IsMainThread()) {
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> runnable =
+    new ReleaseContentParentRunnable(mActor.forget());
+
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ManagerId release runnable.");
+  }
+}
+
+NS_IMETHODIMP
+PrincipalVerifier::Run()
+{
+  if (NS_IsMainThread()) {
+    VerifyOnMainThread();
+    return NS_OK;
+  }
+  CompleteOnInitiatingThread();
+  return NS_OK;
+}
+
+void
+PrincipalVerifier::VerifyOnMainThread()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsresult rv;
+  nsRefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                              &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    DispatchToInitiatingThread(rv);
+    return;
+  }
+
+  if (NS_WARN_IF(mActor && !AssertAppPrincipal(mActor, principal))) {
+    DispatchToInitiatingThread(NS_ERROR_FAILURE);
+    return;
+  }
+  mActor = nullptr;
+
+  rv = ManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    DispatchToInitiatingThread(rv);
+    return;
+  }
+
+  DispatchToInitiatingThread(NS_OK);
+}
+
+void
+PrincipalVerifier::CompleteOnInitiatingThread()
+{
+  MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+
+  if (!mListener) {
+    return;
+  }
+  mListener->OnPrincipalVerified(mResult, mManagerId);
+}
+
+void
+PrincipalVerifier::DispatchToInitiatingThread(nsresult aRv)
+{
+  mResult = aRv;
+  nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch PrincipalVerifier to initiating thread.");
+  }
+}
+
+} // namesapce cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PrincipalVerifier.h b/dom/cache/PrincipalVerifier.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/PrincipalVerifier.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_PrincipalVerifier_h
+#define mozilla_dom_cache_PrincipalVerifier_h
+
+#include "mozilla/ipc/PBackgroundSharedTypes.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+
+namespace ipc {
+  class PBackgroundParent;
+}
+
+namespace dom {
+namespace cache {
+
+class ManagerId;
+
+class PrincipalVerifier MOZ_FINAL : public nsRunnable
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+
+    virtual void OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)=0;
+  };
+
+  static nsresult
+  Create(Listener* aListener, ipc::PBackgroundParent* aActor,
+         const ipc::PrincipalInfo& aPrincipalInfo,
+         PrincipalVerifier** aVerifierOut);
+
+  void ClearListener();
+
+private:
+  PrincipalVerifier(Listener* aListener, ipc::PBackgroundParent* aActor,
+                    const ipc::PrincipalInfo& aPrincipalInfo);
+  virtual ~PrincipalVerifier();
+
+  void VerifyOnMainThread();
+  void CompleteOnInitiatingThread();
+
+  void DispatchToInitiatingThread(nsresult aRv);
+
+  Listener* mListener;
+  nsRefPtr<ContentParent> mActor;
+  const ipc::PrincipalInfo mPrincipalInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsresult mResult;
+  nsRefPtr<ManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namesapce cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_PrincipalVerifier_h
diff --git a/dom/cache/ShutdownObserver.cpp b/dom/cache/ShutdownObserver.cpp
--- a/dom/cache/ShutdownObserver.cpp
+++ b/dom/cache/ShutdownObserver.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/ShutdownObserver.h"
 
 #include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/Services.h"
 #include "nsIObserverService.h"
 #include "nsThreadUtils.h"
 
 namespace {
 
 static bool sInstanceInit = false;
@@ -38,46 +39,44 @@ ShutdownObserver::Instance()
     sInstance = new ShutdownObserver();
   }
 
   nsRefPtr<ShutdownObserver> ref = sInstance;
   return ref.forget();
 }
 
 nsresult
-ShutdownObserver::AddOrigin(const nsACString& aOrigin)
+ShutdownObserver::AddManagerId(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   if (mShuttingDown) {
     return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
   }
 
   nsCOMPtr<nsIRunnable> runnable =
-    NS_NewRunnableMethodWithArg<nsCString>(this,
-                                           &ShutdownObserver::AddOriginOnMainThread,
-                                           nsCString(aOrigin));
+    NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
+      this, &ShutdownObserver::AddManagerIdOnMainThread, aManagerId);
 
   DebugOnly<nsresult> rv =
     NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
 
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   return NS_OK;
 }
 
 void
-ShutdownObserver::RemoveOrigin(const nsACString& aOrigin)
+ShutdownObserver::RemoveManagerId(ManagerId* aManagerId)
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   nsCOMPtr<nsIRunnable> runnable =
-    NS_NewRunnableMethodWithArg<nsCString>(this,
-                                           &ShutdownObserver::RemoveOriginOnMainThread,
-                                           nsCString(aOrigin));
+    NS_NewRunnableMethodWithArg<nsRefPtr<ManagerId>>(
+      this, &ShutdownObserver::RemoveManagerIdOnMainThread, aManagerId);
 
   DebugOnly<nsresult> rv =
     NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
 
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
 ShutdownObserver::ShutdownObserver()
@@ -112,45 +111,50 @@ ShutdownObserver::InitOnMainThread()
     DoShutdown();
     return;
   }
 
   os->AddObserver(this, "profile-before-change", false /* weak ref */);
 }
 
 void
-ShutdownObserver::AddOriginOnMainThread(const nsACString& aOrigin)
+ShutdownObserver::AddManagerIdOnMainThread(ManagerId* aManagerId)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  if (!mOrigins.Contains(aOrigin)) {
-    mOrigins.AppendElement(aOrigin);
+  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
+    if (*mManagerIds[i] == *aManagerId) {
+      return;
+    }
   }
+  mManagerIds.AppendElement(aManagerId);
 }
 
 void
-ShutdownObserver::RemoveOriginOnMainThread(const nsACString& aOrigin)
+ShutdownObserver::RemoveManagerIdOnMainThread(ManagerId* aManagerId)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
-  size_t index = mOrigins.IndexOf(aOrigin);
-  if (index != nsTArray<nsCString>::NoIndex) {
-    mOrigins.RemoveElementAt(index);
+  for (uint32_t i = 0; i < mManagerIds.Length(); ++i) {
+    if (*mManagerIds[i] == *aManagerId) {
+      mManagerIds.RemoveElementAt(i);
+      return;
+    }
   }
 }
 
 void
 ShutdownObserver::StartShutdownOnBgThread()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
   mShuttingDown = true;
 
-  for (uint32_t i = 0; i < mOriginsInProcess.Length(); ++i) {
-    nsRefPtr<Manager> manager = Manager::ForExistingOrigin(mOriginsInProcess[i]);
+  for (uint32_t i = 0; i < mManagerIdsInProcess.Length(); ++i) {
+    nsRefPtr<Manager> manager = Manager::Get(mManagerIdsInProcess[i]);
     if (manager) {
       manager->Shutdown();
     }
   }
 }
 
 void
 ShutdownObserver::FinishShutdownOnBgThread()
@@ -167,29 +171,29 @@ ShutdownObserver::DoShutdown()
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
   if (os) {
     os->RemoveObserver(this, "profile-before-change");
   }
 
   // Copy origins to separate array to process to avoid races
-  mOriginsInProcess = mOrigins;
+  mManagerIdsInProcess = mManagerIds;
 
   // Send shutdown notification to origin managers
   nsCOMPtr<nsIRunnable> runnable =
     NS_NewRunnableMethod(this, &ShutdownObserver::StartShutdownOnBgThread);
   DebugOnly<nsresult> rv =
     mBackgroundThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   runnable = nullptr;
 
   // Wait for managers to shutdown
-  while (!mOrigins.IsEmpty()) {
+  while (!mManagerIds.IsEmpty()) {
     if (!NS_ProcessNextEvent()) {
       NS_WARNING("Something bad happened!");
       break;
     }
   }
 
   // schedule runnable to clear singleton ref on background thread
   runnable =
diff --git a/dom/cache/ShutdownObserver.h b/dom/cache/ShutdownObserver.h
--- a/dom/cache/ShutdownObserver.h
+++ b/dom/cache/ShutdownObserver.h
@@ -13,44 +13,46 @@
 #include "nsIThread.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class ManagerId;
+
 class ShutdownObserver MOZ_FINAL : public nsIObserver
 {
 public:
   static already_AddRefed<ShutdownObserver> Instance();
 
-  nsresult AddOrigin(const nsACString& aOrigin);
-  void RemoveOrigin(const nsACString& aOrigin);
+  nsresult AddManagerId(ManagerId* aManagerId);
+  void RemoveManagerId(ManagerId* aManagerId);
 
 private:
   ShutdownObserver();
   virtual ~ShutdownObserver();
 
   void InitOnMainThread();
-  void AddOriginOnMainThread(const nsACString& aOrigin);
-  void RemoveOriginOnMainThread(const nsACString& aOrigin);
+  void AddManagerIdOnMainThread(ManagerId* aManagerId);
+  void RemoveManagerIdOnMainThread(ManagerId* aManagerId);
 
   void StartShutdownOnBgThread();
   void FinishShutdownOnBgThread();
 
   void DoShutdown();
 
   nsCOMPtr<nsIThread> mBackgroundThread;
 
   // main thread only
-  nsTArray<nsCString> mOrigins;
+  nsTArray<nsRefPtr<ManagerId>> mManagerIds;
 
   // set on main thread once and read on bg thread
-  nsTArray<nsCString> mOriginsInProcess;
+  nsTArray<nsRefPtr<ManagerId>> mManagerIdsInProcess;
 
   // bg thread only
   bool mShuttingDown;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIOBSERVER
 };
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -420,17 +420,20 @@ TypeUtils::ToResponse(const PCacheRespon
   return ref.forget();
 }
 
 already_AddRefed<InternalRequest>
 TypeUtils::ToInternalRequest(const PCacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
+  // TODO: Is this valid if DOM object has a system principal with
+  //       an origin of "[System Principal]"?
   internalRequest->SetOrigin(Origin());
+
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
   internalRequest->SetContext(aIn.context());
 
   nsRefPtr<InternalHeaders> internalHeaders =
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -3,16 +3,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Types_h
 #define mozilla_dom_cache_Types_h
 
 #include <stdint.h>
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsString.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 enum Namespace
 {
   DEFAULT_NAMESPACE,
@@ -20,13 +23,23 @@ enum Namespace
   NUMBER_OF_NAMESPACES
 };
 
 typedef uintptr_t RequestId;
 static const RequestId INVALID_REQUEST_ID = 0;
 
 typedef int32_t CacheId;
 
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false), mHasUnlimStoragePerm(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+  bool mHasUnlimStoragePerm;
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -19,16 +19,18 @@ EXPORTS.mozilla.dom.cache += [
     'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FetchPut.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
+    'ManagerId.h',
+    'PrincipalVerifier.h',
     'ReadStream.h',
     'SavedTypes.h',
     'ShutdownObserver.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
@@ -42,16 +44,18 @@ SOURCES += [
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
+    'ManagerId.cpp',
+    'PrincipalVerifier.cpp',
     'ReadStream.cpp',
     'ShutdownObserver.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'CacheInitData.ipdlh',
     'PCache.ipdl',
diff --git a/dom/tests/mochitest/cache/test_cache_add.js b/dom/tests/mochitest/cache/test_cache_add.js
--- a/dom/tests/mochitest/cache/test_cache_add.js
+++ b/dom/tests/mochitest/cache/test_cache_add.js
@@ -29,9 +29,12 @@ caches.open('adder').then(function(openC
   promiseList.push(cache.match(singleUrl));
   return Promise.all(promiseList);
 }).then(function(resultList) {
   is(urlList.length + 1, resultList.length, 'Expected number of results');
   resultList.every(function(result) {
     ok(!!result, 'Responses should now be in cache for each URL.');
   });
   workerTestDone();
+}).catch(function(err) {
+  ok(false, 'Caught error: ' + err);
+  workerTestDone();
 });
diff --git a/dom/tests/mochitest/cache/worker_driver.js b/dom/tests/mochitest/cache/worker_driver.js
--- a/dom/tests/mochitest/cache/worker_driver.js
+++ b/dom/tests/mochitest/cache/worker_driver.js
@@ -26,16 +26,17 @@
 //
 // For an example see test_worker_interfaces.html and test_worker_interfaces.js.
 
 function workerTestExec(script) {
   SimpleTest.waitForExplicitFinish();
   var worker = new Worker('worker_wrapper.js');
   worker.onmessage = function(event) {
     if (event.data.type == 'finish') {
+      SpecialPowers.forceGC();
       SimpleTest.finish();
 
     } else if (event.data.type == 'status') {
       ok(event.data.status, event.data.msg);
 
     } else if (event.data.type == 'getPrefs') {
       var result = {};
       event.data.prefs.forEach(function(pref) {
diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -8,18 +8,16 @@
  *
  * You are granted a license to use, reproduce and create derivative works of
  * this document.
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
-  readonly attribute CacheStorage caches;
-
   readonly attribute ServiceWorkerClients clients;
 
   [Unforgeable] readonly attribute DOMString scope;
 
   // FIXME(nsm): Bug 995484
   // ResponsePromise<any> fetch((Request or [EnsureUTF16] DOMString) request);
 
   void update();
diff --git a/dom/webidl/Window.webidl b/dom/webidl/Window.webidl
--- a/dom/webidl/Window.webidl
+++ b/dom/webidl/Window.webidl
@@ -379,17 +379,18 @@ partial interface Window {
                                                any... extraArguments);
 
   [Replaceable, Throws] readonly attribute object? content;
 
   [ChromeOnly, Throws] readonly attribute object? __content;
 
   [Throws, ChromeOnly] any getInterface(IID iid);
 
-  [Pref="dom.window-caches.enabled"] readonly attribute CacheStorage caches;
+  [Throws, Pref="dom.window-caches.enabled"]
+  readonly attribute CacheStorage caches;
 };
 
 Window implements TouchEventHandlers;
 
 Window implements OnErrorEventHandlerForWindow;
 
 // ConsoleAPI
 partial interface Window {
diff --git a/dom/webidl/WorkerGlobalScope.webidl b/dom/webidl/WorkerGlobalScope.webidl
--- a/dom/webidl/WorkerGlobalScope.webidl
+++ b/dom/webidl/WorkerGlobalScope.webidl
@@ -48,11 +48,11 @@ partial interface WorkerGlobalScope {
   attribute EventHandler onclose;
 
   void dump(optional DOMString str);
 
   // XXXbz no spec for this yet, because the webperf WG is a bit dysfunctional
   [Constant, Cached]
   readonly attribute Performance performance;
 
-  [Func="mozilla::dom::cache::CacheStorage::PrefEnabled"]
+  [Throws, Func="mozilla::dom::cache::CacheStorage::PrefEnabled"]
   readonly attribute CacheStorage caches;
 };
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -112,23 +112,25 @@ WorkerGlobalScope::GetConsole()
   if (!mConsole) {
     mConsole = new Console(nullptr);
   }
 
   return mConsole;
 }
 
 already_AddRefed<CacheStorage>
-WorkerGlobalScope::Caches()
+WorkerGlobalScope::GetCaches(ErrorResult& aRv)
 {
   if (!mCacheStorage) {
     MOZ_ASSERT(mWorkerPrivate);
-    NS_ConvertUTF16toUTF8 origin(mWorkerPrivate->GetLocationInfo().mOrigin);
-    mCacheStorage = new CacheStorage(cache::DEFAULT_NAMESPACE, ToSupports(this),
-                                     this, origin, origin, false, false);
+    mCacheStorage = CacheStorage::CreateOnWorker(cache::DEFAULT_NAMESPACE, this,
+                                                 mWorkerPrivate, aRv);
+    if (aRv.Failed()) {
+      return nullptr;
+    }
   }
 
   nsRefPtr<CacheStorage> ref = mCacheStorage;
   return ref.forget();
 }
 
 already_AddRefed<WorkerLocation>
 WorkerGlobalScope::Location()
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -131,17 +131,17 @@ public:
 
   Performance* GetPerformance();
 
   already_AddRefed<Promise>
   Fetch(const RequestOrScalarValueString& aInput,
         const RequestInit& aInit,
         ErrorResult& aRv);
 
-  already_AddRefed<mozilla::dom::cache::CacheStorage> Caches();
+  already_AddRefed<cache::CacheStorage> GetCaches(ErrorResult& aRv);
 };
 
 class DedicatedWorkerGlobalScope MOZ_FINAL : public WorkerGlobalScope
 {
   ~DedicatedWorkerGlobalScope() { }
 
 public:
   explicit DedicatedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -160,17 +160,18 @@ BackgroundChildImpl::DeallocPFileDescrip
 {
   MOZ_ASSERT(aActor);
 
   delete static_cast<FileDescriptorSetChild*>(aActor);
   return true;
 }
 
 PCacheStorageChild*
-BackgroundChildImpl::AllocPCacheStorageChild(const CacheInitData& aInitData)
+BackgroundChildImpl::AllocPCacheStorageChild(const Namespace& aNamespace,
+                                             const PrincipalInfo& aPrincipalInfo)
 {
   MOZ_CRASH("CacheStorageChild actor must be provided to PBackground manager");
   return nullptr;
 }
 
 bool
 BackgroundChildImpl::DeallocPCacheStorageChild(PCacheStorageChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -73,27 +73,28 @@ protected:
   virtual PFileDescriptorSetChild*
   AllocPFileDescriptorSetChild(const FileDescriptor& aFileDescriptor)
                                MOZ_OVERRIDE;
 
   virtual bool
   DeallocPFileDescriptorSetChild(PFileDescriptorSetChild* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheStorageChild*
-  AllocPCacheStorageChild(const CacheInitData& aInitData) MOZ_OVERRIDE;
+  AllocPCacheStorageChild(const dom::cache::Namespace& aNamespace,
+                          const PrincipalInfo& aPrincipalInfo) MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheStorageChild(mozilla::dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
+  DeallocPCacheStorageChild(dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
+  virtual dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheChild(mozilla::dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
+  DeallocPCacheChild(dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::cache::PCacheStreamControlChild*
+  virtual dom::cache::PCacheStreamControlChild*
   AllocPCacheStreamControlChild();
 
   virtual bool
   DeallocPCacheStreamControlChild(mozilla::dom::cache::PCacheStreamControlChild* aActor);
 
   virtual PMessagePortChild*
   AllocPMessagePortChild() MOZ_OVERRIDE;
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -211,19 +211,20 @@ BackgroundParentImpl::DeallocPFileDescri
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
   delete static_cast<FileDescriptorSetParent*>(aActor);
   return true;
 }
 
 PCacheStorageParent*
-BackgroundParentImpl::AllocPCacheStorageParent(const CacheInitData& aInitData)
+BackgroundParentImpl::AllocPCacheStorageParent(const Namespace& aNamespace,
+                                               const PrincipalInfo& aPrincipalInfo)
 {
-  return new CacheStorageParent(aInitData);
+  return new CacheStorageParent(this, aNamespace, aPrincipalInfo);
 }
 
 bool
 BackgroundParentImpl::DeallocPCacheStorageParent(PCacheStorageParent* aActor)
 {
   delete aActor;
   return true;
 }
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -63,17 +63,18 @@ protected:
   AllocPFileDescriptorSetParent(const FileDescriptor& aFileDescriptor)
                                 MOZ_OVERRIDE;
 
   virtual bool
   DeallocPFileDescriptorSetParent(PFileDescriptorSetParent* aActor)
                                   MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheStorageParent*
-  AllocPCacheStorageParent(const CacheInitData& aInitData) MOZ_OVERRIDE;
+  AllocPCacheStorageParent(const Namespace& aNamespace,
+                           const PrincipalInfo& aPrincipalInfo) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheStorageParent(mozilla::dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
 
   virtual mozilla::dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheParent(mozilla::dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -7,17 +7,19 @@ include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PFileDescriptorSet;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PMessagePort;
 
 include DOMTypes;
-include CacheInitData;
+include PBackgroundSharedTypes;
+
+using mozilla::dom::cache::Namespace from "mozilla/dom/cache/IPCUtils.h";
 
 using struct mozilla::void_t
   from "ipc/IPCMessageUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace indexedDB {
 
@@ -44,17 +46,17 @@ sync protocol PBackground
   manages PMessagePort;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(OptionalWindowId optionalWindowId);
 
-  PCacheStorage(CacheInitData initData);
+  PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
 
   PMessagePort();
 
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 
