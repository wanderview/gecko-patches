# HG changeset patch
# Parent ab06fd9ee40e07227a073733e58932bb05ebf97f
# User Ben Kelly <ben@wanderview.com>
Bug 1175138 P1 Make CacheStorage reject on untrusted origins. r=ehsan


diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "nsIDocument.h"
 #include "nsIGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsURLParsers.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ErrorResult;
@@ -57,64 +58,98 @@ struct CacheStorage::Entry final
 {
   nsRefPtr<Promise> mPromise;
   CacheOpArgs mArgs;
   // We cannot add the requests until after the actor is present.  So store
   // the request data separately for now.
   nsRefPtr<InternalRequest> mRequest;
 };
 
+namespace {
+
+bool
+IsTrusted(const PrincipalInfo& aPrincipalInfo)
+{
+  // Can happen on main thread or worker thread
+
+  printf_stderr("### ### principal type: %u\n", (uint32_t)aPrincipalInfo.type());
+
+  if (aPrincipalInfo.type() == PrincipalInfo::TSystemPrincipalInfo) {
+    return true;
+  }
+
+  // Require a ContentPrincipal to avoid null principal, etc.
+  //
+  // Also, an unknown appId means that this principal was created for the
+  // codebase without all the security information from the end document or
+  // worker.  We require exact knowledge of this information before allowing
+  // the caller to touch the disk using the Cache API.
+  if (aPrincipalInfo.type() != PrincipalInfo::TContentPrincipalInfo ||
+      aPrincipalInfo.get_ContentPrincipalInfo().appId() ==
+      nsIScriptSecurityManager::UNKNOWN_APP_ID) {
+    return false;
+  }
+
+  // Now parse the scheme of the principal's origin.  This is a short term
+  // method for determining "trust".  In the long term we need to implement
+  // the full algorithm here:
+  //
+  // https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-secure
+
+  const nsCString& flatURL = aPrincipalInfo.get_ContentPrincipalInfo().spec();
+  const char* url = flatURL.get();
+
+  // off the main thread URL parsing using nsStdURLParser.
+  nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
+
+  uint32_t schemePos;
+  int32_t schemeLen;
+  nsresult rv = urlParser->ParseURL(url, flatURL.Length(),
+                                    &schemePos, &schemeLen,
+                                    nullptr, nullptr,       // ignore authority
+                                    nullptr, nullptr);      // ignore path
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  nsAutoCString scheme(Substring(flatURL, schemePos, schemeLen));
+  printf_stderr("### ### scheme: %s\n", scheme.get());
+  return scheme.LowerCaseEqualsLiteral("https") ||
+         scheme.LowerCaseEqualsLiteral("app");
+}
+
+} // anonymous namespace
+
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                                  nsIPrincipal* aPrincipal, bool aPrivateBrowsing,
                                  ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   if (aPrivateBrowsing) {
     NS_WARNING("CacheStorage not supported during private browsing.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  bool nullPrincipal;
-  nsresult rv = aPrincipal->GetIsNullPrincipal(&nullPrincipal);
+  PrincipalInfo principalInfo;
+  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aRv.Throw(rv);
     return nullptr;
   }
 
-  if (nullPrincipal) {
-    NS_WARNING("CacheStorage not supported on null principal.");
+  if (!IsTrusted(principalInfo)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  // An unknown appId means that this principal was created for the codebase
-  // without all the security information from the end document or worker.
-  // We require exact knowledge of this information before allowing the
-  // caller to touch the disk using the Cache API.
-  bool unknownAppId = false;
-  aPrincipal->GetUnknownAppId(&unknownAppId);
-  if (unknownAppId) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
-
-  PrincipalInfo principalInfo;
-  rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
-    return nullptr;
-  }
-
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, nullptr);
   return ref.forget();
 }
 
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
@@ -133,26 +168,19 @@ CacheStorage::CreateOnWorker(Namespace a
   nsRefPtr<Feature> feature = Feature::Create(aWorkerPrivate);
   if (!feature) {
     NS_WARNING("Worker thread is shutting down.");
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
-  if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
-    NS_WARNING("CacheStorage not supported on null principal.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
 
-  if (principalInfo.type() == PrincipalInfo::TContentPrincipalInfo &&
-      principalInfo.get_ContentPrincipalInfo().appId() ==
-      nsIScriptSecurityManager::UNKNOWN_APP_ID) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
+  if (!IsTrusted(principalInfo)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, feature);
   return ref.forget();
 }
