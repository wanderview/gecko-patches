# HG changeset patch
# Parent e9839e70340be859de7d9b88db85e61baf33cf0d
# User Ben Kelly <ben@wanderview.com>
Bug 1168152 P2 Use a wrapper mozIStorageConnection for shared Cache connections. r=ehsan

diff --git a/dom/cache/Connection.cpp b/dom/cache/Connection.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Connection.cpp
@@ -0,0 +1,260 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Connection.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+NS_IMPL_ISUPPORTS(cache::Connection, mozIStorageAsyncConnection,
+                                     mozIStorageConnection);
+
+Connection::Connection(mozIStorageConnection* aBase)
+  : mBase(aBase)
+{
+  MOZ_ASSERT(mBase);
+}
+
+Connection::~Connection()
+{
+}
+
+// The following methods are all boilerplate that either forward to the
+// base connection or block the method.  All the async execution methods
+// are blocked because Cache does not use them and they would require more
+// work to wrap properly.
+
+// mozIStorageAsyncConnection methods
+
+NS_IMETHODIMP
+Connection::AsyncClose(mozIStorageCompletionCallback*)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::AsyncClone(bool, mozIStorageCompletionCallback*)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::GetDatabaseFile(nsIFile** aFileOut)
+{
+  return mBase->GetDatabaseFile(aFileOut);
+}
+
+NS_IMETHODIMP
+Connection::CreateAsyncStatement(const nsACString&, mozIStorageAsyncStatement**)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::ExecuteAsync(mozIStorageBaseStatement**, uint32_t,
+                         mozIStorageStatementCallback*,
+                         mozIStoragePendingStatement**)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::ExecuteSimpleSQLAsync(const nsACString&,
+                                  mozIStorageStatementCallback*,
+                                  mozIStoragePendingStatement**)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::CreateFunction(const nsACString& aFunctionName,
+                           int32_t aNumArguments,
+                           mozIStorageFunction* aFunction)
+{
+  // async methods are not supported
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+Connection::CreateAggregateFunction(const nsACString& aFunctionName,
+                                    int32_t aNumArguments,
+                                    mozIStorageAggregateFunction* aFunction)
+{
+  return mBase->CreateAggregateFunction(aFunctionName, aNumArguments,
+                                        aFunction);
+}
+
+NS_IMETHODIMP
+Connection::RemoveFunction(const nsACString& aFunctionName)
+{
+  return mBase->RemoveFunction(aFunctionName);
+}
+
+NS_IMETHODIMP
+Connection::SetProgressHandler(int32_t aGranularity,
+                               mozIStorageProgressHandler* aHandler,
+                               mozIStorageProgressHandler** aHandlerOut)
+{
+  return mBase->SetProgressHandler(aGranularity, aHandler, aHandlerOut);
+}
+
+NS_IMETHODIMP
+Connection::RemoveProgressHandler(mozIStorageProgressHandler** aHandlerOut)
+{
+  return mBase->RemoveProgressHandler(aHandlerOut);
+}
+
+// mozIStorageConnection methods
+
+NS_IMETHODIMP
+Connection::Close()
+{
+  return mBase->Close();
+}
+
+NS_IMETHODIMP
+Connection::Clone(bool aReadOnly, mozIStorageConnection** aConnectionOut)
+{
+  nsCOMPtr<mozIStorageConnection> conn;
+  nsresult rv = mBase->Clone(aReadOnly, getter_AddRefs(conn));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageConnection> wrapped = new Connection(conn);
+  wrapped.forget(aConnectionOut);
+
+  return rv;
+}
+
+NS_IMETHODIMP
+Connection::GetDefaultPageSize(int32_t* aSizeOut)
+{
+  return mBase->GetDefaultPageSize(aSizeOut);
+}
+
+NS_IMETHODIMP
+Connection::GetConnectionReady(bool* aReadyOut)
+{
+  return mBase->GetConnectionReady(aReadyOut);
+}
+
+NS_IMETHODIMP
+Connection::GetLastInsertRowID(int64_t* aRowIdOut)
+{
+  return mBase->GetLastInsertRowID(aRowIdOut);
+}
+
+NS_IMETHODIMP
+Connection::GetAffectedRows(int32_t* aCountOut)
+{
+  return mBase->GetAffectedRows(aCountOut);
+}
+
+NS_IMETHODIMP
+Connection::GetLastError(int32_t* aErrorOut)
+{
+  return mBase->GetLastError(aErrorOut);
+}
+
+NS_IMETHODIMP
+Connection::GetLastErrorString(nsACString& aErrorOut)
+{
+  return mBase->GetLastErrorString(aErrorOut);
+}
+
+NS_IMETHODIMP
+Connection::GetSchemaVersion(int32_t* aVersionOut)
+{
+  return mBase->GetSchemaVersion(aVersionOut);
+}
+
+NS_IMETHODIMP
+Connection::SetSchemaVersion(int32_t aVersion)
+{
+  return mBase->SetSchemaVersion(aVersion);
+}
+
+NS_IMETHODIMP
+Connection::CreateStatement(const nsACString& aQuery,
+                            mozIStorageStatement** aStatementOut)
+{
+  return mBase->CreateStatement(aQuery, aStatementOut);
+}
+
+NS_IMETHODIMP
+Connection::ExecuteSimpleSQL(const nsACString& aQuery)
+{
+  return mBase->ExecuteSimpleSQL(aQuery);
+}
+
+NS_IMETHODIMP
+Connection::TableExists(const nsACString& aTableName, bool* aExistsOut)
+{
+  return mBase->TableExists(aTableName, aExistsOut);
+}
+
+NS_IMETHODIMP
+Connection::IndexExists(const nsACString& aIndexName, bool* aExistsOut)
+{
+  return mBase->IndexExists(aIndexName, aExistsOut);
+}
+
+NS_IMETHODIMP
+Connection::GetTransactionInProgress(bool* aResultOut)
+{
+  return mBase->GetTransactionInProgress(aResultOut);
+}
+
+NS_IMETHODIMP
+Connection::BeginTransaction()
+{
+  return mBase->BeginTransaction();
+}
+
+NS_IMETHODIMP
+Connection::BeginTransactionAs(int32_t aType)
+{
+  return mBase->BeginTransactionAs(aType);
+}
+
+NS_IMETHODIMP
+Connection::CommitTransaction()
+{
+  return mBase->CommitTransaction();
+}
+
+NS_IMETHODIMP
+Connection::RollbackTransaction()
+{
+  return mBase->RollbackTransaction();
+}
+
+NS_IMETHODIMP
+Connection::CreateTable(const char* aTable, const char* aSchema)
+{
+  return mBase->CreateTable(aTable, aSchema);
+}
+
+NS_IMETHODIMP
+Connection::SetGrowthIncrement(int32_t aIncrement, const nsACString& aDatabase)
+{
+  return mBase->SetGrowthIncrement(aIncrement, aDatabase);
+}
+
+NS_IMETHODIMP
+Connection::EnableModule(const nsACString& aModule)
+{
+  return mBase->EnableModule(aModule);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Connection.h b/dom/cache/Connection.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Connection.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Connection_h
+#define mozilla_dom_cache_Connection_h
+
+#include "mozIStorageConnection.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Connection final : public mozIStorageConnection
+{
+public:
+  explicit Connection(mozIStorageConnection* aBase);
+
+private:
+  ~Connection();
+
+  nsCOMPtr<mozIStorageConnection> mBase;
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_MOZISTORAGEASYNCCONNECTION
+  NS_DECL_MOZISTORAGECONNECTION
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Connection_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -1,27 +1,28 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBAction.h"
 
+#include "mozilla/dom/cache/Connection.h"
+#include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/quota/PersistenceType.h"
 #include "mozilla/net/nsFileProtocolHandler.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
 #include "mozStorageCID.h"
 #include "nsIFile.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 #include "nsThreadUtils.h"
-#include "DBSchema.h"
-#include "FileUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
@@ -74,17 +75,22 @@ DBAction::RunOnTarget(Resolver* aResolve
       aResolver->Resolve(rv);
       return;
     }
     MOZ_ASSERT(conn);
 
     // Save this connection in the shared Data object so later Actions can
     // use it.  This avoids opening a new connection for every Action.
     if (aOptionalData) {
-      aOptionalData->SetConnection(conn);
+      // Since we know this connection will be around for as long as the
+      // Cache is open, use our special wrapped connection class.  This
+      // will let us perform certain operations once the Cache origin
+      // is closed.
+      nsCOMPtr<mozIStorageConnection> wrapped = new Connection(conn);
+      aOptionalData->SetConnection(wrapped);
     }
   }
 
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
 DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -16,16 +16,17 @@ EXPORTS.mozilla.dom.cache += [
     'CacheParent.h',
     'CachePushStreamChild.h',
     'CachePushStreamParent.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlParent.h',
+    'Connection.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'Feature.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
@@ -51,16 +52,17 @@ UNIFIED_SOURCES += [
     'CacheParent.cpp',
     'CachePushStreamChild.cpp',
     'CachePushStreamParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
+    'Connection.cpp',
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'Feature.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'OfflineStorage.cpp',
