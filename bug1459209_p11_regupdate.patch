# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e02ed96105262bde910a12eaf6deafee029d666b
Bug 1459209 P11 Implement RemoteServiceWorkerRegistrationImpl::Update() across IPC to the parent-side SWM. r=baku

diff --git a/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh b/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
--- a/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
+++ b/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
@@ -1,16 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PBackgroundSharedTypes;
 include IPCServiceWorkerDescriptor;
 
 using ServiceWorkerUpdateViaCache from "mozilla/dom/ServiceWorkerIPCUtils.h";
+using mozilla::CopyableErrorResult from "ipc/ErrorIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Note that the state may be slightly out-of-sync
 // with the parent and should be updated dynamically if necessary.
 struct IPCServiceWorkerRegistrationDescriptor
@@ -28,10 +29,16 @@ struct IPCServiceWorkerRegistrationDescr
 
   ServiceWorkerUpdateViaCache updateViaCache;
 
   OptionalIPCServiceWorkerDescriptor installing;
   OptionalIPCServiceWorkerDescriptor waiting;
   OptionalIPCServiceWorkerDescriptor active;
 };
 
+union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult
+{
+  IPCServiceWorkerRegistrationDescriptor;
+  CopyableErrorResult;
+};
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/PServiceWorkerRegistration.ipdl b/dom/serviceworkers/PServiceWorkerRegistration.ipdl
--- a/dom/serviceworkers/PServiceWorkerRegistration.ipdl
+++ b/dom/serviceworkers/PServiceWorkerRegistration.ipdl
@@ -1,22 +1,26 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 
+include IPCServiceWorkerRegistrationDescriptor;
+
 namespace mozilla {
 namespace dom {
 
 protocol PServiceWorkerRegistration
 {
   manager PBackground;
 
 parent:
   async Teardown();
 
+  async Update() returns (IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult aResult);
+
 child:
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerRegistrationImpl.cpp
@@ -6,16 +6,19 @@
 
 #include "RemoteServiceWorkerRegistrationImpl.h"
 
 #include "ServiceWorkerRegistrationChild.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::IPCResult;
+using mozilla::ipc::ResponseRejectReason;
+
 RemoteServiceWorkerRegistrationImpl::~RemoteServiceWorkerRegistrationImpl()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mOuter);
   Shutdown();
 }
 
 void
 RemoteServiceWorkerRegistrationImpl::Shutdown()
@@ -49,17 +52,38 @@ RemoteServiceWorkerRegistrationImpl::Cle
   MOZ_DIAGNOSTIC_ASSERT(aReg == mOuter);
   mOuter = nullptr;
 }
 
 void
 RemoteServiceWorkerRegistrationImpl::Update(ServiceWorkerRegistrationCallback&& aSuccessCB,
                                             ServiceWorkerFailureCallback&& aFailureCB)
 {
-  // TODO
+  if (!mActor) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
+  mActor->SendUpdate(
+    [successCB = std::move(aSuccessCB), aFailureCB]
+    (const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aResult) {
+      if (aResult.type() == IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::TCopyableErrorResult) {
+        // application layer error
+        auto& rv = aResult.get_CopyableErrorResult();
+        MOZ_DIAGNOSTIC_ASSERT(rv.Failed());
+        aFailureCB(CopyableErrorResult(rv));
+        return;
+      }
+      // success
+      auto& ipcDesc = aResult.get_IPCServiceWorkerRegistrationDescriptor();
+      successCB(ServiceWorkerRegistrationDescriptor(ipcDesc));
+    }, [aFailureCB] (ResponseRejectReason aReason) {
+      // IPC layer error
+      aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    });
 }
 
 void
 RemoteServiceWorkerRegistrationImpl::Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
                                                 ServiceWorkerFailureCallback&& aFailureCB)
 {
   // TODO
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp b/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
@@ -24,16 +24,34 @@ ServiceWorkerRegistrationParent::ActorDe
 
 IPCResult
 ServiceWorkerRegistrationParent::RecvTeardown()
 {
   MaybeSendDelete();
   return IPC_OK();
 }
 
+IPCResult
+ServiceWorkerRegistrationParent::RecvUpdate(UpdateResolver&& aResolver)
+{
+  if (!mProxy) {
+    aResolver(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return IPC_OK();
+  }
+
+  mProxy->Update()->Then(GetCurrentThreadSerialEventTarget(), __func__,
+    [aResolver] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+      aResolver(aDescriptor.ToIPC());
+    }, [aResolver] (const CopyableErrorResult& aResult) {
+      aResolver(aResult);
+    });
+
+  return IPC_OK();
+}
+
 ServiceWorkerRegistrationParent::ServiceWorkerRegistrationParent()
   : mDeleteSent(false)
 {
 }
 
 ServiceWorkerRegistrationParent::~ServiceWorkerRegistrationParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mProxy);
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationParent.h b/dom/serviceworkers/ServiceWorkerRegistrationParent.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationParent.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationParent.h
@@ -22,16 +22,19 @@ class ServiceWorkerRegistrationParent fi
 
   // PServiceWorkerRegistrationParent
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
+  mozilla::ipc::IPCResult
+  RecvUpdate(UpdateResolver&& aResolver) override;
+
 public:
   ServiceWorkerRegistrationParent();
   ~ServiceWorkerRegistrationParent();
 
   void
   Init(const IPCServiceWorkerRegistrationDescriptor& aDescriptor);
 
   void
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp b/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
@@ -165,10 +165,71 @@ ServiceWorkerRegistrationProxy::RevokeAc
   mActor = nullptr;
 
   nsCOMPtr<nsIRunnable> r =
     NewRunnableMethod(__func__, this,
                       &ServiceWorkerRegistrationProxy::StopListeningOnMainThread);
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 }
 
+namespace {
+
+class UpdateCallback final : public ServiceWorkerUpdateFinishCallback
+{
+  RefPtr<ServiceWorkerRegistrationPromise::Private> mPromise;
+
+  ~UpdateCallback() = default;
+
+public:
+  explicit UpdateCallback(RefPtr<ServiceWorkerRegistrationPromise::Private>&& aPromise)
+    : mPromise(std::move(aPromise))
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+  }
+
+  void
+  UpdateSucceeded(ServiceWorkerRegistrationInfo* aInfo) override
+  {
+    mPromise->Resolve(aInfo->Descriptor(), __func__);
+  }
+
+  void
+  UpdateFailed(ErrorResult& aResult) override
+  {
+    mPromise->Reject(CopyableErrorResult(aResult), __func__);
+  }
+};
+
+} // anonymous namespace
+
+RefPtr<ServiceWorkerRegistrationPromise>
+ServiceWorkerRegistrationProxy::Update()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ServiceWorkerRegistrationProxy> self = this;
+  RefPtr<ServiceWorkerRegistrationPromise::Private> promise =
+    new ServiceWorkerRegistrationPromise::Private(__func__);
+
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
+    [self, promise] () mutable {
+      auto scopeExit = MakeScopeExit([&] {
+        promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      });
+
+      NS_ENSURE_TRUE_VOID(self->mReg);
+
+      RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+      NS_ENSURE_TRUE_VOID(swm);
+
+      RefPtr<UpdateCallback> cb = new UpdateCallback(std::move(promise));
+      swm->Update(self->mReg->Principal(), self->mReg->Scope(), cb);
+
+      scopeExit.release();
+    });
+
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+  return promise;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationProxy.h b/dom/serviceworkers/ServiceWorkerRegistrationProxy.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationProxy.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationProxy.h
@@ -2,19 +2,21 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef moz_dom_ServiceWorkerRegistrationProxy_h
 #define moz_dom_ServiceWorkerRegistrationProxy_h
 
+#include "mozilla/dom/PServiceWorkerRegistrationParent.h"
 #include "nsProxyRelease.h"
 #include "ServiceWorkerRegistrationDescriptor.h"
 #include "ServiceWorkerRegistrationListener.h"
+#include "ServiceWorkerUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 class ServiceWorkerRegistrationInfo;
 class ServiceWorkerRegistrationParent;
 
 class ServiceWorkerRegistrationProxy final : public ServiceWorkerRegistrationListener
@@ -65,15 +67,18 @@ public:
   explicit ServiceWorkerRegistrationProxy(const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
   void
   Init(ServiceWorkerRegistrationParent* aActor);
 
   void
   RevokeActor(ServiceWorkerRegistrationParent* aActor);
 
+  RefPtr<ServiceWorkerRegistrationPromise>
+  Update();
+
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerRegistrationProxy, override);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // moz_dom_ServiceWorkerRegistrationProxy_h
