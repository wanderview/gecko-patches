# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7c2e2da4c608f6c649c0f6e0072a74d023e7ad6f

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -9,16 +9,19 @@
 #include <algorithm>
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/Casting.h"
 #include "mozilla/dom/ClientChannelHelper.h"
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
@@ -3316,16 +3319,52 @@ nsDocShell::GetParent(nsIDocShellTreeIte
 already_AddRefed<nsDocShell>
 nsDocShell::GetParentDocshell()
 {
   nsCOMPtr<nsIDocShell> docshell = do_QueryInterface(GetAsSupports(mParent));
   return docshell.forget().downcast<nsDocShell>();
 }
 
 void
+nsDocShell::EnsureInnerWindowOrInitialClientSource()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mInitialClientSource);
+
+  if (mScriptGlobal && mScriptGlobal->GetExtantDoc()) {
+    MOZ_DIAGNOSTIC_ASSERT(mScriptGlobal->GetCurrentInnerWindowInternal()->GetClientInfo().isSome());
+    return;
+  }
+
+  mInitialClientSource = ClientManager::CreateSource(ClientType::Window,
+                                                     GetInheritedPrincipal(false));
+
+  mInitialClientSource->DocShellExecutionReady(this);
+}
+
+Maybe<ClientInfo>
+nsDocShell::GetInitialClientInfo() const
+{
+  if (mInitialClientSource) {
+    Maybe<ClientInfo> result;
+    result.emplace(mInitialClientSource->Info());
+    return Move(result);
+  }
+
+  nsGlobalWindow* innerWindow =
+    mScriptGlobal ? mScriptGlobal->GetCurrentInnerWindowInternal() : nullptr;
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+
+  if (!doc || !doc->IsInitialDocument()) {
+    return Maybe<ClientInfo>();
+  }
+
+  return innerWindow->GetClientInfo();
+}
+
+void
 nsDocShell::RecomputeCanExecuteScripts()
 {
   bool old = mCanExecuteScripts;
   RefPtr<nsDocShell> parent = GetParentDocshell();
 
   // If we have no tree owner, that means that we've been detached from the
   // docshell tree (this is distinct from having no parent dochshell, which
   // is the case for root docshells). It would be nice to simply disallow
@@ -5827,16 +5866,19 @@ nsDocShell::Destroy()
       const char* msg = mItemType == typeContent ?
         NS_WEBNAVIGATION_DESTROY : NS_CHROME_WEBNAVIGATION_DESTROY;
       serv->NotifyObservers(GetAsSupports(this), msg, nullptr);
     }
   }
 
   mIsBeingDestroyed = true;
 
+  // Break the cycle with the initial client, if present.
+  mInitialClientSource = nullptr;
+
   // Make sure we don't record profile timeline markers anymore
   SetRecordProfileTimelineMarkers(false);
 
   // Remove our pref observers
   if (mObserveErrorPages) {
     mObserveErrorPages = false;
   }
 
@@ -7659,16 +7701,20 @@ nsDocShell::EndPageLoad(nsIWebProgress* 
         internalLoadGroup->OnEndPageLoad(aChannel);
       }
     }
   }
 
   // Timing is picked up by the window, we don't need it anymore
   mTiming = nullptr;
 
+  // Make sure to discard the initial Client if we never created the initial
+  // about:blank document.
+  mInitialClientSource.reset();
+
   // clean up reload state for meta charset
   if (eCharsetReloadRequested == mCharsetReloadState) {
     mCharsetReloadState = eCharsetReloadStopOrigional;
   } else {
     mCharsetReloadState = eCharsetReloadInit;
   }
 
   // Save a pointer to the currently-loading history entry.
@@ -11541,17 +11587,19 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
 
-  rv = AddClientChannelHelperToChannel(this, aChannel);
+  EnsureInnerWindowOrInitialClientSource();
+
+  rv = AddClientChannelHelper(this, aChannel, GetInitialClientInfo());
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
@@ -14896,16 +14944,22 @@ nsDocShell::InFrameSwap()
     if (shell->mInFrameSwap) {
       return true;
     }
     shell = shell->GetParentDocshell();
   } while (shell);
   return false;
 }
 
+UniquePtr<ClientSource>
+nsDocShell::TakeInitialClientSource()
+{
+  return Move(mInitialClientSource);
+}
+
 NS_IMETHODIMP
 nsDocShell::IssueWarning(uint32_t aWarning, bool aAsError)
 {
   if (mContentViewer) {
     nsCOMPtr<nsIDocument> doc = mContentViewer->GetDocument();
     if (doc) {
       doc->WarnOnceAbout(nsIDocument::DeprecatedOperations(aWarning), aAsError);
     }
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -14,16 +14,17 @@
 #include "nsIBaseWindow.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIScrollable.h"
 #include "nsITextScroll.h"
 #include "nsIContentViewerContainer.h"
 #include "nsIDOMStorageManager.h"
 #include "nsDocLoader.h"
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/Maybe.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/TimeStamp.h"
 #include "GeckoProfiler.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/LinkedList.h"
 #include "jsapi.h"
 
@@ -59,16 +60,18 @@
 #include "prtime.h"
 #include "nsRect.h"
 #include "Units.h"
 #include "nsIDeprecationWarner.h"
 
 namespace mozilla {
 enum class TaskCategory;
 namespace dom {
+class ClientInfo;
+class ClientSource;
 class EventTarget;
 class PendingGlobalHistoryEntry;
 typedef uint32_t ScreenOrientationInternal;
 } // namespace dom
 } // namespace mozilla
 
 class nsDocShell;
 class nsDOMNavigationTiming;
@@ -269,16 +272,19 @@ public:
   void NotifyAsyncPanZoomStopped();
 
   void SetInFrameSwap(bool aInSwap)
   {
     mInFrameSwap = aInSwap;
   }
   bool InFrameSwap();
 
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() override;
+
 private:
   bool CanSetOriginAttributes();
 
 public:
   const mozilla::OriginAttributes&
   GetOriginAttributes()
   {
     return mOriginAttributes;
@@ -736,16 +742,19 @@ protected:
 
   nsIChannel* GetCurrentDocChannel();
 
   bool ShouldBlockLoadingForBackButton();
 
   // Convenience method for getting our parent docshell. Can return null
   already_AddRefed<nsDocShell> GetParentDocshell();
 
+  void EnsureInnerWindowOrInitialClientSource();
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetInitialClientInfo() const;
+
 protected:
   nsresult GetCurScrollPos(int32_t aScrollOrientation, int32_t* aCurPos);
   nsresult SetCurScrollPosEx(int32_t aCurHorizontalPos,
                              int32_t aCurVerticalPos);
 
   // Override the parent setter from nsDocLoader
   virtual nsresult SetDocLoaderParent(nsDocLoader* aLoader) override;
 
@@ -1044,16 +1053,18 @@ private:
   nsTObserverArray<nsWeakPtr> mReflowObservers;
   nsTObserverArray<nsWeakPtr> mScrollObservers;
   nsCString mOriginalUriString;
   nsWeakPtr mOpener;
   mozilla::OriginAttributes mOriginAttributes;
 
   mozilla::UniquePtr<mozilla::dom::PendingGlobalHistoryEntry> mPrerenderGlobalHistory;
 
+  mozilla::UniquePtr<mozilla::dom::ClientSource> mInitialClientSource;
+
   // A depth count of how many times NotifyRunToCompletionStart
   // has been called without a matching NotifyRunToCompletionStop.
   uint32_t mJSRunToCompletionDepth;
 
   // Whether or not touch events are overridden. Possible values are defined
   // as constants in the nsIDocShell.idl file.
   uint32_t mTouchEventsOverride;
 
diff --git a/docshell/base/nsIDocShell.idl b/docshell/base/nsIDocShell.idl
--- a/docshell/base/nsIDocShell.idl
+++ b/docshell/base/nsIDocShell.idl
@@ -6,18 +6,25 @@
 
 #include "domstubs.idl"
 #include "nsIDocShellTreeItem.idl"
 #include "nsIRequest.idl"
 
 %{ C++
 #include "js/TypeDecls.h"
 #include "mozilla/Maybe.h"
+#include "mozilla/UniquePtr.h"
 class nsPresContext;
 class nsIPresShell;
+
+namespace mozilla {
+namespace dom {
+class ClientSource;
+} // namespace dom
+} // namespace mozilla
 %}
 
 /**
  * The nsIDocShell interface.
  */
 
 [ptr] native nsPresContext(nsPresContext);
 [ptr] native nsIPresShell(nsIPresShell);
@@ -1143,9 +1150,16 @@ interface nsIDocShell : nsIDocShellTreeI
    * Attribute that determines whether tracking protection is enabled.
    */
   attribute boolean useTrackingProtection;
 
  /**
   * Fire a dummy location change event asynchronously.
   */
   [noscript] void dispatchLocationChangeEvent();
+
+
+%{ C++
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() = 0;
+%}
+
 };
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -2440,16 +2440,18 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIntlUtils)
 #endif
 
   tmp->UnlinkHostObjectURIs();
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIdleRequestExecutor)
   tmp->DisableIdleCallbackRequests();
 
+  tmp->mClientSource.reset();
+
   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 #ifdef DEBUG
 void
 nsGlobalWindow::RiskyUnlink()
 {
   NS_CYCLE_COLLECTION_INNERNAME.Unlink(this);
@@ -3498,33 +3500,51 @@ nsGlobalWindow::InnerSetNewDocument(JSCo
 nsresult
 nsGlobalWindow::EnsureClientSource()
 {
   MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
   MOZ_DIAGNOSTIC_ASSERT(mDoc);
 
   bool newClientSource = false;
 
-  nsCOMPtr<nsILoadInfo> loadInfo;
   nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
-  if (channel) {
-    loadInfo = channel->GetLoadInfo();
-  }
-
-  // Try to get the reserved client from the loading document
+  nsCOMPtr<nsILoadInfo> loadInfo = channel ? channel->GetLoadInfo() : nullptr;
+
+  // Try to get the reserved client from the LoadInfo.  A Client is
+  // reserved at the start of the channel load if there is not an
+  // initial about:blank document that will be reused.  It is also
+  // created if the channel load encounters a cross-origin redirect.
   if (loadInfo) {
     UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClient();
     if (reservedClient) {
       mClientSource.reset();
       mClientSource = Move(reservedClient);
       newClientSource = true;
     }
   }
 
-  // If we don't have a reserved client we need to create one now
+  // We don't have a LoadInfo reserved client, but maybe we should
+  // be inheriting an initial one from the docshell.  This means
+  // that the docshell started the channel load before creating the
+  // initial about:blank document.  This is an optimization, though,
+  // and it created an initial Client as a placeholder for the document.
+  // In this case we want to inherit this placeholder Client here.
+  if (!mClientSource) {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      mClientSource = docshell->TakeInitialClientSource();
+      if (mClientSource) {
+        newClientSource = true;
+      }
+    }
+  }
+
+  // If we don't have a reserved client or an initial client, then create
+  // one now.  For example, this can happen if the docshell creates the
+  // initial about:blank document before it starts the channel load.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
     newClientSource = true;
   }
@@ -3536,16 +3556,18 @@ nsGlobalWindow::EnsureClientSource()
   if (loadInfo) {
     const Maybe<ServiceWorkerDescriptor>& controller =
       loadInfo->GetController();
     if (controller.isSome()) {
       mClientSource->SetController(controller.ref());
     }
   }
 
+  // Its possible that we got a client just after being frozen in
+  // the bfcache.  In that case freeze the client immediately.
   if (newClientSource && IsFrozen()) {
     mClientSource->Freeze();
   }
 
   return NS_OK;
 }
 
 nsresult
diff --git a/dom/clients/manager/ClientChannelHelper.cpp b/dom/clients/manager/ClientChannelHelper.cpp
--- a/dom/clients/manager/ClientChannelHelper.cpp
+++ b/dom/clients/manager/ClientChannelHelper.cpp
@@ -4,27 +4,30 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientChannelHelper.h"
 
 #include "ClientManager.h"
 #include "ClientSource.h"
 #include "MainThreadUtils.h"
+#include "mozilla/ipc/BackgroundUtils.h"
 #include "nsContentUtils.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsIChannel.h"
 #include "nsIChannelEventSink.h"
 #include "nsIDocShell.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::PrincipalInfoToPrincipal;
+
 namespace {
 
 class ClientChannelHelper final : public nsIInterfaceRequestor
                                 , public nsIChannelEventSink
 {
   nsCOMPtr<nsIInterfaceRequestor> mOuter;
 
   ~ClientChannelHelper()
@@ -143,17 +146,18 @@ public:
 };
 
 NS_IMPL_ISUPPORTS(ClientChannelHelper, nsIInterfaceRequestor,
                                        nsIChannelEventSink);
 
 } // anonymous namespace
 
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel)
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
   if (NS_WARN_IF(!loadInfo)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -163,33 +167,26 @@ AddClientChannelHelperToChannel(nsIDocSh
   }
 
   nsCOMPtr<nsIPrincipal> channelPrincipal;
   nsresult rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(channelPrincipal));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  Maybe<ClientInfo> initialClientInfo;
-  nsPIDOMWindowOuter* outerWindow = aDocShell->GetWindow();
-  if (outerWindow) {
-    nsPIDOMWindowInner* innerWindow = outerWindow->GetCurrentInnerWindow();
-    if (innerWindow) {
-      nsIDocument* doc = innerWindow->GetExtantDoc();
-      if (doc && doc->IsInitialDocument()) {
-        nsIPrincipal* initialPrincipal = doc->NodePrincipal();
+  Maybe<ClientInfo> initialClientInfo(Move(aInitialClientInfo));
+  if (initialClientInfo.isSome()) {
+    nsCOMPtr<nsIPrincipal> initialPrincipal =
+      PrincipalInfoToPrincipal(initialClientInfo.ref().PrincipalInfo(), nullptr);
 
-        // This should match the checking in
-        // nsGlobalWindow::WouldReuseInnerWindow().
-        bool equals = false;
-        rv = initialPrincipal->Equals(channelPrincipal, &equals);
-        if (NS_SUCCEEDED(rv) && equals) {
-          initialClientInfo = innerWindow->GetClientInfo();
-        }
-      }
+    bool equals = false;
+    rv = initialPrincipal ? initialPrincipal->Equals(channelPrincipal, &equals)
+                          : NS_ERROR_FAILURE;
+    if (NS_FAILED(rv) || !equals) {
+      initialClientInfo.reset();
     }
   }
 
   nsCOMPtr<nsIInterfaceRequestor> outerCallbacks;
   rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outerCallbacks));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
diff --git a/dom/clients/manager/ClientChannelHelper.h b/dom/clients/manager/ClientChannelHelper.h
--- a/dom/clients/manager/ClientChannelHelper.h
+++ b/dom/clients/manager/ClientChannelHelper.h
@@ -1,23 +1,27 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientChannelHelper_h
 #define _mozilla_dom_ClientChannelHelper_h
 
+#include "mozilla/Maybe.h"
 #include "nsError.h"
 
 class nsIChannel;
 class nsIDocShell;
 
 namespace mozilla {
 namespace dom {
 
+class ClientInfo;
+
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel);
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo);
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientChannelHelper_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -84,19 +84,50 @@ ClientSource::SnapshotWindowState(Client
   }
 
   *aStateOut = ClientState(ClientWindowState(doc->VisibilityState(),
                                              doc->LastFocusTime(), focused));
 
   return NS_OK;
 }
 
+WorkerPrivate*
+ClientSource::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<WorkerPrivate*>()) {
+    return nullptr;
+  }
+  return mOwner.as<WorkerPrivate*>();
+}
+
+nsIDocShell*
+ClientSource::GetDocShell() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<nsCOMPtr<nsIDocShell>>()) {
+    return nullptr;
+  }
+  return mOwner.as<nsCOMPtr<nsIDocShell>>();
+}
+
+void
+ClientSource::MaybeCreateInitialDocument()
+{
+  nsIDocShell* docshell = GetDocShell();
+  if (docshell) {
+    // Force the create of the initial document if it does not exist yet.
+    Unused << docshell->GetDocument();
+  }
+}
+
 ClientSource::ClientSource(ClientManager* aManager,
                            const ClientSourceConstructorArgs& aArgs)
   : mManager(aManager)
+  , mOwner(AsVariant(Nothing()))
   , mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
 {
   MOZ_ASSERT(mManager);
 }
 
 void
 ClientSource::Activate(PClientManagerChild* aActor)
 {
@@ -124,42 +155,32 @@ ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
 nsPIDOMWindowInner*
 ClientSource::GetInnerWindow() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() || !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
+  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
     return nullptr;
   }
-  return mOwner.ref().as<RefPtr<nsPIDOMWindowInner>>();
-}
-
-WorkerPrivate*
-ClientSource::GetWorkerPrivate() const
-{
-  NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() || !mOwner.ref().is<WorkerPrivate*>()) {
-    return nullptr;
-  }
-  return mOwner.ref().as<WorkerPrivate*>();
+  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   // Its safe to store the WorkerPrivate* here because the ClientSource
   // is explicitly destroyed by WorkerPrivate before exiting its run loop.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing());
-  mOwner.emplace(AsVariant(aWorkerPrivate));
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>());
+  mOwner = AsVariant(aWorkerPrivate);
 
   ClientSourceExecutionReadyArgs args(
     aWorkerPrivate->GetLocationInfo().mHref,
     FrameType::None);
 
   ExecutionReady(args);
 }
 
@@ -199,23 +220,55 @@ ClientSource::WindowExecutionReady(nsPID
   }
 
   ClientSourceExecutionReadyArgs args(spec, frameType);
   ExecutionReady(args);
 
   // We should either be setting a window execution ready for the
   // first time or setting the same window execution ready again.
   // The secondary calls are due to initial about:blank replacement.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing() ||
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>() ||
+                        mOwner.is<nsCOMPtr<nsIDocShell>>() ||
                         GetInnerWindow() == aInnerWindow);
 
   // This creates a cycle with the window.  It is broken when
   // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
-  mOwner.reset();
-  mOwner.emplace(AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow)));
+  mOwner = AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow));
+
+  return NS_OK;
+}
+
+nsresult
+ClientSource::DocShellExecutionReady(nsIDocShell* aDocShell)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_DIAGNOSTIC_ASSERT(aDocShell);
+
+  nsPIDOMWindowOuter* outer = aDocShell->GetWindow();
+  if (NS_WARN_IF(!outer)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // TODO: dedupe this with WindowExecutionReady
+  FrameType frameType = FrameType::Top_level;
+  if (!outer->IsTopLevelWindow()) {
+    frameType = FrameType::Nested;
+  } else if(outer->HadOriginalOpener()) {
+    frameType = FrameType::Auxiliary;
+  }
+
+  ClientSourceExecutionReadyArgs args(NS_LITERAL_CSTRING("about:blank"),
+                                      frameType);
+  ExecutionReady(args);
+
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>());
+
+  // This creates a cycle with the docshell.  It is broken when
+  // nsDocShell::Destroy() deletes the ClientSource.
+  mOwner = AsVariant(nsCOMPtr<nsIDocShell>(aDocShell));
 
   return NS_OK;
 }
 
 void
 ClientSource::Freeze()
 {
   MaybeExecute([](PClientSourceChild* aActor) {
@@ -304,27 +357,37 @@ ClientSource::Focus(const ClientFocusArg
   RefPtr<ClientOpPromise> ref;
 
   if (mClientInfo.Type() != ClientType::Window) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
                                            __func__);
     return ref.forget();
   }
 
-  nsPIDOMWindowInner* window = GetInnerWindow();
-  if (!window) {
+  nsPIDOMWindowOuter* outer = nullptr;
+
+  nsPIDOMWindowInner* inner = GetInnerWindow();
+  if (inner) {
+    outer = inner->GetOuterWindow();
+  } else {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      outer = docshell->GetWindow();
+    }
+  }
+
+  if (!outer) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
                                            __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv =
-    nsContentUtils::DispatchFocusChromeEvent(window->GetOuterWindow());
+  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(outer);
   if (NS_FAILED(rv)) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ClientState state;
   rv = SnapshotState(&state);
   if (NS_FAILED(rv)) {
@@ -356,16 +419,19 @@ ClientSource::PostMessage(const ClientPo
 
   StructuredCloneData clonedData;
   clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
 
   RefPtr<ServiceWorkerContainer> target;
   nsCOMPtr<nsIGlobalObject> globalObject;
   if (mClientInfo.Type() == ClientType::Window) {
     MOZ_ASSERT(NS_IsMainThread());
+    // We don't need to force the creation of the about:blank document
+    // here because there is no postMessage listener.  If a listener
+    // was registered then the document will already be created.
     nsPIDOMWindowInner* window = GetInnerWindow();
     if (window) {
       globalObject = nsGlobalWindow::Cast(window);
       RefPtr<Navigator> navigator =
         static_cast<Navigator*>(window->GetNavigator());
       if (navigator) {
         target = navigator->ServiceWorker();
       }
@@ -558,16 +624,17 @@ nsresult
 ClientSource::SnapshotState(ClientState* aStateOut)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   MOZ_DIAGNOSTIC_ASSERT(aStateOut);
 
   // TODO: Handle state on reserved client where no window/workerprivate yet.
 
   if (mClientInfo.Type() == ClientType::Window) {
+    MaybeCreateInitialDocument();
     nsresult rv = SnapshotWindowState(aStateOut);
     if (NS_FAILED(rv)) {
       return rv;
     }
     return NS_OK;
   }
 
   *aStateOut = ClientState(ClientWorkerState());
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -11,16 +11,17 @@
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/Variant.h"
 #include "ClientOpPromise.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
+class nsIDocShell;
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class ClientClaimArgs;
 class ClientControlledArgs;
 class ClientFocusArgs;
@@ -43,53 +44,64 @@ class ClientSource final : public Client
 {
   friend class ClientManager;
   friend class ClientSourceChild;
 
   NS_DECL_OWNINGTHREAD
 
   RefPtr<ClientManager> mManager;
 
-  Maybe<Variant<RefPtr<nsPIDOMWindowInner>,
-                mozilla::dom::workers::WorkerPrivate*>> mOwner;
+  Variant<Nothing,
+          RefPtr<nsPIDOMWindowInner>,
+          nsCOMPtr<nsIDocShell>,
+          mozilla::dom::workers::WorkerPrivate*> mOwner;
 
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
   void
   Shutdown();
 
   void
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
 
   nsresult
   SnapshotWindowState(ClientState* aStateOut);
 
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+
+  nsIDocShell*
+  GetDocShell() const;
+
+  void
+  MaybeCreateInitialDocument();
+
   // Private methods called by ClientManager
   ClientSource(ClientManager* aManager,
                const ClientSourceConstructorArgs& aArgs);
 
   void
   Activate(PClientManagerChild* aActor);
 
 public:
   ~ClientSource();
 
   nsPIDOMWindowInner*
   GetInnerWindow() const;
 
-  mozilla::dom::workers::WorkerPrivate*
-  GetWorkerPrivate() const;
-
   void
   WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
 
   nsresult
   WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
 
+  nsresult
+  DocShellExecutionReady(nsIDocShell* aDocShell);
+
   void
   Freeze();
 
   void
   Thaw();
 
   const ClientInfo&
   Info() const;
