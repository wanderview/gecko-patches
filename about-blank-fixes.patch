# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7c2e2da4c608f6c649c0f6e0072a74d023e7ad6f

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -9,16 +9,20 @@
 #include <algorithm>
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/Casting.h"
 #include "mozilla/dom/ClientChannelHelper.h"
+#include "mozilla/dom/ClientHandle.h"
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
@@ -3316,16 +3320,101 @@ nsDocShell::GetParent(nsIDocShellTreeIte
 already_AddRefed<nsDocShell>
 nsDocShell::GetParentDocshell()
 {
   nsCOMPtr<nsIDocShell> docshell = do_QueryInterface(GetAsSupports(mParent));
   return docshell.forget().downcast<nsDocShell>();
 }
 
 void
+nsDocShell::MaybeCreateInitialClientSource(nsIPrincipal* aPrincipal)
+{
+  // If there is an existing document then there is no need to create
+  // a client for a future initial about:blank document.
+  if (mScriptGlobal && mScriptGlobal->GetExtantDoc()) {
+    MOZ_DIAGNOSTIC_ASSERT(mScriptGlobal->GetCurrentInnerWindowInternal()->GetClientInfo().isSome());
+    MOZ_DIAGNOSTIC_ASSERT(!mInitialClientSource);
+    return;
+  }
+
+  // Don't recreate the initial client source.  We call this multiple times
+  // when DoChannelLoad() is called before CreateAboutBlankContentViewer.
+  if (mInitialClientSource) {
+    return;
+  }
+
+  // Don't pre-allocate the client when we are sandboxed.  The inherited
+  // principal does not take sandboxing into account.
+  // TODO: Refactor sandboxing principal code out so we can use it here.
+  if (!aPrincipal && (mSandboxFlags & SANDBOXED_ORIGIN)) {
+    return;
+  }
+
+  nsIPrincipal* principal = aPrincipal ? aPrincipal
+                                       : GetInheritedPrincipal(false);
+
+  // Sometimes there is no principal available when we are called from
+  // CreateAboutBlankContentViewer.  For example, sometimes the principal
+  // is only extracted from the load context after the document is created
+  // in nsDocument::ResetToURI().  Ideally we would do something similar
+  // here, but for now lets just avoid the issue by not preallocating the
+  // client.
+  if (!principal) {
+    return;
+  }
+
+  mInitialClientSource = ClientManager::CreateSource(ClientType::Window,
+                                                     principal);
+
+  // Mark the initial client as execution ready, but owned by the docshell.
+  // If the client is actually used this will cause ClientSource to force
+  // the creation of the initial about:blank by calling nsDocShell::GetDocument().
+  mInitialClientSource->DocShellExecutionReady(this);
+
+  // Next, check to see if the parent is controlled.
+  nsCOMPtr<nsIDocShell> parent = GetParentDocshell();
+  nsPIDOMWindowOuter* parentOuter = parent ? parent->GetWindow() : nullptr;
+  nsPIDOMWindowInner* parentInner = parentOuter ? parentOuter->GetCurrentInnerWindow() : nullptr;
+  if (!parentInner) {
+    return;
+  }
+
+  Maybe<ServiceWorkerDescriptor> controller(parentInner->GetController());
+  if (controller.isNothing()) {
+    return;
+  }
+
+  // If the parent is controlled then propagate that controller to the
+  // initial about:blank client as well.
+  RefPtr<ClientHandle> handle =
+    ClientManager::CreateHandle(mInitialClientSource->Info());
+  RefPtr<GenericPromise> ref = handle->Control(controller.ref());
+}
+
+Maybe<ClientInfo>
+nsDocShell::GetInitialClientInfo() const
+{
+  if (mInitialClientSource) {
+    Maybe<ClientInfo> result;
+    result.emplace(mInitialClientSource->Info());
+    return Move(result);
+  }
+
+  nsGlobalWindow* innerWindow =
+    mScriptGlobal ? mScriptGlobal->GetCurrentInnerWindowInternal() : nullptr;
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+
+  if (!doc || !doc->IsInitialDocument()) {
+    return Maybe<ClientInfo>();
+  }
+
+  return innerWindow->GetClientInfo();
+}
+
+void
 nsDocShell::RecomputeCanExecuteScripts()
 {
   bool old = mCanExecuteScripts;
   RefPtr<nsDocShell> parent = GetParentDocshell();
 
   // If we have no tree owner, that means that we've been detached from the
   // docshell tree (this is distinct from having no parent dochshell, which
   // is the case for root docshells). It would be nice to simply disallow
@@ -5827,16 +5916,19 @@ nsDocShell::Destroy()
       const char* msg = mItemType == typeContent ?
         NS_WEBNAVIGATION_DESTROY : NS_CHROME_WEBNAVIGATION_DESTROY;
       serv->NotifyObservers(GetAsSupports(this), msg, nullptr);
     }
   }
 
   mIsBeingDestroyed = true;
 
+  // Break the cycle with the initial client, if present.
+  mInitialClientSource = nullptr;
+
   // Make sure we don't record profile timeline markers anymore
   SetRecordProfileTimelineMarkers(false);
 
   // Remove our pref observers
   if (mObserveErrorPages) {
     mObserveErrorPages = false;
   }
 
@@ -7659,16 +7751,20 @@ nsDocShell::EndPageLoad(nsIWebProgress* 
         internalLoadGroup->OnEndPageLoad(aChannel);
       }
     }
   }
 
   // Timing is picked up by the window, we don't need it anymore
   mTiming = nullptr;
 
+  // Make sure to discard the initial Client if we never created the initial
+  // about:blank document.
+  mInitialClientSource.reset();
+
   // clean up reload state for meta charset
   if (eCharsetReloadRequested == mCharsetReloadState) {
     mCharsetReloadState = eCharsetReloadStopOrigional;
   } else {
     mCharsetReloadState = eCharsetReloadInit;
   }
 
   // Save a pointer to the currently-loading history entry.
@@ -8154,16 +8250,19 @@ nsDocShell::CreateAboutBlankContentViewe
       if (aPrincipal) {
         principal = NullPrincipal::CreateWithInheritedAttributes(aPrincipal);
       } else {
         principal = NullPrincipal::CreateWithInheritedAttributes(this);
       }
     } else {
       principal = aPrincipal;
     }
+
+    MaybeCreateInitialClientSource(principal);
+
     // generate (about:blank) document to load
     docFactory->CreateBlankDocument(mLoadGroup, principal,
                                     getter_AddRefs(blankDoc));
     if (blankDoc) {
       // Hack: set the base URI manually, since this document never
       // got Reset() with a channel.
       blankDoc->SetBaseURI(aBaseURI);
 
@@ -11541,17 +11640,19 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
 
-  rv = AddClientChannelHelperToChannel(this, aChannel);
+  MaybeCreateInitialClientSource();
+
+  rv = AddClientChannelHelper(this, aChannel, GetInitialClientInfo());
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
@@ -14896,16 +14997,22 @@ nsDocShell::InFrameSwap()
     if (shell->mInFrameSwap) {
       return true;
     }
     shell = shell->GetParentDocshell();
   } while (shell);
   return false;
 }
 
+UniquePtr<ClientSource>
+nsDocShell::TakeInitialClientSource()
+{
+  return Move(mInitialClientSource);
+}
+
 NS_IMETHODIMP
 nsDocShell::IssueWarning(uint32_t aWarning, bool aAsError)
 {
   if (mContentViewer) {
     nsCOMPtr<nsIDocument> doc = mContentViewer->GetDocument();
     if (doc) {
       doc->WarnOnceAbout(nsIDocument::DeprecatedOperations(aWarning), aAsError);
     }
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -14,16 +14,17 @@
 #include "nsIBaseWindow.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIScrollable.h"
 #include "nsITextScroll.h"
 #include "nsIContentViewerContainer.h"
 #include "nsIDOMStorageManager.h"
 #include "nsDocLoader.h"
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/Maybe.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/TimeStamp.h"
 #include "GeckoProfiler.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/LinkedList.h"
 #include "jsapi.h"
 
@@ -59,16 +60,18 @@
 #include "prtime.h"
 #include "nsRect.h"
 #include "Units.h"
 #include "nsIDeprecationWarner.h"
 
 namespace mozilla {
 enum class TaskCategory;
 namespace dom {
+class ClientInfo;
+class ClientSource;
 class EventTarget;
 class PendingGlobalHistoryEntry;
 typedef uint32_t ScreenOrientationInternal;
 } // namespace dom
 } // namespace mozilla
 
 class nsDocShell;
 class nsDOMNavigationTiming;
@@ -269,16 +272,19 @@ public:
   void NotifyAsyncPanZoomStopped();
 
   void SetInFrameSwap(bool aInSwap)
   {
     mInFrameSwap = aInSwap;
   }
   bool InFrameSwap();
 
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() override;
+
 private:
   bool CanSetOriginAttributes();
 
 public:
   const mozilla::OriginAttributes&
   GetOriginAttributes()
   {
     return mOriginAttributes;
@@ -736,16 +742,19 @@ protected:
 
   nsIChannel* GetCurrentDocChannel();
 
   bool ShouldBlockLoadingForBackButton();
 
   // Convenience method for getting our parent docshell. Can return null
   already_AddRefed<nsDocShell> GetParentDocshell();
 
+  void MaybeCreateInitialClientSource(nsIPrincipal* aPrincipal = nullptr);
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetInitialClientInfo() const;
+
 protected:
   nsresult GetCurScrollPos(int32_t aScrollOrientation, int32_t* aCurPos);
   nsresult SetCurScrollPosEx(int32_t aCurHorizontalPos,
                              int32_t aCurVerticalPos);
 
   // Override the parent setter from nsDocLoader
   virtual nsresult SetDocLoaderParent(nsDocLoader* aLoader) override;
 
@@ -1044,16 +1053,18 @@ private:
   nsTObserverArray<nsWeakPtr> mReflowObservers;
   nsTObserverArray<nsWeakPtr> mScrollObservers;
   nsCString mOriginalUriString;
   nsWeakPtr mOpener;
   mozilla::OriginAttributes mOriginAttributes;
 
   mozilla::UniquePtr<mozilla::dom::PendingGlobalHistoryEntry> mPrerenderGlobalHistory;
 
+  mozilla::UniquePtr<mozilla::dom::ClientSource> mInitialClientSource;
+
   // A depth count of how many times NotifyRunToCompletionStart
   // has been called without a matching NotifyRunToCompletionStop.
   uint32_t mJSRunToCompletionDepth;
 
   // Whether or not touch events are overridden. Possible values are defined
   // as constants in the nsIDocShell.idl file.
   uint32_t mTouchEventsOverride;
 
diff --git a/docshell/base/nsIDocShell.idl b/docshell/base/nsIDocShell.idl
--- a/docshell/base/nsIDocShell.idl
+++ b/docshell/base/nsIDocShell.idl
@@ -6,18 +6,25 @@
 
 #include "domstubs.idl"
 #include "nsIDocShellTreeItem.idl"
 #include "nsIRequest.idl"
 
 %{ C++
 #include "js/TypeDecls.h"
 #include "mozilla/Maybe.h"
+#include "mozilla/UniquePtr.h"
 class nsPresContext;
 class nsIPresShell;
+
+namespace mozilla {
+namespace dom {
+class ClientSource;
+} // namespace dom
+} // namespace mozilla
 %}
 
 /**
  * The nsIDocShell interface.
  */
 
 [ptr] native nsPresContext(nsPresContext);
 [ptr] native nsIPresShell(nsIPresShell);
@@ -1143,9 +1150,16 @@ interface nsIDocShell : nsIDocShellTreeI
    * Attribute that determines whether tracking protection is enabled.
    */
   attribute boolean useTrackingProtection;
 
  /**
   * Fire a dummy location change event asynchronously.
   */
   [noscript] void dispatchLocationChangeEvent();
+
+
+%{ C++
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() = 0;
+%}
+
 };
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -2440,16 +2440,18 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIntlUtils)
 #endif
 
   tmp->UnlinkHostObjectURIs();
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIdleRequestExecutor)
   tmp->DisableIdleCallbackRequests();
 
+  tmp->mClientSource.reset();
+
   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 #ifdef DEBUG
 void
 nsGlobalWindow::RiskyUnlink()
 {
   NS_CYCLE_COLLECTION_INNERNAME.Unlink(this);
@@ -3498,33 +3500,52 @@ nsGlobalWindow::InnerSetNewDocument(JSCo
 nsresult
 nsGlobalWindow::EnsureClientSource()
 {
   MOZ_DIAGNOSTIC_ASSERT(IsInnerWindow());
   MOZ_DIAGNOSTIC_ASSERT(mDoc);
 
   bool newClientSource = false;
 
-  nsCOMPtr<nsILoadInfo> loadInfo;
   nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
-  if (channel) {
-    loadInfo = channel->GetLoadInfo();
-  }
-
-  // Try to get the reserved client from the loading document
+  nsCOMPtr<nsILoadInfo> loadInfo = channel ? channel->GetLoadInfo() : nullptr;
+
+  // Try to get the reserved client from the LoadInfo.  A Client is
+  // reserved at the start of the channel load if there is not an
+  // initial about:blank document that will be reused.  It is also
+  // created if the channel load encounters a cross-origin redirect.
   if (loadInfo) {
     UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClient();
     if (reservedClient) {
       mClientSource.reset();
       mClientSource = Move(reservedClient);
       newClientSource = true;
     }
   }
 
-  // If we don't have a reserved client we need to create one now
+  // We don't have a LoadInfo reserved client, but maybe we should
+  // be inheriting an initial one from the docshell.  This means
+  // that the docshell started the channel load before creating the
+  // initial about:blank document.  This is an optimization, though,
+  // and it created an initial Client as a placeholder for the document.
+  // In this case we want to inherit this placeholder Client here.
+  if (!mClientSource) {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      mClientSource = docshell->TakeInitialClientSource();
+      if (mClientSource) {
+        newClientSource = true;
+      }
+    }
+  }
+
+  // If we don't have a reserved client or an initial client, then create
+  // one now.  This can happen in certain cases where we avoid preallocating
+  // the client in the docshell.  This mainly occurs in situations where
+  // the principal is not clearly inherited; e.g. sandboxed iframes, etc.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
     newClientSource = true;
   }
@@ -3536,16 +3557,18 @@ nsGlobalWindow::EnsureClientSource()
   if (loadInfo) {
     const Maybe<ServiceWorkerDescriptor>& controller =
       loadInfo->GetController();
     if (controller.isSome()) {
       mClientSource->SetController(controller.ref());
     }
   }
 
+  // Its possible that we got a client just after being frozen in
+  // the bfcache.  In that case freeze the client immediately.
   if (newClientSource && IsFrozen()) {
     mClientSource->Freeze();
   }
 
   return NS_OK;
 }
 
 nsresult
diff --git a/dom/clients/manager/ClientChannelHelper.cpp b/dom/clients/manager/ClientChannelHelper.cpp
--- a/dom/clients/manager/ClientChannelHelper.cpp
+++ b/dom/clients/manager/ClientChannelHelper.cpp
@@ -4,27 +4,30 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientChannelHelper.h"
 
 #include "ClientManager.h"
 #include "ClientSource.h"
 #include "MainThreadUtils.h"
+#include "mozilla/ipc/BackgroundUtils.h"
 #include "nsContentUtils.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsIChannel.h"
 #include "nsIChannelEventSink.h"
 #include "nsIDocShell.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::PrincipalInfoToPrincipal;
+
 namespace {
 
 class ClientChannelHelper final : public nsIInterfaceRequestor
                                 , public nsIChannelEventSink
 {
   nsCOMPtr<nsIInterfaceRequestor> mOuter;
 
   ~ClientChannelHelper()
@@ -143,17 +146,18 @@ public:
 };
 
 NS_IMPL_ISUPPORTS(ClientChannelHelper, nsIInterfaceRequestor,
                                        nsIChannelEventSink);
 
 } // anonymous namespace
 
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel)
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
   if (NS_WARN_IF(!loadInfo)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -163,33 +167,26 @@ AddClientChannelHelperToChannel(nsIDocSh
   }
 
   nsCOMPtr<nsIPrincipal> channelPrincipal;
   nsresult rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(channelPrincipal));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  Maybe<ClientInfo> initialClientInfo;
-  nsPIDOMWindowOuter* outerWindow = aDocShell->GetWindow();
-  if (outerWindow) {
-    nsPIDOMWindowInner* innerWindow = outerWindow->GetCurrentInnerWindow();
-    if (innerWindow) {
-      nsIDocument* doc = innerWindow->GetExtantDoc();
-      if (doc && doc->IsInitialDocument()) {
-        nsIPrincipal* initialPrincipal = doc->NodePrincipal();
+  Maybe<ClientInfo> initialClientInfo(Move(aInitialClientInfo));
+  if (initialClientInfo.isSome()) {
+    nsCOMPtr<nsIPrincipal> initialPrincipal =
+      PrincipalInfoToPrincipal(initialClientInfo.ref().PrincipalInfo(), nullptr);
 
-        // This should match the checking in
-        // nsGlobalWindow::WouldReuseInnerWindow().
-        bool equals = false;
-        rv = initialPrincipal->Equals(channelPrincipal, &equals);
-        if (NS_SUCCEEDED(rv) && equals) {
-          initialClientInfo = innerWindow->GetClientInfo();
-        }
-      }
+    bool equals = false;
+    rv = initialPrincipal ? initialPrincipal->Equals(channelPrincipal, &equals)
+                          : NS_ERROR_FAILURE;
+    if (NS_FAILED(rv) || !equals) {
+      initialClientInfo.reset();
     }
   }
 
   nsCOMPtr<nsIInterfaceRequestor> outerCallbacks;
   rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outerCallbacks));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
diff --git a/dom/clients/manager/ClientChannelHelper.h b/dom/clients/manager/ClientChannelHelper.h
--- a/dom/clients/manager/ClientChannelHelper.h
+++ b/dom/clients/manager/ClientChannelHelper.h
@@ -1,23 +1,27 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientChannelHelper_h
 #define _mozilla_dom_ClientChannelHelper_h
 
+#include "mozilla/Maybe.h"
 #include "nsError.h"
 
 class nsIChannel;
 class nsIDocShell;
 
 namespace mozilla {
 namespace dom {
 
+class ClientInfo;
+
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel);
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo);
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientChannelHelper_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -84,19 +84,52 @@ ClientSource::SnapshotWindowState(Client
   }
 
   *aStateOut = ClientState(ClientWindowState(doc->VisibilityState(),
                                              doc->LastFocusTime(), focused));
 
   return NS_OK;
 }
 
+WorkerPrivate*
+ClientSource::GetWorkerPrivate() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<WorkerPrivate*>()) {
+    return nullptr;
+  }
+  return mOwner.as<WorkerPrivate*>();
+}
+
+nsIDocShell*
+ClientSource::GetDocShell() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientSource);
+  if (!mOwner.is<nsCOMPtr<nsIDocShell>>()) {
+    return nullptr;
+  }
+  return mOwner.as<nsCOMPtr<nsIDocShell>>();
+}
+
+void
+ClientSource::MaybeCreateInitialDocument()
+{
+  nsIDocShell* docshell = GetDocShell();
+  if (docshell) {
+    // Force the create of the initial document if it does not exist yet.
+    Unused << docshell->GetDocument();
+
+    MOZ_DIAGNOSTIC_ASSERT(GetInnerWindow());
+  }
+}
+
 ClientSource::ClientSource(ClientManager* aManager,
                            const ClientSourceConstructorArgs& aArgs)
   : mManager(aManager)
+  , mOwner(AsVariant(Nothing()))
   , mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
 {
   MOZ_ASSERT(mManager);
 }
 
 void
 ClientSource::Activate(PClientManagerChild* aActor)
 {
@@ -124,42 +157,32 @@ ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
 nsPIDOMWindowInner*
 ClientSource::GetInnerWindow() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() || !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
+  if (!mOwner.is<RefPtr<nsPIDOMWindowInner>>()) {
     return nullptr;
   }
-  return mOwner.ref().as<RefPtr<nsPIDOMWindowInner>>();
-}
-
-WorkerPrivate*
-ClientSource::GetWorkerPrivate() const
-{
-  NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() || !mOwner.ref().is<WorkerPrivate*>()) {
-    return nullptr;
-  }
-  return mOwner.ref().as<WorkerPrivate*>();
+  return mOwner.as<RefPtr<nsPIDOMWindowInner>>();
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   // Its safe to store the WorkerPrivate* here because the ClientSource
   // is explicitly destroyed by WorkerPrivate before exiting its run loop.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing());
-  mOwner.emplace(AsVariant(aWorkerPrivate));
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>());
+  mOwner = AsVariant(aWorkerPrivate);
 
   ClientSourceExecutionReadyArgs args(
     aWorkerPrivate->GetLocationInfo().mHref,
     FrameType::None);
 
   ExecutionReady(args);
 }
 
@@ -199,23 +222,55 @@ ClientSource::WindowExecutionReady(nsPID
   }
 
   ClientSourceExecutionReadyArgs args(spec, frameType);
   ExecutionReady(args);
 
   // We should either be setting a window execution ready for the
   // first time or setting the same window execution ready again.
   // The secondary calls are due to initial about:blank replacement.
-  MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing() ||
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>() ||
+                        mOwner.is<nsCOMPtr<nsIDocShell>>() ||
                         GetInnerWindow() == aInnerWindow);
 
   // This creates a cycle with the window.  It is broken when
   // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
-  mOwner.reset();
-  mOwner.emplace(AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow)));
+  mOwner = AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow));
+
+  return NS_OK;
+}
+
+nsresult
+ClientSource::DocShellExecutionReady(nsIDocShell* aDocShell)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_DIAGNOSTIC_ASSERT(aDocShell);
+
+  nsPIDOMWindowOuter* outer = aDocShell->GetWindow();
+  if (NS_WARN_IF(!outer)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // TODO: dedupe this with WindowExecutionReady
+  FrameType frameType = FrameType::Top_level;
+  if (!outer->IsTopLevelWindow()) {
+    frameType = FrameType::Nested;
+  } else if(outer->HadOriginalOpener()) {
+    frameType = FrameType::Auxiliary;
+  }
+
+  ClientSourceExecutionReadyArgs args(NS_LITERAL_CSTRING("about:blank"),
+                                      frameType);
+  ExecutionReady(args);
+
+  MOZ_DIAGNOSTIC_ASSERT(mOwner.is<Nothing>());
+
+  // This creates a cycle with the docshell.  It is broken when
+  // nsDocShell::Destroy() deletes the ClientSource.
+  mOwner = AsVariant(nsCOMPtr<nsIDocShell>(aDocShell));
 
   return NS_OK;
 }
 
 void
 ClientSource::Freeze()
 {
   MaybeExecute([](PClientSourceChild* aActor) {
@@ -304,27 +359,37 @@ ClientSource::Focus(const ClientFocusArg
   RefPtr<ClientOpPromise> ref;
 
   if (mClientInfo.Type() != ClientType::Window) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_NOT_SUPPORTED_ERR,
                                            __func__);
     return ref.forget();
   }
 
-  nsPIDOMWindowInner* window = GetInnerWindow();
-  if (!window) {
+  nsPIDOMWindowOuter* outer = nullptr;
+
+  nsPIDOMWindowInner* inner = GetInnerWindow();
+  if (inner) {
+    outer = inner->GetOuterWindow();
+  } else {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      outer = docshell->GetWindow();
+    }
+  }
+
+  if (!outer) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
                                            __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
-  nsresult rv =
-    nsContentUtils::DispatchFocusChromeEvent(window->GetOuterWindow());
+  nsresult rv = nsContentUtils::DispatchFocusChromeEvent(outer);
   if (NS_FAILED(rv)) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
     return ref.forget();
   }
 
   ClientState state;
   rv = SnapshotState(&state);
   if (NS_FAILED(rv)) {
@@ -356,16 +421,19 @@ ClientSource::PostMessage(const ClientPo
 
   StructuredCloneData clonedData;
   clonedData.BorrowFromClonedMessageDataForBackgroundChild(aArgs.clonedData());
 
   RefPtr<ServiceWorkerContainer> target;
   nsCOMPtr<nsIGlobalObject> globalObject;
   if (mClientInfo.Type() == ClientType::Window) {
     MOZ_ASSERT(NS_IsMainThread());
+    // We don't need to force the creation of the about:blank document
+    // here because there is no postMessage listener.  If a listener
+    // was registered then the document will already be created.
     nsPIDOMWindowInner* window = GetInnerWindow();
     if (window) {
       globalObject = nsGlobalWindow::Cast(window);
       RefPtr<Navigator> navigator =
         static_cast<Navigator*>(window->GetNavigator());
       if (navigator) {
         target = navigator->ServiceWorker();
       }
@@ -558,16 +626,17 @@ nsresult
 ClientSource::SnapshotState(ClientState* aStateOut)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   MOZ_DIAGNOSTIC_ASSERT(aStateOut);
 
   // TODO: Handle state on reserved client where no window/workerprivate yet.
 
   if (mClientInfo.Type() == ClientType::Window) {
+    MaybeCreateInitialDocument();
     nsresult rv = SnapshotWindowState(aStateOut);
     if (NS_FAILED(rv)) {
       return rv;
     }
     return NS_OK;
   }
 
   *aStateOut = ClientState(ClientWorkerState());
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -11,16 +11,17 @@
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/Variant.h"
 #include "ClientOpPromise.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
+class nsIDocShell;
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class ClientClaimArgs;
 class ClientControlledArgs;
 class ClientFocusArgs;
@@ -43,53 +44,64 @@ class ClientSource final : public Client
 {
   friend class ClientManager;
   friend class ClientSourceChild;
 
   NS_DECL_OWNINGTHREAD
 
   RefPtr<ClientManager> mManager;
 
-  Maybe<Variant<RefPtr<nsPIDOMWindowInner>,
-                mozilla::dom::workers::WorkerPrivate*>> mOwner;
+  Variant<Nothing,
+          RefPtr<nsPIDOMWindowInner>,
+          nsCOMPtr<nsIDocShell>,
+          mozilla::dom::workers::WorkerPrivate*> mOwner;
 
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
 
   void
   Shutdown();
 
   void
   ExecutionReady(const ClientSourceExecutionReadyArgs& aArgs);
 
   nsresult
   SnapshotWindowState(ClientState* aStateOut);
 
+  mozilla::dom::workers::WorkerPrivate*
+  GetWorkerPrivate() const;
+
+  nsIDocShell*
+  GetDocShell() const;
+
+  void
+  MaybeCreateInitialDocument();
+
   // Private methods called by ClientManager
   ClientSource(ClientManager* aManager,
                const ClientSourceConstructorArgs& aArgs);
 
   void
   Activate(PClientManagerChild* aActor);
 
 public:
   ~ClientSource();
 
   nsPIDOMWindowInner*
   GetInnerWindow() const;
 
-  mozilla::dom::workers::WorkerPrivate*
-  GetWorkerPrivate() const;
-
   void
   WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
 
   nsresult
   WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
 
+  nsresult
+  DocShellExecutionReady(nsIDocShell* aDocShell);
+
   void
   Freeze();
 
   void
   Thaw();
 
   const ClientInfo&
   Info() const;
diff --git a/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html b/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/about-blank-replacement.https.html
@@ -3,28 +3,43 @@
 <meta name=timeout content=long>
 <script src="/resources/testharness.js"></script>
 <script src="/resources/testharnessreport.js"></script>
 <script src="/common/get-host-info.sub.js"></script>
 <script src="resources/test-helpers.sub.js"></script>
 <body>
 <script>
 const worker = 'resources/about-blank-replacement-worker.js';
-const scope = 'resources/about-blank-replacement-frame.html'
 
 promise_test(async function(t) {
+  const scope = 'resources/about-blank-replacement-frame.html'
   try {
     let reg = await service_worker_unregister_and_register(t, worker, scope);
-    dump(`### ### got reg ${reg}\n`);
     await wait_for_state(t, reg.installing, 'activated');
-    dump(`### ### worker activated\n`);
     let frame = await with_iframe(scope);
-    dump(`### ### got frame ${frame}\n`);
-    assert_true(true);
+    let result = frame.contentWindow.nested().contentWindow.document.body.textContent;
+    assert_false(result.startsWith('failure:'), `result: ${result}`);
     frame.remove();
   } catch (e) {
     assert_true(false, `caught exception ${e}`);
   } finally {
     await service_worker_unregister_and_done(t, scope);
   }
-}, 'TODO');
+}, 'no-ping');
+
+promise_test(async function(t) {
+  const scope = 'resources/about-blank-replacement-ping-frame.html'
+  try {
+    let reg = await service_worker_unregister_and_register(t, worker, scope);
+    await wait_for_state(t, reg.installing, 'activated');
+    let frame = await with_iframe(scope);
+    let result = frame.contentWindow.nested().contentWindow.document.body.textContent;
+    assert_false(result.startsWith('failure:'), `result: ${result}`);
+    frame.remove();
+  } catch (e) {
+    assert_true(false, `caught exception ${e}`);
+  } finally {
+    await service_worker_unregister_and_done(t, scope);
+  }
+}, 'ping');
+
 </script>
 </body>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html
--- a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-frame.html
@@ -1,18 +1,11 @@
 <!doctype html>
 <html>
 <body>
 <iframe src="?nested" id="nested"></iframe>
 <script>
-let frame = document.getElementById('nested');
-frame.contentWindow.navigator.serviceWorker.addEventListener('message', evt => {
-  if (evt.data.type === 'PING') {
-    dump(`### ### frame got ping, location is ${frame.contentWindow.location.toString()}\n`);
-    evt.source.postMessage({
-      type: 'PONG',
-      location: frame.contentWindow.location.toString()
-    });
-  }
-});
+function nested() {
+  return document.getElementById('nested');
+}
 </script>
 </body>
 </html>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-ping-frame.html
@@ -0,0 +1,20 @@
+<!doctype html>
+<html>
+<body>
+<iframe src="?nested&ping" id="nested"></iframe>
+<script>
+function nested() {
+  return document.getElementById('nested');
+}
+let frame = nested();
+frame.contentWindow.navigator.serviceWorker.addEventListener('message', evt => {
+  if (evt.data.type === 'PING') {
+    evt.source.postMessage({
+      type: 'PONG',
+      location: frame.contentWindow.location.toString()
+    });
+  }
+});
+</script>
+</body>
+</html>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js
--- a/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/about-blank-replacement-worker.js
@@ -1,46 +1,56 @@
 let resolveDelayed;
 function delayedResponse() {
   return new Promise(resolve => {
-    resolveDelayed = _ => resolve(new Response());
+    resolveDelayed = resolve;
   });
 }
 
+async function getClientByURL(url) {
+  let list = await clients.matchAll();
+  for (client of list) {
+    if (client.frameType === 'nested' && client.url === url) {
+      return client;
+    }
+  }
+}
+
 function waitForPong() {
   return new Promise(resolve => {
     self.addEventListener('message', function onMessage(evt) {
-      dump(`### ### pong ${JSON.stringify(evt.data)}\n`);
       if (evt.data.type === 'PONG') {
         resolve(evt.data.location);
       }
     });
   });
 }
 
-function delay(ms) {
-  return new Promise(resolve => setTimeout(resolve, ms));
-}
-
-async function pingNested(url) {
-  await delay(100);
-  let list = await clients.matchAll({ includeUncontrolled: true });
-  let target;
-  for (client of list) {
-    dump(`### ### checking ${client.url}\n`);
-    if (client.frameType === 'nested' && client.url === url) {
-      target = client;
-      break;
-    }
-  }
-
+async function pingPong(target) {
   target.postMessage({ type: 'PING' })
   return await waitForPong(target);
 }
 
 addEventListener('fetch', async evt => {
-  if (evt.request.url.endsWith('nested')) {
-    evt.respondWith(delayedResponse());
-    let location = await pingNested('about:blank');
-    dump(`### ### got location ${location}\n`);
+  let url = new URL(evt.request.url);
+  if (!url.searchParams.has('nested')) {
     return;
   }
+
+  evt.respondWith(delayedResponse());
+  let client = await getClientByURL('about:blank');
+  if (!client) {
+    resolveDelayed(new Response('failure: could not find about:blank client'));
+  }
+
+  if (!url.searchParams.has('ping')) {
+    resolveDelayed(new Response('success'));
+    return;
+  }
+
+  let loc = await pingPong(client);
+  if (loc === 'about:blank') {
+    resolveDelayed(new Response('success'));
+    return;
+  }
+
+  resolveDelayed(new Response(`failure: got location {$loc}, expected about:blank`));
 });
