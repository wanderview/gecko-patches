# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c39d05f1510664cbc525aca5811ae8ffab28ebad

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -9,16 +9,19 @@
 #include <algorithm>
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/AutoRestore.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/Casting.h"
 #include "mozilla/dom/ClientChannelHelper.h"
+#include "mozilla/dom/ClientInfo.h"
+#include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientSource.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/PendingGlobalHistoryEntry.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/dom/ScreenOrientation.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
@@ -3313,16 +3316,50 @@ nsDocShell::GetParent(nsIDocShellTreeIte
 already_AddRefed<nsDocShell>
 nsDocShell::GetParentDocshell()
 {
   nsCOMPtr<nsIDocShell> docshell = do_QueryInterface(GetAsSupports(mParent));
   return docshell.forget().downcast<nsDocShell>();
 }
 
 void
+nsDocShell::EnsureInnerWindowOrInitialClientSource()
+{
+  if (mScriptGlobal && mScriptGlobal->GetExtantDoc()) {
+    MOZ_DIAGNOSTIC_ASSERT(mScriptGlobal->GetCurrentInnerWindowInternal()->GetClientInfo().isSome());
+    return;
+  }
+
+  mInitialClientSource = ClientManager::CreateSource(ClientType::Window,
+                                                     GetInheritedPrincipal(false));
+
+  // TODO: Mark the initial client as execution ready, but owned by the docshell.
+}
+
+Maybe<ClientInfo>
+nsDocShell::GetInitialClientInfo() const
+{
+  if (mInitialClientSource) {
+    Maybe<ClientInfo> result;
+    result.emplace(mInitialClientSource->Info());
+    return Move(result);
+  }
+
+  nsGlobalWindow* innerWindow =
+    mScriptGlobal ? mScriptGlobal->GetCurrentInnerWindowInternal() : nullptr;
+  nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
+
+  if (!doc || !doc->IsInitialDocument()) {
+    return Maybe<ClientInfo>();
+  }
+
+  return innerWindow->GetClientInfo();
+}
+
+void
 nsDocShell::RecomputeCanExecuteScripts()
 {
   bool old = mCanExecuteScripts;
   RefPtr<nsDocShell> parent = GetParentDocshell();
 
   // If we have no tree owner, that means that we've been detached from the
   // docshell tree (this is distinct from having no parent dochshell, which
   // is the case for root docshells). It would be nice to simply disallow
@@ -11505,17 +11542,19 @@ nsDocShell::DoChannelLoad(nsIChannel* aC
   uint32_t openFlags = 0;
   if (mLoadType == LOAD_LINK) {
     openFlags |= nsIURILoader::IS_CONTENT_PREFERRED;
   }
   if (!mAllowContentRetargeting) {
     openFlags |= nsIURILoader::DONT_RETARGET;
   }
 
-  rv = AddClientChannelHelperToChannel(this, aChannel);
+  EnsureInnerWindowOrInitialClientSource();
+
+  rv = AddClientChannelHelper(this, aChannel, GetInitialClientInfo());
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = aURILoader->OpenURI(aChannel, openFlags, this);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
@@ -14849,16 +14888,22 @@ nsDocShell::InFrameSwap()
     if (shell->mInFrameSwap) {
       return true;
     }
     shell = shell->GetParentDocshell();
   } while (shell);
   return false;
 }
 
+UniquePtr<ClientSource>
+nsDocShell::TakeInitialClientSource()
+{
+  return Move(mInitialClientSource);
+}
+
 NS_IMETHODIMP
 nsDocShell::IssueWarning(uint32_t aWarning, bool aAsError)
 {
   if (mContentViewer) {
     nsCOMPtr<nsIDocument> doc = mContentViewer->GetDocument();
     if (doc) {
       doc->WarnOnceAbout(nsIDocument::DeprecatedOperations(aWarning), aAsError);
     }
diff --git a/docshell/base/nsDocShell.h b/docshell/base/nsDocShell.h
--- a/docshell/base/nsDocShell.h
+++ b/docshell/base/nsDocShell.h
@@ -14,16 +14,17 @@
 #include "nsIBaseWindow.h"
 #include "nsINetworkInterceptController.h"
 #include "nsIScrollable.h"
 #include "nsITextScroll.h"
 #include "nsIContentViewerContainer.h"
 #include "nsIDOMStorageManager.h"
 #include "nsDocLoader.h"
 #include "mozilla/BasePrincipal.h"
+#include "mozilla/Maybe.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/TimeStamp.h"
 #include "GeckoProfiler.h"
 #include "mozilla/dom/ProfileTimelineMarkerBinding.h"
 #include "mozilla/LinkedList.h"
 #include "jsapi.h"
 
@@ -59,16 +60,18 @@
 #include "prtime.h"
 #include "nsRect.h"
 #include "Units.h"
 #include "nsIDeprecationWarner.h"
 
 namespace mozilla {
 enum class TaskCategory;
 namespace dom {
+class ClientInfo;
+class ClientSource;
 class EventTarget;
 class PendingGlobalHistoryEntry;
 typedef uint32_t ScreenOrientationInternal;
 } // namespace dom
 } // namespace mozilla
 
 class nsDocShell;
 class nsDOMNavigationTiming;
@@ -267,16 +270,19 @@ public:
   void NotifyAsyncPanZoomStopped();
 
   void SetInFrameSwap(bool aInSwap)
   {
     mInFrameSwap = aInSwap;
   }
   bool InFrameSwap();
 
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() override;
+
 private:
   bool CanSetOriginAttributes();
 
 public:
   const mozilla::OriginAttributes&
   GetOriginAttributes()
   {
     return mOriginAttributes;
@@ -733,16 +739,19 @@ protected:
 
   nsIChannel* GetCurrentDocChannel();
 
   bool ShouldBlockLoadingForBackButton();
 
   // Convenience method for getting our parent docshell. Can return null
   already_AddRefed<nsDocShell> GetParentDocshell();
 
+  void EnsureInnerWindowOrInitialClientSource();
+  mozilla::Maybe<mozilla::dom::ClientInfo> GetInitialClientInfo() const;
+
 protected:
   nsresult GetCurScrollPos(int32_t aScrollOrientation, int32_t* aCurPos);
   nsresult SetCurScrollPosEx(int32_t aCurHorizontalPos,
                              int32_t aCurVerticalPos);
 
   // Override the parent setter from nsDocLoader
   virtual nsresult SetDocLoaderParent(nsDocLoader* aLoader) override;
 
@@ -1041,16 +1050,18 @@ private:
   nsTObserverArray<nsWeakPtr> mReflowObservers;
   nsTObserverArray<nsWeakPtr> mScrollObservers;
   nsCString mOriginalUriString;
   nsWeakPtr mOpener;
   mozilla::OriginAttributes mOriginAttributes;
 
   mozilla::UniquePtr<mozilla::dom::PendingGlobalHistoryEntry> mPrerenderGlobalHistory;
 
+  mozilla::UniquePtr<mozilla::dom::ClientSource> mInitialClientSource;
+
   // A depth count of how many times NotifyRunToCompletionStart
   // has been called without a matching NotifyRunToCompletionStop.
   uint32_t mJSRunToCompletionDepth;
 
   // Whether or not touch events are overridden. Possible values are defined
   // as constants in the nsIDocShell.idl file.
   uint32_t mTouchEventsOverride;
 
diff --git a/docshell/base/nsIDocShell.idl b/docshell/base/nsIDocShell.idl
--- a/docshell/base/nsIDocShell.idl
+++ b/docshell/base/nsIDocShell.idl
@@ -4,19 +4,26 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "domstubs.idl"
 #include "nsIDocShellTreeItem.idl"
 #include "nsIRequest.idl"
 
 %{ C++
+#include "mozilla/UniquePtr.h"
 #include "js/TypeDecls.h"
 class nsPresContext;
 class nsIPresShell;
+
+namespace mozilla {
+namespace dom {
+class ClientSource;
+} // namespace dom
+} // namespace mozilla
 %}
 
 /**
  * The nsIDocShell interface.
  */
 
 [ptr] native nsPresContext(nsPresContext);
 [ptr] native nsIPresShell(nsIPresShell);
@@ -1136,9 +1143,16 @@ interface nsIDocShell : nsIDocShellTreeI
    * Attribute that determines whether tracking protection is enabled.
    */
   attribute boolean useTrackingProtection;
 
  /**
   * Fire a dummy location change event asynchronously.
   */
   [noscript] void dispatchLocationChangeEvent();
+
+
+%{ C++
+  virtual mozilla::UniquePtr<mozilla::dom::ClientSource>
+  TakeInitialClientSource() = 0;
+%}
+
 };
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3512,17 +3512,27 @@ nsGlobalWindow::EnsureClientSource()
     UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClient();
     if (reservedClient) {
       mClientSource.reset();
       mClientSource = Move(reservedClient);
       newClientSource = true;
     }
   }
 
-  // If we don't have a reserved client we need to create one now
+  // We don't have a LoadInfo reserved client, but maybe we should
+  // be inheriting an initial one from the docshell.
+  if (!mClientSource && mDoc->IsInitialDocument()) {
+    nsIDocShell* docshell = GetDocShell();
+    if (docshell) {
+      mClientSource = docshell->TakeInitialClientSource();
+    }
+  }
+
+  // If we don't have a reserved client or an initial client, then create
+  // one now.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
     newClientSource = true;
   }
diff --git a/dom/clients/manager/ClientChannelHelper.cpp b/dom/clients/manager/ClientChannelHelper.cpp
--- a/dom/clients/manager/ClientChannelHelper.cpp
+++ b/dom/clients/manager/ClientChannelHelper.cpp
@@ -4,27 +4,30 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientChannelHelper.h"
 
 #include "ClientManager.h"
 #include "ClientSource.h"
 #include "MainThreadUtils.h"
+#include "mozilla/ipc/BackgroundUtils.h"
 #include "nsContentUtils.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsIChannel.h"
 #include "nsIChannelEventSink.h"
 #include "nsIDocShell.h"
 #include "nsIInterfaceRequestor.h"
 #include "nsIInterfaceRequestorUtils.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::PrincipalInfoToPrincipal;
+
 namespace {
 
 class ClientChannelHelper final : public nsIInterfaceRequestor
                                 , public nsIChannelEventSink
 {
   nsCOMPtr<nsIInterfaceRequestor> mOuter;
 
   ~ClientChannelHelper()
@@ -143,17 +146,18 @@ public:
 };
 
 NS_IMPL_ISUPPORTS(ClientChannelHelper, nsIInterfaceRequestor,
                                        nsIChannelEventSink);
 
 } // anonymous namespace
 
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel)
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsILoadInfo> loadInfo = aChannel->GetLoadInfo();
   if (NS_WARN_IF(!loadInfo)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -163,33 +167,26 @@ AddClientChannelHelperToChannel(nsIDocSh
   }
 
   nsCOMPtr<nsIPrincipal> channelPrincipal;
   nsresult rv = ssm->GetChannelResultPrincipal(aChannel, getter_AddRefs(channelPrincipal));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
-  Maybe<ClientInfo> initialClientInfo;
-  nsPIDOMWindowOuter* outerWindow = aDocShell->GetWindow();
-  if (outerWindow) {
-    nsPIDOMWindowInner* innerWindow = outerWindow->GetCurrentInnerWindow();
-    if (innerWindow) {
-      nsIDocument* doc = innerWindow->GetExtantDoc();
-      if (doc && doc->IsInitialDocument()) {
-        nsIPrincipal* initialPrincipal = doc->NodePrincipal();
+  Maybe<ClientInfo> initialClientInfo(Move(aInitialClientInfo));
+  if (initialClientInfo.isSome()) {
+    nsCOMPtr<nsIPrincipal> initialPrincipal =
+      PrincipalInfoToPrincipal(initialClientInfo.ref().PrincipalInfo(), nullptr);
 
-        // This should match the checking in
-        // nsGlobalWindow::WouldReuseInnerWindow().
-        bool equals = false;
-        rv = initialPrincipal->Equals(channelPrincipal, &equals);
-        if (NS_SUCCEEDED(rv) && equals) {
-          initialClientInfo = innerWindow->GetClientInfo();
-        }
-      }
+    bool equals = false;
+    rv = initialPrincipal ? initialPrincipal->Equals(channelPrincipal, &equals)
+                          : NS_ERROR_FAILURE;
+    if (NS_FAILED(rv) || !equals) {
+      initialClientInfo.reset();
     }
   }
 
   nsCOMPtr<nsIInterfaceRequestor> outerCallbacks;
   rv = aChannel->GetNotificationCallbacks(getter_AddRefs(outerCallbacks));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
diff --git a/dom/clients/manager/ClientChannelHelper.h b/dom/clients/manager/ClientChannelHelper.h
--- a/dom/clients/manager/ClientChannelHelper.h
+++ b/dom/clients/manager/ClientChannelHelper.h
@@ -1,23 +1,27 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientChannelHelper_h
 #define _mozilla_dom_ClientChannelHelper_h
 
+#include "mozilla/Maybe.h"
 #include "nsError.h"
 
 class nsIChannel;
 class nsIDocShell;
 
 namespace mozilla {
 namespace dom {
 
+class ClientInfo;
+
 nsresult
-AddClientChannelHelperToChannel(nsIDocShell* aDocShell, nsIChannel* aChannel);
+AddClientChannelHelper(nsIDocShell* aDocShell, nsIChannel* aChannel,
+                       Maybe<ClientInfo>&& aInitialClientInfo);
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientChannelHelper_h
