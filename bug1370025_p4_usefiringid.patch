# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6859e108093478a954e046daea4d282f721ecba2
Bug 1370025 P4 Use FiringId validity in TimeoutManager::Timeouts::Insert() and ::ResetTimersForThrottleReduction(). r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -916,30 +916,24 @@ TimeoutManager::ResetTimersForThrottleRe
 
 nsresult
 TimeoutManager::Timeouts::ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
                                                           const TimeoutManager& aTimeoutManager,
                                                           SortBy aSortBy)
 {
   TimeStamp now = TimeStamp::Now();
 
-  // If insertion point is non-null, we're in the middle of firing timers and
-  // the timers we're planning to fire all come before insertion point;
-  // insertion point itself is a dummy timeout with an When() that may be
-  // semi-bogus.  In that case, we don't need to do anything with insertion
-  // point or anything before it, so should start at the timer after insertion
-  // point, if there is one.
-  // Otherwise, start at the beginning of the list.
-  for (RefPtr<Timeout> timeout = InsertionPoint() ?
-         InsertionPoint()->getNext() : GetFirst();
-       timeout; ) {
-    // It's important that this check be <= so that we guarantee that
-    // taking std::max with |now| won't make a quantity equal to
+  for (RefPtr<Timeout> timeout = GetFirst(); timeout; ) {
+    // Skip over any Timeout values with a valid FiringId.  These are in the
+    // middle of a RunTimeout and should not be modified.  Also, skip any
+    // timeouts in the past.  It's important that this check be <= so that we
+    // guarantee that taking std::max with |now| won't make a quantity equal to
     // timeout->When() below.
-    if (timeout->When() <= now) {
+    if (mManager.IsValidFiringId(timeout->mFiringId) ||
+        timeout->When() <= now) {
       timeout = timeout->getNext();
       continue;
     }
 
     if (timeout->When() - now >
         TimeDuration::FromMilliseconds(aPreviousThrottleDelayMS)) {
       // No need to loop further.  Timeouts are sorted in When() order
       // and the ones after this point were all set up for at least
@@ -1044,26 +1038,30 @@ TimeoutManager::ClearAllTimeouts()
   mNormalTimeouts.Clear();
   mTrackingTimeouts.Clear();
 }
 
 void
 TimeoutManager::Timeouts::Insert(Timeout* aTimeout, SortBy aSortBy)
 {
 
-  // Start at mLastTimeout and go backwards.  Don't go further than insertion
-  // point, though.  This optimizes for the common case of insertion at the end.
+  // Start at mLastTimeout and go backwards.  Stop if we see a Timeout with a
+  // valid FiringId since those timers are currently being processed by
+  // RunTimeout.  This optimizes for the common case of insertion at the end.
   Timeout* prevSibling;
   for (prevSibling = GetLast();
-       prevSibling && prevSibling != InsertionPoint() &&
+       prevSibling &&
          // This condition needs to match the one in SetTimeoutOrInterval that
          // determines whether to set When() or TimeRemaining().
          (aSortBy == SortBy::TimeRemaining ?
           prevSibling->TimeRemaining() > aTimeout->TimeRemaining() :
-          prevSibling->When() > aTimeout->When());
+          prevSibling->When() > aTimeout->When()) &&
+         // Check the firing ID last since it will evaluate true in the vast
+         // majority of cases.
+         mManager.IsInvalidFiringId(prevSibling->mFiringId);
        prevSibling = prevSibling->getPrevious()) {
     /* Do nothing; just searching */
   }
 
   // Now link in aTimeout after prevSibling.
   if (prevSibling) {
     prevSibling->setNext(aTimeout);
   } else {
