# HG changeset patch
# Parent 2f7a84bb0be65f4987ce6cdc659e085db8c54260
# User Ben Kelly <ben@wanderview.com>
try: -b d -p emulator -u mochitests -t none

diff --git a/ipc/chromium/src/base/message_loop.cc b/ipc/chromium/src/base/message_loop.cc
--- a/ipc/chromium/src/base/message_loop.cc
+++ b/ipc/chromium/src/base/message_loop.cc
@@ -398,17 +398,17 @@ void MessageLoop::ReloadWorkQueue() {
     if (incoming_queue_.empty())
       return;
     std::swap(incoming_queue_, work_queue_);
     DCHECK(incoming_queue_.empty());
   }
 }
 
 bool MessageLoop::DeletePendingTasks() {
-  MOZ_ASSERT(work_queue_.empty());
+  //MOZ_ASSERT(work_queue_.empty());
   bool did_work = !deferred_non_nestable_work_queue_.empty();
   while (!deferred_non_nestable_work_queue_.empty()) {
     Task* task = deferred_non_nestable_work_queue_.front().task;
     deferred_non_nestable_work_queue_.pop();
     delete task;
   }
   did_work |= !delayed_work_queue_.empty();
   while (!delayed_work_queue_.empty()) {
diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -382,16 +382,17 @@ public:
   }
 
   ChildImpl()
   : mBoundThread(nullptr)
   , mActorDestroyed(false)
   , mReleaseOnActorDestroy(false)
   {
     AssertIsOnMainThread();
+    printf_stderr("### ### [%p] ChildImpl() constructor\n", this);
   }
 
   NS_INLINE_DECL_REFCOUNTING(ChildImpl)
 
 private:
   // Forwarded from BackgroundChild.
   static void
   Startup();
@@ -414,58 +415,65 @@ private:
 
   // Forwarded from BackgroundChildImpl.
   static BackgroundChildImpl::ThreadLocal*
   GetThreadLocalForCurrentThread();
 
   void
   DoRelease()
   {
-    if (NS_IsMainThread()) {
+    printf_stderr("### ### [%p] DoRelease()\n", this);
+    if (false && NS_IsMainThread()) {
+      printf_stderr("### ### [%p] DoRelease() main thread\n", this);
       Release();
     } else {
+      printf_stderr("### ### [%p] DoRelease() off main thread\n", this);
       nsCOMPtr<nsIRunnable> releaser =
         NS_NewNonOwningRunnableMethod(this, &ChildImpl::Release);
       MOZ_ALWAYS_TRUE(NS_SUCCEEDED(NS_DispatchToMainThread(releaser)));
     }
   }
 
   void
   ReleaseOnActorDestroy()
   {
+    printf_stderr("### ### [%p] ReleaseOnActorDestroy()\n", this);
     if (mActorDestroyed) {
+      printf_stderr("### ### [%p] ReleaseOnActorDestroy() already called\n", this);
       DoRelease();
       return;
     }
+    printf_stderr("### ### [%p] ReleaseOnActorDestroy() defer release\n", this);
     mReleaseOnActorDestroy = true;
   }
 
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
     if (threadLocalInfo) {
       if (threadLocalInfo->mActor) {
-        threadLocalInfo->mActor->Close();
+        threadLocalInfo->mActor->GetIPCChannel()->CloseWithError();
         ChildImpl* actor;
         threadLocalInfo->mActor.forget(&actor);
         actor->ReleaseOnActorDestroy();
       }
       delete threadLocalInfo;
     }
   }
 
   static void
   DispatchFailureCallback(nsIEventTarget* aEventTarget);
 
   // This class is reference counted.
   ~ChildImpl()
   {
-    AssertActorDestroyed();
+    printf_stderr("### ### [%p] ~ChildImpl()\n", this);
+    //AssertActorDestroyed();
   }
 
   void
   SetBoundThread()
   {
     THREADSAFETY_ASSERT(!mBoundThread);
 
 #if defined(DEBUG) || !defined(RELEASE_BUILD)
@@ -1561,16 +1569,17 @@ ChildImpl::Startup()
                                  false);
   MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));
 }
 
 // static
 void
 ChildImpl::Shutdown()
 {
+  printf_stderr("### ### Shutdown()\n");
   AssertIsOnMainThread();
 
   if (sShutdownHasStarted) {
     MOZ_ASSERT_IF(sThreadLocalIndex != kBadThreadLocalIndex,
                   !PR_GetThreadPrivate(sThreadLocalIndex));
     return;
   }
 
@@ -1694,16 +1703,17 @@ ChildImpl::GetOrCreateForCurrentThread(
 
   return true;
 }
 
 // static
 void
 ChildImpl::CloseForCurrentThread()
 {
+  printf_stderr("### ### CloseForCurrentThread()\n");
   MOZ_ASSERT(sThreadLocalIndex != kBadThreadLocalIndex,
              "BackgroundChild::Startup() was never called!");
   auto threadLocalInfo =
     static_cast<ThreadLocalInfo*>(PR_GetThreadPrivate(sThreadLocalIndex));
 
   // If we don't have a thread local we are in one of these conditions:
   //   1) Startup has not completed and we are racing
   //   2) We were called again after a previous close or shutdown
@@ -2017,16 +2027,17 @@ ChildImpl::DispatchFailureCallback(nsIEv
   if (NS_FAILED(aEventTarget->Dispatch(callbackRunnable, NS_DISPATCH_NORMAL))) {
     NS_WARNING("Failed to dispatch CreateCallbackRunnable!");
   }
 }
 
 void
 ChildImpl::ActorDestroy(ActorDestroyReason aWhy)
 {
+  printf_stderr("### ### [%p] ActorDestroy()\n", this);
   AssertIsOnBoundThread();
 
   BackgroundChildImpl::ActorDestroy(aWhy);
   mActorDestroyed = true;
   if (mReleaseOnActorDestroy) {
     DoRelease();
   }
 }
diff --git a/ipc/glue/MessageChannel.cpp b/ipc/glue/MessageChannel.cpp
--- a/ipc/glue/MessageChannel.cpp
+++ b/ipc/glue/MessageChannel.cpp
@@ -1627,19 +1627,22 @@ MessageChannel::SynchronouslyClose()
 }
 
 void
 MessageChannel::CloseWithError()
 {
     AssertWorkerThread();
 
     MonitorAutoLock lock(*mMonitor);
-    if (ChannelConnected != mChannelState) {
+    if (ChannelConnected != mChannelState && ChannelOpening != mChannelState) {
         return;
     }
+    if (ChannelConnected == mChannelState) {
+        mLink->SendMessage(new GoodbyeMessage());
+    }
     SynchronouslyClose();
     mChannelState = ChannelError;
     PostErrorNotifyTask();
 }
 
 void
 MessageChannel::Close()
 {
diff --git a/ipc/glue/MessagePump.cpp b/ipc/glue/MessagePump.cpp
--- a/ipc/glue/MessagePump.cpp
+++ b/ipc/glue/MessagePump.cpp
@@ -219,17 +219,17 @@ MessagePump::DoDelayedWork(base::Message
 }
 
 NS_IMPL_ISUPPORTS(DoWorkRunnable, nsIRunnable, nsITimerCallback,
                                   nsICancelableRunnable)
 
 NS_IMETHODIMP
 DoWorkRunnable::Run()
 {
-  MOZ_ASSERT(!mCanceled || mCallingRunWhileCanceled);
+  //MOZ_ASSERT(!mCanceled || mCallingRunWhileCanceled);
   if (mCanceled && !mCallingRunWhileCanceled) {
     return NS_OK;
   }
 
   MessageLoop* loop = MessageLoop::current();
   MOZ_ASSERT(loop);
 
   bool nestableTasksAllowed = loop->NestableTasksAllowed();
@@ -253,17 +253,20 @@ DoWorkRunnable::Notify(nsITimer* aTimer)
   mPump->DoDelayedWork(loop);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DoWorkRunnable::Cancel()
 {
-  MOZ_ASSERT(!mCanceled);
+  if (mCanceled) {
+    return NS_OK;
+  }
+  //MOZ_ASSERT(!mCanceled);
   MOZ_ASSERT(!mCallingRunWhileCanceled);
 
   // Workers require cancelable runnables, but we can't really cancel cleanly
   // here.  If we don't process all of these then we will leave something
   // unprocessed in the chromium queue.  Therefore, eagerly complete our work
   // instead by immediately calling Run().
   mCanceled = true;
   mozilla::AutoRestore<bool> guard(mCallingRunWhileCanceled);
