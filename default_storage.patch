# HG changeset patch
# Parent d33ce916364d7c669c419905621490e07f0f71c0
# User Ben Kelly <ben@wanderview.com>
Use QuotaManager default storage in Cache.


diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -17,17 +17,17 @@
 #include "nsThreadUtils.h"
 
 namespace {
 
 using mozilla::dom::Nullable;
 using mozilla::dom::cache::QuotaInfo;
 using mozilla::dom::quota::OriginOrPatternString;
 using mozilla::dom::quota::QuotaManager;
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
 class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
 {
 public:
   QuotaReleaseRunnable(const QuotaInfo& aQuotaInfo, const nsACString& aQuotaId)
     : mQuotaInfo(aQuotaInfo)
     , mQuotaId(aQuotaId)
@@ -48,31 +48,31 @@ NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, 
 
 NS_IMETHODIMP
 QuotaReleaseRunnable::Run()
 {
   MOZ_ASSERT(NS_IsMainThread());
   QuotaManager* qm = QuotaManager::Get();
   MOZ_ASSERT(qm);
   qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
-                              Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
                               mQuotaId);
   return NS_OK;
 }
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::DebugOnly;
 using mozilla::dom::quota::OriginOrPatternString;
 using mozilla::dom::quota::QuotaManager;
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
 class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
                                            , public Action::Resolver
 {
 public:
   QuotaInitRunnable(Context* aContext,
                     ManagerId* aManagerId,
@@ -181,19 +181,18 @@ Context::QuotaInitRunnable::Run()
                                              &mQuotaInfo.mIsApp,
                                              &mQuotaInfo.mHasUnlimStoragePerm);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         Resolve(rv);
         return NS_OK;
       }
 
       mState = STATE_WAIT_FOR_OPEN_ALLOWED;
-      // TODO: use default storage instead of persistent
       rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
-                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
                                   mQuotaId, this);
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
       break;
     }
     case STATE_WAIT_FOR_OPEN_ALLOWED:
@@ -210,17 +209,17 @@ Context::QuotaInitRunnable::Run()
       break;
     }
     case STATE_ENSURE_ORIGIN_INITIALIZED:
     {
       // Can't assert quota IO thread because its an idle thread that can get
       // recreated.
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
-      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   mQuotaInfo.mHasUnlimStoragePerm,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -13,17 +13,17 @@
 #include "nsIFile.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
 DBAction::DBAction(Mode aMode)
   : mMode(aMode)
 {
 }
 
 DBAction::~DBAction()
@@ -93,19 +93,18 @@ DBAction::OpenConnection(const QuotaInfo
   // TODO: move this to main thread where GetInfoFromPrincipal() is executed
   nsCOMPtr<nsIURI> uri;
   rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
   if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
 
-  // TODO: use default storage
   nsAutoCString type;
-  PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
+  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
 
   rv = dbFileUrl->SetQuery(
     NS_LITERAL_CSTRING("persistenceType=") + type +
     NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
     NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<mozIStorageService> ss =
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -16,17 +16,17 @@
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::dom::quota::FileInputStream;
 using mozilla::dom::quota::FileOutputStream;
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::unused;
 
 // static
 nsresult
 FileUtils::BodyCreateDir(nsIFile* aBaseDir)
 {
   MOZ_ASSERT(aBaseDir);
 
@@ -172,19 +172,18 @@ FileUtils::BodyStartWriteStream(const Qu
   nsCOMPtr<nsIFile> tmpFile;
   rv = BodyIdToFile(aBaseDir, *aIdOut, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = tmpFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
-  // TODO: use default storage
   nsCOMPtr<nsIOutputStream> fileStream =
-    FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aQuotaInfo.mGroup,
+    FileOutputStream::Create(PERSISTENCE_TYPE_DEFAULT, aQuotaInfo.mGroup,
                              aQuotaInfo.mOrigin, tmpFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
   // By default we would prefer to just use ReadSegments to copy buffers.
   nsAsyncCopyMode mode = NS_ASYNCCOPY_VIA_READSEGMENTS;
 
   // But first we must check to see if the source stream provides ReadSegments.
   // If it does not, use a buffered output stream to write to the file.  We don't
@@ -282,19 +281,18 @@ FileUtils::BodyOpen(const QuotaInfo& aQu
                              getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool exists;
   rv = finalFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!exists)) { return NS_ERROR_FILE_NOT_FOUND; }
 
-  // TODO: use default storage
   nsCOMPtr<nsIInputStream> fileStream =
-    FileInputStream::Create(PERSISTENCE_TYPE_PERSISTENT, aQuotaInfo.mGroup,
+    FileInputStream::Create(PERSISTENCE_TYPE_DEFAULT, aQuotaInfo.mGroup,
                             aQuotaInfo.mOrigin, finalFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
   fileStream.forget(aStreamOut);
 
   return rv;
 }
 
