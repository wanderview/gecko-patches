# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ccda836b2a163f1a4e582aa34eb0b87dc3ed707e
Bug 1448141 P2 Uninstall the service worker registration if update fails while its scripts are missing from offline storage. r=asuth

diff --git a/dom/serviceworkers/ServiceWorkerScriptCache.cpp b/dom/serviceworkers/ServiceWorkerScriptCache.cpp
--- a/dom/serviceworkers/ServiceWorkerScriptCache.cpp
+++ b/dom/serviceworkers/ServiceWorkerScriptCache.cpp
@@ -295,16 +295,17 @@ public:
 
   explicit CompareManager(ServiceWorkerRegistrationInfo* aRegistration,
                           CompareCallback* aCallback)
     : mRegistration(aRegistration)
     , mCallback(aCallback)
     , mLoadFlags(nsIChannel::LOAD_BYPASS_SERVICE_WORKER)
     , mState(WaitingForInitialization)
     , mPendingCount(0)
+    , mOnFailure(OnFailure::DoNothing)
     , mAreScriptsEqual(true)
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aRegistration);
   }
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL,
@@ -355,16 +356,17 @@ public:
     if (--mPendingCount) {
       return;
     }
 
     if (mAreScriptsEqual) {
       MOZ_ASSERT(mCallback);
       mCallback->ComparisonResult(aStatus,
                                   true /* aSameScripts */,
+                                  mOnFailure,
                                   EmptyString(),
                                   mMaxScope,
                                   mLoadFlags);
       Cleanup();
       return;
     }
 
     // Write to Cache so ScriptLoader reads succeed.
@@ -471,48 +473,68 @@ private:
       return;
     }
 
     // Fetch and compare the source scripts.
     MOZ_ASSERT(mPendingCount == 0);
 
     mState = WaitingForScriptOrComparisonResult;
 
-    // Always make sure to fetch the main script.  If the old cache has
-    // no entries or the main script entry is missing, then the loop below
-    // may not trigger it.  This should not really happen, but we handle it
-    // gracefully if it does occur.  Its possible the bad cache state is due
-    // to a crash or shutdown during an update, etc.
-    rv = FetchScript(mURL, true /* aIsMainScript */, mOldCache);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      return;
-    }
+    bool hasMainScript = false;
+    AutoTArray<nsString, 8> urlList;
 
+    // Extract the list of URLs in the old cache.
     for (uint32_t i = 0; i < len; ++i) {
       JS::Rooted<JS::Value> val(aCx);
       if (NS_WARN_IF(!JS_GetElement(aCx, obj, i, &val)) ||
           NS_WARN_IF(!val.isObject())) {
         return;
       }
 
       Request* request;
       JS::Rooted<JSObject*> requestObj(aCx, &val.toObject());
       if (NS_WARN_IF(NS_FAILED(UNWRAP_OBJECT(Request, &requestObj, request)))) {
         return;
       };
 
-      nsString URL;
-      request->GetUrl(URL);
+      nsString url;
+      request->GetUrl(url);
+
+      if (!hasMainScript && url == mURL) {
+        hasMainScript = true;
+      }
+
+      urlList.AppendElement(url);
+    }
 
+    // If the main script is missing, then something has gone wrong.  We
+    // will try to continue with the update process to trigger a new
+    // installation.  If that fails, however, then uninstall the registration
+    // because it is broken in a way that cannot be fixed.
+    if (!hasMainScript) {
+      mOnFailure = OnFailure::Uninstall;
+    }
+
+    // Always make sure to fetch the main script.  If the old cache has
+    // no entries or the main script entry is missing, then the loop below
+    // may not trigger it.  This should not really happen, but we handle it
+    // gracefully if it does occur.  Its possible the bad cache state is due
+    // to a crash or shutdown during an update, etc.
+    rv = FetchScript(mURL, true /* aIsMainScript */, mOldCache);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return;
+    }
+
+    for (const auto& url : urlList) {
       // We explicitly start the fetch for the main script above.
-      if (mURL == URL) {
+      if (mURL == url) {
         continue;
       }
 
-      rv = FetchScript(URL, false /* aIsMainScript */, mOldCache);
+      rv = FetchScript(url, false /* aIsMainScript */, mOldCache);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return;
       }
     }
 
     guard.release();
   }
 
@@ -669,16 +691,17 @@ private:
     WaitingForExistingKeys,
     WaitingForScriptOrComparisonResult,
     WaitingForOpen,
     WaitingForPut,
     Finished
   } mState;
 
   uint32_t mPendingCount;
+  OnFailure mOnFailure;
   bool mAreScriptsEqual;
 };
 
 NS_IMPL_ISUPPORTS0(CompareManager)
 
 nsresult
 CompareNetwork::Initialize(nsIPrincipal* aPrincipal,
                            const nsAString& aURL,
@@ -1321,16 +1344,17 @@ CompareManager::ResolvedCallback(JSConte
     case WaitingForOpen:
       ManageNewCache(aCx, aValue);
       return;
     case WaitingForPut:
       MOZ_DIAGNOSTIC_ASSERT(mPendingCount > 0);
       if (--mPendingCount == 0) {
         mCallback->ComparisonResult(NS_OK,
                                     false /* aIsEqual */,
+                                    mOnFailure,
                                     mNewCacheName,
                                     mMaxScope,
                                     mLoadFlags);
         Cleanup();
       }
       return;
     default:
       MOZ_DIAGNOSTIC_ASSERT(false);
@@ -1362,17 +1386,17 @@ CompareManager::RejectedCallback(JSConte
 
   Fail(NS_ERROR_FAILURE);
 }
 
 void
 CompareManager::Fail(nsresult aStatus)
 {
   MOZ_ASSERT(NS_IsMainThread());
-  mCallback->ComparisonResult(aStatus, false /* aIsEqual */,
+  mCallback->ComparisonResult(aStatus, false /* aIsEqual */, mOnFailure,
                               EmptyString(), EmptyCString(), mLoadFlags);
   Cleanup();
 }
 
 void
 CompareManager::Cleanup()
 {
   MOZ_ASSERT(NS_IsMainThread());
diff --git a/dom/serviceworkers/ServiceWorkerScriptCache.h b/dom/serviceworkers/ServiceWorkerScriptCache.h
--- a/dom/serviceworkers/ServiceWorkerScriptCache.h
+++ b/dom/serviceworkers/ServiceWorkerScriptCache.h
@@ -20,28 +20,35 @@ class ServiceWorkerRegistrationInfo;
 namespace serviceWorkerScriptCache {
 
 nsresult
 PurgeCache(nsIPrincipal* aPrincipal, const nsAString& aCacheName);
 
 nsresult
 GenerateCacheName(nsAString& aName);
 
+enum class OnFailure : uint8_t {
+    DoNothing,
+    Uninstall
+};
+
 class CompareCallback
 {
 public:
+
   /*
    * If there is an error, ignore aInCacheAndEqual and aNewCacheName.
    * On success, if the cached result and network result matched,
    * aInCacheAndEqual will be true and no new cache name is passed, otherwise
    * use the new cache name to load the ServiceWorker.
    */
   virtual void
   ComparisonResult(nsresult aStatus,
                    bool aInCacheAndEqual,
+                   OnFailure aOnFailure,
                    const nsAString& aNewCacheName,
                    const nsACString& aMaxScope,
                    nsLoadFlags aLoadFlags) = 0;
 
   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
 };
 
 nsresult
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -9,16 +9,18 @@
 #include "nsIScriptError.h"
 #include "nsIURL.h"
 #include "ServiceWorkerScriptCache.h"
 #include "mozilla/dom/WorkerCommon.h"
 
 namespace mozilla {
 namespace dom {
 
+using serviceWorkerScriptCache::OnFailure;
+
 namespace {
 
 /**
  * The spec mandates slightly different behaviors for computing the scope
  * prefix string in case a Service-Worker-Allowed header is specified versus
  * when it's not available.
  *
  * With the header:
@@ -91,22 +93,24 @@ public:
     : mJob(aJob)
   {
     MOZ_ASSERT(mJob);
   }
 
   virtual void
   ComparisonResult(nsresult aStatus,
                    bool aInCacheAndEqual,
+                   OnFailure aOnFailure,
                    const nsAString& aNewCacheName,
                    const nsACString& aMaxScope,
                    nsLoadFlags aLoadFlags) override
   {
     mJob->ComparisonResult(aStatus,
                            aInCacheAndEqual,
+                           aOnFailure,
                            aNewCacheName,
                            aMaxScope,
                            aLoadFlags);
   }
 
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateJob::CompareCallback, override)
 };
 
@@ -172,16 +176,17 @@ ServiceWorkerUpdateJob::ServiceWorkerUpd
     nsIPrincipal* aPrincipal,
     const nsACString& aScope,
     const nsACString& aScriptSpec,
     nsILoadGroup* aLoadGroup,
     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : ServiceWorkerJob(Type::Update, aPrincipal, aScope, aScriptSpec)
   , mLoadGroup(aLoadGroup)
   , mUpdateViaCache(aUpdateViaCache)
+  , mOnFailure(OnFailure::DoNothing)
 {
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerUpdateJob::GetRegistration() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   RefPtr<ServiceWorkerRegistrationInfo> ref = mRegistration;
@@ -207,30 +212,47 @@ ServiceWorkerUpdateJob::~ServiceWorkerUp
 
 void
 ServiceWorkerUpdateJob::FailUpdateJob(ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aRv.Failed());
 
   // Cleanup after a failed installation.  This essentially implements
-  // step 12 of the Install algorithm.
+  // step 13 of the Install algorithm.
   //
-  //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
+  //  https://w3c.github.io/ServiceWorker/#installation-algorithm
   //
   // The spec currently only runs this after an install event fails,
   // but we must handle many more internal errors.  So we check for
   // cleanup on every non-successful exit.
   if (mRegistration) {
-    mRegistration->ClearEvaluating();
-    mRegistration->ClearInstalling();
+    // Some kinds of failures indicate there is something broken in the currently
+    // installed registration.  In these cases we want to fully unregister.
+    if (mOnFailure == OnFailure::Uninstall) {
+      mRegistration->Clear();
+    }
+
+    // Otherwise just clear the workers we may have created as part of the
+    // update process.
+    else {
+      mRegistration->ClearEvaluating();
+      mRegistration->ClearInstalling();
+    }
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (swm) {
       swm->MaybeRemoveRegistration(mRegistration);
+
+      // Also clear the registration on disk if we are forcing uninstall
+      // due to a particularly bad failure.
+      if (mOnFailure == OnFailure::Uninstall) {
+        swm->MaybeSendUnregister(mRegistration->Principal(),
+                                 mRegistration->Scope());
+      }
     }
   }
 
   mRegistration = nullptr;
 
   Finish(aRv);
 }
 
@@ -332,22 +354,25 @@ ServiceWorkerUpdateViaCache
 ServiceWorkerUpdateJob::GetUpdateViaCache() const
 {
   return mUpdateViaCache;
 }
 
 void
 ServiceWorkerUpdateJob::ComparisonResult(nsresult aStatus,
                                          bool aInCacheAndEqual,
+                                         OnFailure aOnFailure,
                                          const nsAString& aNewCacheName,
                                          const nsACString& aMaxScope,
                                          nsLoadFlags aLoadFlags)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
+  mOnFailure = aOnFailure;
+
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(Canceled() || !swm)) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // Handle failure of the download or comparison.  This is part of Update
   // step 5 as "If the algorithm asynchronously completes with null, then:".
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.h b/dom/serviceworkers/ServiceWorkerUpdateJob.h
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.h
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.h
@@ -8,16 +8,20 @@
 #define mozilla_dom_serviceworkerupdatejob_h
 
 #include "ServiceWorkerJob.h"
 #include "ServiceWorkerRegistration.h"
 
 namespace mozilla {
 namespace dom {
 
+namespace serviceWorkerScriptCache {
+enum class OnFailure : uint8_t;
+} // namespace serviceWorkerScriptCache
+
 class ServiceWorkerManager;
 
 // A job class that performs the Update and Install algorithms from the
 // service worker spec.  This class is designed to be inherited and customized
 // as a different job type.  This is necessary because the register job
 // performs largely the same operations as the update job, but has a few
 // different starting steps.
 class ServiceWorkerUpdateJob : public ServiceWorkerJob
@@ -78,34 +82,35 @@ private:
   class ContinueUpdateRunnable;
   class ContinueInstallRunnable;
 
   // Utility method called after a script is loaded and compared to
   // our current cached script.
   void
   ComparisonResult(nsresult aStatus,
                    bool aInCacheAndEqual,
+                   serviceWorkerScriptCache::OnFailure aOnFailure,
                    const nsAString& aNewCacheName,
                    const nsACString& aMaxScope,
                    nsLoadFlags aLoadFlags);
 
   // Utility method called after evaluating the worker script.
   void
   ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult);
 
   // Utility method corresponding to the spec Install algorithm.
   void
   Install(ServiceWorkerManager* aSWM);
 
   // Utility method called after the install event is handled.
   void
   ContinueAfterInstallEvent(bool aInstallEventSuccess);
 
+  RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
   nsCOMPtr<nsILoadGroup> mLoadGroup;
   ServiceWorkerUpdateViaCache mUpdateViaCache;
-
-  RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
+  serviceWorkerScriptCache::OnFailure mOnFailure;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_serviceworkerupdatejob_h
