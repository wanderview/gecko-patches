# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a042e6467ec7a474e799b79528c8ffa3992f4360
Bug 1255070 P3 Make nsStringInputStream implement nsIBufferedInputStream. r=froydnj

diff --git a/xpcom/io/nsStringStream.cpp b/xpcom/io/nsStringStream.cpp
--- a/xpcom/io/nsStringStream.cpp
+++ b/xpcom/io/nsStringStream.cpp
@@ -8,16 +8,17 @@
  * Based on original code from nsIStringStream.cpp
  */
 
 #include "ipc/IPCMessageUtils.h"
 
 #include "nsStringStream.h"
 #include "nsStreamUtils.h"
 #include "nsReadableUtils.h"
+#include "nsIBufferedStreams.h"
 #include "nsICloneableInputStream.h"
 #include "nsISeekableStream.h"
 #include "nsISupportsPrimitives.h"
 #include "nsCRT.h"
 #include "prerror.h"
 #include "plstr.h"
 #include "nsIClassInfoImpl.h"
 #include "mozilla/Attributes.h"
@@ -31,26 +32,28 @@ using namespace mozilla::ipc;
 //-----------------------------------------------------------------------------
 
 class nsStringInputStream final
   : public nsIStringInputStream
   , public nsISeekableStream
   , public nsISupportsCString
   , public nsIIPCSerializableInputStream
   , public nsICloneableInputStream
+  , public nsIBufferedInputStream
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
   NS_DECL_NSISTRINGINPUTSTREAM
   NS_DECL_NSISEEKABLESTREAM
   NS_DECL_NSISUPPORTSPRIMITIVE
   NS_DECL_NSISUPPORTSCSTRING
   NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
   NS_DECL_NSICLONEABLEINPUTSTREAM
+  NS_DECL_NSIBUFFEREDINPUTSTREAM
 
   nsStringInputStream()
   {
     Clear();
   }
 
   explicit nsStringInputStream(const nsStringInputStream& aOther)
     : mOffset(aOther.mOffset)
@@ -91,29 +94,36 @@ private:
 
 // This class needs to support threadsafe refcounting since people often
 // allocate a string stream, and then read it from a background thread.
 NS_IMPL_ADDREF(nsStringInputStream)
 NS_IMPL_RELEASE(nsStringInputStream)
 
 NS_IMPL_CLASSINFO(nsStringInputStream, nullptr, nsIClassInfo::THREADSAFE,
                   NS_STRINGINPUTSTREAM_CID)
-NS_IMPL_QUERY_INTERFACE_CI(nsStringInputStream,
-                           nsIStringInputStream,
-                           nsIInputStream,
-                           nsISupportsCString,
-                           nsISeekableStream,
-                           nsIIPCSerializableInputStream,
-                           nsICloneableInputStream)
+
+NS_INTERFACE_MAP_BEGIN(nsStringInputStream)
+  NS_INTERFACE_MAP_ENTRY(nsIStringInputStream)
+  NS_INTERFACE_MAP_ENTRY(nsISupportsCString)
+  NS_INTERFACE_MAP_ENTRY(nsISeekableStream)
+  NS_INTERFACE_MAP_ENTRY(nsIIPCSerializableInputStream)
+  NS_INTERFACE_MAP_ENTRY(nsICloneableInputStream)
+  NS_INTERFACE_MAP_ENTRY(nsIBufferedInputStream)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIInputStream, nsIStringInputStream)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStringInputStream)
+  NS_IMPL_QUERY_CLASSINFO(nsStringInputStream)
+NS_INTERFACE_MAP_END
+
 NS_IMPL_CI_INTERFACE_GETTER(nsStringInputStream,
                             nsIStringInputStream,
                             nsIInputStream,
                             nsISupportsCString,
                             nsISeekableStream,
-                            nsICloneableInputStream)
+                            nsICloneableInputStream,
+                            nsIBufferedInputStream)
 
 /////////
 // nsISupportsCString implementation
 /////////
 
 NS_IMETHODIMP
 nsStringInputStream::GetType(uint16_t* aType)
 {
@@ -239,18 +249,18 @@ nsStringInputStream::ReadSegments(nsWrit
   if (maxCount == 0) {
     *aResult = 0;
     return NS_OK;
   }
 
   if (aCount > maxCount) {
     aCount = maxCount;
   }
-  nsresult rv = aWriter(this, aClosure, mData.BeginReading() + mOffset, 0,
-                        aCount, aResult);
+  nsresult rv = aWriter(static_cast<nsIStringInputStream*>(this), aClosure,
+                        mData.BeginReading() + mOffset, 0, aCount, aResult);
   if (NS_SUCCEEDED(rv)) {
     NS_ASSERTION(*aResult <= aCount,
                  "writer should not write more than we asked it to write");
     mOffset += *aResult;
   }
 
   // errors returned from the writer end here!
   return NS_OK;
@@ -363,21 +373,33 @@ nsStringInputStream::GetCloneable(bool* 
 {
   *aCloneableOut = true;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsStringInputStream::Clone(nsIInputStream** aCloneOut)
 {
-  RefPtr<nsIInputStream> ref = new nsStringInputStream(*this);
-  ref.forget(aCloneOut);
+  RefPtr<nsStringInputStream> ref = new nsStringInputStream(*this);
+  RefPtr<nsIStringInputStream> downcast = ref.forget();
+  downcast.forget(aCloneOut);
   return NS_OK;
 }
 
+/////////
+// nsIBufferedInputStream implementation
+/////////
+
+NS_IMETHODIMP
+nsStringInputStream::Init(nsIInputStream*, uint32_t)
+{
+  MOZ_CRASH("nsStringInputStream should never be initialized with "
+            "nsIBufferedInputStream::Init!\n");
+}
+
 nsresult
 NS_NewByteInputStream(nsIInputStream** aStreamResult,
                       const char* aStringToRead, int32_t aLength,
                       nsAssignmentType aAssignment)
 {
   NS_PRECONDITION(aStreamResult, "null out ptr");
 
   RefPtr<nsStringInputStream> stream = new nsStringInputStream();
@@ -397,17 +419,18 @@ NS_NewByteInputStream(nsIInputStream** a
       NS_ERROR("invalid assignment type");
       rv = NS_ERROR_INVALID_ARG;
   }
 
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  stream.forget(aStreamResult);
+  RefPtr<nsIStringInputStream> downcast = stream.forget();
+  downcast.forget(aStreamResult);
   return NS_OK;
 }
 
 nsresult
 NS_NewStringInputStream(nsIInputStream** aStreamResult,
                         const nsAString& aStringToRead)
 {
   NS_LossyConvertUTF16toASCII data(aStringToRead); // truncates high-order bytes
@@ -419,17 +442,18 @@ NS_NewCStringInputStream(nsIInputStream*
                          const nsACString& aStringToRead)
 {
   NS_PRECONDITION(aStreamResult, "null out ptr");
 
   RefPtr<nsStringInputStream> stream = new nsStringInputStream();
 
   stream->SetData(aStringToRead);
 
-  stream.forget(aStreamResult);
+  RefPtr<nsIStringInputStream> downcast = stream.forget();
+  downcast.forget(aStreamResult);
   return NS_OK;
 }
 
 // factory method for constructing a nsStringInputStream object
 nsresult
 nsStringInputStreamConstructor(nsISupports* aOuter, REFNSIID aIID,
                                void** aResult)
 {
diff --git a/xpcom/tests/gtest/TestStringStream.cpp b/xpcom/tests/gtest/TestStringStream.cpp
--- a/xpcom/tests/gtest/TestStringStream.cpp
+++ b/xpcom/tests/gtest/TestStringStream.cpp
@@ -1,17 +1,20 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "gtest/gtest.h"
 #include "Helpers.h"
+#include "nsIBufferedStreams.h"
 #include "nsICloneableInputStream.h"
+#include "nsIIPCSerializableInputStream.h"
+#include "nsISupportsPrimitives.h"
 #include "nsStringStream.h"
 
 namespace {
 
 static void TestStringStream(uint32_t aNumBytes)
 {
   nsTArray<char> inputData;
   testing::CreateData(aNumBytes, inputData);
@@ -55,8 +58,33 @@ TEST(StringStream, Simple_4k)
 {
   TestStringStream(1024 * 4);
 }
 
 TEST(StringStream, Clone_4k)
 {
   TestStringStreamClone(1024 * 4);
 }
+
+TEST(StringStream, Interfaces)
+{
+  nsCOMPtr<nsIInputStream> stream;
+  nsresult rv = NS_NewCStringInputStream(getter_AddRefs(stream), EmptyCString());
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIStringInputStream> type1 = do_QueryInterface(stream);
+  ASSERT_TRUE(type1);
+
+  nsCOMPtr<nsISeekableStream> type2 = do_QueryInterface(stream);
+  ASSERT_TRUE(type2);
+
+  nsCOMPtr<nsISupportsCString> type3 = do_QueryInterface(stream);
+  ASSERT_TRUE(type3);
+
+  nsCOMPtr<nsIIPCSerializableInputStream> type4 = do_QueryInterface(stream);
+  ASSERT_TRUE(type4);
+
+  nsCOMPtr<nsICloneableInputStream> type5 = do_QueryInterface(stream);
+  ASSERT_TRUE(type5);
+
+  nsCOMPtr<nsIBufferedInputStream> type6 = do_QueryInterface(stream);
+  ASSERT_TRUE(type6);
+}
