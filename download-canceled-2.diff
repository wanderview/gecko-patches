# HG changeset patch
# User Andrew Sutherland <asutherland@asutherland.org>
# Date 1512987082 18000
#      Mon Dec 11 05:11:22 2017 -0500
# Node ID c58074905ea65fb345923b1204e5dcee06f6c4fe
# Parent  22b439b0c37cf9557f484c1022c1de2744428cda
in-progress

diff --git a/dom/workers/test/serviceworkers/browser_download_canceled.js b/dom/workers/test/serviceworkers/browser_download_canceled.js
--- a/dom/workers/test/serviceworkers/browser_download_canceled.js
+++ b/dom/workers/test/serviceworkers/browser_download_canceled.js
@@ -46,21 +46,32 @@ function promiseClickDownloadDialogButto
         // class has already been added (it is added when "DOMContentLoaded" is
         // fired).
         win.addEventListener("load", function() {
           info(`found window of type: ${win.document.documentURI}`);
           if (win.document.documentURI ===
                 "chrome://mozapps/content/downloads/unknownContentType.xul") {
             Services.ww.unregisterNotification(onOpen);
 
-            const button = win.document.documentElement.getButton(buttonAction);
-            button.disabled = false;
-            info(`clicking ${buttonAction} button`);
-            button.click();
-            resolve();
+            // nsHelperAppDlg.js currently uses an eval-based setTimeout(0) to
+            // invoke its postShowCallback that results in a misleading error to
+            // the console if we close the dialog before it gets a chance to
+            // run.  Just a setTimeout is not sufficient because it appears we
+            // get our "load" listener before the document's, so we use
+            // executeSoon to defer until after its load handler runs, then
+            // use setTimeout(0) to end up after its eval.
+            executeSoon(function() {
+              setTimeout(function() {
+                const button = win.document.documentElement.getButton(buttonAction);
+                button.disabled = false;
+                info(`clicking ${buttonAction} button`);
+                button.click();
+                resolve();
+              }, 0);
+            });
           }
         }, {once: true});
       }
     });
   });
 }
 
 async function performCanceledDownload(tab, path) {
@@ -79,16 +90,17 @@ async function performCanceledDownload(t
       link.download = path;
       content.document.body.appendChild(link);
       link.click();
     });
 
   // Wait for the cancelation to have been triggered.
   info("waiting for download popup");
   await cancelDownload;
+  ok("canceled download");
 }
 
 const gTestRoot = getRootDirectory(gTestPath)
   .replace("chrome://mochitests/content/", "http://mochi.test:8888/");
 
 
 const PAGE_URL = `${gTestRoot}download_canceled/page_download_canceled.html`;
 
diff --git a/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
--- a/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
+++ b/dom/workers/test/serviceworkers/download_canceled/sw_download_canceled.js
@@ -32,20 +32,22 @@ function handleStream(evt, filename) {
         let count = 0;
         let intervalId;
         function tick() {
           try {
             // bound worst-case behavior.
             if (count++ > 3000) {
               clearInterval(intervalId);
               resolve();
+              controller.close();
             }
             controller.enqueue(dataChunk);
           } catch(e) {
             resolve();
+            controller.close();
           }
         }
         intervalId = setInterval(tick, 1);
       },
     });
     evt.respondWith(new Response(body, {
       headers: {
         'Content-Disposition': `attachment; filename="${filename}"`,
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -639,16 +639,17 @@ public:
     return NS_OK;
   }
 
   NS_IMETHOD
   OnStopRequest(nsIRequest* aRequest, nsISupports* aContext,
                 nsresult aStatus) override
   {
     mChannel->SendDivertOnStopRequest(aStatus);
+    mChannel->SendDivertComplete();
     return NS_OK;
   }
 
   NS_IMETHOD
   OnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
                   nsIInputStream* aInputStream, uint64_t aOffset,
                   uint32_t aCount) override
   {
@@ -1856,17 +1857,21 @@ HttpChannelChild::FlushedForDiversion()
   LOG(("HttpChannelChild::FlushedForDiversion [this=%p]\n", this));
   MOZ_RELEASE_ASSERT(mDivertingToParent);
 
   // Once this is set, it should not be unset before HttpChannelChild is taken
   // down. After it is set, no OnStart/OnData/OnStop callbacks should be
   // received from the parent channel, nor dequeued from the ChannelEventQueue.
   mFlushedForDiversion = true;
 
-  SendDivertComplete();
+  // If we're synthesized, it's up to the SyntheticDiversionListener to invoke
+  // SendDivertComplete after it has sent the DivertOnStopRequestMessage.
+  if (!mSynthesizedResponse) {
+    SendDivertComplete();
+  }
 }
 
 void
 HttpChannelChild::ProcessSetClassifierMatchedInfo(const nsCString& aList,
                                                   const nsCString& aProvider,
                                                   const nsCString& aFullHash)
 {
   LOG(("HttpChannelChild::ProcessSetClassifierMatchedInfo [this=%p]\n", this));
