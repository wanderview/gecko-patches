# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5de419aeca79db81ab6b6586d17b3a337a01f7d8
Bug 1420221 Make workers handle the case when the ClientSource cannot be created during shutdown. r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -595,17 +595,19 @@ private:
   // run we have not yet done our load so don't know things like our final
   // principal and whatnot.
 
   virtual bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
-    aWorkerPrivate->EnsureClientSource();
+    if (NS_WARN_IF(!aWorkerPrivate->EnsureClientSource())) {
+      return false;
+    }
 
     ErrorResult rv;
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL, WorkerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
     // return false and don't SetWorkerScriptExecutedSuccessfully() in that
     // case, but don't throw anything on aCx.  The idea is to not dispatch error
     // events if our load is canceled with that error code.
@@ -667,17 +669,19 @@ private:
 
     WorkerDebuggerGlobalScope* globalScope =
       aWorkerPrivate->CreateDebuggerGlobalScope(aCx);
     if (!globalScope) {
       NS_WARNING("Failed to make global!");
       return false;
     }
 
-    aWorkerPrivate->EnsureClientSource();
+    if (NS_WARN_IF(!aWorkerPrivate->EnsureClientSource())) {
+      return false;
+    }
 
     JS::Rooted<JSObject*> global(aCx, globalScope->GetWrapper());
 
     ErrorResult rv;
     JSAutoCompartment ac(aCx, global);
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL,
                                  DebuggerScript, rv);
     rv.WouldReportJSException();
@@ -5290,23 +5294,23 @@ WorkerPrivate::ControlEventTarget()
 }
 
 nsISerialEventTarget*
 WorkerPrivate::HybridEventTarget()
 {
   return mWorkerHybridEventTarget;
 }
 
-void
+bool
 WorkerPrivate::EnsureClientSource()
 {
   AssertIsOnWorkerThread();
 
   if (mClientSource) {
-    return;
+    return true;
   }
 
   ClientType type;
   switch(Type()) {
     case WorkerTypeDedicated:
       type = ClientType::Worker;
       break;
     case WorkerTypeShared:
@@ -5316,19 +5320,25 @@ WorkerPrivate::EnsureClientSource()
       type = ClientType::Serviceworker;
       break;
     default:
       MOZ_CRASH("unknown worker type!");
   }
 
   mClientSource = ClientManager::CreateSource(type, mWorkerHybridEventTarget,
                                               GetPrincipalInfo());
+  if (!mClientSource) {
+    return false;
+  }
+
   if (mFrozen) {
     mClientSource->Freeze();
   }
+
+  return true;
 }
 
 const ClientInfo&
 WorkerPrivate::GetClientInfo() const
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   return mClientSource->Info();
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1492,17 +1492,17 @@ public:
   // Get an event target that will attempt to dispatch a normal WorkerRunnable,
   // but if that fails will then fall back to a control runnable.
   nsISerialEventTarget*
   HybridEventTarget();
 
   void
   DumpCrashInformation(nsACString& aString);
 
-  void
+  bool
   EnsureClientSource();
 
   const ClientInfo&
   GetClientInfo() const;
 
   void
   ExecutionReady();
 
