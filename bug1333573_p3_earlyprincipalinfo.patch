# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  70c539645c3acac3c63e7b7b3cad0ea99bc665ec
Bug 1333573 P3 Initialize mPrincipalInfo when setting WorkerPrivate's mPrincipal. r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -1682,31 +1682,39 @@ WorkerLoadInfo::StealFrom(WorkerLoadInfo
   mServiceWorkersTestingInWindow = aOther.mServiceWorkersTestingInWindow;
   mOriginAttributes = aOther.mOriginAttributes;
 }
 
 void
 WorkerLoadInfo::CopyPrincipalFrom(const WorkerLoadInfo& aOther)
 {
   // any thread
+  MOZ_DIAGNOSTIC_ASSERT(aOther.mPrincipal);
+  MOZ_DIAGNOSTIC_ASSERT(aOther.mPrincipalInfo);
+
   mPrincipal = aOther.mPrincipal;
   mPrincipalIsSystem = aOther.mPrincipalIsSystem;
   mOriginAttributes = aOther.mOriginAttributes;
+
+  mPrincipalInfo = new PrincipalInfo(*aOther.mPrincipalInfo);
 }
 
 void
 WorkerLoadInfo::SetPrincipalOnMainThread(nsIPrincipal* aPrincipal,
                                          const OriginAttributes& aAttributes)
 {
   AssertIsOnMainThread();
   MOZ_DIAGNOSTIC_ASSERT(aPrincipal);
 
   mPrincipal = new nsMainThreadPtrHolder<nsIPrincipal>(aPrincipal);
   mPrincipalIsSystem = mPrincipal->GetIsSystemPrincipal();
   mOriginAttributes = aAttributes;
+
+  mPrincipalInfo = new PrincipalInfo();
+  MOZ_ALWAYS_SUCCEEDS(PrincipalToPrincipalInfo(mPrincipal, mPrincipalInfo));
 }
 
 template <class Derived>
 class WorkerPrivateParent<Derived>::EventTarget final
   : public nsIEventTarget
 {
   // This mutex protects mWorkerPrivate and must be acquired *before* the
   // WorkerPrivate's mutex whenever they must both be held.
@@ -3521,17 +3529,26 @@ WorkerPrivateParent<Derived>::SetBaseURI
 
 template <class Derived>
 void
 WorkerPrivateParent<Derived>::SetPrincipal(nsIPrincipal* aPrincipal,
                                            nsILoadGroup* aLoadGroup)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(aLoadGroup, aPrincipal));
-  MOZ_ASSERT(!mLoadInfo.mPrincipalInfo);
+
+  // Initial principal should already have been set
+  MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mPrincipal);
+  MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mPrincipalInfo);
+
+  // Our loading policy should guarantee that the final principal can
+  // only change in a few ways.  In general this means we should only
+  // ever be downgrading the principal.
+  MOZ_RELEASE_ASSERT(aPrincipal->GetIsNullPrincipal() ||
+                     mLoadInfo.mPrincipal->Subsumes(aPrincipal));
 
   mLoadInfo.SetPrincipalOnMainThread(aPrincipal,
                                      nsContentUtils::GetOriginAttributes(aLoadGroup));
 
   aPrincipal->GetCsp(getter_AddRefs(mLoadInfo.mCSP));
 
   if (mLoadInfo.mCSP) {
     mLoadInfo.mCSP->GetAllowsEval(&mLoadInfo.mReportCSPViolations,
@@ -3547,20 +3564,16 @@ WorkerPrivateParent<Derived>::SetPrincip
       mLoadInfo.mReferrerPolicy = static_cast<net::ReferrerPolicy>(rp);
     }
   } else {
     mLoadInfo.mEvalAllowed = true;
     mLoadInfo.mReportCSPViolations = false;
   }
 
   mLoadInfo.mLoadGroup = aLoadGroup;
-
-  mLoadInfo.mPrincipalInfo = new PrincipalInfo();
-  MOZ_ALWAYS_SUCCEEDS(
-    PrincipalToPrincipalInfo(aPrincipal, mLoadInfo.mPrincipalInfo));
 }
 
 template <class Derived>
 void
 WorkerPrivateParent<Derived>::UpdateOverridenLoadGroup(nsILoadGroup* aBaseLoadGroup)
 {
   AssertIsOnMainThread();
 
