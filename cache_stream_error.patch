# HG changeset patch
# Parent 1b2f88a8fd83c95e18f297eceadbd013f90aaad0
# User Ben Kelly <ben@wanderview.com>
Handle Cache streams properly when serialization fails.


diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -238,16 +238,17 @@ Cache::Put(const RequestOrUSVString& aRe
 
   CacheRequestResponse put;
 
   // Be careful not to early exist after this point to avoid leaking
   // file descriptor resources from stream serialization.
 
   ToPCacheRequest(put.request(), aRequest, ReadBody, PassThroughReferrer, aRv);
 
+  put.response().body() = void_t();
   if (!aRv.Failed()) {
     ToPCacheResponse(put.response(), aResponse, aRv);
   }
 
   if (!aRv.Failed()) {
     RequestId requestId = AddRequestPromise(promise, aRv);
 
     unused << mActor->SendPut(requestId, put);
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -485,32 +485,32 @@ TypeUtils::CleanupChildFds(PCacheReadStr
   fdSetActor->ForgetFileDescriptors(fds);
 }
 
 void
 TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
                                 PCacheReadStreamOrVoid* aStreamOut,
                                 ErrorResult& aRv)
 {
-  MOZ_ASSERT(aStreamOut);
+  *aStreamOut = void_t();
   if (!aStream) {
-    *aStreamOut = void_t();
     return;
   }
 
   nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
   if (controlled) {
     controlled->Serialize(aStreamOut);
     return;
   }
 
   // TODO: implement CrossProcessPipe if we cannot directly serialize (bug 1110814)
   nsCOMPtr<nsIIPCSerializableInputStream> serial = do_QueryInterface(aStream);
   if (!serial) {
     aRv.Throw(NS_ERROR_FAILURE);
+    return;
   }
 
   PCacheReadStream readStream;
   readStream.controlChild() = nullptr;
   readStream.controlParent() = nullptr;
 
   nsTArray<FileDescriptor> fds;
   SerializeInputStream(aStream, readStream.params(), fds);
