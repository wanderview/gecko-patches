# HG changeset patch
# Parent 8acfa5bb050b875f63422f56c92d3e528f3b608b
# User Ben Kelly <ben@wanderview.com>
Bug 1029620 P6 Implement Fetch Headers DOM object. r=ehsan r=jst

diff --git a/dom/bindings/Errors.msg b/dom/bindings/Errors.msg
--- a/dom/bindings/Errors.msg
+++ b/dom/bindings/Errors.msg
@@ -49,8 +49,12 @@ MSG_DEF(MSG_INVALID_VERSION, 0, "0 (Zero
 MSG_DEF(MSG_INVALID_BYTESTRING, 2, "Cannot convert string to ByteString because the character"
         " at index {0} has value {1} which is greater than 255.")
 MSG_DEF(MSG_NOT_DATE, 1, "{0} is not a date.")
 MSG_DEF(MSG_INVALID_ADVANCE_COUNT, 0, "0 (Zero) is not a valid advance count.")
 MSG_DEF(MSG_DEFINEPROPERTY_ON_GSP, 0, "Not allowed to define a property on the named properties object.")
 MSG_DEF(MSG_INVALID_URL, 1, "{0} is not a valid URL.")
 MSG_DEF(MSG_METADATA_NOT_CONFIGURED, 0, "Either size or lastModified should be true.")
 MSG_DEF(MSG_INVALID_READ_SIZE, 0, "0 (Zero) is not a valid read size.")
+MSG_DEF(MSG_HEADERS_IMMUTABLE, 0, "Headers are immutable and cannot be modified.")
+MSG_DEF(MSG_INVALID_HEADER_NAME, 1, "{0} is an invalid header name.")
+MSG_DEF(MSG_INVALID_HEADER_VALUE, 1, "{0} is an invalid header value.")
+MSG_DEF(MSG_INVALID_HEADER_SEQUENCE, 0, "Headers require name/value tuples when being initialized by a sequence.")
diff --git a/dom/fetch/Headers.cpp b/dom/fetch/Headers.cpp
new file mode 100644
--- /dev/null
+++ b/dom/fetch/Headers.cpp
@@ -0,0 +1,301 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/Headers.h"
+
+#include "mozilla/ErrorResult.h"
+#include "mozilla/dom/UnionTypes.h"
+
+#include "nsCharSeparatedTokenizer.h"
+#include "nsContentUtils.h"
+#include "nsDOMString.h"
+#include "nsNetUtil.h"
+#include "nsPIDOMWindow.h"
+#include "nsReadableUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Headers)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Headers)
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Headers, mOwner)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Headers)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+// static
+already_AddRefed<Headers>
+Headers::Constructor(const GlobalObject& aGlobal,
+                     const Optional<HeadersOrByteStringSequenceSequenceOrByteStringMozMap>& aInit,
+                     ErrorResult& aRv)
+{
+  nsRefPtr<Headers> headers = new Headers(aGlobal.GetAsSupports());
+
+  if (!aInit.WasPassed()) {
+    return headers.forget();
+  }
+
+  if (aInit.Value().IsHeaders()) {
+    headers->Fill(aInit.Value().GetAsHeaders(), aRv);
+  } else if (aInit.Value().IsByteStringSequenceSequence()) {
+    headers->Fill(aInit.Value().GetAsByteStringSequenceSequence(), aRv);
+  } else if (aInit.Value().IsByteStringMozMap()) {
+    headers->Fill(aInit.Value().GetAsByteStringMozMap(), aRv);
+  }
+
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  return headers.forget();
+}
+
+void
+Headers::Append(const nsACString& aName, const nsACString& aValue,
+                ErrorResult& aRv)
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
+    return;
+  }
+
+  mList.AppendElement(Entry(lowerName, aValue));
+}
+
+void
+Headers::Delete(const nsACString& aName, ErrorResult& aRv)
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidMutableHeader(lowerName, nullptr, aRv)) {
+    return;
+  }
+
+  // remove in reverse order to minimize copying
+  for (int32_t i = mList.Length() - 1; i >= 0; --i) {
+    if (lowerName == mList[i].mName) {
+      mList.RemoveElementAt(i);
+    }
+  }
+}
+
+void
+Headers::Get(const nsACString& aName, nsCString& aValue, ErrorResult& aRv) const
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidName(lowerName, aRv)) {
+    return;
+  }
+
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
+      aValue = mList[i].mValue;
+      return;
+    }
+  }
+
+  // No value found, so return null to content
+  aValue.SetIsVoid(true);
+}
+
+void
+Headers::GetAll(const nsACString& aName, nsTArray<nsCString>& aResults,
+                ErrorResult& aRv) const
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidName(lowerName, aRv)) {
+    return;
+  }
+
+  aResults.SetLength(0);
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
+      aResults.AppendElement(mList[i].mValue);
+    }
+  }
+}
+
+bool
+Headers::Has(const nsACString& aName, ErrorResult& aRv) const
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidName(lowerName, aRv)) {
+    return false;
+  }
+
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
+      return true;
+    }
+  }
+  return false;
+}
+
+void
+Headers::Set(const nsACString& aName, const nsACString& aValue, ErrorResult& aRv)
+{
+  nsAutoCString lowerName;
+  ToLowerCase(aName, lowerName);
+
+  if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
+    return;
+  }
+
+  int32_t firstIndex = INT32_MAX;
+
+  // remove in reverse order to minimize copying
+  for (int32_t i = mList.Length() - 1; i >= 0; --i) {
+    if (lowerName == mList[i].mName) {
+      firstIndex = std::min(firstIndex, i);
+      mList.RemoveElementAt(i);
+    }
+  }
+
+  if (firstIndex < INT32_MAX) {
+    Entry* entry = mList.InsertElementAt(firstIndex);
+    entry->mName = lowerName;
+    entry->mValue = aValue;
+  } else {
+    mList.AppendElement(Entry(lowerName, aValue));
+  }
+}
+
+void
+Headers::SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv)
+{
+  // Rather than re-validate all current headers, just require code to set
+  // this prior to populating the Headers object.  Allow setting immutable
+  // late, though, as that is pretty much required to have a  useful, immutable
+  // headers object.
+  if (aGuard != HeadersGuardEnum::Immutable && mList.Length() > 0) {
+    aRv.Throw(NS_ERROR_FAILURE);
+  }
+  mGuard = aGuard;
+}
+
+JSObject*
+Headers::WrapObject(JSContext* aCx)
+{
+  return mozilla::dom::HeadersBinding::Wrap(aCx, this);
+}
+
+Headers::~Headers()
+{
+}
+
+// static
+bool
+Headers::IsSimpleHeader(const nsACString& aName, const nsACString* aValue)
+{
+  // Note, we must allow a null content-type value here to support
+  // get("content-type"), but the IsInvalidValue() check will prevent null
+  // from being set or appended.
+  return aName.EqualsLiteral("accept") ||
+         aName.EqualsLiteral("accept-language") ||
+         aName.EqualsLiteral("content-language") ||
+         (aName.EqualsLiteral("content-type") &&
+          (!aValue || nsContentUtils::IsAllowedNonCorsContentType(*aValue)));
+}
+
+//static
+bool
+Headers::IsInvalidName(const nsACString& aName, ErrorResult& aRv)
+{
+  if (!NS_IsValidHTTPToken(aName)) {
+    NS_ConvertUTF8toUTF16 label(aName);
+    aRv.ThrowTypeError(MSG_INVALID_HEADER_NAME, &label);
+    return true;
+  }
+
+  return false;
+}
+
+// static
+bool
+Headers::IsInvalidValue(const nsACString& aValue, ErrorResult& aRv)
+{
+  if (!NS_IsReasonableHTTPHeaderValue(aValue)) {
+    NS_ConvertUTF8toUTF16 label(aValue);
+    aRv.ThrowTypeError(MSG_INVALID_HEADER_VALUE, &label);
+    return true;
+  }
+  return false;
+}
+
+bool
+Headers::IsImmutable(ErrorResult& aRv) const
+{
+  if (mGuard == HeadersGuardEnum::Immutable) {
+    aRv.ThrowTypeError(MSG_HEADERS_IMMUTABLE);
+    return true;
+  }
+  return false;
+}
+
+bool
+Headers::IsForbiddenRequestHeader(const nsACString& aName) const
+{
+  return mGuard == HeadersGuardEnum::Request &&
+         nsContentUtils::IsForbiddenRequestHeader(aName);
+}
+
+bool
+Headers::IsForbiddenRequestNoCorsHeader(const nsACString& aName,
+                                        const nsACString* aValue) const
+{
+  return mGuard == HeadersGuardEnum::Request_no_cors &&
+         !IsSimpleHeader(aName, aValue);
+}
+
+bool
+Headers::IsForbiddenResponseHeader(const nsACString& aName) const
+{
+  return mGuard == HeadersGuardEnum::Response &&
+         nsContentUtils::IsForbiddenResponseHeader(aName);
+}
+
+void
+Headers::Fill(const Headers& aInit, ErrorResult&)
+{
+  mList = aInit.mList;
+}
+
+void
+Headers::Fill(const Sequence<Sequence<nsCString>>& aInit, ErrorResult& aRv)
+{
+  for (uint32_t i = 0; i < aInit.Length() && !aRv.Failed(); ++i) {
+    const Sequence<nsCString>& tuple = aInit[i];
+    if (tuple.Length() != 2) {
+      aRv.ThrowTypeError(MSG_INVALID_HEADER_SEQUENCE);
+      return;
+    }
+    Append(tuple[0], tuple[1], aRv);
+  }
+}
+
+void
+Headers::Fill(const MozMap<nsCString>& aInit, ErrorResult& aRv)
+{
+  nsTArray<nsString> keys;
+  aInit.GetKeys(keys);
+  for (uint32_t i = 0; i < keys.Length() && !aRv.Failed(); ++i) {
+    Append(NS_ConvertUTF16toUTF8(keys[i]), aInit.Get(keys[i]), aRv);
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/fetch/Headers.h b/dom/fetch/Headers.h
new file mode 100644
--- /dev/null
+++ b/dom/fetch/Headers.h
@@ -0,0 +1,112 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_Headers_h
+#define mozilla_dom_Headers_h
+
+#include "mozilla/dom/HeadersBinding.h"
+#include "nsClassHashtable.h"
+#include "nsWrapperCache.h"
+
+class nsPIDOMWindow;
+
+namespace mozilla {
+
+class ErrorResult;
+
+namespace dom {
+
+template<typename T> class MozMap;
+class HeadersOrByteStringSequenceSequenceOrByteStringMozMap;
+
+class Headers MOZ_FINAL : public nsISupports
+                        , public nsWrapperCache
+{
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Headers)
+
+private:
+  struct Entry
+  {
+    Entry(const nsACString& aName, const nsACString& aValue)
+      : mName(aName)
+      , mValue(aValue)
+    { }
+
+    Entry() { }
+
+    nsCString mName;
+    nsCString mValue;
+  };
+
+  nsRefPtr<nsISupports> mOwner;
+  HeadersGuardEnum mGuard;
+  nsTArray<Entry> mList;
+
+public:
+  explicit Headers(nsISupports* aOwner, HeadersGuardEnum aGuard = HeadersGuardEnum::None)
+    : mOwner(aOwner)
+    , mGuard(aGuard)
+  {
+    SetIsDOMBinding();
+  }
+
+  static already_AddRefed<Headers>
+  Constructor(const GlobalObject& aGlobal,
+              const Optional<HeadersOrByteStringSequenceSequenceOrByteStringMozMap>& aInit,
+              ErrorResult& aRv);
+
+  void Append(const nsACString& aName, const nsACString& aValue,
+              ErrorResult& aRv);
+  void Delete(const nsACString& aName, ErrorResult& aRv);
+  void Get(const nsACString& aName, nsCString& aValue, ErrorResult& aRv) const;
+  void GetAll(const nsACString& aName, nsTArray<nsCString>& aResults,
+              ErrorResult& aRv) const;
+  bool Has(const nsACString& aName, ErrorResult& aRv) const;
+  void Set(const nsACString& aName, const nsACString& aValue, ErrorResult& aRv);
+
+  // ChromeOnly
+  HeadersGuardEnum Guard() const { return mGuard; }
+  void SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv);
+
+  virtual JSObject* WrapObject(JSContext* aCx);
+  nsISupports* GetParentObject() const { return mOwner; }
+
+private:
+  Headers(const Headers& aOther) MOZ_DELETE;
+  virtual ~Headers();
+
+  static bool IsSimpleHeader(const nsACString& aName,
+                             const nsACString* aValue = nullptr);
+  static bool IsInvalidName(const nsACString& aName, ErrorResult& aRv);
+  static bool IsInvalidValue(const nsACString& aValue, ErrorResult& aRv);
+  bool IsImmutable(ErrorResult& aRv) const;
+  bool IsForbiddenRequestHeader(const nsACString& aName) const;
+  bool IsForbiddenRequestNoCorsHeader(const nsACString& aName,
+                                      const nsACString* aValue = nullptr) const;
+  bool IsForbiddenResponseHeader(const nsACString& aName) const;
+
+  bool IsInvalidMutableHeader(const nsACString& aName,
+                              const nsACString* aValue,
+                              ErrorResult& aRv) const
+  {
+    return IsInvalidName(aName, aRv) ||
+           (aValue && IsInvalidValue(*aValue, aRv)) ||
+           IsImmutable(aRv) ||
+           IsForbiddenRequestHeader(aName) ||
+           IsForbiddenRequestNoCorsHeader(aName, aValue) ||
+           IsForbiddenResponseHeader(aName);
+  }
+
+  void Fill(const Headers& aInit, ErrorResult& aRv);
+  void Fill(const Sequence<Sequence<nsCString>>& aInit, ErrorResult& aRv);
+  void Fill(const MozMap<nsCString>& aInit, ErrorResult& aRv);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_Headers_h
diff --git a/dom/fetch/moz.build b/dom/fetch/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/fetch/moz.build
@@ -0,0 +1,17 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+    'Headers.h',
+]
+
+UNIFIED_SOURCES += [
+    'Headers.cpp',
+]
+
+FAIL_ON_WARNINGS = True
+MSVC_ENABLE_PGO = True
+FINAL_LIBRARY = 'xul'
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -47,16 +47,17 @@ PARALLEL_DIRS += [
     'contacts',
     'crypto',
     'phonenumberutils',
     'alarm',
     'datastore',
     'devicestorage',
     'encoding',
     'events',
+    'fetch',
     'filehandle',
     'filesystem',
     'fmradio',
     'asmjscache',
     'mathml',
     'media',
     'messages',
     'power',
diff --git a/dom/tests/mochitest/general/test_interfaces.html b/dom/tests/mochitest/general/test_interfaces.html
--- a/dom/tests/mochitest/general/test_interfaces.html
+++ b/dom/tests/mochitest/general/test_interfaces.html
@@ -389,16 +389,18 @@ var interfaceNamesInGlobalScope =
     {name: "GamepadButtonEvent", b2g: false},
 // IMPORTANT: Do not change this list without review from a DOM peer!
     {name: "GamepadButton", b2g: false},
 // IMPORTANT: Do not change this list without review from a DOM peer!
     {name: "GamepadEvent", b2g: false},
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HashChangeEvent",
 // IMPORTANT: Do not change this list without review from a DOM peer!
+    {name: "Headers", pref: "dom.fetch.enabled"},
+// IMPORTANT: Do not change this list without review from a DOM peer!
     "History",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLAllCollection",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLAnchorElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLAppletElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
diff --git a/dom/webidl/Headers.webidl b/dom/webidl/Headers.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/Headers.webidl
@@ -0,0 +1,35 @@
+/* -*- Mode: IDL; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * http://fetch.spec.whatwg.org/#headers-class
+ */
+
+typedef (Headers or sequence<sequence<ByteString>> or MozMap<ByteString>) HeadersInit;
+
+enum HeadersGuardEnum {
+  "none",
+  "request",
+  "request-no-cors",
+  "response",
+  "immutable"
+};
+
+[Constructor(optional HeadersInit init),
+ // FIXME: Exposed=Window,Worker,
+ Pref="dom.fetch.enabled"]
+interface Headers {
+  [Throws] void append(ByteString name, ByteString value);
+  [Throws] void delete(ByteString name);
+  [Throws] ByteString? get(ByteString name);
+  [Throws] sequence<ByteString> getAll(ByteString name);
+  [Throws] boolean has(ByteString name);
+  [Throws] void set(ByteString name, ByteString value);
+
+  // Used to test different guard states from mochitest.
+  // Note: Must be set prior to populating headers or will throw.
+  [ChromeOnly, SetterThrows] attribute HeadersGuardEnum guard;
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -124,16 +124,17 @@ WEBIDL_FILES = [
     'FileReaderSync.webidl',
     'FocusEvent.webidl',
     'FormData.webidl',
     'Function.webidl',
     'GainNode.webidl',
     'Geolocation.webidl',
     'GeometryUtils.webidl',
     'GetUserMediaRequest.webidl',
+    'Headers.webidl',
     'History.webidl',
     'HTMLAllCollection.webidl',
     'HTMLAnchorElement.webidl',
     'HTMLAppletElement.webidl',
     'HTMLAreaElement.webidl',
     'HTMLAudioElement.webidl',
     'HTMLBaseElement.webidl',
     'HTMLBodyElement.webidl',
diff --git a/dom/workers/RegisterBindings.cpp b/dom/workers/RegisterBindings.cpp
--- a/dom/workers/RegisterBindings.cpp
+++ b/dom/workers/RegisterBindings.cpp
@@ -12,16 +12,17 @@
 #include "js/OldDebugAPI.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ConsoleBinding.h"
 #include "mozilla/dom/DOMExceptionBinding.h"
 #include "mozilla/dom/EventBinding.h"
 #include "mozilla/dom/EventHandlerBinding.h"
 #include "mozilla/dom/EventTargetBinding.h"
 #include "mozilla/dom/FileReaderSyncBinding.h"
+#include "mozilla/dom/HeadersBinding.h"
 #include "mozilla/dom/ImageData.h"
 #include "mozilla/dom/ImageDataBinding.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/MessagePortBinding.h"
 #include "mozilla/dom/PromiseBinding.h"
 #include "mozilla/dom/TextDecoderBinding.h"
 #include "mozilla/dom/TextEncoderBinding.h"
 #include "mozilla/dom/XMLHttpRequestBinding.h"
@@ -74,14 +75,20 @@ WorkerPrivate::RegisterBindings(JSContex
       !URLBinding_workers::GetConstructorObject(aCx, aGlobal) ||
       !URLSearchParamsBinding::GetConstructorObject(aCx, aGlobal) ||
       !WorkerBinding::GetConstructorObject(aCx, aGlobal) ||
       !WorkerLocationBinding_workers::GetConstructorObject(aCx, aGlobal) ||
       !WorkerNavigatorBinding_workers::GetConstructorObject(aCx, aGlobal)) {
     return false;
   }
 
+  if (DOMFetchEnabled()) {
+    if (!HeadersBinding::GetConstructorObject(aCx, aGlobal)) {
+      return false;
+    }
+  }
+
   if (!JS_DefineProfilingFunctions(aCx, aGlobal)) {
     return false;
   }
 
   return true;
 }
