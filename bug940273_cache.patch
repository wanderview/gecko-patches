# HG changeset patch
# Parent c8e3484e7733f3e8540c1b69af49f650a7b5e5c6
# User Ben Kelly <ben@wanderview.com>
Bug 940273 Cache and CacheStorage work-in-progress

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -207,16 +207,17 @@
 #include "nsHTMLDocument.h"
 #include "nsWrapperCacheInlines.h"
 #include "mozilla/DOMEventTargetHelper.h"
 #include "prrng.h"
 #include "nsSandboxFlags.h"
 #include "TimeChangeObserver.h"
 #include "mozilla/dom/AudioContext.h"
 #include "mozilla/dom/BrowserElementDictionariesBinding.h"
+#include "mozilla/dom/CacheStorage.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/HashChangeEvent.h"
 #include "mozilla/dom/PopStateEvent.h"
 #include "mozilla/dom/PopupBlockedEvent.h"
 #include "mozilla/dom/WindowBinding.h"
 #include "nsITabChild.h"
 #include "mozilla/dom/MediaQueryList.h"
@@ -1767,16 +1768,18 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIdleService)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPendingStorageEvents)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIdleObservers)
 
 #ifdef MOZ_GAMEPAD
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mGamepads)
 #endif
 
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCacheStorage)
+
   // Traverse stuff from nsPIDOMWindow
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mChromeEventHandler)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mParentTarget)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFrameElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFocusedNode)
 
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mMenubar)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mToolbar)
@@ -1827,16 +1830,18 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(ns
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIdleService)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPendingStorageEvents)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mIdleObservers)
 
 #ifdef MOZ_GAMEPAD
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mGamepads)
 #endif
 
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCacheStorage)
+
   // Unlink stuff from nsPIDOMWindow
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mChromeEventHandler)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mParentTarget)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFrameElement)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFocusedNode)
 
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mMenubar)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mToolbar)
@@ -10741,16 +10746,32 @@ nsGlobalWindow::GetInterface(const nsIID
 void
 nsGlobalWindow::GetInterface(JSContext* aCx, nsIJSID* aIID,
                              JS::MutableHandle<JS::Value> aRetval,
                              ErrorResult& aError)
 {
   dom::GetInterface(aCx, this, aIID, aRetval, aError);
 }
 
+already_AddRefed<CacheStorage>
+nsGlobalWindow::Caches()
+{
+  if (!mCacheStorage) {
+    nsAutoCString origin;
+    nsCOMPtr<nsIPrincipal> principal = GetPrincipal();
+    if (!principal || NS_FAILED(principal->GetOrigin(getter_Copies(origin)))) {
+      origin.AssignLiteral("null");
+    }
+    mCacheStorage = new CacheStorage(ToSupports(this), origin);
+  }
+
+  nsRefPtr<CacheStorage> ref = mCacheStorage;
+  return ref.forget();
+}
+
 void
 nsGlobalWindow::FireOfflineStatusEvent()
 {
   if (!IsCurrentInnerWindow())
     return;
   nsAutoString name;
   if (NS_IsOffline()) {
     name.AssignLiteral("offline");
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -103,16 +103,17 @@ struct nsIntSize;
 struct nsRect;
 
 class nsWindowSizes;
 
 namespace mozilla {
 class DOMEventTargetHelper;
 namespace dom {
 class BarProp;
+class CacheStorage;
 class Console;
 class External;
 class Function;
 class Gamepad;
 class MediaQueryList;
 class Navigator;
 class OwningExternalOrWindowProxy;
 class Selection;
@@ -1051,16 +1052,18 @@ public:
                       mozilla::ErrorResult& aError);
   void SetReturnValue(JSContext* aCx, JS::Handle<JS::Value> aReturnValue,
                       mozilla::ErrorResult& aError);
 
   void GetInterface(JSContext* aCx, nsIJSID* aIID,
                     JS::MutableHandle<JS::Value> aRetval,
                     mozilla::ErrorResult& aError);
 
+  already_AddRefed<mozilla::dom::CacheStorage> Caches();
+
 protected:
   // Array of idle observers that are notified of idle events.
   nsTObserverArray<IdleObserverHolder> mIdleObservers;
 
   // Idle timer used for function callbacks to notify idle observers.
   nsCOMPtr<nsITimer> mIdleTimer;
 
   // Idle fuzz time added to idle timer callbacks.
@@ -1626,16 +1629,18 @@ protected:
 
   nsTArray<uint32_t> mEnabledSensors;
 
 #ifdef MOZ_WEBSPEECH
   // mSpeechSynthesis is only used on inner windows.
   nsRefPtr<mozilla::dom::SpeechSynthesis> mSpeechSynthesis;
 #endif
 
+  nsRefPtr<mozilla::dom::CacheStorage> mCacheStorage;
+
   friend class nsDOMScriptableHelper;
   friend class nsDOMWindowUtils;
   friend class PostMessageEvent;
   friend class DesktopNotification;
 
   static WindowByIdTable* sWindowsById;
   static bool sWarnedAboutWindowInternal;
 };
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Cache.cpp
@@ -0,0 +1,124 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/Cache.h"
+#include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/Preferences.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(Cache);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(Cache);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mOwner)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Cache)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+Cache::Cache(nsISupports* aOwner)
+: mOwner(aOwner)
+{
+  SetIsDOMBinding();
+}
+
+already_AddRefed<Promise>
+Cache::Match(const RequestOrScalarValueString& aRequest,
+             const QueryParams& aParams)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::MatchAll(const RequestOrScalarValueString& aRequest,
+                const QueryParams& aParams)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::Add(const RequestOrScalarValueString& aRequests)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::AddAll(const Sequence<OwningRequestOrScalarValueString>& aRequests)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::Put(const RequestOrScalarValueString& aRequest,
+           const Response& aResponse)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::Delete(const RequestOrScalarValueString& aRequest,
+              const QueryParams& aParams)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+Cache::Keys(const Optional<RequestOrScalarValueString>& aRequest,
+            const QueryParams& aParams)
+{
+  MOZ_CRASH("not implemented");
+}
+
+// static
+bool
+Cache::PrefEnabled(JSContext* aCx, JSObject* aObj)
+{
+  using mozilla::dom::workers::WorkerPrivate;
+  using mozilla::dom::workers::GetWorkerPrivateFromContext;
+
+  // In the long term we want to support Cache on main-thread, so
+  // allow it to be exposed there via a pref.
+  if (NS_IsMainThread()) {
+    static bool sPrefCacheInit = false;
+    static bool sPrefEnabled = false;
+    if (sPrefCacheInit) {
+      return sPrefEnabled;
+    }
+    Preferences::AddBoolVarCache(&sPrefEnabled, "dom.window-caches.enabled");
+    sPrefCacheInit = true;
+    return sPrefEnabled;
+  }
+
+  WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
+  if (!workerPrivate) {
+    return false;
+  }
+
+  // Otherwise expose on ServiceWorkers.  Also expose on others workers if
+  // pref enabled.
+  return workerPrivate->IsServiceWorker() || workerPrivate->DOMCachesEnabled();
+}
+
+nsISupports*
+Cache::GetParentObject() const
+{
+  return mOwner;
+}
+
+JSObject*
+Cache::WrapObject(JSContext* aContext)
+{
+  return CacheBinding::Wrap(aContext, this);
+}
+
+Cache::~Cache()
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Cache.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_Cache_h
+#define mozilla_dom_Cache_h
+
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsWrapperCache.h"
+
+namespace mozilla {
+namespace dom {
+
+class Promise;
+class OwningRequestOrScalarValueString;
+class RequestOrScalarValueString;
+class QueryParams;
+class Response;
+template<typename T> class Optional;
+template<typename T> class Sequence;
+
+class Cache MOZ_FINAL : public nsISupports
+                      , public nsWrapperCache
+{
+public:
+  // webidl interface methods
+  already_AddRefed<Promise> Match(const RequestOrScalarValueString& aRequest,
+                                  const QueryParams& aParams);
+  already_AddRefed<Promise> MatchAll(const RequestOrScalarValueString& aRequest,
+                                     const QueryParams& aParams);
+  already_AddRefed<Promise> Add(const RequestOrScalarValueString& aRequest);
+  already_AddRefed<Promise> AddAll(const Sequence<OwningRequestOrScalarValueString>& aRequests);
+  already_AddRefed<Promise> Put(const RequestOrScalarValueString& aRequest,
+                                const Response& aResponse);
+  already_AddRefed<Promise> Delete(const RequestOrScalarValueString& aRequest,
+                                   const QueryParams& aParams);
+  already_AddRefed<Promise> Keys(const Optional<RequestOrScalarValueString>& aRequest,
+                                 const QueryParams& aParams);
+
+  // binding methods
+  static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
+
+  virtual nsISupports* GetParentObject() const MOZ_OVERRIDE;
+  virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Cache)
+
+private:
+  Cache(nsISupports* aOwner);
+  virtual ~Cache();
+
+private:
+  nsCOMPtr<nsISupports> mOwner;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_Cache_h
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorage.cpp
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/CacheStorage.h"
+#include "mozilla/dom/Cache.h"
+#include "mozilla/dom/CacheStorageBinding.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(CacheStorage);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(CacheStorage);
+NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CacheStorage, mOwner)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(CacheStorage)
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+NS_INTERFACE_MAP_END
+
+CacheStorage::CacheStorage(nsISupports* aOwner, const nsACString& aOrigin)
+  : mOwner(aOwner)
+  , mOrigin(aOrigin)
+{
+  SetIsDOMBinding();
+}
+
+already_AddRefed<Promise>
+CacheStorage::Match(const RequestOrScalarValueString& aRequest,
+                    const QueryParams& aParams)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+CacheStorage::Get(const nsAString& aKey)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+CacheStorage::Has(const nsAString& aKey)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+CacheStorage::Create(const nsAString& aKey)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+CacheStorage::Delete(const nsAString& aKey)
+{
+  MOZ_CRASH("not implemented");
+}
+
+already_AddRefed<Promise>
+CacheStorage::Keys()
+{
+  MOZ_CRASH("not implemented");
+}
+
+// static
+bool
+CacheStorage::PrefEnabled(JSContext* aCx, JSObject* aObj)
+{
+  return Cache::PrefEnabled(aCx, aObj);
+}
+
+nsISupports*
+CacheStorage::GetParentObject() const
+{
+  return mOwner;
+}
+
+JSObject*
+CacheStorage::WrapObject(JSContext* aContext)
+{
+  return mozilla::dom::CacheStorageBinding::Wrap(aContext, this);
+}
+
+CacheStorage::~CacheStorage()
+{
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/CacheStorage.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_CacheStorage_h
+#define mozilla_dom_CacheStorage_h
+
+#include "nsISupportsImpl.h"
+#include "nsWrapperCache.h"
+
+namespace mozilla {
+namespace dom {
+
+class Promise;
+class QueryParams;
+class RequestOrScalarValueString;
+
+class CacheStorage MOZ_FINAL : public nsISupports
+                             , public nsWrapperCache
+{
+public:
+  explicit CacheStorage(nsISupports* aOwner, const nsACString& aOrigin);
+
+  // webidl interface methods
+  already_AddRefed<Promise> Match(const RequestOrScalarValueString& aRequest,
+                                  const QueryParams& aParams);
+  already_AddRefed<Promise> Get(const nsAString& aKey);
+  already_AddRefed<Promise> Has(const nsAString& aKey);
+  already_AddRefed<Promise> Create(const nsAString& aKey);
+  already_AddRefed<Promise> Delete(const nsAString& aKey);
+  already_AddRefed<Promise> Keys();
+
+  // binding methods
+  static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
+
+  virtual nsISupports* GetParentObject() const MOZ_OVERRIDE;
+  virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
+
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CacheStorage)
+
+private:
+  virtual ~CacheStorage();
+
+  nsCOMPtr<nsISupports> mOwner;
+  const nsCString mOrigin;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_CacheStorage_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
new file mode 100644
--- /dev/null
+++ b/dom/cache/moz.build
@@ -0,0 +1,23 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+EXPORTS.mozilla.dom += [
+    'Cache.h',
+    'CacheStorage.h',
+]
+
+UNIFIED_SOURCES += [
+    'Cache.cpp',
+    'CacheStorage.cpp',
+]
+
+LOCAL_INCLUDES += [
+    '../workers',
+]
+
+FAIL_ON_WARNINGS = True
+
+FINAL_LIBRARY = 'xul'
diff --git a/dom/ipc/PCache.ipdl b/dom/ipc/PCache.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/ipc/PCache.ipdl
@@ -0,0 +1,19 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+namespace mozilla {
+namespace dom {
+
+protocol PCache
+{
+  manager PBackground;
+
+both:
+  __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/ipc/PCacheStorage.ipdl b/dom/ipc/PCacheStorage.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/ipc/PCacheStorage.ipdl
@@ -0,0 +1,19 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+namespace mozilla {
+namespace dom {
+
+protocol PCacheStorage
+{
+  manager PBackground;
+
+both:
+  __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/ipc/moz.build b/dom/ipc/moz.build
--- a/dom/ipc/moz.build
+++ b/dom/ipc/moz.build
@@ -74,16 +74,18 @@ SOURCES += [
     'CrashReporterChild.cpp',
 ]
 
 IPDL_SOURCES += [
     'DOMTypes.ipdlh',
     'PBlob.ipdl',
     'PBlobStream.ipdl',
     'PBrowser.ipdl',
+    'PCache.ipdl',
+    'PCacheStorage.ipdl',
     'PColorPicker.ipdl',
     'PContent.ipdl',
     'PContentBridge.ipdl',
     'PContentPermission.ipdlh',
     'PContentPermissionRequest.ipdl',
     'PCrashReporter.ipdl',
     'PCycleCollectWithLogs.ipdl',
     'PDocumentRenderer.ipdl',
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -38,16 +38,17 @@ DIRS += [
     'animation',
     'apps',
     'base',
     'activities',
     'archivereader',
     'bindings',
     'battery',
     'browser-element',
+    'cache',
     'canvas',
     'contacts',
     'crypto',
     'phonenumberutils',
     'alarm',
     'datastore',
     'devicestorage',
     'encoding',
diff --git a/dom/tests/mochitest/cache/mochitest.ini b/dom/tests/mochitest/cache/mochitest.ini
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/mochitest.ini
@@ -0,0 +1,8 @@
+[DEFAULT]
+support-files =
+  test_cache.js
+  test_cache_frame.html
+  worker_driver.js
+  worker_wrapper.js
+
+[test_cache.html]
diff --git a/dom/tests/mochitest/cache/test_cache.html b/dom/tests/mochitest/cache/test_cache.html
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/test_cache.html
@@ -0,0 +1,33 @@
+<!-- Any copyright is dedicated to the Public Domain.
+   - http://creativecommons.org/publicdomain/zero/1.0/ -->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Validate Interfaces Exposed to Workers</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <script type="text/javascript" src="worker_driver.js"></script>
+</head>
+<body>
+<iframe id="frame"></iframe>
+<script class="testbody" type="text/javascript">
+SimpleTest.waitForExplicitFinish();
+SpecialPowers.setBoolPref("dom.window-caches.enabled", true);
+var frame = document.getElementById("frame");
+frame.src = "test_cache_frame.html";
+frame.onload = function() {
+  frame = frame.contentWindow;
+
+  addEventListener("message", function(evt) {
+    ok(evt.data.success, "frame should have succeeded");
+    SpecialPowers.setBoolPref("dom.worker-caches.enabled", true);
+    workerTestExec("test_cache.js");
+  });
+
+  frame.postMessage({
+    type: "start"
+  }, "*");
+}
+</script>
+</body>
+</html>
diff --git a/dom/tests/mochitest/cache/test_cache.js b/dom/tests/mochitest/cache/test_cache.js
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/test_cache.js
@@ -0,0 +1,2 @@
+ok(!!caches, 'caches object should be available on global');
+workerTestDone();
diff --git a/dom/tests/mochitest/cache/test_cache_frame.html b/dom/tests/mochitest/cache/test_cache_frame.html
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/test_cache_frame.html
@@ -0,0 +1,23 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+<title>Test for SharedWorker</title>
+</head>
+<body>
+<script type="text/javascript">
+  "use strict";
+  addEventListener("message", function(evt) {
+    var success = true;
+    success = success && !!caches;
+    parent.postMessage({
+      type: "result",
+      success: success
+    }, "*");
+  });
+</script>
+</body>
+</html>
diff --git a/dom/tests/mochitest/cache/worker_driver.js b/dom/tests/mochitest/cache/worker_driver.js
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/worker_driver.js
@@ -0,0 +1,82 @@
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/publicdomain/zero/1.0/
+//
+// Utility script for writing worker tests.  In your main document do:
+//
+//  <script type="text/javascript" src="worker_driver.js"></script>
+//  <script type="text/javascript">
+//    workerTestExec('myWorkerTestCase.js')
+//  </script>
+//
+// This will then spawn a worker, define some utility functions, and then
+// execute the code in myWorkerTestCase.js.  You can then use these
+// functions in your worker-side test:
+//
+//  ok() - like the SimpleTest assert
+//  is() - like the SimpleTest assert
+//  workerTestDone() - like SimpleTest.finish() indicating the test is complete
+//
+// There are also some functions for requesting information that requires
+// SpecialPowers or other main-thread-only resources:
+//
+//  workerTestGetPrefs() - request an array of prefs value from the main thread
+//  workerTestGetPermissions() - request an array permissions from the MT
+//  workerTestGetVersion() - request the current version string from the MT
+//  workerTestGetUserAgent() - request the user agent string from the MT
+//
+// For an example see test_worker_interfaces.html and test_worker_interfaces.js.
+
+function workerTestExec(script) {
+  SimpleTest.waitForExplicitFinish();
+  var worker = new Worker('worker_wrapper.js');
+  worker.onmessage = function(event) {
+    if (event.data.type == 'finish') {
+      SimpleTest.finish();
+
+    } else if (event.data.type == 'status') {
+      ok(event.data.status, event.data.msg);
+
+    } else if (event.data.type == 'getPrefs') {
+      var result = {};
+      event.data.prefs.forEach(function(pref) {
+        result[pref] = SpecialPowers.Services.prefs.getBoolPref(pref);
+      });
+      worker.postMessage({
+        type: 'returnPrefs',
+        prefs: event.data.prefs,
+        result: result
+      });
+
+    } else if (event.data.type == 'getPermissions') {
+      var result = {};
+      event.data.permissions.forEach(function(permission) {
+        result[permission] = SpecialPowers.hasPermission(permission, window.document);
+      });
+      worker.postMessage({
+        type: 'returnPermissions',
+        permissions: event.data.permissions,
+        result: result
+      });
+
+    } else if (event.data.type == 'getVersion') {
+      var result = SpecialPowers.Cc['@mozilla.org/xre/app-info;1'].getService(SpecialPowers.Ci.nsIXULAppInfo).version;
+      worker.postMessage({
+        type: 'returnVersion',
+        result: result
+      });
+
+    } else if (event.data.type == 'getUserAgent') {
+      worker.postMessage({
+        type: 'returnUserAgent',
+        result: navigator.userAgent
+      });
+    }
+  }
+
+  worker.onerror = function(event) {
+    ok(false, 'Worker had an error: ' + event.data);
+    SimpleTest.finish();
+  };
+
+  worker.postMessage({ script: script });
+}
diff --git a/dom/tests/mochitest/cache/worker_wrapper.js b/dom/tests/mochitest/cache/worker_wrapper.js
new file mode 100644
--- /dev/null
+++ b/dom/tests/mochitest/cache/worker_wrapper.js
@@ -0,0 +1,101 @@
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/publicdomain/zero/1.0/
+//
+// Worker-side wrapper script for the worker_driver.js helper code.  See
+// the comments at the top of worker_driver.js for more information.
+
+function ok(a, msg) {
+  dump("OK: " + !!a + "  =>  " + a + ": " + msg + "\n");
+  postMessage({type: 'status', status: !!a, msg: a + ": " + msg });
+}
+
+function is(a, b, msg) {
+  dump("IS: " + (a===b) + "  =>  " + a + " | " + b + ": " + msg + "\n");
+  postMessage({type: 'status', status: a === b, msg: a + " === " + b + ": " + msg });
+}
+
+function workerTestArrayEquals(a, b) {
+  if (!Array.isArray(a) || !Array.isArray(b) || a.length != b.length) {
+    return false;
+  }
+  for (var i = 0, n = a.length; i < n; ++i) {
+    if (a[i] !== b[i]) {
+      return false;
+    }
+  }
+  return true;
+}
+
+function workerTestDone() {
+  postMessage({ type: 'finish' });
+}
+
+function workerTestGetPrefs(prefs, cb) {
+  addEventListener('message', function workerTestGetPrefsCB(e) {
+    if (e.data.type != 'returnPrefs' ||
+        !workerTestArrayEquals(prefs, e.data.prefs)) {
+      return;
+    }
+    removeEventListener('message', workerTestGetPrefsCB);
+    cb(e.data.result);
+  });
+  postMessage({
+    type: 'getPrefs',
+    prefs: prefs
+  });
+}
+
+function workerTestGetPermissions(permissions, cb) {
+  addEventListener('message', function workerTestGetPermissionsCB(e) {
+    if (e.data.type != 'returnPermissions' ||
+        !workerTestArrayEquals(permissions, e.data.permissions)) {
+      return;
+    }
+    removeEventListener('message', workerTestGetPermissionsCB);
+    cb(e.data.result);
+  });
+  postMessage({
+    type: 'getPermissions',
+    permissions: permissions
+  });
+}
+
+function workerTestGetVersion(cb) {
+  addEventListener('message', function workerTestGetVersionCB(e) {
+    if (e.data.type !== 'returnVersion') {
+      return;
+    }
+    removeEventListener('message', workerTestGetVersionCB);
+    cb(e.data.result);
+  });
+  postMessage({
+    type: 'getVersion'
+  });
+}
+
+function workerTestGetUserAgent(cb) {
+  addEventListener('message', function workerTestGetUserAgentCB(e) {
+    if (e.data.type !== 'returnUserAgent') {
+      return;
+    }
+    removeEventListener('message', workerTestGetUserAgentCB);
+    cb(e.data.result);
+  });
+  postMessage({
+    type: 'getUserAgent'
+  });
+}
+
+addEventListener('message', function workerWrapperOnMessage(e) {
+  removeEventListener('message', workerWrapperOnMessage);
+  var data = e.data;
+  try {
+    importScripts(data.script);
+  } catch(e) {
+    postMessage({
+      type: 'status',
+      status: false,
+      msg: 'worker failed to import ' + data.script + "; error: " + e.message
+    });
+  }
+});
diff --git a/dom/tests/moz.build b/dom/tests/moz.build
--- a/dom/tests/moz.build
+++ b/dom/tests/moz.build
@@ -9,16 +9,17 @@ MOCHITEST_MANIFESTS += [
     'mochitest/ajax/lib/mochitest.ini',
     'mochitest/ajax/mochikit/mochitest.ini',
     'mochitest/ajax/mochikit/tests/mochitest.ini',
     'mochitest/ajax/offline/mochitest.ini',
     'mochitest/ajax/prototype/mochitest.ini',
     'mochitest/ajax/scriptaculous/mochitest.ini',
     'mochitest/beacon/mochitest.ini',
     'mochitest/bugs/mochitest.ini',
+    'mochitest/cache/mochitest.ini',
     'mochitest/crypto/mochitest.ini',
     'mochitest/dom-level0/mochitest.ini',
     'mochitest/dom-level1-core/mochitest.ini',
     'mochitest/dom-level2-core/mochitest.ini',
     'mochitest/dom-level2-html/mochitest.ini',
     'mochitest/fetch/mochitest.ini',
     'mochitest/general/mochitest.ini',
     'mochitest/geolocation/mochitest.ini',
diff --git a/dom/webidl/Cache.webidl b/dom/webidl/Cache.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/Cache.webidl
@@ -0,0 +1,41 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html
+ *
+ */
+
+[Exposed=(Window,Worker),
+ Func="mozilla::dom::Cache::PrefEnabled"]
+interface Cache {
+  Promise<Response> match((Request or ScalarValueString) request,
+                          optional QueryParams params);
+  Promise<sequence<Response>> matchAll((Request or ScalarValueString) request,
+                                       optional QueryParams params);
+  Promise<Response> add((Request or ScalarValueString) request);
+  Promise<sequence<Response>> addAll(sequence<(Request or ScalarValueString)> requests);
+  Promise<Response> put((Request or ScalarValueString) request,
+                        Response response);
+  Promise<boolean> delete((Request or ScalarValueString) request,
+                          optional QueryParams params);
+  Promise<sequence<Request>> keys(optional (Request or ScalarValueString) request,
+                                  optional QueryParams params);
+};
+
+dictionary QueryParams {
+  boolean ignoreSearch;
+  boolean ignoreMethod;
+  boolean ignoreVary;
+  boolean prefixMatch;
+  DOMString cacheName;
+};
+
+dictionary CacheBatchOperation {
+  DOMString type;
+  Request request;
+  Response response;
+  QueryParams matchParams;
+};
diff --git a/dom/webidl/CacheStorage.webidl b/dom/webidl/CacheStorage.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/CacheStorage.webidl
@@ -0,0 +1,21 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html
+ *
+ */
+
+[Exposed=(Window,Worker),
+ Func="mozilla::dom::CacheStorage::PrefEnabled"]
+interface CacheStorage {
+   Promise<Response> match((Request or ScalarValueString) request,
+                           optional QueryParams params);
+   Promise<Cache> get(DOMString cacheName);
+   Promise<boolean> has(DOMString cacheName);
+   Promise<Cache> create(DOMString cacheName);
+   Promise<boolean> delete(DOMString cacheName);
+   Promise<sequence<DOMString>> keys();
+};
diff --git a/dom/webidl/ServiceWorkerGlobalScope.webidl b/dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl
@@ -8,18 +8,17 @@
  *
  * You are granted a license to use, reproduce and create derivative works of
  * this document.
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
-  // FIXME(nsm): Bug 982725
-  // readonly attribute CacheList caches;
+  readonly attribute CacheStorage caches;
 
   // FIXME(nsm): Bug 982726
   // A container for a list of window objects, identifiable by ID, that
   // correspond to windows (or workers) that are "controlled" by this SW
   // readonly attribute ServiceWorkerClients clients;
 
   [Unforgeable] readonly attribute DOMString scope;
 
diff --git a/dom/webidl/Window.webidl b/dom/webidl/Window.webidl
--- a/dom/webidl/Window.webidl
+++ b/dom/webidl/Window.webidl
@@ -452,11 +452,14 @@ interface ChromeWindow {
    * while the left mouse button is held down, callers must check this.
    *
    * The optional panel argument should be set when moving a panel.
    *
    * Throws NS_ERROR_NOT_IMPLEMENTED if the OS doesn't support this.
    */
   [Throws, Func="nsGlobalWindow::IsChromeWindow"]
   void beginWindowMove(Event mouseDownEvent, optional Element? panel = null);
+
+  [Pref="dom.window-caches.enabled"]
+  readonly attribute CacheStorage caches;
 };
 
 Window implements ChromeWindow;
diff --git a/dom/webidl/WorkerGlobalScope.webidl b/dom/webidl/WorkerGlobalScope.webidl
--- a/dom/webidl/WorkerGlobalScope.webidl
+++ b/dom/webidl/WorkerGlobalScope.webidl
@@ -39,9 +39,12 @@ partial interface WorkerGlobalScope {
 WorkerGlobalScope implements WindowTimers;
 WorkerGlobalScope implements WindowBase64;
 
 // Mozilla extensions
 partial interface WorkerGlobalScope {
   attribute EventHandler onclose;
 
   void dump(optional DOMString str);
+
+  [Func="mozilla::dom::CacheStorage::PrefEnabled"]
+  readonly attribute CacheStorage caches;
 };
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -45,16 +45,18 @@ WEBIDL_FILES = [
     'AudioTrackList.webidl',
     'AutocompleteInfo.webidl',
     'BarProp.webidl',
     'BatteryManager.webidl',
     'BeforeUnloadEvent.webidl',
     'BiquadFilterNode.webidl',
     'Blob.webidl',
     'BrowserElementDictionaries.webidl',
+    'Cache.webidl',
+    'CacheStorage.webidl',
     'CallsList.webidl',
     'CameraCapabilities.webidl',
     'CameraControl.webidl',
     'CameraManager.webidl',
     'CanvasRenderingContext2D.webidl',
     'CaretPosition.webidl',
     'CDATASection.webidl',
     'ChannelMergerNode.webidl',
diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -150,16 +150,17 @@ static_assert(MAX_WORKERS_PER_DOMAIN >= 
 #define PREF_GCZEAL "gcZeal"
 
 #if !(defined(DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
 #define DUMP_CONTROLLED_BY_PREF 1
 #define PREF_DOM_WINDOW_DUMP_ENABLED "browser.dom.window.dump.enabled"
 #endif
 
 #define PREF_DOM_FETCH_ENABLED         "dom.fetch.enabled"
+#define PREF_DOM_CACHES_ENABLED        "dom.worker-caches.enabled"
 #define PREF_WORKERS_LATEST_JS_VERSION "dom.workers.latestJSVersion"
 
 namespace {
 
 const uint32_t kNoIndex = uint32_t(-1);
 
 const JS::ContextOptions kRequiredContextOptions =
   JS::ContextOptions().setDontReportUncaught(true);
@@ -1756,16 +1757,20 @@ RuntimeService::Init()
                                   WorkerPrefChanged,
                                   PREF_DOM_WINDOW_DUMP_ENABLED,
                                   reinterpret_cast<void *>(WORKERPREF_DUMP))) ||
 #endif
       NS_FAILED(Preferences::RegisterCallbackAndCall(
                                   WorkerPrefChanged,
                                   PREF_DOM_FETCH_ENABLED,
                                   reinterpret_cast<void *>(WORKERPREF_DOM_FETCH))) ||
+      NS_FAILED(Preferences::RegisterCallbackAndCall(
+                                  WorkerPrefChanged,
+                                  PREF_DOM_CACHES_ENABLED,
+                                  reinterpret_cast<void *>(WORKERPREF_DOM_CACHES))) ||
       NS_FAILED(Preferences::RegisterCallback(LoadRuntimeOptions,
                                               PREF_JS_OPTIONS_PREFIX,
                                               nullptr)) ||
       NS_FAILED(Preferences::RegisterCallbackAndCall(
                                                    LoadRuntimeOptions,
                                                    PREF_WORKERS_OPTIONS_PREFIX,
                                                    nullptr)) ||
       NS_FAILED(Preferences::RegisterCallbackAndCall(
@@ -1917,16 +1922,20 @@ RuntimeService::Cleanup()
         NS_FAILED(Preferences::UnregisterCallback(LoadRuntimeOptions,
                                                   PREF_JS_OPTIONS_PREFIX,
                                                   nullptr)) ||
         NS_FAILED(Preferences::UnregisterCallback(LoadRuntimeOptions,
                                                   PREF_WORKERS_OPTIONS_PREFIX,
                                                   nullptr)) ||
         NS_FAILED(Preferences::UnregisterCallback(
                                   WorkerPrefChanged,
+                                  PREF_DOM_CACHES_ENABLED,
+                                  reinterpret_cast<void *>(WORKERPREF_DOM_CACHES))) ||
+        NS_FAILED(Preferences::UnregisterCallback(
+                                  WorkerPrefChanged,
                                   PREF_DOM_FETCH_ENABLED,
                                   reinterpret_cast<void *>(WORKERPREF_DOM_FETCH))) ||
 #if DUMP_CONTROLLED_BY_PREF
         NS_FAILED(Preferences::UnregisterCallback(
                                   WorkerPrefChanged,
                                   PREF_DOM_WINDOW_DUMP_ENABLED,
                                   reinterpret_cast<void *>(WORKERPREF_DUMP))) ||
 #endif
@@ -2472,16 +2481,22 @@ RuntimeService::WorkerPrefChanged(const 
 #endif
 
   if (key == WORKERPREF_DOM_FETCH) {
     key = WORKERPREF_DOM_FETCH;
     sDefaultPreferences[WORKERPREF_DOM_FETCH] =
       Preferences::GetBool(PREF_DOM_FETCH_ENABLED, false);
   }
 
+  if (key == WORKERPREF_DOM_CACHES) {
+    key = WORKERPREF_DOM_CACHES;
+    sDefaultPreferences[WORKERPREF_DOM_CACHES] =
+      Preferences::GetBool(PREF_DOM_CACHES_ENABLED, false);
+  }
+
   // This function should never be registered as a callback for a preference it
   // does not handle.
   MOZ_ASSERT(key != WORKERPREF_COUNT);
 
   RuntimeService* rts = RuntimeService::GetService();
   if (rts) {
     rts->UpdateAllWorkerPreference(key, sDefaultPreferences[key]);
   }
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1038,16 +1038,23 @@ public:
   bool
   DOMFetchEnabled() const
   {
     AssertIsOnWorkerThread();
     return mPreferences[WORKERPREF_DOM_FETCH];
   }
 
   bool
+  DOMCachesEnabled() const
+  {
+    AssertIsOnWorkerThread();
+    return mPreferences[WORKERPREF_DOM_CACHES];
+  }
+
+  bool
   OnLine() const
   {
     AssertIsOnWorkerThread();
     return mOnLine;
   }
 
   void
   StopSyncLoop(nsIEventTarget* aSyncLoopTarget, bool aResult);
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -7,16 +7,17 @@
 #include "WorkerScope.h"
 
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/SharedWorkerGlobalScopeBinding.h"
+#include "mozilla/dom/CacheStorage.h"
 #include "mozilla/dom/Console.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #include "Location.h"
 #include "Navigator.h"
@@ -49,22 +50,24 @@ WorkerGlobalScope::~WorkerGlobalScope()
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerGlobalScope)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(WorkerGlobalScope,
                                                   DOMEventTargetHelper)
   tmp->mWorkerPrivate->AssertIsOnWorkerThread();
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mConsole)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCacheStorage)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(WorkerGlobalScope,
                                                 DOMEventTargetHelper)
   tmp->mWorkerPrivate->AssertIsOnWorkerThread();
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mConsole)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mCacheStorage)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(WorkerGlobalScope,
                                                DOMEventTargetHelper)
   tmp->mWorkerPrivate->AssertIsOnWorkerThread();
 
   tmp->mWorkerPrivate->TraceTimeouts(aCallbacks, aClosure);
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
@@ -89,16 +92,29 @@ WorkerGlobalScope::GetConsole()
 
   if (!mConsole) {
     mConsole = new Console(nullptr);
   }
 
   return mConsole;
 }
 
+already_AddRefed<CacheStorage>
+WorkerGlobalScope::Caches()
+{
+  if (!mCacheStorage) {
+    MOZ_ASSERT(mWorkerPrivate);
+    NS_ConvertUTF16toUTF8 origin(mWorkerPrivate->GetLocationInfo().mOrigin);
+    mCacheStorage = new CacheStorage(nullptr, origin);
+  }
+
+  nsRefPtr<CacheStorage> ref = mCacheStorage;
+  return ref.forget();
+}
+
 already_AddRefed<WorkerLocation>
 WorkerGlobalScope::Location()
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 
   if (!mLocation) {
     WorkerPrivate::LocationInfo& info = mWorkerPrivate->GetLocationInfo();
 
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -7,16 +7,17 @@
 #define mozilla_dom_workerscope_h__
 
 #include "Workers.h"
 #include "mozilla/DOMEventTargetHelper.h"
 
 namespace mozilla {
 namespace dom {
 
+class CacheStorage;
 class Console;
 class Function;
 
 } // namespace dom
 } // namespace mozilla
 
 BEGIN_WORKERS_NAMESPACE
 
@@ -25,16 +26,17 @@ class WorkerLocation;
 class WorkerNavigator;
 
 class WorkerGlobalScope : public DOMEventTargetHelper,
                           public nsIGlobalObject
 {
   nsRefPtr<Console> mConsole;
   nsRefPtr<WorkerLocation> mLocation;
   nsRefPtr<WorkerNavigator> mNavigator;
+  nsRefPtr<CacheStorage> mCacheStorage;
 
 protected:
   WorkerPrivate* mWorkerPrivate;
 
   WorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
   virtual ~WorkerGlobalScope();
 
 public:
@@ -110,16 +112,18 @@ public:
   Btoa(const nsAString& aBtoa, nsAString& aOutput, ErrorResult& aRv) const;
 
   IMPL_EVENT_HANDLER(online)
   IMPL_EVENT_HANDLER(offline)
   IMPL_EVENT_HANDLER(close)
 
   void
   Dump(const Optional<nsAString>& aString) const;
+
+  already_AddRefed<CacheStorage> Caches();
 };
 
 class DedicatedWorkerGlobalScope MOZ_FINAL : public WorkerGlobalScope
 {
   ~DedicatedWorkerGlobalScope() { }
 
 public:
   DedicatedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
@@ -154,17 +158,17 @@ public:
   }
 
   IMPL_EVENT_HANDLER(connect)
 };
 
 class ServiceWorkerGlobalScope MOZ_FINAL : public WorkerGlobalScope
 {
   const nsString mScope;
-  ~ServiceWorkerGlobalScope() { }
+  ~ServiceWorkerGlobalScope() { };
 
 public:
   ServiceWorkerGlobalScope(WorkerPrivate* aWorkerPrivate, const nsACString& aScope);
 
   virtual JSObject*
   WrapGlobalObject(JSContext* aCx) MOZ_OVERRIDE;
 
   void
diff --git a/dom/workers/Workers.h b/dom/workers/Workers.h
--- a/dom/workers/Workers.h
+++ b/dom/workers/Workers.h
@@ -159,18 +159,19 @@ struct JSSettings
     }
 
     return false;
   }
 };
 
 enum WorkerPreference
 {
-  WORKERPREF_DUMP = 0, // browser.dom.window.dump.enabled
-  WORKERPREF_DOM_FETCH,// dom.fetch.enabled
+  WORKERPREF_DUMP = 0,   // browser.dom.window.dump.enabled
+  WORKERPREF_DOM_FETCH,  // dom.fetch.enabled
+  WORKERPREF_DOM_CACHES, // dom.worker-caches.enabled
   WORKERPREF_COUNT
 };
 
 // All of these are implemented in RuntimeService.cpp
 
 // Resolves all of the worker classes onto |aObjp| if one of them matches |aId|
 // or if |aId| is JSID_VOID.
 bool
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -1,17 +1,22 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
+#include "mozilla/dom/PCacheStorageChild.h"
+#include "mozilla/dom/PCacheChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
+using mozilla::dom::PCacheStorageChild;
+using mozilla::dom::PCacheChild;
+
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
   nsCString mTestArg;
 
@@ -87,16 +92,44 @@ bool
 BackgroundChildImpl::DeallocPBackgroundTestChild(PBackgroundTestChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete static_cast<TestChild*>(aActor);
   return true;
 }
 
+PCacheStorageChild*
+BackgroundChildImpl::AllocPCacheStorageChild(const nsCString& aOrigin)
+{
+  MOZ_CRASH("not implemented");
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheStorageChild(PCacheStorageChild* aActor)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
+PCacheChild*
+BackgroundChildImpl::AllocPCacheChild()
+{
+  MOZ_CRASH("not implemented");
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -6,16 +6,20 @@
 #define mozilla_ipc_backgroundchildimpl_h__
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 
 template <class> class nsAutoPtr;
 
 namespace mozilla {
+namespace dom {
+  class PCacheStorageChild;
+  class PCacheChild;
+}
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundChildImpl : public PBackgroundChild
 {
 public:
   class ThreadLocal;
@@ -35,16 +39,28 @@ protected:
   virtual void
   ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
 
   virtual PBackgroundTestChild*
   AllocPBackgroundTestChild(const nsCString& aTestArg) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundTestChild(PBackgroundTestChild* aActor) MOZ_OVERRIDE;
+
+  virtual mozilla::dom::PCacheStorageChild*
+  AllocPCacheStorageChild(const nsCString& aOrigin) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStorageChild(mozilla::dom::PCacheStorageChild* aActor) MOZ_OVERRIDE;
+
+  virtual mozilla::dom::PCacheChild*
+  AllocPCacheChild() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheChild(mozilla::dom::PCacheChild* aActor) MOZ_OVERRIDE;
 };
 
 class BackgroundChildImpl::ThreadLocal
 {
   friend class nsAutoPtr<ThreadLocal>;
 
   // Add any members needed here.
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -2,21 +2,25 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundParentImpl.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
+#include "mozilla/dom/PCacheStorageParent.h"
+#include "mozilla/dom/PCacheParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
+using mozilla::dom::PCacheStorageParent;
+using mozilla::dom::PCacheParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -103,16 +107,59 @@ BackgroundParentImpl::DeallocPBackground
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
   delete static_cast<TestParent*>(aActor);
   return true;
 }
 
+PCacheStorageParent*
+BackgroundParentImpl::AllocPCacheStorageParent(const nsCString& aOrigin)
+{
+  MOZ_CRASH("not implemented");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::RecvPCacheStorageConstructor(PCacheStorageParent* aActor,
+                                                   const nsCString& aOrigin)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheStorageParent(PCacheStorageParent* aActor)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
+PCacheParent*
+BackgroundParentImpl::AllocPCacheParent()
+{
+  MOZ_CRASH("not implemented");
+  return nullptr;
+}
+
+bool
+BackgroundParentImpl::RecvPCacheConstructor(PCacheParent* aActor)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
+bool
+BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
+{
+  MOZ_CRASH("not implemented");
+  return false;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -4,16 +4,20 @@
 
 #ifndef mozilla_ipc_backgroundparentimpl_h__
 #define mozilla_ipc_backgroundparentimpl_h__
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
+namespace dom {
+  class PCacheStorageParent;
+  class PCacheParent;
+}
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundParentImpl : public PBackgroundParent
 {
 protected:
   BackgroundParentImpl();
@@ -26,14 +30,33 @@ protected:
   AllocPBackgroundTestParent(const nsCString& aTestArg) MOZ_OVERRIDE;
 
   virtual bool
   RecvPBackgroundTestConstructor(PBackgroundTestParent* aActor,
                                  const nsCString& aTestArg) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundTestParent(PBackgroundTestParent* aActor) MOZ_OVERRIDE;
+
+  virtual mozilla::dom::PCacheStorageParent*
+  AllocPCacheStorageParent(const nsCString& aOrigin) MOZ_OVERRIDE;
+
+  virtual bool
+  RecvPCacheStorageConstructor(mozilla::dom::PCacheStorageParent* aActor,
+                               const nsCString& aOrigin) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheStorageParent(mozilla::dom::PCacheStorageParent* aActor) MOZ_OVERRIDE;
+
+  virtual mozilla::dom::PCacheParent*
+  AllocPCacheParent() MOZ_OVERRIDE;
+
+  virtual bool
+  RecvPCacheConstructor(mozilla::dom::PCacheParent* aActor) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPCacheParent(mozilla::dom::PCacheParent* aActor) MOZ_OVERRIDE;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,20 +1,27 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundTest;
+include protocol PCacheStorage;
+include protocol PCache;
 
 namespace mozilla {
 namespace ipc {
 
 protocol PBackground
 {
   manages PBackgroundTest;
+  manages PCacheStorage;
+  manages PCache;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
+
+  PCacheStorage(nsCString origin);
+  PCache();
 };
 
 } // namespace ipc
 } // namespace mozilla
