# HG changeset patch
# Parent 5b979caa3461137a6561b9f75195da64f8596655
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -102,16 +102,18 @@ public:
     MOZ_ASSERT(mPromise);
   }
 
   virtual void
   ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override
   {
     NS_ASSERT_OWNINGTHREAD(FetchHandler);
 
+    printf_stderr("### ### [%p] FetchHandler::ResolvedCallback()\n", this);
+
     // Stop holding the worker alive when we leave this method.
     nsRefPtr<Feature> feature;
     feature.swap(mFeature);
 
     // Promise::All() passed an array of fetch() Promises should give us
     // an Array of Response objects.  The following code unwraps these
     // JS values back to an nsTArray<nsRefPtr<Response>>.
 
@@ -156,36 +158,42 @@ public:
       if (NS_WARN_IF(response->Type() == ResponseType::Error)) {
         Fail();
         return;
       }
 
       responseList.AppendElement(Move(response));
     }
 
+    printf_stderr("### ### [%p] FetchHandler::ResolvedCallback() got %lu responses\n",
+                  this, responseList.Length());
+
     MOZ_ASSERT(mRequestList.Length() == responseList.Length());
 
     // Now store the unwrapped Response list in the Cache.
     ErrorResult result;
     nsRefPtr<Promise> put = mCache->PutAll(mRequestList, responseList, result);
     if (NS_WARN_IF(result.Failed())) {
       // TODO: abort the fetch requests we have running (bug 1157434)
       mPromise->MaybeReject(result);
       return;
     }
 
+    printf_stderr("### ### [%p] FetchHandler::ResolvedCallback() started PutAll\n", this);
+
     // Chain the Cache::Put() promise to the original promise returned to
     // the content script.
     mPromise->MaybeResolve(put);
   }
 
   virtual void
   RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override
   {
     NS_ASSERT_OWNINGTHREAD(FetchHandler);
+    printf_stderr("### ### [%p] FetchHandler::RejectedCallback()\n", this);
     Fail();
   }
 
 private:
   ~FetchHandler()
   {
   }
 
@@ -281,16 +289,18 @@ Cache::MatchAll(const Optional<RequestOr
 
   return ExecuteOp(args, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Add(JSContext* aContext, const RequestOrUSVString& aRequest,
            ErrorResult& aRv)
 {
+  printf_stderr("### ### [%p] Cache::Add()\n", this);
+
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   if (!IsValidPutRequestMethod(aRequest, aRv)) {
     return nullptr;
   }
@@ -306,25 +316,30 @@ Cache::Add(JSContext* aContext, const Re
   }
 
   nsAutoString url;
   request->GetUrl(url);
   if (NS_WARN_IF(!IsValidPutRequestURL(url, aRv))) {
     return nullptr;
   }
 
+  printf_stderr("### ### [%p] Cache::Add() url:%s\n",
+                this, NS_ConvertUTF16toUTF8(url).get());
+
   requestList.AppendElement(Move(request));
   return AddAll(global, Move(requestList), aRv);
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(JSContext* aContext,
               const Sequence<OwningRequestOrUSVString>& aRequestList,
               ErrorResult& aRv)
 {
+  printf_stderr("### ### [%p] Cache::AddAll()\n", this);
+
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   GlobalObject global(aContext, mGlobal->GetGlobalJSObject());
   MOZ_ASSERT(!global.Failed());
 
@@ -351,16 +366,19 @@ Cache::AddAll(JSContext* aContext,
     }
 
     nsAutoString url;
     request->GetUrl(url);
     if (NS_WARN_IF(!IsValidPutRequestURL(url, aRv))) {
       return nullptr;
     }
 
+    printf_stderr("### ### [%p] Cache::AddAll() url:%s\n",
+                  this, NS_ConvertUTF16toUTF8(url).get());
+
     requestList.AppendElement(Move(request));
   }
 
   return AddAll(global, Move(requestList), aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Put(const RequestOrUSVString& aRequest, Response& aResponse,
@@ -558,16 +576,21 @@ Cache::AddAll(const GlobalObject& aGloba
   nsAutoTArray<nsRefPtr<Promise>, 256> fetchList;
   fetchList.SetCapacity(aRequestList.Length());
 
   // Begin fetching each request in parallel.  For now, if an error occurs just
   // abandon our previous fetch calls.  In theory we could cancel them in the
   // future once fetch supports it.
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
+    nsAutoString url;
+    aRequestList[i]->GetUrl(url);
+    printf_stderr("### ### [%p] Cache::AddAll() start fetch for url:%s\n",
+                  this, NS_ConvertUTF16toUTF8(url).get());
+
     RequestOrUSVString requestOrString;
     requestOrString.SetAsRequest() = aRequestList[i];
     nsRefPtr<Promise> fetch = FetchRequest(mGlobal, requestOrString,
                                            RequestInit(), aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
 
@@ -583,39 +606,48 @@ Cache::AddAll(const GlobalObject& aGloba
                                                     Move(aRequestList), promise);
 
   nsRefPtr<Promise> fetchPromise = Promise::All(aGlobal, fetchList, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
   fetchPromise->AppendNativeHandler(handler);
 
+  printf_stderr("### ### [%p] Cache::AddAll() fetch running with handler %p\n",
+                this, handler.get());
+
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::PutAll(const nsTArray<nsRefPtr<Request>>& aRequestList,
               const nsTArray<nsRefPtr<Response>>& aResponseList,
               ErrorResult& aRv)
 {
   MOZ_ASSERT(aRequestList.Length() == aResponseList.Length());
 
+  printf_stderr("### ### [%p] Cache::PutAll() with %lu entries\n",
+                this, aRequestList.Length());
+
   if (NS_WARN_IF(!mActor)) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   AutoChildOpArgs args(this, CachePutAllArgs());
 
   for (uint32_t i = 0; i < aRequestList.Length(); ++i) {
     nsRefPtr<InternalRequest> ir = aRequestList[i]->GetInternalRequest();
     args.Add(ir, ReadBody, TypeErrorOnInvalidScheme, *aResponseList[i], aRv);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
     }
   }
 
+  printf_stderr("### ### [%p] Cache::PutAll() executing Op for %lu entries\n",
+                this, aRequestList.Length());
+
   return ExecuteOp(args, aRv);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -115,16 +115,17 @@ CacheOpChild::Recv__delete__(const Error
     }
     case CacheOpResult::TCacheMatchAllResult:
     {
       HandleResponseList(aResult.get_CacheMatchAllResult().responseList());
       break;
     }
     case CacheOpResult::TCachePutAllResult:
     {
+      printf_stderr("### ### [%p] CacheOpChild::Recv__delete__() for put\n", this);
       mPromise->MaybeResolve(JS::UndefinedHandleValue);
       break;
     }
     case CacheOpResult::TCacheDeleteResult:
     {
       mPromise->MaybeResolve(aResult.get_CacheDeleteResult().success());
       break;
     }
diff --git a/dom/cache/CacheOpParent.cpp b/dom/cache/CacheOpParent.cpp
--- a/dom/cache/CacheOpParent.cpp
+++ b/dom/cache/CacheOpParent.cpp
@@ -74,16 +74,19 @@ CacheOpParent::Execute(Manager* aManager
 
   // Handle put op
   if (mOpArgs.type() == CacheOpArgs::TCachePutAllArgs) {
     MOZ_ASSERT(mCacheId != INVALID_CACHE_ID);
 
     const CachePutAllArgs& args = mOpArgs.get_CachePutAllArgs();
     const nsTArray<CacheRequestResponse>& list = args.requestResponseList();
 
+    printf_stderr("### ### [%p] CacheOpParent::Execute() put with %lu entries\n",
+                  this, list.Length());
+
     nsAutoTArray<nsCOMPtr<nsIInputStream>, 256> requestStreamList;
     nsAutoTArray<nsCOMPtr<nsIInputStream>, 256> responseStreamList;
 
     for (uint32_t i = 0; i < list.Length(); ++i) {
       requestStreamList.AppendElement(
         DeserializeCacheStream(list[i].request().body()));
       responseStreamList.AppendElement(
         DeserializeCacheStream(list[i].response().body()));
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -653,16 +653,19 @@ public:
     , mExpectedAsyncCopyCompletions(1)
     , mAsyncResult(NS_OK)
     , mMutex("cache::Manager::CachePutAllAction")
   {
     MOZ_ASSERT(!aPutList.IsEmpty());
     MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
     MOZ_ASSERT(aPutList.Length() == aResponseStreamList.Length());
 
+    printf_stderr("### ### [%p] CachePutAllAction() for %lu entries\n",
+                  this, aPutList.Length());
+
     for (uint32_t i = 0; i < aPutList.Length(); ++i) {
       Entry* entry = mList.AppendElement();
       entry->mRequest = aPutList[i].request();
       entry->mRequestStream = aRequestStreamList[i];
       entry->mResponse = aPutList[i].response();
       entry->mResponseStream = aResponseStreamList[i];
     }
   }
@@ -760,16 +763,19 @@ private:
 
     // Check to see if async copying is still on-going.  If so, then simply
     // return for now.  We must wait for a later OnAsyncCopyComplete() call.
     mExpectedAsyncCopyCompletions -= 1;
     if (mExpectedAsyncCopyCompletions > 0) {
       return;
     }
 
+    printf_stderr("### ### [%p] CachePutAllAction() copying complete for %lu entries\n",
+                  this, mList.Length());
+
     // We have finished with all async copying.  Indicate this by clearing all
     // our copy contexts.
     {
       MutexAutoLock lock(mMutex);
       mCopyContextList.Clear();
     }
 
     // An error occurred while async copying.  Terminate the Action.
@@ -817,16 +823,19 @@ private:
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
     NS_ASSERT_OWNINGTHREAD(Action);
 
+    printf_stderr("### ### [%p] CachePutAllAction() action complete for %lu entries\n",
+                  this, mList.Length());
+
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mList[i].mRequestStream = nullptr;
       mList[i].mResponseStream = nullptr;
     }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
@@ -835,16 +844,18 @@ private:
       listener->OnOpComplete(ErrorResult(aRv), CachePutAllResult());
     }
   }
 
   virtual void
   CancelOnInitiatingThread() override
   {
     NS_ASSERT_OWNINGTHREAD(Action);
+    printf_stderr("### ### [%p] CachePutAllAction() canceled with %lu entries\n",
+                  this, mList.Length());
     Action::CancelOnInitiatingThread();
     CancelAllStreamCopying();
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const override
   {
     NS_ASSERT_OWNINGTHREAD(Action);
     return aCacheId == mCacheId;
