# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b3d0b3e32c6c6859d6e31bbe18811da5df167470

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2881,16 +2881,20 @@ bool
 ServiceWorkerRegistrationInfo::CheckAndClearIfUpdateNeeded()
 {
   AssertIsOnMainThread();
 
   bool result = mUpdateState == NeedUpdate ||
                (mUpdateState == NeedTimeCheckAndUpdate &&
                 IsLastUpdateCheckTimeOverOneDay());
 
+  printf_stderr("### ### CheckAndClearIfUpdateNeeded() state:%u overOneDay:%s scope:%s\n",
+                mUpdateState, (IsLastUpdateCheckTimeOverOneDay() ? "true" : "false"),
+                mScope.get());
+
   mUpdateState = NoUpdate;
 
   return result;
 }
 
 void
 ServiceWorkerManager::LoadRegistration(
                              const ServiceWorkerRegistrationData& aRegistration)
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/update-after-oneday.https.html b/testing/web-platform/mozilla/tests/service-workers/service-worker/update-after-oneday.https.html
--- a/testing/web-platform/mozilla/tests/service-workers/service-worker/update-after-oneday.https.html
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/update-after-oneday.https.html
@@ -18,33 +18,41 @@ promise_test(function(t) {
     return service_worker_unregister_and_register(t, expected_url, scope)
       .then(function(r) {
           registration = r;
           return wait_for_state(t, registration.installing, 'activated');
         })
       .then(function() { return with_iframe(scope); })
       .then(function(f) {
           frame = f;
+          dump('### ### wait for navigation update\n');
           return wait_for_update(t, registration);
         })
       .then(function() {
+          dump('### ### got navigation update\n');
           assert_equals(registration.installing.scriptURL, expected_url,
                         'new installing should be set after update resolves.');
           assert_equals(registration.waiting, null,
                         'waiting should still be null after update resolves.');
           assert_equals(registration.active.scriptURL, expected_url,
                         'active should still exist after update found.');
+          dump('### ### wait for worker to be installed\n');
           return wait_for_state(t, registration.installing, 'installed');
         })
       .then(function() {
+          dump('### ### worker installed\n');
           // Trigger a non-navigation fetch event
+          dump('### ### load image\n');
           frame.contentWindow.load_image(normalizeURL('resources/update/dummy'));
+          dump('### ### wait for update\n');
           return wait_for_update(t, registration);
        })
        .then(function() {
+          dump('### ### got update\n');
           frame.remove();
+          dump('### ### unregister and done\n');
           return service_worker_unregister_and_done(t, scope);
        })
   }, 'Update should be triggered after a functional event when last update time is over 24 hours');
 
 </script>
 
 
