# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  82800e7bec3ac0534ac5664e7d378f316d35edce

diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -3162,16 +3162,17 @@ ServiceWorkerManager::UpdateTimerFired(n
   }
 
   if (!registration->CheckAndClearIfUpdateNeeded()) {
     return;
   }
 
   OriginAttributes attrs = aPrincipal->OriginAttributesRef();
 
+  printf_stderr("### ### ServiceWorkerManager::%s calling SoftUpdate\n", __func__);
   SoftUpdate(attrs, aScope);
 }
 
 void
 ServiceWorkerManager::MaybeSendUnregister(nsIPrincipal* aPrincipal,
                                           const nsACString& aScope)
 {
   MOZ_ASSERT(NS_IsMainThread());
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -215,16 +215,22 @@ ServiceWorkerRegistration::UpdateState(c
 
   Maybe<ServiceWorkerDescriptor> installing = aDescriptor.GetInstalling();
   if (installing.isSome()) {
     mInstallingWorker = global->GetOrCreateServiceWorker(installing.ref());
     mInstallingWorker->SetState(installing.ref().State());
   } else {
     mInstallingWorker = nullptr;
   }
+  printf_stderr("### ### [%p] ServiceWorkerRegistration::%s installing: %p -> %p\n",
+                this, __func__, oldInstalling.get(), mInstallingWorker.get());
+  printf_stderr("### ### [%p] ServiceWorkerRegistration::%s waiting: %p -> %p\n",
+                this, __func__, oldWaiting.get(), mWaitingWorker.get());
+  printf_stderr("### ### [%p] ServiceWorkerRegistration::%s active: %p -> %p\n",
+                this, __func__, oldActive.get(), mActiveWorker.get());
 }
 
 bool
 ServiceWorkerRegistration::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) const
 {
   return aDescriptor.Id() == mDescriptor.Id() &&
          aDescriptor.PrincipalInfo() == mDescriptor.PrincipalInfo() &&
          aDescriptor.Scope() == mDescriptor.Scope();
@@ -264,25 +270,19 @@ ServiceWorkerRegistration::Update(ErrorR
   RefPtr<ServiceWorkerRegistration> self = this;
   RefPtr<DOMMozPromiseRequestHolder<ServiceWorkerRegistrationPromise>> holder =
     new DOMMozPromiseRequestHolder<ServiceWorkerRegistrationPromise>(global);
 
   mInner->Update()->Then(
     global->EventTargetFor(TaskCategory::Other), __func__,
     [outer, self, holder](const ServiceWorkerRegistrationDescriptor& aDesc) {
       holder->Complete();
-      nsIGlobalObject* global = self->GetParentObject();
-      MOZ_DIAGNOSTIC_ASSERT(global);
-      RefPtr<ServiceWorkerRegistration> ref =
-        global->GetOrCreateServiceWorkerRegistration(aDesc);
-      if (!ref) {
-        outer->MaybeReject(NS_ERROR_DOM_INVALID_STATE_ERR);
-        return;
-      }
-      outer->MaybeResolve(ref);
+      printf_stderr("### ### [%p] ServiceWorkerRegistration::Update() resolved\n", self.get());
+      MOZ_DIAGNOSTIC_ASSERT(self->MatchesDescriptor(aDesc));
+      outer->MaybeResolve(self);
     }, [outer, holder] (const CopyableErrorResult& aRv) {
       holder->Complete();
       outer->MaybeReject(CopyableErrorResult(aRv));
     })->Track(*holder);
 
   return outer.forget();
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -626,29 +626,31 @@ ServiceWorkerRegistrationInfo::ClearInst
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionEvaluatingToInstalling()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mEvaluatingWorker);
   MOZ_ASSERT(!mInstallingWorker);
+  printf_stderr("### ### [%p] ServiceWorkerRegistrationInfo::%s\n", this, __func__);
 
   mInstallingWorker = mEvaluatingWorker.forget();
   mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
 
   UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionInstallingToWaiting()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mInstallingWorker);
+  printf_stderr("### ### [%p] ServiceWorkerRegistrationInfo::%s\n", this, __func__);
 
   if (mWaitingWorker) {
     MOZ_ASSERT(mInstallingWorker->CacheName() != mWaitingWorker->CacheName());
     mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
     mWaitingWorker->UpdateRedundantTime();
   }
 
   mWaitingWorker = mInstallingWorker.forget();
@@ -694,16 +696,17 @@ ServiceWorkerRegistrationInfo::SetActive
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionWaitingToActive()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mWaitingWorker);
+  printf_stderr("### ### [%p] ServiceWorkerRegistrationInfo::%s\n", this, __func__);
 
   if (mActiveWorker) {
     MOZ_ASSERT(mWaitingWorker->CacheName() != mActiveWorker->CacheName());
     mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
     mActiveWorker->UpdateRedundantTime();
   }
 
   // We are transitioning from waiting to active normally, so go to
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp b/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationParent.cpp
@@ -64,16 +64,17 @@ ServiceWorkerRegistrationParent::RecvUpd
 {
   if (!mProxy) {
     aResolver(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
     return IPC_OK();
   }
 
   mProxy->Update()->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [aResolver] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+      printf_stderr("### ### ServiceWorkerRegistrationParent::RecvUpdate() resolve descriptor\n");
       aResolver(aDescriptor.ToIPC());
     }, [aResolver] (const CopyableErrorResult& aResult) {
       aResolver(aResult);
     });
 
   return IPC_OK();
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp b/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationProxy.cpp
@@ -336,16 +336,17 @@ ServiceWorkerRegistrationProxy::Update()
         promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
       });
 
       NS_ENSURE_TRUE_VOID(self->mReg);
 
       RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
       NS_ENSURE_TRUE_VOID(swm);
 
+      printf_stderr("### ### ServiceWorkerRegistrationproxy::Update() calling SWM update\n");
       RefPtr<UpdateCallback> cb = new UpdateCallback(Move(promise));
       swm->Update(self->mReg->Principal(), self->mReg->Scope(), cb);
 
       scopeExit.release();
     });
 
   MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
 
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -531,16 +531,17 @@ ServiceWorkerUpdateJob::Install()
   MOZ_DIAGNOSTIC_ASSERT(!Canceled());
 
   MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin step 2 of the Install algorithm.
   //
   //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
 
+  printf_stderr("### ### [%p] ServiceWorkerUpdateJob::%s calling TransitionEvaluatingToInstalling\n", this, __func__);
   mRegistration->TransitionEvaluatingToInstalling();
 
   // Step 6 of the Install algorithm resolving the job promise.
   InvokeResultCallbacks(NS_OK);
 
   // The job promise cannot be rejected after this point, but the job can
   // still fail; e.g. if the install event handler throws, etc.
 
diff --git a/testing/web-platform/tests/service-workers/service-worker/activation.https.html b/testing/web-platform/tests/service-workers/service-worker/activation.https.html
--- a/testing/web-platform/tests/service-workers/service-worker/activation.https.html
+++ b/testing/web-platform/tests/service-workers/service-worker/activation.https.html
@@ -41,16 +41,17 @@ function setup_activation_test(t, scope,
         // Create an in-flight request.
         registration.active.postMessage('wait');
         // Now there is both a controllee and an in-flight request.
         // Initiate an update.
         return registration.update();
       })
     .then(() => {
         // Wait for a waiting worker.
+        dump('### ### setup - calling wait_for_state() on ' + registration.installing + '\n');
         return wait_for_state(t, registration.installing, 'installed');
       })
     .then(() => {
         return wait_for_activation_on_dummy_scope(t, self);
       })
     .then(() => {
         assert_not_equals(registration.waiting, null);
         assert_not_equals(registration.active, null);
@@ -71,24 +72,26 @@ promise_test(t => {
           registration.active.postMessage('go');
           return wait_for_activation_on_dummy_scope(t, self);
         })
       .then(() => {
           // The new worker is still waiting. Remove the frame and it should
           // activate.
           new_worker = registration.waiting;
           assert_equals(new_worker.state, 'installed');
+          dump('### ### calling wait_for_state() on ' + new_worker + '\n');
           var reached_active = wait_for_state(t, new_worker, 'activating');
           iframe.remove();
           return reached_active;
         })
       .then(() => {
           assert_equals(new_worker, registration.active);
         });
   }, 'loss of controllees triggers activation');
+/*
 promise_test(t => {
     var scope = 'resources/no-request';
     var worker_url = 'resources/mint-new-worker.py';
     var registration;
     var iframe;
     var new_worker;
     return setup_activation_test(t, scope, worker_url)
       .then(result => {
@@ -154,10 +157,11 @@ promise_test(t => {
           return reached_redundant;
         })
       .then(() => {
           assert_equals(registration.installing, null);
           assert_equals(registration.waiting, null);
           assert_equals(registration.active, null);
         });
   }, 'finishing a request triggers unregister');
+  */
 </script>
 </body>
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/test-helpers.sub.js b/testing/web-platform/tests/service-workers/service-worker/resources/test-helpers.sub.js
--- a/testing/web-platform/tests/service-workers/service-worker/resources/test-helpers.sub.js
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/test-helpers.sub.js
@@ -263,11 +263,12 @@ function with_sandboxed_iframe(url, sand
 // This can be used to wait for a period of time needed to register,
 // activate, and then unregister a service worker.  When checking that
 // certain behavior does *NOT* happen, this is preferable to using an
 // arbitrary delay.
 async function wait_for_activation_on_dummy_scope(t, window_or_workerglobalscope) {
   const script = '/service-workers/service-worker/resources/empty-worker.js';
   const scope = 'resources/there/is/no/there/there?' + Date.now();
   let registration = await window_or_workerglobalscope.navigator.serviceWorker.register(script, { scope });
+  dump('### ### dummy - calling wait_for_state() on ' + registration.installing + '\n');
   await wait_for_state(t, registration.installing, 'activated');
   await registration.unregister();
 }
