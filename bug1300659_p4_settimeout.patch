# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c4005ac6aa0a8b431da486c05b273a48d9381803
Bug 1300659 P4 Make setTimeout() and setInterval() use the MainThreadTaskQueue. r=bz

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -77,16 +77,17 @@
 #include "mozilla/MouseEvents.h"
 #include "mozilla/ProcessHangMonitor.h"
 #include "AudioChannelService.h"
 #include "nsAboutProtocolUtils.h"
 #include "nsCharTraits.h" // NS_IS_HIGH/LOW_SURROGATE
 #include "PostMessageEvent.h"
 
 // Interfaces Needed
+#include "nsIEventTarget.h"
 #include "nsIFrame.h"
 #include "nsCanvasFrame.h"
 #include "nsIWidget.h"
 #include "nsIWidgetListener.h"
 #include "nsIBaseWindow.h"
 #include "nsIDeviceSensors.h"
 #include "nsIContent.h"
 #include "nsIDocShell.h"
@@ -548,16 +549,25 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTimeout, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTimeout, Release)
 
 nsresult
 nsTimeout::InitTimer(uint32_t aDelay)
 {
+  // Attempt to throttle timers through if a task queue is present.  If
+  // our target is nullptr then the current thread will be used.  We do
+  // this every time in order to stop using the TaskQueue if its shutdown.
+  nsCOMPtr<nsIEventTarget> target;
+  if (mWindow) {
+    target = mWindow->GetMainThreadTaskQueue();
+  }
+  Unused << mTimer->SetTarget(target);
+
   return mTimer->InitWithNameableFuncCallback(
     nsGlobalWindow::TimerCallback, this, aDelay,
     nsITimer::TYPE_ONE_SHOT, nsGlobalWindow::TimerNameCallback);
 }
 
 // Return true if this timeout has a refcount of 1. This is used to check
 // that dummy_timeout doesn't leak from nsGlobalWindow::RunTimeout.
 bool
@@ -12559,16 +12569,19 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
   for (nsTimeout *timeout = mTimeouts.getFirst();
        timeout && timeout->mWhen <= deadline;
        timeout = timeout->getNext()) {
     if (timeout->mFiringDepth == 0) {
       // Mark any timeouts that are on the list to be fired with the
       // firing depth so that we can reentrantly run timeouts
       timeout->mFiringDepth = firingDepth;
       last_expired_timeout = timeout;
+
+      // Only run a single timer in order to avoid janking the main thread.
+      break;
     }
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_timeout) {
     return;
