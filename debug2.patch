# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ede77de397404ab1654c7c1d177a6e9deb9d2bde

diff --git a/devtools/client/shared/source-map/index.js b/devtools/client/shared/source-map/index.js
--- a/devtools/client/shared/source-map/index.js
+++ b/devtools/client/shared/source-map/index.js
@@ -563,27 +563,30 @@ return /******/ (function(modules) { // 
 	  this.msgId = 1;
 	  this.worker = null;
 	} /* This Source Code Form is subject to the terms of the Mozilla Public
 	   * License, v. 2.0. If a copy of the MPL was not distributed with this
 	   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 	WorkerDispatcher.prototype = {
 	  start(url) {
+            dump('### ### start source map worker\n');
 	    this.worker = new Worker(url);
 	    this.worker.onerror = () => {
 	      console.error(`Error in worker ${url}`);
 	    };
 	  },
 
 	  stop() {
 	    if (!this.worker) {
 	      return;
 	    }
 
+            dump('### ### stop source map worker\n');
+
 	    this.worker.terminate();
 	    this.worker = null;
 	  },
 
 	  task(method) {
 	    return (...args) => {
 	      return new Promise((resolve, reject) => {
 	        const id = this.msgId++;
@@ -623,9 +626,9 @@ return /******/ (function(modules) { // 
 	module.exports = {
 	  WorkerDispatcher,
 	  workerHandler
 	};
 
 /***/ }
 /******/ ])
 });
-;
\ No newline at end of file
+;
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -363,16 +363,18 @@ public:
   NS_IMETHOD
   Run() override
   {
     if (mLoadGroupToCancel) {
       mLoadGroupToCancel->Cancel(NS_BINDING_ABORTED);
       mLoadGroupToCancel = nullptr;
     }
 
+    printf_stderr("### ### worker proxy releasing objects on main thread\n");
+
     mDoomed.Clear();
     return NS_OK;
   }
 
 private:
   ~MainThreadReleaseRunnable()
   { }
 };
@@ -2029,17 +2031,17 @@ WorkerLoadInfo::ProxyReleaseMainThreadOb
   nsCOMPtr<nsILoadGroup> nullLoadGroup;
   return ProxyReleaseMainThreadObjects(aWorkerPrivate, nullLoadGroup);
 }
 
 bool
 WorkerLoadInfo::ProxyReleaseMainThreadObjects(WorkerPrivate* aWorkerPrivate,
                                               nsCOMPtr<nsILoadGroup>& aLoadGroupToCancel)
 {
-
+  printf_stderr("### ### ProxyReleaseMainThreadObjects for %p\n", aWorkerPrivate);
   static const uint32_t kDoomedCount = 10;
   nsTArray<nsCOMPtr<nsISupports>> doomed(kDoomedCount);
 
   SwapToISupportsArray(mWindow, doomed);
   SwapToISupportsArray(mScriptContext, doomed);
   SwapToISupportsArray(mBaseURI, doomed);
   SwapToISupportsArray(mResolvedScriptURI, doomed);
   SwapToISupportsArray(mPrincipal, doomed);
@@ -4443,16 +4445,17 @@ WorkerPrivate::WorkerPrivate(WorkerPriva
   , mPendingEventQueueClearing(false)
   , mCancelAllPendingRunnables(false)
   , mPeriodicGCTimerRunning(false)
   , mIdleGCTimerRunning(false)
   , mWorkerScriptExecutedSuccessfully(false)
   , mFetchHandlerWasAdded(false)
   , mOnLine(false)
 {
+  printf_stderr("### ### [%p] WorkerPrivate()\n", this);
   if (aParent) {
     aParent->AssertIsOnWorkerThread();
     aParent->GetAllPreferences(mPreferences);
     mOnLine = aParent->OnLine();
   }
   else {
     AssertIsOnMainThread();
     RuntimeService::GetDefaultPreferences(mPreferences);
@@ -4492,16 +4495,17 @@ WorkerPrivate::WorkerPrivate(WorkerPriva
     mMainThreadEventTarget = mMainThreadThrottledEventQueue;
   } else {
     mMainThreadEventTarget = target.forget();
   }
 }
 
 WorkerPrivate::~WorkerPrivate()
 {
+  printf_stderr("### ### [%p] ~WorkerPrivate()\n", this);
   mWorkerControlEventTarget->ForgetWorkerPrivate(this);
 }
 
 // static
 already_AddRefed<WorkerPrivate>
 WorkerPrivate::Constructor(const GlobalObject& aGlobal,
                            const nsAString& aScriptURL,
                            const WorkerOptions& aOptions,
