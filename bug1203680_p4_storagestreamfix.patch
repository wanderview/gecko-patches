# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  576cf6c79db6a04bcda2c6c7a1489ca63039dc02
Bug 1203680 P4 Fix bug in nsStorageStream with reading streams created before data is populated. r=froydnj

diff --git a/xpcom/io/nsSegmentedBuffer.h b/xpcom/io/nsSegmentedBuffer.h
--- a/xpcom/io/nsSegmentedBuffer.h
+++ b/xpcom/io/nsSegmentedBuffer.h
@@ -63,16 +63,19 @@ public:
   }
   inline uint32_t GetSize()
   {
     return GetSegmentCount() * mSegmentSize;
   }
 
   inline char* GetSegment(uint32_t aIndex)
   {
+    if (aIndex >= GetSegmentCount()) {
+      printf_stderr("### ### index:%u segment count:%u\n", aIndex, GetSegmentCount());
+    }
     NS_ASSERTION(aIndex < GetSegmentCount(), "index out of bounds");
     int32_t i = ModSegArraySize(mFirstSegmentIndex + (int32_t)aIndex);
     return mSegmentArray[i];
   }
 
 protected:
   inline int32_t ModSegArraySize(int32_t aIndex)
   {
diff --git a/xpcom/io/nsStorageStream.cpp b/xpcom/io/nsStorageStream.cpp
--- a/xpcom/io/nsStorageStream.cpp
+++ b/xpcom/io/nsStorageStream.cpp
@@ -455,17 +455,24 @@ nsStorageInputStream::ReadSegments(nsWri
   while (remainingCapacity) {
     availableInSegment = mSegmentEnd - mReadCursor;
     if (!availableInSegment) {
       uint32_t available = mStorageStream->mLogicalLength - mLogicalCursor;
       if (!available) {
         goto out;
       }
 
-      mSegmentNum++;
+      // If mSegmentEnd is 0 and yet there is still data available in the
+      // stream, that means this is the first read for stream that was
+      // constructed before data was appended to the stream.  Skip moving
+      // to the next segment so we can initialize our state and perform
+      // the initial read.
+      if (mSegmentEnd > 0) {
+        mSegmentNum++;
+      }
       mReadCursor = 0;
       mSegmentEnd = XPCOM_MIN(mSegmentSize, available);
       availableInSegment = mSegmentEnd;
     }
     const char* cur = mStorageStream->mSegmentedBuffer->GetSegment(mSegmentNum);
 
     count = XPCOM_MIN(availableInSegment, remainingCapacity);
     rv = aWriter(this, aClosure, cur + mReadCursor, aCount - remainingCapacity,
diff --git a/xpcom/tests/gtest/TestStorageStream.cpp b/xpcom/tests/gtest/TestStorageStream.cpp
--- a/xpcom/tests/gtest/TestStorageStream.cpp
+++ b/xpcom/tests/gtest/TestStorageStream.cpp
@@ -9,27 +9,29 @@
 #include "Helpers.h"
 #include "nsCOMPtr.h"
 #include "nsICloneableInputStream.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsIStorageStream.h"
 
 namespace {
+
 void
 WriteData(nsIOutputStream* aOut, nsTArray<char>& aData, uint32_t aNumBytes,
           nsACString& aDataWritten)
 {
   uint32_t n;
   nsresult rv = aOut->Write(aData.Elements(), aNumBytes, &n);
   EXPECT_TRUE(NS_SUCCEEDED(rv));
   aDataWritten.Append(aData.Elements(), aNumBytes);
 }
 
 } // namespace
+
 TEST(StorageStreams, Main)
 {
   // generate some test data we will write in 4k chunks to the stream
   nsTArray<char> kData;
   testing::CreateData(4096, kData);
 
   // track how much data was written so we can compare at the end
   nsAutoCString dataWritten;
@@ -84,8 +86,45 @@ TEST(StorageStreams, Main)
 
   // now, read all
   rv = stor->NewInputStream(0, getter_AddRefs(in));
   EXPECT_TRUE(NS_SUCCEEDED(rv));
 
   testing::ConsumeAndValidateStream(in, dataWritten);
   in = nullptr;
 }
+
+TEST(StorageStreams, EarlyInputStream)
+{
+  // generate some test data we will write in 4k chunks to the stream
+  nsTArray<char> kData;
+  testing::CreateData(4096, kData);
+
+  // track how much data was written so we can compare at the end
+  nsAutoCString dataWritten;
+
+  nsresult rv;
+  nsCOMPtr<nsIStorageStream> stor;
+
+  rv = NS_NewStorageStream(kData.Length(), UINT32_MAX, getter_AddRefs(stor));
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+
+  // Get input stream before writing data into the output stream
+  nsCOMPtr<nsIInputStream> in;
+  rv = stor->NewInputStream(0, getter_AddRefs(in));
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+
+  // Write data to output stream
+  nsCOMPtr<nsIOutputStream> out;
+  rv = stor->GetOutputStream(0, getter_AddRefs(out));
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+
+  WriteData(out, kData, kData.Length(), dataWritten);
+  WriteData(out, kData, kData.Length(), dataWritten);
+
+  rv = out->Close();
+  EXPECT_TRUE(NS_SUCCEEDED(rv));
+  out = nullptr;
+
+  // Should be able to consume input stream
+  testing::ConsumeAndValidateStream(in, dataWritten);
+  in = nullptr;
+}
