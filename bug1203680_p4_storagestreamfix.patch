# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  576cf6c79db6a04bcda2c6c7a1489ca63039dc02
Bug 1203680 P4 Fix bug in nsStorageStream with reading streams created before data is populated. r=froydnj

diff --git a/xpcom/io/nsSegmentedBuffer.h b/xpcom/io/nsSegmentedBuffer.h
--- a/xpcom/io/nsSegmentedBuffer.h
+++ b/xpcom/io/nsSegmentedBuffer.h
@@ -63,16 +63,19 @@ public:
   }
   inline uint32_t GetSize()
   {
     return GetSegmentCount() * mSegmentSize;
   }
 
   inline char* GetSegment(uint32_t aIndex)
   {
+    if (aIndex >= GetSegmentCount()) {
+      printf_stderr("### ### index:%u segment count:%u\n", aIndex, GetSegmentCount());
+    }
     NS_ASSERTION(aIndex < GetSegmentCount(), "index out of bounds");
     int32_t i = ModSegArraySize(mFirstSegmentIndex + (int32_t)aIndex);
     return mSegmentArray[i];
   }
 
 protected:
   inline int32_t ModSegArraySize(int32_t aIndex)
   {
diff --git a/xpcom/io/nsStorageStream.cpp b/xpcom/io/nsStorageStream.cpp
--- a/xpcom/io/nsStorageStream.cpp
+++ b/xpcom/io/nsStorageStream.cpp
@@ -455,17 +455,24 @@ nsStorageInputStream::ReadSegments(nsWri
   while (remainingCapacity) {
     availableInSegment = mSegmentEnd - mReadCursor;
     if (!availableInSegment) {
       uint32_t available = mStorageStream->mLogicalLength - mLogicalCursor;
       if (!available) {
         goto out;
       }
 
-      mSegmentNum++;
+      // If mSegmentEnd is 0 and yet there is still data available in the
+      // stream, that means this is the first read for stream that was
+      // constructed before data was appended to the stream.  Skip moving
+      // to the next segment so we can initialize our state and perform
+      // the initial read.
+      if (mSegmentEnd > 0) {
+        mSegmentNum++;
+      }
       mReadCursor = 0;
       mSegmentEnd = XPCOM_MIN(mSegmentSize, available);
       availableInSegment = mSegmentEnd;
     }
     const char* cur = mStorageStream->mSegmentedBuffer->GetSegment(mSegmentNum);
 
     count = XPCOM_MIN(availableInSegment, remainingCapacity);
     rv = aWriter(this, aClosure, cur + mReadCursor, aCount - remainingCapacity,
