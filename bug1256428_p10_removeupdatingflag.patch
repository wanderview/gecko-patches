# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  cda564aa4b32a132b058e90d9c3a1d036205e09f
Bug 1256428 P10 Remove ServiceWorkerRegistrationInfo::mUpdating flag. r=jdm

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -259,17 +259,16 @@ ServiceWorkerRegistrationInfo::Clear()
 
 ServiceWorkerRegistrationInfo::ServiceWorkerRegistrationInfo(const nsACString& aScope,
                                                              nsIPrincipal* aPrincipal)
   : mControlledDocumentsCounter(0)
   , mUpdateState(NoUpdate)
   , mLastUpdateCheckTime(0)
   , mScope(aScope)
   , mPrincipal(aPrincipal)
-  , mUpdating(false)
   , mPendingUninstall(false)
 {}
 
 ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
 {
   if (IsControllingDocuments()) {
     NS_WARNING("ServiceWorkerRegistrationInfo is still controlling documents. This can be a bug or a leak in ServiceWorker API or in any other API that takes the document alive.");
   }
@@ -2879,25 +2878,23 @@ ServiceWorkerManager::SoftUpdate(const P
   if (!newest) {
     return;
   }
 
   // "If the registration queue for registration is empty, invoke Update algorithm,
   // or its equivalent, with client, registration as its argument."
   // TODO(catalinb): We don't implement the force bypass cache flag.
   // See: https://github.com/slightlyoff/ServiceWorker/issues/759
-  if (!registration->mUpdating) {
-    RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey,
-                                                               aScope);
-
-    RefPtr<ServiceWorkerUpdateJob2> job =
-      new ServiceWorkerUpdateJob2(principal, registration->mScope,
-                                  newest->ScriptSpec(), nullptr);
-    queue->ScheduleJob(job);
-  }
+  RefPtr<ServiceWorkerJobQueue2> queue = GetOrCreateJobQueue(scopeKey,
+                                                             aScope);
+
+  RefPtr<ServiceWorkerUpdateJob2> job =
+    new ServiceWorkerUpdateJob2(principal, registration->mScope,
+                                newest->ScriptSpec(), nullptr);
+  queue->ScheduleJob(job);
 }
 
 namespace {
 
 class UpdateJobCallback final : public ServiceWorkerJob2::Callback
 {
   RefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
 
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -76,22 +76,16 @@ public:
   nsCOMPtr<nsIPrincipal> mPrincipal;
 
   RefPtr<ServiceWorkerInfo> mActiveWorker;
   RefPtr<ServiceWorkerInfo> mWaitingWorker;
   RefPtr<ServiceWorkerInfo> mInstallingWorker;
 
   nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
 
-  // According to the spec, Soft Update shouldn't queue an update job
-  // if the registration queue is not empty. Because our job queue
-  // works slightly different, we use a flag to determine if the registration
-  // is already updating.
-  bool mUpdating;
-
   // When unregister() is called on a registration, it is not immediately
   // removed since documents may be controlled. It is marked as
   // pendingUninstall and when all controlling documents go away, removed.
   bool mPendingUninstall;
 
   ServiceWorkerRegistrationInfo(const nsACString& aScope,
                                 nsIPrincipal* aPrincipal);
 
diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
--- a/dom/workers/ServiceWorkerUpdateJob.cpp
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -224,19 +224,16 @@ ServiceWorkerUpdateJob2::SetRegistration
 void
 ServiceWorkerUpdateJob2::Update()
 {
   AssertIsOnMainThread();
 
   // SetRegistration() must be called before Update().
   MOZ_ASSERT(mRegistration);
 
-  // TODO: I think we can remove mUpdating from registration now
-  mRegistration->mUpdating = true;
-
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   MOZ_ASSERT(!mRegistration->mInstallingWorker);
 
   RefPtr<ServiceWorkerInfo> workerInfo = mRegistration->Newest();
@@ -359,19 +356,16 @@ ServiceWorkerUpdateJob2::ComparisonResul
   }
 }
 
 void
 ServiceWorkerUpdateJob2::ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult)
 {
   AssertIsOnMainThread();
 
-  // TODO: I think we can remove this now
-  mRegistration->mUpdating = false;
-
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   if (NS_WARN_IF(!aScriptEvaluationResult)) {
     ErrorResult error;
 
