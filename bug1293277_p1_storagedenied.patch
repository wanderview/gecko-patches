# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f027d51c1dd9f9e7edede78eeb2a680e1be9bad0
Bug 1293277 P1 Capture StorageAccess when snapshoting ClientSource state. r=baku

diff --git a/dom/base/nsContentUtils.h b/dom/base/nsContentUtils.h
--- a/dom/base/nsContentUtils.h
+++ b/dom/base/nsContentUtils.h
@@ -2952,16 +2952,18 @@ public:
     eDeny = 0,
     // Allow access to the storage, but only if it is secure to do so in a
     // private browsing context.
     ePrivateBrowsing = 1,
     // Allow access to the storage, but only persist it for the current session
     eSessionScoped = 2,
     // Allow access to the storage
     eAllow = 3,
+    // Keep this at the end.  Used for serialization, but not a valid value.
+    eNumValues = 4,
   };
 
   /*
    * Checks if storage for the given window is permitted by a combination of
    * the user's preferences, and whether the window is a third-party iframe.
    *
    * This logic is intended to be shared between the different forms of
    * persistent storage which are available to web pages. Cookies don't use
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -5,16 +5,17 @@
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include IPCServiceWorkerDescriptor;
 include ProtocolTypes;
 using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
+using nsContentUtils::StorageAccess from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 struct ClientSourceConstructorArgs
 {
   nsID id;
@@ -32,21 +33,23 @@ struct IPCClientInfo
   nsCString url;
   FrameType frameType;
 };
 
 struct IPCClientWindowState
 {
   VisibilityState visibilityState;
   TimeStamp lastFocusTime;
+  StorageAccess storageAccess;
   bool focused;
 };
 
 struct IPCClientWorkerState
 {
+  StorageAccess storageAccess;
 };
 
 union IPCClientState
 {
   IPCClientWindowState;
   IPCClientWorkerState;
 };
 
diff --git a/dom/clients/manager/ClientIPCUtils.h b/dom/clients/manager/ClientIPCUtils.h
--- a/dom/clients/manager/ClientIPCUtils.h
+++ b/dom/clients/manager/ClientIPCUtils.h
@@ -9,16 +9,17 @@
 #include "ipc/IPCMessageUtils.h"
 
 // Fix X11 header brain damage that conflicts with FrameType::None
 #undef None
 
 #include "mozilla/dom/ClientBinding.h"
 #include "mozilla/dom/ClientsBinding.h"
 #include "mozilla/dom/DocumentBinding.h"
+#include "nsContentUtils.h"
 
 namespace IPC {
   template<>
   struct ParamTraits<mozilla::dom::ClientType> :
     public ContiguousEnumSerializer<mozilla::dom::ClientType,
                                     mozilla::dom::ClientType::Window,
                                     mozilla::dom::ClientType::EndGuard_>
   {};
@@ -31,11 +32,18 @@ namespace IPC {
   {};
 
   template<>
   struct ParamTraits<mozilla::dom::VisibilityState> :
     public ContiguousEnumSerializer<mozilla::dom::VisibilityState,
                                     mozilla::dom::VisibilityState::Hidden,
                                     mozilla::dom::VisibilityState::EndGuard_>
   {};
+
+  template<>
+  struct ParamTraits<nsContentUtils::StorageAccess> :
+    public ContiguousEnumSerializer<nsContentUtils::StorageAccess,
+                                    nsContentUtils::StorageAccess::eDeny,
+                                    nsContentUtils::StorageAccess::eNumValues>
+  {};
 } // namespace IPC
 
 #endif // _mozilla_dom_ClientIPCUtils_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -73,34 +73,40 @@ nsresult
 ClientSource::SnapshotWindowState(ClientState* aStateOut)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsPIDOMWindowInner* window = GetInnerWindow();
   if (!window || !window->IsCurrentInnerWindow() ||
       !window->HasActiveDocument()) {
     *aStateOut = ClientState(ClientWindowState(VisibilityState::Hidden,
-                                               TimeStamp(), false));
+                                               TimeStamp(),
+                                               nsContentUtils::StorageAccess::eDeny,
+                                               false));
     return NS_OK;
   }
 
   nsIDocument* doc = window->GetExtantDoc();
   if (NS_WARN_IF(!doc)) {
     return NS_ERROR_UNEXPECTED;
   }
 
   ErrorResult rv;
   bool focused = doc->HasFocus(rv);
   if (NS_WARN_IF(rv.Failed())) {
     rv.SuppressException();
     return rv.StealNSResult();
   }
 
+  nsContentUtils::StorageAccess storage =
+    nsContentUtils::StorageAllowedForDocument(doc);
+
   *aStateOut = ClientState(ClientWindowState(doc->VisibilityState(),
-                                             doc->LastFocusTime(), focused));
+                                             doc->LastFocusTime(), storage,
+                                             focused));
 
   return NS_OK;
 }
 
 WorkerPrivate*
 ClientSource::GetWorkerPrivate() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
@@ -584,17 +590,28 @@ ClientSource::SnapshotState(ClientState*
     MaybeCreateInitialDocument();
     nsresult rv = SnapshotWindowState(aStateOut);
     if (NS_FAILED(rv)) {
       return rv;
     }
     return NS_OK;
   }
 
-  *aStateOut = ClientState(ClientWorkerState());
+  WorkerPrivate* workerPrivate = GetWorkerPrivate();
+  if (!workerPrivate) {
+    return NS_ERROR_DOM_INVALID_STATE_ERR;
+  }
+
+  // Workers only keep a boolean for storage access at the moment.
+  // Map this back to eAllow or eDeny for now.
+  nsContentUtils::StorageAccess storage =
+    workerPrivate->IsStorageAllowed() ? nsContentUtils::StorageAccess::eAllow
+                                      : nsContentUtils::StorageAccess::eDeny;
+
+  *aStateOut = ClientState(ClientWorkerState(storage));
   return NS_OK;
 }
 
 nsISerialEventTarget*
 ClientSource::EventTarget() const
 {
   return mEventTarget;
 }
diff --git a/dom/clients/manager/ClientState.cpp b/dom/clients/manager/ClientState.cpp
--- a/dom/clients/manager/ClientState.cpp
+++ b/dom/clients/manager/ClientState.cpp
@@ -8,19 +8,20 @@
 
 #include "mozilla/dom/ClientIPCTypes.h"
 
 namespace mozilla {
 namespace dom {
 
 ClientWindowState::ClientWindowState(mozilla::dom::VisibilityState aVisibilityState,
                                      const TimeStamp& aLastFocusTime,
+                                     nsContentUtils::StorageAccess aStorageAccess,
                                      bool aFocused)
   : mData(MakeUnique<IPCClientWindowState>(aVisibilityState, aLastFocusTime,
-                                           aFocused))
+                                           aStorageAccess, aFocused))
 {
 }
 
 ClientWindowState::ClientWindowState(const IPCClientWindowState& aData)
   : mData(MakeUnique<IPCClientWindowState>(aData))
 {
 }
 
@@ -67,24 +68,30 @@ ClientWindowState::LastFocusTime() const
 }
 
 bool
 ClientWindowState::Focused() const
 {
   return mData->focused();
 }
 
+nsContentUtils::StorageAccess
+ClientWindowState::GetStorageAccess() const
+{
+  return mData->storageAccess();
+}
+
 const IPCClientWindowState&
 ClientWindowState::ToIPC() const
 {
   return *mData;
 }
 
-ClientWorkerState::ClientWorkerState()
-  : mData(MakeUnique<IPCClientWorkerState>())
+ClientWorkerState::ClientWorkerState(nsContentUtils::StorageAccess aStorageAccess)
+  : mData(MakeUnique<IPCClientWorkerState>(aStorageAccess))
 {
 }
 
 ClientWorkerState::ClientWorkerState(const IPCClientWorkerState& aData)
   : mData(MakeUnique<IPCClientWorkerState>(aData))
 {
 }
 
@@ -113,16 +120,22 @@ ClientWorkerState::operator=(ClientWorke
   mData = Move(aRight.mData);
   return *this;
 }
 
 ClientWorkerState::~ClientWorkerState()
 {
 }
 
+nsContentUtils::StorageAccess
+ClientWorkerState::GetStorageAccess() const
+{
+  return mData->storageAccess();
+}
+
 const IPCClientWorkerState&
 ClientWorkerState::ToIPC() const
 {
   return *mData;
 }
 
 ClientState::ClientState()
 {
@@ -197,16 +210,26 @@ ClientState::IsWorkerState() const
 }
 
 const ClientWorkerState&
 ClientState::AsWorkerState() const
 {
   return mData.ref().as<ClientWorkerState>();
 }
 
+nsContentUtils::StorageAccess
+ClientState::GetStorageAccess() const
+{
+  if (IsWindowState()) {
+    return AsWindowState().GetStorageAccess();
+  }
+
+  return AsWorkerState().GetStorageAccess();
+}
+
 const IPCClientState
 ClientState::ToIPC() const
 {
   if (IsWindowState()) {
     return IPCClientState(AsWindowState().ToIPC());
   }
 
   return IPCClientState(AsWorkerState().ToIPC());
diff --git a/dom/clients/manager/ClientState.h b/dom/clients/manager/ClientState.h
--- a/dom/clients/manager/ClientState.h
+++ b/dom/clients/manager/ClientState.h
@@ -6,16 +6,17 @@
 
 #ifndef _mozilla_dom_ClientState_h
 #define _mozilla_dom_ClientState_h
 
 #include "mozilla/dom/DocumentBinding.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/TimeStamp.h"
 #include "mozilla/UniquePtr.h"
+#include "nsContentUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 class IPCClientState;
 class IPCClientWindowState;
 class IPCClientWorkerState;
 
@@ -24,16 +25,17 @@ class IPCClientWorkerState;
 // is not live updated.
 class ClientWindowState final
 {
   UniquePtr<IPCClientWindowState> mData;
 
 public:
   ClientWindowState(mozilla::dom::VisibilityState aVisibilityState,
                     const TimeStamp& aLastFocusTime,
+                    nsContentUtils::StorageAccess aStorageAccess,
                     bool aFocused);
 
   explicit ClientWindowState(const IPCClientWindowState& aData);
 
   ClientWindowState(const ClientWindowState& aRight);
   ClientWindowState(ClientWindowState&& aRight);
 
   ClientWindowState&
@@ -48,46 +50,52 @@ public:
   VisibilityState() const;
 
   const TimeStamp&
   LastFocusTime() const;
 
   bool
   Focused() const;
 
+  nsContentUtils::StorageAccess
+  GetStorageAccess() const;
+
   const IPCClientWindowState&
   ToIPC() const;
 };
 
 // This class defines the mutable worker state we support querying
 // through the ClientManagerService.  It is a snapshot of the state and
 // is not live updated.  Right now, we don't actually providate any
 // worker specific state values, but we may in the future.  This
 // class also services as a placeholder that the state is referring
 // to a worker in ClientState.
 class ClientWorkerState final
 {
   UniquePtr<IPCClientWorkerState> mData;
 
 public:
-  ClientWorkerState();
+  explicit ClientWorkerState(nsContentUtils::StorageAccess aStorageAccess);
 
   explicit ClientWorkerState(const IPCClientWorkerState& aData);
 
   ClientWorkerState(const ClientWorkerState& aRight);
   ClientWorkerState(ClientWorkerState&& aRight);
 
   ClientWorkerState&
   operator=(const ClientWorkerState& aRight);
 
   ClientWorkerState&
   operator=(ClientWorkerState&& aRight);
 
   ~ClientWorkerState();
 
+  nsContentUtils::StorageAccess
+  GetStorageAccess() const;
+
   const IPCClientWorkerState&
   ToIPC() const;
 };
 
 // This is a union of the various types of mutable state we support
 // querying in ClientManagerService.  Right now it can contain either
 // window or worker states.
 class ClientState final
@@ -123,16 +131,19 @@ public:
   AsWindowState() const;
 
   bool
   IsWorkerState() const;
 
   const ClientWorkerState&
   AsWorkerState() const;
 
+  nsContentUtils::StorageAccess
+  GetStorageAccess() const;
+
   const IPCClientState
   ToIPC() const;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientState_h
