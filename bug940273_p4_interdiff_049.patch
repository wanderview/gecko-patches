# HG changeset patch
# Parent b64ee53cfb806f548b89a0875bb59e7c8d6a852e
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 049 rewrite Action cancelation


diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
--- a/dom/cache/Action.cpp
+++ b/dom/cache/Action.cpp
@@ -7,11 +7,36 @@
 #include "mozilla/dom/cache/Action.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action::Resolver);
 
+void
+Action::CancelOnInitiatingThread()
+{
+  MutexAutoLock lock(mMutex);
+  MOZ_ASSERT(!mCanceled);
+  mCanceled = true;
+}
+
+Action::Action()
+  : mMutex("dom-cache-action-mutex")
+  , mCanceled(false)
+{
+}
+
+Action::~Action()
+{
+}
+
+bool
+Action::IsCanceled()
+{
+  MutexAutoLock lock(mMutex);
+  return mCanceled;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
--- a/dom/cache/Action.h
+++ b/dom/cache/Action.h
@@ -2,29 +2,26 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Action_h
 #define mozilla_dom_cache_Action_h
 
+#include "mozilla/Mutex.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Action
 {
-protected:
-  // virtual because deleted through base class pointer
-  virtual ~Action() { }
-
 public:
   class Resolver : public nsISupports
   {
   protected:
     // virtual because deleted through base class pointer
     virtual ~Resolver() { }
 
   public:
@@ -40,30 +37,57 @@ public:
 
   // Execute operations on the target thread.  Once complete call
   // Resolver::Resolve().  This can be done sync or async.
   // Note: Action should hold Resolver ref until its ready to call Resolve().
   // Note: The "target" thread is determined when the Action is scheduled on
   //       Context.  The Action should not assume any particular thread is used.
   virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) = 0;
 
-  // Called on target thread if the Action is being canceled.  Simply
-  // clean up and do not call Resolver::Resolve() in this case.
-  // Note: Action must drop Resolver ref if CancelOnTarget() is called!
-  virtual void CancelOnTarget() = 0;
+  // Called on initiating thread when the Action is canceled.  The Action is
+  // responsible for calling Resolver::Resolve() as normal; either with a
+  // normal error code or NS_ERROR_ABORT.  If CancelOnInitiatingThread() is
+  // called after Resolve() has already occurred, then the cancel can be
+  // ignored.
+  //
+  // Cancelation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the Action will not run.
+  //
+  // Default implementation sets an internal cancelation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
 
   // Executed on the initiating thread and is passed the nsresult given to
   // Resolver::Resolve().
   virtual void CompleteOnInitiatingThread(nsresult aRv) { }
 
   // Executed on the initiating thread.  If this Action will operate on the
   // given cache ID then override this to return true.
   virtual bool MatchesCacheId(CacheId aCacheId) const { return false; }
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Action)
   NS_DECL_OWNINGTHREAD
+
+protected:
+  Action();
+
+  // virtual because deleted through base class pointer
+  virtual ~Action();
+
+  // Check if this Action has been canceled.  May be called from any thread,
+  // but typically used from the target thread.
+  bool IsCanceled();
+
+  // Expose the mutex protecting our cancelation state.  Any overrides of
+  // CancelOnInitiatingThread will likely need to use this as well.  This
+  // is better than creating yet another mutex.
+  Mutex mMutex;
+
+private:
+  // Must hold mMutex lock to access.
+  bool mCanceled;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -326,37 +326,30 @@ public:
   ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
                  const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
-    , mCanceled(false)
     , mResult(NS_OK)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     MOZ_ASSERT(mQuotaInfo.mDir);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mState == STATE_INIT);
 
-    if (mCanceled) {
-      mState = STATE_COMPLETE;
-      Clear();
-      return NS_OK;
-    }
-
     mState = STATE_RUN_ON_TARGET;
     nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
@@ -364,38 +357,17 @@ public:
   bool MatchesCacheId(CacheId aCacheId) {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     return mAction->MatchesCacheId(aCacheId);
   }
 
   void Cancel()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
-    mCanceled = true;
-    mResult = NS_ERROR_FAILURE;
-    nsresult rv;
-    switch(mState) {
-      case STATE_RUNNING:
-        // Re-dispatch if we are currently running
-        rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
-        if (NS_WARN_IF(NS_FAILED(rv))) {
-          // Shutdown must be delayed until all Contexts are destroyed.  Crash
-          // for this invariant violation.
-          MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
-        }
-        break;
-      case STATE_INIT:
-      case STATE_RUN_ON_TARGET:
-      case STATE_COMPLETING:
-      case STATE_COMPLETE:
-        break;
-      default:
-        MOZ_CRASH("unexpected state");
-        break;
-    }
+    mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
   {
     MOZ_ASSERT(mState == STATE_RUNNING);
     mResult = aRv;
     mState = STATE_COMPLETING;
     nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
@@ -434,17 +406,16 @@ private:
   };
 
   nsRefPtr<Context> mContext;
   nsCOMPtr<nsIEventTarget> mTarget;
   nsRefPtr<Action> mAction;
   const QuotaInfo mQuotaInfo;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
-  bool mCanceled;
   nsresult mResult;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
@@ -483,54 +454,25 @@ NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom
 // Cancel() simply sets a flag to be processed in the normal state machine.
 // In the case of an async Running state, however, it must reschedule the
 // ActionRunnable to execute again.  The flag then causes
 // Action::CancelOnTarget() to be executed which should halt any Action
 // processing.
 NS_IMETHODIMP
 Context::ActionRunnable::Run()
 {
-  nsresult rv;
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      if (mCanceled) {
-        mState = STATE_COMPLETING;
-        rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-        if (NS_FAILED(rv)) {
-          // Shutdown must be delayed until all Contexts are destroyed.  Crash
-          // for this invariant violation.
-          MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
-        }
-        break;
-      }
       mState = STATE_RUNNING;
       mAction->RunOnTarget(this, mQuotaInfo);
       break;
     }
-    // ----------------
-    case STATE_RUNNING:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      // We only re-enter the RUNNING state if we are canceling.  Normally we
-      // should transition out of RUNNING via Resolve() instead.
-      MOZ_ASSERT(mCanceled);
-      mState = STATE_COMPLETING;
-      mAction->CancelOnTarget();
-      mResult = NS_FAILED(mResult) ? mResult : NS_ERROR_FAILURE;
-      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-      if (NS_FAILED(rv)) {
-        // Shutdown must be delayed until all Contexts are destroyed.  Crash
-        // for this invariant violation.
-        MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
-      }
-      break;
-    }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
@@ -539,17 +481,16 @@ Context::ActionRunnable::Run()
     }
     // -----------------
     case STATE_COMPLETE:
     {
       // We can end up running in the complete state if we cancel on the
       // original thread while simultaneously starting to run the action on the
       // target thread.
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
-      MOZ_ASSERT(mCanceled);
       break;
     }
     // -----
     default:
     {
       MOZ_CRASH("unexpected state in ActionRunnable");
       break;
     }
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -33,16 +33,21 @@ DBAction::~DBAction()
 
 void
 DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aResolver);
   MOZ_ASSERT(aQuotaInfo.mDir);
 
+  if (IsCanceled()) {
+    aResolver->Resolve(NS_ERROR_ABORT);
+    return;
+  }
+
   nsCOMPtr<nsIFile> dbDir;
   nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
 
   rv = dbDir->Append(NS_LITERAL_STRING("cache"));
@@ -154,17 +159,11 @@ SyncDBAction::RunWithDBOnTarget(Resolver
   MOZ_ASSERT(aResolver);
   MOZ_ASSERT(aDBDir);
   MOZ_ASSERT(aConn);
 
   nsresult rv = RunSyncWithDBOnTarget(aQuotaInfo, aDBDir, aConn);
   aResolver->Resolve(rv);
 }
 
-void
-SyncDBAction::CancelOnTarget()
-{
-  // This action runs synchronously.  Nothing to cancel here.
-}
-
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -17,34 +17,37 @@ class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class DBAction : public Action
 {
 protected:
+  // The mode specifies whether the database should already exist or if its
+  // ok to create a new database.
   enum Mode
   {
     Existing,
     Create
   };
 
   explicit DBAction(Mode aMode);
 
   // Action objects are deleted through their base pointer
   virtual ~DBAction();
 
-  // Just as the resolver must be ref'd until cancel or resolve, you may also
+  // Just as the resolver must be ref'd until resolve, you may also
   // ref the DB connection.  The connection can only be referenced from the
-  // target thread and must be released upon cancel or resolve.
+  // target thread and must be released upon resolve.
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) = 0;
 
+private:
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE;
 
   nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
                           mozIStorageConnection** aConnOut);
 
   const Mode mMode;
 };
@@ -56,20 +59,19 @@ protected:
 
   // Action objects are deleted through their base pointer
   virtual ~SyncDBAction();
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) = 0;
 
+private:
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE;
-
-  virtual void CancelOnTarget() MOZ_OVERRIDE;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -139,31 +139,26 @@ FileUtils::BodyStartWriteStream(const Qu
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 void
-FileUtils::BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
-                           nsISupports* aCopyContext)
+FileUtils::BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aCopyContext);
 
   nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
   unused << NS_WARN_IF(NS_FAILED(rv));
 
-  nsCOMPtr<nsIFile> tmpFile;
-  rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-
-  rv = tmpFile->Remove(false /* recursive */);
-  unused << NS_WARN_IF(NS_FAILED(rv));
+  // The partially written file must be cleaned up after the async copy
+  // makes its callback.
 }
 
 // static
 nsresult
 FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
 {
   MOZ_ASSERT(aBaseDir);
 
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -35,18 +35,17 @@ public:
 
   static nsresult
   BodyStartWriteStream(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
                        nsIInputStream* aSource, void* aClosure,
                        nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
                        nsISupports** aCopyContextOut);
 
   static void
-  BodyCancelWrite(nsIFile* aBaseDir, const nsID& aId,
-                  nsISupports* aCopyContext);
+  BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext);
 
   static nsresult
   BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
 
   static nsresult
   BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
            nsIInputStream** aStreamOut);
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -91,16 +91,22 @@ public:
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
     MOZ_ASSERT(aQuotaInfo.mDir);
 
+    if (IsCanceled()) {
+      // TODO: handle orphaned files (bug 1110446)
+      aResolver->Resolve(NS_ERROR_ABORT);
+      return;
+    }
+
     nsCOMPtr<nsIFile> dbDir;
     nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
     rv = dbDir->Append(NS_LITERAL_STRING("cache"));
@@ -110,19 +116,16 @@ public:
     }
 
     rv = FileUtils::BodyDeleteFiles(dbDir, mDeletedBodyIdList);
     unused << NS_WARN_IF(NS_FAILED(rv));
 
     aResolver->Resolve(rv);
   }
 
-  // We run synchronously, so there is nothing to do when canceled.
-  virtual void CancelOnTarget() { }
-
 private:
   nsTArray<nsID> mDeletedBodyIdList;
 };
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
@@ -599,126 +602,150 @@ private:
 
 // ----------------------------------------------------------------------------
 
 // This is the most complex Action.  It puts a request/response pair into the
 // Cache.  It does not complete until all of the body data has been saved to
 // disk.  This means its an asynchronous Action.
 class Manager::CachePutAllAction MOZ_FINAL : public DBAction
 {
+private:
+  struct Entry
+  {
+    PCacheRequest mRequest;
+    nsCOMPtr<nsIInputStream> mRequestStream;
+    nsID mRequestBodyId;
+    nsCOMPtr<nsISupports> mRequestCopyContext;
+
+    PCacheResponse mResponse;
+    nsCOMPtr<nsIInputStream> mResponseStream;
+    nsID mResponseBodyId;
+    nsCOMPtr<nsISupports> mResponseCopyContext;
+  };
+
 public:
   CachePutAllAction(Manager* aManager, ListenerId aListenerId,
                     RequestId aRequestId, CacheId aCacheId,
                     const nsTArray<CacheRequestResponse>& aPutList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
     : DBAction(DBAction::Existing)
     , mManager(aManager)
     , mListenerId(aListenerId)
     , mRequestId(aRequestId)
     , mCacheId(aCacheId)
     , mList(aPutList.Length())
     , mExpectedAsyncCopyCompletions(0)
+    , mResult(NS_OK)
   {
     MOZ_ASSERT(aPutList.Length() == aRequestStreamList.Length());
     MOZ_ASSERT(aPutList.Length() == aResponseStreamList.Length());
 
     for (uint32_t i = 0; i < aPutList.Length(); ++i) {
       Entry* entry = mList.AppendElement();
       entry->mRequest = aPutList[i].request();
       entry->mRequestStream = aRequestStreamList[i];
       entry->mResponse = aPutList[i].response();
       entry->mResponseStream = aResponseStreamList[i];
-
-      mExpectedAsyncCopyCompletions += entry->mRequestStream ? 1 : 0;
-      mExpectedAsyncCopyCompletions += entry->mResponseStream ? 1 : 0;
     }
   }
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aResolver);
     MOZ_ASSERT(aDBDir);
     MOZ_ASSERT(aConn);
     MOZ_ASSERT(!mResolver);
     MOZ_ASSERT(!mDBDir);
     MOZ_ASSERT(!mConn);
 
+    mTargetThread = NS_GetCurrentThread();
+    MOZ_ASSERT(mTargetThread);
+
     mResolver = aResolver;
     mDBDir = aDBDir;
     mConn = aConn;
 
-    if (mExpectedAsyncCopyCompletions < 1) {
-      mExpectedAsyncCopyCompletions = 1;
-      OnAsyncCopyComplete(NS_OK);
-      return;
+    nsresult rv = NS_OK;
+    for (uint32_t i = 0; i < mList.Length(); ++i) {
+      rv = StartStreamCopy(aQuotaInfo, mList[i], RequestStream,
+                           &mExpectedAsyncCopyCompletions);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        break;
+      }
+
+      rv = StartStreamCopy(aQuotaInfo, mList[i], ResponseStream,
+                           &mExpectedAsyncCopyCompletions);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        break;
+      }
     }
 
-    nsresult rv = NS_OK;
-    for (uint32_t i = 0; i < mList.Length(); ++i) {
-      rv = StartStreamCopy(aQuotaInfo, mList[i].mRequestStream,
-                           &mList[i].mRequestBodyId,
-                           getter_AddRefs(mList[i].mRequestCopyContext));
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        CancelAllStreamCopying();
-        DoResolve(rv);
-        return;
-      }
+    // If we were canceled in the middle of starting out stream copiers, then
+    // some may already be canceled.  Streams could have been created after
+    // the cancel, though.  Simulate an error to cancel them now.
+    if (IsCanceled()) {
+      rv = NS_ERROR_ABORT;
+    }
 
-      rv = StartStreamCopy(aQuotaInfo, mList[i].mResponseStream,
-                           &mList[i].mResponseBodyId,
-                           getter_AddRefs(mList[i].mResponseCopyContext));
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        CancelAllStreamCopying();
-        DoResolve(rv);
-        return;
-      }
+    // If we failed, we have potentially a partial number of expected
+    // streams in flight.  We must cancel these.
+    if (NS_FAILED(rv)) {
+      CancelAllStreamCopying();
+    }
+
+    // No matter what, we need to exit through the OnAsyncCopyCompletion path.
+    // If we're not actually waiting for any copies, simulate a single
+    // completion.
+    if (mExpectedAsyncCopyCompletions == 0) {
+      mExpectedAsyncCopyCompletions = 1;
+      OnAsyncCopyComplete(rv);
     }
   }
 
   void
   OnAsyncCopyComplete(nsresult aRv)
   {
+    MOZ_ASSERT(mTargetThread == NS_GetCurrentThread());
     MOZ_ASSERT(mConn);
     MOZ_ASSERT(mResolver);
     MOZ_ASSERT(mExpectedAsyncCopyCompletions > 0);
 
-    // When DoResolve() is called below the "this" object can get destructed
-    // out from under us on the initiating thread.  Ensure that we cleanly
-    // run to completion in this scope before destruction.
-    nsRefPtr<Action> kungFuDeathGrip = this;
-
-    if (NS_FAILED(aRv)) {
-      DoResolve(aRv);
-      return;
+    // If any of the async copies fail, we need to still wait for them
+    // all to complete.  Just remember our negative status for now.
+    if (NS_FAILED(aRv) && NS_SUCCEEDED(mResult)) {
+      mResult = aRv;
     }
 
     mExpectedAsyncCopyCompletions -= 1;
     if (mExpectedAsyncCopyCompletions > 0) {
       return;
     }
 
+    if (NS_FAILED(mResult)) {
+      DoResolve(mResult);
+      return;
+    }
+
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = NS_OK;
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       Entry& e = mList[i];
       if (e.mRequestStream) {
-        e.mRequestCopyContext = nullptr;
         rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mRequestBodyId);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           DoResolve(rv);
           return;
         }
       }
       if (e.mResponseStream) {
-        e.mResponseCopyContext = nullptr;
         rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mResponseBodyId);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           DoResolve(rv);
           return;
         }
       }
 
       rv = DBSchema::CachePut(mConn, mCacheId, e.mRequest,
@@ -753,127 +780,130 @@ public:
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (listener) {
       listener->OnCachePutAll(mRequestId, aRv);
     }
   }
 
   virtual void
-  CancelOnTarget() MOZ_OVERRIDE
+  CancelOnInitiatingThread() MOZ_OVERRIDE
   {
     CancelAllStreamCopying();
-    mConn = nullptr;
-    mResolver = nullptr;
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
   {
     return aCacheId == mCacheId;
   }
 
 private:
+  enum StreamId
+  {
+    RequestStream,
+    ResponseStream
+  };
+
   nsresult
-  StartStreamCopy(const QuotaInfo& aQuotaInfo, nsIInputStream* aSource,
-                  nsID* aIdOut, nsISupports** aCopyContextOut)
+  StartStreamCopy(const QuotaInfo& aQuotaInfo, Entry& aEntry,
+                  StreamId aStreamId, uint32_t* aCopyCountOut)
   {
-    MOZ_ASSERT(aIdOut);
-    MOZ_ASSERT(aCopyContextOut);
-    MOZ_ASSERT(mDBDir);
+    MOZ_ASSERT(mTargetThread == NS_GetCurrentThread());
+    MOZ_ASSERT(aCopyCountOut);
 
-    if (!aSource) {
+    nsCOMPtr<nsIInputStream> source;
+    nsID* bodyId;
+
+    if (aStreamId == RequestStream) {
+      source = aEntry.mRequestStream;
+      bodyId = &aEntry.mRequestBodyId;
+    } else {
+      MOZ_ASSERT(aStreamId == ResponseStream);
+      source = aEntry.mResponseStream;
+      bodyId = &aEntry.mResponseBodyId;
+    }
+
+    if (!source) {
       return NS_OK;
     }
 
-    nsresult rv = FileUtils::BodyStartWriteStream(aQuotaInfo, mDBDir, aSource,
+    nsCOMPtr<nsISupports> copyContext;
+
+    nsresult rv = FileUtils::BodyStartWriteStream(aQuotaInfo, mDBDir, source,
                                                   this, AsyncCopyCompleteFunc,
-                                                  aIdOut, aCopyContextOut);
+                                                  bodyId,
+                                                  getter_AddRefs(copyContext));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+    if (copyContext) {
+      MutexAutoLock lock(Action::mMutex);
+      mCopyContextList.AppendElement(copyContext);
+    }
+
+    *aCopyCountOut += 1;
+
     return rv;
   }
 
   void
   CancelAllStreamCopying()
   {
-    for (uint32_t i = 0; i < mList.Length(); ++i) {
-      Entry& e = mList[i];
-      if (e.mRequestStream && e.mRequestCopyContext) {
-        CancelStreamCopy(e.mRequestStream, e.mRequestCopyContext,
-                         e.mRequestBodyId);
-        e.mRequestCopyContext = nullptr;
-      }
-      if (e.mResponseStream && e.mResponseCopyContext) {
-        CancelStreamCopy(e.mResponseStream, e.mResponseCopyContext,
-                         e.mResponseBodyId);
-        e.mResponseCopyContext = nullptr;
-      }
+    MutexAutoLock lock(Action::mMutex);
+
+    for (uint32_t i = 0; i < mCopyContextList.Length(); ++i) {
+      FileUtils::BodyCancelWrite(mDBDir, mCopyContextList[i]);
     }
-  }
-
-  void
-  CancelStreamCopy(nsIInputStream* aSource, nsISupports* aCopyContext,
-                   const nsID& aId)
-  {
-    if (!aSource || !aCopyContext) {
-      return;
-    }
-    FileUtils::BodyCancelWrite(mDBDir, aId, aCopyContext);
+    mCopyContextList.Clear();
   }
 
   static void
   AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
   {
     MOZ_ASSERT(aClosure);
-    CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
+    // TODO: bounce from STS thread back to target thread
+    nsRefPtr<CachePutAllAction> action = static_cast<CachePutAllAction*>(aClosure);
     action->OnAsyncCopyComplete(aRv);
   }
 
   void
   DoResolve(nsresult aRv)
   {
+    MOZ_ASSERT(mTargetThread == NS_GetCurrentThread());
+
+#ifdef DEBUG
+    {
+      MutexAutoLock lock(Action::mMutex);
+      MOZ_ASSERT(mCopyContextList.IsEmpty());
+    }
+#endif
+
     if (NS_FAILED(aRv)) {
-      CancelAllStreamCopying();
+      // TODO: remove all temp and final files
     }
 
     mConn = nullptr;
 
-    nsRefPtr<Resolver> resolver;
-    mResolver.swap(resolver);
-
-    if (resolver) {
-      // This can trigger self destruction if a self-ref is not held by the
-      // caller.
-      resolver->Resolve(aRv);
-    }
+    mResolver->Resolve(aRv);
   }
 
-  struct Entry
-  {
-    PCacheRequest mRequest;
-    nsCOMPtr<nsIInputStream> mRequestStream;
-    nsID mRequestBodyId;
-    nsCOMPtr<nsISupports> mRequestCopyContext;
-
-    PCacheResponse mResponse;
-    nsCOMPtr<nsIInputStream> mResponseStream;
-    nsID mResponseBodyId;
-    nsCOMPtr<nsISupports> mResponseCopyContext;
-  };
-
   nsRefPtr<Manager> mManager;
   const ListenerId mListenerId;
   const RequestId mRequestId;
   const CacheId mCacheId;
   nsTArray<Entry> mList;
   nsRefPtr<Resolver> mResolver;
   nsCOMPtr<nsIFile> mDBDir;
   nsCOMPtr<mozIStorageConnection> mConn;
+  nsCOMPtr<nsIThread> mTargetThread;
   uint32_t mExpectedAsyncCopyCompletions;
   nsTArray<nsID> mDeletedBodyIdList;
+  nsresult mResult;
+
+  // protected by Action::mMutex
+  nsTArray<nsCOMPtr<nsISupports>> mCopyContextList;
 };
 
 // ----------------------------------------------------------------------------
 
 class Manager::CacheDeleteAction MOZ_FINAL : public Manager::BaseAction
 {
 public:
   CacheDeleteAction(Manager* aManager, ListenerId aListenerId,
