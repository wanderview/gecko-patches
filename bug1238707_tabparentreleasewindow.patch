
# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Date 1459804097 25200
# Node ID 2fb6ece8eee9848605172e5dc658f24b0cd54e42
# Parent  9bd90088875399347b05d87c67d3709e31539dcd
Bug 1238707 Release the window immediately in TabParent::Destroy() to avoid leaks. r=smaug

diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -5423,17 +5423,17 @@ ContentParent::RecvCreateWindow(PBrowser
                                            aPositionSpecified, aSizeSpecified);
 
   MOZ_ASSERT(openLocation == nsIBrowserDOMWindow::OPEN_NEWTAB ||
              openLocation == nsIBrowserDOMWindow::OPEN_NEWWINDOW);
 
   // Opening new tabs is the easy case...
   if (openLocation == nsIBrowserDOMWindow::OPEN_NEWTAB) {
     if (NS_WARN_IF(!browserDOMWin)) {
-      *aResult = NS_ERROR_FAILURE;
+      *aResult = NS_ERROR_ABORT;
       return true;
     }
 
     bool isPrivate = false;
     if (thisTabParent) {
       nsCOMPtr<nsILoadContext> loadContext = thisTabParent->GetLoadContext();
       loadContext->GetUsePrivateBrowsing(&isPrivate);
     }
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -601,16 +601,20 @@ TabParent::DestroyInternal()
     static_cast<mozilla::plugins::PluginWidgetParent*>(
        iter.Get()->GetKey())->ParentDestroy();
   }
 }
 
 void
 TabParent::Destroy()
 {
+  // Aggressively release the window to avoid leaking the world in shutdown
+  // corner cases.
+  mBrowserDOMWindow = nullptr;
+
   if (mIsDestroyed) {
     return;
   }
 
   DestroyInternal();
 
   mIsDestroyed = true;
 

