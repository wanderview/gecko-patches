# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e969dc3a107a6a7e210b00e2ab4bda7120d7455a
Bug 1462069 P2 Make ClientManagerService forward claim() requests to the main thread SWM when the pref is set. r=baku

diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -8,16 +8,18 @@
 
 #include "ClientManagerParent.h"
 #include "ClientNavigateOpParent.h"
 #include "ClientOpenWindowOpParent.h"
 #include "ClientOpenWindowUtils.h"
 #include "ClientPrincipalUtils.h"
 #include "ClientSourceParent.h"
 #include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerUtils.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/SystemGroup.h"
 #include "nsIAsyncShutdown.h"
 #include "nsIXULRuntime.h"
 #include "nsProxyRelease.h"
 
@@ -443,16 +445,50 @@ ClientManagerService::MatchAll(const Cli
   }
 
   // Maybe finish the promise now in case we didn't find any matching clients.
   promiseList->MaybeFinish();
 
   return promiseList->GetResultPromise();
 }
 
+namespace {
+
+RefPtr<ClientOpPromise>
+ClaimOnMainThread(const ClientInfo& aClientInfo,
+                  const ServiceWorkerDescriptor& aDescriptor)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
+    [promise, clientInfo = std::move(aClientInfo), desc = std::move(aDescriptor)] () {
+      auto scopeExit = MakeScopeExit([&] {
+        promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      });
+
+      RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+      NS_ENSURE_TRUE_VOID(swm);
+
+      RefPtr<GenericPromise> inner = swm->MaybeClaimClient(clientInfo, desc);
+      inner->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
+        [promise] (bool aResult) {
+          promise->Resolve(NS_OK, __func__);
+        }, [promise] (nsresult aRv) {
+          promise->Reject(aRv, __func__);
+        });
+    });
+
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+  return promise.forget();
+}
+
+} // anonymous namespace
+
 RefPtr<ClientOpPromise>
 ClientManagerService::Claim(const ClientClaimArgs& aArgs)
 {
   AssertIsOnBackgroundThread();
 
   const IPCServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
   const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
 
@@ -482,17 +518,23 @@ ClientManagerService::Claim(const Client
     //       This can't happen until the SWM is moved to the parent process,
     //       though.
     if (!source->ExecutionReady() ||
         source->Info().Type() == ClientType::Serviceworker ||
         source->Info().URL().Find(serviceWorker.scope()) != 0) {
       continue;
     }
 
-    promiseList->AddPromise(source->StartOp(aArgs));
+    if (ServiceWorkerParentInterceptEnabled()) {
+      promiseList->AddPromise(
+        ClaimOnMainThread(source->Info(),
+                          ServiceWorkerDescriptor(serviceWorker)));
+    } else {
+      promiseList->AddPromise(source->StartOp(aArgs));
+    }
   }
 
   // Maybe finish the promise now in case we didn't find any matching clients.
   promiseList->MaybeFinish();
 
   return promiseList->GetResultPromise();
 }
 
