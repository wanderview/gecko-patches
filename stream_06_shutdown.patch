# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  cd77c7d442c459bcd4773fdf136f9ad899d4384c
Bug 1128959 - Implement the WHATWG Streams spec - part 6 - Shutting down procedure, r=bkelly

diff --git a/dom/fetch/FetchStream.cpp b/dom/fetch/FetchStream.cpp
--- a/dom/fetch/FetchStream.cpp
+++ b/dom/fetch/FetchStream.cpp
@@ -3,36 +3,127 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "FetchStream.h"
 #include "nsITransport.h"
 #include "nsIStreamTransportService.h"
 #include "nsProxyRelease.h"
+#include "WorkerPrivate.h"
+#include "Workers.h"
 
 #define FETCH_STREAM_FLAG 0
 
 static NS_DEFINE_CID(kStreamTransportServiceCID,
                      NS_STREAMTRANSPORTSERVICE_CID);
 
 namespace mozilla {
 namespace dom {
 
-NS_IMPL_ISUPPORTS(FetchStream, nsIInputStreamCallback)
+using namespace workers;
+
+namespace {
+
+class FetchStreamWorkerHolder final : public WorkerHolder
+{
+public:
+  explicit FetchStreamWorkerHolder(FetchStream* aStream)
+    : WorkerHolder(WorkerHolder::Behavior::AllowIdleShutdownStart)
+    , mStream(aStream)
+    , mWasNotified(false)
+  {}
+
+  bool Notify(Status aStatus) override
+  {
+    if (!mWasNotified) {
+      mWasNotified = true;
+      mStream->Close();
+    }
+
+    return true;
+  }
+
+  WorkerPrivate* GetWorkerPrivate() const
+  {
+    return mWorkerPrivate;
+  }
+
+private:
+  RefPtr<FetchStream> mStream;
+  bool mWasNotified;
+};
+
+class FetchStreamWorkerHolderShutdown final : public WorkerControlRunnable
+{
+public:
+  FetchStreamWorkerHolderShutdown(WorkerPrivate* aWorkerPrivate,
+                                  UniquePtr<WorkerHolder>&& aHolder,
+                                  nsCOMPtr<nsIGlobalObject>&& aGlobal)
+    : WorkerControlRunnable(aWorkerPrivate)
+    , mHolder(Move(aHolder))
+    , mGlobal(Move(aGlobal))
+  {}
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    mHolder = nullptr;
+    mGlobal = nullptr;
+    return true;
+  }
+
+private:
+  UniquePtr<WorkerHolder> mHolder;
+  nsCOMPtr<nsIGlobalObject> mGlobal;
+};
+
+} // anonymous
+
+NS_IMPL_ISUPPORTS(FetchStream, nsIInputStreamCallback, nsIObserver,
+                  nsISupportsWeakReference)
 
 /* static */ JSObject*
 FetchStream::Create(JSContext* aCx, nsIGlobalObject* aGlobal,
                     nsIInputStream* aInputStream, ErrorResult& aRv)
 {
   MOZ_DIAGNOSTIC_ASSERT(aCx);
   MOZ_DIAGNOSTIC_ASSERT(aInputStream);
 
   RefPtr<FetchStream> stream = new FetchStream(aGlobal, aInputStream);
 
+  if (NS_IsMainThread()) {
+    nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+    if (NS_WARN_IF(!os)) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    aRv = os->AddObserver(stream, DOM_WINDOW_DESTROYED_TOPIC, true);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+
+  } else {
+    WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
+    MOZ_ASSERT(workerPrivate);
+
+    UniquePtr<FetchStreamWorkerHolder> holder(
+      new FetchStreamWorkerHolder(stream));
+    if (NS_WARN_IF(!holder->HoldWorker(workerPrivate, Closing))) {
+      aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+      return nullptr;
+    }
+
+    // Note, this will create a ref-cycle between the holder and the stream.
+    // The cycle is broken when the stream is closed or the worker begins
+    // shutting down.
+    stream->mWorkerHolder = Move(holder);
+  }
+
   if (!JS::HasReadableStreamCallbacks(aCx)) {
     JS::SetReadableStreamCallbacks(aCx,
                                    &FetchStream::RequestDataCallback,
                                    &FetchStream::WriteIntoReadRequestCallback,
                                    &FetchStream::CancelCallback,
                                    &FetchStream::ClosedCallback,
                                    &FetchStream::ErroredCallback,
                                    &FetchStream::FinalizeCallback);
@@ -223,37 +314,41 @@ FetchStream::ErroredCallback(JSContext* 
 }
 
 void
 FetchStream::FinalizeCallback(void* aUnderlyingSource, uint8_t aFlags)
 {
   MOZ_DIAGNOSTIC_ASSERT(aUnderlyingSource);
   MOZ_DIAGNOSTIC_ASSERT(aFlags == FETCH_STREAM_FLAG);
 
+  // This can be called in any thread.
+
   RefPtr<FetchStream> stream =
     dont_AddRef(static_cast<FetchStream*>(aUnderlyingSource));
 
-  stream->mState = eClosed;
-  stream->mReadableStream = nullptr;
+  if (stream->mState == eClosed) {
+    return;
+  }
+
+  stream->CloseAndReleaseObjects();
 }
 
 FetchStream::FetchStream(nsIGlobalObject* aGlobal,
                          nsIInputStream* aInputStream)
   : mState(eWaiting)
   , mGlobal(aGlobal)
   , mOriginalInputStream(aInputStream)
   , mOwningEventTarget(mGlobal->EventTargetFor(TaskCategory::Other))
   , mReadableStream(nullptr)
 {
   MOZ_DIAGNOSTIC_ASSERT(aInputStream);
 }
 
 FetchStream::~FetchStream()
 {
-  NS_ProxyRelease("FetchStream::mGlobal", mOwningEventTarget, mGlobal.forget());
 }
 
 void
 FetchStream::ErrorPropagation(JSContext* aCx, JS::HandleObject aStream,
                               nsresult aError)
 {
   // Nothing to do.
   if (mState == eClosed) {
@@ -327,10 +422,77 @@ FetchStream::OnInputStreamReady(nsIAsync
   JS::ReadableStreamUpdateDataAvailableFromSource(cx, stream, size);
 
   // The WriteInto callback changes mState to eChecking.
   MOZ_DIAGNOSTIC_ASSERT(mState == eChecking);
 
   return NS_OK;
 }
 
+void
+FetchStream::Close()
+{
+  if (mState == eClosed) {
+    return;
+  }
+
+  AutoJSAPI jsapi;
+  if (NS_WARN_IF(!jsapi.Init(mGlobal))) {
+    return;
+  }
+
+  JSContext* cx = jsapi.cx();
+  JS::Rooted<JSObject*> stream(cx, mReadableStream);
+  JS::ReadableStreamClose(cx, stream);
+
+  CloseAndReleaseObjects();
+}
+
+void
+FetchStream::CloseAndReleaseObjects()
+{
+  MOZ_DIAGNOSTIC_ASSERT(mState != eClosed);
+  mState = eClosed;
+
+  if (mWorkerHolder) {
+    RefPtr<FetchStreamWorkerHolderShutdown> r =
+      new FetchStreamWorkerHolderShutdown(
+        static_cast<FetchStreamWorkerHolder*>(mWorkerHolder.get())->GetWorkerPrivate(),
+        Move(mWorkerHolder), Move(mGlobal));
+    r->Dispatch();
+  } else {
+    RefPtr<FetchStream> self = this;
+    RefPtr<Runnable> r = NS_NewRunnableFunction(
+      "FetchStream::Finalize",
+      [self] () {
+        nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
+        if (os) {
+          os->RemoveObserver(self, DOM_WINDOW_DESTROYED_TOPIC);
+        }
+        self->mGlobal = nullptr;
+      });
+
+    mGlobal->Dispatch("FetchStream::FinalizeCallback",
+                      TaskCategory::Other, r.forget());
+  }
+}
+
+// nsIObserver
+// -----------
+
+NS_IMETHODIMP
+FetchStream::Observe(nsISupports* aSubject, const char* aTopic,
+                     const char16_t* aData)
+{
+  AssertIsOnMainThread();
+
+  MOZ_ASSERT(strcmp(aTopic, DOM_WINDOW_DESTROYED_TOPIC) == 0);
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (SameCOMIdentity(aSubject, window)) {
+    Close();
+  }
+
+  return NS_OK;
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/fetch/FetchStream.h b/dom/fetch/FetchStream.h
--- a/dom/fetch/FetchStream.h
+++ b/dom/fetch/FetchStream.h
@@ -5,35 +5,47 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_FetchStream_h
 #define mozilla_dom_FetchStream_h
 
 #include "Fetch.h"
 #include "jsapi.h"
 #include "nsIAsyncInputStream.h"
+#include "nsIObserver.h"
 #include "nsISupportsImpl.h"
+#include "nsWeakReference.h"
 
 class nsIGlobalObject;
 
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 
+namespace workers {
+class WorkerHolder;
+}
+
 class FetchStream final : public nsIInputStreamCallback
+                        , public nsIObserver
+                        , public nsSupportsWeakReference
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAMCALLBACK
+  NS_DECL_NSIOBSERVER
 
   static JSObject*
   Create(JSContext* aCx, nsIGlobalObject* aGlobal,
          nsIInputStream* aInputStream, ErrorResult& aRv);
 
+  void
+  Close();
+
 private:
   FetchStream(nsIGlobalObject* aGlobal, nsIInputStream* aInputStream);
   ~FetchStream();
 
   static void
   RequestDataCallback(JSContext* aCx, JS::HandleObject aStream,
                       void* aUnderlyingSource, uint8_t aFlags,
                       size_t aDesiredSize);
@@ -59,16 +71,19 @@ private:
                   JS::HandleValue reason);
 
   static void
   FinalizeCallback(void* aUnderlyingSource, uint8_t aFlags);
 
   void
   ErrorPropagation(JSContext* aCx, JS::HandleObject aStream, nsresult aRv);
 
+  void
+  CloseAndReleaseObjects();
+
   // Common methods
 
   enum State {
     // RequestDataCallback has not been called yet. We haven't started to read
     // data from the stream yet.
     eWaiting,
 
     // We are reading data in a separate I/O thread.
@@ -94,15 +109,17 @@ private:
   // This is the original inputStream received during the CTOR. It will be
   // converted into an nsIAsyncInputStream and stored into mInputStream at the
   // first use.
   nsCOMPtr<nsIInputStream> mOriginalInputStream;
   nsCOMPtr<nsIAsyncInputStream> mInputStream;
 
   nsCOMPtr<nsIEventTarget> mOwningEventTarget;
 
+  UniquePtr<workers::WorkerHolder> mWorkerHolder;
+
   JS::Heap<JSObject*> mReadableStream;
 };
 
 } // dom namespace
 } // mozilla namespace
 
 #endif // mozilla_dom_FetchStream_h
