diff -r f578b845c4b8 -r c7ab9fcc8770 dom/webidl/ServiceWorkerGlobalScope.webidl
--- a/dom/webidl/ServiceWorkerGlobalScope.webidl	Mon May 18 13:43:01 2015 +0200
+++ b/dom/webidl/ServiceWorkerGlobalScope.webidl	Mon May 18 16:12:00 2015 +0200
@@ -11,16 +11,19 @@
  */
 
 [Global=(Worker,ServiceWorker),
  Exposed=ServiceWorker]
 interface ServiceWorkerGlobalScope : WorkerGlobalScope {
   readonly attribute Clients clients;
   readonly attribute ServiceWorkerRegistration registration;
 
+  [Throws]
+  Promise<boolean> skipWaiting();
+
   attribute EventHandler oninstall;
   attribute EventHandler onactivate;
   attribute EventHandler onfetch;
   attribute EventHandler onbeforeevicted;
   attribute EventHandler onevicted;
 
   // The event.source of these MessageEvents are instances of Client
   attribute EventHandler onmessage;
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h	Mon May 18 13:43:01 2015 +0200
+++ b/dom/workers/ServiceWorkerManager.h	Mon May 18 16:12:00 2015 +0200
@@ -207,16 +207,19 @@ public:
   {
     return mActiveWorker && mControlledDocumentsCounter > 0;
   }
 
   void
   Clear();
 
   void
+  PurgeActiveWorker();
+
+  void
   TryToActivate();
 
   void
   Activate();
 
   void
   FinishActivate(bool aSuccess);
 
@@ -240,16 +243,17 @@ private:
   // workers to their corresponding serviceWorkerInfo.
   uint64_t mServiceWorkerID;
 
   // We hold rawptrs since the ServiceWorker constructor and destructor ensure
   // addition and removal.
   // There is a high chance of there being at least one ServiceWorker
   // associated with this all the time.
   nsAutoTArray<ServiceWorker*, 1> mInstances;
+  bool mSkipWaitingFlag;
 
   ~ServiceWorkerInfo()
   { }
 
   // Generates a unique id for the service worker, with zero being treated as
   // invalid.
   uint64_t
   GetNextID() const;
@@ -270,24 +274,37 @@ public:
   }
 
   void SetScriptSpec(const nsCString& aSpec)
   {
     MOZ_ASSERT(!aSpec.IsEmpty());
     mScriptSpec = aSpec;
   }
 
-  explicit ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
-                             const nsACString& aScriptSpec,
-                             const nsAString& aCacheName)
+  bool SkipWaitingFlag() const
+  {
+    AssertIsOnMainThread();
+    return mSkipWaitingFlag;
+  }
+
+  void SetSkipWaitingFlag()
+  {
+    AssertIsOnMainThread();
+    mSkipWaitingFlag = true;
+  }
+
+  ServiceWorkerInfo(ServiceWorkerRegistrationInfo* aReg,
+                    const nsACString& aScriptSpec,
+                    const nsAString& aCacheName)
     : mRegistration(aReg)
     , mScriptSpec(aScriptSpec)
     , mCacheName(aCacheName)
     , mState(ServiceWorkerState::EndGuard_)
     , mServiceWorkerID(GetNextID())
+    , mSkipWaitingFlag(false)
   {
     MOZ_ASSERT(mRegistration);
     MOZ_ASSERT(!aCacheName.IsEmpty());
   }
 
   ServiceWorkerState
   State() const
   {
@@ -434,16 +451,19 @@ public:
 
   void
   MaybeClaimClient(nsIDocument* aDocument,
                    ServiceWorkerRegistrationInfo* aWorkerRegistration);
 
   nsresult
   ClaimClients(const nsCString& aScope, uint64_t aId);
 
+  nsresult
+  SetSkipWaitingFlag(const nsCString& aScope, uint64_t aServiceWorkerID);
+
   static already_AddRefed<ServiceWorkerManager>
   GetInstance();
 
  void LoadRegistrations(
                  const nsTArray<ServiceWorkerRegistrationData>& aRegistrations);
 
   // Used by remove() and removeAll() when clearing history.
   // MUST ONLY BE CALLED FROM UnregisterIfMatchesHost!
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp	Mon May 18 13:43:01 2015 +0200
+++ b/dom/workers/ServiceWorkerManager.cpp	Mon May 18 16:12:00 2015 +0200
@@ -983,18 +983,21 @@ private:
       }
     }
 
     mRegistration->mWaitingWorker = mRegistration->mInstallingWorker.forget();
     mRegistration->mWaitingWorker->UpdateState(ServiceWorkerState::Installed);
     swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                    WhichServiceWorker::INSTALLING_WORKER | WhichServiceWorker::WAITING_WORKER);
 
-    // FIXME(nsm): Bug 982711 Deal with activateImmediately.
-    NS_WARN_IF_FALSE(!aActivateImmediately, "Immediate activation using replace() is not supported yet");
+    // "If registration's waiting worker's skip waiting flag is set"
+    if (mRegistration->mWaitingWorker->SkipWaitingFlag()) {
+      mRegistration->PurgeActiveWorker();
+    }
+
     Done(NS_OK);
     // Activate() is invoked out of band of atomic.
     mRegistration->TryToActivate();
   }
 };
 
 NS_IMPL_ISUPPORTS_INHERITED0(ServiceWorkerRegisterJob, ServiceWorkerJob);
 
@@ -1307,49 +1310,57 @@ LifecycleEventWorkerRunnable::DispatchLi
     new LifecycleEventPromiseHandler(mTask, mServiceWorker, false /* activateImmediately */);
   waitUntilPromise->AppendNativeHandler(handler);
   return true;
 }
 
 void
 ServiceWorkerRegistrationInfo::TryToActivate()
 {
-  if (!IsControllingDocuments()) {
+  if (!IsControllingDocuments() || mWaitingWorker->SkipWaitingFlag()) {
     Activate();
   }
 }
 
 void
 ContinueActivateTask::ContinueAfterWorkerEvent(bool aSuccess, bool aActivateImmediately /* unused */)
 {
   mRegistration->FinishActivate(aSuccess);
 }
 
 void
+ServiceWorkerRegistrationInfo::PurgeActiveWorker()
+{
+  nsRefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker.forget();
+  if (!exitingWorker)
+    return;
+
+  // FIXME(jaoo): Wait for exitingWorker to finish and terminate.
+  exitingWorker->UpdateState(ServiceWorkerState::Redundant);
+  nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
+                                                     exitingWorker->CacheName());
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to purge the activating cache.");
+  }
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::ACTIVE_WORKER);
+}
+
+void
 ServiceWorkerRegistrationInfo::Activate()
 {
   nsRefPtr<ServiceWorkerInfo> activatingWorker = mWaitingWorker;
-  nsRefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker;
-
-  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::WAITING_WORKER | WhichServiceWorker::ACTIVE_WORKER);
   if (!activatingWorker) {
     return;
   }
 
-  if (exitingWorker) {
-    // FIXME(nsm): Wait for worker.
-    // Terminate worker
-    exitingWorker->UpdateState(ServiceWorkerState::Redundant);
-    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
-                                                       exitingWorker->CacheName());
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to purge the activating cache.");
-    }
-  }
+  PurgeActiveWorker();
+
+  nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::WAITING_WORKER);
 
   mActiveWorker = activatingWorker.forget();
   mWaitingWorker = nullptr;
   mActiveWorker->UpdateState(ServiceWorkerState::Activating);
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   swm->CheckPendingReadyPromises();
@@ -3216,16 +3227,41 @@ ServiceWorkerManager::ClaimClients(const
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   mAllDocuments.EnumerateEntries(ClaimMatchingClients, registration);
 
   return NS_OK;
 }
 
+nsresult
+ServiceWorkerManager::SetSkipWaitingFlag(const nsCString& aScope,
+                                         uint64_t aServiceWorkerID)
+{
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetRegistration(aScope);
+  if (!registration) {
+    return NS_ERROR_FAILURE;
+  }
+
+  if (registration->mInstallingWorker &&
+      (registration->mInstallingWorker->ID() == aServiceWorkerID)) {
+    registration->mInstallingWorker->SetSkipWaitingFlag();
+  } else if (registration->mWaitingWorker &&
+             (registration->mWaitingWorker->ID() == aServiceWorkerID)) {
+    registration->mWaitingWorker->SetSkipWaitingFlag();
+    if (registration->mWaitingWorker->State() == ServiceWorkerState::Installed) {
+      registration->TryToActivate();
+    }
+  } else {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 void
 ServiceWorkerManager::FireControllerChange(ServiceWorkerRegistrationInfo* aRegistration)
 {
   mControlledDocuments.EnumerateRead(FireControllerChangeOnMatchingDocument, aRegistration);
 }
 
 ServiceWorkerRegistrationInfo*
 ServiceWorkerManager::CreateNewRegistration(const nsCString& aScope,
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h	Mon May 18 13:43:01 2015 +0200
+++ b/dom/workers/WorkerScope.h	Mon May 18 16:12:00 2015 +0200
@@ -222,16 +222,19 @@ public:
   }
 
   ServiceWorkerClients*
   Clients();
 
   ServiceWorkerRegistrationWorkerThread*
   Registration();
 
+  already_AddRefed<Promise>
+  SkipWaiting(ErrorResult& aRv);
+
   IMPL_EVENT_HANDLER(activate)
   IMPL_EVENT_HANDLER(beforeevicted)
   IMPL_EVENT_HANDLER(evicted)
   IMPL_EVENT_HANDLER(fetch)
   IMPL_EVENT_HANDLER(install)
   IMPL_EVENT_HANDLER(message)
 
   IMPL_EVENT_HANDLER(push)
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp	Mon May 18 13:43:01 2015 +0200
+++ b/dom/workers/WorkerScope.cpp	Mon May 18 16:12:00 2015 +0200
@@ -482,16 +482,135 @@ ServiceWorkerGlobalScope::Registration()
   if (!mRegistration) {
     mRegistration =
       new ServiceWorkerRegistrationWorkerThread(mWorkerPrivate, mScope);
   }
 
   return mRegistration;
 }
 
+namespace {
+
+class SkipWaitingResultRunnable final : public WorkerRunnable
+{
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+
+public:
+  SkipWaitingResultRunnable(WorkerPrivate* aWorkerPrivate,
+                            PromiseWorkerProxy* aPromiseProxy)
+    : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+    , mPromiseProxy(aPromiseProxy)
+  {
+    AssertIsOnMainThread();
+  }
+
+  virtual bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    aWorkerPrivate->AssertIsOnWorkerThread();
+
+    Promise* promise = mPromiseProxy->GetWorkerPromise();
+    MOZ_ASSERT(promise);
+
+    promise->MaybeResolve(JS::UndefinedHandleValue);
+
+    // Release the reference on the worker thread.
+    mPromiseProxy->CleanUp(aCx);
+
+    return true;
+  }
+};
+
+class WorkerScopeSkipWaitingRunnable final : public nsRunnable
+{
+  nsRefPtr<PromiseWorkerProxy> mPromiseProxy;
+  nsCString mScope;
+
+public:
+  WorkerScopeSkipWaitingRunnable(PromiseWorkerProxy* aPromiseProxy,
+                                 const nsCString& aScope)
+    : mPromiseProxy(aPromiseProxy)
+    , mScope(aScope)
+  {
+    MOZ_ASSERT(aPromiseProxy);
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    AssertIsOnMainThread();
+    nsRefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+    MOZ_ASSERT(swm);
+
+    MutexAutoLock lock(mPromiseProxy->GetCleanUpLock());
+    if (mPromiseProxy->IsClean()) {
+      return NS_OK;
+    }
+    WorkerPrivate* workerPrivate = mPromiseProxy->GetWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+
+    swm->SetSkipWaitingFlag(mScope, workerPrivate->ServiceWorkerID());
+
+    nsRefPtr<SkipWaitingResultRunnable> runnable =
+      new SkipWaitingResultRunnable(workerPrivate, mPromiseProxy);
+
+    AutoJSAPI jsapi;
+    jsapi.Init();
+    JSContext* cx = jsapi.cx();
+    if (runnable->Dispatch(cx)) {
+      return NS_OK;
+    }
+
+    // Dispatch to worker thread failed because the worker is shutting down.
+    // Use a control runnable to release the runnable on the worker thread.
+    nsRefPtr<PromiseWorkerProxyControlRunnable> releaseRunnable =
+      new PromiseWorkerProxyControlRunnable(workerPrivate, mPromiseProxy);
+
+    if (!releaseRunnable->Dispatch(cx)) {
+      NS_RUNTIMEABORT("Failed to dispatch Claim control runnable.");
+    }
+
+    return NS_OK;
+  }
+};
+
+}
+
+already_AddRefed<Promise>
+ServiceWorkerGlobalScope::SkipWaiting(ErrorResult& aRv)
+{
+  mWorkerPrivate->AssertIsOnWorkerThread();
+  MOZ_ASSERT(mWorkerPrivate->IsServiceWorker());
+
+  nsRefPtr<Promise> promise = Promise::Create(this, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  nsRefPtr<PromiseWorkerProxy> promiseProxy =
+    PromiseWorkerProxy::Create(mWorkerPrivate, promise);
+  if (!promiseProxy->GetWorkerPromise()) {
+    // Don't dispatch if adding the worker feature failed.
+    promise->MaybeResolve(JS::UndefinedHandleValue);
+    return promise.forget();
+  }
+
+  nsRefPtr<WorkerScopeSkipWaitingRunnable> runnable =
+    new WorkerScopeSkipWaitingRunnable(promiseProxy,
+                                       NS_ConvertUTF16toUTF8(mScope));
+
+  aRv = NS_DispatchToMainThread(runnable);
+  if (NS_WARN_IF(aRv.Failed())) {
+    promise->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+  }
+
+  return promise.forget();
+}
+
 WorkerDebuggerGlobalScope::WorkerDebuggerGlobalScope(
                                                   WorkerPrivate* aWorkerPrivate)
 : mWorkerPrivate(aWorkerPrivate)
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 }
 
 WorkerDebuggerGlobalScope::~WorkerDebuggerGlobalScope()
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/test/serviceworkers/mochitest.ini
--- a/dom/workers/test/serviceworkers/mochitest.ini	Mon May 18 13:43:01 2015 +0200
+++ b/dom/workers/test/serviceworkers/mochitest.ini	Mon May 18 16:12:00 2015 +0200
@@ -91,16 +91,18 @@ support-files =
   swa/worker_scope_too_deep.js
   swa/worker_scope_too_deep.js^headers^
   swa/worker_scope_too_narrow.js
   swa/worker_scope_too_narrow.js^headers^
   claim_oninstall_worker.js
   claim_worker_1.js
   claim_worker_2.js
   claim_clients/client.html
+  skip_waiting_installed_worker.js
+  skip_waiting_scope/index.html
 
 [test_unregister.html]
 [test_installation_simple.html]
 [test_fetch_event.html]
 [test_https_fetch.html]
 [test_https_fetch_cloned_response.html]
 [test_https_synth_fetch_from_cached_sw.html]
 [test_match_all.html]
@@ -128,8 +130,9 @@ support-files =
 [test_empty_serviceworker.html]
 [test_periodic_update.html]
 [test_claim_oninstall.html]
 [test_claim.html]
 [test_periodic_https_update.html]
 [test_sanitize.html]
 [test_sanitize_domain.html]
 [test_service_worker_allowed.html]
+[test_skip_waiting.html]
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/test/serviceworkers/skip_waiting_installed_worker.js
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/workers/test/serviceworkers/skip_waiting_installed_worker.js	Mon May 18 16:12:00 2015 +0200
@@ -0,0 +1,6 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+self.addEventListener('install', evt => {
+  evt.waitUntil(self.skipWaiting());
+});
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/test/serviceworkers/skip_waiting_scope/index.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/workers/test/serviceworkers/skip_waiting_scope/index.html	Mon May 18 16:12:00 2015 +0200
@@ -0,0 +1,37 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1131352 - Add ServiceWorkerGlobalScope skipWaiting()</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+
+  if (!parent) {
+    info("skip_waiting_scope/index.html shouldn't be launched directly!");
+  }
+
+  navigator.serviceWorker.ready.then(function() {
+    parent.postMessage("READY", "*");
+  });
+
+  navigator.serviceWorker.oncontrollerchange = function() {
+    parent.postMessage({
+      event: "controllerchange",
+      controllerScriptURL: navigator.serviceWorker.controller &&
+                           navigator.serviceWorker.controller.scriptURL
+    }, "*");
+  }
+
+</script>
+</pre>
+</body>
+</html>
diff -r f578b845c4b8 -r c7ab9fcc8770 dom/workers/test/serviceworkers/test_skip_waiting.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/dom/workers/test/serviceworkers/test_skip_waiting.html	Mon May 18 16:12:00 2015 +0200
@@ -0,0 +1,95 @@
+<!--
+  Any copyright is dedicated to the Public Domain.
+  http://creativecommons.org/publicdomain/zero/1.0/
+-->
+<!DOCTYPE HTML>
+<html>
+<head>
+  <title>Bug 1131352 - Add ServiceWorkerGlobalScope skipWaiting()</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+</head>
+<body>
+<p id="display"></p>
+<div id="content" style="display: none"></div>
+<pre id="test"></pre>
+<script class="testbody" type="text/javascript">
+  var registration, iframe, content;
+
+  function start() {
+    return navigator.serviceWorker.register("worker.js",
+                                            {scope: "./skip_waiting_scope/"});
+  }
+
+  function waitForActivated(swr) {
+    registration = swr;
+    var promise = new Promise(function(resolve, reject) {
+      window.onmessage = function(e) {
+        if (e.data === "READY") {
+          ok(true, "Active worker is activated now");
+          resolve();
+        } else {
+          ok(false, "Wrong value. Somenting went wrong");
+          resolve();
+        }
+      }
+    });
+
+    iframe = document.createElement("iframe");
+    iframe.setAttribute("src", "skip_waiting_scope/index.html");
+
+    content = document.getElementById("content");
+    content.appendChild(iframe);
+
+    return promise;
+  }
+
+  function checkWhetherItSkippedWaiting() {
+    var promise = new Promise(function(resolve, reject) {
+      window.onmessage = function (evt) {
+        if (evt.data.event === "controllerchange") {
+          ok(evt.data.controllerScriptURL.match("skip_waiting_installed_worker"),
+             "The controller changed after skiping the waiting step");
+          resolve();
+        } else {
+          ok(false, "Wrong value. Somenting went wrong");
+          resolve();
+        }
+      };
+    });
+
+    navigator.serviceWorker.register("skip_waiting_installed_worker.js",
+                                     {scope: "./skip_waiting_scope/"})
+      .then(swr => {
+        registration = swr;
+    });
+
+    return promise;
+  }
+
+  function clean() {
+    content.removeChild(iframe);
+
+    return registration.unregister();
+  }
+
+  function runTest() {
+    start()
+      .then(waitForActivated)
+      .then(checkWhetherItSkippedWaiting)
+      .then(clean)
+      .catch(function(e) {
+        ok(false, "Some test failed with error " + e);
+      }).then(SimpleTest.finish);
+  }
+
+  SimpleTest.waitForExplicitFinish();
+  SpecialPowers.pushPrefEnv({"set": [
+    ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+    ["dom.serviceWorkers.enabled", true],
+    ["dom.serviceWorkers.testing.enabled", true]
+  ]}, runTest);
+</script>
+</pre>
+</body>
+</html>
