# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f373802df088f71c4c9065805107b0973f452672
Bug 1458971 Make operation actors explicitly hold references to the initiating object instead of using an extra MozPromise::Then(). r=baku

diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -45,22 +45,23 @@ ClientHandle::StartOp(const ClientOpCons
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
 
   MaybeExecute([aArgs, kungFuGrip, aRejectCallback,
                 resolve = Move(aResolveCallback)] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor =
-      new ClientHandleOpChild(aArgs, Move(resolve), Move(aRejectCallback));
+      new ClientHandleOpChild(kungFuGrip, aArgs, Move(resolve),
+                              Move(aRejectCallback));
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will call reject callback via ActorDestroy()
       return;
     }
-  }, [aRejectCallback, kungFuGrip] {
+  }, [aRejectCallback] {
     aRejectCallback(NS_ERROR_DOM_INVALID_STATE_ERR);
   });
 }
 
 void
 ClientHandle::OnShutdownThing()
 {
   NS_ASSERT_OWNINGTHREAD(ClientHandle);
diff --git a/dom/clients/manager/ClientHandleOpChild.cpp b/dom/clients/manager/ClientHandleOpChild.cpp
--- a/dom/clients/manager/ClientHandleOpChild.cpp
+++ b/dom/clients/manager/ClientHandleOpChild.cpp
@@ -1,41 +1,48 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandleOpChild.h"
 
+#include "ClientHandle.h"
+
 namespace mozilla {
 namespace dom {
 
 void
 ClientHandleOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  mClientHandle = nullptr;
   mRejectCallback(NS_ERROR_DOM_ABORT_ERR);
 }
 
 mozilla::ipc::IPCResult
 ClientHandleOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
+  mClientHandle = nullptr;
   if (aResult.type() == ClientOpResult::Tnsresult &&
       NS_FAILED(aResult.get_nsresult())) {
     mRejectCallback(aResult.get_nsresult());
     return IPC_OK();
   }
   mResolveCallback(aResult);
   return IPC_OK();
 }
 
-ClientHandleOpChild::ClientHandleOpChild(const ClientOpConstructorArgs& aArgs,
+ClientHandleOpChild::ClientHandleOpChild(ClientHandle* aClientHandle,
+                                         const ClientOpConstructorArgs& aArgs,
                                          const ClientOpCallback&& aResolveCallback,
                                          const ClientOpCallback&& aRejectCallback)
-  : mResolveCallback(Move(aResolveCallback))
+  : mClientHandle(aClientHandle)
+  , mResolveCallback(Move(aResolveCallback))
   , mRejectCallback(Move(aRejectCallback))
 {
+  MOZ_DIAGNOSTIC_ASSERT(mClientHandle);
   MOZ_DIAGNOSTIC_ASSERT(mResolveCallback);
   MOZ_DIAGNOSTIC_ASSERT(mRejectCallback);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleOpChild.h b/dom/clients/manager/ClientHandleOpChild.h
--- a/dom/clients/manager/ClientHandleOpChild.h
+++ b/dom/clients/manager/ClientHandleOpChild.h
@@ -7,30 +7,34 @@
 #define _mozilla_dom_ClientHandleOpChild_h
 
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/PClientHandleOpChild.h"
 
 namespace mozilla {
 namespace dom {
 
+class ClientHandle;
+
 class ClientHandleOpChild final : public PClientHandleOpChild
 {
+  RefPtr<ClientHandle> mClientHandle;
   const ClientOpCallback mResolveCallback;
   const ClientOpCallback mRejectCallback;
 
   // PClientHandleOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   Recv__delete__(const ClientOpResult& aResult) override;
 
 public:
-  ClientHandleOpChild(const ClientOpConstructorArgs& aArgs,
+  ClientHandleOpChild(ClientHandle* aClientHandle,
+                      const ClientOpConstructorArgs& aArgs,
                       const ClientOpCallback&& aResolveCallback,
                       const ClientOpCallback&& aRejectCallback);
 
   ~ClientHandleOpChild() = default;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -160,22 +160,20 @@ ClientManager::StartOp(const ClientOpCon
 {
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientManager> kungFuGrip = this;
-  promise->Then(aSerialEventTarget, __func__,
-                [kungFuGrip] (const ClientOpResult&) { },
-                [kungFuGrip] (nsresult) { });
 
-  MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
-    ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
+  MaybeExecute([aArgs, promise, kungFuGrip] (ClientManagerChild* aActor) {
+    ClientManagerOpChild* actor =
+      new ClientManagerOpChild(kungFuGrip, aArgs, promise);
     if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   }, [promise] {
     promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
   });
 
diff --git a/dom/clients/manager/ClientManagerOpChild.cpp b/dom/clients/manager/ClientManagerOpChild.cpp
--- a/dom/clients/manager/ClientManagerOpChild.cpp
+++ b/dom/clients/manager/ClientManagerOpChild.cpp
@@ -1,48 +1,54 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerOpChild.h"
 
+#include "mozilla/dom/ClientManager.h"
 #include "mozilla/ipc/ProtocolUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 void
 ClientManagerOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  mClientManager = nullptr;
   if (mPromise) {
     mPromise->Reject(NS_ERROR_ABORT, __func__);
     mPromise = nullptr;
   }
 }
 
 mozilla::ipc::IPCResult
 ClientManagerOpChild::Recv__delete__(const ClientOpResult& aResult)
 {
+  mClientManager = nullptr;
   if (aResult.type() == ClientOpResult::Tnsresult &&
       NS_FAILED(aResult.get_nsresult())) {
     mPromise->Reject(aResult.get_nsresult(), __func__);
     mPromise = nullptr;
     return IPC_OK();
   }
   mPromise->Resolve(aResult, __func__);
   mPromise = nullptr;
   return IPC_OK();
 }
 
-ClientManagerOpChild::ClientManagerOpChild(const ClientOpConstructorArgs& aArgs,
+ClientManagerOpChild::ClientManagerOpChild(ClientManager* aClientManager,
+                                           const ClientOpConstructorArgs& aArgs,
                                            ClientOpPromise::Private* aPromise)
-  : mPromise(aPromise)
+  : mClientManager(aClientManager)
+  , mPromise(aPromise)
 {
+  MOZ_DIAGNOSTIC_ASSERT(mClientManager);
   MOZ_DIAGNOSTIC_ASSERT(mPromise);
 }
 
 ClientManagerOpChild::~ClientManagerOpChild()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mPromise);
 }
 
diff --git a/dom/clients/manager/ClientManagerOpChild.h b/dom/clients/manager/ClientManagerOpChild.h
--- a/dom/clients/manager/ClientManagerOpChild.h
+++ b/dom/clients/manager/ClientManagerOpChild.h
@@ -8,29 +8,33 @@
 
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/PClientManagerOpChild.h"
 #include "mozilla/MozPromise.h"
 
 namespace mozilla {
 namespace dom {
 
+class ClientManager;
+
 class ClientManagerOpChild final : public PClientManagerOpChild
 {
+  RefPtr<ClientManager> mClientManager;
   RefPtr<ClientOpPromise::Private> mPromise;
 
   // PClientManagerOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   Recv__delete__(const ClientOpResult& aResult) override;
 
 public:
-  ClientManagerOpChild(const ClientOpConstructorArgs& aArgs,
+  ClientManagerOpChild(ClientManager* aClientManager,
+                       const ClientOpConstructorArgs& aArgs,
                        ClientOpPromise::Private* aPromise);
 
   ~ClientManagerOpChild();
 };
 
 } // namespace dom
 } // namespace mozilla
 
