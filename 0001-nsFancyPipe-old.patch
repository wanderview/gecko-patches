# HG changeset patch
# Parent 42ab37ac0bd9deda53b76253bd4211bd77f65530
# User Kyle Huey <khuey@kylehuey.com>

nsFancyPipe

diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -545,16 +545,17 @@ ReinitTaskTracer(void* /*aUnused*/)
 
 ContentChild::ContentChild()
  : mID(uint64_t(-1))
 #ifdef ANDROID
    ,mScreenSize(0, 0)
 #endif
    , mCanOverrideProcessName(true)
    , mIsAlive(true)
+   , mIsCurrentlyProcessingMessages(false)
 {
     // This process is a content process, so it's clearly running in
     // multiprocess mode!
     nsDebugImpl::SetMultiprocessMode("Child");
 }
 
 ContentChild::~ContentChild()
 {
@@ -753,16 +754,28 @@ ContentChild::InitXPCOM()
     // This object is held alive by the observer service.
     nsRefPtr<SystemMessageHandledObserver> sysMsgObserver =
         new SystemMessageHandledObserver();
     sysMsgObserver->Init();
 
     InitOnContentProcessCreated();
 }
 
+/* static */ ContentChild*
+ContentChild::GetCurrentlyProcessingMessages()
+{
+    ContentChild* self = GetSingleton();
+
+    if (self->mIsCurrentlyProcessingMessages) {
+        return self;
+    }
+
+    return nullptr;
+}
+
 a11y::PDocAccessibleChild*
 ContentChild::AllocPDocAccessibleChild(PDocAccessibleChild*, const uint64_t&)
 {
   MOZ_ASSERT(false, "should never call this!");
   return nullptr;
 }
 
 bool
@@ -1824,16 +1837,32 @@ ContentChild::ProcessingError(Result wha
     case MsgValueError:
         NS_RUNTIMEABORT("aborting because of MsgValueError");
 
     default:
         NS_RUNTIMEABORT("not reached");
     }
 }
 
+auto
+ContentChild::OnMessageReceived(const Message& __msg) -> Result
+{
+    AutoRestore<bool> autoRestore(mIsCurrentlyProcessingMessages);
+    mIsCurrentlyProcessingMessages = true;
+    return PContentChild::OnMessageReceived(__msg);
+}
+
+auto
+ContentChild::OnMessageReceived(const Message& __msg, Message*& __reply) -> Result
+{
+    AutoRestore<bool> autoRestore(mIsCurrentlyProcessingMessages);
+    mIsCurrentlyProcessingMessages = true;
+    return PContentChild::OnMessageReceived(__msg, __reply);
+}
+
 void
 ContentChild::QuickExit()
 {
     NS_WARNING("content process _exit()ing");
     _exit(0);
 }
 
 nsresult
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -81,16 +81,18 @@ public:
               IPC::Channel* aChannel);
     void InitProcessAttributes();
     void InitXPCOM();
 
     static ContentChild* GetSingleton() {
         return sSingleton;
     }
 
+    static ContentChild* GetCurrentlyProcessingMessages();
+
     const AppInfo& GetAppInfo() {
         return mAppInfo;
     }
     void SetProcessName(const nsAString& aName, bool aDontOverride = false);
     void GetProcessName(nsAString& aName);
     void GetProcessName(nsACString& aName);
     bool IsAlive();
     static void AppendProcessId(nsACString& aName);
@@ -438,16 +440,22 @@ public:
     virtual bool
     DeallocPOfflineCacheUpdateChild(POfflineCacheUpdateChild* offlineCacheUpdate) MOZ_OVERRIDE;
 
 private:
     virtual void ActorDestroy(ActorDestroyReason why) MOZ_OVERRIDE;
 
     virtual void ProcessingError(Result what) MOZ_OVERRIDE;
 
+    virtual Result
+    OnMessageReceived(const Message& __msg) MOZ_OVERRIDE;
+
+    virtual Result
+    OnMessageReceived(const Message& __msg, Message*& __reply) MOZ_OVERRIDE;
+
     /**
      * Exit *now*.  Do not shut down XPCOM, do not pass Go, do not run
      * static destructors, do not collect $200.
      */
     MOZ_NORETURN void QuickExit();
 
     InfallibleTArray<nsAutoPtr<AlertObserver> > mAlertObservers;
     nsRefPtr<ConsoleListener> mConsoleListener;
@@ -472,16 +480,18 @@ private:
 #endif
 
     bool mIsForApp;
     bool mIsForBrowser;
     bool mCanOverrideProcessName;
     bool mIsAlive;
     nsString mProcessName;
 
+    bool mIsCurrentlyProcessingMessages;
+
     static ContentChild* sSingleton;
 
     DISALLOW_EVIL_CONSTRUCTORS(ContentChild);
 };
 
 uint64_t
 NextWindowID();
 
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -367,16 +367,17 @@ template<>
 struct nsIConsoleService::COMTypeInfo<nsConsoleService, void> {
   static const nsIID kIID;
 };
 const nsIID nsIConsoleService::COMTypeInfo<nsConsoleService, void>::kIID = NS_ICONSOLESERVICE_IID;
 
 namespace mozilla {
 namespace dom {
 
+ContentParent* ContentParent::sCurrentlyProcessingMessagesContentParent;
 #ifdef MOZ_NUWA_PROCESS
 int32_t ContentParent::sNuwaPid = 0;
 bool ContentParent::sNuwaReady = false;
 #endif
 
 #define NS_IPC_IOSERVICE_SET_OFFLINE_TOPIC "ipc:network:set-offline"
 
 class MemoryReportRequestParent : public PMemoryReportRequestParent
@@ -1282,16 +1283,22 @@ ContentParent::GetAllEvenIfDead(nsTArray
     }
 
     for (ContentParent* cp = sContentParents->getFirst(); cp;
          cp = cp->LinkedListElement<ContentParent>::getNext()) {
         aArray.AppendElement(cp);
     }
 }
 
+/* static */ ContentParent*
+ContentParent::GetCurrentlyProcessingMessages() {
+    MOZ_ASSERT(NS_IsMainThread());
+    return sCurrentlyProcessingMessagesContentParent;
+}
+
 void
 ContentParent::Init()
 {
     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
     if (obs) {
         size_t length = ArrayLength(sObserverTopics);
         for (size_t i = 0; i < length; ++i) {
             obs->AddObserver(this, sObserverTopics[i], false);
@@ -3050,16 +3057,32 @@ ContentParent::RecvPDocAccessibleConstru
   } else {
     MOZ_ASSERT(!aParentID);
     a11y::DocManager::RemoteDocAdded(doc);
   }
 #endif
   return true;
 }
 
+auto
+ContentParent::OnMessageReceived(const Message& __msg) -> Result
+{
+    AutoRestore<ContentParent*> autoRestore(sCurrentlyProcessingMessagesContentParent);
+    sCurrentlyProcessingMessagesContentParent = this;
+    return PContentParent::OnMessageReceived(__msg);
+}
+
+auto
+ContentParent::OnMessageReceived(const Message& __msg, Message*& __reply) -> Result
+{
+    AutoRestore<ContentParent*> autoRestore(sCurrentlyProcessingMessagesContentParent);
+    sCurrentlyProcessingMessagesContentParent = this;
+    return PContentParent::OnMessageReceived(__msg, __reply);
+}
+
 PCompositorParent*
 ContentParent::AllocPCompositorParent(mozilla::ipc::Transport* aTransport,
                                       base::ProcessId aOtherProcess)
 {
     return CompositorParent::Create(aTransport, aOtherProcess);
 }
 
 PImageBridgeParent*
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -135,16 +135,18 @@ public:
     static TabParent*
     CreateBrowserOrApp(const TabContext& aContext,
                        Element* aFrameElement,
                        ContentParent* aOpenerContentParent);
 
     static void GetAll(nsTArray<ContentParent*>& aArray);
     static void GetAllEvenIfDead(nsTArray<ContentParent*>& aArray);
 
+    static ContentParent* GetCurrentlyProcessingMessages();
+
     static bool IgnoreIPCPrincipal();
 
     static void NotifyUpdatedDictionaries();
 
     virtual bool RecvCreateChildProcess(const IPCTabContext& aContext,
                                         const hal::ProcessPriority& aPriority,
                                         const TabId& aOpenerTabId,
                                         ContentParentId* aCpId,
@@ -777,16 +779,24 @@ private:
                           int32_t* aSliceRefCnt,
                           bool* aResult) MOZ_OVERRIDE;
 
     virtual PDocAccessibleParent* AllocPDocAccessibleParent(PDocAccessibleParent*, const uint64_t&) MOZ_OVERRIDE;
     virtual bool DeallocPDocAccessibleParent(PDocAccessibleParent*) MOZ_OVERRIDE;
     virtual bool RecvPDocAccessibleConstructor(PDocAccessibleParent* aDoc,
                                                PDocAccessibleParent* aParentDoc, const uint64_t& aParentID) MOZ_OVERRIDE;
 
+    virtual Result
+    OnMessageReceived(const Message& __msg) MOZ_OVERRIDE;
+
+    virtual Result
+    OnMessageReceived(const Message& __msg, Message*& __reply) MOZ_OVERRIDE;
+
+    static ContentParent* sCurrentlyProcessingMessagesContentParent;
+
     // If you add strong pointers to cycle collected objects here, be sure to
     // release these objects in ShutDownProcess.  See the comment there for more
     // details.
 
     GeckoChildProcessHost* mSubprocess;
     ContentParent* mOpener;
 
     ContentParentId mChildID;
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -48,16 +48,17 @@ include PluginTypes;
 include ProtocolTypes;
 
 // Workaround to prevent error if PContentChild.cpp & PContentBridgeParent.cpp
 // are put into different UnifiedProtocolsXX.cpp files.
 // XXX Remove this once bug 1069073 is fixed
 include "mozilla/dom/PContentBridgeParent.h";
 
 include "mozilla/dom/indexedDB/SerializationHelpers.h";
+include "mozilla/dom/PContentBridgeParent.h";
 
 using GeoPosition from "nsGeoPositionIPCSerialiser.h";
 
 using struct ChromePackage from "mozilla/chrome/RegistryMessageUtils.h";
 using struct ResourceMapping from "mozilla/chrome/RegistryMessageUtils.h";
 using struct OverrideMapping from "mozilla/chrome/RegistryMessageUtils.h";
 using base::ChildPrivileges from "base/process_util.h";
 using base::ProcessId from "base/process.h";
diff --git a/ipc/glue/BackgroundChild.h b/ipc/glue/BackgroundChild.h
--- a/ipc/glue/BackgroundChild.h
+++ b/ipc/glue/BackgroundChild.h
@@ -66,16 +66,22 @@ public:
   static mozilla::dom::PBlobChild*
   GetOrCreateActorForBlob(PBackgroundChild* aBackgroundActor,
                           nsIDOMBlob* aBlob);
 
   // See above.
   static void
   CloseForCurrentThread();
 
+  // Returns the PBackgroundChild that is currently processing messages. This
+  // function may only be called on a thread with an existing PBackgroundChild,
+  // and only when a message is being processed.
+  static PBackgroundChild*
+  GetCurrentlyProcessingMessages();
+
 private:
   // Only called by ContentChild or ContentParent.
   static void
   Startup();
 
   // Only called by ContentChild.
   static PBackgroundChild*
   Alloc(Transport* aTransport, ProcessId aOtherProcess);
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -3,24 +3,26 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
 #include "ActorsChild.h" // IndexedDB
 #include "BroadcastChannelChild.h"
 #include "FileDescriptorSetChild.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/AutoRestore.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/cache/PCacheChild.h"
 #include "mozilla/dom/cache/PCacheStorageChild.h"
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/layout/VsyncChild.h"
 #include "nsID.h"
 #include "nsTraceRefcnt.h"
 
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
@@ -72,23 +74,28 @@ ThreadLocal::~ThreadLocal()
   MOZ_COUNT_DTOR(mozilla::ipc::BackgroundChildImpl::ThreadLocal);
 }
 
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl
 // -----------------------------------------------------------------------------
 
 BackgroundChildImpl::BackgroundChildImpl()
+#ifdef DEBUG
+  : mCurrentlyProcessingMessages(false)
+#endif
 {
   // May happen on any thread!
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundChildImpl);
 }
 
 BackgroundChildImpl::~BackgroundChildImpl()
 {
+  MOZ_ASSERT(!mCurrentlyProcessingMessages);
+
   // May happen on any thread!
   MOZ_COUNT_DTOR(mozilla::ipc::BackgroundChildImpl);
 }
 
 void
 BackgroundChildImpl::ProcessingError(Result aWhat)
 {
   // May happen on any thread!
@@ -155,16 +162,29 @@ BackgroundChildImpl::DeallocPBackgroundI
                                              PBackgroundIDBFactoryChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+PBackgroundPipeTransportChild*
+BackgroundChildImpl::AllocPBackgroundPipeTransportChild(const intptr_t& aCookie)
+{
+  MOZ_ASSERT_UNREACHABLE("Not reached!");
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor)
+{
+  return detail::DeallocPBackgroundPipeTransportChild(aActor);
+}
+
 auto
 BackgroundChildImpl::AllocPBlobChild(const BlobConstructorParams& aParams)
   -> PBlobChild*
 {
   MOZ_ASSERT(aParams.type() != BlobConstructorParams::T__None);
 
   return mozilla::dom::BlobChild::Create(this, aParams);
 }
@@ -283,16 +303,35 @@ BackgroundChildImpl::AllocPCacheStreamCo
 
 bool
 BackgroundChildImpl::DeallocPCacheStreamControlChild(PCacheStreamControlChild* aActor)
 {
   delete aActor;
   return true;
 }
 
+#ifdef DEBUG
+auto
+BackgroundChildImpl::OnMessageReceived(const Message& __msg) -> Result
+{
+  AutoRestore<bool> autoRestore(mCurrentlyProcessingMessages);
+  mCurrentlyProcessingMessages = true;
+  return PBackgroundChild::OnMessageReceived(__msg);
+}
+
+auto
+BackgroundChildImpl::OnMessageReceived(const Message& __msg,
+                                       Message*& __reply) -> Result
+{
+  AutoRestore<bool> autoRestore(mCurrentlyProcessingMessages);
+  mCurrentlyProcessingMessages = true;
+  return PBackgroundChild::OnMessageReceived(__msg, __reply);
+}
+#endif
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -60,16 +60,22 @@ protected:
 
   virtual PBackgroundIDBFactoryChild*
   AllocPBackgroundIDBFactoryChild(const LoggingInfo& aLoggingInfo) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundIDBFactoryChild(PBackgroundIDBFactoryChild* aActor)
                                     MOZ_OVERRIDE;
 
+  virtual PBackgroundPipeTransportChild*
+  AllocPBackgroundPipeTransportChild(const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor) MOZ_OVERRIDE;
+
   virtual PBlobChild*
   AllocPBlobChild(const BlobConstructorParams& aParams) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBlobChild(PBlobChild* aActor) MOZ_OVERRIDE;
 
   virtual PFileDescriptorSetChild*
   AllocPFileDescriptorSetChild(const FileDescriptor& aFileDescriptor)
@@ -104,16 +110,27 @@ protected:
   virtual bool
   DeallocPCacheChild(dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
   virtual dom::cache::PCacheStreamControlChild*
   AllocPCacheStreamControlChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheStreamControlChild(dom::cache::PCacheStreamControlChild* aActor) MOZ_OVERRIDE;
+
+#ifdef DEBUG
+  virtual Result
+  OnMessageReceived(const Message& __msg) MOZ_OVERRIDE;
+
+  virtual Result
+  OnMessageReceived(const Message& __msg,
+                    Message*& __reply) MOZ_OVERRIDE;
+
+  bool mCurrentlyProcessingMessages;
+#endif
 };
 
 class BackgroundChildImpl::ThreadLocal MOZ_FINAL
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -232,16 +232,20 @@ private:
   GetContentParent(PBackgroundParent* aBackgroundActor);
 
   // Forwarded from BackgroundParent.
   static intptr_t
   GetRawContentParentForComparison(PBackgroundParent* aBackgroundActor);
 
   // Forwarded from BackgroundParent.
   static PBackgroundParent*
+  GetCurrentlyProcessingMessages();
+
+  // Forwarded from BackgroundParent.
+  static PBackgroundParent*
   Alloc(ContentParent* aContent,
         Transport* aTransport,
         ProcessId aOtherProcess);
 
   static bool
   CreateBackgroundThread();
 
   static void
@@ -418,16 +422,20 @@ private:
   // Forwarded from BackgroundChild.
   static bool
   GetOrCreateForCurrentThread(nsIIPCBackgroundChildCreateCallback* aCallback);
 
   // Forwarded from BackgroundChild.
   static void
   CloseForCurrentThread();
 
+  // Forwarded from BackgroundChild.
+  static PBackgroundChild*
+  GetCurrentlyProcessingMessages();
+
   // Forwarded from BackgroundChildImpl.
   static BackgroundChildImpl::ThreadLocal*
   GetThreadLocalForCurrentThread();
 
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
@@ -869,16 +877,23 @@ intptr_t
 BackgroundParent::GetRawContentParentForComparison(
                                             PBackgroundParent* aBackgroundActor)
 {
   return ParentImpl::GetRawContentParentForComparison(aBackgroundActor);
 }
 
 // static
 PBackgroundParent*
+BackgroundParent::GetCurrentlyProcessingMessages()
+{
+  return ParentImpl::GetCurrentlyProcessingMessages();
+}
+
+// static
+PBackgroundParent*
 BackgroundParent::Alloc(ContentParent* aContent,
                         Transport* aTransport,
                         ProcessId aOtherProcess)
 {
   return ParentImpl::Alloc(aContent, aTransport, aOtherProcess);
 }
 
 // -----------------------------------------------------------------------------
@@ -939,16 +954,23 @@ BackgroundChild::GetOrCreateActorForBlob
 
 // static
 void
 BackgroundChild::CloseForCurrentThread()
 {
   ChildImpl::CloseForCurrentThread();
 }
 
+// static
+PBackgroundChild*
+BackgroundChild::GetCurrentlyProcessingMessages()
+{
+  return ChildImpl::GetCurrentlyProcessingMessages();
+}
+
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl Public Methods
 // -----------------------------------------------------------------------------
 
 // static
 BackgroundChildImpl::ThreadLocal*
 BackgroundChildImpl::GetThreadLocalForCurrentThread()
 {
@@ -1055,16 +1077,28 @@ ParentImpl::GetRawContentParentForCompar
     return intptr_t(-1);
   }
 
   return intptr_t(static_cast<nsIContentParent*>(actor->mContent.get()));
 }
 
 // static
 PBackgroundParent*
+ParentImpl::GetCurrentlyProcessingMessages()
+{
+  AssertIsOnBackgroundThread();
+
+  PBackgroundParent* actor = sCurrentlyProcessingMessagesBackgroundParent;
+  MOZ_ASSERT(actor);
+
+  return actor;
+}
+
+// static
+PBackgroundParent*
 ParentImpl::Alloc(ContentParent* aContent,
                   Transport* aTransport,
                   ProcessId aOtherProcess)
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
   MOZ_ASSERT(aTransport);
 
@@ -1790,16 +1824,29 @@ ChildImpl::CloseForCurrentThread()
   }
 
   // Clearing the thread local will synchronously close the actor.
   DebugOnly<PRStatus> status = PR_SetThreadPrivate(sThreadLocalIndex, nullptr);
   MOZ_ASSERT(status == PR_SUCCESS);
 }
 
 // static
+PBackgroundChild*
+ChildImpl::GetCurrentlyProcessingMessages()
+{
+  auto actor = static_cast<ChildImpl*>(ChildImpl::GetForCurrentThread());
+
+  if (!actor || !actor->mCurrentlyProcessingMessages) {
+    return nullptr;
+  }
+
+  return actor;
+}
+
+// static
 BackgroundChildImpl::ThreadLocal*
 ChildImpl::GetThreadLocalForCurrentThread()
 {
   MOZ_ASSERT(sThreadLocalIndex != kBadThreadLocalIndex,
              "BackgroundChild::Startup() was never called!");
 
   auto threadLocalInfo =
     static_cast<ThreadLocalInfo*>(PR_GetThreadPrivate(sThreadLocalIndex));
diff --git a/ipc/glue/BackgroundParent.h b/ipc/glue/BackgroundParent.h
--- a/ipc/glue/BackgroundParent.h
+++ b/ipc/glue/BackgroundParent.h
@@ -60,16 +60,22 @@ public:
 
   // Get a value that represents the ContentParent associated with the parent
   // actor for comparison. The value is not guaranteed to uniquely identify the
   // ContentParent after the ContentParent has died. This function may only be
   // called on the background thread.
   static intptr_t
   GetRawContentParentForComparison(PBackgroundParent* aBackgroundActor);
 
+  // Returns the PBackgroundParent that is currently processing messages. This
+  // function may only be called on the background thread, and only when a
+  // message is being processed.
+  static PBackgroundParent*
+  GetCurrentlyProcessingMessages();
+
 private:
   // Only called by ContentParent for cross-process actors.
   static PBackgroundParent*
   Alloc(ContentParent* aContent,
         Transport* aTransport,
         ProcessId aOtherProcess);
 };
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -3,26 +3,28 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundParentImpl.h"
 
 #include "BroadcastChannelParent.h"
 #include "FileDescriptorSetParent.h"
 #include "mozilla/AppProcessChecker.h"
 #include "mozilla/Assertions.h"
+#include "mozilla/AutoRestore.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/cache/PCacheParent.h"
 #include "mozilla/dom/cache/PCacheStorageParent.h"
 #include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "mozilla/layout/VsyncParent.h"
 #include "nsNetUtil.h"
 #include "nsRefPtr.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
@@ -74,16 +76,19 @@ public:
 } // anonymous namespace
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::BroadcastChannelParent;
 
+/* static */
+BackgroundParentImpl* BackgroundParentImpl::sCurrentlyProcessingMessagesBackgroundParent;
+
 BackgroundParentImpl::BackgroundParentImpl()
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
 
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundParentImpl);
 }
 
@@ -170,16 +175,46 @@ BackgroundParentImpl::DeallocPBackground
 
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
   return DeallocPBackgroundIDBFactoryParent(aActor);
 }
 
+
+PBackgroundPipeTransportParent*
+BackgroundParentImpl::AllocPBackgroundPipeTransportParent(const intptr_t& aCookie)
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+
+  intptr_t contentParentId = BackgroundParent::GetRawContentParentForComparison(this);
+
+  return detail::AllocPBackgroundPipeTransportParent(contentParentId, aCookie);
+}
+
+bool
+BackgroundParentImpl::RecvPBackgroundPipeTransportConstructor(PBackgroundPipeTransportParent* aActor,
+							      const intptr_t& aCookie)
+{
+  // Nothing to do.  Everything interesting happens in alloc.
+  return true;
+}
+
+bool
+BackgroundParentImpl::DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor)
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aActor);
+
+  return detail::DeallocPBackgroundPipeTransportParent(aActor);
+}
+
 auto
 BackgroundParentImpl::AllocPBlobParent(const BlobConstructorParams& aParams)
   -> PBlobParent*
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   if (NS_WARN_IF(aParams.type() !=
@@ -401,16 +436,33 @@ bool
 BackgroundParentImpl::DeallocPCacheStreamControlParent(PCacheStreamControlParent* aActor)
 {
   // The CacheStreamControlParent actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
+auto
+BackgroundParentImpl::OnMessageReceived(const Message& __msg) -> Result
+{
+  AutoRestore<BackgroundParentImpl*> autoRestore(sCurrentlyProcessingMessagesBackgroundParent);
+  sCurrentlyProcessingMessagesBackgroundParent = this;
+  return PBackgroundParent::OnMessageReceived(__msg);
+}
+
+auto
+BackgroundParentImpl::OnMessageReceived(const Message& __msg,
+                                        Message*& __reply) -> Result
+{
+  AutoRestore<BackgroundParentImpl*> autoRestore(sCurrentlyProcessingMessagesBackgroundParent);
+  sCurrentlyProcessingMessagesBackgroundParent = this;
+  return PBackgroundParent::OnMessageReceived(__msg, __reply);
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -51,16 +51,26 @@ protected:
   RecvPBackgroundIDBFactoryConstructor(PBackgroundIDBFactoryParent* aActor,
                                        const LoggingInfo& aLoggingInfo)
                                        MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundIDBFactoryParent(PBackgroundIDBFactoryParent* aActor)
                                      MOZ_OVERRIDE;
 
+  virtual PBackgroundPipeTransportParent*
+  AllocPBackgroundPipeTransportParent(const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  RecvPBackgroundPipeTransportConstructor(PBackgroundPipeTransportParent* aActor,
+					  const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor) MOZ_OVERRIDE;
+
   virtual PBlobParent*
   AllocPBlobParent(const BlobConstructorParams& aParams) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBlobParent(PBlobParent* aActor) MOZ_OVERRIDE;
 
   virtual PFileDescriptorSetParent*
   AllocPFileDescriptorSetParent(const FileDescriptor& aFileDescriptor)
@@ -102,14 +112,23 @@ protected:
   virtual bool
   DeallocPCacheParent(dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
 
   virtual dom::cache::PCacheStreamControlParent*
   AllocPCacheStreamControlParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPCacheStreamControlParent(dom::cache::PCacheStreamControlParent* aActor) MOZ_OVERRIDE;
+
+  virtual Result
+  OnMessageReceived(const Message& __msg) MOZ_OVERRIDE;
+
+  virtual Result
+  OnMessageReceived(const Message& __msg,
+                    Message*& __reply) MOZ_OVERRIDE;
+
+  static BackgroundParentImpl* sCurrentlyProcessingMessagesBackgroundParent;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/CrossProcessPipe.cpp b/ipc/glue/CrossProcessPipe.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/CrossProcessPipe.cpp
@@ -0,0 +1,1078 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * A CrossProcessPipe is a pipe between the main process and a child process.
+ * The pipe can flow in either direction, but it is not duplex (meaning that
+ * a given pipe can only flow in one direction).  nsICrossProcessPipe is the
+ * external facing interface we provide.
+ */
+
+#include "mozilla/ipc/CrossProcessPipe.h"
+
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundPipeTransportParent.h"
+#include "mozilla/ipc/PBackgroundPipeTransportChild.h"
+#include "mozilla/StaticMutex.h"
+#include "nsComponentManagerUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIEventTarget.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIIPCSerializableInputStream.h"
+#include "nsIPipe.h"
+#include "nsISupportsImpl.h"
+#include "nsStreamUtils.h"
+#include "nsThreadUtils.h"
+#include "nsXULAppAPI.h"
+
+namespace {
+
+class CrossProcessPipe MOZ_FINAL : public nsICrossProcessPipe
+{
+  typedef mozilla::ipc::PipeDirection PipeDirection;
+
+  nsCOMPtr<nsIAsyncInputStream> mInputStream;
+  nsCOMPtr<nsIAsyncOutputStream> mOutputStream;
+
+  ~CrossProcessPipe() {}
+
+public:
+  CrossProcessPipe() {}
+
+  void
+  InitializeStreams(intptr_t aContentParentId, PipeDirection aDirection);
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSICROSSPROCESSPIPE
+};
+
+// Handed out by CrossProcessPipe in the sending process for the other side's
+// stream.  All this knows how to do is serialize.  There's no reason this can't
+// be an output stream too, but we don't have any code that serializes output
+// streams today.
+class SerializationPlaceholderStream MOZ_FINAL : public nsIAsyncInputStream,
+                                                 public nsIIPCSerializableInputStream
+{
+  nsRefPtr<CrossProcessPipe> mCrossProcessPipe;
+
+public:
+  SerializationPlaceholderStream(CrossProcessPipe* aCrossProcessPipe)
+    : mCrossProcessPipe(aCrossProcessPipe)
+  {
+  }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+  NS_DECL_NSIASYNCINPUTSTREAM
+  NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
+};
+
+NS_IMPL_ISUPPORTS(SerializationPlaceholderStream,
+                  nsIAsyncInputStream,
+                  nsIInputStream,
+                  nsIIPCSerializableInputStream)
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Close()
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Available(uint64_t* aAvailableBytes)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Read(char* aBuf, uint32_t aCount,
+                                     uint32_t* aBytesRead)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::ReadSegments(nsWriteSegmentFun aWriter,
+                                             void* aClosure, uint32_t aCount,
+                                             uint32_t* aBytesRead)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::IsNonBlocking(bool* aIsNonBlocking)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::CloseWithStatus(nsresult aStatus)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::AsyncWait(nsIInputStreamCallback* aCallback,
+                                          uint32_t aFlags, uint32_t aRequestedCount,
+                                          nsIEventTarget* aEventTarget)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void
+SerializationPlaceholderStream::Serialize(mozilla::ipc::InputStreamParams& aParams,
+                                          FileDescriptorArray& aFileDesriptors)
+{
+  MOZ_ASSERT(mCrossProcessPipe);
+
+  mozilla::ipc::PipeInputStreamParams params;
+  params.pipeId() = (intptr_t)mCrossProcessPipe.get();
+
+  aParams = params;
+
+  // We can only be serialized once.  This also breaks the cycle the pipe has
+  // with us.
+  mCrossProcessPipe = nullptr;
+}
+
+bool
+SerializationPlaceholderStream::Deserialize(const mozilla::ipc::InputStreamParams& aParams,
+                                            const FileDescriptorArray& aFileDescriptors)
+{
+  MOZ_ASSERT_UNREACHABLE("Don't deserialize me!");
+  return false;
+}
+
+// The class for the "active" streams.  These are the streams that actually
+// support reading and writing, as opposed to just being serialized across the
+// process boundary.  When a SerializationPlaceholderStream crosses the process
+// boundary it comes out as an XPPActiveStream on the other side.
+//
+// The PBackgroundTransport must always be initiated from the child, because the
+// parent (PBackground) thread doesn't know where the other end of the transport
+// should be.  But the data can flow either direction.
+class XPPActiveStream : private mozilla::ipc::PBackgroundPipeTransportParent,
+                        private mozilla::ipc::PBackgroundPipeTransportChild,
+                        public nsIAsyncInputStream,
+                        public nsIAsyncOutputStream,
+                        public nsIIPCBackgroundChildCreateCallback
+{
+  typedef mozilla::ipc::PipeDirection PipeDirection;
+  typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
+
+  // If true, we're the parent actor, otherwise, we're the child actor.
+  const bool mInMainProcess;
+  const intptr_t mContentParentId;
+  const intptr_t mPipeId;
+  // Are we the sending or receiving side?
+  const PipeDirection mDirection;
+
+  // Things only touched on the transport thread.
+
+  // The event target we are doing the transport on.  In the main process this
+  // is the PBackground thread.  In the child it is whatever thread is using
+  // the stream (probably a stream transport service thread).  In the main
+  // process this will be null until the transport actor is setup.
+  nsCOMPtr<nsIEventTarget> mTransportThread;
+  PBackgroundChild* mBackgroundChild;
+
+  // Stream implementation variables touched on multiple threads, and protected
+  // by mLock.
+  // mIsTransportActive is only ever written to on the transport thread, so it's
+  // ok to read unlocked on the transport thread.
+  bool mIsTransportActive;
+  nsresult mResultCode;
+  bool mClosed;
+  FallibleTArray<unsigned char> mData;
+  uint32_t mRequestedAsyncWaitCount;
+  nsCOMPtr<nsIInputStreamCallback> mInputAsyncWaitCallback;
+  nsCOMPtr<nsIOutputStreamCallback> mOutputAsyncWaitCallback;
+
+  mozilla::Mutex mLock;
+
+  ~XPPActiveStream();
+
+  virtual bool
+  Recv__delete__(const nsresult& aResult) MOZ_OVERRIDE;
+
+  virtual bool
+  RecvChunk(InfallibleTArray<unsigned char>&& aData) MOZ_OVERRIDE;
+
+  virtual void
+  ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
+
+  void
+  CloseTransport(nsresult aRv);
+
+  void
+  FlushTransport();
+
+public:
+  static mozilla::StaticMutex sInFlightTableLock;
+  static nsAutoPtr<InfallibleTArray<nsRefPtr<XPPActiveStream>>> sInFlightTable;
+
+  PBackgroundPipeTransportParent*
+  AsParent() const {
+    MOZ_ASSERT(mInMainProcess);
+    return const_cast<XPPActiveStream*>(this);
+  }
+
+  static XPPActiveStream*
+  FromParent(PBackgroundPipeTransportParent* aParent) {
+    auto self = static_cast<XPPActiveStream*>(aParent);
+    MOZ_ASSERT(self->mInMainProcess);
+    return self;
+  }
+
+  XPPActiveStream(intptr_t aContentParentId, intptr_t aPipeId, PipeDirection aDirection)
+    : mInMainProcess(XRE_GetProcessType() == GeckoProcessType_Default)
+    , mContentParentId(aContentParentId)
+    , mPipeId(aPipeId)
+    , mDirection(aDirection)
+    , mBackgroundChild(nullptr)
+    , mIsTransportActive(false)
+    , mResultCode(NS_OK)
+    , mClosed(false)
+    , mRequestedAsyncWaitCount(0)
+    , mLock("XPPActiveStream lock")
+  {
+  }
+
+  intptr_t
+  ContentParentId() const {
+    return mContentParentId;
+  }
+
+  intptr_t
+  PipeId() const {
+    return mPipeId;
+  }
+
+  bool IsOnTransportThread() const
+  {
+    bool isOnCurrentThread = false;
+    MOZ_ALWAYS_SUCCEEDS(mTransportThread->IsOnCurrentThread(&isOnCurrentThread));
+    return isOnCurrentThread;
+  }
+
+  void
+  AssertIsOnTransportThread() const
+  {
+#ifdef DEBUG
+    if (mTransportThread) {
+      MOZ_ASSERT(IsOnTransportThread());
+    }
+    else {
+      // If the transport thread is not setup yet we can't check the threading,
+      // but we can at least ensure that we're allowed to be unset.
+      MOZ_ASSERT(!mIsTransportActive);
+    }
+#endif
+  }
+
+  // Called to initialize mTransportThread.
+  void
+  NoteTransportThread()
+  {
+    MOZ_ASSERT(!mTransportThread);
+
+    // In the main process we must always be on the PBackground thread.
+    // But in a child process we could be on any thread.
+    if (mInMainProcess) {
+      mozilla::ipc::AssertIsOnBackgroundThread();
+    }
+
+    mTransportThread = do_GetCurrentThread();
+  }
+
+  bool
+  RecvIPDLConstructor();
+
+  bool
+  IsReceiving() const
+  {
+    return mDirection == mozilla::ipc::Receiving;
+  }
+
+  bool
+  IsSending() const
+  {
+    return mDirection == mozilla::ipc::Sending;
+  }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  // We can't use the XPCOM macros directly, because nsIInputStream and
+  // nsIOutputStream have some of the same member functions.
+  // nsIInputStream
+  NS_IMETHOD
+  Close() MOZ_OVERRIDE
+  {
+    return CloseWithStatus(NS_OK);
+  }
+
+  NS_IMETHOD
+  Available(uint64_t* aBytesAvailable) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  Read(char* aBuf, uint32_t aCount, uint32_t* aBytesRead) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  ReadSegments(nsWriteSegmentFun aWriter, void* aClosure, uint32_t aCount,
+               uint32_t* aBytesRead) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  IsNonBlocking(bool* aIsNonBlocking) MOZ_OVERRIDE;
+
+  // The parts of nsIOutputStream that are not shared
+  NS_IMETHOD
+  Flush(void) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  Write(const char* aBuf, uint32_t aCount,
+        uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  WriteFrom(nsIInputStream* aFromStream, uint32_t aCount,
+            uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  WriteSegments(nsReadSegmentFun aReader, void* aClosure, uint32_t aCount,
+                uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  // nsIAsyncInputStream
+  NS_IMETHOD
+  CloseWithStatus(nsresult aStatus) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  AsyncWait(nsIInputStreamCallback* aCallback, uint32_t aFlags,
+            uint32_t aRequestedCount,
+            nsIEventTarget* aEventTarget) MOZ_OVERRIDE;
+
+  // The parts of nsIAsyncOutputStream that are not shared
+  NS_IMETHOD
+  AsyncWait(nsIOutputStreamCallback* aCallback, uint32_t aFlags,
+            uint32_t aRequestedCount,
+            nsIEventTarget* aEventTarget) MOZ_OVERRIDE;
+
+  NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
+
+  nsresult
+  InitializeTransport();
+
+  bool
+  IPDLConstruct(mozilla::ipc::PBackgroundChild* aActor);
+
+  void
+  MaybeFireCallbacks();
+};
+
+/*static*/
+mozilla::StaticMutex XPPActiveStream::sInFlightTableLock;
+/*static*/
+nsAutoPtr<InfallibleTArray<nsRefPtr<XPPActiveStream>>> XPPActiveStream::sInFlightTable;
+
+XPPActiveStream::~XPPActiveStream() {
+  if (XRE_GetProcessType() == GeckoProcessType_Default) {
+    mozilla::StaticMutexAutoLock autoLock(sInFlightTableLock);
+    if (sInFlightTable->Length() == 0) {
+      sInFlightTable = nullptr;
+    }
+  }
+}
+
+NS_IMPL_ADDREF(XPPActiveStream)
+NS_IMPL_RELEASE(XPPActiveStream)
+
+NS_INTERFACE_MAP_BEGIN(XPPActiveStream)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAsyncInputStream)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIInputStream, IsReceiving())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAsyncInputStream, IsReceiving())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIOutputStream, IsSending())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAsyncOutputStream, IsSending())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIIPCBackgroundChildCreateCallback, !mInMainProcess)
+NS_INTERFACE_MAP_END
+
+bool
+XPPActiveStream::Recv__delete__(const nsresult& aResult)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  // XXXkhuey should CloseWithStatus
+  mResultCode = aResult;
+  mClosed = true;
+  MaybeFireCallbacks();
+  mIsTransportActive = false;
+
+  return true;
+}
+
+bool
+XPPActiveStream::RecvChunk(InfallibleTArray<unsigned char>&& aData)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(IsReceiving());
+  MOZ_ASSERT(mIsTransportActive);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  // XXXkhuey IPDL move refs would be really useful here ...  
+  mData.AppendElements(aData);
+
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+void
+XPPActiveStream::ActorDestroy(ActorDestroyReason aWhy)
+{
+  AssertIsOnTransportThread();
+
+  // If the transport was already shutdown we don't care.
+  if (!mIsTransportActive) {
+    return;
+  }
+
+  // But if the transport was interrupted we need to close things.
+  // XXXtodo close things
+  mIsTransportActive = false;
+}
+
+void
+XPPActiveStream::CloseTransport(nsresult aRv)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  if (mInMainProcess) {
+    if (!PBackgroundPipeTransportParent::Send__delete__(this, aRv)) {
+      NS_WARNING("Send__delete__ failed!");
+    }
+  }
+  else {
+    if (!PBackgroundPipeTransportChild::Send__delete__(this, aRv)) {
+      NS_WARNING("Send__delete__ failed!");
+    }
+  }
+}
+
+void
+XPPActiveStream::FlushTransport()
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  nsTArray<unsigned char> dataToSend;
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+    dataToSend = mozilla::Move(mData);
+  }
+
+  if (mInMainProcess) {
+    if (!PBackgroundPipeTransportParent::SendChunk(dataToSend)) {
+      NS_WARNING("SendChunk failed!");
+    }
+  }
+  else {
+    if (!PBackgroundPipeTransportChild::SendChunk(dataToSend)) {
+      NS_WARNING("SendChunk failed!");
+    }
+  }
+}
+
+NS_IMETHODIMP
+XPPActiveStream::CloseWithStatus(nsresult aRv)
+{
+  if (mClosed) {
+    return NS_OK;
+  }
+
+  // If we are the sending end, we close the transport here.  If we are the
+  // receiving end, we just ignore anything further that we receive.  We could
+  // add support for shutting the transport but it would require not using the
+  // __delete__ message to signal the completion of the stream.
+  if (IsSending()) {
+    Flush();
+
+    {
+      mozilla::MutexAutoLock lock(mLock);
+      mClosed = true;
+      mResultCode = aRv;
+    }
+
+    if (mIsTransportActive) {
+      if (IsOnTransportThread()) {
+        CloseTransport(aRv);
+      }
+      else {
+        nsCOMPtr<nsIRunnable> event =
+          NS_NewRunnableMethodWithArg<nsresult>(this,
+                                                &XPPActiveStream::CloseTransport,
+                                                aRv);
+        mTransportThread->Dispatch(event, 0);
+      }
+    }
+
+    return NS_OK;
+  }
+
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::IsNonBlocking(bool* aIsNonBlocking)
+{
+  // We can't assert that we're on the transport thread here, this may be tested
+  // on one thread to determine whether or not to send us to another thread.
+  MOZ_ASSERT(aIsNonBlocking);
+
+  *aIsNonBlocking = true;
+
+  return NS_OK;
+}
+
+bool
+XPPActiveStream::RecvIPDLConstructor()
+{
+  MOZ_ASSERT(mInMainProcess);
+
+  NoteTransportThread();
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  mIsTransportActive = true;
+
+  // And if we're waiting, begin.
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Available(uint64_t* aBytesAvailable)
+{
+  MOZ_ASSERT(IsReceiving());
+
+  mozilla::MutexAutoLock lock(mLock);
+  *aBytesAvailable = mData.Length();
+
+  if (*aBytesAvailable == 0 && !mIsTransportActive) {
+    if (!mClosed) {
+      return NS_OK;
+    }
+
+    return mResultCode == NS_OK ? NS_BASE_STREAM_CLOSED : mResultCode;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Read(char* aBuf, uint32_t aCount, uint32_t* aBytesRead)
+{
+  return ReadSegments(NS_CopySegmentToBuffer, aBuf, aCount, aBytesRead);
+}
+
+NS_IMETHODIMP
+XPPActiveStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                              uint32_t aCount, uint32_t* aBytesRead)
+{
+  MOZ_ASSERT(IsReceiving());
+
+  *aBytesRead = 0;
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    auto countToCopy = std::min<uint32_t>(aCount, mData.Length());
+    while (countToCopy) {
+      uint32_t countCopied = 0;
+      nsresult rv = aWriter(this, aClosure, (char*)mData.Elements(), *aBytesRead,
+                            countToCopy, &countCopied);
+
+      if (NS_FAILED(rv) || countCopied == 0) {
+        // We're done.  Don't propagate errors.
+        return NS_OK;
+      }
+
+      MOZ_ASSERT(countCopied <= countToCopy);
+      mData.RemoveElementsAt(0, countCopied);
+      countToCopy -= countCopied;
+      *aBytesRead += countCopied;
+    }
+  }
+
+  if (*aBytesRead > 0) {
+    return NS_OK;
+  }
+
+  if (mClosed) {
+    return NS_OK;
+  }
+
+  // Otherwise the transport is not open or we're waiting for data.
+  return NS_BASE_STREAM_WOULD_BLOCK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Flush()
+{
+  MOZ_ASSERT(IsSending());
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    if (mClosed) {
+      return NS_BASE_STREAM_CLOSED;
+    }
+
+    if (!mIsTransportActive) {
+      // Can't flush if we're not open.
+      return NS_BASE_STREAM_WOULD_BLOCK;
+    }
+  }
+
+  if (IsOnTransportThread()) {
+    FlushTransport();
+  }
+  else {
+    nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &XPPActiveStream::FlushTransport);
+    mTransportThread->Dispatch(event, 0);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Write(const char* aBuf, uint32_t aCount,
+                       uint32_t* aBytesWritten)
+{
+  return WriteSegments(NS_CopySegmentToBuffer, (void*)aBuf, aCount, aBytesWritten);
+}
+
+NS_IMETHODIMP
+XPPActiveStream::WriteFrom(nsIInputStream* aFromStream, uint32_t aCount,
+                           uint32_t* aBytesWritten)
+{
+  MOZ_ASSERT(IsSending());
+
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::WriteSegments(nsReadSegmentFun aReader, void* aClosure,
+                               uint32_t aCount, uint32_t* aBytesWritten)
+{
+  MOZ_ASSERT(IsSending());
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    if (mClosed) {
+      return NS_BASE_STREAM_CLOSED;
+    }
+
+    if (!mIsTransportActive) {
+      return NS_BASE_STREAM_WOULD_BLOCK;
+    }
+
+    const uint32_t originalLength = mData.Length();
+    *aBytesWritten = originalLength;
+
+    while (aCount) {
+      uint32_t countRead = 0;
+      uint32_t oldLength = mData.Length();
+      mData.SetLength(oldLength + aCount);
+
+      nsresult rv = aReader(this, aClosure, (char*)mData.Elements(),
+                            *aBytesWritten, aCount, &countRead);
+      if (NS_FAILED(rv) || countRead == 0) {
+        mData.SetLength(oldLength);
+        *aBytesWritten -= originalLength;
+        return NS_OK;
+      }
+
+      mData.SetLength(oldLength + countRead);
+      aCount -= countRead;
+      *aBytesWritten += countRead;
+    }
+
+    *aBytesWritten -= originalLength;
+  }
+
+  // XXXkhuey queue flush.
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::AsyncWait(nsIInputStreamCallback* aCallback, uint32_t aFlags,
+                           uint32_t aRequestedCount, nsIEventTarget* aEventTarget)
+{
+  NS_WARNING("AsyncWait");
+  MOZ_ASSERT(IsReceiving());
+
+  nsCOMPtr<nsIEventTarget> currentThread = do_GetCurrentThread();
+  if (aEventTarget && currentThread != aEventTarget) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mOutputAsyncWaitCallback);
+  if (NS_WARN_IF(mInputAsyncWaitCallback)) {
+    MOZ_ASSERT(mResultCode == NS_OK); // We shouldn't be closed if we're waiting
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // WAIT_CLOSURE_ONLY is kind of silly.
+  if (aFlags & nsIAsyncInputStream::WAIT_CLOSURE_ONLY) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  MOZ_ASSERT(!aFlags);
+
+  // If aRequestedCount is 0, we're allowed to wait for any amount.  Let's pick 1.
+  if (aRequestedCount == 0) {
+    aRequestedCount = 1;
+  }
+
+  mRequestedAsyncWaitCount = aRequestedCount;
+
+  mInputAsyncWaitCallback =
+    NS_NewInputStreamReadyEvent(aCallback, currentThread);
+
+  if (!mIsTransportActive && !mClosed && !mInMainProcess) {
+    InitializeTransport();
+  }
+
+  MaybeFireCallbacks();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::AsyncWait(nsIOutputStreamCallback* aCallback, uint32_t aFlags,
+                           uint32_t aRequestedCount, nsIEventTarget* aEventTarget)
+{
+  MOZ_ASSERT(IsSending());
+
+  nsCOMPtr<nsIEventTarget> currentThread = do_GetCurrentThread();
+  if (aEventTarget && currentThread != aEventTarget) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mInputAsyncWaitCallback);
+  if (NS_WARN_IF(mOutputAsyncWaitCallback)) {
+    MOZ_ASSERT(mResultCode == NS_OK); // We shouldn't be closed if we're waiting
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // WAIT_CLOSURE_ONLY is kind of silly.
+  if (aFlags & nsIAsyncOutputStream::WAIT_CLOSURE_ONLY) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  MOZ_ASSERT(!aFlags);
+
+  // If aRequestedCount is 0, we're allowed to wait for any amount.  Let's pick 1.
+  if (aRequestedCount == 0) {
+    aRequestedCount = 1;
+  }
+
+  mRequestedAsyncWaitCount = aRequestedCount;
+
+  mOutputAsyncWaitCallback =
+    NS_NewOutputStreamReadyEvent(aCallback, currentThread);
+
+  if (!mIsTransportActive && !mClosed && !mInMainProcess) {
+    InitializeTransport();
+  }
+
+  MaybeFireCallbacks();
+
+  return NS_OK;
+}
+
+void
+XPPActiveStream::ActorCreated(PBackgroundChild* aActor)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(!mBackgroundChild);
+  MOZ_ASSERT(aActor);
+
+  mBackgroundChild = aActor;
+  IPDLConstruct(mBackgroundChild);
+}
+
+void
+XPPActiveStream::ActorFailed()
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(!mBackgroundChild);
+
+  MOZ_ASSERT_UNREACHABLE("");
+}
+
+nsresult
+XPPActiveStream::InitializeTransport()
+{
+  NS_WARNING("Init transport");
+  // The transport is always initialized in the child.
+  // XXXkhuey guard against one call while another is in flight!
+  MOZ_ASSERT(!mInMainProcess);
+  MOZ_ASSERT(!mIsTransportActive);
+
+  NoteTransportThread();
+
+  // XXXkhuey we should short circuit this if the BackgroundChild already exists
+  // but we have to be careful not to deadlock.
+  if (!mozilla::ipc::BackgroundChild::GetOrCreateForCurrentThread(this)) {
+    CloseWithStatus(NS_ERROR_FAILURE);
+    return NS_ERROR_FAILURE;
+  }
+    
+  return NS_OK;
+}
+
+bool
+XPPActiveStream::IPDLConstruct(PBackgroundChild* aActor)
+{
+  // Construction must always be initiated from the child.
+  MOZ_ASSERT(!mInMainProcess);
+  MOZ_ASSERT(mPipeId);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mIsTransportActive);
+
+  // If this fails, we'll abort inside IPDL.
+  MOZ_ALWAYS_TRUE(aActor->SendPBackgroundPipeTransportConstructor(this,
+                                                                  mPipeId));
+
+  mIsTransportActive = true;
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+void
+XPPActiveStream::MaybeFireCallbacks()
+{
+  NS_WARNING("Maybe fire callbacks");
+  mLock.AssertCurrentThreadOwns();
+
+  if (IsReceiving()) {
+    MOZ_ASSERT(!mOutputAsyncWaitCallback);
+    if (mInputAsyncWaitCallback && (mData.Length() >= mRequestedAsyncWaitCount ||
+                                    mClosed)) {
+      NS_WARNING("Firing callback");
+      mInputAsyncWaitCallback->OnInputStreamReady(this);
+      mRequestedAsyncWaitCount = 0;
+      mInputAsyncWaitCallback = nullptr;
+    }
+  } else if (IsSending()) {
+    MOZ_ASSERT(!mInputAsyncWaitCallback);
+    if (mOutputAsyncWaitCallback && (mRequestedAsyncWaitCount == 0 ||
+                                     mIsTransportActive)) {
+      // The requested count is pointless for writing, since once the transport
+      // layer is active we can write as much as we want.
+      NS_WARNING("Firing callback");
+      mOutputAsyncWaitCallback->OnOutputStreamReady(this);
+      mRequestedAsyncWaitCount = 0;
+      mOutputAsyncWaitCallback = nullptr;
+    }
+  } else {
+    MOZ_ASSERT_UNREACHABLE("");
+  }
+}
+
+NS_IMPL_ISUPPORTS(CrossProcessPipe, nsICrossProcessPipe)
+
+already_AddRefed<XPPActiveStream>
+GetOrCreatePipeStreamForId(intptr_t aContentParentId, intptr_t aPipeId, mozilla::ipc::PipeDirection aDirection)
+{
+  if (XRE_GetProcessType() != GeckoProcessType_Default) {
+    NS_WARNING("Created new stream in non-default process");
+    MOZ_ASSERT(!aContentParentId);
+    nsRefPtr<XPPActiveStream> stream =
+      new XPPActiveStream(aContentParentId, aPipeId, aDirection);
+    return stream.forget();
+  }
+
+  // Otherwise we must consult the table.
+  mozilla::StaticMutexAutoLock autoLock(XPPActiveStream::sInFlightTableLock);
+  if (XPPActiveStream::sInFlightTable) {
+    for (uint32_t length = XPPActiveStream::sInFlightTable->Length(), i = 0; i < length; ++i) {
+      nsRefPtr<XPPActiveStream>& stream = XPPActiveStream::sInFlightTable->ElementAt(i);
+      if (stream->PipeId() == aPipeId) {
+        if (stream->ContentParentId() == aContentParentId) {
+          NS_WARNING("Found existing stream in default process");
+          nsRefPtr<XPPActiveStream> addRefedStream = stream;
+          return addRefedStream.forget();
+        } else {
+          NS_WARNING("Matched pipe id but not ContentParent id, something might be wrong");
+        }
+      }
+    }
+  } else {
+    XPPActiveStream::sInFlightTable = new InfallibleTArray<nsRefPtr<XPPActiveStream>>();
+  }
+
+  NS_WARNING("Created new stream in default process");
+  // Not in the table, create a new one.
+  nsRefPtr<XPPActiveStream> stream =
+    new XPPActiveStream(aContentParentId, aPipeId, aDirection);
+  XPPActiveStream::sInFlightTable->AppendElement(stream);
+  return stream.forget();
+}
+
+void
+CrossProcessPipe::InitializeStreams(intptr_t aContentParentId,
+                                    PipeDirection aDirection)
+{
+  MOZ_ASSERT(!mInputStream && !mOutputStream);
+
+  if (aDirection == mozilla::ipc::Sending) {
+    // If we're sending, the output stream is "active" and the input stream is
+    // just a serialization placeholder
+    mInputStream = new SerializationPlaceholderStream(this);
+    intptr_t id = reinterpret_cast<intptr_t>(this);
+    mOutputStream = GetOrCreatePipeStreamForId(aContentParentId, id, aDirection);
+    // XXX assert created?
+  }
+  else {
+    MOZ_CRASH("Implement me!");
+  }
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::Init(nsISupports* aContentParent, bool aIsSending)
+{
+  if (mInputStream || mOutputStream) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  nsCOMPtr<mozilla::dom::nsIContentParent> contentParent = do_QueryInterface(aContentParent);
+  if (aContentParent && !contentParent) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  InitializeStreams(reinterpret_cast<intptr_t>(contentParent.get()),
+                    aIsSending ? mozilla::ipc::Sending
+                               : mozilla::ipc::Receiving);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::GetInputStream(nsIAsyncInputStream** aInputStream)
+{
+  if (!mInputStream) {
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+
+  nsCOMPtr<nsIAsyncInputStream> inputStream = mInputStream;
+  inputStream.forget(aInputStream);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::GetOutputStream(nsIAsyncOutputStream** aOutputStream)
+{
+  if (!mOutputStream) {
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+
+  nsCOMPtr<nsIAsyncOutputStream> outputStream = mOutputStream;
+  outputStream.forget(aOutputStream);
+
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace ipc {
+
+already_AddRefed<nsICrossProcessPipe>
+CreateCrossProcessPipe(PipeDirection aDirection)
+{
+  nsRefPtr<CrossProcessPipe> xpp = new CrossProcessPipe();
+  return xpp.forget();
+}
+
+namespace detail {
+
+nsresult
+XPCOMCreateCrossProcessPipe(nsISupports* aOuter,
+                            REFNSIID aIID,
+                            void** aOutparam)
+{
+  if (aOuter) {
+    return NS_ERROR_NO_AGGREGATION;
+  }
+
+  nsRefPtr<CrossProcessPipe> xpp = new CrossProcessPipe();
+  return xpp->QueryInterface(aIID, aOutparam);
+}
+
+PBackgroundPipeTransportParent*
+AllocPBackgroundPipeTransportParent(const intptr_t& aContentParentId, const intptr_t& aPipeId)
+{
+  NS_WARNING("AllocPBackgroundPipeTransportParent");
+  nsRefPtr<XPPActiveStream> stream = GetOrCreatePipeStreamForId(aContentParentId, aPipeId, mozilla::ipc::Receiving);
+
+  MOZ_ASSERT(stream->ContentParentId() == aContentParentId && stream->PipeId() == aPipeId);
+  if (!stream->RecvIPDLConstructor()) {
+    return nullptr;
+  }
+
+  return stream.forget().take()->AsParent(); // Owned by IPDL now.
+}
+
+bool
+DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor)
+{
+  nsRefPtr<XPPActiveStream> stream =
+    dont_AddRef(XPPActiveStream::FromParent(aActor));
+
+  // XXXkhuey should we check the table to see if the stream is still in it?
+  // That could happen if the stream is never serialized.
+
+  return true;
+}
+
+// The constructor only goes from child to parent, so we don't need an
+// AllocPBackgroundPipeTransportChild.
+
+bool
+DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor)
+{
+  return false;
+}
+
+already_AddRefed<nsIInputStream>
+GetOrCreatePipeInputStreamForId(intptr_t aContentParentId, intptr_t aPipeId)
+{
+  return GetOrCreatePipeStreamForId(aContentParentId, aPipeId,
+                                    mozilla::ipc::Receiving).downcast<nsIInputStream>();
+}
+
+} // namespace detail
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/CrossProcessPipe.h b/ipc/glue/CrossProcessPipe.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/CrossProcessPipe.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsCOMPtr.h"
+#include "nsICrossProcessPipe.h"
+
+class nsIInputStream;
+
+namespace mozilla {
+namespace ipc {
+
+enum PipeDirection {
+  Sending,
+  Receiving
+};
+
+/**
+ * Create a new CrossProcessPipe.  This pipe provides input and output streams,
+ * and the input stream can be serialized across IPDL.
+ * The init method must be called before using it.
+ */
+already_AddRefed<nsICrossProcessPipe>
+CreateCrossProcessPipe(PipeDirection aDirection);
+
+// Implementation details
+
+class PBackgroundPipeTransportParent;
+class PBackgroundPipeTransportChild;
+
+namespace detail {
+
+#define NS_CROSSPROCESSPIPE_CID \
+  { 0x072e39cd, 0x7dbb, 0x408f, \
+    { 0x83, 0x15, 0x4e, 0xf0, 0xbb, 0xba, 0x8a, 0x9d } }
+
+
+#define NS_CROSSPROCESSPIPE_CONTRACTID "@mozilla.org/crossprocesspipe;1"
+
+nsresult
+XPCOMCreateCrossProcessPipe(nsISupports* aOuter,
+                            REFNSIID aIID,
+                            void** aResult);
+
+PBackgroundPipeTransportParent*
+AllocPBackgroundPipeTransportParent(const intptr_t& aContentParentId,
+                                    const intptr_t& aPipeId);
+
+bool
+DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor);
+
+// The constructor only goes from child to parent, so we don't need an
+// AllocPBackgroundPipeTransportChild.
+
+bool
+DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor);
+
+already_AddRefed<nsIInputStream>
+GetOrCreatePipeInputStreamForId(intptr_t aContentParent, intptr_t aPipeId);
+
+} // namespace detail
+} // namespace ipc
+} // namspace mozilla
diff --git a/ipc/glue/InputStreamParams.ipdlh b/ipc/glue/InputStreamParams.ipdlh
--- a/ipc/glue/InputStreamParams.ipdlh
+++ b/ipc/glue/InputStreamParams.ipdlh
@@ -48,26 +48,34 @@ struct RemoteInputStreamParams
 // XXX This may only be used for same-process inter-thread communication! The
 //     value should be reinterpret_cast'd to nsIInputStream. It carries a
 //     reference.
 struct SameProcessInputStreamParams
 {
   intptr_t addRefedInputStream;
 };
 
+struct PipeInputStreamParams
+{
+  // This is a pointer to the pipe in the other process, but we only ever use it
+  // as an identifier so it's not dangerous.
+  intptr_t pipeId;
+};
+
 union InputStreamParams
 {
   StringInputStreamParams;
   FileInputStreamParams;
   PartialFileInputStreamParams;
   BufferedInputStreamParams;
   MIMEInputStreamParams;
   MultiplexInputStreamParams;
   RemoteInputStreamParams;
   SameProcessInputStreamParams;
+  PipeInputStreamParams;
 };
 
 union OptionalInputStreamParams
 {
   void_t;
   InputStreamParams;
 };
 
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -5,16 +5,17 @@
 #include "InputStreamUtils.h"
 
 #include "nsIIPCSerializableInputStream.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/ipc/BlobParent.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
 #include "nsID.h"
 #include "nsIXULRuntime.h"
 #include "nsMIMEInputStream.h"
 #include "nsMultiplexInputStream.h"
 #include "nsNetCID.h"
 #include "nsStringStream.h"
@@ -134,16 +135,52 @@ DeserializeInputStream(const InputStream
 
       stream = dont_AddRef(
         reinterpret_cast<nsIInputStream*>(params.addRefedInputStream()));
       MOZ_ASSERT(stream);
 
       return stream.forget();
     }
 
+    case InputStreamParams::TPipeInputStreamParams: {
+      NS_WARNING("Got stuff, deserializing");
+      MOZ_ASSERT(aFileDescriptors.IsEmpty());
+
+      const PipeInputStreamParams& params =
+	aParams.get_PipeInputStreamParams();
+
+      // The tricky part about pipes is that we have to connect the transport
+      // actor to the serialized pipe.  This isn't a problem if we're on the
+      // child side though, since the transport actor is always created from
+      // the child.
+      intptr_t contentParentId = 0;
+      if (XRE_GetProcessType() == GeckoProcessType_Default) {
+	// If we're on the background thread, we must have a PBackgroundParent.
+	if (IsOnBackgroundThread()) {
+	  NS_WARNING("Got PBackground contentParent");
+          contentParentId = BackgroundParent::GetRawContentParentForComparison(BackgroundParent::GetCurrentlyProcessingMessages());
+	} else if (NS_IsMainThread()) {
+	  auto contentParent = ContentParent::GetCurrentlyProcessingMessages();
+	  contentParentId = (intptr_t)static_cast<nsIContentParent*>(contentParent);
+	  NS_WARNING("Got ContentParent contentParent");
+	}
+	if (!contentParentId) {
+	  // Else we must be on a BackgroundChild.
+	  // XXXkhuey assert that.
+	  NS_WARNING("Got nothing");
+	}
+      }
+
+      nsCOMPtr<nsIInputStream> stream =
+	detail::GetOrCreatePipeInputStreamForId(contentParentId, params.pipeId());
+      MOZ_ASSERT(stream);
+
+      return stream.forget();
+    }
+
     default:
       MOZ_ASSERT(false, "Unknown params!");
       return nullptr;
   }
 
   MOZ_ASSERT(serializable);
 
   if (!serializable->Deserialize(aParams, aFileDescriptors)) {
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,13 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
+include protocol PBackgroundPipeTransport;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PBroadcastChannel;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PVsync;
@@ -19,16 +20,17 @@ include PBackgroundIDBSharedTypes;
 using mozilla::dom::cache::Namespace from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
+  manages PBackgroundPipeTransport;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PVsync;
@@ -45,15 +47,19 @@ parent:
 
   PCacheStorage(Namespace aNamespace, PrincipalInfo aPrincipalInfo);
 
 child:
   PCache();
   PCacheStreamControl();
 
 both:
+  // The cookie is used to match up the transport on the background thread and
+  // the serialized stream that might come over on the main thread.
+  PBackgroundPipeTransport(intptr_t aCookie);
+
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
 };
 
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/glue/PBackgroundPipeTransport.ipdl b/ipc/glue/PBackgroundPipeTransport.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PBackgroundPipeTransport.ipdl
@@ -0,0 +1,27 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+namespace mozilla {
+namespace ipc {
+
+async protocol PBackgroundPipeTransport
+{
+  manager PBackground;
+
+both:
+  // PBackgroundPipeTransport is always constructed from the child process,
+  // but once that is complete all method calls initiate from the sending side.
+
+  // Deletion of the protocol signals the end of the stream, if data was ever
+  // sent, or the destruction of the sending side machinery, if it was not.
+  __delete__(nsresult rv);
+
+  // Send data through the pipe.
+  Chunk(uint8_t[] aData);
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -1,26 +1,33 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+XPIDL_SOURCES += [
+    'nsICrossProcessPipe.idl',
+]
+
+XPIDL_MODULE = 'ipc_glue'
+
 EXPORTS += [
     'nsIIPCBackgroundChildCreateCallback.h',
     'nsIIPCSerializableInputStream.h',
     'nsIIPCSerializableURI.h',
 ]
 
 EXPORTS.mozilla.ipc += [
     'BackgroundChild.h',
     'BackgroundParent.h',
     'BackgroundUtils.h',
     'BrowserProcessSubThread.h',
     'CrossProcessMutex.h',
+    'CrossProcessPipe.h',
     'FileDescriptor.h',
     'FileDescriptorSetChild.h',
     'FileDescriptorSetParent.h',
     'FileDescriptorUtils.h',
     'GeckoChildProcessHost.h',
     'InputStreamUtils.h',
     'IOThreadChild.h',
     'MessageChannel.h',
@@ -133,16 +140,17 @@ LOCAL_INCLUDES += [
     '/dom/broadcastchannel',
     '/dom/indexedDB',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
+    'PBackgroundPipeTransport.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
     'URIParams.ipdlh',
 ]
 
@@ -165,8 +173,14 @@ LOCAL_INCLUDES += [
 ]
 
 if CONFIG['OS_ARCH'] == 'WINNT':
     LOCAL_INCLUDES += [
         '/security/sandbox/win/src/sandboxbroker',
     ]
 
 FAIL_ON_WARNINGS = True
+
+XPCSHELL_TESTS_MANIFESTS += ['unit/xpcshell.ini']
+
+SOURCES += [
+    'CrossProcessPipe.cpp',
+]
diff --git a/ipc/glue/nsICrossProcessPipe.idl b/ipc/glue/nsICrossProcessPipe.idl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/nsICrossProcessPipe.idl
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+interface nsIAsyncInputStream;
+interface nsIAsyncOutputStream;
+
+/**
+ * Like nsIPipe, except with the ends in different processes.
+ */
+[builtinclass, scriptable, uuid(e63d5c58-5086-4a1c-8b97-980a05deeb8e)]
+interface nsICrossProcessPipe : nsISupports
+{
+    /**
+     * initialize this pipe
+     *
+     * @param contentParent
+     *        the ContentParent the pipe belongs to.
+     * @param sending
+     *        true if the pipe is sending (that is, the output stream will be
+     *        used in the this process and the input stream will be serialized),
+     *        false if the pipe is receiving.
+     */
+    void init(in nsISupports contentParent, in boolean sending);
+
+    /**
+     * The pipe's input end.  If the pipe is sending this is only useful for
+     * serializing via IPDL.
+     */
+    readonly attribute nsIAsyncInputStream inputStream;
+
+    /**
+     * The pipe's output end.  If the pipe is receiving this is only useful for
+     * serializing via IPDL.
+     */
+    readonly attribute nsIAsyncOutputStream outputStream;
+};
diff --git a/ipc/glue/unit/test_crossProcessPipe.js b/ipc/glue/unit/test_crossProcessPipe.js
new file mode 100644
--- /dev/null
+++ b/ipc/glue/unit/test_crossProcessPipe.js
@@ -0,0 +1,250 @@
+const { 'classes': Cc, 'interfaces': Ci, 'results': Cr, 'utils': Cu } = Components;
+
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+const gIsInChild = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime)
+                     .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;
+
+let mm = gIsInChild ?
+              Cc["@mozilla.org/childprocessmessagemanager;1"].getService(Ci.nsIMessageSender) :
+              Cc["@mozilla.org/parentprocessmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
+
+function newXPP() {
+  return Cc["@mozilla.org/crossprocesspipe;1"].createInstance(Ci.nsICrossProcessPipe);
+}
+
+function initializeChild(callback) {
+  let file = do_get_file("test_crossProcessPipe.js");
+  mm.addMessageListener("XPPINIT", function thunk(message) {
+    // Replace mm with the correct process message manager
+    mm.removeMessageListener("XPPINIT", thunk);
+    mm = message.target.QueryInterface(Ci.nsIMessageSender);
+    addListener();
+    do_execute_soon(callback);
+  });
+  do_load_child_test_harness();
+  sendCommand("load(\"" + file.path.replace(/\\/g, "/") + "\"); run_test();");
+}
+
+function addListener() {
+  Assert.ok(mm instanceof Ci.nsIMessageSender);
+  mm.addMessageListener("XPPTEST", function(message) {
+    let retval;
+
+    if (test) {
+      retval = test.next(message.data).value;
+    } else if (receiver) {
+      retval = receiver.next(message.data).value;
+    } else {
+      do_check_true(false);
+    }
+
+    if (retval) {
+      sendMessage(retval);
+    }
+  });
+
+  mm.addMessageListener("XPPCONTINUE", continueTest);
+}
+
+function sendMessage(message) {
+  mm.sendAsyncMessage("XPPTEST", message);
+}
+
+function continueTest() {
+  if (gIsInChild) {
+    mm.sendAsyncMessage("XPPCONTINUE", null);
+    return;
+  }
+
+  test_runner.next();
+}
+
+function getStreamAndContinue(thing) {
+  return function(object) { thing.next(object); };
+}
+
+function getDataAndContinue(thing) {
+  return function(stream, resultCode) {
+      let data = NetUtil.readInputStreamToString(stream, stream.available());
+      thing.next(data);
+    };
+}
+
+let test;
+let receiver;
+
+// Make sure the basics work.
+function* test0() {
+  let ipc = ipcTest();
+  Assert.ok(ipc instanceof Ci.nsITestShellTest);
+
+  let XPP = newXPP();
+  Assert.notEqual(XPP, null);
+  Assert.ok(XPP instanceof Ci.nsICrossProcessPipe);
+  Assert.throws(function() { XPP.inputStream; }, "NS_ERROR_NOT_INITIALIZED");
+  Assert.throws(function() { XPP.outputStream; }, "NS_ERROR_NOT_INITIALIZED");
+  Assert.notEqual(XPP.init, undefined);
+
+  XPP.init(ipc.contentParent, true);
+  Assert.ok(XPP.inputStream instanceof Ci.nsIAsyncInputStream);
+  Assert.ok(XPP.outputStream instanceof Ci.nsIAsyncOutputStream);
+
+  sendMessage("ohai");
+  let response = yield;
+  Assert.equal(response, "obai");
+
+  continueTest();
+}
+
+function* recv0() {
+  let response = yield;
+  Assert.equal(response, "ohai");
+  yield "obai";
+}
+
+// Test sending data
+function* test1() {
+  const data = "ohai";
+  let ipc = ipcTest();
+
+  let XPP = newXPP();
+  XPP.init(ipc.contentParent, true);
+
+  let inputStream = XPP.inputStream;
+  let outputStream = XPP.outputStream;
+
+  Assert.throws(function() { outputStream.write(data, data.length); }, "NS_ERROR_BASE_STREAM_WOULD_BLOCK");
+
+  outputStream.asyncWait(getStreamAndContinue(test), 0, 0, null);
+
+  ipc.sendInputStream(inputStream);
+
+  let readyStream = yield;
+  Assert.equal(readyStream, outputStream);
+
+  outputStream.write(data, data.length);
+  outputStream.close();
+
+  let dataReceived = yield;
+  Assert.equal(data, dataReceived);
+
+  continueTest();
+}
+
+function* recv1() {
+  let ipc = ipcTest();
+  ipc.onInputStreamReceived = getStreamAndContinue(receiver);
+
+  let inputStream = yield;
+  Assert.ok(inputStream instanceof Ci.nsIAsyncInputStream);
+
+  Assert.equal(inputStream.isNonBlocking(), true);
+
+  NetUtil.asyncFetch(inputStream, getDataAndContinue(receiver))
+
+  let data = yield;
+  sendMessage(data);
+}
+
+// Test the result code
+function* test2() {
+  let ipc = ipcTest();
+  let XPP = newXPP();
+  XPP.init(ipc.contentParent, true);
+
+  let inputStream = XPP.inputStream;
+  let outputStream = XPP.outputStream;
+
+  outputStream.asyncWait(getStreamAndContinue(test), 0, 0, null);
+
+  ipc.sendInputStream(inputStream);
+
+  yield;
+
+  // Pick a strange result code so it won't show up naturally.
+  outputStream.closeWithStatus(Cr.NS_ERROR_FILE_TOO_BIG);
+
+  let statusReceived = yield;
+  Assert.equal(statusReceived, Cr.NS_ERROR_FILE_TOO_BIG);
+
+  // Close the pipe again to make sure nothing breaks.
+  outputStream.close();
+
+  continueTest();
+};
+
+function* recv2() {
+  let ipc = ipcTest();
+  ipc.onInputStreamReceived = getStreamAndContinue(receiver);
+
+  let inputStream = yield;
+
+  NetUtil.asyncFetch(inputStream, function (stream, resultCode) {
+    receiver.next(resultCode);
+  })
+
+  let exception = yield;
+  sendMessage(exception);
+}
+
+function* test3() {
+  let ipc = ipcTest();
+
+  let XPP = newXPP();
+  XPP.init(ipc.contentParent, true);
+  let outputStream = XPP.outputStream;
+  outputStream.close();
+  continueTest();
+}
+
+function* recv3() {
+}
+
+const tests = [
+  [test0, recv0],
+  [test1, recv1],
+  [test2, recv2],
+  [test3, recv3],
+];
+
+function* run_all_tests() {
+  equal(gIsInChild, false);
+
+  // Synchronize tests.  testN and recvN will be run simultaneously in the
+  // parent and child, and then in the child and parent, respectively.
+  for (let i = 0; i < tests.length; i++) {
+    sendCommand("test = null; receiver = tests[" + i + "][1](); receiver.next();", function() { test.next(); });
+    test = tests[i][0]();
+    receiver = null;
+
+    yield;
+
+    sendCommand("receiver = null; test = tests[" + i + "][0](); test.next();");
+    receiver = tests[i][1]();
+    receiver.next(); // NB: We initialize the receiver immediately, only the test has to wait.
+    test = null;
+
+    yield;
+  }
+
+  do_test_finished();
+}
+
+let test_runner;
+
+function run_test() {
+  if (!gIsInChild) {
+    do_test_pending();
+    initializeChild(function() { test_runner = run_all_tests(); test_runner.next(); });
+  } else {
+    addListener();
+
+    // Set up the IPC testing protocol
+    ipcTest();
+
+    // Nothing else to do, parent drives.
+    mm.sendAsyncMessage("XPPINIT", "Hello");
+  }
+}
+
diff --git a/ipc/glue/unit/xpcshell.ini b/ipc/glue/unit/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/ipc/glue/unit/xpcshell.ini
@@ -0,0 +1,5 @@
+[DEFAULT]
+head = 
+tail = 
+
+[test_crossProcessPipe.js]
diff --git a/ipc/testshell/PTestShell.ipdl b/ipc/testshell/PTestShell.ipdl
--- a/ipc/testshell/PTestShell.ipdl
+++ b/ipc/testshell/PTestShell.ipdl
@@ -1,24 +1,29 @@
 /* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PContent;
 include protocol PTestShellCommand;
+include protocol PTestShellTest;
 
 namespace mozilla {
 namespace ipc {
 
 async protocol PTestShell
 {
   manager PContent;
 
   manages PTestShellCommand;
+  manages PTestShellTest;
+
+parent:
+  PTestShellTest();
 
 child:
   __delete__();
 
   ExecuteCommand(nsString aCommand);
 
   PTestShellCommand(nsString aCommand);
 };
diff --git a/ipc/testshell/PTestShell.ipdl b/ipc/testshell/PTestShellTest.ipdl
copy from ipc/testshell/PTestShell.ipdl
copy to ipc/testshell/PTestShellTest.ipdl
--- a/ipc/testshell/PTestShell.ipdl
+++ b/ipc/testshell/PTestShellTest.ipdl
@@ -1,27 +1,26 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-include protocol PContent;
-include protocol PTestShellCommand;
+include protocol PTestShell;
+include protocol PFileDescriptorSet;
+
+include InputStreamParams;
 
 namespace mozilla {
 namespace ipc {
 
-async protocol PTestShell
+// An object for random test methods.
+async protocol PTestShellTest
 {
-  manager PContent;
-
-  manages PTestShellCommand;
+  manager PTestShell;
 
 child:
   __delete__();
 
-  ExecuteCommand(nsString aCommand);
-
-  PTestShellCommand(nsString aCommand);
+both:
+  InputStream(InputStreamParams params, OptionalFileDescriptorSet fds);
 };
 
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/testshell/TestShellChild.cpp b/ipc/testshell/TestShellChild.cpp
--- a/ipc/testshell/TestShellChild.cpp
+++ b/ipc/testshell/TestShellChild.cpp
@@ -3,19 +3,24 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "TestShellChild.h"
 
 using mozilla::ipc::TestShellChild;
 using mozilla::ipc::PTestShellCommandChild;
 using mozilla::ipc::XPCShellEnvironment;
 
+/* static */
+TestShellChild* TestShellChild::sSingleton;
+
 TestShellChild::TestShellChild()
 : mXPCShell(XPCShellEnvironment::CreateEnvironment())
 {
+  MOZ_ASSERT(!sSingleton);
+  sSingleton = this;
 }
 
 bool
 TestShellChild::RecvExecuteCommand(const nsString& aCommand)
 {
   if (mXPCShell->IsQuitting()) {
     NS_WARNING("Commands sent after quit command issued!");
     return false;
@@ -49,8 +54,13 @@ TestShellChild::RecvPTestShellCommandCon
   nsString response;
   if (!mXPCShell->EvaluateString(aCommand, &response)) {
     return false;
   }
 
   return PTestShellCommandChild::Send__delete__(aActor, response);
 }
 
+/* static */ TestShellChild*
+TestShellChild::Get()
+{
+  return sSingleton;
+}
diff --git a/ipc/testshell/TestShellChild.h b/ipc/testshell/TestShellChild.h
--- a/ipc/testshell/TestShellChild.h
+++ b/ipc/testshell/TestShellChild.h
@@ -2,43 +2,58 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef ipc_testshell_TestShellChild_h
 #define ipc_testshell_TestShellChild_h 1
 
 #include "mozilla/ipc/PTestShellChild.h"
 #include "mozilla/ipc/PTestShellCommandChild.h"
+#include "mozilla/ipc/PTestShellTestParent.h"
 #include "mozilla/ipc/XPCShellEnvironment.h"
 
 #include "nsAutoPtr.h"
 
+class nsITestShellTest;
+
 namespace mozilla {
 
 namespace ipc {
 
 class XPCShellEnvironment;
 
 class TestShellChild : public PTestShellChild
 {
+  static TestShellChild* sSingleton;
+
 public:
   TestShellChild();
 
-  bool
-  RecvExecuteCommand(const nsString& aCommand);
+  virtual bool
+  RecvExecuteCommand(const nsString& aCommand) MOZ_OVERRIDE;
 
-  PTestShellCommandChild*
-  AllocPTestShellCommandChild(const nsString& aCommand);
+  virtual PTestShellCommandChild*
+  AllocPTestShellCommandChild(const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
+  virtual bool
   RecvPTestShellCommandConstructor(PTestShellCommandChild* aActor,
-                                   const nsString& aCommand);
+                                   const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
-  DeallocPTestShellCommandChild(PTestShellCommandChild* aCommand);
+  virtual bool
+  DeallocPTestShellCommandChild(PTestShellCommandChild* aCommand) MOZ_OVERRIDE;
+
+  virtual PTestShellTestChild*
+  AllocPTestShellTestChild() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPTestShellTestChild(PTestShellTestChild* aTest) MOZ_OVERRIDE;
+
+  nsITestShellTest* GetOrCreateTestObject();
+
+  static TestShellChild* Get();
 
 private:
   nsAutoPtr<XPCShellEnvironment> mXPCShell;
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
diff --git a/ipc/testshell/TestShellParent.cpp b/ipc/testshell/TestShellParent.cpp
--- a/ipc/testshell/TestShellParent.cpp
+++ b/ipc/testshell/TestShellParent.cpp
@@ -15,16 +15,25 @@
 #include "xpcpublic.h"
 
 using namespace mozilla;
 using mozilla::ipc::TestShellParent;
 using mozilla::ipc::TestShellCommandParent;
 using mozilla::ipc::PTestShellCommandParent;
 using mozilla::dom::ContentParent;
 
+/* static */
+TestShellParent* TestShellParent::sSingleton;
+
+TestShellParent::TestShellParent()
+{
+  MOZ_ASSERT(!sSingleton);
+  sSingleton = this;
+}
+
 void
 TestShellParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   // Implement me! Bug 1005177
 }
 
 PTestShellCommandParent*
 TestShellParent::AllocPTestShellCommandParent(const nsString& aCommand)
@@ -45,16 +54,22 @@ TestShellParent::CommandDone(TestShellCo
 {
   // XXX what should happen if the callback fails?
   /*bool ok = */command->RunCallback(aResponse);
   command->ReleaseCallback();
 
   return true;
 }
 
+/* static */ TestShellParent*
+TestShellParent::Get()
+{
+  return sSingleton;
+}
+
 bool
 TestShellCommandParent::SetCallback(JSContext* aCx,
                                     JS::Value aCallback)
 {
   if (!mCallback.initialized()) {
     mCallback.init(aCx, aCallback);
     return true;
   }
diff --git a/ipc/testshell/TestShellParent.h b/ipc/testshell/TestShellParent.h
--- a/ipc/testshell/TestShellParent.h
+++ b/ipc/testshell/TestShellParent.h
@@ -5,40 +5,57 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef ipc_testshell_TestShellParent_h
 #define ipc_testshell_TestShellParent_h 1
 
 #include "mozilla/ipc/PTestShellParent.h"
 #include "mozilla/ipc/PTestShellCommandParent.h"
+#include "mozilla/ipc/PTestShellTest.h"
 
 #include "js/TypeDecls.h"
 #include "js/RootingAPI.h"
 #include "nsString.h"
 
+class nsITestShellTest;
+
 namespace mozilla {
 
 namespace ipc {
 
 class TestShellCommandParent;
 
 class TestShellParent : public PTestShellParent
 {
+  static TestShellParent* sSingleton;
+
 public:
+  TestShellParent();
+
   virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
 
-  PTestShellCommandParent*
+  virtual PTestShellCommandParent*
   AllocPTestShellCommandParent(const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
+  virtual bool
   DeallocPTestShellCommandParent(PTestShellCommandParent* aActor) MOZ_OVERRIDE;
 
+  virtual PTestShellTestParent*
+  AllocPTestShellTestParent() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPTestShellTestParent(PTestShellTestParent* aTest) MOZ_OVERRIDE;
+
   bool
   CommandDone(TestShellCommandParent* aActor, const nsString& aResponse);
+
+  nsITestShellTest* GetTestObject();
+
+  static TestShellParent* Get();
 };
 
 
 class TestShellCommandParent : public PTestShellCommandParent
 {
 public:
   TestShellCommandParent() {}
 
diff --git a/ipc/testshell/TestShellTest.cpp b/ipc/testshell/TestShellTest.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/testshell/TestShellTest.cpp
@@ -0,0 +1,245 @@
+#include "nsITestShellTest.h"
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/ipc/PTestShellTestParent.h"
+#include "mozilla/ipc/PTestShellTestChild.h"
+#include "TestShellParent.h"
+#include "TestShellChild.h"
+
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsISupportsImpl.h"
+
+#include "nsCOMPtr.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+
+namespace mozilla {
+namespace ipc {
+
+template <class Derived>
+class TestShellTest : public nsITestShellTest
+{
+  nsCOMPtr<nsIInputStreamCallback> mInputStreamCb;
+  nsCOMPtr<nsIOutputStreamCallback> mOutputStreamCb;
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSITESTSHELLTEST
+
+  Derived*
+  AsDerived() const
+  {
+    return static_cast<Derived*>(const_cast<TestShellTest*>(this));
+  }
+
+protected:
+  virtual ~TestShellTest() { }
+
+  bool RecvInputStream(const InputStreamParams& aParams,
+		       const OptionalFileDescriptorSet& aFds);
+};
+
+template <class Derived>
+NS_IMPL_ADDREF(TestShellTest<Derived>)
+
+template <class Derived>
+NS_IMPL_RELEASE(TestShellTest<Derived>)
+
+template <class Derived>
+NS_INTERFACE_MAP_BEGIN(TestShellTest<Derived>)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsITestShellTest)
+NS_INTERFACE_MAP_END
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::GetOnInputStreamReceived(nsIInputStreamCallback** aCb)
+{
+  NS_IF_ADDREF(*aCb = mInputStreamCb);
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SetOnInputStreamReceived(nsIInputStreamCallback* aCb)
+{
+  mInputStreamCb = aCb;
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::GetOnOutputStreamReceived(nsIOutputStreamCallback** aCb)
+{
+  NS_IF_ADDREF(*aCb = mOutputStreamCb);
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SetOnOutputStreamReceived(nsIOutputStreamCallback* aCb)
+{
+  mOutputStreamCb = aCb;
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SendInputStream(nsIInputStream* aInputStream)
+{
+  InputStreamParams params;
+  nsTArray<FileDescriptor> fds;
+
+  SerializeInputStream(aInputStream, params, fds);
+
+  MOZ_RELEASE_ASSERT(fds.Length() == 0); // Not supported yet!
+
+  if (!AsDerived()->Derived::Protocol::SendInputStream(params, void_t())) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SendOutputStream(nsIOutputStream* aOutputStream)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+template <class Derived>
+bool
+TestShellTest<Derived>::RecvInputStream(const InputStreamParams& aParams,
+					const OptionalFileDescriptorSet& aFds)
+{
+  nsTArray<FileDescriptor> fds;
+  nsCOMPtr<nsIInputStream> stream = DeserializeInputStream(aParams, fds);
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+
+  if (mInputStreamCb) {
+    mInputStreamCb->OnInputStreamReady(asyncStream);
+  }
+
+  return true;
+}
+
+class TestShellTestParent MOZ_FINAL : public TestShellTest<TestShellTestParent>,
+			              public PTestShellTestParent
+{
+  ~TestShellTestParent() { }
+
+public:
+  typedef TestShellTest<TestShellTestParent> Base;
+  typedef PTestShellTestParent Protocol;
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
+  { }
+
+  virtual bool RecvInputStream(const InputStreamParams& aParams,
+			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
+  {
+    return Base::RecvInputStream(aParams, aFds);
+  }
+};
+
+class TestShellTestChild MOZ_FINAL : public TestShellTest<TestShellTestChild>,
+			             public PTestShellTestChild
+{
+  ~TestShellTestChild() { }
+
+public:
+  typedef TestShellTest<TestShellTestChild> Base;
+  typedef PTestShellTestChild Protocol;
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
+  { }
+
+  virtual bool RecvInputStream(const InputStreamParams& aParams,
+			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
+  {
+    return Base::RecvInputStream(aParams, aFds);
+  }
+};
+
+template <>
+NS_IMETHODIMP
+TestShellTest<TestShellTestChild>::GetContentParent(nsISupports** aContentParent)
+{
+  *aContentParent = nullptr;
+  return NS_OK;
+}
+
+template <>
+NS_IMETHODIMP
+TestShellTest<TestShellTestParent>::GetContentParent(nsISupports** aContentParent)
+{
+  NS_ADDREF(*aContentParent =
+	      static_cast<mozilla::dom::nsIContentParent*>(
+	        static_cast<mozilla::dom::ContentParent*>(AsDerived()->Manager()->Manager())));
+  return NS_OK;
+}
+
+template class TestShellTest<TestShellTestParent>;
+template class TestShellTest<TestShellTestChild>;
+
+PTestShellTestParent*
+TestShellParent::AllocPTestShellTestParent()
+{
+  nsRefPtr<TestShellTestParent> test = new TestShellTestParent();
+  return test.forget().take(); // The reference is held by IPDL.
+}
+
+bool
+TestShellParent::DeallocPTestShellTestParent(PTestShellTestParent* aTest)
+{
+  nsRefPtr<TestShellTestParent> test =
+    dont_AddRef(static_cast<TestShellTestParent*>(aTest));
+  return true;
+}
+
+nsITestShellTest*
+TestShellParent::GetTestObject()
+{
+  auto& tests = ManagedPTestShellTestParent();
+  MOZ_ASSERT(tests.Length() <= 1);
+
+  if (tests.Length() == 0) {
+    return nullptr;
+  }
+
+  return static_cast<TestShellTestParent*>(tests[0]);
+}
+
+PTestShellTestChild*
+TestShellChild::AllocPTestShellTestChild()
+{
+  MOZ_ASSERT_UNREACHABLE("Should be allocated elsewhere!");
+  return nullptr;
+}
+
+bool
+TestShellChild::DeallocPTestShellTestChild(PTestShellTestChild* aTest)
+{
+  nsRefPtr<TestShellTestChild> test =
+    dont_AddRef(static_cast<TestShellTestChild*>(aTest));
+  return true;
+}
+
+nsITestShellTest*
+TestShellChild::GetOrCreateTestObject()
+{
+  auto& tests = ManagedPTestShellTestChild();
+  MOZ_ASSERT(tests.Length() <= 1);
+
+  if (tests.Length() == 0) {
+    nsRefPtr<TestShellTestChild> test = new TestShellTestChild();
+    SendPTestShellTestConstructor(test);
+    return test.forget().take(); // This reference belongs to IPDL,
+                                 // not the caller.
+  }
+
+  return static_cast<TestShellTestChild*>(tests[0]);
+}
+
+}
+}
diff --git a/ipc/testshell/XPCShellEnvironment.cpp b/ipc/testshell/XPCShellEnvironment.cpp
--- a/ipc/testshell/XPCShellEnvironment.cpp
+++ b/ipc/testshell/XPCShellEnvironment.cpp
@@ -35,21 +35,20 @@
 #include "nsJSUtils.h"
 #include "nsJSPrincipals.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 
 #include "BackstagePass.h"
 
 #include "TestShellChild.h"
-#include "TestShellParent.h"
+#include "nsITestShellTest.h"
 
 using mozilla::ipc::XPCShellEnvironment;
 using mozilla::ipc::TestShellChild;
-using mozilla::ipc::TestShellParent;
 using mozilla::AutoSafeJSContext;
 using namespace JS;
 
 namespace {
 
 static const char kDefaultRuntimeScriptFilename[] = "xpcshell.js";
 
 class XPCShellDirProvider : public nsIDirectoryServiceProvider
@@ -259,29 +258,57 @@ GCZeal(JSContext *cx, unsigned argc, JS:
   if (!ToUint32(cx, args.get(0), &zeal))
     return false;
 
   JS_SetGCZeal(cx, uint8_t(zeal), JS_DEFAULT_ZEAL_FREQ);
   return true;
 }
 #endif
 
+static bool
+IpcTest(JSContext *cx, unsigned argc, JS::Value *vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    nsCOMPtr<nsITestShellTest> test;
+    MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Content);
+
+    TestShellChild* tsc = TestShellChild::Get();
+    test = tsc->GetOrCreateTestObject();
+
+    if (test) {
+        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
+        nsCOMPtr<nsIXPConnectJSObjectHolder> wrappedNative;
+        xpc->WrapNative(cx, JS_THIS_OBJECT(cx, vp), test,
+                        NS_GET_IID(nsITestShellTest),
+                        getter_AddRefs(wrappedNative));
+        
+        args.rval().set(OBJECT_TO_JSVAL(wrappedNative->GetJSObject()));
+    }
+    else {
+        args.rval().setUndefined();
+    }
+
+    return true;
+}
+
 const JSFunctionSpec gGlobalFunctions[] =
 {
     JS_FS("print",           Print,          0,0),
     JS_FS("load",            Load,           1,0),
     JS_FS("quit",            Quit,           0,0),
     JS_FS("version",         Version,        1,0),
     JS_FS("build",           BuildDate,      0,0),
     JS_FS("dumpXPC",         DumpXPC,        1,0),
     JS_FS("dump",            Dump,           1,0),
     JS_FS("gc",              GC,             0,0),
  #ifdef JS_GC_ZEAL
     JS_FS("gczeal",          GCZeal,         1,0),
  #endif
+    JS_FS("ipcTest",         IpcTest,        0,0),
     JS_FS_END
 };
 
 typedef enum JSShellErrNum
 {
 #define MSG_DEF(name, number, count, exception, format) \
     name = number,
 #include "jsshell.msg"
diff --git a/ipc/testshell/moz.build b/ipc/testshell/moz.build
--- a/ipc/testshell/moz.build
+++ b/ipc/testshell/moz.build
@@ -1,31 +1,39 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+XPIDL_MODULE = 'testshell'
+
+XPIDL_SOURCES += [
+    'nsITestShellTest.idl',
+]
+
 EXPORTS.mozilla.ipc += [
     'TestShellChild.h',
     'TestShellParent.h',
     'XPCShellEnvironment.h',
 ]
 
 XPCSHELL_TESTS_MANIFESTS += ['tests/xpcshell.ini']
 
 SOURCES += [
     'TestShellChild.cpp',
     'TestShellParent.cpp',
+    'TestShellTest.cpp',
     'XPCShellEnvironment.cpp',
 ]
 
 IPDL_SOURCES = [
     'PTestShell.ipdl',
     'PTestShellCommand.ipdl',
+    'PTestShellTest.ipdl',
 ]
 
 FAIL_ON_WARNINGS = True
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
 
diff --git a/ipc/testshell/nsITestShellTest.idl b/ipc/testshell/nsITestShellTest.idl
new file mode 100644
--- /dev/null
+++ b/ipc/testshell/nsITestShellTest.idl
@@ -0,0 +1,22 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+interface nsIInputStream;
+interface nsIInputStreamCallback;
+interface nsIOutputStream;
+interface nsIOutputStreamCallback;
+
+[scriptable, builtinclass, uuid(ef3342e4-7f63-4403-bed4-0b4a95bc0a2a)]
+interface nsITestShellTest : nsISupports
+{
+  readonly attribute nsISupports contentParent;
+
+  attribute nsIInputStreamCallback onInputStreamReceived;
+  attribute nsIOutputStreamCallback onOutputStreamReceived;
+
+  void sendInputStream(in nsIInputStream aInputStream);
+  void sendOutputStream(in nsIOutputStream aOutputStream);
+};
diff --git a/ipc/testshell/tests/test_ipcshell.js b/ipc/testshell/tests/test_ipcshell.js
--- a/ipc/testshell/tests/test_ipcshell.js
+++ b/ipc/testshell/tests/test_ipcshell.js
@@ -18,11 +18,19 @@ function run_test() {
       var cmp = pair[0].localeCompare(pair[1]);
       sendCommand(
           "'"+ pair[0] +"'.localeCompare('"+ pair[1] +"');",
           function (result) {
               do_check_eq(cmp, result);
               do_test_finished(); 
           });
     })
+
+  do_test_pending();
+  sendCommand("ipcTest",
+    function(result) {
+      do_check_neq(result, undefined);
+      do_check_neq(ipcTest, undefined);
+      do_test_finished();
+    });
 }
 load('test_ipcshell_child.js');
 
diff --git a/ipc/testshell/tests/test_ipcshell_child.js b/ipc/testshell/tests/test_ipcshell_child.js
--- a/ipc/testshell/tests/test_ipcshell_child.js
+++ b/ipc/testshell/tests/test_ipcshell_child.js
@@ -1,9 +1,10 @@
-const Cc = Components.classes;
-const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Ci = Components.interfaces;
 
 const runtime = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime);
 
-if (typeof(run_test) == "undefined") {
+if (typeof(run_test) == "undefined") {
   run_test = function() {
-    do_check_eq(runtime.processType, Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT);
-  }}
+    do_check_eq(runtime.processType, Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT);
+  }
+}
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -26,16 +26,19 @@
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsJSPrincipals.h"
 #include "xpcpublic.h"
 #include "BackstagePass.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "nsJSUtils.h"
+#include "nsITestShellTest.h"
+#include "mozilla/ipc/TestShellParent.h"
+#include "mozilla/ipc/TestShellChild.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #ifdef XP_WIN
 #include <windows.h>
 #endif
@@ -51,16 +54,17 @@
 #endif
 
 #ifdef MOZ_CRASHREPORTER
 #include "nsExceptionHandler.h"
 #include "nsICrashReporter.h"
 #endif
 
 using namespace mozilla;
+using namespace mozilla::ipc;
 using namespace JS;
 
 class XPCShellDirProvider : public nsIDirectoryServiceProvider2
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIDIRECTORYSERVICEPROVIDER
     NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
@@ -467,16 +471,47 @@ SendCommand(JSContext *cx, unsigned argc
         return false;
     }
 
     args.rval().setUndefined();
     return true;
 }
 
 static bool
+IpcTest(JSContext *cx, unsigned argc, JS::Value *vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    nsCOMPtr<nsITestShellTest> test;
+    if (XRE_GetProcessType() == GeckoProcessType_Default) {
+        TestShellParent* tsp = TestShellParent::Get();
+	test = tsp->GetTestObject();
+    }
+    else {
+        TestShellChild* tsc = TestShellChild::Get();
+	test = tsc->GetOrCreateTestObject();
+    }
+
+    if (test) {
+        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
+        nsCOMPtr<nsIXPConnectJSObjectHolder> wrappedNative;
+        xpc->WrapNative(cx, JS_THIS_OBJECT(cx, vp), test,
+                        NS_GET_IID(nsITestShellTest),
+                        getter_AddRefs(wrappedNative));
+        
+        args.rval().set(OBJECT_TO_JSVAL(wrappedNative->GetJSObject()));
+    }
+    else {
+        args.rval().setUndefined();
+    }
+
+    return true;
+}
+
+static bool
 Options(JSContext *cx, unsigned argc, jsval *vp)
 {
     JS::CallArgs args = CallArgsFromVp(argc, vp);
     RuntimeOptions oldRuntimeOptions = RuntimeOptionsRef(cx);
 
     for (unsigned i = 0; i < args.length(); ++i) {
         JSString *str = ToString(cx, args[i]);
         if (!str)
@@ -649,16 +684,17 @@ static const JSFunctionSpec glob_functio
     JS_FS("dump",            Dump,           1,0),
     JS_FS("gc",              GC,             0,0),
 #ifdef JS_GC_ZEAL
     JS_FS("gczeal",          GCZeal,         1,0),
 #endif
     JS_FS("options",         Options,        0,0),
     JS_FN("parent",          Parent,         1,0),
     JS_FS("sendCommand",     SendCommand,    1,0),
+    JS_FS("ipcTest",         IpcTest,        0,0),
     JS_FS("atob",            Atob,           1,0),
     JS_FS("btoa",            Btoa,           1,0),
     JS_FS("setInterruptCallback", SetInterruptCallback, 1,0),
     JS_FS("simulateActivityCallback", SimulateActivityCallback, 1,0),
     JS_FS_END
 };
 
 static bool
diff --git a/xpcom/base/nsError.h b/xpcom/base/nsError.h
--- a/xpcom/base/nsError.h
+++ b/xpcom/base/nsError.h
@@ -134,27 +134,34 @@ const nsresult
   #undef ERROR
 ;
 
 #undef SUCCESS_OR_FAILURE
 #undef SUCCESS
 #undef FAILURE
 
 /**
+ * mozilla/Assertions.h includes nsTraceRefcnt.h, which expects to be able to
+ * use nsresult, so we have to include it after defining nsresult.
+ */
+#include "mozilla/Assertions.h"
+
+/**
  * @name Standard Error Handling Macros
  * @return 0 or 1 (false/true with bool type for C++)
  */
 
 inline uint32_t
 NS_FAILED_impl(nsresult aErr)
 {
   return static_cast<uint32_t>(aErr) & 0x80000000;
 }
 #define NS_FAILED(_nsresult)    ((bool)MOZ_UNLIKELY(NS_FAILED_impl(_nsresult)))
 #define NS_SUCCEEDED(_nsresult) ((bool)MOZ_LIKELY(!NS_FAILED_impl(_nsresult)))
+#define MOZ_ALWAYS_SUCCEEDS(_nsresult) MOZ_ALWAYS_TRUE(NS_SUCCEEDED(_nsresult))
 
 /* Check that our enum type is actually uint32_t as expected */
 static_assert(((nsresult)0) < ((nsresult)-1),
               "nsresult must be an unsigned type");
 static_assert(sizeof(nsresult) == sizeof(uint32_t),
               "nsresult must be 32 bits");
 
 /**
diff --git a/xpcom/build/XPCOMInit.cpp b/xpcom/build/XPCOMInit.cpp
--- a/xpcom/build/XPCOMInit.cpp
+++ b/xpcom/build/XPCOMInit.cpp
@@ -25,16 +25,17 @@
 #include "nsObserverList.h"
 #include "nsObserverService.h"
 #include "nsProperties.h"
 #include "nsPersistentProperties.h"
 #include "nsScriptableInputStream.h"
 #include "nsBinaryStream.h"
 #include "nsStorageStream.h"
 #include "nsPipe.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "nsScriptableBase64Encoder.h"
 
 #include "nsMemoryImpl.h"
 #include "nsDebugImpl.h"
 #include "nsTraceRefcnt.h"
 #include "nsErrorService.h"
 
 #include "nsSupportsArray.h"
diff --git a/xpcom/build/XPCOMModule.inc b/xpcom/build/XPCOMModule.inc
--- a/xpcom/build/XPCOMModule.inc
+++ b/xpcom/build/XPCOMModule.inc
@@ -6,16 +6,18 @@
 
     COMPONENT(SCRIPTABLEINPUTSTREAM, nsScriptableInputStream::Create)
     COMPONENT(BINARYINPUTSTREAM, nsBinaryInputStreamConstructor)
     COMPONENT(BINARYOUTPUTSTREAM, nsBinaryOutputStreamConstructor)
     COMPONENT(STORAGESTREAM, nsStorageStreamConstructor)
     COMPONENT(VERSIONCOMPARATOR, nsVersionComparatorImplConstructor)
     COMPONENT(SCRIPTABLEBASE64ENCODER, nsScriptableBase64EncoderConstructor)
     COMPONENT(PIPE, nsPipeConstructor)
+    COMPONENT(CROSSPROCESSPIPE,
+              mozilla::ipc::detail::XPCOMCreateCrossProcessPipe)
 
     COMPONENT(PROPERTIES, nsPropertiesConstructor)
 
     COMPONENT(PERSISTENTPROPERTIES, nsPersistentProperties::Create)
 
     COMPONENT(SUPPORTSARRAY, nsSupportsArray::Create)
     COMPONENT(ARRAY, nsArrayBase::XPCOMConstructor)
     COMPONENT(CONSOLESERVICE, nsConsoleServiceConstructor)
diff --git a/xpcom/io/nsIAsyncOutputStream.idl b/xpcom/io/nsIAsyncOutputStream.idl
--- a/xpcom/io/nsIAsyncOutputStream.idl
+++ b/xpcom/io/nsIAsyncOutputStream.idl
@@ -86,17 +86,17 @@ interface nsIAsyncOutputStream : nsIOutp
      * stream).
      */
     const unsigned long WAIT_CLOSURE_ONLY = (1<<0);
 };
 
 /**
  * This is a companion interface for nsIAsyncOutputStream::asyncWait.
  */
-[scriptable, uuid(40dbcdff-9053-42c5-a57c-3ec910d0f148)]
+[function, scriptable, uuid(40dbcdff-9053-42c5-a57c-3ec910d0f148)]
 interface nsIOutputStreamCallback : nsISupports
 {
     /**
      * Called to indicate that the stream is either writable or closed.
      *
      * @param aStream
      *        The stream whose asyncWait method was called.
      */
diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -1185,36 +1185,22 @@ nsPipeOutputStream::WriteSegments(nsRead
     if (segmentLen < originalLen) {
       mPipe->AdvanceWriteCursor(originalLen - segmentLen);
     }
   }
 
   return rv;
 }
 
-static NS_METHOD
-nsReadFromRawBuffer(nsIOutputStream* aOutStr,
-                    void* aClosure,
-                    char* aToRawSegment,
-                    uint32_t aOffset,
-                    uint32_t aCount,
-                    uint32_t* aReadCount)
-{
-  const char* fromBuf = (const char*)aClosure;
-  memcpy(aToRawSegment, &fromBuf[aOffset], aCount);
-  *aReadCount = aCount;
-  return NS_OK;
-}
-
 NS_IMETHODIMP
 nsPipeOutputStream::Write(const char* aFromBuf,
                           uint32_t aBufLen,
                           uint32_t* aWriteCount)
 {
-  return WriteSegments(nsReadFromRawBuffer, (void*)aFromBuf, aBufLen, aWriteCount);
+  return WriteSegments(NS_CopySegmentToBuffer, (void*)aFromBuf, aBufLen, aWriteCount);
 }
 
 NS_IMETHODIMP
 nsPipeOutputStream::Flush(void)
 {
   // nothing to do
   return NS_OK;
 }
