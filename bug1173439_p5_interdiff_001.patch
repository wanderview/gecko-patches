# HG changeset patch
# Parent 0178500052d39e409925f1536f2a6cc083d24cfc
# User Ben Kelly <ben@wanderview.com>
try md5 hashes instead


diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -265,17 +265,17 @@ CreateSchema(mozIStorageConnection* aCon
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // Security blobs are quite large and duplicated for every Response from
     // the same https origin.  This table is used to de-duplicate this data.
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE security_info ("
         "id INTEGER NOT NULL PRIMARY KEY, "
-        "hash BLOB NOT NULL, "  // first 8-bytes of the sha1 hash of data column
+        "hash BLOB NOT NULL, "  // first 8-bytes of the md5 hash of data column
         "data BLOB NOT NULL, "  // full security info data, usually a few KB
         "refcount INTEGER NOT NULL"
       ");"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // Index the smaller hash value instead of the large security data blob.
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
@@ -283,19 +283,19 @@ CreateSchema(mozIStorageConnection* aCon
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE entries ("
         "id INTEGER NOT NULL PRIMARY KEY, "
         "request_method TEXT NOT NULL, "
         "request_url_no_query TEXT NOT NULL, "
-        "request_url_no_query_hash BLOB NOT NULL, " // first 8-bytes of sha1 hash
+        "request_url_no_query_hash BLOB NOT NULL, " // first 8-bytes of md5 hash
         "request_url_query TEXT NOT NULL, "
-        "request_url_query_hash BLOB NOT NULL, "    // first 8-bytes of sha1 hash
+        "request_url_query_hash BLOB NOT NULL, "    // first 8-bytes of md5 hash
         "request_referrer TEXT NOT NULL, "
         "request_headers_guard INTEGER NOT NULL, "
         "request_mode INTEGER NOT NULL, "
         "request_credentials INTEGER NOT NULL, "
         "request_contentpolicytype INTEGER NOT NULL, "
         "request_context INTEGER NOT NULL, "
         "request_cache INTEGER NOT NULL, "
         "request_body_id TEXT NULL, "
@@ -1286,17 +1286,17 @@ InsertSecurityInfo(mozIStorageConnection
 {
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aCrypto);
   MOZ_ASSERT(aIdOut);
   MOZ_ASSERT(!aData.IsEmpty());
 
   // We want to use an index to find existing security blobs, but indexing
   // the full blob would be quite expensive.  Instead, we index a small
-  // hash value.  Calculate this hash as the first 8 bytes of the SHA1 of
+  // hash value.  Calculate this hash as the first 8 bytes of the MD5 of
   // the full data.
   nsAutoCString hash;
   nsresult rv = HashCString(aCrypto, aData, hash);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Next, search for an existing entry for this blob by comparing the hash
   // value first and then the full data.  SQLite is smart enough to use
   // the index on the hash to search the table before doing the expensive
@@ -2034,17 +2034,17 @@ CreateAndBindKeyStatement(mozIStorageCon
   return rv;
 }
 
 nsresult
 HashCString(nsICryptoHash* aCrypto, const nsACString& aIn, nsACString& aOut)
 {
   MOZ_ASSERT(aCrypto);
 
-  nsresult rv = aCrypto->Init(nsICryptoHash::SHA1);
+  nsresult rv = aCrypto->Init(nsICryptoHash::MD5);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aCrypto->Update(reinterpret_cast<const uint8_t*>(aIn.BeginReading()),
                        aIn.Length());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsAutoCString fullHash;
   rv = aCrypto->Finish(false /* based64 result */, fullHash);
