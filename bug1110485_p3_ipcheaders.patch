# HG changeset patch
# Parent 4cca2243bef35fafd1e7e28c41985ee9d2c968f3
# User Ben Kelly <ben@wanderview.com>
Bug 1110485 P3 Move Fetch IPC PHeaderEntry type to Cache. Rename HeadesEntry. r=nsm

diff --git a/dom/cache/CacheOpChild.cpp b/dom/cache/CacheOpChild.cpp
--- a/dom/cache/CacheOpChild.cpp
+++ b/dom/cache/CacheOpChild.cpp
@@ -1,16 +1,19 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheOpChild.h"
 
+#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/Request.h"
+#include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/Cache.h"
 #include "mozilla/dom/cache/CacheChild.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 CacheOpChild::CacheOpChild(Feature* aFeature, nsIGlobalObject* aGlobal,
diff --git a/dom/cache/CacheTypes.ipdlh b/dom/cache/CacheTypes.ipdlh
--- a/dom/cache/CacheTypes.ipdlh
+++ b/dom/cache/CacheTypes.ipdlh
@@ -1,24 +1,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PCache;
 include protocol PCachePushStream;
 include protocol PCacheStreamControl;
-include PHeaders;
 include InputStreamParams;
 
-using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
-using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
-using RequestMode from "mozilla/dom/FetchIPCUtils.h";
-using RequestCache from "mozilla/dom/FetchIPCUtils.h";
-using RequestContext from "mozilla/dom/FetchIPCUtils.h";
-using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
+using HeadersGuardEnum from "mozilla/dom/cache/IPCUtils.h";
+using RequestCredentials from "mozilla/dom/cache/IPCUtils.h";
+using RequestMode from "mozilla/dom/cache/IPCUtils.h";
+using RequestCache from "mozilla/dom/cache/IPCUtils.h";
+using RequestContext from "mozilla/dom/cache/IPCUtils.h";
+using ResponseType from "mozilla/dom/cache/IPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 struct CacheQueryParams
@@ -40,22 +39,28 @@ struct CacheReadStream
 };
 
 union CacheReadStreamOrVoid
 {
   void_t;
   CacheReadStream;
 };
 
+struct HeadersEntry
+{
+  nsCString name;
+  nsCString value;
+};
+
 struct CacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
-  PHeadersEntry[] headers;
+  HeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
   CacheReadStreamOrVoid body;
   uint32_t contentPolicyType;
   RequestContext context;
   RequestCache requestCache;
@@ -68,17 +73,17 @@ union CacheRequestOrVoid
 };
 
 struct CacheResponse
 {
   ResponseType type;
   nsString url;
   uint32_t status;
   nsCString statusText;
-  PHeadersEntry[] headers;
+  HeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   CacheReadStreamOrVoid body;
   nsCString securityInfo;
 };
 
 union CacheResponseOrVoid
 {
   void_t;
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -5,26 +5,27 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBSchema.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/dom/InternalHeaders.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/TypeUtils.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 #include "mozilla/dom/HeadersBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/dom/ResponseBinding.h"
-#include "Types.h"
 #include "nsIContentPolicy.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 const int32_t DBSchema::kMaxWipeSchemaVersion = 6;
 const int32_t DBSchema::kLatestSchemaVersion = 6;
@@ -908,34 +909,36 @@ DBSchema::MatchByVaryHeader(mozIStorageC
     "SELECT name, value FROM request_headers "
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, entryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  nsRefPtr<InternalHeaders> cachedHeaders = new InternalHeaders(HeadersGuardEnum::None);
+  nsRefPtr<InternalHeaders> cachedHeaders =
+    new InternalHeaders(HeadersGuardEnum::None);
 
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
     nsAutoCString name;
     nsAutoCString value;
     rv = state->GetUTF8String(0, name);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     rv = state->GetUTF8String(1, value);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     ErrorResult errorResult;
 
     cachedHeaders->Append(name, value, errorResult);
     if (errorResult.Failed()) { return errorResult.ErrorCode(); };
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  nsRefPtr<InternalHeaders> queryHeaders = new InternalHeaders(aRequest.headers());
+  nsRefPtr<InternalHeaders> queryHeaders =
+    TypeUtils::ToInternalHeaders(aRequest.headers());
 
   // Assume the vary headers match until we find a conflict
   bool varyHeadersMatch = true;
 
   for (uint32_t i = 0; i < varyValues.Length(); ++i) {
     // Extract the header names inside the Vary header value.
     nsAutoCString varyValue(varyValues[i]);
     char* rawBuffer = varyValue.BeginWriting();
@@ -1190,17 +1193,17 @@ DBSchema::InsertEntry(mozIStorageConnect
     "INSERT INTO request_headers ("
       "name, "
       "value, "
       "entry_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers();
+  const nsTArray<HeadersEntry>& requestHeaders = aRequest.headers();
   for (uint32_t i = 0; i < requestHeaders.Length(); ++i) {
     rv = state->BindUTF8StringParameter(0, requestHeaders[i].name());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->BindUTF8StringParameter(1, requestHeaders[i].value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->BindInt32Parameter(2, entryId);
@@ -1214,17 +1217,17 @@ DBSchema::InsertEntry(mozIStorageConnect
     "INSERT INTO response_headers ("
       "name, "
       "value, "
       "entry_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers();
+  const nsTArray<HeadersEntry>& responseHeaders = aResponse.headers();
   for (uint32_t i = 0; i < responseHeaders.Length(); ++i) {
     rv = state->BindUTF8StringParameter(0, responseHeaders[i].name());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->BindUTF8StringParameter(1, responseHeaders[i].value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->BindInt32Parameter(2, entryId);
@@ -1315,17 +1318,17 @@ DBSchema::ReadResponse(mozIStorageConnec
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    PHeadersEntry header;
+    HeadersEntry header;
 
     rv = state->GetUTF8String(0, header.name());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->GetUTF8String(1, header.value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     aSavedResponseOut->mValue.headers().AppendElement(header);
@@ -1434,17 +1437,17 @@ DBSchema::ReadRequest(mozIStorageConnect
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    PHeadersEntry header;
+    HeadersEntry header;
 
     rv = state->GetUTF8String(0, header.name());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = state->GetUTF8String(1, header.value());
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     aSavedRequestOut->mValue.headers().AppendElement(header);
diff --git a/dom/cache/FetchPut.cpp b/dom/cache/FetchPut.cpp
--- a/dom/cache/FetchPut.cpp
+++ b/dom/cache/FetchPut.cpp
@@ -342,32 +342,32 @@ FetchPut::MatchInPutList(const CacheRequ
   // we don't want to load all request/response objects into memory.
 
   if (!aRequest.method().LowerCaseEqualsLiteral("get") &&
       !aRequest.method().LowerCaseEqualsLiteral("head")) {
     return false;
   }
 
   nsRefPtr<InternalHeaders> requestHeaders =
-    new InternalHeaders(aRequest.headers());
+    ToInternalHeaders(aRequest.headers());
 
   for (uint32_t i = 0; i < aPutList.Length(); ++i) {
     const CacheRequest& cachedRequest = aPutList[i].request();
     const CacheResponse& cachedResponse = aPutList[i].response();
 
     // If the URLs don't match, then just skip to the next entry.
     if (aRequest.url() != cachedRequest.url()) {
       continue;
     }
 
     nsRefPtr<InternalHeaders> cachedRequestHeaders =
-      new InternalHeaders(cachedRequest.headers());
+      ToInternalHeaders(cachedRequest.headers());
 
     nsRefPtr<InternalHeaders> cachedResponseHeaders =
-      new InternalHeaders(cachedResponse.headers());
+      ToInternalHeaders(cachedResponse.headers());
 
     nsAutoTArray<nsCString, 16> varyHeaders;
     ErrorResult rv;
     cachedResponseHeaders->GetAll(NS_LITERAL_CSTRING("vary"), varyHeaders, rv);
     MOZ_ALWAYS_TRUE(!rv.Failed());
 
     // Assume the vary headers match until we find a conflict
     bool varyHeadersMatch = true;
diff --git a/dom/cache/IPCUtils.h b/dom/cache/IPCUtils.h
--- a/dom/cache/IPCUtils.h
+++ b/dom/cache/IPCUtils.h
@@ -3,20 +3,57 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_IPCUtils_h
 #define mozilla_dom_cache_IPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
+
+// Fix X11 header brain damage that conflicts with HeadersGuardEnum::None
+#undef None
+
+#include "mozilla/dom/HeadersBinding.h"
+#include "mozilla/dom/RequestBinding.h"
+#include "mozilla/dom/ResponseBinding.h"
 #include "mozilla/dom/cache/Types.h"
 
 namespace IPC {
   template<>
+  struct ParamTraits<mozilla::dom::HeadersGuardEnum> :
+    public ContiguousEnumSerializer<mozilla::dom::HeadersGuardEnum,
+                                    mozilla::dom::HeadersGuardEnum::None,
+                                    mozilla::dom::HeadersGuardEnum::EndGuard_> {};
+  template<>
+  struct ParamTraits<mozilla::dom::RequestMode> :
+    public ContiguousEnumSerializer<mozilla::dom::RequestMode,
+                                    mozilla::dom::RequestMode::Same_origin,
+                                    mozilla::dom::RequestMode::EndGuard_> {};
+  template<>
+  struct ParamTraits<mozilla::dom::RequestCredentials> :
+    public ContiguousEnumSerializer<mozilla::dom::RequestCredentials,
+                                    mozilla::dom::RequestCredentials::Omit,
+                                    mozilla::dom::RequestCredentials::EndGuard_> {};
+  template<>
+  struct ParamTraits<mozilla::dom::RequestCache> :
+    public ContiguousEnumSerializer<mozilla::dom::RequestCache,
+                                    mozilla::dom::RequestCache::Default,
+                                    mozilla::dom::RequestCache::EndGuard_> {};
+  template<>
+  struct ParamTraits<mozilla::dom::RequestContext> :
+    public ContiguousEnumSerializer<mozilla::dom::RequestContext,
+                                    mozilla::dom::RequestContext::Audio,
+                                    mozilla::dom::RequestContext::EndGuard_> {};
+  template<>
+  struct ParamTraits<mozilla::dom::ResponseType> :
+    public ContiguousEnumSerializer<mozilla::dom::ResponseType,
+                                    mozilla::dom::ResponseType::Basic,
+                                    mozilla::dom::ResponseType::EndGuard_> {};
+  template<>
   struct ParamTraits<mozilla::dom::cache::Namespace> :
     public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
                                     mozilla::dom::cache::DEFAULT_NAMESPACE,
                                     mozilla::dom::cache::NUMBER_OF_NAMESPACES>
   {};
 }
 
 #endif // mozilla_dom_cache_IPCUtils_h
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -29,17 +29,19 @@
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 namespace {
 
 using mozilla::ErrorResult;
 using mozilla::unused;
 using mozilla::void_t;
+using mozilla::dom::InternalHeaders;
 using mozilla::dom::cache::CacheReadStream;
+using mozilla::dom::cache::HeadersEntry;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
@@ -149,16 +151,30 @@ SerializeNormalStream(nsIInputStream* aS
 
   if (fdSet) {
     aReadStreamOut.fds() = fdSet;
   } else {
     aReadStreamOut.fds() = void_t();
   }
 }
 
+void
+ToHeadersEntryList(nsTArray<HeadersEntry>& aOut, InternalHeaders* aHeaders)
+{
+  MOZ_ASSERT(aHeaders);
+
+  nsAutoTArray<InternalHeaders::Entry, 16> entryList;
+  aHeaders->GetEntries(entryList);
+
+  for (uint32_t i = 0; i < entryList.Length(); ++i) {
+    InternalHeaders::Entry& entry = entryList[i];
+    aOut.AppendElement(HeadersEntry(entry.mName, entry.mValue));
+  }
+}
+
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
@@ -240,17 +256,17 @@ TypeUtils::ToCacheRequest(CacheRequest& 
 
   if (aReferrerAction == ExpandReferrer) {
     UpdateRequestReferrer(GetGlobalObject(), aIn);
   }
   aIn->GetReferrer(aOut.referrer());
 
   nsRefPtr<InternalHeaders> headers = aIn->Headers();
   MOZ_ASSERT(headers);
-  headers->GetPHeaders(aOut.headers());
+  ToHeadersEntryList(aOut.headers(), headers);
   aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn->Mode();
   aOut.credentials() = aIn->GetCredentialsMode();
   aOut.contentPolicyType() = aIn->ContentPolicyType();
   aOut.context() = aIn->Context();
   aOut.requestCache() = aIn->GetCacheMode();
 
   if (aBodyAction == IgnoreBody) {
@@ -290,17 +306,17 @@ TypeUtils::ToCacheResponseWithoutBody(Ca
   aOut.status() = aIn.GetStatus();
   aOut.statusText() = aIn.GetStatusText();
   nsRefPtr<InternalHeaders> headers = aIn.UnfilteredHeaders();
   MOZ_ASSERT(headers);
   if (HasVaryStar(headers)) {
     aRv.ThrowTypeError(MSG_RESPONSE_HAS_VARY_STAR);
     return;
   }
-  headers->GetPHeaders(aOut.headers());
+  ToHeadersEntryList(aOut.headers(), headers);
   aOut.headersGuard() = headers->Guard();
   aOut.securityInfo() = aIn.GetSecurityInfo();
 }
 
 void
 TypeUtils::ToCacheResponse(CacheResponse& aOut, Response& aIn, ErrorResult& aRv)
 {
   if (aIn.BodyUsed()) {
@@ -351,17 +367,17 @@ TypeUtils::ToResponse(const CacheRespons
     return r.forget();
   }
 
   nsRefPtr<InternalResponse> ir = new InternalResponse(aIn.status(),
                                                        aIn.statusText());
   ir->SetUrl(NS_ConvertUTF16toUTF8(aIn.url()));
 
   nsRefPtr<InternalHeaders> internalHeaders =
-    new InternalHeaders(aIn.headers(), aIn.headersGuard());
+    ToInternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
   ir->Headers()->SetGuard(aIn.headersGuard(), result);
   MOZ_ASSERT(!result.Failed());
   ir->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
   ir->SetSecurityInfo(aIn.securityInfo());
 
@@ -403,17 +419,17 @@ TypeUtils::ToInternalRequest(const Cache
   internalRequest->SetContentPolicyType(aIn.contentPolicyType());
   DebugOnly<RequestContext> contextAfterSetContentPolicyType = internalRequest->Context();
   internalRequest->SetContext(aIn.context());
   MOZ_ASSERT(contextAfterSetContentPolicyType.value == internalRequest->Context(),
              "The RequestContext and nsContentPolicyType values should not get out of sync");
   internalRequest->SetCacheMode(aIn.requestCache());
 
   nsRefPtr<InternalHeaders> internalHeaders =
-    new InternalHeaders(aIn.headers(), aIn.headersGuard());
+    ToInternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
   internalRequest->Headers()->SetGuard(aIn.headersGuard(), result);
   MOZ_ASSERT(!result.Failed());
   internalRequest->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
   nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
 
@@ -425,16 +441,33 @@ TypeUtils::ToInternalRequest(const Cache
 already_AddRefed<Request>
 TypeUtils::ToRequest(const CacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = ToInternalRequest(aIn);
   nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
   return request.forget();
 }
 
+// static
+already_AddRefed<InternalHeaders>
+TypeUtils::ToInternalHeaders(const nsTArray<HeadersEntry>& aHeadersEntryList,
+                             HeadersGuardEnum aGuard)
+{
+  nsTArray<InternalHeaders::Entry> entryList(aHeadersEntryList.Length());
+
+  for (uint32_t i = 0; i < aHeadersEntryList.Length(); ++i) {
+    const HeadersEntry& headersEntry = aHeadersEntryList[i];
+    entryList.AppendElement(InternalHeaders::Entry(headersEntry.name(),
+                                                   headersEntry.value()));
+  }
+
+  nsRefPtr<InternalHeaders> ref = new InternalHeaders(Move(entryList), aGuard);
+  return ref.forget();
+}
+
 void
 TypeUtils::CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                                ErrorResult& aRv)
 {
   MOZ_ASSERT(aRequest);
 
   if (aBodyAction == IgnoreBody) {
     return;
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_TypesUtils_h
 #define mozilla_dom_cache_TypesUtils_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/InternalHeaders.h"
 #include "nsError.h"
 
 class nsIGlobalObject;
 class nsIAsyncInputStream;
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
@@ -29,16 +30,17 @@ class Response;
 namespace cache {
 
 class CachePushStreamChild;
 class CacheQueryParams;
 class CacheReadStream;
 class CacheReadStreamOrVoid;
 class CacheRequest;
 class CacheResponse;
+class HeadersEntry;
 
 class TypeUtils
 {
 public:
   enum BodyAction
   {
     IgnoreBody,
     ReadBody
@@ -95,16 +97,21 @@ public:
   ToResponse(const CacheResponse& aIn);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const CacheRequest& aIn);
 
   already_AddRefed<Request>
   ToRequest(const CacheRequest& aIn);
 
+  // static methods
+  static already_AddRefed<InternalHeaders>
+  ToInternalHeaders(const nsTArray<HeadersEntry>& aHeadersEntryList,
+                    HeadersGuardEnum aGuard = HeadersGuardEnum::None);
+
 private:
   void
   CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                       ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const nsAString& aIn, ErrorResult& aRv);
 
diff --git a/dom/fetch/FetchIPCUtils.h b/dom/fetch/FetchIPCUtils.h
deleted file mode 100644
--- a/dom/fetch/FetchIPCUtils.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_FetchIPCUtils_h
-#define mozilla_dom_FetchIPCUtils_h
-
-#include "ipc/IPCMessageUtils.h"
-
-// Fix X11 header brain damage that conflicts with HeadersGuardEnum::None
-#undef None
-
-#include "mozilla/dom/HeadersBinding.h"
-#include "mozilla/dom/Request.h"
-#include "mozilla/dom/Response.h"
-
-namespace IPC {
-  template<>
-  struct ParamTraits<mozilla::dom::HeadersGuardEnum> :
-    public ContiguousEnumSerializer<mozilla::dom::HeadersGuardEnum,
-                                    mozilla::dom::HeadersGuardEnum::None,
-                                    mozilla::dom::HeadersGuardEnum::EndGuard_> {};
-  template<>
-  struct ParamTraits<mozilla::dom::RequestMode> :
-    public ContiguousEnumSerializer<mozilla::dom::RequestMode,
-                                    mozilla::dom::RequestMode::Same_origin,
-                                    mozilla::dom::RequestMode::EndGuard_> {};
-  template<>
-  struct ParamTraits<mozilla::dom::RequestCredentials> :
-    public ContiguousEnumSerializer<mozilla::dom::RequestCredentials,
-                                    mozilla::dom::RequestCredentials::Omit,
-                                    mozilla::dom::RequestCredentials::EndGuard_> {};
-  template<>
-  struct ParamTraits<mozilla::dom::RequestCache> :
-    public ContiguousEnumSerializer<mozilla::dom::RequestCache,
-                                    mozilla::dom::RequestCache::Default,
-                                    mozilla::dom::RequestCache::EndGuard_> {};
-  template<>
-  struct ParamTraits<mozilla::dom::RequestContext> :
-    public ContiguousEnumSerializer<mozilla::dom::RequestContext,
-                                    mozilla::dom::RequestContext::Audio,
-                                    mozilla::dom::RequestContext::EndGuard_> {};
-  template<>
-  struct ParamTraits<mozilla::dom::ResponseType> :
-    public ContiguousEnumSerializer<mozilla::dom::ResponseType,
-                                    mozilla::dom::ResponseType::Basic,
-                                    mozilla::dom::ResponseType::EndGuard_> {};
-}
-
-#endif // mozilla_dom_FetchIPCUtils_h
diff --git a/dom/fetch/InternalHeaders.cpp b/dom/fetch/InternalHeaders.cpp
--- a/dom/fetch/InternalHeaders.cpp
+++ b/dom/fetch/InternalHeaders.cpp
@@ -2,41 +2,30 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/InternalHeaders.h"
 
 #include "mozilla/ErrorResult.h"
-#include "mozilla/dom/PHeaders.h"
 
 #include "nsCharSeparatedTokenizer.h"
 #include "nsContentUtils.h"
 #include "nsNetUtil.h"
 #include "nsReadableUtils.h"
 
 namespace mozilla {
 namespace dom {
 
-InternalHeaders::InternalHeaders(const nsTArray<PHeadersEntry>& aHeaders,
+InternalHeaders::InternalHeaders(const nsTArray<Entry>&& aHeaders,
                                  HeadersGuardEnum aGuard)
   : mGuard(aGuard)
+  , mList(aHeaders)
 {
-  for (uint32_t i = 0; i < aHeaders.Length(); ++i) {
-    mList.AppendElement(Entry(aHeaders[i].name(), aHeaders[i].value()));
-  }
-}
-
-void
-InternalHeaders::GetPHeaders(nsTArray<PHeadersEntry>& aPHeadersOut) const
-{
-  for (uint32_t i = 0; i < mList.Length(); ++i) {
-    aPHeadersOut.AppendElement(PHeadersEntry(mList[i].mName, mList[i].mValue));
-  }
 }
 
 void
 InternalHeaders::Append(const nsACString& aName, const nsACString& aValue,
                         ErrorResult& aRv)
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
diff --git a/dom/fetch/InternalHeaders.h b/dom/fetch/InternalHeaders.h
--- a/dom/fetch/InternalHeaders.h
+++ b/dom/fetch/InternalHeaders.h
@@ -19,17 +19,16 @@ class nsPIDOMWindow;
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
 template<typename T> class MozMap;
 class HeadersOrByteStringSequenceSequenceOrByteStringMozMap;
-class PHeadersEntry;
 
 class InternalHeaders final
 {
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(InternalHeaders)
 
 public:
   struct Entry
   {
@@ -57,17 +56,17 @@ public:
   explicit InternalHeaders(const InternalHeaders& aOther)
     : mGuard(aOther.mGuard)
   {
     ErrorResult result;
     Fill(aOther, result);
     MOZ_ASSERT(!result.Failed());
   }
 
-  explicit InternalHeaders(const nsTArray<PHeadersEntry>& aHeaders,
+  explicit InternalHeaders(const nsTArray<Entry>&& aHeaders,
                            HeadersGuardEnum aGuard = HeadersGuardEnum::None);
 
   void Append(const nsACString& aName, const nsACString& aValue,
               ErrorResult& aRv);
   void Delete(const nsACString& aName, ErrorResult& aRv);
   void Get(const nsACString& aName, nsCString& aValue, ErrorResult& aRv) const;
   void GetAll(const nsACString& aName, nsTArray<nsCString>& aResults,
               ErrorResult& aRv) const;
@@ -87,19 +86,16 @@ public:
 
   static already_AddRefed<InternalHeaders>
   BasicHeaders(InternalHeaders* aHeaders);
 
   static already_AddRefed<InternalHeaders>
   CORSHeaders(InternalHeaders* aHeaders);
 
   void
-  GetPHeaders(nsTArray<PHeadersEntry>& aPHeadersOut) const;
-
-  void
   GetEntries(nsTArray<InternalHeaders::Entry>& aEntries) const;
 
   void
   GetUnsafeHeaders(nsTArray<nsCString>& aNames) const;
 private:
   virtual ~InternalHeaders();
 
   static bool IsInvalidName(const nsACString& aName, ErrorResult& aRv);
diff --git a/dom/fetch/PHeaders.ipdlh b/dom/fetch/PHeaders.ipdlh
deleted file mode 100644
--- a/dom/fetch/PHeaders.ipdlh
+++ /dev/null
@@ -1,15 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-namespace mozilla {
-namespace dom {
-
-struct PHeadersEntry
-{
-  nsCString name;
-  nsCString value;
-};
-
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/fetch/moz.build b/dom/fetch/moz.build
--- a/dom/fetch/moz.build
+++ b/dom/fetch/moz.build
@@ -2,17 +2,16 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
     'Fetch.h',
     'FetchDriver.h',
-    'FetchIPCUtils.h',
     'Headers.h',
     'InternalHeaders.h',
     'InternalRequest.h',
     'InternalResponse.h',
     'Request.h',
     'Response.h',
 ]
 
@@ -22,22 +21,16 @@ UNIFIED_SOURCES += [
     'Headers.cpp',
     'InternalHeaders.cpp',
     'InternalRequest.cpp',
     'InternalResponse.cpp',
     'Request.cpp',
     'Response.cpp',
 ]
 
-IPDL_SOURCES += [
-    'PHeaders.ipdlh',
-]
-
-include('/ipc/chromium/chromium-config.mozbuild')
-
 LOCAL_INCLUDES += [
     '../workers',
     # For nsDataHandler.h
     '/netwerk/protocol/data',
 ]
 
 FAIL_ON_WARNINGS = True
 MSVC_ENABLE_PGO = True
