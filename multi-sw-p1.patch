# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ffac2798999c5b84f1b4605a1280994bb665a406
Multiple SW instances P1

diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -151,17 +151,18 @@ ServiceWorkerPrivate::SendMessageEvent(J
     return rv.StealNSResult();
   }
 
   nsMainThreadPtrHandle<nsISupports> token(
     new nsMainThreadPtrHolder<nsISupports>(CreateEventKeepAliveToken()));
 
   RefPtr<PromiseNativeHandler> handler = new MessageWaitUntilHandler(token);
 
-  mWorkerPrivate->PostMessageToServiceWorker(aCx, aMessage, aTransferable,
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
+  workerPrivate->PostMessageToServiceWorker(aCx, aMessage, aTransferable,
                                              Move(aClientInfo), handler,
                                              rv);
   return rv.StealNSResult();
 }
 
 namespace {
 
 class CheckScriptEvaluationWithCallback final : public WorkerRunnable
@@ -223,17 +224,18 @@ private:
 
 nsresult
 ServiceWorkerPrivate::CheckScriptEvaluation(LifeCycleEventCallback* aCallback)
 {
   nsresult rv = SpawnWorkerIfNeeded(LifeCycleEvent, nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
-  RefPtr<WorkerRunnable> r = new CheckScriptEvaluationWithCallback(mWorkerPrivate,
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
+  RefPtr<WorkerRunnable> r = new CheckScriptEvaluationWithCallback(workerPrivate,
                                                                    token,
                                                                    aCallback);
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
@@ -713,17 +715,18 @@ nsresult
 ServiceWorkerPrivate::SendLifeCycleEvent(const nsAString& aEventType,
                                          LifeCycleEventCallback* aCallback,
                                          nsIRunnable* aLoadFailure)
 {
   nsresult rv = SpawnWorkerIfNeeded(LifeCycleEvent, aLoadFailure);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
-  RefPtr<WorkerRunnable> r = new LifecycleEventWorkerRunnable(mWorkerPrivate,
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
+  RefPtr<WorkerRunnable> r = new LifecycleEventWorkerRunnable(workerPrivate,
                                                               token,
                                                               aEventType,
                                                               aCallback);
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
@@ -908,17 +911,18 @@ ServiceWorkerPrivate::SendPushEvent(cons
   nsresult rv = SpawnWorkerIfNeeded(PushEvent, nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> regInfo(
     new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(aRegistration, false));
 
-  RefPtr<WorkerRunnable> r = new SendPushEventRunnable(mWorkerPrivate,
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
+  RefPtr<WorkerRunnable> r = new SendPushEventRunnable(workerPrivate,
                                                        token,
                                                        aMessageId,
                                                        aData,
                                                        regInfo);
 
   if (mInfo->State() == ServiceWorkerState::Activating) {
     mPendingFunctionalEvents.AppendElement(r.forget());
     return NS_OK;
@@ -939,18 +943,19 @@ ServiceWorkerPrivate::SendPushSubscripti
 {
 #ifdef MOZ_SIMPLEPUSH
   return NS_ERROR_NOT_AVAILABLE;
 #else
   nsresult rv = SpawnWorkerIfNeeded(PushSubscriptionChangeEvent, nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
   RefPtr<WorkerRunnable> r =
-    new SendPushSubscriptionChangeEventRunnable(mWorkerPrivate, token);
+    new SendPushSubscriptionChangeEventRunnable(workerPrivate, token);
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 #endif // MOZ_SIMPLEPUSH
 }
 
@@ -1230,18 +1235,19 @@ ServiceWorkerPrivate::SendNotificationEv
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv = SpawnWorkerIfNeeded(why, nullptr);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
 
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
   RefPtr<WorkerRunnable> r =
-    new SendNotificationEventRunnable(mWorkerPrivate, token,
+    new SendNotificationEventRunnable(workerPrivate, token,
                                       aEventName, aID, aTitle, aDir, aLang,
                                       aBody, aTag, aIcon, aData, aBehavior,
                                       aScope);
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
@@ -1633,19 +1639,20 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     swm->GetRegistration(mInfo->GetPrincipal(), mInfo->Scope());
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> regInfo(
     new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(registration, false));
 
   RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
+  WorkerPrivate* workerPrivate = GetNextWorkerPrivate();
 
   RefPtr<FetchEventRunnable> r =
-    new FetchEventRunnable(mWorkerPrivate, token, handle,
+    new FetchEventRunnable(workerPrivate, token, handle,
                            mInfo->ScriptSpec(), regInfo,
                            aDocumentId, aIsReload);
   rv = r->Init();
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   if (mInfo->State() == ServiceWorkerState::Activating) {
@@ -2014,9 +2021,15 @@ ServiceWorkerPrivate::CreateEventKeepAli
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(mWorkerPrivate);
   MOZ_ASSERT(mIdleKeepAliveToken);
   RefPtr<KeepAliveToken> ref = new KeepAliveToken(this);
   return ref.forget();
 }
 
+WorkerPrivate*
+ServiceWorkerPrivate::GetNextWorkerPrivate() const
+{
+  return mWorkerPrivate;
+}
+
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -187,16 +187,19 @@ private:
                       nsIRunnable* aLoadFailedRunnable,
                       nsILoadGroup* aLoadGroup = nullptr);
 
   ~ServiceWorkerPrivate();
 
   already_AddRefed<KeepAliveToken>
   CreateEventKeepAliveToken();
 
+  WorkerPrivate*
+  GetNextWorkerPrivate() const;
+
   // The info object owns us. It is possible to outlive it for a brief period
   // of time if there are pending waitUntil promises, in which case it
   // will be null and |SpawnWorkerIfNeeded| will always fail.
   ServiceWorkerInfo* MOZ_NON_OWNING_REF mInfo;
 
   // The WorkerPrivate object can only be closed by this class or by the
   // RuntimeService class if gecko is shutting down. Closing the worker
   // multiple times is OK, since the second attempt will be a no-op.
