# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dc29290880158be876ec7721ef1b0b7747f10874

diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -34,16 +34,17 @@ uint32_t sClientManagerThreadLocalMagic1
 uint32_t sClientManagerThreadLocalIndex = kBadThreadLocalIndex;
 uint32_t sClientManagerThreadLocalMagic2 = kThreadLocalMagic2;
 uint32_t sClientManagerThreadLocalIndexDuplicate = kBadThreadLocalIndex;
 
 } // anonymous namespace
 
 ClientManager::ClientManager()
 {
+  printf_stderr("### ### [%p] ClientManager::%s\n", this, __func__);
   PBackgroundChild* parentActor = BackgroundChild::GetOrCreateForCurrentThread();
   if (NS_WARN_IF(!parentActor)) {
     Shutdown();
     return;
   }
 
   RefPtr<WorkerHolderToken> workerHolderToken;
   if (!NS_IsMainThread()) {
@@ -76,16 +77,17 @@ ClientManager::ClientManager()
   MOZ_DIAGNOSTIC_ASSERT(sentActor == actor);
 
   ActivateThing(actor);
 }
 
 ClientManager::~ClientManager()
 {
   NS_ASSERT_OWNINGTHREAD(ClientManager);
+  printf_stderr("### ### [%p] ClientManager::%s\n", this, __func__);
 
   Shutdown();
 
   MOZ_RELEASE_ASSERT(sClientManagerThreadLocalMagic1 == kThreadLocalMagic1);
   MOZ_RELEASE_ASSERT(sClientManagerThreadLocalMagic2 == kThreadLocalMagic2);
   MOZ_RELEASE_ASSERT(sClientManagerThreadLocalIndex != kBadThreadLocalIndex);
   MOZ_RELEASE_ASSERT(sClientManagerThreadLocalIndex == sClientManagerThreadLocalIndexDuplicate);
   MOZ_RELEASE_ASSERT(this == PR_GetThreadPrivate(sClientManagerThreadLocalIndex));
diff --git a/dom/clients/manager/ClientManagerChild.cpp b/dom/clients/manager/ClientManagerChild.cpp
--- a/dom/clients/manager/ClientManagerChild.cpp
+++ b/dom/clients/manager/ClientManagerChild.cpp
@@ -12,23 +12,26 @@
 #include "ClientSourceChild.h"
 
 namespace mozilla {
 namespace dom {
 
 void
 ClientManagerChild::ActorDestroy(ActorDestroyReason aReason)
 {
+  printf_stderr("### ### [%p] ClientManagerChild::%s\n", this, __func__);
   if (mWorkerHolderToken) {
+    printf_stderr("### ### [%p] ClientManagerChild::%s clear holder token\n", this, __func__);
     mWorkerHolderToken->RemoveListener(this);
     mWorkerHolderToken = nullptr;
 
   }
 
   if (mManager) {
+    printf_stderr("### ### [%p] ClientManagerChild::%s revoke manager actor\n", this, __func__);
     mManager->RevokeActor(this);
 
     // Revoking the actor link should automatically cause the owner
     // to call RevokeOwner() as well.
     MOZ_DIAGNOSTIC_ASSERT(!mManager);
   }
 }
 
@@ -92,25 +95,27 @@ ClientManagerChild::DeallocPClientSource
 {
   delete aActor;
   return true;
 }
 
 void
 ClientManagerChild::WorkerShuttingDown()
 {
+  printf_stderr("### ### [%p] ClientManagerChild::%s\n", this, __func__);
   MaybeStartTeardown();
 }
 
 ClientManagerChild::ClientManagerChild(WorkerHolderToken* aWorkerHolderToken)
   : mManager(nullptr)
   , mWorkerHolderToken(aWorkerHolderToken)
   , mTeardownStarted(false)
 {
   MOZ_ASSERT_IF(!NS_IsMainThread(), mWorkerHolderToken);
+  printf_stderr("### ### [%p] ClientManagerChild::%s\n", this, __func__);
 
   if (mWorkerHolderToken) {
     mWorkerHolderToken->AddListener(this);
   }
 }
 
 void
 ClientManagerChild::SetOwner(ClientThing<ClientManagerChild>* aThing)
@@ -130,16 +135,17 @@ ClientManagerChild::RevokeOwner(ClientTh
 
 void
 ClientManagerChild::MaybeStartTeardown()
 {
   if (mTeardownStarted) {
     return;
   }
   mTeardownStarted = true;
+  printf_stderr("### ### [%p] ClientManagerChild::%s\n", this, __func__);
   SendTeardown();
 }
 
 WorkerPrivate*
 ClientManagerChild::GetWorkerPrivate() const
 {
   if (!mWorkerHolderToken) {
     return nullptr;
diff --git a/dom/serviceworkers/test/browser_storage_permission.js b/dom/serviceworkers/test/browser_storage_permission.js
--- a/dom/serviceworkers/test/browser_storage_permission.js
+++ b/dom/serviceworkers/test/browser_storage_permission.js
@@ -37,38 +37,41 @@ add_task(async function setup() {
         });
       });
     }
   );
 
   BrowserTestUtils.removeTab(tab);
 });
 
+/*
 add_task(async function test_allow_permission() {
   Services.perms.add(Services.io.newURI(PAGE_URI), "cookie",
                      Ci.nsICookiePermission.ACCESS_ALLOW);
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_allow";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   ok(!!controller, "page should be controlled with storage allowed");
 
   BrowserTestUtils.removeTab(tab);
 });
 
 add_task(async function test_deny_permission() {
   Services.perms.add(Services.io.newURI(PAGE_URI), "cookie",
                      Ci.nsICookiePermission.ACCESS_DENY);
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_deny";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   is(controller, null, "page should be not controlled with storage denied");
@@ -76,17 +79,18 @@ add_task(async function test_deny_permis
   BrowserTestUtils.removeTab(tab);
   Services.perms.remove(Services.io.newURI(PAGE_URI), "cookie");
 });
 
 add_task(async function test_session_permission() {
   Services.perms.add(Services.io.newURI(PAGE_URI), "cookie",
                      Ci.nsICookiePermission.ACCESS_SESSION);
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_session";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   is(controller, null, "page should be not controlled with session storage");
@@ -96,17 +100,18 @@ add_task(async function test_session_per
 });
 
 // Test to verify an about:blank iframe successfully inherits the
 // parent's controller when storage is blocked between opening the
 // parent page and creating the iframe.
 add_task(async function test_block_storage_before_blank_iframe() {
   Services.perms.remove(Services.io.newURI(PAGE_URI), "cookie");
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_before_blank";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   ok(!!controller, "page should be controlled with storage allowed");
@@ -138,17 +143,18 @@ add_task(async function test_block_stora
 });
 
 // Test to verify a blob URL iframe successfully inherits the
 // parent's controller when storage is blocked between opening the
 // parent page and creating the iframe.
 add_task(async function test_block_storage_before_blob_iframe() {
   Services.perms.remove(Services.io.newURI(PAGE_URI), "cookie");
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_before_blob";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   ok(!!controller, "page should be controlled with storage allowed");
@@ -179,60 +185,70 @@ add_task(async function test_block_stora
     return !!f.contentWindow.navigator.serviceWorker.controller;
   });
 
   ok(!!controller3, "page should be controlled with storage allowed");
 
   await SpecialPowers.popPrefEnv();
   BrowserTestUtils.removeTab(tab);
 });
+*/
 
 // Test to verify a blob worker script does not hit our service
 // worker storage assertions when storage is blocked between opening
 // the parent page and creating the worker.  Note, we cannot
 // explicitly check if the worker is controlled since we don't expose
 // WorkerNavigator.serviceWorkers.controller yet.
 add_task(async function test_block_storage_before_blob_worker() {
   Services.perms.remove(Services.io.newURI(PAGE_URI), "cookie");
 
-  let tab = BrowserTestUtils.addTab(gBrowser, SCOPE);
+  const scope = SCOPE + "_before_blob_worker";
+  let tab = BrowserTestUtils.addTab(gBrowser, scope);
   let browser = gBrowser.getBrowserForTab(tab);
   await BrowserTestUtils.browserLoaded(browser);
 
   let controller = await ContentTask.spawn(browser, null, async function() {
     return content.navigator.serviceWorker.controller;
   });
 
   ok(!!controller, "page should be controlled with storage allowed");
 
   let scriptURL = await ContentTask.spawn(browser, null, async function() {
-    let b = new content.Blob(["self.postMessage(self.location.href);self.close()"],
+    let b = new content.Blob(["self.postMessage(self.location.href);"],
                              { type: "application/javascript" });
-    // No need to call revokeObjectURL() since the window will be closed shortly.
     let u = content.URL.createObjectURL(b);
     let w = new content.Worker(u);
     return await new Promise(resolve => {
-      w.onmessage = e => resolve(e.data);
+      w.onmessage = e => {
+        content.URL.revokeObjectURL(u);
+        w.terminate();
+        w.onmessage = null;
+        resolve(e.data);
+      };
     });
   });
 
   ok(scriptURL.startsWith("blob:"), "blob URL worker should run");
 
   await SpecialPowers.pushPrefEnv({"set": [
     ["network.cookie.cookieBehavior", Ci.nsICookieService.BEHAVIOR_REJECT],
   ]});
 
   let scriptURL2 = await ContentTask.spawn(browser, null, async function() {
-    let b = new content.Blob(["self.postMessage(self.location.href);self.close()"],
+    let b = new content.Blob(["self.postMessage(self.location.href);"],
                              { type: "application/javascript" });
-    // No need to call revokeObjectURL() since the window will be closed shortly.
     let u = content.URL.createObjectURL(b);
     let w = new content.Worker(u);
     return await new Promise(resolve => {
-      w.onmessage = e => resolve(e.data);
+      w.onmessage = e => {
+        content.URL.revokeObjectURL(u);
+        w.terminate();
+        w.onmessage = null;
+        resolve(e.data);
+      };
     });
   });
 
   ok(scriptURL2.startsWith("blob:"), "blob URL worker should run");
 
   await SpecialPowers.popPrefEnv();
   BrowserTestUtils.removeTab(tab);
 });
@@ -258,9 +274,11 @@ add_task(async function cleanup() {
           worker.removeEventListener("statechange", onStateChange);
           resolve();
         }
       });
     });
   });
 
   BrowserTestUtils.removeTab(tab);
+
+  await new Promise(resolve => SpecialPowers.exactGC(resolve));
 });
