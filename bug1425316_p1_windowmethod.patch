# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f7e3e4db671267b0ed021fc3f0574a8fae55db6b
Bug 1425316 P1 Expose a chrome-only Window.shouldReportForServiceWorkerScope() method that initially forwards to ServiceWorkerManager. r=asuth

diff --git a/devtools/server/actors/webconsole/listeners.js b/devtools/server/actors/webconsole/listeners.js
--- a/devtools/server/actors/webconsole/listeners.js
+++ b/devtools/server/actors/webconsole/listeners.js
@@ -278,17 +278,17 @@ ConsoleAPIListener.prototype =
     let workerType = WebConsoleUtils.getWorkerType(message);
 
     if (this.window && workerType === "ServiceWorker") {
       // For messages from Service Workers, message.ID is the
       // scope, which can be used to determine whether it's controlling
       // a window.
       let scope = message.ID;
 
-      if (!swm.shouldReportToWindow(this.window, scope)) {
+      if (!this.window.shouldReportForServiceWorkerScope(scope)) {
         return false;
       }
     }
 
     if (this.window && !workerType) {
       let msgWindow = Services.wm.getCurrentInnerWindowWithId(message.innerID);
       if (!msgWindow || !isWindowIncluded(this.window, msgWindow)) {
         // Not the same window!
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -75,16 +75,17 @@
 #include "mozilla/Sprintf.h"
 #include "mozilla/Unused.h"
 
 // Other Classes
 #include "mozilla/dom/BarProps.h"
 #include "nsContentCID.h"
 #include "nsLayoutStatics.h"
 #include "nsCCUncollectableMarker.h"
+#include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/dom/workers/Workers.h"
 #include "mozilla/dom/ToJSValue.h"
 #include "nsJSPrincipals.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/Debug.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/EventStates.h"
 #include "mozilla/MouseEvents.h"
@@ -2325,16 +2326,31 @@ nsPIDOMWindowInner::GetClientState() con
 }
 
 Maybe<ServiceWorkerDescriptor>
 nsPIDOMWindowInner::GetController() const
 {
   return Move(nsGlobalWindowInner::Cast(this)->GetController());
 }
 
+bool
+nsGlobalWindowInner::ShouldReportForServiceWorkerScope(const nsAString& aScope)
+{
+  RefPtr<workers::ServiceWorkerManager> swm =
+    workers::ServiceWorkerManager::GetInstance();
+  NS_ENSURE_TRUE(swm, false);
+
+  bool aResult = false;
+  nsresult rv = swm->ShouldReportToWindow(GetOuterWindowInternal(),
+                                          NS_ConvertUTF16toUTF8(aScope), &aResult);
+  NS_ENSURE_SUCCESS(rv, false);
+
+  return aResult;
+}
+
 void
 nsGlobalWindowInner::UpdateTopInnerWindow()
 {
   if (IsTopInnerWindow() || !mTopInnerWindow) {
     return;
   }
 
   mTopInnerWindow->UpdateWebSocketCount(-(int32_t)mNumOfOpenWebSockets);
diff --git a/dom/base/nsGlobalWindowInner.h b/dom/base/nsGlobalWindowInner.h
--- a/dom/base/nsGlobalWindowInner.h
+++ b/dom/base/nsGlobalWindowInner.h
@@ -966,16 +966,18 @@ public:
                       mozilla::ErrorResult& aError);
 
   void GetInterface(JSContext* aCx, nsIJSID* aIID,
                     JS::MutableHandle<JS::Value> aRetval,
                     mozilla::ErrorResult& aError);
 
   already_AddRefed<nsWindowRoot> GetWindowRoot(mozilla::ErrorResult& aError);
 
+  bool ShouldReportForServiceWorkerScope(const nsAString& aScope);
+
   void UpdateTopInnerWindow();
 
   virtual bool IsInSyncOperation() override
   {
     return GetExtantDoc() && GetExtantDoc()->IsInSyncOperation();
   }
 
 protected:
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -229,15 +229,13 @@ interface nsIServiceWorkerManager : nsIS
                                      [optional] in uint32_t aDataLength,
                                      [optional, array, size_is(aDataLength)] in uint8_t aDataBytes);
   void sendPushSubscriptionChangeEvent(in ACString aOriginAttributes,
                                        in ACString scope);
 
   void addListener(in nsIServiceWorkerManagerListener aListener);
 
   void removeListener(in nsIServiceWorkerManagerListener aListener);
-
-  bool shouldReportToWindow(in mozIDOMWindowProxy aWindow, in ACString aScope);
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/webidl/Window.webidl b/dom/webidl/Window.webidl
--- a/dom/webidl/Window.webidl
+++ b/dom/webidl/Window.webidl
@@ -338,16 +338,23 @@ partial interface Window {
 
   [Throws, ChromeOnly] any getInterface(IID iid);
 
   /**
    * Same as nsIDOMWindow.windowRoot, useful for event listener targeting.
    */
   [ChromeOnly, Throws]
   readonly attribute WindowRoot? windowRoot;
+
+  /**
+   * ChromeOnly method to determine if a particular window should see console
+   * reports from service workers of the given scope.
+   */
+  [ChromeOnly]
+  boolean shouldReportForServiceWorkerScope(USVString aScope);
 };
 
 Window implements TouchEventHandlers;
 
 Window implements OnErrorEventHandlerForWindow;
 
 #if defined(MOZ_WIDGET_ANDROID)
 // https://compat.spec.whatwg.org/#windoworientation-interface
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -3626,17 +3626,17 @@ ServiceWorkerManager::RemoveListener(nsI
     return NS_ERROR_INVALID_ARG;
   }
 
   mListeners.RemoveElement(aListener);
 
   return NS_OK;
 }
 
-NS_IMETHODIMP
+nsresult
 ServiceWorkerManager::ShouldReportToWindow(mozIDOMWindowProxy* aWindow,
                                            const nsACString& aScope,
                                            bool* aResult)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aResult);
 
   *aResult = false;
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -319,16 +319,20 @@ public:
   NotifyUnregister(nsIPrincipal* aPrincipal, const nsAString& aScope);
 
   void
   WorkerIsIdle(ServiceWorkerInfo* aWorker);
 
   void
   CheckPendingReadyPromises();
 
+  nsresult
+  ShouldReportToWindow(mozIDOMWindowProxy* aWindow, const nsACString& aScope,
+                       bool* aResult);
+
 private:
   ServiceWorkerManager();
   ~ServiceWorkerManager();
 
   void
   Init(ServiceWorkerRegistrar* aRegistrar);
 
   void
