# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  00e38d42c5f2c981aa018b1f7db210e079895613
Bug 1387211 Avoid potential deadlock during worker shutdown. r=billm

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -6312,30 +6312,43 @@ WorkerPrivate::NotifyInternal(JSContext*
   Status previousStatus;
   {
     MutexAutoLock lock(mMutex);
 
     if (mStatus >= aStatus) {
       return true;
     }
 
+    // Make sure the hybrid event target stops dispatching runnables
+    // once we reaching the killing state.
+    if (aStatus == Killing) {
+      // We need to unlock while disabling the hybrid event target to avoid
+      // a possible deadlock.  During dispatch the event target locks its own
+      // lock and then locks the WorkerPrivate lock.  We would be locking in
+      // the reverse order here.
+      {
+        MutexAutoUnlock unlock(mMutex);
+        mWorkerHybridEventTarget->ForgetWorkerPrivate(this);
+      }
+
+      // Check the status code again in case another NotifyInternal came in
+      // while we were unlocked above.
+      if (mStatus >= aStatus) {
+        return true;
+      }
+    }
+
     previousStatus = mStatus;
     mStatus = aStatus;
 
     // Mark parent status as closing immediately to avoid new events being
     // dispatched after we clear the queue below.
     if (aStatus == Closing) {
       Close();
     }
-
-    // Make sure the hybrid event target stops dispatching runnables
-    // once we reaching the killing state.
-    if (aStatus == Killing) {
-      mWorkerHybridEventTarget->ForgetWorkerPrivate(this);
-    }
   }
 
   if (mCrossThreadDispatcher) {
     // Since we'll no longer process events, make sure we no longer allow
     // anyone to post them. We have to do this without mMutex held, since our
     // mutex must be acquired *after* mCrossThreadDispatcher's mutex when
     // they're both held.
     mCrossThreadDispatcher->Forget();
