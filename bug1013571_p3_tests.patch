# HG changeset patch
# Parent d7e9982e74955e772b99ea56a615008346ae6a7e
# User Ben Kelly <ben@wanderview.com>

diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -56,18 +56,23 @@
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
 #include "SharedWorker.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+
 #include "nsIIPCBackgroundChildCreateCallback.h"
 #include "BackgroundChild.h"
+#ifdef ENABLE_TESTS
+#include "BackgroundChildImpl.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::MutexAutoLock;
 using mozilla::MutexAutoUnlock;
@@ -156,16 +161,20 @@ const JS::ContextOptions kRequiredContex
 uint32_t gMaxWorkersPerDomain = MAX_WORKERS_PER_DOMAIN;
 
 // Does not hold an owning reference.
 RuntimeService* gRuntimeService = nullptr;
 
 // Only non-null during the call to Init.
 RuntimeService* gRuntimeServiceDuringInit = nullptr;
 
+#ifdef ENABLE_TESTS
+bool gTestPBackground = false;
+#endif // ENABLE_TESTS
+
 enum {
   ID_Worker = 0,
   ID_ChromeWorker,
   ID_Event,
   ID_MessageEvent,
   ID_ErrorEvent,
 
   ID_COUNT
@@ -1296,16 +1305,20 @@ RuntimeService::~RuntimeService()
 }
 
 // static
 RuntimeService*
 RuntimeService::GetOrCreateService()
 {
   AssertIsOnMainThread();
 
+#ifdef ENABLE_TESTS
+  gTestPBackground = mozilla::Preferences::GetBool("pbackground.testing", false);
+#endif // ENABLE_TESTS
+
   if (!gRuntimeService) {
     nsRefPtr<RuntimeService> service = new RuntimeService();
     if (NS_FAILED(service->Init())) {
       NS_WARNING("Failed to initialize!");
       service->Cleanup();
       return nullptr;
     }
 
@@ -2638,16 +2651,28 @@ WorkerThreadPrimaryRunnable::Run()
 
     JSContext* cx = CreateJSContextForWorker(mWorkerPrivate, rt);
     if (!cx) {
       // XXX need to fire an error at parent.
       NS_ERROR("Failed to create runtime and context!");
       return NS_ERROR_FAILURE;
     }
 
+#ifdef ENABLE_TESTS
+    using mozilla::ipc::PBackgroundChild;
+    NS_NAMED_LITERAL_CSTRING(testStr, "0123456789");
+    if (gTestPBackground) {
+      PBackgroundChild* existingBackgroundChild =
+        BackgroundChild::GetForCurrentThread();
+      MOZ_RELEASE_ASSERT(existingBackgroundChild);
+      bool ok = existingBackgroundChild->SendPBackgroundTestConstructor(testStr);
+      MOZ_RELEASE_ASSERT(ok);
+    }
+#endif
+
     {
 #ifdef MOZ_ENABLE_PROFILER_SPS
       PseudoStack* stack = mozilla_get_pseudo_stack();
       if (stack) {
         stack->sampleRuntime(rt);
       }
 #endif
 
@@ -2673,16 +2698,26 @@ WorkerThreadPrimaryRunnable::Run()
     // GC.  This is not the last JSContext (WorkerJSRuntime maintains an
     // internal JSContext).
     JS_DestroyContext(cx);
 
     // Now WorkerJSRuntime goes out of scope and its destructor will shut
     // down the cycle collector and destroy the final JSContext.  This
     // breaks any remaining cycles and collects the C++ and JS objects
     // participating.
+
+#ifdef ENABLE_TESTS
+    if (gTestPBackground) {
+      PBackgroundChild* existingBackgroundChild =
+        BackgroundChild::GetForCurrentThread();
+      MOZ_RELEASE_ASSERT(existingBackgroundChild);
+      bool ok = existingBackgroundChild->SendPBackgroundTestConstructor(testStr);
+      MOZ_RELEASE_ASSERT(ok);
+    }
+#endif
   }
 
   mThread->SetWorker(nullptr);
 
   mWorkerPrivate->ScheduleDeletion(WorkerPrivate::WorkerRan);
 
   // It is no longer safe to touch mWorkerPrivate.
   mWorkerPrivate = nullptr;
