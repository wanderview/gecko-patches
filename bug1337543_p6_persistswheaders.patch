# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  28af538b8cc9a61511d82504e42bba0168f48689
Bug 1337543 P6 Persist response headers for offlined service worker scripts. r=baku

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -666,16 +666,17 @@ private:
 
     nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
     MOZ_ASSERT(channel == loadInfo.mChannel);
 
     // We synthesize the result code, but its never exposed to content.
     RefPtr<mozilla::dom::InternalResponse> ir =
       new mozilla::dom::InternalResponse(200, NS_LITERAL_CSTRING("OK"));
     ir->SetBody(loadInfo.mCacheReadStream, InternalResponse::UNKNOWN_BODY_SIZE);
+
     // Drop our reference to the stream now that we've passed it along, so it
     // doesn't hang around once the cache is done with it and keep data alive.
     loadInfo.mCacheReadStream = nullptr;
 
     // Set the channel info of the channel on the response so that it's
     // saved in the cache.
     ir->InitChannelInfo(channel);
 
@@ -694,16 +695,17 @@ private:
     UniquePtr<PrincipalInfo> principalInfo(new PrincipalInfo());
     rv = PrincipalToPrincipalInfo(channelPrincipal, principalInfo.get());
     if (NS_WARN_IF(NS_FAILED(rv))) {
       channel->Cancel(rv);
       return rv;
     }
 
     ir->SetPrincipalInfo(Move(principalInfo));
+    ir->Headers()->FillResponseHeaders(loadInfo.mChannel);
 
     RefPtr<mozilla::dom::Response> response =
       new mozilla::dom::Response(mCacheCreator->Global(), ir);
 
     mozilla::dom::RequestOrUSVString request;
 
     MOZ_ASSERT(!loadInfo.mFullURL.IsEmpty());
     request.SetAsUSVString().Rebind(loadInfo.mFullURL.Data(),
diff --git a/dom/workers/ServiceWorkerScriptCache.cpp b/dom/workers/ServiceWorkerScriptCache.cpp
--- a/dom/workers/ServiceWorkerScriptCache.cpp
+++ b/dom/workers/ServiceWorkerScriptCache.cpp
@@ -235,16 +235,17 @@ class CompareManager final : public Prom
 {
 public:
   NS_DECL_ISUPPORTS
 
   explicit CompareManager(ServiceWorkerRegistrationInfo* aRegistration,
                           CompareCallback* aCallback)
     : mRegistration(aRegistration)
     , mCallback(aCallback)
+    , mInternalHeaders(new InternalHeaders())
     , mState(WaitingForOpen)
     , mNetworkFinished(false)
     , mCacheFinished(false)
     , mInCache(false)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aRegistration);
   }
@@ -429,20 +430,29 @@ public:
   CacheStorage*
   CacheStorage_()
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(mCacheStorage);
     return mCacheStorage;
   }
 
-  void
-  InitChannelInfo(nsIChannel* aChannel)
+  nsresult
+  OnStartRequest(nsIChannel* aChannel)
   {
+    nsresult rv = SetPrincipalInfo(aChannel);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
     mChannelInfo.InitFromChannel(aChannel);
+
+    mInternalHeaders->FillResponseHeaders(aChannel);
+
+    return NS_OK;
   }
 
   nsresult
   SetPrincipalInfo(nsIChannel* aChannel)
   {
     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
     NS_ASSERTION(ssm, "Should never be null!");
 
@@ -557,16 +567,19 @@ private:
       new InternalResponse(200, NS_LITERAL_CSTRING("OK"));
     ir->SetBody(body, mCN->Buffer().Length());
 
     ir->InitChannelInfo(mChannelInfo);
     if (mPrincipalInfo) {
       ir->SetPrincipalInfo(Move(mPrincipalInfo));
     }
 
+    IgnoredErrorResult ignored;
+    ir->Headers()->Fill(*mInternalHeaders, ignored);
+
     RefPtr<Response> response = new Response(aCache->GetGlobalObject(), ir);
 
     RequestOrUSVString request;
     request.SetAsUSVString().Rebind(URL().Data(), URL().Length());
 
     // For now we have to wait until the Put Promise is fulfilled before we can
     // continue since Cache does not yet support starting a read that is being
     // written to.
@@ -589,16 +602,17 @@ private:
   RefPtr<CompareNetwork> mCN;
   RefPtr<CompareCache> mCC;
 
   nsString mURL;
   // Only used if the network script has changed and needs to be cached.
   nsString mNewCacheName;
 
   ChannelInfo mChannelInfo;
+  RefPtr<InternalHeaders> mInternalHeaders;
 
   UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
 
   nsCString mMaxScope;
 
   enum {
     WaitingForOpen,
     WaitingForPut
@@ -688,18 +702,17 @@ CompareNetwork::OnStartRequest(nsIReques
     return NS_OK;
   }
 
 #ifdef DEBUG
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
   MOZ_ASSERT(channel == mChannel);
 #endif
 
-  mManager->InitChannelInfo(mChannel);
-  nsresult rv = mManager->SetPrincipalInfo(mChannel);
+  nsresult rv = mManager->OnStartRequest(mChannel);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
