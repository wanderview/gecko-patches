# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bbfc104da7391f4bee46ff897bd2aeea88d3b5fd
Bug 1260591 Move ServiceWorkerInfo and ServiceWorkerRegistrationInfo into separate files. r=jdm

diff --git a/dom/workers/ServiceWorkerInfo.cpp b/dom/workers/ServiceWorkerInfo.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInfo.cpp
@@ -0,0 +1,200 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerInfo.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+NS_IMPL_ISUPPORTS(ServiceWorkerInfo, nsIServiceWorkerInfo)
+
+NS_IMETHODIMP
+ServiceWorkerInfo::GetScriptSpec(nsAString& aScriptSpec)
+{
+  AssertIsOnMainThread();
+  CopyUTF8toUTF16(mScriptSpec, aScriptSpec);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerInfo::GetCacheName(nsAString& aCacheName)
+{
+  AssertIsOnMainThread();
+  aCacheName = mCacheName;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerInfo::GetDebugger(nsIWorkerDebugger** aResult)
+{
+  if (NS_WARN_IF(!aResult)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return mServiceWorkerPrivate->GetDebugger(aResult);
+}
+
+NS_IMETHODIMP
+ServiceWorkerInfo::AttachDebugger()
+{
+  return mServiceWorkerPrivate->AttachDebugger();
+}
+
+NS_IMETHODIMP
+ServiceWorkerInfo::DetachDebugger()
+{
+  return mServiceWorkerPrivate->DetachDebugger();
+}
+
+void
+ServiceWorkerInfo::AppendWorker(ServiceWorker* aWorker)
+{
+  MOZ_ASSERT(aWorker);
+#ifdef DEBUG
+  nsAutoString workerURL;
+  aWorker->GetScriptURL(workerURL);
+  MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
+#endif
+  MOZ_ASSERT(!mInstances.Contains(aWorker));
+
+  mInstances.AppendElement(aWorker);
+  aWorker->SetState(State());
+}
+
+void
+ServiceWorkerInfo::RemoveWorker(ServiceWorker* aWorker)
+{
+  MOZ_ASSERT(aWorker);
+#ifdef DEBUG
+  nsAutoString workerURL;
+  aWorker->GetScriptURL(workerURL);
+  MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
+#endif
+  MOZ_ASSERT(mInstances.Contains(aWorker));
+
+  mInstances.RemoveElement(aWorker);
+}
+
+namespace {
+
+class ChangeStateUpdater final : public nsRunnable
+{
+public:
+  ChangeStateUpdater(const nsTArray<ServiceWorker*>& aInstances,
+                     ServiceWorkerState aState)
+    : mState(aState)
+  {
+    for (size_t i = 0; i < aInstances.Length(); ++i) {
+      mInstances.AppendElement(aInstances[i]);
+    }
+  }
+
+  NS_IMETHODIMP Run()
+  {
+    // We need to update the state of all instances atomically before notifying
+    // them to make sure that the observed state for all instances inside
+    // statechange event handlers is correct.
+    for (size_t i = 0; i < mInstances.Length(); ++i) {
+      mInstances[i]->SetState(mState);
+    }
+    for (size_t i = 0; i < mInstances.Length(); ++i) {
+      mInstances[i]->DispatchStateChange(mState);
+    }
+
+    return NS_OK;
+  }
+
+private:
+  AutoTArray<RefPtr<ServiceWorker>, 1> mInstances;
+  ServiceWorkerState mState;
+};
+
+}
+
+void
+ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
+{
+  AssertIsOnMainThread();
+#ifdef DEBUG
+  // Any state can directly transition to redundant, but everything else is
+  // ordered.
+  if (aState != ServiceWorkerState::Redundant) {
+    MOZ_ASSERT_IF(mState == ServiceWorkerState::EndGuard_, aState == ServiceWorkerState::Installing);
+    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installing, aState == ServiceWorkerState::Installed);
+    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installed, aState == ServiceWorkerState::Activating);
+    MOZ_ASSERT_IF(mState == ServiceWorkerState::Activating, aState == ServiceWorkerState::Activated);
+  }
+  // Activated can only go to redundant.
+  MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
+#endif
+  // Flush any pending functional events to the worker when it transitions to the
+  // activated state.
+  // TODO: Do we care that these events will race with the propagation of the
+  //       state change?
+  if (aState == ServiceWorkerState::Activated && mState != aState) {
+    mServiceWorkerPrivate->Activated();
+  }
+  mState = aState;
+  nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
+}
+
+ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
+                                     const nsACString& aScope,
+                                     const nsACString& aScriptSpec,
+                                     const nsAString& aCacheName)
+  : mPrincipal(aPrincipal)
+  , mScope(aScope)
+  , mScriptSpec(aScriptSpec)
+  , mCacheName(aCacheName)
+  , mState(ServiceWorkerState::EndGuard_)
+  , mServiceWorkerID(GetNextID())
+  , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
+  , mSkipWaitingFlag(false)
+{
+  MOZ_ASSERT(mPrincipal);
+  MOZ_ASSERT(!mScope.IsEmpty());
+  MOZ_ASSERT(!mScriptSpec.IsEmpty());
+  MOZ_ASSERT(!mCacheName.IsEmpty());
+}
+
+ServiceWorkerInfo::~ServiceWorkerInfo()
+{
+  MOZ_ASSERT(mServiceWorkerPrivate);
+  mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
+}
+
+static uint64_t gServiceWorkerInfoCurrentID = 0;
+
+uint64_t
+ServiceWorkerInfo::GetNextID() const
+{
+  return ++gServiceWorkerInfoCurrentID;
+}
+
+already_AddRefed<ServiceWorker>
+ServiceWorkerInfo::GetOrCreateInstance(nsPIDOMWindowInner* aWindow)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aWindow);
+
+  RefPtr<ServiceWorker> ref;
+
+  for (uint32_t i = 0; i < mInstances.Length(); ++i) {
+    MOZ_ASSERT(mInstances[i]);
+    if (mInstances[i]->GetOwner() == aWindow) {
+      ref = mInstances[i];
+      break;
+    }
+  }
+
+  if (!ref) {
+    ref = new ServiceWorker(aWindow, this);
+  }
+
+  return ref.forget();
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -0,0 +1,144 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_serviceworkerinfo_h
+#define mozilla_dom_workers_serviceworkerinfo_h
+
+#include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState
+#include "nsIServiceWorkerManager.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorker;
+class ServiceWorkerPrivate;
+
+/*
+ * Wherever the spec treats a worker instance and a description of said worker
+ * as the same thing; i.e. "Resolve foo with
+ * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
+ * by this class and spawn a ServiceWorker in the right global when required.
+ */
+class ServiceWorkerInfo final : public nsIServiceWorkerInfo
+{
+private:
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+  const nsCString mScope;
+  const nsCString mScriptSpec;
+  const nsString mCacheName;
+  ServiceWorkerState mState;
+
+  // This id is shared with WorkerPrivate to match requests issued by service
+  // workers to their corresponding serviceWorkerInfo.
+  uint64_t mServiceWorkerID;
+
+  // We hold rawptrs since the ServiceWorker constructor and destructor ensure
+  // addition and removal.
+  // There is a high chance of there being at least one ServiceWorker
+  // associated with this all the time.
+  AutoTArray<ServiceWorker*, 1> mInstances;
+
+  RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
+  bool mSkipWaitingFlag;
+
+  ~ServiceWorkerInfo();
+
+  // Generates a unique id for the service worker, with zero being treated as
+  // invalid.
+  uint64_t
+  GetNextID() const;
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISERVICEWORKERINFO
+
+  class ServiceWorkerPrivate*
+  WorkerPrivate() const
+  {
+    MOZ_ASSERT(mServiceWorkerPrivate);
+    return mServiceWorkerPrivate;
+  }
+
+  nsIPrincipal*
+  GetPrincipal() const
+  {
+    return mPrincipal;
+  }
+
+  const nsCString&
+  ScriptSpec() const
+  {
+    return mScriptSpec;
+  }
+
+  const nsCString&
+  Scope() const
+  {
+    return mScope;
+  }
+
+  bool SkipWaitingFlag() const
+  {
+    AssertIsOnMainThread();
+    return mSkipWaitingFlag;
+  }
+
+  void SetSkipWaitingFlag()
+  {
+    AssertIsOnMainThread();
+    mSkipWaitingFlag = true;
+  }
+
+  ServiceWorkerInfo(nsIPrincipal* aPrincipal,
+                    const nsACString& aScope,
+                    const nsACString& aScriptSpec,
+                    const nsAString& aCacheName);
+
+  ServiceWorkerState
+  State() const
+  {
+    return mState;
+  }
+
+  const nsString&
+  CacheName() const
+  {
+    return mCacheName;
+  }
+
+  uint64_t
+  ID() const
+  {
+    return mServiceWorkerID;
+  }
+
+  void
+  UpdateState(ServiceWorkerState aState);
+
+  // Only used to set initial state when loading from disk!
+  void
+  SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
+  {
+    AssertIsOnMainThread();
+    mState = aState;
+  }
+
+  void
+  AppendWorker(ServiceWorker* aWorker);
+
+  void
+  RemoveWorker(ServiceWorker* aWorker);
+
+  already_AddRefed<ServiceWorker>
+  GetOrCreateInstance(nsPIDOMWindowInner* aWindow);
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_serviceworkerinfo_h
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -59,16 +59,17 @@
 #include "nsProxyRelease.h"
 #include "nsQueryObject.h"
 #include "nsTArray.h"
 
 #include "RuntimeService.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerClient.h"
 #include "ServiceWorkerContainer.h"
+#include "ServiceWorkerInfo.h"
 #include "ServiceWorkerJobQueue.h"
 #include "ServiceWorkerManagerChild.h"
 #include "ServiceWorkerPrivate.h"
 #include "ServiceWorkerRegisterJob.h"
 #include "ServiceWorkerRegistrar.h"
 #include "ServiceWorkerRegistration.h"
 #include "ServiceWorkerScriptCache.h"
 #include "ServiceWorkerEvents.h"
@@ -208,190 +209,16 @@ public:
 private:
   ~TeardownRunnable() {}
 
   RefPtr<ServiceWorkerManagerChild> mActor;
 };
 
 } // namespace
 
-void
-ServiceWorkerRegistrationInfo::Clear()
-{
-  if (mInstallingWorker) {
-    mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
-    mInstallingWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
-    mInstallingWorker = nullptr;
-    // FIXME(nsm): Abort any inflight requests from installing worker.
-  }
-
-  if (mWaitingWorker) {
-    mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
-
-    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
-                                                       mWaitingWorker->CacheName());
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to purge the waiting cache.");
-    }
-
-    mWaitingWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
-    mWaitingWorker = nullptr;
-  }
-
-  if (mActiveWorker) {
-    mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
-
-    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
-                                                       mActiveWorker->CacheName());
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to purge the active cache.");
-    }
-
-    mActiveWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
-    mActiveWorker = nullptr;
-  }
-
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  MOZ_ASSERT(swm);
-  swm->InvalidateServiceWorkerRegistrationWorker(this,
-                                                 WhichServiceWorker::INSTALLING_WORKER |
-                                                 WhichServiceWorker::WAITING_WORKER |
-                                                 WhichServiceWorker::ACTIVE_WORKER);
-}
-
-ServiceWorkerRegistrationInfo::ServiceWorkerRegistrationInfo(const nsACString& aScope,
-                                                             nsIPrincipal* aPrincipal)
-  : mControlledDocumentsCounter(0)
-  , mUpdateState(NoUpdate)
-  , mLastUpdateCheckTime(0)
-  , mScope(aScope)
-  , mPrincipal(aPrincipal)
-  , mPendingUninstall(false)
-{}
-
-ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
-{
-  if (IsControllingDocuments()) {
-    NS_WARNING("ServiceWorkerRegistrationInfo is still controlling documents. This can be a bug or a leak in ServiceWorker API or in any other API that takes the document alive.");
-  }
-}
-
-NS_IMPL_ISUPPORTS(ServiceWorkerRegistrationInfo, nsIServiceWorkerRegistrationInfo)
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetPrincipal(nsIPrincipal** aPrincipal)
-{
-  AssertIsOnMainThread();
-  NS_ADDREF(*aPrincipal = mPrincipal);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetScope(nsAString& aScope)
-{
-  AssertIsOnMainThread();
-  CopyUTF8toUTF16(mScope, aScope);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetScriptSpec(nsAString& aScriptSpec)
-{
-  AssertIsOnMainThread();
-  RefPtr<ServiceWorkerInfo> newest = Newest();
-  if (newest) {
-    CopyUTF8toUTF16(newest->ScriptSpec(), aScriptSpec);
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetInstallingWorker(nsIServiceWorkerInfo **aResult)
-{
-  AssertIsOnMainThread();
-  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mInstallingWorker);
-  info.forget(aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetWaitingWorker(nsIServiceWorkerInfo **aResult)
-{
-  AssertIsOnMainThread();
-  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mWaitingWorker);
-  info.forget(aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetActiveWorker(nsIServiceWorkerInfo **aResult)
-{
-  AssertIsOnMainThread();
-  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mActiveWorker);
-  info.forget(aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::GetWorkerByID(uint64_t aID, nsIServiceWorkerInfo **aResult)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aResult);
-
-  RefPtr<ServiceWorkerInfo> info = GetServiceWorkerInfoById(aID);
-  // It is ok to return null for a missing service worker info.
-  info.forget(aResult);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::AddListener(
-                            nsIServiceWorkerRegistrationInfoListener *aListener)
-{
-  AssertIsOnMainThread();
-
-  if (!aListener || mListeners.Contains(aListener)) {
-    return NS_ERROR_INVALID_ARG;
-  }
-
-  mListeners.AppendElement(aListener);
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerRegistrationInfo::RemoveListener(
-                            nsIServiceWorkerRegistrationInfoListener *aListener)
-{
-  AssertIsOnMainThread();
-
-  if (!aListener || !mListeners.Contains(aListener)) {
-    return NS_ERROR_INVALID_ARG;
-  }
-
-  mListeners.RemoveElement(aListener);
-
-  return NS_OK;
-}
-
-already_AddRefed<ServiceWorkerInfo>
-ServiceWorkerRegistrationInfo::GetServiceWorkerInfoById(uint64_t aId)
-{
-  RefPtr<ServiceWorkerInfo> serviceWorker;
-  if (mInstallingWorker && mInstallingWorker->ID() == aId) {
-    serviceWorker = mInstallingWorker;
-  } else if (mWaitingWorker && mWaitingWorker->ID() == aId) {
-    serviceWorker = mWaitingWorker;
-  } else if (mActiveWorker && mActiveWorker->ID() == aId) {
-    serviceWorker = mActiveWorker;
-  }
-
-  return serviceWorker.forget();
-}
-
 //////////////////////////
 // ServiceWorkerManager //
 //////////////////////////
 
 NS_IMPL_ADDREF(ServiceWorkerManager)
 NS_IMPL_RELEASE(ServiceWorkerManager)
 
 NS_INTERFACE_MAP_BEGIN(ServiceWorkerManager)
@@ -904,103 +731,16 @@ ServiceWorkerManager::AppendPendingOpera
   MOZ_ASSERT(!mActor);
   MOZ_ASSERT(aRunnable);
 
   if (!mShuttingDown) {
     mPendingOperations.AppendElement(aRunnable);
   }
 }
 
-void
-ServiceWorkerRegistrationInfo::TryToActivateAsync()
-{
-  nsCOMPtr<nsIRunnable> r =
-  NS_NewRunnableMethod(this,
-                       &ServiceWorkerRegistrationInfo::TryToActivate);
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r));
-}
-
-/*
- * TryToActivate should not be called directly, use TryToACtivateAsync instead.
- */
-void
-ServiceWorkerRegistrationInfo::TryToActivate()
-{
-  if (!IsControllingDocuments() ||
-      // Waiting worker will be removed if the registration is removed
-      (mWaitingWorker && mWaitingWorker->SkipWaitingFlag())) {
-    Activate();
-  }
-}
-
-void
-ServiceWorkerRegistrationInfo::PurgeActiveWorker()
-{
-  RefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker.forget();
-  if (!exitingWorker)
-    return;
-
-  // FIXME(jaoo): Bug 1170543 - Wait for exitingWorker to finish and terminate it.
-  exitingWorker->UpdateState(ServiceWorkerState::Redundant);
-  nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
-                                                     exitingWorker->CacheName());
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to purge the activating cache.");
-  }
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::ACTIVE_WORKER);
-}
-
-void
-ServiceWorkerRegistrationInfo::Activate()
-{
-  RefPtr<ServiceWorkerInfo> activatingWorker = mWaitingWorker;
-  if (!activatingWorker) {
-    return;
-  }
-
-  PurgeActiveWorker();
-
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::WAITING_WORKER);
-
-  mActiveWorker = activatingWorker.forget();
-  mWaitingWorker = nullptr;
-  mActiveWorker->UpdateState(ServiceWorkerState::Activating);
-  NotifyListenersOnChange();
-
-  // FIXME(nsm): Unlink appcache if there is one.
-
-  swm->CheckPendingReadyPromises();
-
-  // "Queue a task to fire a simple event named controllerchange..."
-  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
-    NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
-      swm, &ServiceWorkerManager::FireControllerChange, this);
-  NS_DispatchToMainThread(controllerChangeRunnable);
-
-  nsCOMPtr<nsIRunnable> failRunnable =
-    NS_NewRunnableMethodWithArg<bool>(this,
-                                      &ServiceWorkerRegistrationInfo::FinishActivate,
-                                      false /* success */);
-
-  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
-    new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(this));
-  RefPtr<LifeCycleEventCallback> callback = new ContinueActivateRunnable(handle);
-
-  ServiceWorkerPrivate* workerPrivate = mActiveWorker->WorkerPrivate();
-  MOZ_ASSERT(workerPrivate);
-  nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("activate"),
-                                                  callback, failRunnable);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(failRunnable));
-    return;
-  }
-}
-
 /*
  * Implements the async aspects of the getRegistrations algorithm.
  */
 class GetRegistrationsRunnable final : public nsRunnable
 {
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   RefPtr<Promise> mPromise;
 public:
@@ -1829,114 +1569,16 @@ ServiceWorkerManager::HandleError(JSCont
 
   // Always report any uncaught exceptions or errors to the console of
   // each client.
   ReportToAllClients(aScope, aMessage, aFilename, aLine, aLineNumber,
                      aColumnNumber, aFlags);
 }
 
 void
-ServiceWorkerRegistrationInfo::FinishActivate(bool aSuccess)
-{
-  if (mPendingUninstall || !mActiveWorker ||
-      mActiveWorker->State() != ServiceWorkerState::Activating) {
-    return;
-  }
-
-  // Activation never fails, so aSuccess is ignored.
-  mActiveWorker->UpdateState(ServiceWorkerState::Activated);
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  swm->StoreRegistration(mPrincipal, this);
-}
-
-void
-ServiceWorkerRegistrationInfo::RefreshLastUpdateCheckTime()
-{
-  AssertIsOnMainThread();
-  mLastUpdateCheckTime = PR_IntervalNow() / PR_MSEC_PER_SEC;
-}
-
-bool
-ServiceWorkerRegistrationInfo::IsLastUpdateCheckTimeOverOneDay() const
-{
-  AssertIsOnMainThread();
-
-  // For testing.
-  if (Preferences::GetBool("dom.serviceWorkers.testUpdateOverOneDay")) {
-    return true;
-  }
-
-  const uint64_t kSecondsPerDay = 86400;
-  const uint64_t now = PR_IntervalNow() / PR_MSEC_PER_SEC;
-
-  if ((mLastUpdateCheckTime != 0) &&
-      (now - mLastUpdateCheckTime > kSecondsPerDay)) {
-    return true;
-  }
-  return false;
-}
-
-void
-ServiceWorkerRegistrationInfo::NotifyListenersOnChange()
-{
-  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> listeners(mListeners);
-  for (size_t index = 0; index < listeners.Length(); ++index) {
-    listeners[index]->OnChange();
-  }
-}
-
-void
-ServiceWorkerRegistrationInfo::MaybeScheduleTimeCheckAndUpdate()
-{
-  AssertIsOnMainThread();
-
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (!swm) {
-    // shutting down, do nothing
-    return;
-  }
-
-  if (mUpdateState == NoUpdate) {
-    mUpdateState = NeedTimeCheckAndUpdate;
-  }
-
-  swm->ScheduleUpdateTimer(mPrincipal, mScope);
-}
-
-void
-ServiceWorkerRegistrationInfo::MaybeScheduleUpdate()
-{
-  AssertIsOnMainThread();
-
-  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
-  if (!swm) {
-    // shutting down, do nothing
-    return;
-  }
-
-  mUpdateState = NeedUpdate;
-
-  swm->ScheduleUpdateTimer(mPrincipal, mScope);
-}
-
-bool
-ServiceWorkerRegistrationInfo::CheckAndClearIfUpdateNeeded()
-{
-  AssertIsOnMainThread();
-
-  bool result = mUpdateState == NeedUpdate ||
-               (mUpdateState == NeedTimeCheckAndUpdate &&
-                IsLastUpdateCheckTimeOverOneDay());
-
-  mUpdateState = NoUpdate;
-
-  return result;
-}
-
-void
 ServiceWorkerManager::LoadRegistration(
                              const ServiceWorkerRegistrationData& aRegistration)
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIPrincipal> principal =
     PrincipalInfoToPrincipal(aRegistration.principal());
   if (!principal) {
@@ -4106,198 +3748,9 @@ ServiceWorkerManager::MaybeSendUnregiste
   nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
   Unused << mActor->SendUnregister(principalInfo, NS_ConvertUTF8toUTF16(aScope));
 }
 
-NS_IMPL_ISUPPORTS(ServiceWorkerInfo, nsIServiceWorkerInfo)
-
-NS_IMETHODIMP
-ServiceWorkerInfo::GetScriptSpec(nsAString& aScriptSpec)
-{
-  AssertIsOnMainThread();
-  CopyUTF8toUTF16(mScriptSpec, aScriptSpec);
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerInfo::GetCacheName(nsAString& aCacheName)
-{
-  AssertIsOnMainThread();
-  aCacheName = mCacheName;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-ServiceWorkerInfo::GetDebugger(nsIWorkerDebugger** aResult)
-{
-  if (NS_WARN_IF(!aResult)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return mServiceWorkerPrivate->GetDebugger(aResult);
-}
-
-NS_IMETHODIMP
-ServiceWorkerInfo::AttachDebugger()
-{
-  return mServiceWorkerPrivate->AttachDebugger();
-}
-
-NS_IMETHODIMP
-ServiceWorkerInfo::DetachDebugger()
-{
-  return mServiceWorkerPrivate->DetachDebugger();
-}
-
-void
-ServiceWorkerInfo::AppendWorker(ServiceWorker* aWorker)
-{
-  MOZ_ASSERT(aWorker);
-#ifdef DEBUG
-  nsAutoString workerURL;
-  aWorker->GetScriptURL(workerURL);
-  MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
-#endif
-  MOZ_ASSERT(!mInstances.Contains(aWorker));
-
-  mInstances.AppendElement(aWorker);
-  aWorker->SetState(State());
-}
-
-void
-ServiceWorkerInfo::RemoveWorker(ServiceWorker* aWorker)
-{
-  MOZ_ASSERT(aWorker);
-#ifdef DEBUG
-  nsAutoString workerURL;
-  aWorker->GetScriptURL(workerURL);
-  MOZ_ASSERT(workerURL.Equals(NS_ConvertUTF8toUTF16(mScriptSpec)));
-#endif
-  MOZ_ASSERT(mInstances.Contains(aWorker));
-
-  mInstances.RemoveElement(aWorker);
-}
-
-namespace {
-
-class ChangeStateUpdater final : public nsRunnable
-{
-public:
-  ChangeStateUpdater(const nsTArray<ServiceWorker*>& aInstances,
-                     ServiceWorkerState aState)
-    : mState(aState)
-  {
-    for (size_t i = 0; i < aInstances.Length(); ++i) {
-      mInstances.AppendElement(aInstances[i]);
-    }
-  }
-
-  NS_IMETHODIMP Run()
-  {
-    // We need to update the state of all instances atomically before notifying
-    // them to make sure that the observed state for all instances inside
-    // statechange event handlers is correct.
-    for (size_t i = 0; i < mInstances.Length(); ++i) {
-      mInstances[i]->SetState(mState);
-    }
-    for (size_t i = 0; i < mInstances.Length(); ++i) {
-      mInstances[i]->DispatchStateChange(mState);
-    }
-
-    return NS_OK;
-  }
-
-private:
-  AutoTArray<RefPtr<ServiceWorker>, 1> mInstances;
-  ServiceWorkerState mState;
-};
-
-}
-
-void
-ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
-{
-  AssertIsOnMainThread();
-#ifdef DEBUG
-  // Any state can directly transition to redundant, but everything else is
-  // ordered.
-  if (aState != ServiceWorkerState::Redundant) {
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::EndGuard_, aState == ServiceWorkerState::Installing);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installing, aState == ServiceWorkerState::Installed);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installed, aState == ServiceWorkerState::Activating);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Activating, aState == ServiceWorkerState::Activated);
-  }
-  // Activated can only go to redundant.
-  MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
-#endif
-  // Flush any pending functional events to the worker when it transitions to the
-  // activated state.
-  // TODO: Do we care that these events will race with the propagation of the
-  //       state change?
-  if (aState == ServiceWorkerState::Activated && mState != aState) {
-    mServiceWorkerPrivate->Activated();
-  }
-  mState = aState;
-  nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
-}
-
-ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
-                                     const nsACString& aScope,
-                                     const nsACString& aScriptSpec,
-                                     const nsAString& aCacheName)
-  : mPrincipal(aPrincipal)
-  , mScope(aScope)
-  , mScriptSpec(aScriptSpec)
-  , mCacheName(aCacheName)
-  , mState(ServiceWorkerState::EndGuard_)
-  , mServiceWorkerID(GetNextID())
-  , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
-  , mSkipWaitingFlag(false)
-{
-  MOZ_ASSERT(mPrincipal);
-  MOZ_ASSERT(!mScope.IsEmpty());
-  MOZ_ASSERT(!mScriptSpec.IsEmpty());
-  MOZ_ASSERT(!mCacheName.IsEmpty());
-}
-
-ServiceWorkerInfo::~ServiceWorkerInfo()
-{
-  MOZ_ASSERT(mServiceWorkerPrivate);
-  mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
-}
-
-static uint64_t gServiceWorkerInfoCurrentID = 0;
-
-uint64_t
-ServiceWorkerInfo::GetNextID() const
-{
-  return ++gServiceWorkerInfoCurrentID;
-}
-
-already_AddRefed<ServiceWorker>
-ServiceWorkerInfo::GetOrCreateInstance(nsPIDOMWindowInner* aWindow)
-{
-  AssertIsOnMainThread();
-  MOZ_ASSERT(aWindow);
-
-  RefPtr<ServiceWorker> ref;
-
-  for (uint32_t i = 0; i < mInstances.Length(); ++i) {
-    MOZ_ASSERT(mInstances[i]);
-    if (mInstances[i]->GetOwner() == aWindow) {
-      ref = mInstances[i];
-      break;
-    }
-  }
-
-  if (!ref) {
-    ref = new ServiceWorker(aWindow, this);
-  }
-
-  return ref.forget();
-}
-
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -15,20 +15,20 @@
 #include "mozilla/AutoRestore.h"
 #include "mozilla/LinkedList.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/TypedEnumBits.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/Promise.h"
-#include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState
 #include "mozilla/dom/ServiceWorkerCommon.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/dom/ServiceWorkerRegistrarTypes.h"
+#include "mozilla/dom/workers/ServiceWorkerRegistrationInfo.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 #include "nsRefPtrHashtable.h"
 #include "nsTArrayForwardDeclare.h"
 #include "nsTObserverArray.h"
 
@@ -39,271 +39,38 @@ namespace mozilla {
 class PrincipalOriginAttributes;
 
 namespace dom {
 
 class ServiceWorkerRegistrationListener;
 
 namespace workers {
 
-class ServiceWorker;
 class ServiceWorkerClientInfo;
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
 
-class ServiceWorkerRegistrationInfo final
-  : public nsIServiceWorkerRegistrationInfo
-{
-  uint32_t mControlledDocumentsCounter;
-
-  enum
-  {
-    NoUpdate,
-    NeedTimeCheckAndUpdate,
-    NeedUpdate
-  } mUpdateState;
-
-  uint64_t mLastUpdateCheckTime;
-
-  virtual ~ServiceWorkerRegistrationInfo();
-
-public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
-
-  nsCString mScope;
-
-  nsCOMPtr<nsIPrincipal> mPrincipal;
-
-  RefPtr<ServiceWorkerInfo> mActiveWorker;
-  RefPtr<ServiceWorkerInfo> mWaitingWorker;
-  RefPtr<ServiceWorkerInfo> mInstallingWorker;
-
-  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
-
-  // When unregister() is called on a registration, it is not immediately
-  // removed since documents may be controlled. It is marked as
-  // pendingUninstall and when all controlling documents go away, removed.
-  bool mPendingUninstall;
-
-  ServiceWorkerRegistrationInfo(const nsACString& aScope,
-                                nsIPrincipal* aPrincipal);
-
-  already_AddRefed<ServiceWorkerInfo>
-  Newest() const
-  {
-    RefPtr<ServiceWorkerInfo> newest;
-    if (mInstallingWorker) {
-      newest = mInstallingWorker;
-    } else if (mWaitingWorker) {
-      newest = mWaitingWorker;
-    } else {
-      newest = mActiveWorker;
-    }
-
-    return newest.forget();
-  }
-
-  already_AddRefed<ServiceWorkerInfo>
-  GetServiceWorkerInfoById(uint64_t aId);
-
-  void
-  StartControllingADocument()
-  {
-    ++mControlledDocumentsCounter;
-  }
-
-  void
-  StopControllingADocument()
-  {
-    MOZ_ASSERT(mControlledDocumentsCounter);
-    --mControlledDocumentsCounter;
-  }
-
-  bool
-  IsControllingDocuments() const
-  {
-    return mActiveWorker && mControlledDocumentsCounter;
-  }
-
-  void
-  Clear();
-
-  void
-  PurgeActiveWorker();
-
-  void
-  TryToActivateAsync();
-
-  void
-  TryToActivate();
-
-  void
-  Activate();
-
-  void
-  FinishActivate(bool aSuccess);
-
-  void
-  RefreshLastUpdateCheckTime();
-
-  bool
-  IsLastUpdateCheckTimeOverOneDay() const;
-
-  void
-  NotifyListenersOnChange();
-
-  void
-  MaybeScheduleTimeCheckAndUpdate();
-
-  void
-  MaybeScheduleUpdate();
-
-  bool
-  CheckAndClearIfUpdateNeeded();
-};
-
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
   virtual ~ServiceWorkerUpdateFinishCallback()
   {}
 
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerUpdateFinishCallback)
 
   virtual
   void UpdateSucceeded(ServiceWorkerRegistrationInfo* aInfo) = 0;
 
   virtual
   void UpdateFailed(ErrorResult& aStatus) = 0;
 };
 
-/*
- * Wherever the spec treats a worker instance and a description of said worker
- * as the same thing; i.e. "Resolve foo with
- * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
- * by this class and spawn a ServiceWorker in the right global when required.
- */
-class ServiceWorkerInfo final : public nsIServiceWorkerInfo
-{
-private:
-  nsCOMPtr<nsIPrincipal> mPrincipal;
-  const nsCString mScope;
-  const nsCString mScriptSpec;
-  const nsString mCacheName;
-  ServiceWorkerState mState;
-
-  // This id is shared with WorkerPrivate to match requests issued by service
-  // workers to their corresponding serviceWorkerInfo.
-  uint64_t mServiceWorkerID;
-
-  // We hold rawptrs since the ServiceWorker constructor and destructor ensure
-  // addition and removal.
-  // There is a high chance of there being at least one ServiceWorker
-  // associated with this all the time.
-  AutoTArray<ServiceWorker*, 1> mInstances;
-
-  RefPtr<ServiceWorkerPrivate> mServiceWorkerPrivate;
-  bool mSkipWaitingFlag;
-
-  ~ServiceWorkerInfo();
-
-  // Generates a unique id for the service worker, with zero being treated as
-  // invalid.
-  uint64_t
-  GetNextID() const;
-
-public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSISERVICEWORKERINFO
-
-  class ServiceWorkerPrivate*
-  WorkerPrivate() const
-  {
-    MOZ_ASSERT(mServiceWorkerPrivate);
-    return mServiceWorkerPrivate;
-  }
-
-  nsIPrincipal*
-  GetPrincipal() const
-  {
-    return mPrincipal;
-  }
-
-  const nsCString&
-  ScriptSpec() const
-  {
-    return mScriptSpec;
-  }
-
-  const nsCString&
-  Scope() const
-  {
-    return mScope;
-  }
-
-  bool SkipWaitingFlag() const
-  {
-    AssertIsOnMainThread();
-    return mSkipWaitingFlag;
-  }
-
-  void SetSkipWaitingFlag()
-  {
-    AssertIsOnMainThread();
-    mSkipWaitingFlag = true;
-  }
-
-  ServiceWorkerInfo(nsIPrincipal* aPrincipal,
-                    const nsACString& aScope,
-                    const nsACString& aScriptSpec,
-                    const nsAString& aCacheName);
-
-  ServiceWorkerState
-  State() const
-  {
-    return mState;
-  }
-
-  const nsString&
-  CacheName() const
-  {
-    return mCacheName;
-  }
-
-  uint64_t
-  ID() const
-  {
-    return mServiceWorkerID;
-  }
-
-  void
-  UpdateState(ServiceWorkerState aState);
-
-  // Only used to set initial state when loading from disk!
-  void
-  SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
-  {
-    AssertIsOnMainThread();
-    mState = aState;
-  }
-
-  void
-  AppendWorker(ServiceWorker* aWorker);
-
-  void
-  RemoveWorker(ServiceWorker* aWorker);
-
-  already_AddRefed<ServiceWorker>
-  GetOrCreateInstance(nsPIDOMWindowInner* aWindow);
-};
-
 #define NS_SERVICEWORKERMANAGER_IMPL_IID                 \
 { /* f4f8755a-69ca-46e8-a65d-775745535990 */             \
   0xf4f8755a,                                            \
   0x69ca,                                                \
   0x46e8,                                                \
   { 0xa6, 0x5d, 0x77, 0x57, 0x45, 0x53, 0x59, 0x90 }     \
 }
 
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -0,0 +1,370 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerRegistrationInfo.h"
+
+BEGIN_WORKERS_NAMESPACE
+
+void
+ServiceWorkerRegistrationInfo::Clear()
+{
+  if (mInstallingWorker) {
+    mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
+    mInstallingWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
+    mInstallingWorker = nullptr;
+    // FIXME(nsm): Abort any inflight requests from installing worker.
+  }
+
+  if (mWaitingWorker) {
+    mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
+
+    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
+                                                       mWaitingWorker->CacheName());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to purge the waiting cache.");
+    }
+
+    mWaitingWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
+    mWaitingWorker = nullptr;
+  }
+
+  if (mActiveWorker) {
+    mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
+
+    nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
+                                                       mActiveWorker->CacheName());
+    if (NS_FAILED(rv)) {
+      NS_WARNING("Failed to purge the active cache.");
+    }
+
+    mActiveWorker->WorkerPrivate()->NoteDeadServiceWorkerInfo();
+    mActiveWorker = nullptr;
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+  swm->InvalidateServiceWorkerRegistrationWorker(this,
+                                                 WhichServiceWorker::INSTALLING_WORKER |
+                                                 WhichServiceWorker::WAITING_WORKER |
+                                                 WhichServiceWorker::ACTIVE_WORKER);
+}
+
+ServiceWorkerRegistrationInfo::ServiceWorkerRegistrationInfo(const nsACString& aScope,
+                                                             nsIPrincipal* aPrincipal)
+  : mControlledDocumentsCounter(0)
+  , mUpdateState(NoUpdate)
+  , mLastUpdateCheckTime(0)
+  , mScope(aScope)
+  , mPrincipal(aPrincipal)
+  , mPendingUninstall(false)
+{}
+
+ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
+{
+  if (IsControllingDocuments()) {
+    NS_WARNING("ServiceWorkerRegistrationInfo is still controlling documents. This can be a bug or a leak in ServiceWorker API or in any other API that takes the document alive.");
+  }
+}
+
+NS_IMPL_ISUPPORTS(ServiceWorkerRegistrationInfo, nsIServiceWorkerRegistrationInfo)
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetPrincipal(nsIPrincipal** aPrincipal)
+{
+  AssertIsOnMainThread();
+  NS_ADDREF(*aPrincipal = mPrincipal);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetScope(nsAString& aScope)
+{
+  AssertIsOnMainThread();
+  CopyUTF8toUTF16(mScope, aScope);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetScriptSpec(nsAString& aScriptSpec)
+{
+  AssertIsOnMainThread();
+  RefPtr<ServiceWorkerInfo> newest = Newest();
+  if (newest) {
+    CopyUTF8toUTF16(newest->ScriptSpec(), aScriptSpec);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetInstallingWorker(nsIServiceWorkerInfo **aResult)
+{
+  AssertIsOnMainThread();
+  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mInstallingWorker);
+  info.forget(aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetWaitingWorker(nsIServiceWorkerInfo **aResult)
+{
+  AssertIsOnMainThread();
+  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mWaitingWorker);
+  info.forget(aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetActiveWorker(nsIServiceWorkerInfo **aResult)
+{
+  AssertIsOnMainThread();
+  nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mActiveWorker);
+  info.forget(aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::GetWorkerByID(uint64_t aID, nsIServiceWorkerInfo **aResult)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(aResult);
+
+  RefPtr<ServiceWorkerInfo> info = GetServiceWorkerInfoById(aID);
+  // It is ok to return null for a missing service worker info.
+  info.forget(aResult);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::AddListener(
+                            nsIServiceWorkerRegistrationInfoListener *aListener)
+{
+  AssertIsOnMainThread();
+
+  if (!aListener || mListeners.Contains(aListener)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  mListeners.AppendElement(aListener);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+ServiceWorkerRegistrationInfo::RemoveListener(
+                            nsIServiceWorkerRegistrationInfoListener *aListener)
+{
+  AssertIsOnMainThread();
+
+  if (!aListener || !mListeners.Contains(aListener)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  mListeners.RemoveElement(aListener);
+
+  return NS_OK;
+}
+
+already_AddRefed<ServiceWorkerInfo>
+ServiceWorkerRegistrationInfo::GetServiceWorkerInfoById(uint64_t aId)
+{
+  RefPtr<ServiceWorkerInfo> serviceWorker;
+  if (mInstallingWorker && mInstallingWorker->ID() == aId) {
+    serviceWorker = mInstallingWorker;
+  } else if (mWaitingWorker && mWaitingWorker->ID() == aId) {
+    serviceWorker = mWaitingWorker;
+  } else if (mActiveWorker && mActiveWorker->ID() == aId) {
+    serviceWorker = mActiveWorker;
+  }
+
+  return serviceWorker.forget();
+}
+
+void
+ServiceWorkerRegistrationInfo::TryToActivateAsync()
+{
+  nsCOMPtr<nsIRunnable> r =
+  NS_NewRunnableMethod(this,
+                       &ServiceWorkerRegistrationInfo::TryToActivate);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r));
+}
+
+/*
+ * TryToActivate should not be called directly, use TryToACtivateAsync instead.
+ */
+void
+ServiceWorkerRegistrationInfo::TryToActivate()
+{
+  if (!IsControllingDocuments() ||
+      // Waiting worker will be removed if the registration is removed
+      (mWaitingWorker && mWaitingWorker->SkipWaitingFlag())) {
+    Activate();
+  }
+}
+
+void
+ServiceWorkerRegistrationInfo::PurgeActiveWorker()
+{
+  RefPtr<ServiceWorkerInfo> exitingWorker = mActiveWorker.forget();
+  if (!exitingWorker)
+    return;
+
+  // FIXME(jaoo): Bug 1170543 - Wait for exitingWorker to finish and terminate it.
+  exitingWorker->UpdateState(ServiceWorkerState::Redundant);
+  nsresult rv = serviceWorkerScriptCache::PurgeCache(mPrincipal,
+                                                     exitingWorker->CacheName());
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Failed to purge the activating cache.");
+  }
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::ACTIVE_WORKER);
+}
+
+void
+ServiceWorkerRegistrationInfo::Activate()
+{
+  RefPtr<ServiceWorkerInfo> activatingWorker = mWaitingWorker;
+  if (!activatingWorker) {
+    return;
+  }
+
+  PurgeActiveWorker();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->InvalidateServiceWorkerRegistrationWorker(this, WhichServiceWorker::WAITING_WORKER);
+
+  mActiveWorker = activatingWorker.forget();
+  mWaitingWorker = nullptr;
+  mActiveWorker->UpdateState(ServiceWorkerState::Activating);
+  NotifyListenersOnChange();
+
+  // FIXME(nsm): Unlink appcache if there is one.
+
+  swm->CheckPendingReadyPromises();
+
+  // "Queue a task to fire a simple event named controllerchange..."
+  nsCOMPtr<nsIRunnable> controllerChangeRunnable =
+    NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
+      swm, &ServiceWorkerManager::FireControllerChange, this);
+  NS_DispatchToMainThread(controllerChangeRunnable);
+
+  nsCOMPtr<nsIRunnable> failRunnable =
+    NS_NewRunnableMethodWithArg<bool>(this,
+                                      &ServiceWorkerRegistrationInfo::FinishActivate,
+                                      false /* success */);
+
+  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
+    new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(this));
+  RefPtr<LifeCycleEventCallback> callback = new ContinueActivateRunnable(handle);
+
+  ServiceWorkerPrivate* workerPrivate = mActiveWorker->WorkerPrivate();
+  MOZ_ASSERT(workerPrivate);
+  nsresult rv = workerPrivate->SendLifeCycleEvent(NS_LITERAL_STRING("activate"),
+                                                  callback, failRunnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(failRunnable));
+    return;
+  }
+}
+
+void
+ServiceWorkerRegistrationInfo::FinishActivate(bool aSuccess)
+{
+  if (mPendingUninstall || !mActiveWorker ||
+      mActiveWorker->State() != ServiceWorkerState::Activating) {
+    return;
+  }
+
+  // Activation never fails, so aSuccess is ignored.
+  mActiveWorker->UpdateState(ServiceWorkerState::Activated);
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  swm->StoreRegistration(mPrincipal, this);
+}
+
+void
+ServiceWorkerRegistrationInfo::RefreshLastUpdateCheckTime()
+{
+  AssertIsOnMainThread();
+  mLastUpdateCheckTime = PR_IntervalNow() / PR_MSEC_PER_SEC;
+}
+
+bool
+ServiceWorkerRegistrationInfo::IsLastUpdateCheckTimeOverOneDay() const
+{
+  AssertIsOnMainThread();
+
+  // For testing.
+  if (Preferences::GetBool("dom.serviceWorkers.testUpdateOverOneDay")) {
+    return true;
+  }
+
+  const uint64_t kSecondsPerDay = 86400;
+  const uint64_t now = PR_IntervalNow() / PR_MSEC_PER_SEC;
+
+  if ((mLastUpdateCheckTime != 0) &&
+      (now - mLastUpdateCheckTime > kSecondsPerDay)) {
+    return true;
+  }
+  return false;
+}
+
+void
+ServiceWorkerRegistrationInfo::NotifyListenersOnChange()
+{
+  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> listeners(mListeners);
+  for (size_t index = 0; index < listeners.Length(); ++index) {
+    listeners[index]->OnChange();
+  }
+}
+
+void
+ServiceWorkerRegistrationInfo::MaybeScheduleTimeCheckAndUpdate()
+{
+  AssertIsOnMainThread();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    // shutting down, do nothing
+    return;
+  }
+
+  if (mUpdateState == NoUpdate) {
+    mUpdateState = NeedTimeCheckAndUpdate;
+  }
+
+  swm->ScheduleUpdateTimer(mPrincipal, mScope);
+}
+
+void
+ServiceWorkerRegistrationInfo::MaybeScheduleUpdate()
+{
+  AssertIsOnMainThread();
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  if (!swm) {
+    // shutting down, do nothing
+    return;
+  }
+
+  mUpdateState = NeedUpdate;
+
+  swm->ScheduleUpdateTimer(mPrincipal, mScope);
+}
+
+bool
+ServiceWorkerRegistrationInfo::CheckAndClearIfUpdateNeeded()
+{
+  AssertIsOnMainThread();
+
+  bool result = mUpdateState == NeedUpdate ||
+               (mUpdateState == NeedTimeCheckAndUpdate &&
+                IsLastUpdateCheckTimeOverOneDay());
+
+  mUpdateState = NoUpdate;
+
+  return result;
+}
+
+END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.h b/dom/workers/ServiceWorkerRegistrationInfo.h
new file mode 100644
--- /dev/null
+++ b/dom/workers/ServiceWorkerRegistrationInfo.h
@@ -0,0 +1,132 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_workers_serviceworkerregistrationinfo_h
+#define mozilla_dom_workers_serviceworkerregistrationinfo_h
+
+#include "mozilla/dom/workers/ServiceWorkerInfo.h"
+
+namespace mozilla {
+namespace dom {
+namespace workers {
+
+class ServiceWorkerRegistrationInfo final
+  : public nsIServiceWorkerRegistrationInfo
+{
+  uint32_t mControlledDocumentsCounter;
+
+  enum
+  {
+    NoUpdate,
+    NeedTimeCheckAndUpdate,
+    NeedUpdate
+  } mUpdateState;
+
+  uint64_t mLastUpdateCheckTime;
+
+  virtual ~ServiceWorkerRegistrationInfo();
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
+
+  nsCString mScope;
+
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  RefPtr<ServiceWorkerInfo> mActiveWorker;
+  RefPtr<ServiceWorkerInfo> mWaitingWorker;
+  RefPtr<ServiceWorkerInfo> mInstallingWorker;
+
+  nsTArray<nsCOMPtr<nsIServiceWorkerRegistrationInfoListener>> mListeners;
+
+  // When unregister() is called on a registration, it is not immediately
+  // removed since documents may be controlled. It is marked as
+  // pendingUninstall and when all controlling documents go away, removed.
+  bool mPendingUninstall;
+
+  ServiceWorkerRegistrationInfo(const nsACString& aScope,
+                                nsIPrincipal* aPrincipal);
+
+  already_AddRefed<ServiceWorkerInfo>
+  Newest() const
+  {
+    RefPtr<ServiceWorkerInfo> newest;
+    if (mInstallingWorker) {
+      newest = mInstallingWorker;
+    } else if (mWaitingWorker) {
+      newest = mWaitingWorker;
+    } else {
+      newest = mActiveWorker;
+    }
+
+    return newest.forget();
+  }
+
+  already_AddRefed<ServiceWorkerInfo>
+  GetServiceWorkerInfoById(uint64_t aId);
+
+  void
+  StartControllingADocument()
+  {
+    ++mControlledDocumentsCounter;
+  }
+
+  void
+  StopControllingADocument()
+  {
+    MOZ_ASSERT(mControlledDocumentsCounter);
+    --mControlledDocumentsCounter;
+  }
+
+  bool
+  IsControllingDocuments() const
+  {
+    return mActiveWorker && mControlledDocumentsCounter;
+  }
+
+  void
+  Clear();
+
+  void
+  PurgeActiveWorker();
+
+  void
+  TryToActivateAsync();
+
+  void
+  TryToActivate();
+
+  void
+  Activate();
+
+  void
+  FinishActivate(bool aSuccess);
+
+  void
+  RefreshLastUpdateCheckTime();
+
+  bool
+  IsLastUpdateCheckTimeOverOneDay() const;
+
+  void
+  NotifyListenersOnChange();
+
+  void
+  MaybeScheduleTimeCheckAndUpdate();
+
+  void
+  MaybeScheduleUpdate();
+
+  bool
+  CheckAndClearIfUpdateNeeded();
+};
+
+} // namespace workers
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_workers_serviceworkerregistrationinfo_h
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -18,17 +18,19 @@ EXPORTS.mozilla.dom += [
     'WorkerPrefs.h',
     'WorkerPrivate.h',
     'WorkerRunnable.h',
     'WorkerScope.h',
 ]
 
 EXPORTS.mozilla.dom.workers += [
     'RuntimeService.h',
+    'ServiceWorkerInfo.h',
     'ServiceWorkerManager.h',
+    'ServiceWorkerRegistrationInfo.h',
     'WorkerDebuggerManager.h',
     'Workers.h',
 ]
 
 # Stuff needed for the bindings, not really public though.
 EXPORTS.mozilla.dom.workers.bindings += [
     'DataStore.h',
     'DataStoreCursor.h',
@@ -61,27 +63,29 @@ UNIFIED_SOURCES += [
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerClient.cpp',
     'ServiceWorkerClients.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerEvents.cpp',
+    'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerMessageEvent.cpp',
     'ServiceWorkerPrivate.cpp',
     'ServiceWorkerRegisterJob.cpp',
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
+    'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerScriptCache.cpp',
     'ServiceWorkerUnregisterJob.cpp',
     'ServiceWorkerUpdateJob.cpp',
     'ServiceWorkerWindowClient.cpp',
     'SharedWorker.cpp',
     'URL.cpp',
     'WorkerDebuggerManager.cpp',
     'WorkerLocation.cpp',
