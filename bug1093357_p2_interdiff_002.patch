# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2f0ae7dfd6e0cfe529a41730be626368b299ff54
Bug 1093357 P2 interdiff 002 refactor to IPCStream type

diff --git a/ipc/glue/InputStreamParamsWithFdsOrSendStream.ipdlh b/ipc/glue/IPCStream.ipdlh
rename from ipc/glue/InputStreamParamsWithFdsOrSendStream.ipdlh
rename to ipc/glue/IPCStream.ipdlh
--- a/ipc/glue/InputStreamParamsWithFdsOrSendStream.ipdlh
+++ b/ipc/glue/IPCStream.ipdlh
@@ -9,22 +9,22 @@ namespace mozilla {
 namespace ipc {
 
 struct InputStreamParamsWithFds
 {
   InputStreamParams stream;
   OptionalFileDescriptorSet optionalFds;
 };
 
-union InputStreamParamsWithFdsOrSendStream
+union IPCStream
 {
   InputStreamParamsWithFds;
   PSendStream;
 };
 
-union OptionalInputStreamParamsWithFdsOrSendStream
+union OptionalIPCStream
 {
-  InputStreamParamsWithFdsOrSendStream;
+  IPCStream;
   void_t;
 };
 
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/glue/IPCStreamUtils.cpp b/ipc/glue/IPCStreamUtils.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/IPCStreamUtils.cpp
@@ -0,0 +1,457 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "IPCStreamUtils.h"
+
+#include "nsIIPCSerializableInputStream.h"
+
+#include "mozilla/Assertions.h"
+#include "mozilla/dom/PContentChild.h"
+#include "mozilla/dom/File.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/SendStream.h"
+#include "nsIAsyncInputStream.h"
+
+namespace mozilla {
+namespace ipc {
+
+namespace {
+
+// These serialization and cleanup functions could be externally exposed.  For
+// now, though, keep them private to encourage use of the safer RAII
+// AutoIPCStream class.
+
+template<typename M>
+void
+SerializeInputStreamWithFdsChild(nsIInputStream* aStream,
+                                 IPCStream& aValue,
+                                 M* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+
+  // First attempt simple stream serialization
+  nsCOMPtr<nsIIPCSerializableInputStream> serializable =
+    do_QueryInterface(aStream);
+  if (!serializable) {
+    MOZ_CRASH("Input stream is not serializable!");
+  }
+
+  aValue = InputStreamParamsWithFds();
+  InputStreamParamsWithFds& streamWithFds =
+    aValue.get_InputStreamParamsWithFds();
+
+  AutoTArray<FileDescriptor, 4> fds;
+  serializable->Serialize(streamWithFds.stream(), fds);
+
+  if (streamWithFds.stream().type() == InputStreamParams::T__None) {
+    MOZ_CRASH("Serialize failed!");
+  }
+
+  if (fds.IsEmpty()) {
+    streamWithFds.optionalFds() = void_t();
+  } else {
+    PFileDescriptorSetChild* fdSet =
+      aManager->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      Unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+
+    streamWithFds.optionalFds() = fdSet;
+  }
+}
+
+template<typename M>
+void
+SerializeInputStreamWithFdsParent(nsIInputStream* aStream,
+                                  IPCStream& aValue,
+                                  M* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+
+  // First attempt simple stream serialization
+  nsCOMPtr<nsIIPCSerializableInputStream> serializable =
+    do_QueryInterface(aStream);
+  if (!serializable) {
+    MOZ_CRASH("Input stream is not serializable!");
+  }
+
+  aValue = InputStreamParamsWithFds();
+  InputStreamParamsWithFds& streamWithFds =
+    aValue.get_InputStreamParamsWithFds();
+
+  AutoTArray<FileDescriptor, 4> fds;
+  serializable->Serialize(streamWithFds.stream(), fds);
+
+  if (streamWithFds.stream().type() == InputStreamParams::T__None) {
+    MOZ_CRASH("Serialize failed!");
+  }
+
+  if (fds.IsEmpty()) {
+    streamWithFds.optionalFds() = void_t();
+  } else {
+    PFileDescriptorSetParent* fdSet =
+      aManager->SendPFileDescriptorSetConstructor(fds[0]);
+    for (uint32_t i = 1; i < fds.Length(); ++i) {
+      Unused << fdSet->SendAddFileDescriptor(fds[i]);
+    }
+
+    streamWithFds.optionalFds() = fdSet;
+  }
+}
+
+template<typename M>
+void
+SerializeInputStream(nsIInputStream* aStream, IPCStream& aValue, M* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+
+  // First attempt simple stream serialization
+  nsCOMPtr<nsIIPCSerializableInputStream> serializable =
+    do_QueryInterface(aStream);
+  if (serializable) {
+    SerializeInputStreamWithFdsChild(aStream, aValue, aManager);
+    return;
+  }
+
+  // As a fallback, attempt to stream the data across using a SendStream
+  // actor.  This will fail for blocking streams.
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(aStream);
+  aValue = SendStreamChild::Create(asyncStream, aManager);
+
+  if (!aValue.get_PSendStreamChild()) {
+    MOZ_CRASH("SendStream creation failed!");
+  }
+}
+
+template<typename M>
+void
+SerializeInputStream(nsIInputStream* aStream, OptionalIPCStream& aValue,
+                     M* aManager)
+{
+  if (!aStream) {
+    aValue = void_t();
+    return;
+  }
+
+  aValue = IPCStream();
+  SerializeInputStream(aStream, aValue.get_IPCStream(),
+                             aManager);
+}
+
+void
+CleanupIPCStream(IPCStream& aValue, bool aConsumedByIPC)
+{
+  if (aValue.type() == IPCStream::T__None) {
+    return;
+  }
+
+  if (aValue.type() == IPCStream::TInputStreamParamsWithFds) {
+
+    InputStreamParamsWithFds& streamWithFds =
+      aValue.get_InputStreamParamsWithFds();
+
+    // Cleanup file descriptors if necessary
+    if (streamWithFds.optionalFds().type() ==
+        OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+      AutoTArray<FileDescriptor, 4> fds;
+
+      auto fdSetActor = static_cast<FileDescriptorSetChild*>(
+        streamWithFds.optionalFds().get_PFileDescriptorSetChild());
+      MOZ_ASSERT(fdSetActor);
+
+      if (!aConsumedByIPC) {
+        Unused << fdSetActor->Send__delete__(fdSetActor);
+      }
+
+      // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
+      // unconditionally forget them here.  The fds themselves are auto-closed in
+      // ~FileDescriptor since they originated in this process.
+      fdSetActor->ForgetFileDescriptors(fds);
+
+    } else if (streamWithFds.optionalFds().type() ==
+               OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+      AutoTArray<FileDescriptor, 4> fds;
+
+      auto fdSetActor = static_cast<FileDescriptorSetParent*>(
+        streamWithFds.optionalFds().get_PFileDescriptorSetParent());
+      MOZ_ASSERT(fdSetActor);
+
+      if (!aConsumedByIPC) {
+        Unused << fdSetActor->Send__delete__(fdSetActor);
+      }
+
+      // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
+      // unconditionally forget them here.  The fds themselves are auto-closed in
+      // ~FileDescriptor since they originated in this process.
+      fdSetActor->ForgetFileDescriptors(fds);
+    }
+
+    return;
+  }
+
+  MOZ_ASSERT(aValue.type() == IPCStream::TPSendStreamChild);
+
+  auto sendStream =
+    static_cast<SendStreamChild*>(aValue.get_PSendStreamChild());
+
+  if (!aConsumedByIPC) {
+    sendStream->StartDestroy();
+    return;
+  }
+
+  // If the SendStream was taken to be sent to the parent, then we need to
+  // start it before forgetting about it.
+  sendStream->Start();
+}
+
+void
+CleanupIPCStream(OptionalIPCStream& aValue, bool aConsumedByIPC)
+{
+  if (aValue.type() == OptionalIPCStream::Tvoid_t) {
+    return;
+  }
+
+  CleanupIPCStream(aValue.get_IPCStream(), aConsumedByIPC);
+}
+
+} // anonymous namespace
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const IPCStream& aValue)
+{
+  if (aValue.type() == IPCStream::TPSendStreamParent) {
+    auto sendStream =
+      static_cast<SendStreamParent*>(aValue.get_PSendStreamParent());
+    return sendStream->TakeReader();
+  }
+
+  // Note, we explicitly do not support deserializing the PSendStream actor on
+  // the child side.  It can only be send from child to parent.
+  MOZ_ASSERT(aValue.type() == IPCStream::TInputStreamParamsWithFds);
+
+  const InputStreamParamsWithFds& streamWithFds =
+    aValue.get_InputStreamParamsWithFds();
+
+  AutoTArray<FileDescriptor, 4> fds;
+  if (streamWithFds.optionalFds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+    auto fdSetActor = static_cast<FileDescriptorSetParent*>(
+      streamWithFds.optionalFds().get_PFileDescriptorSetParent());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    if (!fdSetActor->Send__delete__(fdSetActor)) {
+      // child process is gone, warn and allow actor to clean up normally
+      NS_WARNING("Failed to delete fd set actor.");
+    }
+  } else if (streamWithFds.optionalFds().type() ==
+             OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+
+    auto fdSetActor = static_cast<FileDescriptorSetChild*>(
+      streamWithFds.optionalFds().get_PFileDescriptorSetChild());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    Unused << fdSetActor->Send__delete__(fdSetActor);
+  }
+
+  return DeserializeInputStream(streamWithFds.stream(), fds);
+}
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const OptionalIPCStream& aValue)
+{
+  if (aValue.type() == OptionalIPCStream::Tvoid_t) {
+    return nullptr;
+  }
+
+  return DeserializeInputStream(aValue.get_IPCStream());
+}
+
+namespace {
+
+void
+AssertValidValueToTake(const IPCStream& aVal)
+{
+  MOZ_ASSERT(aVal.type() == IPCStream::TPSendStreamChild ||
+             aVal.type() == IPCStream::TInputStreamParamsWithFds);
+}
+
+void
+AssertValidValueToTake(const OptionalIPCStream& aVal)
+{
+  MOZ_ASSERT(aVal.type() == OptionalIPCStream::Tvoid_t ||
+             aVal.type() == OptionalIPCStream::TIPCStream);
+  if (aVal.type() == OptionalIPCStream::TIPCStream) {
+    AssertValidValueToTake(aVal.get_IPCStream());
+  }
+}
+
+} // anonymous namespace
+
+AutoIPCStream::AutoIPCStream()
+  : mInlineValue(void_t())
+  , mValue(nullptr)
+  , mOptionalValue(&mInlineValue)
+  , mTaken(false)
+{
+}
+
+AutoIPCStream::AutoIPCStream(IPCStream& aTarget)
+  : mInlineValue(void_t())
+  , mValue(&aTarget)
+  , mOptionalValue(nullptr)
+  , mTaken(false)
+{
+}
+
+AutoIPCStream::AutoIPCStream(OptionalIPCStream& aTarget)
+  : mInlineValue(void_t())
+  , mValue(nullptr)
+  , mOptionalValue(&aTarget)
+  , mTaken(false)
+{
+  *mOptionalValue = void_t();
+}
+
+AutoIPCStream::~AutoIPCStream()
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  if (mValue && IsSet()) {
+    CleanupIPCStream(*mValue, mTaken);
+  } else {
+    CleanupIPCStream(*mOptionalValue, mTaken);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, PContentChild* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStream(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStream(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, PBackgroundChild* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStream(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStream(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, dom::PContentParent* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStreamWithFdsParent(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStreamWithFdsParent(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+void
+AutoIPCStream::Serialize(nsIInputStream* aStream, PBackgroundParent* aManager)
+{
+  MOZ_ASSERT(aStream);
+  MOZ_ASSERT(aManager);
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!IsSet());
+
+  if (mValue) {
+    SerializeInputStreamWithFdsParent(aStream, *mValue, aManager);
+    AssertValidValueToTake(*mValue);
+  } else {
+    SerializeInputStreamWithFdsParent(aStream, *mOptionalValue, aManager);
+    AssertValidValueToTake(*mOptionalValue);
+  }
+}
+
+bool
+AutoIPCStream::IsSet() const
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  if (mValue) {
+    return mValue->type() != IPCStream::T__None;
+  } else {
+    return mOptionalValue->type() != OptionalIPCStream::Tvoid_t &&
+           mOptionalValue->get_IPCStream().type() != IPCStream::T__None;
+  }
+}
+
+IPCStream&
+AutoIPCStream::TakeValue()
+{
+  MOZ_ASSERT(mValue || mOptionalValue);
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(IsSet());
+
+  mTaken = true;
+
+  if (mValue) {
+    AssertValidValueToTake(*mValue);
+    return *mValue;
+  }
+
+  IPCStream& value =
+    mOptionalValue->get_IPCStream();
+
+  AssertValidValueToTake(value);
+  return value;
+}
+
+OptionalIPCStream&
+AutoIPCStream::TakeOptionalValue()
+{
+  MOZ_ASSERT(!mTaken);
+  MOZ_ASSERT(!mValue);
+  MOZ_ASSERT(mOptionalValue);
+  mTaken = true;
+  AssertValidValueToTake(*mOptionalValue);
+  return *mOptionalValue;
+}
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/IPCStreamUtils.h b/ipc/glue/IPCStreamUtils.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/IPCStreamUtils.h
@@ -0,0 +1,129 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_ipc_IPCStreamUtils_h
+#define mozilla_ipc_IPCStreamUtils_h
+
+#include "mozilla/ipc/IPCStream.h"
+#include "nsIInputStream.h"
+
+namespace mozilla {
+
+namespace dom {
+class PContentChild;
+class PContentParent;
+}
+
+namespace ipc {
+
+class PBackgroundChild;
+class PBackgroundParent;
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const IPCStream& aValue);
+
+already_AddRefed<nsIInputStream>
+DeserializeInputStream(const OptionalIPCStream& aValue);
+
+// RAII helper class that serializes an nsIInputStream into an
+// IPCStream IPC struct.  Any SendStreamChild actors
+// are automatically managed correctly.
+//
+// Use the TakeValue() method when passing the value (or just after passing the
+// value) to the IPC Send*() method.
+//
+// For example:
+//
+//  AutoIPCStream stream();
+//  stream.SerializeOrSend(inputStream, actor->Manager());
+//  actor->SendData(stream.TakeValue());
+//
+// If you need to manage an IPCStream struct embedded in
+// another type, you can create the AutoIPCStream around the existing
+// struct like this:
+//
+//  MyIPCStruct data;
+//  AutoIPCStream stream(data.myStream());
+//  stream.SerializeOrSend(inputStream, actor->Manager());
+//  actor->SendData(data);
+//  stream.TakeValue();
+//
+// The AutoIPCStream class also supports OptionalIPCStream
+// values.  As long as you did not initialize the object with a non-optional
+// IPCStream, you can call TakeOptionalValue() instead.
+//
+// Like SerializeInputStream(), the AutoIPCStream will crash if
+// serialization cannot be completed.  Currently, this should only
+// occur if the nsIInputStream cannot be serialized and is also blocking.
+//
+// NOTE: This is not a MOZ_STACK_CLASS so that it can be more easily integrated
+//       with complex ipdl structures.  For example, you may want to create an
+//       array of RAII AutoIPCStream objects or build your own wrapping
+//       RAII object to handle other actors that need to be cleaned up.
+class AutoIPCStream final
+{
+  OptionalIPCStream mInlineValue;
+  IPCStream* mValue;
+  OptionalIPCStream* mOptionalValue;
+  bool mTaken;
+
+  bool
+  IsSet() const;
+
+public:
+  // Implicitly create an OptionalIPCStream value.  Either
+  // TakeValue() or TakeOptionalValue() can be used.
+  AutoIPCStream();
+
+  // Wrap an existing IPCStream.  Only TakeValue() may be
+  // used.  If a nullptr nsIInputStream is passed to SerializeOrSend() then
+  // a crash will be forced.
+  explicit AutoIPCStream(IPCStream& aTarget);
+
+  // Wrap an existing OptionalIPCStream.  Either TakeValue()
+  // or TakeOptionalValue can be used.
+  explicit AutoIPCStream(OptionalIPCStream& aTarget);
+
+  ~AutoIPCStream();
+
+  // Serialize the input stream or create a SendStream actor using the PContent
+  // manager.  If neither of these succeed, then crash.  This should only be
+  // used on the main thread.
+  void
+  Serialize(nsIInputStream* aStream, dom::PContentChild* aManager);
+
+  // Serialize the input stream or create a SendStream actor using the
+  // PBackground manager.  If neither of these succeed, then crash.  This can
+  // be called on the main thread or Worker threads.
+  void
+  Serialize(nsIInputStream* aStream, PBackgroundChild* aManager);
+
+  // Serialize the input stream.  A PSendStream cannot be used when going
+  // from parent-to-child.
+  void
+  Serialize(nsIInputStream* aStream, dom::PContentParent* aManager);
+
+  // Serialize the input stream.  A PSendStream cannot be used when going
+  // from parent-to-child.
+  void
+  Serialize(nsIInputStream* aStream, PBackgroundParent* aManager);
+
+  // Get the IPCStream as a non-optional value.  This will
+  // assert if a stream has not been serialized or if it has already been taken.
+  // This should only be called if the value is being, or has already been, sent
+  // to the parent
+  IPCStream&
+  TakeValue();
+
+  // Get the OptionalIPCStream value.  This will assert if
+  // the value has already been taken.  This should only be called if the value
+  // is being, or has already been, sent to the parent
+  OptionalIPCStream&
+  TakeOptionalValue();
+};
+
+} // namespace ipc
+} // namespace mozilla
+
+#endif // mozilla_ipc_IPCStreamUtils_h
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -2,24 +2,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InputStreamUtils.h"
 
 #include "nsIIPCSerializableInputStream.h"
 
 #include "mozilla/Assertions.h"
-#include "mozilla/dom/PContentChild.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/ipc/BlobParent.h"
-#include "mozilla/ipc/FileDescriptorSetChild.h"
-#include "mozilla/ipc/FileDescriptorSetParent.h"
-#include "mozilla/ipc/PBackgroundChild.h"
-#include "mozilla/ipc/SendStream.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
 #include "nsID.h"
 #include "nsIXULRuntime.h"
 #include "nsMIMEInputStream.h"
 #include "nsMultiplexInputStream.h"
 #include "nsNetCID.h"
 #include "nsStringStream.h"
@@ -182,321 +177,10 @@ DeserializeInputStream(const OptionalInp
 
     default:
       MOZ_ASSERT(false, "Unknown params!");
   }
 
   return stream.forget();
 }
 
-namespace {
-
-// The SerializeOrSendInputStream() and CleanupSendInputStreamParamsWithFdsOrSendStream
-// functions could be externally exposed.  For now, though, keep them private
-// to encourage use of the safer RAII AutoIPCStreamChild class.
-
-template<typename M>
-void
-SerializeOrSendInputStream(nsIInputStream* aStream,
-                           InputStreamParamsWithFdsOrSendStream& aValue,
-                           M* aManager)
-{
-  MOZ_ASSERT(aStream);
-  MOZ_ASSERT(aManager);
-
-  // First attempt simple stream serialization
-  nsCOMPtr<nsIIPCSerializableInputStream> serializable =
-    do_QueryInterface(aStream);
-  if (serializable) {
-    InputStreamParams params;
-    AutoTArray<FileDescriptor, 4> fds;
-
-    serializable->Serialize(params, fds);
-
-    if (params.type() == InputStreamParams::T__None) {
-      MOZ_CRASH("Serialize failed!");
-    }
-
-    InputStreamParamsWithFds streamWithFds(params, void_t());
-
-    if (!fds.IsEmpty()) {
-      PFileDescriptorSetChild* fdSet =
-        aManager->SendPFileDescriptorSetConstructor(fds[0]);
-      for (uint32_t i = 1; i < fds.Length(); ++i) {
-        Unused << fdSet->SendAddFileDescriptor(fds[i]);
-      }
-
-      streamWithFds.optionalFds() = fdSet;
-    }
-
-    aValue = streamWithFds;
-
-    return;
-  }
-
-  // As a fallback, attempt to stream the data across using a SendStream
-  // actor.  This will fail for blocking streams.
-  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(aStream);
-  aValue = SendStreamChild::Create(asyncStream, aManager);
-
-  if (!aValue.get_PSendStreamChild()) {
-    MOZ_CRASH("SendStream creation failed!");
-  }
-}
-
-template<typename M>
-void
-SerializeOrSendInputStream(nsIInputStream* aStream,
-                           OptionalInputStreamParamsWithFdsOrSendStream& aValue,
-                           M* aManager)
-{
-  if (!aStream) {
-    aValue = void_t();
-    return;
-  }
-
-  aValue = InputStreamParamsWithFdsOrSendStream();
-  SerializeOrSendInputStream(aStream, aValue.get_InputStreamParamsWithFdsOrSendStream(),
-                             aManager);
-}
-
-void
-CleanupInputStreamParamsWithFdsOrSendStream(InputStreamParamsWithFdsOrSendStream& aValue,
-                                            bool aConsumedByIPC)
-{
-  if (aValue.type() == InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds) {
-
-    InputStreamParamsWithFds& streamWithFds =
-      aValue.get_InputStreamParamsWithFds();
-
-    // Cleanup file descriptors if necessary
-    if (streamWithFds.optionalFds().type() ==
-        OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
-
-      AutoTArray<FileDescriptor, 4> fds;
-
-      FileDescriptorSetChild* fdSetActor = static_cast<FileDescriptorSetChild*>(
-        streamWithFds.optionalFds().get_PFileDescriptorSetChild());
-      MOZ_ASSERT(fdSetActor);
-
-      if (!aConsumedByIPC) {
-        Unused << fdSetActor->Send__delete__(fdSetActor);
-      }
-
-      // FileDescriptorSet doesn't clear its fds in its ActorDestroy, so we
-      // unconditionally forget them here.  The fds themselves are auto-closed in
-      // ~FileDescriptor since they originated in this process.
-      fdSetActor->ForgetFileDescriptors(fds);
-    }
-
-    return;
-  }
-
-  MOZ_ASSERT(aValue.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamChild);
-
-  auto sendStream =
-    static_cast<SendStreamChild*>(aValue.get_PSendStreamChild());
-
-  if (!aConsumedByIPC) {
-    sendStream->StartDestroy();
-    return;
-  }
-
-  // If the SendStream was taken to be sent to the parent, then we need to
-  // start it before forgetting about it.
-  sendStream->Start();
-}
-
-void
-CleanupInputStreamParamsWithFdsOrSendStream(OptionalInputStreamParamsWithFdsOrSendStream& aValue,
-                                            bool aConsumedByIPC)
-{
-  if (aValue.type() == OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t) {
-    return;
-  }
-
-  CleanupInputStreamParamsWithFdsOrSendStream(aValue.get_InputStreamParamsWithFdsOrSendStream(),
-                                       aConsumedByIPC);
-}
-
-} // anonymous namespace
-
-already_AddRefed<nsIInputStream>
-DeserializeInputStream(const InputStreamParamsWithFdsOrSendStream& aValue)
-{
-  if (aValue.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamParent) {
-    auto sendStream =
-      static_cast<SendStreamParent*>(aValue.get_PSendStreamParent());
-    return sendStream->TakeReader();
-  }
-
-  MOZ_ASSERT(aValue.type() ==
-             InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds);
-
-  const InputStreamParamsWithFds& streamWithFds =
-    aValue.get_InputStreamParamsWithFds();
-
-  AutoTArray<FileDescriptor, 4> fds;
-  if (streamWithFds.optionalFds().type() ==
-      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
-
-    FileDescriptorSetParent* fdSetActor = static_cast<FileDescriptorSetParent*>(
-      streamWithFds.optionalFds().get_PFileDescriptorSetParent());
-    MOZ_ASSERT(fdSetActor);
-
-    fdSetActor->ForgetFileDescriptors(fds);
-    MOZ_ASSERT(!fds.IsEmpty());
-
-    if (!fdSetActor->Send__delete__(fdSetActor)) {
-      // child process is gone, warn and allow actor to clean up normally
-      NS_WARNING("Failed to delete fd set actor.");
-    }
-  }
-
-  return DeserializeInputStream(streamWithFds.stream(), fds);
-}
-
-already_AddRefed<nsIInputStream>
-DeserializeInputStream(const OptionalInputStreamParamsWithFdsOrSendStream& aValue)
-{
-  if (aValue.type() == OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t) {
-    return nullptr;
-  }
-
-  return DeserializeInputStream(aValue.get_InputStreamParamsWithFdsOrSendStream());
-}
-
-AutoIPCStreamChild::AutoIPCStreamChild()
-  : mInlineValue(void_t())
-  , mValue(nullptr)
-  , mOptionalValue(&mInlineValue)
-  , mTaken(false)
-{
-}
-
-AutoIPCStreamChild::AutoIPCStreamChild(InputStreamParamsWithFdsOrSendStream& aTarget)
-  : mInlineValue(void_t())
-  , mValue(&aTarget)
-  , mOptionalValue(nullptr)
-  , mTaken(false)
-{
-}
-
-AutoIPCStreamChild::AutoIPCStreamChild(OptionalInputStreamParamsWithFdsOrSendStream& aTarget)
-  : mInlineValue(void_t())
-  , mValue(nullptr)
-  , mOptionalValue(&aTarget)
-  , mTaken(false)
-{
-  *mOptionalValue = void_t();
-}
-
-AutoIPCStreamChild::~AutoIPCStreamChild()
-{
-  MOZ_ASSERT(mValue || mOptionalValue);
-  if (mValue && IsSet()) {
-    CleanupInputStreamParamsWithFdsOrSendStream(*mValue, mTaken);
-  } else {
-    CleanupInputStreamParamsWithFdsOrSendStream(*mOptionalValue, mTaken);
-  }
-}
-
-void
-AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
-                                    PContentChild* aManager)
-{
-  MOZ_ASSERT(aStream);
-  MOZ_ASSERT(aManager);
-  MOZ_ASSERT(mValue || mOptionalValue);
-  MOZ_ASSERT(!mTaken);
-  MOZ_ASSERT(!IsSet());
-
-  if (mValue) {
-    SerializeOrSendInputStream(aStream, *mValue, aManager);
-  } else {
-    SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
-  }
-}
-
-void
-AutoIPCStreamChild::SerializeOrSend(nsIInputStream* aStream,
-                                    PBackgroundChild* aManager)
-{
-  MOZ_ASSERT(aStream);
-  MOZ_ASSERT(aManager);
-  MOZ_ASSERT(mValue || mOptionalValue);
-  MOZ_ASSERT(!mTaken);
-  MOZ_ASSERT(!IsSet());
-
-  if (mValue) {
-    SerializeOrSendInputStream(aStream, *mValue, aManager);
-  } else {
-    SerializeOrSendInputStream(aStream, *mOptionalValue, aManager);
-  }
-}
-
-bool
-AutoIPCStreamChild::IsSet() const
-{
-  MOZ_ASSERT(mValue || mOptionalValue);
-  if (mValue) {
-    return mValue->type() != InputStreamParamsWithFdsOrSendStream::T__None;
-  } else {
-    return mOptionalValue->type() !=
-           OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t;
-  }
-}
-
-namespace {
-
-void
-AssertValidValueToTake(const InputStreamParamsWithFdsOrSendStream& aVal)
-{
-  MOZ_ASSERT(aVal.type() == InputStreamParamsWithFdsOrSendStream::TPSendStreamChild ||
-             aVal.type() == InputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFds);
-}
-
-void
-AssertValidValueToTake(const OptionalInputStreamParamsWithFdsOrSendStream& aVal)
-{
-  MOZ_ASSERT(aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::Tvoid_t ||
-             aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream);
-  if (aVal.type() == OptionalInputStreamParamsWithFdsOrSendStream::TInputStreamParamsWithFdsOrSendStream) {
-    AssertValidValueToTake(aVal.get_InputStreamParamsWithFdsOrSendStream());
-  }
-}
-
-} // anonymous namespace
-
-InputStreamParamsWithFdsOrSendStream&
-AutoIPCStreamChild::TakeValue()
-{
-  MOZ_ASSERT(mValue || mOptionalValue);
-  MOZ_ASSERT(!mTaken);
-  MOZ_ASSERT(IsSet());
-
-  mTaken = true;
-
-  if (mValue) {
-    AssertValidValueToTake(*mValue);
-    return *mValue;
-  }
-
-  InputStreamParamsWithFdsOrSendStream& value =
-    mOptionalValue->get_InputStreamParamsWithFdsOrSendStream();
-
-  AssertValidValueToTake(value);
-  return value;
-}
-
-OptionalInputStreamParamsWithFdsOrSendStream&
-AutoIPCStreamChild::TakeOptionalValue()
-{
-  MOZ_ASSERT(!mTaken);
-  MOZ_ASSERT(!mValue);
-  MOZ_ASSERT(mOptionalValue);
-  mTaken = true;
-  AssertValidValueToTake(*mOptionalValue);
-  return *mOptionalValue;
-}
-
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/glue/InputStreamUtils.h b/ipc/glue/InputStreamUtils.h
--- a/ipc/glue/InputStreamUtils.h
+++ b/ipc/glue/InputStreamUtils.h
@@ -1,31 +1,24 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_ipc_InputStreamUtils_h
 #define mozilla_ipc_InputStreamUtils_h
 
 #include "mozilla/ipc/InputStreamParams.h"
-#include "mozilla/ipc/InputStreamParamsWithFdsOrSendStream.h"
 #include "nsCOMPtr.h"
 #include "nsIInputStream.h"
 #include "nsTArray.h"
 
 namespace mozilla {
-
-namespace dom {
-class PContentChild;
-}
-
 namespace ipc {
 
 class FileDescriptor;
-class PBackgroundChild;
 
 void
 SerializeInputStream(nsIInputStream* aInputStream,
                      InputStreamParams& aParams,
                      nsTArray<FileDescriptor>& aFileDescriptors);
 
 void
 SerializeInputStream(nsIInputStream* aInputStream,
@@ -35,101 +28,12 @@ SerializeInputStream(nsIInputStream* aIn
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const InputStreamParams& aParams,
                        const nsTArray<FileDescriptor>& aFileDescriptors);
 
 already_AddRefed<nsIInputStream>
 DeserializeInputStream(const OptionalInputStreamParams& aParams,
                        const nsTArray<FileDescriptor>& aFileDescriptors);
 
-already_AddRefed<nsIInputStream>
-DeserializeInputStream(const InputStreamParamsWithFdsOrSendStream& aValue);
-
-already_AddRefed<nsIInputStream>
-DeserializeInputStream(const OptionalInputStreamParamsWithFdsOrSendStream& aValue);
-
-// RAII helper class that serializes an nsIInputStream into an
-// InputStreamParamsWithFdsOrSendStream IPC struct.  Any SendStreamChild actors
-// are automatically managed correctly.
-//
-// Use the TakeValue() method when passing the value (or just after passing the
-// value) to the IPC Send*() method.
-//
-// For example:
-//
-//  AutoIPCStreamChild streamChild();
-//  streamChild.SerializeOrSend(inputStream, actor->Manager());
-//  actor->SendData(streamChild.TakeValue());
-//
-// If you need to manage an InputStreamParamsWithFdsOrSendStream struct embedded in
-// another type, you can create the AutoIPCStreamChild around the existing
-// struct like this:
-//
-//  MyIPCStruct data;
-//  AutoIpcStreamChild streamChild(data.myStream());
-//  streamChild.SerializeOrSend(inputStream, actor->Manager());
-//  actor->SendData(data);
-//  streamChild.TakeValue();
-//
-// The AutoIPCStreamChild class also supports OptionalInputStreamParamsWithFdsOrSendStream
-// values.  As long as you did not initialize the object with a non-optional
-// InputStreamParamsWithFdsOrSendStream, you can call TakeOptionalValue() instead.
-//
-// Like SerializeInputStream(), the AutoIPCStreamChild will crash if
-// serialization cannot be completed.  Currently, this should only
-// occur if the nsIInputStream cannot be serialized and is also blocking.
-//
-class MOZ_STACK_CLASS AutoIPCStreamChild final
-{
-  OptionalInputStreamParamsWithFdsOrSendStream mInlineValue;
-  InputStreamParamsWithFdsOrSendStream* mValue;
-  OptionalInputStreamParamsWithFdsOrSendStream* mOptionalValue;
-  bool mTaken;
-
-  bool
-  IsSet() const;
-
-public:
-  // Implicitly create an OptionalInputStreamParamsWithFdsOrSendStream value.  Either
-  // TakeValue() or TakeOptionalValue() can be used.
-  AutoIPCStreamChild();
-
-  // Wrap an existing InputStreamParamsWithFdsOrSendStream.  Only TakeValue() may be
-  // used.  If a nullptr nsIInputStream is passed to SerializeOrSend() then
-  // a crash will be forced.
-  explicit AutoIPCStreamChild(InputStreamParamsWithFdsOrSendStream& aTarget);
-
-  // Wrap an existing OptionalInputStreamParamsWithFdsOrSendStream.  Either TakeValue()
-  // or TakeOptionalValue can be used.
-  explicit AutoIPCStreamChild(OptionalInputStreamParamsWithFdsOrSendStream& aTarget);
-
-  ~AutoIPCStreamChild();
-
-  // Serialize the input stream or create a SendStream actor using the PContent
-  // manager.  If neither of these succeed, then crash.  This should only be
-  // used on the main thread.
-  void
-  SerializeOrSend(nsIInputStream* aStream, dom::PContentChild* aManager);
-
-  // Serialize the input stream or create a SendStream actor using the
-  // PBackground manager.  If neither of these succeed, then crash.  This can
-  // be called on the main thread or Worker threads.
-  void
-  SerializeOrSend(nsIInputStream* aStream, PBackgroundChild* aManager);
-
-  // Get the InputStreamParamsWithFdsOrSendStream as a non-optional value.  This will
-  // assert if a stream has not been serialized or if it has already been taken.
-  // This should only be called if the value is being, or has already been, sent
-  // to the parent
-  InputStreamParamsWithFdsOrSendStream&
-  TakeValue();
-
-  // Get the OptionalInputStreamParamsWithFdsOrSendStream value.  This will assert if
-  // the value has already been taken.  This should only be called if the value
-  // is being, or has already been, sent to the parent
-  OptionalInputStreamParamsWithFdsOrSendStream&
-  TakeOptionalValue();
-};
-
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_InputStreamUtils_h
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -18,16 +18,17 @@ EXPORTS.mozilla.ipc += [
     'CrossProcessMutex.h',
     'FileDescriptor.h',
     'FileDescriptorSetChild.h',
     'FileDescriptorSetParent.h',
     'FileDescriptorUtils.h',
     'GeckoChildProcessHost.h',
     'InputStreamUtils.h',
     'IOThreadChild.h',
+    'IPCStreamUtils.h',
     'MessageChannel.h',
     'MessageLink.h',
     'Neutering.h',
     'ProcessChild.h',
     'ProtocolUtils.h',
     'ScopedXREEmbed.h',
     'SendStream.h',
     'SendStreamAlloc.h',
@@ -112,16 +113,17 @@ EXPORTS.ipc += [
 UNIFIED_SOURCES += [
     'BackgroundImpl.cpp',
     'BackgroundUtils.cpp',
     'BrowserProcessSubThread.cpp',
     'FileDescriptor.cpp',
     'FileDescriptorUtils.cpp',
     'InputStreamUtils.cpp',
     'IPCMessageUtils.cpp',
+    'IPCStreamUtils.cpp',
     'MessageChannel.cpp',
     'MessageLink.cpp',
     'MessagePump.cpp',
     'ProcessChild.cpp',
     'ProtocolUtils.cpp',
     'ScopedXREEmbed.cpp',
     'SendStreamChild.cpp',
     'SendStreamParent.cpp',
@@ -153,17 +155,17 @@ LOCAL_INCLUDES += [
     '/dom/indexedDB',
     '/dom/workers',
     '/media/webrtc/trunk',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
-    'InputStreamParamsWithFdsOrSendStream.ipdlh',
+    'IPCStream.ipdlh',
     'PBackground.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
     'PSendStream.ipdl',
     'URIParams.ipdlh',
