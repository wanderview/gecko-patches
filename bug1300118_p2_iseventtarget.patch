# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  116eacacbbf35ea71f1bf926a3b51f757e2e1206
Bug 130118 P2 Make TaskQueue implement nsIEventTarget. r=bholley

diff --git a/dom/media/MediaDecoderReader.cpp b/dom/media/MediaDecoderReader.cpp
--- a/dom/media/MediaDecoderReader.cpp
+++ b/dom/media/MediaDecoderReader.cpp
@@ -227,17 +227,17 @@ MediaDecoderReader::MediaDecoderReader(A
   , mIsSuspended(mTaskQueue, true,
                  "MediaDecoderReader::mIsSuspended (Canonical)")
 {
   MOZ_COUNT_CTOR(MediaDecoderReader);
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mDecoder && mDecoder->DataArrivedEvent()) {
     mDataArrivedListener = mDecoder->DataArrivedEvent()->Connect(
-      mTaskQueue, this, &MediaDecoderReader::NotifyDataArrived);
+      mTaskQueue->AsAbstractThread(), this, &MediaDecoderReader::NotifyDataArrived);
   }
 
   ReaderQueue::Instance().Add(this);
 
   // Dispatch initialization that needs to happen on that task queue.
   mTaskQueue->Dispatch(NewRunnableMethod(this, &MediaDecoderReader::InitializationTask));
 }
 
diff --git a/dom/media/MediaDecoderStateMachine.cpp b/dom/media/MediaDecoderStateMachine.cpp
--- a/dom/media/MediaDecoderStateMachine.cpp
+++ b/dom/media/MediaDecoderStateMachine.cpp
@@ -364,17 +364,18 @@ MediaDecoderStateMachine::CreateAudioSin
   RefPtr<MediaDecoderStateMachine> self = this;
   auto audioSinkCreator = [self] () {
     MOZ_ASSERT(self->OnTaskQueue());
     DecodedAudioDataSink* audioSink = new DecodedAudioDataSink(
       self->mTaskQueue, self->mAudioQueue, self->GetMediaTime(),
       self->mInfo.mAudio, self->mAudioChannel);
 
     self->mAudibleListener = audioSink->AudibleEvent().Connect(
-      self->mTaskQueue, self.get(), &MediaDecoderStateMachine::AudioAudibleChanged);
+      self->mTaskQueue->AsAbstractThread(), self.get(),
+      &MediaDecoderStateMachine::AudioAudibleChanged);
     return audioSink;
   };
   return new AudioSinkWrapper(mTaskQueue, audioSinkCreator);
 }
 
 already_AddRefed<media::MediaSink>
 MediaDecoderStateMachine::CreateMediaSink(bool aAudioCaptured)
 {
@@ -844,19 +845,21 @@ nsresult MediaDecoderStateMachine::Init(
   MOZ_ASSERT(NS_IsMainThread());
 
   // Dispatch initialization that needs to happen on that task queue.
   nsCOMPtr<nsIRunnable> r = NewRunnableMethod<RefPtr<MediaDecoder>>(
     this, &MediaDecoderStateMachine::InitializationTask, aDecoder);
   mTaskQueue->Dispatch(r.forget());
 
   mAudioQueueListener = AudioQueue().PopEvent().Connect(
-    mTaskQueue, this, &MediaDecoderStateMachine::OnAudioPopped);
+    mTaskQueue->AsAbstractThread(), this,
+    &MediaDecoderStateMachine::OnAudioPopped);
   mVideoQueueListener = VideoQueue().PopEvent().Connect(
-    mTaskQueue, this, &MediaDecoderStateMachine::OnVideoPopped);
+    mTaskQueue->AsAbstractThread(), this,
+    &MediaDecoderStateMachine::OnVideoPopped);
 
   mMetadataManager.Connect(mReader->TimedMetadataEvent(), OwnerThread());
 
   mMediaSink = CreateMediaSink(mAudioCaptured);
 
 #ifdef MOZ_EME
   mCDMProxyPromise.Begin(aDecoder->RequestCDMProxy()->Then(
     OwnerThread(), __func__, this,
@@ -874,44 +877,44 @@ nsresult MediaDecoderStateMachine::Init(
 }
 
 void
 MediaDecoderStateMachine::SetMediaDecoderReaderWrapperCallback()
 {
   MOZ_ASSERT(OnTaskQueue());
 
   mAudioCallback = mReader->AudioCallback().Connect(
-    mTaskQueue, [this] (AudioCallbackData aData) {
+    mTaskQueue->AsAbstractThread(), [this] (AudioCallbackData aData) {
     if (aData.is<MediaData*>()) {
       OnAudioDecoded(aData.as<MediaData*>());
     } else {
       OnNotDecoded(MediaData::AUDIO_DATA, aData.as<MediaDecoderReader::NotDecodedReason>());
     }
   });
 
   mVideoCallback = mReader->VideoCallback().Connect(
-    mTaskQueue, [this] (VideoCallbackData aData) {
+    mTaskQueue->AsAbstractThread(), [this] (VideoCallbackData aData) {
     typedef Tuple<MediaData*, TimeStamp> Type;
     if (aData.is<Type>()) {
       auto&& v = aData.as<Type>();
       OnVideoDecoded(Get<0>(v), Get<1>(v));
     } else {
       OnNotDecoded(MediaData::VIDEO_DATA, aData.as<MediaDecoderReader::NotDecodedReason>());
     }
   });
 
   mAudioWaitCallback = mReader->AudioWaitCallback().Connect(
-    mTaskQueue, [this] (WaitCallbackData aData) {
+    mTaskQueue->AsAbstractThread(), [this] (WaitCallbackData aData) {
     if (aData.is<MediaData::Type>()) {
       EnsureAudioDecodeTaskQueued();
     }
   });
 
   mVideoWaitCallback = mReader->VideoWaitCallback().Connect(
-    mTaskQueue, [this] (WaitCallbackData aData) {
+    mTaskQueue->AsAbstractThread(), [this] (WaitCallbackData aData) {
     if (aData.is<MediaData::Type>()) {
       EnsureVideoDecodeTaskQueued();
     }
   });
 }
 
 void
 MediaDecoderStateMachine::CancelMediaDecoderReaderWrapperCallback()
diff --git a/dom/media/gtest/TestMediaEventSource.cpp b/dom/media/gtest/TestMediaEventSource.cpp
--- a/dom/media/gtest/TestMediaEventSource.cpp
+++ b/dom/media/gtest/TestMediaEventSource.cpp
@@ -19,17 +19,17 @@ TEST(MediaEventSource, SingleListener)
 {
   RefPtr<TaskQueue> queue = new TaskQueue(
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducer<int> source;
   int i = 0;
 
   auto func = [&] (int j) { i += j; };
-  MediaEventListener listener = source.Connect(queue, func);
+  MediaEventListener listener = source.Connect(queue->AsAbstractThread(), func);
 
   // Call Notify 3 times. The listener should be also called 3 times.
   source.Notify(3);
   source.Notify(5);
   source.Notify(7);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
@@ -45,18 +45,18 @@ TEST(MediaEventSource, MultiListener)
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducer<int> source;
   int i = 0;
   int j = 0;
 
   auto func1 = [&] (int k) { i = k * 2; };
   auto func2 = [&] (int k) { j = k * 3; };
-  MediaEventListener listener1 = source.Connect(queue, func1);
-  MediaEventListener listener2 = source.Connect(queue, func2);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func1);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), func2);
 
   // Both listeners should receive the event.
   source.Notify(11);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
 
   // Verify the event data is passed correctly to the listener.
@@ -75,17 +75,17 @@ TEST(MediaEventSource, DisconnectAfterNo
   RefPtr<TaskQueue> queue = new TaskQueue(
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducer<int> source;
   int i = 0;
 
   MediaEventListener listener;
   auto func = [&] (int j) { i += j; listener.Disconnect(); };
-  listener = source.Connect(queue, func);
+  listener = source.Connect(queue->AsAbstractThread(), func);
 
   // Call Notify() twice. Since we disconnect the listener when receiving
   // the 1st event, the 2nd event should not reach the listener.
   source.Notify(11);
   source.Notify(11);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
@@ -100,18 +100,18 @@ TEST(MediaEventSource, DisconnectBeforeN
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducer<int> source;
   int i = 0;
   int j = 0;
 
   auto func1 = [&] (int k) { i = k * 2; };
   auto func2 = [&] (int k) { j = k * 3; };
-  MediaEventListener listener1 = source.Connect(queue, func1);
-  MediaEventListener listener2 = source.Connect(queue, func2);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func1);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), func2);
 
   // Disconnect listener2 before notification. Only listener1 should receive
   // the event.
   listener2.Disconnect();
   source.Notify(11);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
@@ -123,17 +123,17 @@ TEST(MediaEventSource, DisconnectBeforeN
 }
 
 /*
  * Test we don't hit the assertion when calling Connect() and Disconnect()
  * repeatedly.
  */
 TEST(MediaEventSource, DisconnectAndConnect)
 {
-  RefPtr<TaskQueue> queue;
+  RefPtr<AbstractThread> queue;
   MediaEventProducerExc<int> source;
   MediaEventListener listener = source.Connect(queue, [](){});
   listener.Disconnect();
   listener = source.Connect(queue, [](){});
   listener.Disconnect();
 }
 
 /*
@@ -144,27 +144,27 @@ TEST(MediaEventSource, VoidEventType)
   RefPtr<TaskQueue> queue = new TaskQueue(
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducer<void> source;
   int i = 0;
 
   // Test function object.
   auto func = [&] () { ++i; };
-  MediaEventListener listener1 = source.Connect(queue, func);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func);
 
   // Test member function.
   struct Foo {
     Foo() : j(1) {}
     void OnNotify() {
       j *= 2;
     }
     int j;
   } foo;
-  MediaEventListener listener2 = source.Connect(queue, &foo, &Foo::OnNotify);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify);
 
   // Call Notify 2 times. The listener should be also called 2 times.
   source.Notify();
   source.Notify();
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
 
@@ -185,19 +185,19 @@ TEST(MediaEventSource, ListenerType1)
 
   MediaEventProducer<int> source;
   int i = 0;
 
   // Test various argument types.
   auto func1 = [&] (int&& j) { i += j; };
   auto func2 = [&] (const int& j) { i += j; };
   auto func3 = [&] () { i += 1; };
-  MediaEventListener listener1 = source.Connect(queue, func1);
-  MediaEventListener listener2 = source.Connect(queue, func2);
-  MediaEventListener listener3 = source.Connect(queue, func3);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func1);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), func2);
+  MediaEventListener listener3 = source.Connect(queue->AsAbstractThread(), func3);
 
   source.Notify(1);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
 
   EXPECT_EQ(i, 3);
 
@@ -219,21 +219,21 @@ TEST(MediaEventSource, ListenerType2)
     void OnNotify2(const int& i) { mInt += i; }
     void OnNotify3() { mInt += 1; }
     void OnNotify4(int i) const { mInt += i; }
     void OnNotify5(int i) volatile { mInt += i; }
     mutable int mInt;
   } foo;
 
   // Test member functions which might be CV qualified.
-  MediaEventListener listener1 = source.Connect(queue, &foo, &Foo::OnNotify1);
-  MediaEventListener listener2 = source.Connect(queue, &foo, &Foo::OnNotify2);
-  MediaEventListener listener3 = source.Connect(queue, &foo, &Foo::OnNotify3);
-  MediaEventListener listener4 = source.Connect(queue, &foo, &Foo::OnNotify4);
-  MediaEventListener listener5 = source.Connect(queue, &foo, &Foo::OnNotify5);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify1);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify2);
+  MediaEventListener listener3 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify3);
+  MediaEventListener listener4 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify4);
+  MediaEventListener listener5 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify5);
 
   source.Notify(1);
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
 
   EXPECT_EQ(foo.mInt, 5);
 
@@ -265,18 +265,18 @@ TEST(MediaEventSource, CopyEvent1)
   MediaEventProducer<SomeEvent> source;
   int i = 0;
 
   auto func = [] (SomeEvent&& aEvent) {};
   struct Foo {
     void OnNotify(SomeEvent&& aEvent) {}
   } foo;
 
-  MediaEventListener listener1 = source.Connect(queue, func);
-  MediaEventListener listener2 = source.Connect(queue, &foo, &Foo::OnNotify);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify);
 
   // We expect i to be 2 since SomeEvent should be copied only once when
   // passing to each listener.
   source.Notify(SomeEvent(i));
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
   EXPECT_EQ(i, 2);
@@ -292,18 +292,18 @@ TEST(MediaEventSource, CopyEvent2)
   MediaEventProducer<SomeEvent> source;
   int i = 0;
 
   auto func = [] () {};
   struct Foo {
     void OnNotify() {}
   } foo;
 
-  MediaEventListener listener1 = source.Connect(queue, func);
-  MediaEventListener listener2 = source.Connect(queue, &foo, &Foo::OnNotify);
+  MediaEventListener listener1 = source.Connect(queue->AsAbstractThread(), func);
+  MediaEventListener listener2 = source.Connect(queue->AsAbstractThread(), &foo, &Foo::OnNotify);
 
   // SomeEvent won't be copied at all since the listeners take no arguments.
   source.Notify(SomeEvent(i));
 
   queue->BeginShutdown();
   queue->AwaitShutdownAndIdle();
   EXPECT_EQ(i, 0);
   listener1.Disconnect();
@@ -318,17 +318,17 @@ TEST(MediaEventSource, MoveOnly)
   RefPtr<TaskQueue> queue = new TaskQueue(
     GetMediaThreadPool(MediaThreadType::PLAYBACK));
 
   MediaEventProducerExc<UniquePtr<int>> source;
 
   auto func = [] (UniquePtr<int>&& aEvent) {
     EXPECT_EQ(*aEvent, 20);
   };
-  MediaEventListener listener = source.Connect(queue, func);
+  MediaEventListener listener = source.Connect(queue->AsAbstractThread(), func);
 
   // It is OK to pass an rvalue which is move-only.
   source.Notify(UniquePtr<int>(new int(20)));
   // It is an error to pass an lvalue which is move-only.
   // UniquePtr<int> event(new int(30));
   // source.Notify(event);
 
   queue->BeginShutdown();
diff --git a/dom/media/platforms/agnostic/OpusDecoder.cpp b/dom/media/platforms/agnostic/OpusDecoder.cpp
--- a/dom/media/platforms/agnostic/OpusDecoder.cpp
+++ b/dom/media/platforms/agnostic/OpusDecoder.cpp
@@ -340,17 +340,17 @@ OpusDataDecoder::Flush()
   nsCOMPtr<nsIRunnable> runnable = NS_NewRunnableFunction([this] () {
     MOZ_ASSERT(mOpusDecoder);
     // Reset the decoder.
     opus_multistream_decoder_ctl(mOpusDecoder, OPUS_RESET_STATE);
     mSkip = mOpusParser->mPreSkip;
     mPaddingDiscarded = false;
     mLastFrameTime.reset();
   });
-  SyncRunnable::DispatchToThread(mTaskQueue, runnable);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), runnable);
   mIsFlushing = false;
   return NS_OK;
 }
 
 /* static */
 bool
 OpusDataDecoder::IsOpus(const nsACString& aMimeType)
 {
diff --git a/dom/media/platforms/agnostic/TheoraDecoder.cpp b/dom/media/platforms/agnostic/TheoraDecoder.cpp
--- a/dom/media/platforms/agnostic/TheoraDecoder.cpp
+++ b/dom/media/platforms/agnostic/TheoraDecoder.cpp
@@ -102,17 +102,17 @@ TheoraDecoder::Init()
 nsresult
 TheoraDecoder::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction([this] () {
     // nothing to do for now.
   });
-  SyncRunnable::DispatchToThread(mTaskQueue, r);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), r);
   mIsFlushing = false;
   return NS_OK;
 }
 
 nsresult
 TheoraDecoder::DoDecodeHeader(const unsigned char* aData, size_t aLength)
 {
   bool bos = mPacketCount == 0;
diff --git a/dom/media/platforms/agnostic/VPXDecoder.cpp b/dom/media/platforms/agnostic/VPXDecoder.cpp
--- a/dom/media/platforms/agnostic/VPXDecoder.cpp
+++ b/dom/media/platforms/agnostic/VPXDecoder.cpp
@@ -87,17 +87,17 @@ VPXDecoder::Init()
 nsresult
 VPXDecoder::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction([this] () {
     // nothing to do for now.
   });
-  SyncRunnable::DispatchToThread(mTaskQueue, r);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), r);
   mIsFlushing = false;
   return NS_OK;
 }
 
 int
 VPXDecoder::DoDecode(MediaRawData* aSample)
 {
   MOZ_ASSERT(mTaskQueue->IsCurrentThreadIn());
diff --git a/dom/media/platforms/agnostic/VorbisDecoder.cpp b/dom/media/platforms/agnostic/VorbisDecoder.cpp
--- a/dom/media/platforms/agnostic/VorbisDecoder.cpp
+++ b/dom/media/platforms/agnostic/VorbisDecoder.cpp
@@ -270,17 +270,17 @@ VorbisDataDecoder::Flush()
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction([this] () {
     // Ignore failed results from vorbis_synthesis_restart. They
     // aren't fatal and it fails when ResetDecode is called at a
     // time when no vorbis data has been read.
     vorbis_synthesis_restart(&mVorbisDsp);
     mLastFrameTime.reset();
   });
-  SyncRunnable::DispatchToThread(mTaskQueue, r);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), r);
   mIsFlushing = false;
   return NS_OK;
 }
 
 /* static */
 bool
 VorbisDataDecoder::IsVorbis(const nsACString& aMimeType)
 {
diff --git a/dom/media/platforms/apple/AppleATDecoder.cpp b/dom/media/platforms/apple/AppleATDecoder.cpp
--- a/dom/media/platforms/apple/AppleATDecoder.cpp
+++ b/dom/media/platforms/apple/AppleATDecoder.cpp
@@ -99,17 +99,17 @@ AppleATDecoder::ProcessFlush()
 nsresult
 AppleATDecoder::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   LOG("Flushing AudioToolbox AAC decoder");
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod(this, &AppleATDecoder::ProcessFlush);
-  SyncRunnable::DispatchToThread(mTaskQueue, runnable);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), runnable);
   mIsFlushing = false;
   return NS_OK;
 }
 
 nsresult
 AppleATDecoder::Drain()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
diff --git a/dom/media/platforms/apple/AppleVTDecoder.cpp b/dom/media/platforms/apple/AppleVTDecoder.cpp
--- a/dom/media/platforms/apple/AppleVTDecoder.cpp
+++ b/dom/media/platforms/apple/AppleVTDecoder.cpp
@@ -93,17 +93,17 @@ AppleVTDecoder::Input(MediaRawData* aSam
 
 nsresult
 AppleVTDecoder::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod(this, &AppleVTDecoder::ProcessFlush);
-  SyncRunnable::DispatchToThread(mTaskQueue, runnable);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), runnable);
   mIsFlushing = false;
 
   mSeekTargetThreshold.reset();
 
   return NS_OK;
 }
 
 nsresult
diff --git a/dom/media/platforms/ffmpeg/FFmpegDataDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegDataDecoder.cpp
--- a/dom/media/platforms/ffmpeg/FFmpegDataDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegDataDecoder.cpp
@@ -136,17 +136,17 @@ FFmpegDataDecoder<LIBAV_VER>::Input(Medi
 
 nsresult
 FFmpegDataDecoder<LIBAV_VER>::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod(this, &FFmpegDataDecoder<LIBAV_VER>::ProcessFlush);
-  SyncRunnable::DispatchToThread(mTaskQueue, runnable);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), runnable);
   mIsFlushing = false;
   return NS_OK;
 }
 
 nsresult
 FFmpegDataDecoder<LIBAV_VER>::Drain()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
diff --git a/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp b/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
--- a/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
+++ b/dom/media/platforms/wmf/WMFMediaDataDecoder.cpp
@@ -172,17 +172,17 @@ nsresult
 WMFMediaDataDecoder::Flush()
 {
   MOZ_ASSERT(mCallback->OnReaderTaskQueue());
   MOZ_DIAGNOSTIC_ASSERT(!mIsShutDown);
 
   mIsFlushing = true;
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod(this, &WMFMediaDataDecoder::ProcessFlush);
-  SyncRunnable::DispatchToThread(mTaskQueue, runnable);
+  SyncRunnable::DispatchToThread(mTaskQueue->AsAbstractThread(), runnable);
   mIsFlushing = false;
   return NS_OK;
 }
 
 void
 WMFMediaDataDecoder::ProcessDrain()
 {
   if (!mIsFlushing && mMFTManager) {
diff --git a/xpcom/threads/TaskQueue.cpp b/xpcom/threads/TaskQueue.cpp
--- a/xpcom/threads/TaskQueue.cpp
+++ b/xpcom/threads/TaskQueue.cpp
@@ -6,16 +6,25 @@
 
 #include "mozilla/TaskQueue.h"
 
 #include "nsThreadUtils.h"
 #include "mozilla/SharedThreadPool.h"
 
 namespace mozilla {
 
+// AbstractThread does not implement virtual AddRef/Release.  So we have no
+// guarantees our version of AddRef/Release will be called if code is using
+// an AbstractThread* to reach us.  This confuses AddRef/Release logging here
+// so use non-logging versions.
+NS_IMPL_NONLOGGING_ADDREF_INHERITED(TaskQueue, AbstractThread);
+NS_IMPL_NONLOGGING_RELEASE_INHERITED(TaskQueue, AbstractThread);
+
+NS_IMPL_QUERY_INTERFACE(TaskQueue, nsIEventTarget);
+
 TaskQueue::TaskQueue(already_AddRefed<nsIEventTarget> aTarget,
                      bool aRequireTailDispatch)
   : AbstractThread(aRequireTailDispatch)
   , mTarget(aTarget)
   , mQueueMonitor("TaskQueue::Queue")
   , mTailDispatcher(nullptr)
   , mIsRunning(false)
   , mIsShutdown(false)
@@ -139,16 +148,47 @@ TaskQueue::IsEmpty()
 bool
 TaskQueue::IsCurrentThreadIn()
 {
   bool in = NS_GetCurrentThread() == mRunningThread;
   MOZ_ASSERT(in == (GetCurrent() == this));
   return in;
 }
 
+NS_IMETHODIMP
+TaskQueue::DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
+{
+  nsCOMPtr<nsIRunnable> ref = aEvent;
+  return Dispatch(ref.forget(), aFlags);
+}
+
+NS_IMETHODIMP
+TaskQueue::Dispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aFlags)
+{
+  nsCOMPtr<nsIRunnable> runnable = aEvent;
+  DispatchReason reason = aFlags == DISPATCH_TAIL ? TailDispatch
+                                                  : NormalDispatch;
+  MonitorAutoLock mon(mQueueMonitor);
+  return DispatchLocked(/* passed by ref */runnable, AbortIfFlushing,
+                        DontAssertDispatchSuccess, reason);
+}
+
+NS_IMETHODIMP
+TaskQueue::DelayedDispatch(already_AddRefed<nsIRunnable>, uint32_t aFlags)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+TaskQueue::IsOnCurrentThread(bool* aResult)
+{
+  *aResult = IsCurrentThreadIn();
+  return NS_OK;
+}
+
 nsresult
 TaskQueue::Runner::Run()
 {
   RefPtr<nsIRunnable> event;
   {
     MonitorAutoLock mon(mQueue->mQueueMonitor);
     MOZ_ASSERT(mQueue->mIsRunning);
     if (mQueue->mTasks.size() == 0) {
diff --git a/xpcom/threads/TaskQueue.h b/xpcom/threads/TaskQueue.h
--- a/xpcom/threads/TaskQueue.h
+++ b/xpcom/threads/TaskQueue.h
@@ -11,31 +11,33 @@
 #include "mozilla/MozPromise.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/TaskDispatcher.h"
 #include "mozilla/Unused.h"
 
 #include <queue>
 
 #include "mozilla/SharedThreadPool.h"
+#include "nsIEventTarget.h"
 #include "nsThreadUtils.h"
 
-class nsIEventTarget;
 class nsIRunnable;
 
 namespace mozilla {
 
 typedef MozPromise<bool, bool, false> ShutdownPromise;
 
 // Abstracts executing runnables in order in a thread pool. The runnables
 // dispatched to the TaskQueue will be executed in the order in which
 // they're received, and are guaranteed to not be executed concurrently.
 // They may be executed on different threads, and a memory barrier is used
 // to make this threadsafe for objects that aren't already threadsafe.
-class TaskQueue : public AbstractThread {
+class TaskQueue : public AbstractThread
+                , public nsIEventTarget
+{
 public:
   explicit TaskQueue(already_AddRefed<nsIEventTarget> aPool,
                      bool aSupportsTailDispatch = false);
 
   TaskDispatcher& TailDispatcher() override;
 
   TaskQueue* AsTaskQueue() override { return this; }
 
@@ -72,16 +74,28 @@ public:
   void AwaitShutdownAndIdle();
 
   bool IsEmpty();
 
   // Returns true if the current thread is currently running a Runnable in
   // the task queue.
   bool IsCurrentThreadIn() override;
 
+  AbstractThread*
+  AsAbstractThread()
+  {
+    return static_cast<AbstractThread*>(this);
+  }
+
+  nsIEventTarget*
+  AsEventTarget()
+  {
+    return static_cast<nsIEventTarget*>(this);
+  }
+
 protected:
   virtual ~TaskQueue();
 
 
   // Blocks until all task finish executing. Called internally by methods
   // that need to wait until the task queue is idle.
   // mQueueMonitor must be held.
   void AwaitIdleLocked();
@@ -172,13 +186,16 @@ protected:
     explicit Runner(TaskQueue* aQueue)
       : mQueue(aQueue)
     {
     }
     NS_IMETHOD Run() override;
   private:
     RefPtr<TaskQueue> mQueue;
   };
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIEVENTTARGET
 };
 
 } // namespace mozilla
 
 #endif // TaskQueue_h_
