# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  3913b66a43333479e87df60fbe767677271e0cb3
Bug 130118 P2 Make TaskQueue implement nsIEventTarget. r=bholley

diff --git a/xpcom/threads/SyncRunnable.h b/xpcom/threads/SyncRunnable.h
--- a/xpcom/threads/SyncRunnable.h
+++ b/xpcom/threads/SyncRunnable.h
@@ -6,16 +6,17 @@
 
 #ifndef mozilla_SyncRunnable_h
 #define mozilla_SyncRunnable_h
 
 #include "nsThreadUtils.h"
 #include "mozilla/AbstractThread.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/Move.h"
+#include "mozilla/TaskQueue.h"
 
 namespace mozilla {
 
 /**
  * This class will wrap a nsIRunnable and dispatch it to the main thread
  * synchronously. This is different from nsIEventTarget.DISPATCH_SYNC:
  * this class does not spin the event loop waiting for the event to be
  * dispatched. This means that you don't risk reentrance from pending
@@ -83,32 +84,45 @@ public:
 
     aThread->Dispatch(RefPtr<nsIRunnable>(this).forget());
     mozilla::MonitorAutoLock lock(mMonitor);
     while (!mDone) {
       lock.Wait();
     }
   }
 
+  void DispatchToThread(TaskQueue* aThread, bool aForceDispatch = false)
+  {
+    DispatchToThread(aThread->AsEventTarget());
+  }
+
   static void DispatchToThread(nsIEventTarget* aThread,
                                nsIRunnable* aRunnable,
                                bool aForceDispatch = false)
   {
     RefPtr<SyncRunnable> s(new SyncRunnable(aRunnable));
     s->DispatchToThread(aThread, aForceDispatch);
   }
 
   static void DispatchToThread(AbstractThread* aThread,
                                nsIRunnable* aRunnable,
                                bool aForceDispatch = false)
   {
     RefPtr<SyncRunnable> s(new SyncRunnable(aRunnable));
     s->DispatchToThread(aThread, aForceDispatch);
   }
 
+  static void DispatchToThread(TaskQueue* aThread,
+                               nsIRunnable* aRunnable,
+                               bool aForceDispatch = false)
+  {
+    RefPtr<SyncRunnable> s(new SyncRunnable(aRunnable));
+    s->DispatchToThread(aThread, aForceDispatch);
+  }
+
 protected:
   NS_IMETHOD Run() override
   {
     mRunnable->Run();
 
     mozilla::MonitorAutoLock lock(mMonitor);
     MOZ_ASSERT(!mDone);
 
diff --git a/xpcom/threads/TaskQueue.cpp b/xpcom/threads/TaskQueue.cpp
--- a/xpcom/threads/TaskQueue.cpp
+++ b/xpcom/threads/TaskQueue.cpp
@@ -6,16 +6,25 @@
 
 #include "mozilla/TaskQueue.h"
 
 #include "nsThreadUtils.h"
 #include "mozilla/SharedThreadPool.h"
 
 namespace mozilla {
 
+// AbstractThread does not implement virtual AddRef/Release.  So we have no
+// guarantees our version of AddRef/Release will be called if code is using
+// an AbstractThread* to reach us.  This confuses AddRef/Release logging here
+// so use non-logging versions.
+NS_IMPL_NONLOGGING_ADDREF_INHERITED(TaskQueue, AbstractThread);
+NS_IMPL_NONLOGGING_RELEASE_INHERITED(TaskQueue, AbstractThread);
+
+NS_IMPL_QUERY_INTERFACE(TaskQueue, nsIEventTarget);
+
 TaskQueue::TaskQueue(already_AddRefed<nsIEventTarget> aTarget,
                      bool aRequireTailDispatch)
   : AbstractThread(aRequireTailDispatch)
   , mTarget(aTarget)
   , mQueueMonitor("TaskQueue::Queue")
   , mTailDispatcher(nullptr)
   , mIsRunning(false)
   , mIsShutdown(false)
@@ -139,16 +148,47 @@ TaskQueue::IsEmpty()
 bool
 TaskQueue::IsCurrentThreadIn()
 {
   bool in = NS_GetCurrentThread() == mRunningThread;
   MOZ_ASSERT(in == (GetCurrent() == this));
   return in;
 }
 
+NS_IMETHODIMP
+TaskQueue::DispatchFromScript(nsIRunnable* aEvent, uint32_t aFlags)
+{
+  nsCOMPtr<nsIRunnable> ref = aEvent;
+  return Dispatch(ref.forget(), aFlags);
+}
+
+NS_IMETHODIMP
+TaskQueue::Dispatch(already_AddRefed<nsIRunnable> aEvent, uint32_t aFlags)
+{
+  nsCOMPtr<nsIRunnable> runnable = aEvent;
+  DispatchReason reason = aFlags == DISPATCH_TAIL ? TailDispatch
+                                                  : NormalDispatch;
+  MonitorAutoLock mon(mQueueMonitor);
+  return DispatchLocked(/* passed by ref */runnable, AbortIfFlushing,
+                        DontAssertDispatchSuccess, reason);
+}
+
+NS_IMETHODIMP
+TaskQueue::DelayedDispatch(already_AddRefed<nsIRunnable>, uint32_t aFlags)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+TaskQueue::IsOnCurrentThread(bool* aResult)
+{
+  *aResult = IsCurrentThreadIn();
+  return NS_OK;
+}
+
 nsresult
 TaskQueue::Runner::Run()
 {
   RefPtr<nsIRunnable> event;
   {
     MonitorAutoLock mon(mQueue->mQueueMonitor);
     MOZ_ASSERT(mQueue->mIsRunning);
     if (mQueue->mTasks.size() == 0) {
diff --git a/xpcom/threads/TaskQueue.h b/xpcom/threads/TaskQueue.h
--- a/xpcom/threads/TaskQueue.h
+++ b/xpcom/threads/TaskQueue.h
@@ -11,31 +11,36 @@
 #include "mozilla/MozPromise.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/TaskDispatcher.h"
 #include "mozilla/Unused.h"
 
 #include <queue>
 
 #include "mozilla/SharedThreadPool.h"
+#include "nsIEventTarget.h"
 #include "nsThreadUtils.h"
 
-class nsIEventTarget;
 class nsIRunnable;
 
 namespace mozilla {
 
 typedef MozPromise<bool, bool, false> ShutdownPromise;
 
 // Abstracts executing runnables in order in a thread pool. The runnables
 // dispatched to the TaskQueue will be executed in the order in which
 // they're received, and are guaranteed to not be executed concurrently.
 // They may be executed on different threads, and a memory barrier is used
 // to make this threadsafe for objects that aren't already threadsafe.
-class TaskQueue : public AbstractThread {
+//
+// NOTE: Inherit nsIEventTarget privately to avoid type ambiguity in
+// various APIs.  Use AsEventTarget() to case.
+class TaskQueue : private nsIEventTarget
+                , public AbstractThread
+{
 public:
   explicit TaskQueue(already_AddRefed<nsIEventTarget> aPool,
                      bool aSupportsTailDispatch = false);
 
   TaskDispatcher& TailDispatcher() override;
 
   TaskQueue* AsTaskQueue() override { return this; }
 
@@ -72,16 +77,22 @@ public:
   void AwaitShutdownAndIdle();
 
   bool IsEmpty();
 
   // Returns true if the current thread is currently running a Runnable in
   // the task queue.
   bool IsCurrentThreadIn() override;
 
+  nsIEventTarget*
+  AsEventTarget()
+  {
+    return static_cast<nsIEventTarget*>(this);
+  }
+
 protected:
   virtual ~TaskQueue();
 
 
   // Blocks until all task finish executing. Called internally by methods
   // that need to wait until the task queue is idle.
   // mQueueMonitor must be held.
   void AwaitIdleLocked();
@@ -172,13 +183,16 @@ protected:
     explicit Runner(TaskQueue* aQueue)
       : mQueue(aQueue)
     {
     }
     NS_IMETHOD Run() override;
   private:
     RefPtr<TaskQueue> mQueue;
   };
+
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIEVENTTARGET
 };
 
 } // namespace mozilla
 
 #endif // TaskQueue_h_
