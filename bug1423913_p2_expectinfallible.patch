# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4cd1885e8351a3e99cf2dee1af01a80b3d901671
Bug 1423913 P2 Make callers expect infallble CreateSource() and CreateHandle(). r=baku

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3437,19 +3437,17 @@ nsDocShell::MaybeCreateInitialClientSour
   if (!win) {
     return;
   }
 
   mInitialClientSource =
     ClientManager::CreateSource(ClientType::Window,
                                 win->EventTargetFor(TaskCategory::Other),
                                 principal);
-  if (NS_WARN_IF(!mInitialClientSource)) {
-    return;
-  }
+  MOZ_DIAGNOSTIC_ASSERT(mInitialClientSource);
 
   // Mark the initial client as execution ready, but owned by the docshell.
   // If the client is actually used this will cause ClientSource to force
   // the creation of the initial about:blank by calling nsDocShell::GetDocument().
   mInitialClientSource->DocShellExecutionReady(this);
 
   // Next, check to see if the parent is controlled.
   nsCOMPtr<nsIDocShell> parent = GetParentDocshell();
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -1796,19 +1796,17 @@ nsGlobalWindowInner::EnsureClientSource(
   //       principal.  We do this in docshell, but as mentioned we aren't
   //       smart enough to handle all cases yet.  For example, a
   //       window.open() with new URL should inherit the controller from
   //       the opener, but we probably don't handle that yet.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 EventTargetFor(TaskCategory::Other),
                                                 mDoc->NodePrincipal());
-    if (NS_WARN_IF(!mClientSource)) {
-      return NS_ERROR_FAILURE;
-    }
+    MOZ_DIAGNOSTIC_ASSERT(mClientSource);
     newClientSource = true;
   }
 
   // The load may have started controlling the Client as well.  If
   // so, mark it as controlled immediately here.  The actor may
   // or may not have been notified by the parent side about being
   // controlled yet.
   if (loadInfo) {
@@ -1828,19 +1826,17 @@ nsGlobalWindowInner::EnsureClientSource(
     //  https://github.com/w3c/ServiceWorker/issues/1232
     //
     else if (mClientSource->GetController().isSome()) {
       mClientSource.reset();
       mClientSource =
         ClientManager::CreateSource(ClientType::Window,
                                     EventTargetFor(TaskCategory::Other),
                                     mDoc->NodePrincipal());
-      if (NS_WARN_IF(!mClientSource)) {
-        return NS_ERROR_FAILURE;
-      }
+      MOZ_DIAGNOSTIC_ASSERT(mClientSource);
       newClientSource = true;
     }
   }
 
   // Its possible that we got a client just after being frozen in
   // the bfcache.  In that case freeze the client immediately.
   if (newClientSource && IsFrozen()) {
     mClientSource->Freeze();
diff --git a/dom/clients/manager/ClientChannelHelper.cpp b/dom/clients/manager/ClientChannelHelper.cpp
--- a/dom/clients/manager/ClientChannelHelper.cpp
+++ b/dom/clients/manager/ClientChannelHelper.cpp
@@ -115,16 +115,17 @@ class ClientChannelHelper final : public
       NS_ENSURE_SUCCESS(rv, rv);
 
       // Create the new ClientSource.  This should only happen for window
       // Clients since support cross-origin redirects are blocked by the
       // same-origin security policy.
       reservedClient.reset();
       reservedClient = ClientManager::CreateSource(ClientType::Window,
                                                    mEventTarget, principal);
+      MOZ_DIAGNOSTIC_ASSERT(reservedClient);
 
       newLoadInfo->GiveReservedClientSource(Move(reservedClient));
     }
 
     // Normally we keep the controller across channel redirects, but we must
     // clear it when a non-subresource load redirects.  Only do this for real
     // redirects, however.
     //
@@ -223,17 +224,17 @@ AddClientChannelHelper(nsIChannel* aChan
   if (initialClientInfo.isNothing() && reservedClientInfo.isNothing()) {
     // Wait to reserve the client until we are reasonably sure this method
     // will succeed.  We should only follow this path for window clients.
     // Workers should always provide a reserved ClientInfo since their
     // ClientSource object is owned by a different thread.
     reservedClient = ClientManager::CreateSource(ClientType::Window,
                                                  aEventTarget,
                                                  channelPrincipal);
-    NS_ENSURE_TRUE(reservedClient, NS_ERROR_FAILURE);
+    MOZ_DIAGNOSTIC_ASSERT(reservedClient);
   }
 
   RefPtr<ClientChannelHelper> helper =
     new ClientChannelHelper(outerCallbacks, aEventTarget);
 
   // Only set the callbacks helper if we are able to reserve the client
   // successfully.
   rv = aChannel->SetNotificationCallbacks(helper);
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2371,19 +2371,17 @@ ServiceWorkerManager::StartControllingAD
   ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
   nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
   if (activeWorker && innerWindow) {
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     if (clientInfo.isSome()) {
       RefPtr<ClientHandle> clientHandle =
         ClientManager::CreateHandle(clientInfo.ref(),
                                     SystemGroup::EventTargetFor(TaskCategory::Other));
-      if (clientHandle) {
-        ref = Move(clientHandle->Control(activeWorker->Descriptor()));
-      }
+      ref = Move(clientHandle->Control(activeWorker->Descriptor()));
     }
   }
 
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
   return Move(ref);
 }
 
 void
@@ -2719,19 +2717,17 @@ ServiceWorkerManager::DispatchFetchEvent
 
       if (clientInfo.isSome()) {
         // First, attempt to mark the reserved client controlled directly.  This
         // will update the controlled status in the ClientManagerService in the
         // parent.  It will also eventually propagate back to the ClientSource.
         RefPtr<ClientHandle> clientHandle =
           ClientManager::CreateHandle(clientInfo.ref(),
                                       SystemGroup::EventTargetFor(TaskCategory::Other));
-        if (clientHandle) {
-          clientHandle->Control(serviceWorker->Descriptor());
-        }
+        clientHandle->Control(serviceWorker->Descriptor());
       }
 
       // But we also note the reserved state on the LoadInfo.  This allows the
       // ClientSource to be updated immediately after the nsIChannel starts.
       // This is necessary to have the correct controller in place for immediate
       // follow-on requests.
       loadInfo->SetController(serviceWorker->Descriptor());
     }
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -5320,19 +5320,17 @@ WorkerPrivate::EnsureClientSource()
       type = ClientType::Serviceworker;
       break;
     default:
       MOZ_CRASH("unknown worker type!");
   }
 
   mClientSource = ClientManager::CreateSource(type, mWorkerHybridEventTarget,
                                               GetPrincipalInfo());
-  if (!mClientSource) {
-    return false;
-  }
+  MOZ_DIAGNOSTIC_ASSERT(mClientSource);
 
   if (mFrozen) {
     mClientSource->Freeze();
   }
 
   // Shortly after the client is reserved we will try loading the main script
   // for the worker.  This may get intercepted by the ServiceWorkerManager
   // which will then try to create a ClientHandle.  Its actually possible for
