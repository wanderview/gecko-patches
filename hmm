# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  16ed1c1764373103ee3962322c2d1fc796ce2010

diff --git a/ipc/glue/BackgroundUtils.cpp b/ipc/glue/BackgroundUtils.cpp
--- a/ipc/glue/BackgroundUtils.cpp
+++ b/ipc/glue/BackgroundUtils.cpp
@@ -614,17 +614,20 @@ MergeParentLoadInfoForwarder(ParentLoadI
   }
 
   nsresult rv;
 
   rv = aLoadInfo->SetAllowInsecureRedirectToDataURI(
     aForwarderArgs.allowInsecureRedirectToDataURI());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  aLoadInfo->ClearController();
+  if (aLoadInfo->GetController().isSome()) {
+    aLoadInfo->ClearController();
+  }
+
   auto& controller = aForwarderArgs.controller();
   if (controller.type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     aLoadInfo->SetController(
       ServiceWorkerDescriptor(controller.get_IPCServiceWorkerDescriptor()));
   }
 
   return NS_OK;
 }
@@ -697,17 +700,20 @@ MergeChildLoadInfoForwarder(const ChildL
   }
 
   if (reservedClientInfo.isSome()) {
     aLoadInfo->SetReservedClientInfo(reservedClientInfo.ref());
   } else if (initialClientInfo.isSome()) {
     aLoadInfo->SetInitialClientInfo(reservedClientInfo.ref());
   }
 
-  aLoadInfo->ClearController();
+  if (aLoadInfo->GetController().isSome()) {
+    aLoadInfo->ClearController();
+  }
+
   auto& controller = aForwarderArgs.controller();
   if (controller.type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     aLoadInfo->SetController(
       ServiceWorkerDescriptor(controller.get_IPCServiceWorkerDescriptor()));
   }
 
   return NS_OK;
 }
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -468,17 +468,17 @@ class StartRequestEvent : public NeckoTa
     LOG(("StartRequestEvent [this=%p]\n", mChild));
     mChild->OnStartRequest(mChannelStatus, mResponseHead, mUseResponseHead,
                            mRequestHeaders, mLoadInfoForwarder,
                            mIsFromCache, mCacheEntryAvailable,
                            mCacheEntryId, mCacheFetchCount,
                            mCacheExpirationTime, mCachedCharset,
                            mSecurityInfoSerialization, mSelfAddr, mPeerAddr,
                            mCacheKey, mAltDataType, mAltDataLen,
-                           mController, mApplyConversion);
+                           mApplyConversion);
   }
 
  private:
   nsresult mChannelStatus;
   nsHttpResponseHead mResponseHead;
   nsHttpHeaderArray mRequestHeaders;
   bool mUseResponseHead;
   bool mApplyConversion;
@@ -489,17 +489,16 @@ class StartRequestEvent : public NeckoTa
   uint32_t mCacheExpirationTime;
   nsCString mCachedCharset;
   nsCString mSecurityInfoSerialization;
   NetAddr mSelfAddr;
   NetAddr mPeerAddr;
   uint32_t mCacheKey;
   nsCString mAltDataType;
   int64_t mAltDataLen;
-  Maybe<ServiceWorkerDescriptor> mController;
   ParentLoadInfoForwarderArgs mLoadInfoForwarder;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvOnStartRequest(const nsresult& channelStatus,
                                      const nsHttpResponseHead& responseHead,
                                      const bool& useResponseHead,
                                      const nsHttpHeaderArray& requestHeaders,
@@ -573,17 +572,16 @@ HttpChannelChild::OnStartRequest(const n
                                  const uint32_t& cacheExpirationTime,
                                  const nsCString& cachedCharset,
                                  const nsCString& securityInfoSerialization,
                                  const NetAddr& selfAddr,
                                  const NetAddr& peerAddr,
                                  const uint32_t& cacheKey,
                                  const nsCString& altDataType,
                                  const int64_t& altDataLen,
-                                 const Maybe<ServiceWorkerDescriptor>& aController,
                                  const bool& aApplyConversion)
 {
   LOG(("HttpChannelChild::OnStartRequest [this=%p]\n", this));
 
   // mFlushedForDiversion and mDivertingToParent should NEVER be set at this
   // stage, as they are set in the listener's OnStartRequest.
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "mFlushedForDiversion should be unset before OnStartRequest!");
@@ -613,16 +611,17 @@ HttpChannelChild::OnStartRequest(const n
   mSelfAddr = selfAddr;
   mPeerAddr = peerAddr;
 
   mAvailableCachedAltDataType = altDataType;
   mAltDataLength = altDataLen;
 
   SetApplyConversion(aApplyConversion);
 
+  /*
   if (ServiceWorkerParentInterceptEnabled()) {
     const Maybe<ServiceWorkerDescriptor>& prevController =
       mLoadInfo->GetController();
 
     // If we got a service worker controller from the parent, then note
     // it on the LoadInfo.  This may indicate that a non-subresource request
     // was intercepted and the resulting window/worker should be controlled.
     if (aController.isSome() && prevController.isNothing()) {
@@ -634,16 +633,17 @@ HttpChannelChild::OnStartRequest(const n
     //  2. The parent and child both have the same controlling service worker.
     else {
       MOZ_DIAGNOSTIC_ASSERT((prevController.isNothing() && aController.isNothing()) ||
                             (prevController.ref().Id() == aController.ref().Id() &&
                              prevController.ref().Scope() == aController.ref().Scope() &&
                              prevController.ref().PrincipalInfo() == aController.ref().PrincipalInfo()));
     }
   }
+  */
 
   mAfterOnStartRequestBegun = true;
 
   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
 
   mCacheKey = cacheKey;
 
   // replace our request headers with what actually got sent in the parent
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -414,17 +414,16 @@ private:
                       const uint32_t& cacheExpirationTime,
                       const nsCString& cachedCharset,
                       const nsCString& securityInfoSerialization,
                       const NetAddr& selfAddr,
                       const NetAddr& peerAddr,
                       const uint32_t& cacheKey,
                       const nsCString& altDataType,
                       const int64_t& altDataLen,
-                      const Maybe<mozilla::dom::ServiceWorkerDescriptor>& aController,
                       const bool& aApplyConversion);
   void MaybeDivertOnData(const nsCString& data,
                          const uint64_t& offset,
                          const uint32_t& count);
   void OnTransportAndData(const nsresult& channelStatus,
                           const nsresult& status,
                           const uint64_t& offset,
                           const uint32_t& count,
