# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2a124bac79a198c1772fe888438e95f0732da510

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -693,23 +693,31 @@ RespondWithHandler::ResolvedCallback(JSC
 
     nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
     if (NS_WARN_IF(!stsThread)) {
       return;
     }
 
     MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(startRunnable.forget()));
 
-    // XXXnsm, Fix for Bug 1141332 means that if we decide to make this
-    // streaming at some point, we'll need a different solution to that bug.
+    // Note, we cannot auto-close after copy because we need
+    // a chance to abort the nsIChannel before it sees the end
+    // of the synthesized cache stream.
     rv = NS_AsyncCopy(body, responseBody, stsThread, NS_ASYNCCOPY_VIA_WRITESEGMENTS,
-                      kCopySegmentSize, RespondWithCopyComplete, closure.forget());
+                      kCopySegmentSize, RespondWithCopyComplete, closure.forget(),
+                      true, /* auto-close source */
+                      false /* auto-close sink */);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return;
     }
+
+    // Make sure not to accidentally release the synthesized cache file
+    // stream on the worker thread.
+    NS_ProxyRelease("SynthesizedResponseBody", worker->MainThreadEventTarget(),
+                    responseBody.forget());
   } else {
     MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(startRunnable.forget()));
     RespondWithCopyComplete(closure.forget(), NS_OK);
   }
 
   MOZ_ASSERT(!closure);
   autoCancel.Reset();
   mRequestWasHandled = true;
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -393,16 +393,18 @@ InterceptedChannelChrome::Cancel(nsresul
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   // we need to use AsyncAbort instead of Cancel since there's no active pump
   // to cancel which will provide OnStart/OnStopRequest to the channel.
   nsresult rv = mChannel->AsyncAbort(aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  mResponseBody->Close();
+
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::SetChannelInfo(dom::ChannelInfo* aChannelInfo)
 {
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -7065,17 +7065,17 @@ nsHttpChannel::OnStartRequest(nsIRequest
         mCacheEntry->AsyncDoom(nullptr);
         rv = StartRedirectChannelToURI(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
         if (NS_SUCCEEDED(rv))
             return NS_OK;
     }
 
     // avoid crashing if mListener happens to be null...
     if (!mListener) {
-        NS_NOTREACHED("mListener is null");
+        //NS_NOTREACHED("mListener is null");
         return NS_OK;
     }
 
     // before we start any content load, check for redirectTo being called
     // this code is executed mainly before we start load from the cache
     if (mAPIRedirectToURI && !mCanceled) {
         nsAutoCString redirectToSpec;
         mAPIRedirectToURI->GetAsciiSpec(redirectToSpec);
@@ -7573,17 +7573,18 @@ nsHttpChannel::OnDataAvailable(nsIReques
         return mStatus;
 
     if (mAuthRetryPending || WRONG_RACING_RESPONSE_SOURCE(request) ||
         (request == mTransactionPump && mTransactionReplaced)) {
         uint32_t n;
         return input->ReadSegments(NS_DiscardSegment, nullptr, count, &n);
     }
 
-    MOZ_ASSERT(mResponseHead, "No response head in ODA!!");
+    NS_ENSURE_TRUE(mResponseHead, NS_ERROR_FAILURE);
+    //MOZ_ASSERT(mResponseHead, "No response head in ODA!!");
 
     MOZ_ASSERT(!(mCachedContentIsPartial && (request == mTransactionPump)),
                "transaction pump not suspended");
 
     mIsReadingFromCache = (request == mCachePump);
 
     if (mListener) {
         //
