# HG changeset patch
# Parent e5affb16872a5bfff42132cb7bb3652a2323878d
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -36,16 +36,17 @@ public:
     : mQuotaInfo(aQuotaInfo)
   { }
 
   NS_IMETHOD Run() MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
     QuotaManager* qm = QuotaManager::Get();
     MOZ_ASSERT(qm);
+    printf_stderr("### ### Calling AllowNextSynchronizedOp()\n");
     qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                 Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
                                 mQuotaInfo.mStorageId);
     return NS_OK;
   }
 
 private:
   ~QuotaReleaseRunnable() { }
@@ -236,16 +237,17 @@ Context::QuotaInitRunnable::Run()
                                  Client::DOMCACHE,
                                  NS_LITERAL_STRING("cache"),
                                  mQuotaInfo.mStorageId);
 
       // QuotaManager::WaitForOpenAllowed() will hold a reference to us as
       // a callback.  We will then get executed again on the main thread when
       // it is safe to open the quota directory.
       mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      printf_stderr("### ### Calling WaitForOpenAllowed()\n");
       rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                   Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
                                   mQuotaInfo.mStorageId, this);
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
       }
       break;
@@ -274,16 +276,17 @@ Context::QuotaInitRunnable::Run()
     {
       // Can't assert quota IO thread because its an idle thread that can get
       // recreated.  At least assert we're not on main thread or owning thread.
       MOZ_ASSERT(!NS_IsMainThread());
       MOZ_ASSERT(_mOwningThread.GetThread() != PR_GetCurrentThread());
 
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
+      printf_stderr("### ### Calling EnsureOriginIsInitialized()\n");
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
         Resolve(rv);
         return NS_OK;
@@ -337,16 +340,17 @@ Context::QuotaInitRunnable::Run()
   return NS_OK;
 }
 
 // Runnable wrapper around Action objects dispatched on the Context.  This
 // runnable executes the Action on the appropriate threads while the Context
 // is initialized.
 class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
                                         , public Action::Resolver
+                                        , public Context::CancelableHandle
 {
 public:
   ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
                  const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
@@ -370,22 +374,25 @@ public:
     nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
-  bool MatchesCacheId(CacheId aCacheId) {
+  virtual bool
+  MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE
+  {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     return mAction->MatchesCacheId(aCacheId);
   }
 
-  void Cancel()
+  virtual void
+  Cancel() MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
@@ -408,17 +415,17 @@ private:
     MOZ_ASSERT(!mAction);
   }
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mAction);
-    mContext->OnActionRunnableComplete(this);
+    mContext->OnCancelableHandleDestroyed(this);
     mContext = nullptr;
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
     STATE_RUN_ON_TARGET,
@@ -563,23 +570,27 @@ Context::ThreadsafeHandle::~ThreadsafeHa
 void
 Context::ThreadsafeHandle::AllowToCloseOnOwningThread()
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
   // A Context "closes" when its ref count drops to zero.  Dropping this
   // strong ref is necessary, but not sufficient for the close to occur.
   // Any outstanding IO will continue and keep the Context alive.  Once
   // the Context is idle, it will be destroyed.
+  printf_stderr("### ### [%p] ThreadsafeHandle::CancelAndAllowToCloseOnOwningThread() mStrongRef:%p\n",
+                this, mStrongRef.get());
   mStrongRef = nullptr;
 }
 
 void
 Context::ThreadsafeHandle::CancelAndAllowToCloseOnOwningThread()
 {
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  printf_stderr("### ### [%p] ThreadsafeHandle::CancelAndAllowToCloseOnOwningThread() mWeakRef:%p mStrongRef:%p\n",
+                this, mWeakRef, mStrongRef.get());
   // Cancel the Context through the weak reference.  This means we can
   // allow the Context to close by dropping the strong ref, but then
   // still cancel ongoing IO if necessary.
   if (mWeakRef) {
     mWeakRef->CancelAll();
   }
   // We should synchronously have AllowToCloseOnOwningThread called when
   // the Context is canceled.
@@ -642,55 +653,57 @@ Context::Dispatch(nsIEventTarget* aTarge
   DispatchAction(aTarget, aAction);
 }
 
 void
 Context::CancelAll()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   mState = STATE_CONTEXT_CANCELED;
+  printf_stderr("### ### [%p] Context::CancelAll()\n", this);
   mPendingActions.Clear();
-  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
-    nsRefPtr<ActionRunnable> runnable = mActionRunnables[i];
-    runnable->Cancel();
+  for (uint32_t i = 0; i < mCancelableHandles.Length(); ++i) {
+    mCancelableHandles[i]->Cancel();
   }
   AllowToClose();
 }
 
 void
 Context::AllowToClose()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
+  printf_stderr("### ### [%p] Context::AllowToClose()\n", this);
   if (mThreadsafeHandle) {
     mThreadsafeHandle->AllowToClose();
   }
 }
 
 void
 Context::CancelForCacheId(CacheId aCacheId)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
       mPendingActions.RemoveElementAt(i);
     }
   }
-  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
-    nsRefPtr<ActionRunnable> runnable = mActionRunnables[i];
-    if (runnable->MatchesCacheId(aCacheId)) {
-      runnable->Cancel();
+  for (uint32_t i = 0; i < mCancelableHandles.Length(); ++i) {
+    if (mCancelableHandles[i]->MatchesCacheId(aCacheId)) {
+      mCancelableHandles[i]->Cancel();
     }
   }
 }
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mManager);
 
+  printf_stderr("### ### [%p] ~Context()\n", this);
+
   if (mThreadsafeHandle) {
     mThreadsafeHandle->ContextDestroyed(this);
   }
 
   mManager->RemoveContext(this);
 }
 
 void
@@ -701,17 +714,17 @@ Context::DispatchAction(nsIEventTarget* 
   nsRefPtr<ActionRunnable> runnable =
     new ActionRunnable(this, aTarget, aAction, mQuotaInfo);
   nsresult rv = runnable->Dispatch();
   if (NS_FAILED(rv)) {
     // Shutdown must be delayed until all Contexts are destroyed.  Crash
     // for this invariant violation.
     MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
   }
-  mActionRunnables.AppendElement(runnable);
+  mCancelableHandles.AppendElement(runnable);
 }
 
 void
 Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                      nsMainThreadPtrHandle<nsISupports>& aOfflineStorage)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
 
@@ -734,21 +747,21 @@ Context::OnQuotaInit(nsresult aRv, const
 
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
   }
   mPendingActions.Clear();
 }
 
 void
-Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+Context::OnCancelableHandleDestroyed(CancelableHandle* aHandle)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActionRunnable);
-  MOZ_ALWAYS_TRUE(mActionRunnables.RemoveElement(aActionRunnable));
+  MOZ_ASSERT(aHandle);
+  MOZ_ALWAYS_TRUE(mCancelableHandles.RemoveElement(aHandle));
 }
 
 already_AddRefed<Context::ThreadsafeHandle>
 Context::CreateThreadsafeHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   if (!mThreadsafeHandle) {
     mThreadsafeHandle = new ThreadsafeHandle(this);
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
--- a/dom/cache/Context.h
+++ b/dom/cache/Context.h
@@ -73,16 +73,24 @@ public:
     // safe to access on owning thread.
     Context* mWeakRef;
 
     nsCOMPtr<nsIThread> mOwningThread;
 
     NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Context::ThreadsafeHandle)
   };
 
+  // Must call OnCancelableHandleDestroyed() in its destructor
+  class CancelableHandle
+  {
+  public:
+    virtual void Cancel() = 0;
+    virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
+  };
+
   static already_AddRefed<Context>
   Create(Manager* aManager, Action* aQuotaIOThreadAction);
 
   // Execute given action on the target once the quota manager has been
   // initialized.
   //
   // Only callable from the thread that created the Context.
   void Dispatch(nsIEventTarget* aTarget, Action* aAction);
@@ -127,28 +135,29 @@ private:
     nsRefPtr<Action> mAction;
   };
 
   explicit Context(Manager* aManager);
   ~Context();
   void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
   void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                    nsMainThreadPtrHandle<nsISupports>& aOfflineStorage);
-  void OnActionRunnableComplete(ActionRunnable* const aAction);
+  void OnCancelableHandleDestroyed(CancelableHandle* aHandle);
 
   already_AddRefed<ThreadsafeHandle>
   CreateThreadsafeHandle();
 
   nsRefPtr<Manager> mManager;
   State mState;
   QuotaInfo mQuotaInfo;
   nsTArray<PendingAction> mPendingActions;
 
-  // weak refs since ~ActionRunnable() removes itself from this list
-  nsTArray<ActionRunnable*> mActionRunnables;
+  // Weak refs since handles must remove themselves from this list before
+  // being destroyed by calling OnCancelableHandleDestroyed().
+  nsTArray<CancelableHandle*> mCancelableHandles;
 
   // The ThreadsafeHandle may have a strong ref back to us.  This creates
   // a ref-cycle that keeps the Context alive.  The ref-cycle is broken
   // when ThreadsafeHandle::AllowToClose() is called.
   nsRefPtr<ThreadsafeHandle> mThreadsafeHandle;
 
   nsMainThreadPtrHandle<nsISupports> mOfflineStorage;
 
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
--- a/dom/cache/OfflineStorage.cpp
+++ b/dom/cache/OfflineStorage.cpp
@@ -25,26 +25,28 @@ class CacheOfflineStorage MOZ_FINAL : pu
 {
 public:
   CacheOfflineStorage(Context::ThreadsafeHandle* aContext,
                       const QuotaInfo& aQuotaInfo)
     : mContext(aContext)
     , mQuotaInfo(aQuotaInfo)
   {
     MOZ_ASSERT(mContext);
+    printf_stderr("### ### [%p] CacheOfflineStorage()\n", this);
 
     mPersistenceType = PERSISTENCE_TYPE_DEFAULT;
     mGroup = mQuotaInfo.mGroup;
     mClient = CreateQuotaClient();
   }
 
 private:
   ~CacheOfflineStorage()
   {
     MOZ_ASSERT(NS_IsMainThread());
+    printf_stderr("### ### [%p] ~CacheOfflineStorage()\n", this);
     nsRefPtr<QuotaManager> qm = QuotaManager::GetOrCreate();
     if (!qm) {
       NS_WARNING("QuotaManager gone before Cache storage could unregister");
       return;
     }
     qm->UnregisterStorage(this);
   }
 
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -68,16 +68,17 @@ public:
   {
     return DOMCACHE;
   }
 
   virtual nsresult
   InitOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
              const nsACString& aOrigin, UsageInfo* aUsageInfo) MOZ_OVERRIDE
   {
+    printf_stderr("### ### QuotaClient::InitOrigin()\n");
     return NS_OK;
   }
 
   virtual nsresult
   GetUsageForOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
                     const nsACString& aOrigin,
                     UsageInfo* aUsageInfo) MOZ_OVERRIDE
   {
@@ -147,42 +148,48 @@ public:
     return NS_OK;
   }
 
   virtual void
   OnOriginClearCompleted(PersistenceType aPersistenceType,
                          const nsACString& aOrigin) MOZ_OVERRIDE
   {
     // nothing to do
+    printf_stderr("### ### QuotaClient::OnOriginClearCompleted()\n");
   }
 
   virtual void
   ReleaseIOThreadObjects() MOZ_OVERRIDE
   {
     // nothing to do
+    printf_stderr("### ### QuotaClient::ReleaseIOThreadObjects()\n");
   }
 
   virtual bool
   IsFileServiceUtilized() MOZ_OVERRIDE
   {
-    return false;
+    printf_stderr("### ### QuotaClient::IsFileServiceUtilized()\n");
+    return true;
   }
 
   virtual bool
   IsTransactionServiceActivated() MOZ_OVERRIDE
   {
     // TODO: implement nsIOfflineStorage interface (bug 1110487)
-    return false;
+    printf_stderr("### ### QuotaClient::IsTransactionServiceActivated()\n");
+    return true;
   }
 
   virtual void
   WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
                             nsIRunnable* aCallback) MOZ_OVERRIDE
   {
     // TODO: implement nsIOfflineStorage interface (bug 1110487)
+    printf_stderr("### ### QuotaClient::WaitForStoragesToComplete()\n");
+    aCallback->Run();
   }
 
 
   virtual void
   ShutdownTransactionService() MOZ_OVERRIDE
   {
     MOZ_ASSERT(NS_IsMainThread());
 
diff --git a/dom/cache/StreamList.cpp b/dom/cache/StreamList.cpp
--- a/dom/cache/StreamList.cpp
+++ b/dom/cache/StreamList.cpp
@@ -137,16 +137,30 @@ void
 StreamList::CloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   if (mStreamControl) {
     mStreamControl->CloseAll();
   }
 }
 
+void
+StreamList::Cancel()
+{
+  NS_ASSERT_OWNINGTHREAD(StreamList);
+  CloseAll();
+}
+
+bool
+StreamList::MatchesCacheId(CacheId aCacheId) const
+{
+  NS_ASSERT_OWNINGTHREAD(StreamList);
+  return aCacheId == mCacheId;
+}
+
 StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   MOZ_ASSERT(!mStreamControl);
   if (mActivated) {
     mManager->RemoveStreamList(this);
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mManager->ReleaseBodyId(mList[i].mId);
diff --git a/dom/cache/StreamList.h b/dom/cache/StreamList.h
--- a/dom/cache/StreamList.h
+++ b/dom/cache/StreamList.h
@@ -2,31 +2,31 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_StreamList_h
 #define mozilla_dom_cache_StreamList_h
 
+#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsRefPtr.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheStreamControlParent;
-class Context;
 class Manager;
 
-class StreamList
+class StreamList MOZ_FINAL : public Context::CancelableHandle
 {
 public:
   StreamList(Manager* aManager, Context* aContext);
 
   void SetStreamControl(CacheStreamControlParent* aStreamControl);
   void RemoveStreamControl(CacheStreamControlParent* aStreamControl);
 
   void Activate(CacheId aCacheId);
@@ -34,16 +34,20 @@ public:
   void Add(const nsID& aId, nsIInputStream* aStream);
   already_AddRefed<nsIInputStream> Extract(const nsID& aId);
 
   void NoteClosed(const nsID& aId);
   void NoteClosedAll();
   void Close(const nsID& aId);
   void CloseAll();
 
+  // Context::CancelableHandle methods
+  virtual void Cancel() MOZ_OVERRIDE;
+  virtual bool MatchesCacheId(CacheId aCacheId) const MOZ_OVERRIDE;
+
 private:
   ~StreamList();
   struct Entry
   {
     nsID mId;
     nsCOMPtr<nsIInputStream> mStream;
   };
   nsRefPtr<Manager> mManager;
diff --git a/dom/cache/test/mochitest/test_cache.html b/dom/cache/test/mochitest/test_cache.html
--- a/dom/cache/test/mochitest/test_cache.html
+++ b/dom/cache/test/mochitest/test_cache.html
@@ -2,16 +2,17 @@
    - http://creativecommons.org/publicdomain/zero/1.0/ -->
 <!DOCTYPE HTML>
 <html>
 <head>
   <title>Validate Interfaces Exposed to Workers</title>
   <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
   <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
   <script type="text/javascript" src="worker_driver.js"></script>
+  <script type="text/javascript" src="helpers.js"></script>
 </head>
 <body>
 <iframe id="frame"></iframe>
 <script class="testbody" type="text/javascript">
 SimpleTest.waitForExplicitFinish();
 SpecialPowers.pushPrefEnv({
   "set": [["dom.caches.enabled", true]]
 }, function() {
diff --git a/dom/cache/test/mochitest/worker_driver.js b/dom/cache/test/mochitest/worker_driver.js
--- a/dom/cache/test/mochitest/worker_driver.js
+++ b/dom/cache/test/mochitest/worker_driver.js
@@ -21,24 +21,39 @@
 //
 //  workerTestGetPrefs() - request an array of prefs value from the main thread
 //  workerTestGetPermissions() - request an array permissions from the MT
 //  workerTestGetVersion() - request the current version string from the MT
 //  workerTestGetUserAgent() - request the user agent string from the MT
 //
 // For an example see test_worker_interfaces.html and test_worker_interfaces.js.
 
+function clearStorage(callback) {
+  var principal = SpecialPowers.wrap(document).nodePrincipal;
+  var appId, inBrowser;
+  var nsIPrincipal = SpecialPowers.Components.interfaces.nsIPrincipal;
+  if (principal.appId != nsIPrincipal.UNKNOWN_APP_ID &&
+      principal.appId != nsIPrincipal.NO_APP_ID) {
+    appId = principal.appId;
+    inBrowser = principal.isInBrowserElement;
+  }
+  dump("### ### calling SpecialPowers.clearStorageForURI\n");
+  SpecialPowers.clearStorageForURI(document.documentURI, callback, appId, inBrowser);
+}
+
 function workerTestExec(script) {
   SimpleTest.waitForExplicitFinish();
   var worker = new Worker('worker_wrapper.js');
   worker.onmessage = function(event) {
     if (event.data.type == 'finish') {
       SpecialPowers.forceGC();
-      SimpleTest.finish();
-
+      clearStorage(function() {
+        dump("### ### calling SimpleTest.finish()\n");
+        SimpleTest.finish();
+      });
     } else if (event.data.type == 'status') {
       ok(event.data.status, event.data.msg);
 
     } else if (event.data.type == 'getPrefs') {
       var result = {};
       event.data.prefs.forEach(function(pref) {
         result[pref] = SpecialPowers.Services.prefs.getBoolPref(pref);
       });
