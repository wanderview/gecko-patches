# HG changeset patch
# Parent  14b5795d374010eb8a1ce02e1fa2fb17bb8cf1b0

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -56,58 +56,46 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Convert the precise delay to integral milliseconds for nsITimer.  We can
-  // round down as long as its within our mFlexTime.  If we round down more
-  // than this than we might have to trigger another nsITimer after this one
-  // fires.  Instead, round up to the next integral millisecond if rounding
-  // down would exceed our mFlexTime.
-  //
-  // For example:
-  //  * if delay is 5.4ms and our flex time is 0.25ms, then round up to 6ms
-  //  * if delay is 5.4ms and our flex time is 0.5ms, then round down to 5ms
   TimeDuration delay = aDeadline - aNow;
-  uint32_t delayMS = static_cast<uint32_t>(delay.ToMilliseconds() +
-                                           1.0 - mFlexTime.ToMilliseconds());
-
-  rv = mTimer->InitWithCallback(this, delayMS,
+  rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
 nsresult
-TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
+TimeoutExecutor::Schedule(const TimeStamp& aDeadline, const TimeStamp& aNow)
 {
-  TimeStamp now(TimeStamp::Now());
+  TimeStamp now(aNow.IsNull() ? TimeStamp::Now() : aNow);
 
   // Schedule an immediate runnable if the desired deadline has passed
   // or is slightly in the future.  This matches previous behavior
   // when we used nsITimer for each timeout.  The nsITimer code rounds
   // to the nearest interval and can fire the timer a few microseconds
   // early.  Match that behavior here.
   if (aDeadline <= (now + mFlexTime)) {
     return ScheduleImmediate(aDeadline, now);
   }
 
   return ScheduleDelayed(aDeadline, now);
 }
 
 nsresult
-TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline, const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
   MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Immediate ||
                         mMode == Mode::Delayed);
 
   if (aDeadline >= mDeadline) {
     return NS_OK;
   }
@@ -115,33 +103,33 @@ TimeoutExecutor::MaybeReschedule(const T
   if (mMode == Mode::Immediate) {
     // Don't reduce the deadline here as we want to execute the
     // timer we originally scheduled even if its a few microseconds
     // in the future.
     return NS_OK;
   }
 
   Cancel();
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aNow);
 }
 
 void
 TimeoutExecutor::MaybeExecute()
 {
   MOZ_DIAGNOSTIC_ASSERT(mMode != Mode::Shutdown && mMode != Mode::None);
   MOZ_DIAGNOSTIC_ASSERT(mOwner);
   MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
 
   // Sometimes nsITimer or canceled timers will fire too early.  If this
   // happens then just cap our deadline to our maximum time in the future
   // and proceed.  If there are no timers ready we will get rescheduled
   // by TimeoutManager.
   TimeStamp now(TimeStamp::Now());
-  if (mDeadline > now + mFlexTime) {
-    mDeadline = now + mFlexTime;
+  if (mDeadline > (now + mFlexTime + mFlexTime)) {
+    mDeadline = now + mFlexTime + mFlexTime;
   }
 
   TimeStamp deadline(mDeadline);
 
   Cancel();
 
   mOwner->RunTimeout(now, deadline);
 }
@@ -164,29 +152,29 @@ TimeoutExecutor::Shutdown()
     mTimer = nullptr;
   }
 
   mMode = Mode::Shutdown;
   mDeadline = TimeStamp();
 }
 
 nsresult
-TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
+TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline, const TimeStamp& aNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
 
   if (mMode == Mode::Shutdown) {
     return NS_OK;
   }
 
   if (mMode == Mode::Immediate || mMode == Mode::Delayed) {
-    return MaybeReschedule(aDeadline);
+    return MaybeReschedule(aDeadline, aNow);
   }
 
-  return Schedule(aDeadline);
+  return Schedule(aDeadline, aNow);
 }
 
 void
 TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
--- a/dom/base/TimeoutExecutor.h
+++ b/dom/base/TimeoutExecutor.h
@@ -37,32 +37,32 @@ class TimeoutExecutor final : public nsI
 
   nsresult
   ScheduleImmediate(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   nsresult
   ScheduleDelayed(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   nsresult
-  Schedule(const TimeStamp& aDeadline);
+  Schedule(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   nsresult
-  MaybeReschedule(const TimeStamp& aDeadline);
+  MaybeReschedule(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   void
   MaybeExecute();
 
 public:
   explicit TimeoutExecutor(TimeoutManager* aOwner);
 
   void
   Shutdown();
 
   nsresult
-  MaybeSchedule(const TimeStamp& aDeadline);
+  MaybeSchedule(const TimeStamp& aDeadline, const TimeStamp& aNow);
 
   void
   Cancel();
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
   NS_DECL_NSINAMED
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -404,23 +404,24 @@ TimeoutManager::SetTimeout(nsITimeoutHan
     // now...
     realInterval = std::max(realInterval,
                             uint32_t(DOMMinTimeoutValue(timeout->mIsTracking)));
   }
 
   timeout->mWindow = &mWindow;
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
-  timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
+  TimeStamp now(TimeStamp::Now());
+  timeout->SetWhenOrTimeRemaining(now, delta);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     MOZ_ASSERT(!timeout->When().IsNull());
 
-    nsresult rv = mExecutor->MaybeSchedule(timeout->When());
+    nsresult rv = mExecutor->MaybeSchedule(timeout->When(), now);
     if (NS_FAILED(rv)) {
       return rv;
     }
   }
 
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
@@ -515,17 +516,17 @@ TimeoutManager::ClearTimeout(int32_t aTi
   mExecutor->Cancel();
 
   OrderedTimeoutIterator iter(mNormalTimeouts,
                               mTrackingTimeouts,
                               nullptr,
                               nullptr);
   Timeout* nextTimeout = iter.Next();
   if (nextTimeout) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextTimeout->When()));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextTimeout->When(), TimeStamp::Now()));
   }
 }
 
 void
 TimeoutManager::RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline)
 {
   MOZ_DIAGNOSTIC_ASSERT(!aTargetDeadline.IsNull());
 
@@ -569,26 +570,27 @@ TimeoutManager::RunTimeout(const TimeSta
   // Silence the static analysis error about windowKungFuDeathGrip.  Accessing
   // members of mWindow here is safe, because the lifetime of TimeoutManager is
   // the same as the lifetime of the containing nsGlobalWindow.
   Unused << windowKungFuDeathGrip;
 
   // A native timer has gone off. See which of our timeouts need
   // servicing
   TimeStamp deadline;
+  TimeStamp now(aNow);
 
-  if (aTargetDeadline > aNow) {
+  if (aTargetDeadline > now) {
     // The OS timer fired early (which can happen due to the timers
     // having lower precision than TimeStamp does).  Set |deadline| to
     // be the time when the OS timer *should* have fired so that any
     // timers that *should* have fired *will* be fired now.
 
     deadline = aTargetDeadline;
   } else {
-    deadline = aNow;
+    deadline = now;
   }
 
   TimeStamp nextDeadline;
 
   // The timeout list is kept in deadline order. Discover the latest timeout
   // whose deadline has expired. On some platforms, native timeout events fire
   // "early", but we handled that above by setting deadline to aTargetDeadline
   // if the timer fired early.  So we can stop walking if we get to timeouts
@@ -635,23 +637,25 @@ TimeoutManager::RunTimeout(const TimeSta
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
   }
 
+  now = TimeStamp::Now();
+
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.  Note, this *must* be done
   // before we start executing any content script handlers.  If one
   // of them spins the event loop the executor must already be scheduled
   // in order for timeouts to fire properly.
   if (!nextDeadline.IsNull()) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline, now));
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_normal_timeout && !last_expired_tracking_timeout) {
     return;
   }
@@ -762,19 +766,21 @@ TimeoutManager::RunTimeout(const TimeSta
         mTrackingTimeouts.SetInsertionPoint(last_tracking_insertion_point);
 
         // Since ClearAllTimeouts() was called the lists should be empty.
         MOZ_DIAGNOSTIC_ASSERT(!HasTimeouts());
 
         return;
       }
 
+      now = TimeStamp::Now();
+
       // If we have a regular interval timer, we re-schedule the
       // timeout, accounting for clock drift.
-      bool needsReinsertion = RescheduleTimeout(timeout, aNow);
+      bool needsReinsertion = RescheduleTimeout(timeout, now);
 
       // Running a timeout can cause another timeout to be deleted, so
       // we need to reset the pointer to the following timeout.
       runIter.UpdateIterator();
 
       timeout->remove();
 
       if (needsReinsertion) {
@@ -788,23 +794,23 @@ TimeoutManager::RunTimeout(const TimeSta
           mNormalTimeouts.Insert(timeout,
                                  mWindow.IsFrozen() ? Timeouts::SortBy::TimeRemaining
                                                     : Timeouts::SortBy::TimeWhen);
         }
       }
 
       // Check to see if we have run out of time to execute timeout handlers.
       // If we've exceeded our time budget then terminate the loop immediately.
-      TimeDuration elapsed = TimeStamp::Now() - start;
+      TimeDuration elapsed = now - start;
       if (elapsed >= totalTimeLimit) {
         // We ran out of time.  Make sure to schedule the executor to
         // run immediately for the next timer, if it exists.
         RefPtr<Timeout> timeout = runIter.Next();
         if (timeout) {
-          MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(timeout->When()));
+          MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(timeout->When(), now));
         }
         break;
       }
     }
   }
 
   // Take the dummy timeout off the head of the list
   if (dummy_normal_timeout->isInList()) {
@@ -847,17 +853,17 @@ TimeoutManager::RescheduleTimeout(Timeou
   aTimeout->SetWhenOrTimeRemaining(currentNow, delay);
 
   if (mWindow.IsSuspended()) {
     return true;
   }
 
   // Reschedule the OS timer. Don't bother returning any error codes if
   // this fails since the callers of this method don't care about them.
-  nsresult rv = mExecutor->MaybeSchedule(aTimeout->When());
+  nsresult rv = mExecutor->MaybeSchedule(aTimeout->When(), currentNow);
   if (NS_FAILED(rv)) {
     NS_ERROR("Error initializing timer for DOM timeout!");
     return false;
   }
 
   return true;
 }
 
@@ -889,17 +895,17 @@ TimeoutManager::ResetTimersForThrottleRe
   NS_ENSURE_SUCCESS(rv, rv);
 
   OrderedTimeoutIterator iter(mNormalTimeouts,
                               mTrackingTimeouts,
                               nullptr,
                               nullptr);
   Timeout* firstTimeout = iter.Next();
   if (firstTimeout) {
-    rv = mExecutor->MaybeSchedule(firstTimeout->When());
+    rv = mExecutor->MaybeSchedule(firstTimeout->When(), TimeStamp::Now());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 TimeoutManager::Timeouts::ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
@@ -1167,17 +1173,17 @@ TimeoutManager::Resume()
     aTimeout->SetWhenOrTimeRemaining(now, TimeDuration::FromMilliseconds(delay));
 
     if (nextWakeUp.IsNull() || aTimeout->When() < nextWakeUp) {
       nextWakeUp = aTimeout->When();
     }
   });
 
   if (!nextWakeUp.IsNull()) {
-    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextWakeUp));
+    MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextWakeUp, now));
   }
 }
 
 void
 TimeoutManager::Freeze()
 {
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Freeze(TimeoutManager=%p)\n", this));
