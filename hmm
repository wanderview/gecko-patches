# HG changeset patch
# Parent c8d33c811c8fc62a7cde3f23da9ecec737dd4b27
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -10502,19 +10502,28 @@ nsGlobalWindow::GetInterface(JSContext* 
 {
   dom::GetInterface(aCx, this, aIID, aRetval, aError);
 }
 
 already_AddRefed<CacheStorage>
 nsGlobalWindow::GetCaches(ErrorResult& aRv)
 {
   if (!mCacheStorage) {
+    bool serviceWorkersTestingInWindow = false;
+    if (IsOuterWindow()) {
+      serviceWorkersTestingInWindow = GetServiceWorkersTestingEnabled();
+    } else {
+      nsRefPtr<nsGlobalWindow> outer = GetOuterWindowInternal();
+      serviceWorkersTestingInWindow = outer->GetServiceWorkersTestingEnabled();
+    }
     mCacheStorage = CacheStorage::CreateOnMainThread(cache::DEFAULT_NAMESPACE,
                                                      this, GetPrincipal(),
-                                                     IsPrivateBrowsing(), aRv);
+                                                     IsPrivateBrowsing(),
+                                                     serviceWorkersTestingInWindow,
+                                                     aRv);
   }
 
   nsRefPtr<CacheStorage> ref = mCacheStorage;
   return ref.forget();
 }
 
 void
 nsGlobalWindow::FireOfflineStatusEventIfChanged()
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -309,20 +309,23 @@ private:
 class CacheScriptLoader;
 
 class CacheCreator final : public PromiseNativeHandler
 {
 public:
   explicit CacheCreator(WorkerPrivate* aWorkerPrivate)
     : mCacheName(aWorkerPrivate->ServiceWorkerCacheName())
     , mPrivateBrowsing(aWorkerPrivate->IsInPrivateBrowsing())
+    , mServiceWorkersTestingInWindow(aWorkerPrivate->ServiceWorkersTestingInWindow())
   {
     MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
     MOZ_ASSERT(aWorkerPrivate->LoadScriptAsPartOfLoadingServiceWorkerScript());
     AssertIsOnMainThread();
+    printf_stderr("### ### CacheCreator has testing %s\n",
+                  (mServiceWorkersTestingInWindow ? "true" : "false"));
   }
 
   void
   AddLoader(CacheScriptLoader* aLoader)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(!mCacheStorage);
     mLoaders.AppendElement(aLoader);
@@ -370,16 +373,17 @@ private:
 
   nsRefPtr<Cache> mCache;
   nsRefPtr<CacheStorage> mCacheStorage;
   nsCOMPtr<nsIGlobalObject> mSandboxGlobalObject;
   nsTArray<nsRefPtr<CacheScriptLoader>> mLoaders;
 
   nsString mCacheName;
   bool mPrivateBrowsing;
+  bool mServiceWorkersTestingInWindow;
 };
 
 class CacheScriptLoader final : public PromiseNativeHandler
                                   , public nsIStreamLoaderObserver
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSISTREAMLOADEROBSERVER
@@ -1213,16 +1217,17 @@ CacheCreator::CreateCacheStorage(nsIPrin
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   ErrorResult error;
   mCacheStorage =
     CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                      mSandboxGlobalObject,
                                      aPrincipal, mPrivateBrowsing,
+                                     mServiceWorkersTestingInWindow,
                                      error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   return NS_OK;
 }
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -878,44 +878,48 @@ class ServiceWorkerRegisterJob final : p
 
   enum
   {
     REGISTER_JOB = 0,
     UPDATE_JOB = 1,
   } mJobType;
 
   bool mCanceled;
+  bool mServiceWorkersTestingInWindow;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // [[Register]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            const nsCString& aScope,
                            const nsCString& aScriptSpec,
+                           bool aServiceWorkersTestingInWindow,
                            ServiceWorkerUpdateFinishCallback* aCallback,
                            nsIPrincipal* aPrincipal)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mScriptSpec(aScriptSpec)
     , mCallback(aCallback)
     , mPrincipal(aPrincipal)
     , mJobType(REGISTER_JOB)
     , mCanceled(false)
+    , mServiceWorkersTestingInWindow(aServiceWorkersTestingInWindow)
   { }
 
   // [[Update]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            ServiceWorkerRegistrationInfo* aRegistration,
                            ServiceWorkerUpdateFinishCallback* aCallback)
     : ServiceWorkerJob(aQueue)
     , mRegistration(aRegistration)
     , mCallback(aCallback)
     , mJobType(UPDATE_JOB)
     , mCanceled(false)
+    , mServiceWorkersTestingInWindow(false)
   { }
 
   bool
   IsRegisterJob() const override
   {
     return true;
   }
 
@@ -1225,16 +1229,17 @@ private:
     // byte-for-byte match with the script resource of newestWorker...
     if (workerInfo && workerInfo->ScriptSpec().Equals(mRegistration->mScriptSpec)) {
       cacheName = workerInfo->CacheName();
     }
 
     nsresult rv =
       serviceWorkerScriptCache::Compare(mRegistration->mPrincipal, cacheName,
                                         NS_ConvertUTF8toUTF16(mRegistration->mScriptSpec),
+                                        mServiceWorkersTestingInWindow,
                                         this);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return Fail(rv);
     }
   }
 
   void
   Succeed()
@@ -1529,18 +1534,33 @@ ServiceWorkerManager::Register(nsIDOMWin
   }
 
   ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(originSuffix, cleanedScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerResolveWindowPromiseOnUpdateCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnUpdateCallback(window, promise);
 
+  bool serviceWorkersTestingInWindow = false;
+  nsCOMPtr<nsPIDOMWindow> pWindow = do_QueryInterface(window);
+  if (pWindow) {
+    if (pWindow->IsOuterWindow()) {
+      serviceWorkersTestingInWindow = pWindow->GetServiceWorkersTestingEnabled();
+    } else {
+      nsCOMPtr<nsPIDOMWindow> outer = pWindow->GetOuterWindow();
+      if (outer) {
+        serviceWorkersTestingInWindow = outer->GetServiceWorkersTestingEnabled();
+      }
+    }
+  }
+
   nsRefPtr<ServiceWorkerRegisterJob> job =
-    new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal);
+    new ServiceWorkerRegisterJob(queue, cleanedScope, spec,
+                                 serviceWorkersTestingInWindow,
+                                 cb, documentPrincipal);
   queue->Append(job);
 
   AssertIsOnMainThread();
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
 }
diff --git a/dom/workers/ServiceWorkerScriptCache.cpp b/dom/workers/ServiceWorkerScriptCache.cpp
--- a/dom/workers/ServiceWorkerScriptCache.cpp
+++ b/dom/workers/ServiceWorkerScriptCache.cpp
@@ -19,17 +19,18 @@ using mozilla::dom::cache::CacheStorage;
 
 BEGIN_WORKERS_NAMESPACE
 
 namespace serviceWorkerScriptCache {
 
 namespace {
 
 already_AddRefed<CacheStorage>
-CreateCacheStorage(nsIPrincipal* aPrincipal, ErrorResult& aRv,
+CreateCacheStorage(nsIPrincipal* aPrincipal, bool aServiceWorkersTestingInWindow,
+                   ErrorResult& aRv,
                    nsIXPConnectJSObjectHolder** aHolder = nullptr)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
 
   nsIXPConnect* xpc = nsContentUtils::XPConnect();
   MOZ_ASSERT(xpc, "This should never be null!");
 
@@ -54,17 +55,19 @@ CreateCacheStorage(nsIPrincipal* aPrinci
 
   // We assume private browsing is not enabled here.  The ScriptLoader
   // explicitly fails for private browsing so there should never be
   // a service worker running in private browsing mode.  Therefore if
   // we are purging scripts or running a comparison algorithm we cannot
   // be in private browing.
   return CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                           sandboxGlobalObject, aPrincipal,
-                                          false /* private browsing */, aRv);
+                                          false /* private browsing */,
+                                          aServiceWorkersTestingInWindow,
+                                          aRv);
 }
 
 class CompareManager;
 
 // This class downloads a URL from the network and then it calls
 // NetworkFinished() in the CompareManager.
 class CompareNetwork final : public nsIStreamLoaderObserver,
                              public nsIRequestObserver
@@ -268,39 +271,41 @@ private:
   bool mAborted;
 };
 
 NS_IMPL_ISUPPORTS(CompareCache, nsIStreamLoaderObserver)
 
 class CompareManager final : public PromiseNativeHandler
 {
 public:
-  explicit CompareManager(CompareCallback* aCallback)
+  CompareManager(CompareCallback* aCallback, bool aServiceWorkersTestingInWindow)
     : mCallback(aCallback)
     , mState(WaitingForOpen)
     , mNetworkFinished(false)
     , mCacheFinished(false)
     , mInCache(false)
+    , mServiceWorkersTestingInWindow(aServiceWorkersTestingInWindow)
   {
     AssertIsOnMainThread();
   }
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL,
              const nsAString& aCacheName)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aPrincipal);
 
     mURL = aURL;
 
     // Always create a CacheStorage since we want to write the network entry to
     // the cache even if there isn't an existing one.
     ErrorResult result;
-    mCacheStorage = CreateCacheStorage(aPrincipal, result, getter_AddRefs(mSandbox));
+    mCacheStorage = CreateCacheStorage(aPrincipal, mServiceWorkersTestingInWindow,
+                                       result, getter_AddRefs(mSandbox));
     if (NS_WARN_IF(result.Failed())) {
       MOZ_ASSERT(!result.IsErrorWithMessage());
       return result.StealNSResult();
     }
 
     mCN = new CompareNetwork(this);
     nsresult rv = mCN->Initialize(aPrincipal, aURL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -588,16 +593,17 @@ private:
   enum {
     WaitingForOpen,
     WaitingForPut
   } mState;
 
   bool mNetworkFinished;
   bool mCacheFinished;
   bool mInCache;
+  bool mServiceWorkersTestingInWindow;
 };
 
 NS_IMETHODIMP
 CompareNetwork::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
   AssertIsOnMainThread();
 
   // If no channel, Abort() has been called.
@@ -895,17 +901,18 @@ PurgeCache(nsIPrincipal* aPrincipal, con
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
 
   if (aCacheName.IsEmpty()) {
     return NS_OK;
   }
 
   ErrorResult rv;
-  nsRefPtr<CacheStorage> cacheStorage = CreateCacheStorage(aPrincipal, rv);
+  nsRefPtr<CacheStorage> cacheStorage =
+    CreateCacheStorage(aPrincipal, false /* sw testing in window */, rv);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   // We use the ServiceWorker scope as key for the cacheStorage.
   nsRefPtr<Promise> promise =
     cacheStorage->Delete(aCacheName, rv);
   if (NS_WARN_IF(rv.Failed())) {
@@ -936,24 +943,26 @@ GenerateCacheName(nsAString& aName)
   id.ToProvidedString(chars);
   aName.AssignASCII(chars, NSID_LENGTH);
 
   return NS_OK;
 }
 
 nsresult
 Compare(nsIPrincipal* aPrincipal, const nsAString& aCacheName,
-        const nsAString& aURL, CompareCallback* aCallback)
+        const nsAString& aURL, bool aServiceWorkersTestingInWindow,
+        CompareCallback* aCallback)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aURL.IsEmpty());
   MOZ_ASSERT(aCallback);
 
-  nsRefPtr<CompareManager> cm = new CompareManager(aCallback);
+  nsRefPtr<CompareManager> cm =
+    new CompareManager(aCallback, aServiceWorkersTestingInWindow);
 
   nsresult rv = cm->Initialize(aPrincipal, aURL, aCacheName);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
diff --git a/dom/workers/ServiceWorkerScriptCache.h b/dom/workers/ServiceWorkerScriptCache.h
--- a/dom/workers/ServiceWorkerScriptCache.h
+++ b/dom/workers/ServiceWorkerScriptCache.h
@@ -39,17 +39,18 @@ public:
                    const nsACString& aMaxScope) = 0;
 
   NS_IMETHOD_(MozExternalRefCountType) AddRef() = 0;
   NS_IMETHOD_(MozExternalRefCountType) Release() = 0;
 };
 
 nsresult
 Compare(nsIPrincipal* aPrincipal, const nsAString& aCacheName,
-        const nsAString& aURL, CompareCallback* aCallback);
+        const nsAString& aURL, bool aServiceWorkersTestingInWindow,
+        CompareCallback* aCallback);
 
 } // serviceWorkerScriptCache namespace
 
 } // workers namespace
 } // dom namespace
 } // mozilla namespace
 
 #endif // mozilla_dom_workers_ServiceWorkerScriptCache_h
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -4960,16 +4960,19 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
 
     loadInfo.mDomain = aParent->Domain();
     loadInfo.mFromWindow = aParent->IsFromWindow();
     loadInfo.mWindowID = aParent->WindowID();
     loadInfo.mIndexedDBAllowed = aParent->IsIndexedDBAllowed();
     loadInfo.mPrivateBrowsing = aParent->IsInPrivateBrowsing();
     loadInfo.mServiceWorkersTestingInWindow =
       aParent->ServiceWorkersTestingInWindow();
+
+    printf_stderr("### ### load info parent SW testing %s\n",
+                  (loadInfo.mServiceWorkersTestingInWindow ? "true" : "false"));
   } else {
     AssertIsOnMainThread();
 
     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
     MOZ_ASSERT(ssm);
 
     bool isChrome = nsContentUtils::IsCallerChrome();
 
@@ -5007,18 +5010,25 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
       // Only use the current inner window, and only use it if the caller can
       // access it.
       nsPIDOMWindow* outerWindow = globalWindow->GetOuterWindow();
       if (outerWindow) {
         loadInfo.mWindow = outerWindow->GetCurrentInnerWindow();
         // TODO: fix this for SharedWorkers with multiple documents (bug 1177935)
         loadInfo.mServiceWorkersTestingInWindow =
           outerWindow->GetServiceWorkersTestingEnabled();
+      } else {
+        // TODO: fix this for SharedWorkers with multiple documents (bug 1177935)
+        loadInfo.mServiceWorkersTestingInWindow =
+          globalWindow->GetServiceWorkersTestingEnabled();
       }
 
+      printf_stderr("### ### load info SW testing %s\n",
+                    (loadInfo.mServiceWorkersTestingInWindow ? "true" : "false"));
+
       if (!loadInfo.mWindow ||
           (globalWindow != loadInfo.mWindow &&
             !nsContentUtils::CanCallerAccess(loadInfo.mWindow))) {
         return NS_ERROR_DOM_SECURITY_ERR;
       }
 
       nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(loadInfo.mWindow);
       MOZ_ASSERT(sgo);
