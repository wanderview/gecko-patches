# HG changeset patch
# Parent 642d6d76b20650386f84fac40de2f64468bd762a
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -4655,16 +4655,29 @@ WorkerPrivate::RunBeforeNextEvent(nsIRun
       return false;
     }
   }
 
   return true;
 }
 
 void
+WorkerPrivate::MaybeAddTabChild(nsILoadGroup* aLoadGroup)
+{
+  // TODO
+}
+
+already_AddRefed<nsITabChild>
+WorkerPrivate::GetTabChild()
+{
+  // TODO
+  return nullptr;
+}
+
+void
 WorkerPrivate::InitializeGCTimers()
 {
   AssertIsOnWorkerThread();
 
   // We need a timer for GC. The basic plan is to run a non-shrinking GC
   // periodically (PERIODIC_GC_TIMER_DELAY_SEC) while the worker is running.
   // Once the worker goes idle we set a short (IDLE_GC_TIMER_DELAY_SEC) timer to
   // run a shrinking GC. If the worker receives more messages then the short
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -31,16 +31,17 @@
 #include "WorkerFeature.h"
 
 class JSAutoStructuredCloneBuffer;
 class nsIChannel;
 class nsIDocument;
 class nsIEventTarget;
 class nsIPrincipal;
 class nsIScriptContext;
+class nsITabChild;
 class nsIThread;
 class nsIThreadInternal;
 class nsITimer;
 class nsIURI;
 
 namespace JS {
 struct RuntimeStats;
 }
@@ -1211,16 +1212,22 @@ public:
     return mWorkerScriptExecutedSuccessfully;
   }
 
   // Just like nsIAppShell::RunBeforeNextEvent. May only be called on the worker
   // thread.
   bool
   RunBeforeNextEvent(nsIRunnable* aRunnable);
 
+  void
+  MaybeAddTabChild(nsILoadGroup* aLoadGroup);
+
+  already_AddRefed<nsITabChild>
+  GetTabChild();
+
 private:
   WorkerPrivate(JSContext* aCx, WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsACString& aSharedWorkerName,
                 LoadInfo& aLoadInfo);
 
   void
   ClearMainEventQueue(WorkerRanOrNot aRanOrNot);
