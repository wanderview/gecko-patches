# HG changeset patch
# Parent 958c83cacdc29756632e755c60591f9b29c8a1b2
# User Ben Kelly <ben@wanderview.com>
Work in progress unifying operation types in a single IPC method.


diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -481,16 +481,24 @@ CacheStorage::RecvKeysResponse(RequestId
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   promise->MaybeResolve(aKeys);
 }
 
+void
+CacheStorage::RecvSendOpResponse(CacheStorageOp aOp, RequestId aRequestId,
+                                 nsresult aRv,
+                                 const CacheStorageOpResponseArgs& aArgs)
+{
+  // TODO
+}
+
 nsIGlobalObject*
 CacheStorage::GetGlobalObject() const
 {
   return mGlobal;
 }
 
 const nsACString&
 CacheStorage::Origin() const
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -34,16 +34,17 @@ class Promise;
 
 namespace workers {
   class WorkerPrivate;
 }
 
 namespace cache {
 
 class CacheStorageChild;
+class CacheStorageOpResponseArgs;
 class PCacheChild;
 class PCacheRequest;
 class PCacheResponseOrVoid;
 
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public TypeUtils
 {
@@ -82,16 +83,18 @@ public:
   void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                          const PCacheResponseOrVoid& aResponse);
   void RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
                         PCacheChild* aActor);
   void RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                         const nsTArray<nsString>& aKeys);
+  void RecvSendOpResponse(CacheStorageOp aOp, RequestId aRequestId, nsresult aRv,
+                          const CacheStorageOpResponseArgs& aArgs);
 
   // TypeUtils method
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
   virtual const nsACString& Origin() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -96,11 +96,23 @@ CacheStorageChild::RecvKeysResponse(cons
                                     const nsTArray<nsString>& aKeys)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   MOZ_ASSERT(mListener);
   mListener->RecvKeysResponse(aRequestId, aRv, aKeys);
   return true;
 }
 
+bool
+CacheStorageChild::RecvSendOpResponse(const CacheStorageOp& aOp,
+                                      const RequestId& aRequestId,
+                                      const nsresult& aRv,
+                                      const CacheStorageOpResponseArgs& aArgs)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
+  MOZ_ASSERT(mListener);
+  mListener->RecvSendOpResponse(aOp, aRequestId, aRv, aArgs);
+  return true;
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -42,16 +42,21 @@ public:
                                 PCacheChild* aActor) MOZ_OVERRIDE;
   virtual bool RecvDeleteResponse(const cache::RequestId& aRequestId,
                                   const nsresult& aRv,
                                   const bool& aResult) MOZ_OVERRIDE;
   virtual bool RecvKeysResponse(const cache::RequestId& aRequestId,
                                 const nsresult& aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
+  virtual bool
+  RecvSendOpResponse(const CacheStorageOp& aOp, const RequestId& aRequestId,
+                     const nsresult& aRv,
+                     const CacheStorageOpResponseArgs& aArgs) MOZ_OVERRIDE;
+
 private:
   // Use a weak ref so actor does not hold DOM object alive past content use.
   // The CacheStorage object must call ClearListener() to null this before its
   // destroyed.
   CacheStorage* MOZ_NON_OWNING_REF mListener;
 
   NS_DECL_OWNINGTHREAD
 };
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -197,16 +197,25 @@ CacheStorageParent::RecvKeys(const Reque
     return true;
   }
 
   manager->StorageKeys(this, aRequestId, mNamespace);
 
   return true;
 }
 
+bool
+CacheStorageParent::RecvSendOp(const CacheStorageOp& aOp,
+                               const RequestId& aRequestId,
+                               const CacheStorageOpArgs& aArgs)
+{
+  // TODO
+  return true;
+}
+
 void
 CacheStorageParent::OnPrincipalVerified(nsresult aRv, ManagerId* aManagerId)
 {
   if (NS_WARN_IF(NS_FAILED(aRv))) {
     FailPendingRequests(aRv);
     unused << Send__delete__(this);
     return;
   }
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -39,16 +39,19 @@ public:
   virtual bool RecvHas(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvOpen(const RequestId& aRequestId,
                         const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvDelete(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
+  virtual bool RecvSendOp(const CacheStorageOp& aOp, const RequestId& aRequestId,
+                          const CacheStorageOpArgs& aArgs) MOZ_OVERRIDE;
+
   // PrincipalVerifier::Listener methods
   virtual void OnPrincipalVerified(nsresult aRv,
                                    ManagerId* aManagerId) MOZ_OVERRIDE;
 
   // Manager::Listener methods
   virtual void OnStorageMatch(RequestId aRequestId, nsresult aRv,
                               const SavedResponse* aResponse,
                               StreamList* aStreamList) MOZ_OVERRIDE;
diff --git a/dom/cache/IPCUtils.h b/dom/cache/IPCUtils.h
--- a/dom/cache/IPCUtils.h
+++ b/dom/cache/IPCUtils.h
@@ -12,11 +12,25 @@
 
 namespace IPC {
   template<>
   struct ParamTraits<mozilla::dom::cache::Namespace> :
     public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
                                     mozilla::dom::cache::DEFAULT_NAMESPACE,
                                     mozilla::dom::cache::NUMBER_OF_NAMESPACES>
   {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::cache::CacheOp> :
+    public ContiguousEnumSerializer<mozilla::dom::cache::CacheOp,
+                                    mozilla::dom::cache::CacheMatchOp,
+                                    mozilla::dom::cache::NumberOfCacheOps>
+  {};
+
+  template<>
+  struct ParamTraits<mozilla::dom::cache::CacheStorageOp> :
+    public ContiguousEnumSerializer<mozilla::dom::cache::CacheStorageOp,
+                                    mozilla::dom::cache::CacheStorageMatchOp,
+                                    mozilla::dom::cache::NumberOfCacheStorageOps>
+  {};
 }
 
 #endif // mozilla_dom_cache_IPCUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -231,18 +231,16 @@ private:
     if (!sFactory) {
       // We cannot use ClearOnShutdown() here because we're not on the main
       // thread.  Instead, we delete sFactory in Factory::Remove() after the
       // last manager is removed.  ShutdownObserver ensures this happens
       // before shutdown.
       sFactory = new Factory();
     }
 
-    MOZ_ASSERT(sFactory);
-
     // Never return sFactory to code outside Factory.  We need to delete it
     // out from under ourselves just before we return from Remove().  This
     // would be (even more) dangerous if other code had a pointer to the
     // factory itself.
   }
 
   // Singleton created on demand and deleted when last Manager is cleared
   // in Remove().
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -5,16 +5,18 @@
 include protocol PBackground;
 include protocol PCache;
 include PCacheTypes;
 include protocol PFileDescriptorSet;
 
 include protocol PBlob; // FIXME: bug 792908
 include protocol PCacheStreamControl;
 
+using mozilla::dom::cache::CacheOp from "mozilla/dom/cache/IPCUtils.h";
+using mozilla::dom::cache::CacheStorageOp from "mozilla/dom/cache/IPCUtils.h";
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
 {
@@ -23,23 +25,28 @@ protocol PCacheStorage
 parent:
   Match(RequestId aRequestId, PCacheRequest aRequest,
         PCacheQueryParams aParams);
   Has(RequestId aRequestId, nsString aKey);
   Open(RequestId aRequestId, nsString aKey);
   Delete(RequestId aRequestId, nsString aKey);
   Keys(RequestId aRequestId);
 
+  SendOp(CacheStorageOp aOp, RequestId aRequestId, CacheStorageOpArgs aArgs);
+
 child:
   MatchResponse(RequestId aRequestId, nsresult aRv,
                 PCacheResponseOrVoid aResponseOrVoid);
   HasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   OpenResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
 
+  SendOpResponse(CacheStorageOp aOp, RequestId aRequestId, nsresult aRv,
+                 CacheStorageOpResponseArgs aArgs);
+
 both:
   __delete__();
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,12 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+include protocol PCache;
 include protocol PCacheStreamControl;
 include PHeaders;
 include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
@@ -73,17 +74,53 @@ struct PCacheResponse
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
+struct CacheRequestAndParams
+{
+  PCacheRequest request;
+  PCacheQueryParams params;
+};
+
+struct CacheRequestOrVoidAndParams
+{
+  PCacheRequestOrVoid requestOrVoid;
+  PCacheQueryParams params;
+};
+
 struct CacheRequestResponse
 {
   PCacheRequest request;
   PCacheResponse response;
 };
 
+union CacheOpArgs
+{
+  CacheRequestAndParams;
+  CacheRequestOrVoidAndParams;
+  CacheRequestResponse;
+  PCacheRequest[];
+};
+
+union CacheStorageOpArgs
+{
+  void_t;
+  CacheRequestAndParams;
+  nsString;
+};
+
+union CacheStorageOpResponseArgs
+{
+  void_t;
+  PCacheResponse;
+  bool;
+  PCache;
+  nsString[];
+};
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -18,16 +18,37 @@ namespace cache {
 
 enum Namespace
 {
   DEFAULT_NAMESPACE,
   CHROME_ONLY_NAMESPACE,
   NUMBER_OF_NAMESPACES
 };
 
+enum CacheOp
+{
+  CacheMatchOp,
+  CacheMatchAllOp,
+  CacheAddAllOp,
+  CachePutOp,
+  CacheDeleteOp,
+  CacheKeysOp,
+  NumberOfCacheOps
+};
+
+enum CacheStorageOp
+{
+  CacheStorageMatchOp,
+  CacheStorageHasOp,
+  CacheStorageOpenOp,
+  CacheStorageDeleteOp,
+  CacheStorageKeysOp,
+  NumberOfCacheStorageOps
+};
+
 typedef uintptr_t RequestId;
 static const RequestId INVALID_REQUEST_ID = 0;
 
 typedef int32_t CacheId;
 
 struct QuotaInfo
 {
   QuotaInfo() : mIsApp(false), mHasUnlimStoragePerm(false) { }
