# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  300badbed77b958d5e280bff5e77e78fd0ac2d43

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -74,16 +74,17 @@ TimerNameCallback(nsITimer* aTimer, void
   snprintf(aBuf, aLen, "[content] %s:%u:%u", filename, lineNum, column);
 }
 
 } // anonymous namespace
 
 nsresult
 Timeout::InitTimer(nsIEventTarget* aTarget, uint32_t aDelay)
 {
+  aTarget = nullptr;
   // If the given target does not match the timer's current target
   // then we need to override it before the Init.  Note that GetTarget()
   // will return the current thread after setting the target to nullptr.
   // So we need to special case the nullptr target comparison.
   nsCOMPtr<nsIEventTarget> currentTarget;
   MOZ_ALWAYS_SUCCEEDS(mTimer->GetTarget(getter_AddRefs(currentTarget)));
   if ((aTarget && currentTarget != aTarget) ||
       (!aTarget && currentTarget != NS_GetCurrentThread())) {
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13119,17 +13119,17 @@ nsGlobalWindow::RunTimeout(Timeout* aTim
       // up by their own nsITimer runnables when they execute.
       //
       // For chrome windows, however, we do coalesce all timers and
       // do not yield the main thread.  This is partly because we
       // trust chrome windows not to misbehave and partly because a
       // number of browser chrome tests have races that depend on this
       // coalescing.
       if (timeout == aTimeout && !IsChromeWindow()) {
-        break;
+        //break;
       }
     }
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_timeout) {
