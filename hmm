# HG changeset patch
# Parent 9f2cb23e6b584c08fa49b80cc94621700a2e28ae
# User Ben Kelly <ben@wanderview.com>

diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -46,23 +46,23 @@ CacheStreamControlChild::CacheStreamCont
 }
 
 CacheStreamControlChild::~CacheStreamControlChild()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   MOZ_COUNT_DTOR(cache::CacheStreamControlChild);
 }
 
-already_AddRefed<StreamControl>
-CacheStreamControlChild::CreateStreamControl()
+void
+CacheStreamControlChild::AddReadStream(InnerReadStream* aReadStream)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  nsRefPtr<StreamControl> ref = new StreamControl(this);
-  mControlList.AppendElement(ref);
-  return ref.forget();
+  MOZ_ASSERT(aReadStream);
+  MOZ_ASSERT(!mReadStreamList.Contains(aReadStream));
+  mReadStreamList.AppendElement(aReadStream);
 }
 
 void
 CacheStreamControlChild::SerializeControl(PCacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   aReadStreamOut->controlParent() = nullptr;
   aReadStreamOut->controlChild() = this;
@@ -103,23 +103,39 @@ CacheStreamControlChild::DeserializeFds(
 
   fdSetActor->ForgetFileDescriptors(aFdsOut);
   MOZ_ASSERT(!aFdsOut.IsEmpty());
 
   unused << fdSetActor->Send__delete__(fdSetActor);
 }
 
 void
+CacheStreamControlChild::NoteClosed(InnerReadStream* aReadStream, const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  // TODO
+  NoteClosed(aId);
+}
+
+void
 CacheStreamControlChild::NoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   unused << SendNoteClosed(aId);
 }
 
 void
+CacheStreamControlChild::ForgetReadStream(InnerReadStream* aReadStream)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  // TODO
+  // TODO: do we need nsTObserverArray?
+}
+
+void
 CacheStreamControlChild::StartDestroy()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   // This can get called twice under some circumstances.  For example, if the
   // actor is added to a Feature that has already been notified and the Cache
   // actor has no mListener.
   if (mDestroyStarted) {
     return;
@@ -132,48 +148,48 @@ CacheStreamControlChild::StartDestroy()
 }
 
 void
 CacheStreamControlChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   // Note, we cannot trigger IPC traffic here.  So use
   // CloseStreamWithoutReporting().
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    mControlList[i]->CloseStreamWithoutReporting();
-    mControlList[i]->RemoveActor(this);
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    mReadStreamList[i]->CloseStreamWithoutReporting();
+    mReadStreamList[i]->ActorClosed();
   }
-  mControlList.Clear();
+  mReadStreamList.Clear();
 
   RemoveFeature();
 }
 
 bool
 CacheStreamControlChild::RecvClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
   DebugOnly<uint32_t> closedCount = 0;
 
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    if (mControlList[i]->MatchId(aId)) {
-      mControlList[i]->CloseStream();
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    if (mReadStreamList[i]->MatchId(aId)) {
+      mReadStreamList[i]->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 
   return true;
 }
 
 bool
 CacheStreamControlChild::RecvCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    mControlList[i]->CloseStream();
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    mReadStreamList[i]->CloseStream();
   }
   return true;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -14,51 +14,57 @@
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ReadStream;
 
 class CacheStreamControlChild MOZ_FINAL : public PCacheStreamControlChild
-                                        , public StreamControl::Actor
+                                        , public AbstractStreamControl
                                         , public ActorChild
 {
 public:
   CacheStreamControlChild();
   ~CacheStreamControlChild();
 
-  already_AddRefed<StreamControl>
-  CreateStreamControl();
+  // AbstractStreamControl methods
+  virtual void
+  AddReadStream(InnerReadStream* aReadStream) MOZ_OVERRIDE;
 
-  // StreamControl::Actor methods
   virtual void
   SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE;
 
   virtual void
   SerializeFds(PCacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& aFds) MOZ_OVERRIDE;
 
   virtual void
   DeserializeFds(const PCacheReadStream& aReadStream,
                  nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) MOZ_OVERRIDE;
 
   virtual void
-  NoteClosed(const nsID& aId) MOZ_OVERRIDE;
+  NoteClosed(InnerReadStream* aReadStream, const nsID& aId) MOZ_OVERRIDE;
+
+  virtual void
+  ForgetReadStream(InnerReadStream* aReadStream) MOZ_OVERRIDE;
 
   // ActorChild methods
   virtual void StartDestroy() MOZ_OVERRIDE;
 
 private:
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
-  nsTArray<nsRefPtr<StreamControl>> mControlList;
+  void
+  NoteClosed(const nsID& aId);
+
+  nsTArray<nsRefPtr<InnerReadStream>> mReadStreamList;
 
   bool mDestroyStarted;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -39,23 +39,23 @@ CacheStreamControlParent::CacheStreamCon
 
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(!mStreamList);
   MOZ_COUNT_DTOR(cache::CacheStreamControlParent);
 }
 
-already_AddRefed<StreamControl>
-CacheStreamControlParent::CreateStreamControl()
+void
+CacheStreamControlParent::AddReadStream(InnerReadStream* aReadStream)
 {
-  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
-  nsRefPtr<StreamControl> ref = new StreamControl(this);
-  mControlList.AppendElement(ref);
-  return ref.forget();
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
+  MOZ_ASSERT(aReadStream);
+  MOZ_ASSERT(!mReadStreamList.Contains(aReadStream));
+  mReadStreamList.AppendElement(aReadStream);
 }
 
 void
 CacheStreamControlParent::SerializeControl(PCacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   aReadStreamOut->controlChild() = nullptr;
   aReadStreamOut->controlParent() = this;
@@ -99,31 +99,47 @@ CacheStreamControlParent::DeserializeFds
 
   if (!fdSetActor->Send__delete__(fdSetActor)) {
     // child process is gone, warn and allow actor to clean up normally
     NS_WARNING("Cache failed to delete fd set actor.");
   }
 }
 
 void
+CacheStreamControlParent::NoteClosed(InnerReadStream* aReadStream, const nsID& aId)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
+  // TODO
+  NoteClosed(aId);
+}
+
+void
 CacheStreamControlParent::NoteClosed(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(mStreamList);
   mStreamList->NoteClosed(aId);
 }
 
 void
+CacheStreamControlParent::ForgetReadStream(InnerReadStream* aReadStream)
+{
+  NS_ASSERT_OWNINGTHREAD(CacheStreamControlChild);
+  // TODO
+  // TODO: do we need nsTObserverArray?
+}
+
+void
 CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   MOZ_ASSERT(mStreamList);
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    mControlList[i]->CloseStreamWithoutReporting();
-    mControlList[i]->RemoveActor(this);
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    mReadStreamList[i]->CloseStreamWithoutReporting();
+    mReadStreamList[i]->ActorClosed();
   }
   mStreamList->RemoveStreamControl(this);
   mStreamList->NoteClosedAll();
   mStreamList = nullptr;
 }
 
 bool
 CacheStreamControlParent::RecvNoteClosed(const nsID& aId)
@@ -168,30 +184,30 @@ CacheStreamControlParent::Shutdown()
 }
 
 void
 CacheStreamControlParent::NotifyClose(const nsID& aId)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
   DebugOnly<uint32_t> closedCount = 0;
 
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    if (mControlList[i]->MatchId(aId)) {
-      mControlList[i]->CloseStream();
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    if (mReadStreamList[i]->MatchId(aId)) {
+      mReadStreamList[i]->CloseStream();
       closedCount += 1;
     }
   }
 
   MOZ_ASSERT(closedCount > 0);
 }
 
 void
 CacheStreamControlParent::NotifyCloseAll()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStreamControlParent);
-  for (uint32_t i = 0; i < mControlList.Length(); ++i) {
-    mControlList[i]->CloseStream();
+  for (uint32_t i = 0; i < mReadStreamList.Length(); ++i) {
+    mReadStreamList[i]->CloseStream();
   }
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -14,59 +14,65 @@
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class ReadStream;
 class StreamList;
 
 class CacheStreamControlParent : public PCacheStreamControlParent
-                               , public StreamControl::Actor
+                               , public AbstractStreamControl
 {
 public:
   CacheStreamControlParent();
   ~CacheStreamControlParent();
 
-  already_AddRefed<StreamControl>
-  CreateStreamControl();
-
   void SetStreamList(StreamList* aStreamList);
   void Close(const nsID& aId);
   void CloseAll();
   void Shutdown();
 
-  // StreamControl::Actor methods
+  // AbstractStreamControl methods
+  virtual void
+  AddReadStream(InnerReadStream* aReadStream) MOZ_OVERRIDE;
+
   virtual void
   SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE;
 
   virtual void
   SerializeFds(PCacheReadStream* aReadStreamOut,
                const nsTArray<mozilla::ipc::FileDescriptor>& aFds) MOZ_OVERRIDE;
 
   virtual void
   DeserializeFds(const PCacheReadStream& aReadStream,
                  nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) MOZ_OVERRIDE;
 
   virtual void
-  NoteClosed(const nsID& aId) MOZ_OVERRIDE;
+  NoteClosed(InnerReadStream* aReadStream, const nsID& aId) MOZ_OVERRIDE;
+
+  virtual void
+  ForgetReadStream(InnerReadStream* aReadStream) MOZ_OVERRIDE;
 
 private:
   // PCacheStreamControlParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
 
   void NotifyClose(const nsID& aId);
   void NotifyCloseAll();
 
+  void
+  NoteClosed(const nsID& aId);
+
   // Cycle with StreamList via a weak-ref to us.  Cleanup occurs when the actor
   // is deleted by the PBackground manager.  ActorDestroy() then calls
   // StreamList::RemoveStreamControl() to clear the weak ref.
   nsRefPtr<StreamList> mStreamList;
 
-  nsTArray<nsRefPtr<StreamControl>> mControlList;
+  nsTArray<nsRefPtr<InnerReadStream>> mReadStreamList;
 
   NS_DECL_OWNINGTHREAD
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -105,23 +105,25 @@ ReadStream::Create(const PCacheReadStrea
 {
   // The parameter may or may not be for a Cache created stream.  The way we
   // tell is by looking at the stream control actor.  If the actor exists,
   // then we know the Cache created it.
   if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
     return nullptr;
   }
 
-  nsRefPtr<StreamControl> control;
+  // Control is guaranteed to survive this method as ActorDestroy() cannot
+  // run on this thread until we complete.
+  AbstractStreamControl* control;
   if (aReadStream.controlChild()) {
     auto actor = static_cast<CacheStreamControlChild*>(aReadStream.controlChild());
-    control = actor->CreateStreamControl();
+    control = actor;
   } else {
     auto actor = static_cast<CacheStreamControlParent*>(aReadStream.controlParent());
-    control = actor->CreateStreamControl();
+    control = actor;
   }
   MOZ_ASSERT(control);
 
   nsAutoTArray<FileDescriptor, 4> fds;
   control->DeserializeFds(aReadStream, fds);
 
   nsCOMPtr<nsIInputStream> stream =
     DeserializeInputStream(aReadStream.params(), fds);
@@ -139,18 +141,17 @@ ReadStream::Create(const PCacheReadStrea
 
 // static
 already_AddRefed<ReadStream>
 ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
                    nsIInputStream* aStream)
 {
   MOZ_ASSERT(aControl);
   auto actor = static_cast<CacheStreamControlParent*>(aControl);
-  nsRefPtr<StreamControl> control = actor->CreateStreamControl();
-  nsRefPtr<ReadStream> ref = new ReadStream(control, aId, aStream);
+  nsRefPtr<ReadStream> ref = new ReadStream(actor, aId, aStream);
   return ref.forget();
 }
 
 void
 ReadStream::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
   MOZ_ASSERT(aReadStreamOut);
@@ -160,16 +161,17 @@ ReadStream::Serialize(PCacheReadStreamOr
 }
 
 void
 ReadStream::Serialize(PCacheReadStream* aReadStreamOut)
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
   MOZ_ASSERT(aReadStreamOut);
   MOZ_ASSERT(!mClosed);
+  MOZ_ASSERT(mControl);
 
   aReadStreamOut->id() = mId;
   mControl->SerializeControl(aReadStreamOut);
 
   nsAutoTArray<FileDescriptor, 4> fds;
   SerializeInputStream(mStream, aReadStreamOut->params(), fds);
 
   mControl->SerializeFds(aReadStreamOut, fds);
@@ -201,27 +203,28 @@ ReadStream::MatchId(const nsID& aId) con
 void
 ReadStream::ActorClosed()
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
   mClosed = true;
   mControl = nullptr;
 }
 
-ReadStream::ReadStream(StreamControl* aControl, const nsID& aId,
+ReadStream::ReadStream(AbstractStreamControl* aControl, const nsID& aId,
                        nsIInputStream* aStream)
   : mControl(aControl)
   , mId(aId)
   , mStream(aStream)
   , mSnappyStream(new SnappyUncompressInputStream(aStream))
   , mOwningThread(NS_GetCurrentThread())
   , mClosed(false)
 {
   MOZ_ASSERT(mStream);
-  mControl->SetReadStream(this);
+  MOZ_ASSERT(mControl);
+  mControl->AddReadStream(this);
 }
 
 ReadStream::~ReadStream()
 {
   // Any thread
   MOZ_ASSERT(mClosed);
   MOZ_ASSERT(!mControl);
 }
@@ -265,34 +268,34 @@ ReadStream::NoteClosedOnOwningThread()
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
 
   if (mClosed) {
     return;
   }
 
   mClosed = true;
-  nsRefPtr<StreamControl> control;
-  control.swap(mControl);
-  control->NoteClosed(mId);
+  MOZ_ASSERT(mControl);
+  mControl->NoteClosed(this, mId);
+  mControl = nullptr;
 }
 
 void
 ReadStream::ForgetOnOwningThread()
 {
   NS_ASSERT_OWNINGTHREAD(ReadStream);
 
   if (mClosed) {
     return;
   }
 
   mClosed = true;
-  nsRefPtr<StreamControl> control;
-  control.swap(mControl);
-  control->ForgetReadStream();
+  MOZ_ASSERT(mControl);
+  mControl->ForgetReadStream(this);
+  mControl = nullptr;
 }
 
 NS_IMETHODIMP
 ReadStream::Close()
 {
   nsresult rv = mStream->Close();
   NoteClosed();
   return rv;
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -19,71 +19,98 @@ class nsIThread;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheReadStream;
 class PCacheReadStreamOrVoid;
 class PCacheStreamControlParent;
-class StreamControl;
+class AbstractStreamControl;
 
 // IID for the dom::cache::ReadStream interface
 #define NS_DOM_CACHE_READSTREAM_IID \
 {0x8e5da7c9, 0x0940, 0x4f1d, \
   {0x97, 0x25, 0x5c, 0x59, 0x38, 0xdd, 0xb9, 0x9f}}
 
+class InnerReadStream
+{
+public:
+  virtual void
+  CloseStream() = 0;
+
+  virtual void
+  CloseStreamWithoutReporting() = 0;
+
+  virtual bool
+  MatchId(const nsID& aId) const = 0;
+
+  virtual void
+  ActorClosed() = 0;
+
+  NS_IMETHOD_(MozExternalRefCountType)
+  AddRef(void) = 0;
+
+  NS_IMETHOD_(MozExternalRefCountType)
+  Release(void) = 0;
+};
+
+
 // Custom stream class for Request and Response bodies being read from
 // a Cache.  The main purpose of this class is to report back to the
 // Cache's Manager when the stream is closed.  This allows the Cache to
 // accurately determine when the underlying body file can be deleted,
 // etc.
 //
 // The ReadStream class also provides us with a convenient QI'able
 // interface that we can use to pass additional meta-data with the
 // stream channel.  For example, Cache.put() can detect that the content
 // script is passing a Cache-originated-stream back into the Cache
 // again.  This enables certain optimizations.
 class ReadStream MOZ_FINAL : public nsIInputStream
+                           , public InnerReadStream
 {
+  using nsISupports::AddRef;
+  using nsISupports::Release;
 public:
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
 
   static already_AddRefed<ReadStream>
   Create(const PCacheReadStream& aReadStream);
 
   static already_AddRefed<ReadStream>
   Create(PCacheStreamControlParent* aControl, const nsID& aId,
          nsIInputStream* aStream);
 
   void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
   void Serialize(PCacheReadStream* aReadStreamOut);
 
   // methods called from the child and parent CacheStreamControl actors
-  void CloseStream();
-  void CloseStreamWithoutReporting();
-  bool MatchId(const nsID& aId) const;
-  void ActorClosed();
+  // InnerReadStream methods
+  virtual void CloseStream() MOZ_OVERRIDE;
+  virtual void CloseStreamWithoutReporting() MOZ_OVERRIDE;
+  virtual bool MatchId(const nsID& aId) const MOZ_OVERRIDE;
+  virtual void ActorClosed() MOZ_OVERRIDE;
 
 private:
   class NoteClosedRunnable;
   class ForgetRunnable;
 
-  ReadStream(StreamControl* aStreamControl, const nsID& aId,
+  ReadStream(AbstractStreamControl* aControl, const nsID& aId,
              nsIInputStream* aStream);
   ~ReadStream();
 
   void NoteClosed();
   void Forget();
 
   void NoteClosedOnOwningThread();
   void ForgetOnOwningThread();
 
-  nsRefPtr<StreamControl> mControl;
+  AbstractStreamControl* mControl;
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
   nsCOMPtr<nsIInputStream> mSnappyStream;
   nsCOMPtr<nsIThread> mOwningThread;
   Atomic<bool> mClosed;
 
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_READSTREAM_IID);
diff --git a/dom/cache/StreamControl.cpp b/dom/cache/StreamControl.cpp
--- a/dom/cache/StreamControl.cpp
+++ b/dom/cache/StreamControl.cpp
@@ -10,16 +10,17 @@
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/FileDescriptor.h"
 #include "nsID.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+/*
 using mozilla::ipc::FileDescriptor;
 
 StreamControl::StreamControl(Actor* aActor)
   : mActor(aActor)
 {
   MOZ_ASSERT(mActor);
 }
 
@@ -115,12 +116,13 @@ StreamControl::ForgetReadStream()
 }
 
 StreamControl::~StreamControl()
 {
   NS_ASSERT_OWNINGTHREAD(StreamControl);
   MOZ_ASSERT(!mActor);
   MOZ_ASSERT(!mReadStream);
 }
+*/
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/StreamControl.h b/dom/cache/StreamControl.h
--- a/dom/cache/StreamControl.h
+++ b/dom/cache/StreamControl.h
@@ -15,19 +15,45 @@ struct nsID;
 
 namespace mozilla {
 namespace ipc {
  class FileDescriptor;
 }
 namespace dom {
 namespace cache {
 
+class InnerReadStream;
 class PCacheReadStream;
 class ReadStream;
 
+class AbstractStreamControl
+{
+public:
+  virtual void
+  AddReadStream(InnerReadStream* aReadStream) = 0;
+
+  virtual void
+  SerializeControl(PCacheReadStream* aReadStreamOut) = 0;
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& aFds) = 0;
+
+  virtual void
+  DeserializeFds(const PCacheReadStream& aReadStream,
+                 nsTArray<mozilla::ipc::FileDescriptor>& aFdsOut) = 0;
+
+  virtual void
+  NoteClosed(InnerReadStream* aReadStream, const nsID& aId) = 0;
+
+  virtual void
+  ForgetReadStream(InnerReadStream* aReadStream) = 0;
+};
+
+/*
 // Utility class for connecting ReadStream objects to their backing stream
 // control IPC actors.  The interface between those two objects is quite
 // difficult for a number of reasons:
 //
 //  1) IPC actors are single thread
 //  2) IPC actors are not ref-counted and may be destroyed at any time (on
 //     their thread)
 //  3) ReadStream must be available on multiple threads so it can be read
@@ -135,14 +161,15 @@ private:
   Actor* mActor;
 
   // Ref-cycle with ReadStream.  Neither object will be destroyed until
   // this ref is dropped.
   nsRefPtr<ReadStream> mReadStream;
 
   NS_INLINE_DECL_REFCOUNTING(cache::StreamControl)
 };
+*/
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_StreamControl_h
