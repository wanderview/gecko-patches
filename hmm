# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  55f2c870c41c07bede4ae6ee73936f2cfbbaea92

diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -2,74 +2,101 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerRegistration.h"
 
 #include "mozilla/dom/Promise.h"
+#include "mozilla/dom/ServiceWorker.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsISupportsPrimitives.h"
 #include "nsPIDOMWindow.h"
 #include "ServiceWorkerRegistrationImpl.h"
 
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorkerRegistration)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
-ServiceWorkerRegistration::ServiceWorkerRegistration(nsPIDOMWindowInner* aWindow,
-                                                     const ServiceWorkerRegistrationDescriptor& aDescriptor)
-  : DOMEventTargetHelper(aWindow)
+ServiceWorkerRegistration::ServiceWorkerRegistration(nsIGlobalObject* aGlobal,
+                                                     const ServiceWorkerRegistrationDescriptor& aDescriptor,
+                                                     ServiceWorkerRegistration::Inner* aInner)
+  : DOMEventTargetHelper(aGlobal)
   , mDescriptor(aDescriptor)
+  , mInner(aInner)
 {
+  MOZ_DIAGNOSTIC_ASSERT(mInner);
+  mInner->AddServiceWorkerRegistration(this);
+}
+
+ServiceWorkerRegistration::~ServiceWorkerRegistration()
+{
+  if (mInner) {
+    mInner->RemoveServiceWorkerRegistration(this);
+  }
 }
 
 JSObject*
 ServiceWorkerRegistration::WrapObject(JSContext* aCx,
                                       JS::Handle<JSObject*> aGivenProto)
 {
   return ServiceWorkerRegistrationBinding::Wrap(aCx, this, aGivenProto);
 }
 
 /* static */ already_AddRefed<ServiceWorkerRegistration>
 ServiceWorkerRegistration::CreateForMainThread(nsPIDOMWindowInner* aWindow,
                                                const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
   MOZ_ASSERT(aWindow);
   MOZ_ASSERT(NS_IsMainThread());
 
+  nsCOMPtr<nsIGlobalObject> global(do_QueryInterface(aWindow));
+
+  RefPtr<Inner> inner =
+    new ServiceWorkerRegistrationMainThread(aWindow, aDescriptor);
+
   RefPtr<ServiceWorkerRegistration> registration =
-    new ServiceWorkerRegistrationMainThread(aWindow, aDescriptor);
+    new ServiceWorkerRegistration(global, aDescriptor, inner);
 
   return registration.forget();
 }
 
 /* static */ already_AddRefed<ServiceWorkerRegistration>
 ServiceWorkerRegistration::CreateForWorker(WorkerPrivate* aWorkerPrivate,
                                            const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
-  NS_ConvertUTF8toUTF16 scope(aDescriptor.Scope());
+  RefPtr<Inner> inner =
+    new ServiceWorkerRegistrationWorkerThread(aWorkerPrivate, aDescriptor);
 
   RefPtr<ServiceWorkerRegistration> registration =
-    new ServiceWorkerRegistrationWorkerThread(aWorkerPrivate, aDescriptor);
+    new ServiceWorkerRegistration(aWorkerPrivate->GlobalScope(), aDescriptor,
+                                  inner);
 
   return registration.forget();
 }
 
+void
+ServiceWorkerRegistration::DisconnectFromOwner()
+{
+  mInner->RemoveServiceWorkerRegistration(this);
+  mInner = nullptr;
+  DOMEventTargetHelper::DisconnectFromOwner();
+}
+
 already_AddRefed<ServiceWorker>
 ServiceWorkerRegistration::GetInstalling() const
 {
   RefPtr<ServiceWorker> ref = mInstallingWorker;
   return ref.forget();
 }
 
 already_AddRefed<ServiceWorker>
@@ -137,10 +164,64 @@ ServiceWorkerRegistration::GetScope(nsAS
 }
 
 ServiceWorkerUpdateViaCache
 ServiceWorkerRegistration::GetUpdateViaCache(ErrorResult& aRv) const
 {
   return mDescriptor.UpdateViaCache();
 }
 
+already_AddRefed<Promise>
+ServiceWorkerRegistration::Update(ErrorResult& aRv)
+{
+  if (!mInner) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+  return mInner->Update(aRv);
+}
+
+already_AddRefed<Promise>
+ServiceWorkerRegistration::Unregister(ErrorResult& aRv)
+{
+  if (!mInner) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+  return mInner->Unregister(aRv);
+}
+
+already_AddRefed<PushManager>
+ServiceWorkerRegistration::GetPushManager(JSContext* aCx, ErrorResult& aRv)
+{
+  if (!mInner) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+  return mInner->GetPushManager(aCx, aRv);
+}
+
+already_AddRefed<Promise>
+ServiceWorkerRegistration::ShowNotification(JSContext* aCx,
+                                            const nsAString& aTitle,
+                                            const NotificationOptions& aOptions,
+                                            ErrorResult& aRv)
+{
+  if (!mInner) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+  return mInner->ShowNotification(aCx, aTitle, aOptions, aRv);
+}
+
+already_AddRefed<Promise>
+ServiceWorkerRegistration::GetNotifications(const GetNotificationOptions& aOptions,
+                                            ErrorResult& aRv)
+{
+  if (!mInner) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+  return mInner->GetNotifications(aOptions, aRv);
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -4,51 +4,85 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerRegistration_h
 #define mozilla_dom_ServiceWorkerRegistration_h
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/DOMPrefs.h"
-#include "mozilla/dom/ServiceWorker.h"
 #include "mozilla/dom/ServiceWorkerBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "mozilla/dom/ServiceWorkerRegistrationDescriptor.h"
 
 // Support for Notification API extension.
 #include "mozilla/dom/NotificationBinding.h"
 
-class nsPIDOMWindowInner;
+class nsIGlobalObject;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 class PushManager;
 class WorkerPrivate;
+class ServiceWorker;
 
-class ServiceWorkerRegistration : public DOMEventTargetHelper
+class ServiceWorkerRegistration final : public DOMEventTargetHelper
 {
 public:
+  class Inner
+  {
+  public:
+    NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
+
+    virtual void
+    AddServiceWorkerRegistration(ServiceWorkerRegistration* aReg) = 0;
+
+    virtual void
+    RemoveServiceWorkerRegistration(ServiceWorkerRegistration* aReg) = 0;
+
+    virtual already_AddRefed<Promise>
+    Update(ErrorResult& aRv) = 0;
+
+    virtual already_AddRefed<Promise>
+    Unregister(ErrorResult& aRv) = 0;
+
+    virtual already_AddRefed<Promise>
+    ShowNotification(JSContext* aCx,
+                     const nsAString& aTitle,
+                     const NotificationOptions& aOptions,
+                     ErrorResult& aRv) = 0;
+
+    virtual already_AddRefed<Promise>
+    GetNotifications(const GetNotificationOptions& aOptions,
+                     ErrorResult& aRv) = 0;
+
+    virtual already_AddRefed<PushManager>
+    GetPushManager(JSContext* aCx, ErrorResult& aRv) = 0;
+  };
+
   NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
   IMPL_EVENT_HANDLER(updatefound)
 
   static already_AddRefed<ServiceWorkerRegistration>
   CreateForMainThread(nsPIDOMWindowInner* aWindow,
                       const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
   static already_AddRefed<ServiceWorkerRegistration>
   CreateForWorker(WorkerPrivate* aWorkerPrivate,
                   const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
+  void DisconnectFromOwner() override;
+
   already_AddRefed<ServiceWorker>
   GetInstalling() const;
 
   already_AddRefed<ServiceWorker>
   GetWaiting() const;
 
   already_AddRefed<ServiceWorker>
   GetActive() const;
@@ -60,43 +94,44 @@ public:
   MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) const;
 
   void
   GetScope(nsAString& aScope) const;
 
   ServiceWorkerUpdateViaCache
   GetUpdateViaCache(ErrorResult& aRv) const;
 
-  virtual already_AddRefed<Promise>
-  Update(ErrorResult& aRv) = 0;
+  already_AddRefed<Promise>
+  Update(ErrorResult& aRv);
 
-  virtual already_AddRefed<Promise>
-  Unregister(ErrorResult& aRv) = 0;
+  already_AddRefed<Promise>
+  Unregister(ErrorResult& aRv);
 
-  virtual already_AddRefed<PushManager>
-  GetPushManager(JSContext* aCx, ErrorResult& aRv) = 0;
+  already_AddRefed<PushManager>
+  GetPushManager(JSContext* aCx, ErrorResult& aRv);
 
-  virtual already_AddRefed<Promise>
+  already_AddRefed<Promise>
   ShowNotification(JSContext* aCx,
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
-                   ErrorResult& aRv) = 0;
+                   ErrorResult& aRv);
 
-  virtual already_AddRefed<Promise>
+  already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
-                   ErrorResult& aRv) = 0;
+                   ErrorResult& aRv);
 
-protected:
-  ServiceWorkerRegistration(nsPIDOMWindowInner* aWindow,
-                            const ServiceWorkerRegistrationDescriptor& aDescriptor);
+private:
+  ServiceWorkerRegistration(nsIGlobalObject* aGlobal,
+                            const ServiceWorkerRegistrationDescriptor& aDescriptor,
+                            Inner* aInner);
 
-  virtual ~ServiceWorkerRegistration()
-  { }
+  ~ServiceWorkerRegistration();
 
   ServiceWorkerRegistrationDescriptor mDescriptor;
+  RefPtr<Inner> mInner;
   RefPtr<ServiceWorker> mInstallingWorker;
   RefPtr<ServiceWorker> mWaitingWorker;
   RefPtr<ServiceWorker> mActiveWorker;
 };
 
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -34,34 +34,21 @@
 #include "nsContentUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 ////////////////////////////////////////////////////
 // Main Thread implementation
 
-NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistration)
-NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistration)
-
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorkerRegistrationMainThread)
-NS_INTERFACE_MAP_END_INHERITING(ServiceWorkerRegistration)
-
-NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread,
-                                   ServiceWorkerRegistration,
-                                   mPushManager,
-                                   mInstallingWorker, mWaitingWorker, mActiveWorker);
-
-ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
-                                                                         const ServiceWorkerRegistrationDescriptor& aDescriptor)
-  : ServiceWorkerRegistration(aWindow, aDescriptor)
+ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(const ServiceWorkerRegistrationDescriptor& aDescriptor)
+  : mOwner(nullptr)
   , mListeningForEvents(false)
 {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aWindow);
   UpdateState(aDescriptor);
   StartListeningForEvents();
 }
 
 ServiceWorkerRegistrationMainThread::~ServiceWorkerRegistrationMainThread()
 {
   StopListeningForEvents();
   MOZ_ASSERT(!mListeningForEvents);
@@ -71,66 +58,85 @@ ServiceWorkerRegistrationMainThread::~Se
 // registered.
 void
 ServiceWorkerRegistrationMainThread::StartListeningForEvents()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mListeningForEvents);
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (swm) {
-    NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+    nsAutoString scope;
+    GetScope(scope);
     swm->AddRegistrationEventListener(scope, this);
     mListeningForEvents = true;
   }
 }
 
 void
 ServiceWorkerRegistrationMainThread::StopListeningForEvents()
 {
   MOZ_ASSERT(NS_IsMainThread());
   if (!mListeningForEvents) {
     return;
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (swm) {
-    NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+    nsAutoString scope;
+    GetScope(scope);
     swm->RemoveRegistrationEventListener(scope, this);
   }
   mListeningForEvents = false;
 }
 
 void
 ServiceWorkerRegistrationMainThread::UpdateFound()
 {
-  DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
+  mOwner->DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
 }
 
 void
 ServiceWorkerRegistrationMainThread::UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  ServiceWorkerRegistration::UpdateState(aDescriptor);
+  mOwner->UpdateState(aDescriptor);
 }
 
 void
 ServiceWorkerRegistrationMainThread::RegistrationRemoved()
 {
   // If the registration is being removed completely, remove it from the
   // window registration hash table so that a new registration would get a new
   // wrapper JS object.
-  if (nsCOMPtr<nsPIDOMWindowInner> window = GetOwner()) {
-    NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+  if (nsCOMPtr<nsPIDOMWindowInner> window = mOwner->GetOwner()) {
+    nsAutoString scope;
+    GetScope(scope);
     window->InvalidateServiceWorkerRegistration(scope);
   }
 }
 
 bool
 ServiceWorkerRegistrationMainThread::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
-  return ServiceWorkerRegistration::MatchesDescriptor(aDescriptor);
+  return mOwner->MatchesDescriptor(aDescriptor);
+}
+
+void
+ServiceWorkerRegistrationMainThread::AddServiceWorkerRegistration(ServiceWorkerRegistration* aReg)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aReg);
+  MOZ_DIAGNOSTIC_ASSERT(!mOwner);
+  mOwner = aReg;
+}
+
+void
+ServiceWorkerRegistrationMainThread::RemoveServiceWorkerRegistration(ServiceWorkerRegistration* aReg)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mOwner);
+  MOZ_DIAGNOSTIC_ASSERT(mOwner == aReg);
+  mOwner = nullptr;
 }
 
 namespace {
 
 void
 UpdateInternal(nsIPrincipal* aPrincipal,
                const nsACString& aScope,
                ServiceWorkerUpdateFinishCallback* aCallback)
@@ -525,19 +531,22 @@ ServiceWorkerRegistrationMainThread::Upd
   RefPtr<Promise> promise = Promise::Create(go, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   nsCOMPtr<nsIDocument> doc = GetOwner()->GetExtantDoc();
   MOZ_ASSERT(doc);
 
+  nsAutoString scope;
+  GetScope(scope);
+
   RefPtr<MainThreadUpdateCallback> cb =
     new MainThreadUpdateCallback(GetOwner(), promise);
-  UpdateInternal(doc->NodePrincipal(), mDescriptor.Scope(), cb);
+  UpdateInternal(doc->NodePrincipal(), NS_ConvertUTF16toUTF8(scope), cb);
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::Unregister(ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -553,21 +562,23 @@ ServiceWorkerRegistrationMainThread::Unr
   // asynchronously. We aren't making any internal state changes in these
   // checks, so ordering of multiple calls is not affected.
   nsCOMPtr<nsIDocument> document = GetOwner()->GetExtantDoc();
   if (!document) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
+  nsAutoString scope;
+  GetScope(scope);
+
   nsCOMPtr<nsIURI> scopeURI;
   nsCOMPtr<nsIURI> baseURI = document->GetBaseURI();
   // "If the origin of scope is not client's origin..."
-  nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), mDescriptor.Scope(),
-                          nullptr, baseURI);
+  nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), scope, nullptr, baseURI);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aRv.Throw(NS_ERROR_DOM_SECURITY_ERR);
     return nullptr;
   }
 
   nsCOMPtr<nsIPrincipal> documentPrincipal = document->NodePrincipal();
   rv = documentPrincipal->CheckMayLoad(scopeURI, true /* report */,
                                        false /* allowIfInheritsPrinciple */);
@@ -616,17 +627,18 @@ ServiceWorkerRegistrationMainThread::Sho
   }
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   if (NS_WARN_IF(!doc)) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
-  NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+  nsAutoString scope;
+  GetScope(scope);
 
   RefPtr<ServiceWorker> worker = GetActive();
   if (!worker) {
     aRv.ThrowTypeError<MSG_NO_ACTIVE_WORKER>(scope);
     return nullptr;
   }
 
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(window);
@@ -644,17 +656,18 @@ already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::GetNotifications(const GetNotificationOptions& aOptions, ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsPIDOMWindowInner> window = GetOwner();
   if (NS_WARN_IF(!window)) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
-  NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+  nsAutoString scope;
+  GetScope(scope);
   return Notification::Get(window, aOptions, scope, aRv);
 }
 
 already_AddRefed<PushManager>
 ServiceWorkerRegistrationMainThread::GetPushManager(JSContext* aCx,
                                                     ErrorResult& aRv)
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -662,17 +675,18 @@ ServiceWorkerRegistrationMainThread::Get
   if (!mPushManager) {
     nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
 
     if (!globalObject) {
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
 
-    NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+    nsAutoString scope;
+    GetScope(scope);
 
     GlobalObject global(aCx, globalObject->GetGlobalJSObject());
     mPushManager = PushManager::Constructor(global, scope, aRv);
     if (aRv.Failed()) {
       return nullptr;
     }
   }
 
@@ -793,52 +807,48 @@ public:
 
 private:
   ~WorkerListener()
   {
     MOZ_ASSERT(!mListeningForEvents);
   }
 };
 
-NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistrationWorkerThread, ServiceWorkerRegistration)
-NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistrationWorkerThread, ServiceWorkerRegistration)
-
-NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorkerRegistrationWorkerThread)
-NS_INTERFACE_MAP_END_INHERITING(ServiceWorkerRegistration)
-
-// Expanded macros since we need special behaviour to release the proxy.
-NS_IMPL_CYCLE_COLLECTION_CLASS(ServiceWorkerRegistrationWorkerThread)
-
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
-                                                  ServiceWorkerRegistration)
-  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPushManager)
-
-NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
-
-NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
-                                                ServiceWorkerRegistration)
-  NS_IMPL_CYCLE_COLLECTION_UNLINK(mPushManager)
-  tmp->ReleaseListener();
-NS_IMPL_CYCLE_COLLECTION_UNLINK_END
-
 ServiceWorkerRegistrationWorkerThread::ServiceWorkerRegistrationWorkerThread(WorkerPrivate* aWorkerPrivate,
                                                                              const ServiceWorkerRegistrationDescriptor& aDescriptor)
-  : ServiceWorkerRegistration(nullptr, aDescriptor)
-  , WorkerHolder("ServiceWorkerRegistrationWorkerThread")
+  : WorkerHolder("ServiceWorkerRegistrationWorkerThread")
+  , mOwner(nullptr)
   , mWorkerPrivate(aWorkerPrivate)
 {
   InitListener();
 }
 
 ServiceWorkerRegistrationWorkerThread::~ServiceWorkerRegistrationWorkerThread()
 {
   ReleaseListener();
   MOZ_ASSERT(!mListener);
 }
 
+
+void
+ServiceWorkerRegistrationWorkerThread::AddServiceWorkerRegistration(ServiceWorkerRegistration* aReg)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aReg);
+  MOZ_DIAGNOSTIC_ASSERT(!mOwner);
+  mOwner = aReg;
+}
+
+void
+ServiceWorkerRegistrationWorkerThread::RemoveServiceWorkerRegistration(ServiceWorkerRegistration* aReg)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mOwner);
+  MOZ_DIAGNOSTIC_ASSERT(mOwner == aReg);
+  mOwner = nullptr;
+}
+
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::Update(ErrorResult& aRv)
 {
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
 
   RefPtr<Promise> promise = Promise::Create(worker->GlobalScope(), aRv);
@@ -855,17 +865,20 @@ ServiceWorkerRegistrationWorkerThread::U
   }
 
   RefPtr<PromiseWorkerProxy> proxy = PromiseWorkerProxy::Create(worker, promise);
   if (!proxy) {
     aRv.Throw(NS_ERROR_DOM_ABORT_ERR);
     return nullptr;
   }
 
-  RefPtr<SWRUpdateRunnable> r = new SWRUpdateRunnable(proxy, mDescriptor.Scope());
+  nsAutoString scope;
+  GetScope(scope);
+
+  RefPtr<SWRUpdateRunnable> r = new SWRUpdateRunnable(proxy, NS_ConvertUTF16toUTF8(scope));
   MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(r.forget()));
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::Unregister(ErrorResult& aRv)
 {
@@ -887,18 +900,21 @@ ServiceWorkerRegistrationWorkerThread::U
   }
 
   RefPtr<PromiseWorkerProxy> proxy = PromiseWorkerProxy::Create(worker, promise);
   if (!proxy) {
     aRv.Throw(NS_ERROR_DOM_ABORT_ERR);
     return nullptr;
   }
 
+  nsAutoString scope;
+  GetScope(scope);
+
   RefPtr<StartUnregisterRunnable> r =
-    new StartUnregisterRunnable(proxy, mDescriptor.Scope());
+    new StartUnregisterRunnable(proxy, NS_ConvertUTF16toUTF8(scope));
   MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(r.forget()));
 
   return promise.forget();
 }
 
 void
 ServiceWorkerRegistrationWorkerThread::InitListener()
 {
@@ -1002,40 +1018,43 @@ ServiceWorkerRegistrationWorkerThread::S
                                                         const NotificationOptions& aOptions,
                                                         ErrorResult& aRv)
 {
 
   // Until Bug 1131324 exposes ServiceWorkerContainer on workers,
   // ShowPersistentNotification() checks for valid active worker while it is
   // also verifying scope so that we block the worker on the main thread only
   // once.
-  NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+  nsAutoString scope;
+  GetScope(scope);
   RefPtr<Promise> p =
     Notification::ShowPersistentNotification(aCx, mWorkerPrivate->GlobalScope(),
                                              scope, aTitle, aOptions, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   return p.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationWorkerThread::GetNotifications(const GetNotificationOptions& aOptions,
                                                         ErrorResult& aRv)
 {
-  NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+  nsAutoString scope;
+  GetScope(scope);
   return Notification::WorkerGet(mWorkerPrivate, aOptions, scope, aRv);
 }
 
 already_AddRefed<PushManager>
 ServiceWorkerRegistrationWorkerThread::GetPushManager(JSContext* aCx, ErrorResult& aRv)
 {
   if (!mPushManager) {
-    NS_ConvertUTF8toUTF16 scope(mDescriptor.Scope());
+    nsAutoString scope;
+    GetScope(scope);
     mPushManager = new PushManager(scope);
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 }
 
 } // dom namespace
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
@@ -18,136 +18,139 @@ namespace dom {
 
 class Promise;
 class PushManager;
 class ServiceWorker;
 
 ////////////////////////////////////////////////////
 // Main Thread implementation
 
-class ServiceWorkerRegistrationMainThread final : public ServiceWorkerRegistration,
+class ServiceWorkerRegistrationMainThread final : public ServiceWorkerRegistration::Inner,
                                                   public ServiceWorkerRegistrationListener
 {
-  friend nsPIDOMWindowInner;
 public:
-  NS_DECL_ISUPPORTS_INHERITED
-  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistrationMainThread,
-                                           ServiceWorkerRegistration)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerRegistrationMainThread, override)
+
+  explicit ServiceWorkerRegistrationMainThread(const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
-  ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
-                                      const ServiceWorkerRegistrationDescriptor& aDescriptor);
+  // ServiceWorkerRegistration::Inner
+  void
+  AddServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
+
+  void
+  RemoveServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
 
   already_AddRefed<Promise>
   Update(ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   Unregister(ErrorResult& aRv) override;
 
-  // Partial interface from Notification API.
   already_AddRefed<Promise>
   ShowNotification(JSContext* aCx,
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
 
-  // DOMEventTargethelper
-  void DisconnectFromOwner() override
-  {
-    StopListeningForEvents();
-    ServiceWorkerRegistration::DisconnectFromOwner();
-  }
-
   // ServiceWorkerRegistrationListener
   void
   UpdateFound() override;
 
   void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) override;
 
   void
   RegistrationRemoved() override;
 
   void
   GetScope(nsAString& aScope) const override
   {
-    ServiceWorkerRegistration::GetScope(aScope);
+    mOwner->GetScope(aScope);
   }
 
   bool
   MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor) override;
 
 private:
   ~ServiceWorkerRegistrationMainThread();
 
   void
   StartListeningForEvents();
 
   void
   StopListeningForEvents();
 
+  ServiceWorkerRegistration* mOwner;
+
   bool mListeningForEvents;
 
   RefPtr<PushManager> mPushManager;
 };
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener;
 
-class ServiceWorkerRegistrationWorkerThread final : public ServiceWorkerRegistration
+class ServiceWorkerRegistrationWorkerThread final : public ServiceWorkerRegistration::Inner
                                                   , public WorkerHolder
 {
 public:
-  NS_DECL_ISUPPORTS_INHERITED
-  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistrationWorkerThread,
-                                           ServiceWorkerRegistration)
+  NS_INLINE_DECL_REFCOUNTING(ServiceWorkerRegistrationWorkerThread, override)
 
   ServiceWorkerRegistrationWorkerThread(WorkerPrivate* aWorkerPrivate,
                                         const ServiceWorkerRegistrationDescriptor& aDescriptor);
 
+  // ServiceWorkerRegistration::Inner
+  void
+  AddServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
+
+  void
+  RemoveServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
+
   already_AddRefed<Promise>
   Update(ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   Unregister(ErrorResult& aRv) override;
 
-  // Partial interface from Notification API.
   already_AddRefed<Promise>
   ShowNotification(JSContext* aCx,
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
   already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
                    ErrorResult& aRv) override;
 
+  already_AddRefed<PushManager>
+  GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
+
+  // WorkerHolder
   bool
   Notify(WorkerStatus aStatus) override;
 
-  already_AddRefed<PushManager>
-  GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
-
 private:
   ~ServiceWorkerRegistrationWorkerThread();
 
   void
   InitListener();
 
   void
   ReleaseListener();
 
+  ServiceWorkerRegistration* mOwner;
   WorkerPrivate* mWorkerPrivate;
   RefPtr<WorkerListener> mListener;
 
   RefPtr<PushManager> mPushManager;
 };
 
 } // dom namespace
 } // mozilla namespace
