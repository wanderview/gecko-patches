# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7c4501050b1a0bd23aa587bc6c70bd81d7d8c15b

diff --git a/dom/security/nsCORSListenerProxy.cpp b/dom/security/nsCORSListenerProxy.cpp
--- a/dom/security/nsCORSListenerProxy.cpp
+++ b/dom/security/nsCORSListenerProxy.cpp
@@ -770,26 +770,31 @@ nsCORSListenerProxy::AsyncOnChannelRedir
   mOldRedirectChannel = aOldChannel;
   mNewRedirectChannel = aNewChannel;
 
   nsCOMPtr<nsIChannelEventSink> outer =
     do_GetInterface(mOuterNotificationCallbacks);
   if (outer) {
     rv = outer->AsyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags, this);
     if (NS_FAILED(rv)) {
+        nsCOMPtr<nsIHttpChannelInternal> internal = do_QueryInterface(aOldChannel);
+        if (internal &&
+            internal->GetRedirectMode() != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+          aOldChannel->Cancel(rv);
         // Do not cancel aOldChannel.  The outer nsIChannelEventSink is
         // responsible for canceling if it wishes.  It can legitimately
         // leave it uncanceled if it expects to process the redirect
         // response code later.  For example, fetch() with the "manual"
         // redirect mode will return an opaqueredirect Response object.
+        }
         mRedirectCallback = nullptr;
         mOldRedirectChannel = nullptr;
         mNewRedirectChannel = nullptr;
     }
-    return rv;  
+    return rv;
   }
 
   (void) OnRedirectVerifyCallback(NS_OK);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCORSListenerProxy::OnRedirectVerifyCallback(nsresult result)
