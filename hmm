# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  44fc6130e0fbbb881ac49766b6d61e751e0c17eb

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -169,16 +169,23 @@ TimeoutExecutor::Cancel()
 {
   if (mTimer) {
     mTimer->Cancel();
   }
   mMode = Mode::None;
   mDeadline = TimeStamp();
 }
 
+bool
+TimeoutExecutor::CouldBeExecutedEarly(const TimeStamp& aDeadline) const
+{
+  return (mMode == Mode::Immediate || mMode == Mode::Delayed) &&
+         aDeadline <= mDeadline;
+}
+
 NS_IMETHODIMP
 TimeoutExecutor::Run()
 {
   MaybeExecute();
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
--- a/dom/base/TimeoutExecutor.h
+++ b/dom/base/TimeoutExecutor.h
@@ -54,16 +54,19 @@ public:
   Shutdown();
 
   nsresult
   MaybeSchedule(const TimeStamp& aDeadline);
 
   void
   Cancel();
 
+  bool
+  CouldBeExecutedEarly(const TimeStamp& aDeadline) const;
+
   NS_DECL_ISUPPORTS
   NS_DECL_NSIRUNNABLE
   NS_DECL_NSITIMERCALLBACK
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -301,16 +301,17 @@ CalculateNewBackPressureDelayMS(uint32_t
 } // anonymous namespace
 
 TimeoutManager::TimeoutManager(nsGlobalWindow& aWindow)
   : mWindow(aWindow),
     mExecutor(new TimeoutExecutor(this)),
     mTimeoutIdCounter(1),
     mNextFiringId(InvalidFiringId + 1),
     mRunningTimeout(nullptr),
+    mFirstBlockedTimeout(nullptr),
     mIdleCallbackTimeoutCounter(1),
     mBackPressureDelayMS(0),
     mThrottleTrackingTimeouts(gTrackingTimeoutThrottlingDelay <= 0)
 {
   MOZ_DIAGNOSTIC_ASSERT(aWindow.IsInnerWindow());
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("TimeoutManager %p created, tracking bucketing %s\n",
@@ -511,16 +512,21 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   Timeouts::SortBy sort(mWindow.IsFrozen() ? Timeouts::SortBy::TimeRemaining
                                            : Timeouts::SortBy::TimeWhen);
   if (timeout->mIsTracking) {
     mTrackingTimeouts.Insert(timeout, sort);
   } else {
     mNormalTimeouts.Insert(timeout, sort);
   }
 
+  if (!mWindow.IsFrozen() && !mFirstBlockedTimeout &&
+      mExecutor->CouldBeExecutedEarly(timeout->When())) {
+    mFirstBlockedTimeout = timeout;
+  }
+
   timeout->mTimeoutId = GetTimeoutId(aReason);
   *aReturn = timeout->mTimeoutId;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Set%s(TimeoutManager=%p, timeout=%p, delay=%i, "
            "minimum=%i, throttling=%s, background=%d, realInterval=%i) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
@@ -555,16 +561,19 @@ TimeoutManager::ClearTimeout(int32_t aTi
            aTimeout for deferred deletion by the code in
            RunTimeout() */
         aTimeout->mIsInterval = false;
       }
       else {
         /* Delete the aTimeout from the pending aTimeout list */
         aTimeout->remove();
       }
+      if (mFirstBlockedTimeout == aTimeout) {
+        mFirstBlockedTimeout = nullptr;
+      }
       return true; // abort!
     }
 
     firstTimeout = false;
 
     return false;
   });
 
@@ -664,17 +673,18 @@ TimeoutManager::RunTimeout(const TimeSta
                                        mTrackingTimeouts,
                                        nullptr,
                                        nullptr);
 
     uint32_t numTimersToRun = 0;
 
     while (true) {
       Timeout* timeout = expiredIter.Next();
-      if (!timeout || timeout->When() > deadline) {
+      if (!timeout || timeout->When() > deadline ||
+          timeout == mFirstBlockedTimeout) {
         if (timeout) {
           nextDeadline = timeout->When();
         }
         break;
       }
 
       if (IsInvalidFiringId(timeout->mFiringId)) {
         // Mark any timeouts that are on the list to be fired with the
@@ -698,16 +708,18 @@ TimeoutManager::RunTimeout(const TimeSta
           }
         }
       }
 
       expiredIter.UpdateIterator();
     }
   }
 
+  mFirstBlockedTimeout = nullptr;
+
   // Wherever we stopped in the timer list, schedule the executor to
   // run for the next unexpired deadline.
   if (!nextDeadline.IsNull()) {
     MOZ_ALWAYS_SUCCEEDS(mExecutor->MaybeSchedule(nextDeadline));
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
@@ -1173,16 +1185,17 @@ TimeoutManager::ClearAllTimeouts()
   MOZ_LOG(gLog, LogLevel::Debug,
           ("ClearAllTimeouts(TimeoutManager=%p)\n", this));
 
   if (mThrottleTrackingTimeoutsTimer) {
     mThrottleTrackingTimeoutsTimer->Cancel();
     mThrottleTrackingTimeoutsTimer = nullptr;
   }
 
+  mFirstBlockedTimeout = nullptr;
   mExecutor->Cancel();
 
   ForEachUnorderedTimeout([&](Timeout* aTimeout) {
     /* If RunTimeout() is higher up on the stack for this
        window, e.g. as a result of document.write from a timeout,
        then we need to reset the list insertion point for
        newly-created timeouts in case the user adds a timeout,
        before we pop the stack back to RunTimeout. */
@@ -1292,16 +1305,17 @@ TimeoutManager::Suspend()
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Suspend(TimeoutManager=%p)\n", this));
 
   if (mThrottleTrackingTimeoutsTimer) {
     mThrottleTrackingTimeoutsTimer->Cancel();
     mThrottleTrackingTimeoutsTimer = nullptr;
   }
 
+  mFirstBlockedTimeout = nullptr;
   mExecutor->Cancel();
 }
 
 void
 TimeoutManager::Resume()
 {
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Resume(TimeoutManager=%p)\n", this));
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -148,17 +148,17 @@ private:
 
     // Insert aTimeout into the list, before all timeouts that would
     // fire after it, but no earlier than mTimeoutInsertionPoint, if any.
     enum class SortBy
     {
       TimeRemaining,
       TimeWhen
     };
-    void Insert(mozilla::dom::Timeout* aTimeout, SortBy aSortBy);
+    void Insert(Timeout* aTimeout, SortBy aSortBy);
     nsresult ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
                                              const TimeoutManager& aTimeoutManager,
                                              SortBy aSortBy);
 
     const Timeout* GetFirst() const { return mTimeoutList.getFirst(); }
     Timeout* GetFirst() { return mTimeoutList.getFirst(); }
     const Timeout* GetLast() const { return mTimeoutList.getLast(); }
     Timeout* GetLast() { return mTimeoutList.getLast(); }
@@ -223,19 +223,20 @@ private:
   RefPtr<TimeoutExecutor>     mExecutor;
   // The list of timeouts coming from non-tracking scripts.
   Timeouts                    mNormalTimeouts;
   // The list of timeouts coming from scripts on the tracking protection list.
   Timeouts                    mTrackingTimeouts;
   uint32_t                    mTimeoutIdCounter;
   uint32_t                    mNextFiringId;
   AutoTArray<uint32_t, 2>     mFiringIdStack;
-  mozilla::dom::Timeout*      mRunningTimeout;
+  Timeout*                    mRunningTimeout;
+  Timeout*                    mFirstBlockedTimeout;
 
-   // The current idle request callback timeout handle
+  // The current idle request callback timeout handle
   uint32_t                    mIdleCallbackTimeoutCounter;
 
   int32_t                     mBackPressureDelayMS;
 
   nsCOMPtr<nsITimer>          mThrottleTrackingTimeoutsTimer;
   bool                        mThrottleTrackingTimeouts;
 
   static uint32_t             sNestingLevel;
