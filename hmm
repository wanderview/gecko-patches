# HG changeset patch
# Parent 0f299bec11b87a749622c8021e40deb96675fa3b
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/AutoRestore.h"
 #include "mozilla/DebugOnly.h"
+#include "mozilla/TimeStamp.h"
 #include "mozilla/dom/cache/Action.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/OfflineStorage.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "mozIStorageConnection.h"
 #include "nsIFile.h"
@@ -454,16 +455,17 @@ public:
     , mData(aData)
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
     , mExecutingRunOnTarget(false)
+    , mStart(TimeStamp::Now())
   {
     MOZ_ASSERT(mContext);
     // mData may be nullptr
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     MOZ_ASSERT(mQuotaInfo.mDir);
     MOZ_ASSERT(mInitiatingThread);
   }
@@ -557,16 +559,18 @@ private:
   const QuotaInfo mQuotaInfo;
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   nsresult mResult;
 
   // Only accessible on target thread;
   bool mExecutingRunOnTarget;
 
+  const TimeStamp mStart;
+
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
 NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::ActionRunnable, nsIRunnable);
 
 // The ActionRunnable has a simpler state machine.  It basically needs to run
@@ -600,23 +604,28 @@ NS_IMPL_ISUPPORTS(mozilla::dom::cache::C
 //
 // Its important to note that synchronous actions will effectively Resolve()
 // out of the Running state immediately.  Asynchronous Actions may remain
 // in the Running state for some time, but normally the ActionRunnable itself
 // does not see any execution there.  Its all handled internal to the Action.
 NS_IMETHODIMP
 Context::ActionRunnable::Run()
 {
+  TimeDuration diff = TimeStamp::Now() - mStart;
+
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       MOZ_ASSERT(!mExecutingRunOnTarget);
 
+      printf("### ### [%p] ActionRunnable() took %0.3f ms to start\n",
+             this, diff.ToMilliseconds());
+
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
       nsRefPtr<Data> data;
       data.swap(mData);
 
@@ -647,16 +656,18 @@ Context::ActionRunnable::Run()
       MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+      printf("### ### [%p] ActionRunnable() took %0.3f ms to complete\n",
+             this, diff.ToMilliseconds());
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
     // -----------------
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -71,21 +71,25 @@ DBAction::RunOnTarget(Resolver* aResolve
 
     rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
     MOZ_ASSERT(conn);
 
+    printf_stderr("### ### created DB connection: %p\n", conn.get());
+
     // Save this connection in the shared Data object so later Actions can
     // use it.  This avoids opening a new connection for every Action.
     if (aOptionalData) {
       aOptionalData->SetConnection(conn);
     }
+  } else {
+    printf_stderr("### ### resuing DB connection: %p\n", conn.get());
   }
 
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
 DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                          mozIStorageConnection** aConnOut)
