# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a8d2624f35bcef8465685bb602374c5d9475378d

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -132,30 +132,35 @@ Client::PostMessage(JSContext* aCx, JS::
   }
 
   ClientEndPoint endpoint;
   aRv = ClientGetEndPoint(mGlobal, &endpoint);
   if (aRv.Failed()) {
     return;
   }
 
+  /*
   RefPtr<AutoThreadMozPromiseRequestHolder<GenericPromise>> holder =
     AutoThreadMozPromiseRequestHolder<GenericPromise>::Create();
   if (!holder) {
     return;
   }
+  */
 
   EnsureHandle();
+  mHandle->PostMessage(data, endpoint);
+  /*
   RefPtr<GenericPromise> innerPromise = mHandle->PostMessage(data, endpoint);
   innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
-    [holder] (bool aResult) {
+    [holder] (bool) {
       holder->RequestHolder().Complete();
-    }, [holder] (nsresult aResult) {
+    }, [holder] (nsresult) {
       holder->RequestHolder().Complete();
     }).Track(holder->RequestHolder());
+  */
 }
 
 VisibilityState
 Client::GetVisibilityState() const
 {
   return mData->state().get_IPCClientWindowState().visibilityState();
 }
 
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandle.h"
 
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
 #include "ClientState.h"
+#include "mozilla/AutoThreadMozPromiseRequestHolder.h"
 #include "mozilla/dom/PClientManagerChild.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
@@ -37,36 +38,50 @@ ClientHandle::Shutdown()
 
   mManager->ForgetHandle(this);
   mManager = nullptr;
 }
 
 already_AddRefed<ClientOpPromise>
 ClientHandle::StartOp(const ClientOpConstructorArgs& aArgs)
 {
+  RefPtr<ClientOpPromise> ref;
+
+  RefPtr<AutoThreadMozPromiseRequestHolder<ClientOpPromise>> holder =
+    AutoThreadMozPromiseRequestHolder<ClientOpPromise>::Create();
+  if (!holder) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
   promise->Then(mSerialEventTarget, __func__,
-                [kungFuGrip] (const ClientOpResult &) { },
-                [kungFuGrip] (nsresult) { });
+                [kungFuGrip, holder] (const ClientOpResult &) {
+                  holder->RequestHolder().Complete();
+                },
+                [kungFuGrip, holder] (nsresult) {
+                  holder->RequestHolder().Complete();
+                }).Track(holder->RequestHolder());
 
   MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
 
-  RefPtr<ClientOpPromise> ref = promise.get();
+  ref = promise.get();
   return ref.forget();
 }
 
 ClientHandle::ClientHandle(ClientManager* aManager,
                            nsISerialEventTarget* aSerialEventTarget,
                            const ClientInfo& aClientInfo)
   : mManager(aManager)
   , mSerialEventTarget(aSerialEventTarget)
@@ -108,81 +123,122 @@ const ClientInfo&
 ClientHandle::Info() const
 {
   return mClientInfo;
 }
 
 already_AddRefed<GenericPromise>
 ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
+  RefPtr<GenericPromise> ref;
+
+  RefPtr<AutoThreadMozPromiseRequestHolder<ClientOpPromise>> holder =
+    AutoThreadMozPromiseRequestHolder<ClientOpPromise>::Create();
+  if (!holder) {
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
     StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(mSerialEventTarget, __func__,
-    [outerPromise](const ClientOpResult& aResult) {
+    [outerPromise, holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
       outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
+    }, [outerPromise, holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
       outerPromise->Reject(aResult.get_nsresult(), __func__);
-    });
+    }).Track(holder->RequestHolder());
 
-  RefPtr<GenericPromise> ref = outerPromise.get();
+  ref = outerPromise.get();
   return ref.forget();
 }
 
 already_AddRefed<ClientStatePromise>
 ClientHandle::Focus()
 {
+  RefPtr<ClientStatePromise> ref;
+
+  RefPtr<AutoThreadMozPromiseRequestHolder<ClientOpPromise>> holder =
+    AutoThreadMozPromiseRequestHolder<ClientOpPromise>::Create();
+  if (!holder) {
+    ref = ClientStatePromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                           __func__);
+    return ref.forget();
+  }
+
   RefPtr<ClientStatePromise::Private> outerPromise =
     new ClientStatePromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
 
   innerPromise->Then(mSerialEventTarget, __func__,
-    [outerPromise](const ClientOpResult& aResult) {
+    [outerPromise, holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
       outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
+    }, [outerPromise, holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
       outerPromise->Reject(aResult.get_nsresult(), __func__);
-    });
+    }).Track(holder->RequestHolder());
 
-  RefPtr<ClientStatePromise> ref = outerPromise.get();
+  ref = outerPromise.get();
   return ref.forget();
 }
 
-already_AddRefed<GenericPromise>
+//already_AddRefed<GenericPromise>
+void
 ClientHandle::PostMessage(StructuredCloneData& aData,
                           const ClientEndPoint& aEndPoint)
 {
-  RefPtr<GenericPromise> ref;
+  //RefPtr<GenericPromise> ref;
+
+  RefPtr<AutoThreadMozPromiseRequestHolder<ClientOpPromise>> holder =
+    AutoThreadMozPromiseRequestHolder<ClientOpPromise>::Create();
+  if (!holder) {
+    /*
+    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
+                                          __func__);
+    return ref.forget();
+    */
+    return;
+  }
 
   ClientPostMessageArgs args;
   args.endpoint() = aEndPoint;
 
   // TODO: Ideally we should be able to wait for the actor to initialize,
   //       but for now just fail the postMessage() if its not ready.  We
   //       need a RefCounted version of the StructuredCloneData in order
   //       to capture it in the lambda here.
   if (!GetActor() ||
       !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
                                                       args.clonedData())) {
-    ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    return ref.forget();
+    //ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    //return ref.forget();
+    return;
   }
 
+  /*
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
+  */
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(mSerialEventTarget, __func__,
-    [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Resolve(true, __func__);
-    }, [outerPromise](const ClientOpResult& aResult) {
-      outerPromise->Reject(aResult.get_nsresult(), __func__);
-    });
+    [holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
+      //outerPromise->Resolve(true, __func__);
+    }, [holder](const ClientOpResult& aResult) {
+      holder->RequestHolder().Complete();
+      //outerPromise->Reject(aResult.get_nsresult(), __func__);
+    }).Track(holder->RequestHolder());
 
-  ref = outerPromise.get();
-  return ref.forget();
+  //ref = outerPromise.get();
+  //return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -65,17 +65,18 @@ public:
   Info() const;
 
   already_AddRefed<GenericPromise>
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   already_AddRefed<ClientStatePromise>
   Focus();
 
-  already_AddRefed<GenericPromise>
+  //already_AddRefed<GenericPromise>
+  void
   PostMessage(ipc::StructuredCloneData& aData,
               const ClientEndPoint& aEndPoint);
 
   NS_INLINE_DECL_REFCOUNTING(ClientHandle);
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/AutoThreadMozPromiseRequestHolder.h b/dom/workers/AutoThreadMozPromiseRequestHolder.h
--- a/dom/workers/AutoThreadMozPromiseRequestHolder.h
+++ b/dom/workers/AutoThreadMozPromiseRequestHolder.h
@@ -26,22 +26,25 @@ class AutoThreadMozPromiseRequestHolder
                                                       , public WorkerHolder
   {
     ~WorkerAutoThreadMozPromiseRequestHolder() = default;
 
   public:
     bool
     Notify(Status aStatus) override
     {
-      AutoThreadMozPromiseRequestHolder<PromiseType>::RequestHolder().DisconnectIfExists();
+      RefPtr<WorkerAutoThreadMozPromiseRequestHolder> kungFuGrip(this);
+      RequestHolder().DisconnectIfExists();
       return true;
     }
   };
 
-  virtual ~AutoThreadMozPromiseRequestHolder() = default;
+  virtual ~AutoThreadMozPromiseRequestHolder()
+  {
+  }
 
 public:
   static
   already_AddRefed<AutoThreadMozPromiseRequestHolder<PromiseType>>
   Create()
   {
     RefPtr<AutoThreadMozPromiseRequestHolder<PromiseType>> ref;
 
@@ -55,17 +58,16 @@ public:
     if (!workerPrivate) {
       ref = new AutoThreadMozPromiseRequestHolder<PromiseType>();
       return ref.forget();
     }
 
     RefPtr<WorkerAutoThreadMozPromiseRequestHolder> workerRef =
       new WorkerAutoThreadMozPromiseRequestHolder();
     if(!workerRef->HoldWorker(workerPrivate, mozilla::dom::workers::Closing)) {
-      workerRef->RequestHolder().Complete();
       return nullptr;
     }
 
     ref = workerRef.forget();
     return ref.forget();
   }
 
   MozPromiseRequestHolder<PromiseType>&
diff --git a/xpcom/threads/MozPromise.h b/xpcom/threads/MozPromise.h
--- a/xpcom/threads/MozPromise.h
+++ b/xpcom/threads/MozPromise.h
@@ -460,17 +460,17 @@ protected:
       // then shut down the thread or task queue that the promise result would
       // be dispatched on. So we unfortunately can't assert that promise
       // dispatch succeeds. :-(
       mResponseTarget->Dispatch(r.forget());
     }
 
     void Disconnect() override
     {
-      MOZ_DIAGNOSTIC_ASSERT(mResponseTarget->IsOnCurrentThread());
+      //MOZ_DIAGNOSTIC_ASSERT(mResponseTarget->IsOnCurrentThread());
       MOZ_DIAGNOSTIC_ASSERT(!Request::mComplete);
       Request::mDisconnected = true;
 
       // We could support rejecting the completion promise on disconnection, but
       // then we'd need to have some sort of default reject value. The use cases
       // of disconnection and completion promise chaining seem pretty orthogonal,
       // so let's use assert against it.
       MOZ_DIAGNOSTIC_ASSERT(!CompletionPromise());
