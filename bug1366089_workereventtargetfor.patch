# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  da4ac701aae7e6c070af65dc8f07cec22c1598d5
Bug 1366089 Make EventTargetFor() support worker threads. r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -2060,17 +2060,17 @@ public:
 
   void
   Disable()
   {
     nsCOMPtr<nsIEventTarget> nestedEventTarget;
     {
       MutexAutoLock lock(mMutex);
 
-      MOZ_ASSERT(mWorkerPrivate);
+      // Note, Disable() can be called more than once safely.
       mWorkerPrivate = nullptr;
       mNestedEventTarget.swap(nestedEventTarget);
     }
   }
 
   nsIEventTarget*
   GetWeakNestedEventTarget() const
   {
@@ -2972,32 +2972,44 @@ WorkerPrivateParent<Derived>::MaybeWrapA
 template <class Derived>
 already_AddRefed<nsISerialEventTarget>
 WorkerPrivateParent<Derived>::GetEventTarget()
 {
   WorkerPrivate* self = ParentAsWorkerPrivate();
 
   nsCOMPtr<nsISerialEventTarget> target;
 
+  bool needAutoDisable = false;
+
   {
     MutexAutoLock lock(mMutex);
 
-    if (!mEventTarget &&
-        ParentStatus() <= Running &&
-        self->mStatus <= Running) {
+    if (!mEventTarget) {
       mEventTarget = new EventTarget(self);
+
+      // If the worker is already shutting down then we want to
+      // immediately disable the event target.  This will cause
+      // the Dispatch() method to fail, but the event target
+      // will still exist.
+      if (self->mStatus > Running) {
+        needAutoDisable = true;
+      }
     }
 
     target = mEventTarget;
   }
 
-  NS_WARNING_ASSERTION(
-    target,
-    "Requested event target for a worker that is already shutting down!");
-
+  // Make sure to call Disable() outside of the mutex since it
+  // also internally locks a mutex.
+  if (needAutoDisable) {
+    mEventTarget->Disable();
+  }
+
+
+  MOZ_DIAGNOSTIC_ASSERT(target);
   return target.forget();
 }
 
 template <class Derived>
 bool
 WorkerPrivateParent<Derived>::Start()
 {
   // May be called on any thread!
@@ -6122,41 +6134,38 @@ WorkerPrivate::NotifyInternal(JSContext*
   RefPtr<EventTarget> eventTarget;
 
   // Save the old status and set the new status.
   Status previousStatus;
   {
     MutexAutoLock lock(mMutex);
 
     if (mStatus >= aStatus) {
-      MOZ_ASSERT(!mEventTarget);
       return true;
     }
 
     previousStatus = mStatus;
     mStatus = aStatus;
 
     // Mark parent status as closing immediately to avoid new events being
     // dispatched after we clear the queue below.
     if (aStatus == Closing) {
       Close();
     }
 
-    mEventTarget.swap(eventTarget);
-  }
-
-  // Now that mStatus > Running, no-one can create a new WorkerEventTarget or
-  // WorkerCrossThreadDispatcher if we don't already have one.
+    eventTarget = mEventTarget;
+  }
+
+  // Disable the event target, if it exists.
   if (eventTarget) {
     // Since we'll no longer process events, make sure we no longer allow anyone
     // to post them. We have to do this without mMutex held, since our mutex
     // must be acquired *after* the WorkerEventTarget's mutex when they're both
     // held.
     eventTarget->Disable();
-    eventTarget = nullptr;
   }
 
   if (mCrossThreadDispatcher) {
     // Since we'll no longer process events, make sure we no longer allow
     // anyone to post them. We have to do this without mMutex held, since our
     // mutex must be acquired *after* mCrossThreadDispatcher's mutex when
     // they're both held.
     mCrossThreadDispatcher->Forget();
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -67,20 +67,24 @@ NS_CreateJSTimeoutHandler(JSContext* aCx
 using namespace mozilla;
 using namespace mozilla::dom;
 USING_WORKERS_NAMESPACE
 
 using mozilla::dom::cache::CacheStorage;
 using mozilla::ipc::PrincipalInfo;
 
 WorkerGlobalScope::WorkerGlobalScope(WorkerPrivate* aWorkerPrivate)
-: mWindowInteractionsAllowed(0)
+: mSerialEventTarget(aWorkerPrivate->GetEventTarget())
+, mWindowInteractionsAllowed(0)
 , mWorkerPrivate(aWorkerPrivate)
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
+
+  // We should always have an event target when the global is created.
+  MOZ_DIAGNOSTIC_ASSERT(mSerialEventTarget);
 }
 
 WorkerGlobalScope::~WorkerGlobalScope()
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerGlobalScope)
@@ -484,16 +488,36 @@ WorkerGlobalScope::CreateImageBitmap(JSC
     return ImageBitmap::Create(this, aImage, aOffset, aLength, aFormat, aLayout,
                                aRv);
   } else {
     aRv.Throw(NS_ERROR_TYPE_ERR);
     return nullptr;
   }
 }
 
+nsresult
+WorkerGlobalScope::Dispatch(const char* aName, TaskCategory aCategory,
+                            already_AddRefed<nsIRunnable>&& aRunnable)
+{
+  return EventTargetFor(aCategory)->Dispatch(Move(aRunnable),
+                                             NS_DISPATCH_NORMAL);
+}
+
+nsISerialEventTarget*
+WorkerGlobalScope::EventTargetFor(TaskCategory aCategory) const
+{
+  return mSerialEventTarget;
+}
+
+AbstractThread*
+WorkerGlobalScope::AbstractMainThreadFor(TaskCategory aCategory)
+{
+  MOZ_CRASH("AbstractMainThreadFor not supported for workers.");
+}
+
 DedicatedWorkerGlobalScope::DedicatedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate,
                                                        const nsString& aName)
   : WorkerGlobalScope(aWorkerPrivate)
   , mName(aName)
 {
 }
 
 bool
@@ -829,18 +853,22 @@ ServiceWorkerGlobalScope::OpenWindowEnab
   MOZ_ASSERT(worker);
   worker->AssertIsOnWorkerThread();
   return worker->OpenWindowEnabled();
 }
 
 WorkerDebuggerGlobalScope::WorkerDebuggerGlobalScope(
                                                   WorkerPrivate* aWorkerPrivate)
 : mWorkerPrivate(aWorkerPrivate)
+, mSerialEventTarget(aWorkerPrivate->GetEventTarget())
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
+
+  // We should always have an event target when the global is created.
+  MOZ_DIAGNOSTIC_ASSERT(mSerialEventTarget);
 }
 
 WorkerDebuggerGlobalScope::~WorkerDebuggerGlobalScope()
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(WorkerDebuggerGlobalScope)
@@ -1044,16 +1072,36 @@ WorkerDebuggerGlobalScope::Dump(JSContex
                                 const Optional<nsAString>& aString) const
 {
   WorkerGlobalScope* scope = mWorkerPrivate->GetOrCreateGlobalScope(aCx);
   if (scope) {
     scope->Dump(aString);
   }
 }
 
+nsresult
+WorkerDebuggerGlobalScope::Dispatch(const char* aName, TaskCategory aCategory,
+                                    already_AddRefed<nsIRunnable>&& aRunnable)
+{
+  return EventTargetFor(aCategory)->Dispatch(Move(aRunnable),
+                                             NS_DISPATCH_NORMAL);
+}
+
+nsISerialEventTarget*
+WorkerDebuggerGlobalScope::EventTargetFor(TaskCategory aCategory) const
+{
+  return mSerialEventTarget;
+}
+
+AbstractThread*
+WorkerDebuggerGlobalScope::AbstractMainThreadFor(TaskCategory aCategory)
+{
+  MOZ_CRASH("AbstractMainThreadFor not supported for workers.");
+}
+
 BEGIN_WORKERS_NAMESPACE
 
 bool
 IsWorkerGlobal(JSObject* object)
 {
   nsIGlobalObject* globalObject = nullptr;
   return NS_SUCCEEDED(UNWRAP_OBJECT(WorkerGlobalScope, object,
                                     globalObject)) && !!globalObject;
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -53,16 +53,17 @@ class WorkerGlobalScope : public DOMEven
 
   RefPtr<Console> mConsole;
   RefPtr<Crypto> mCrypto;
   RefPtr<WorkerLocation> mLocation;
   RefPtr<WorkerNavigator> mNavigator;
   RefPtr<Performance> mPerformance;
   RefPtr<IDBFactory> mIndexedDB;
   RefPtr<cache::CacheStorage> mCacheStorage;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
 
   uint32_t mWindowInteractionsAllowed;
 
 protected:
   typedef mozilla::dom::workers::WorkerPrivate WorkerPrivate;
   WorkerPrivate* mWorkerPrivate;
 
   explicit WorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
@@ -198,16 +199,28 @@ public:
   }
 
   void
   ConsumeWindowInteraction()
   {
     MOZ_ASSERT(mWindowInteractionsAllowed > 0);
     mWindowInteractionsAllowed--;
   }
+
+  // Override DispatchTrait API to target the worker thread.  Dispatch may
+  // return failure if the worker thread is not alive.
+  nsresult
+  Dispatch(const char* aName, TaskCategory aCategory,
+           already_AddRefed<nsIRunnable>&& aRunnable) override;
+
+  nsISerialEventTarget*
+  EventTargetFor(TaskCategory aCategory) const override;
+
+  AbstractThread*
+  AbstractMainThreadFor(TaskCategory aCategory) override;
 };
 
 class DedicatedWorkerGlobalScope final : public WorkerGlobalScope
 {
   const nsString mName;
 
   ~DedicatedWorkerGlobalScope() { }
 
@@ -323,16 +336,17 @@ public:
 
 class WorkerDebuggerGlobalScope final : public DOMEventTargetHelper,
                                         public nsIGlobalObject
 {
   typedef mozilla::dom::workers::WorkerPrivate WorkerPrivate;
 
   WorkerPrivate* mWorkerPrivate;
   RefPtr<Console> mConsole;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
 
 public:
   explicit WorkerDebuggerGlobalScope(WorkerPrivate* aWorkerPrivate);
 
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED(WorkerDebuggerGlobalScope,
                                                          DOMEventTargetHelper)
 
@@ -399,16 +413,28 @@ public:
   GetConsoleIfExists() const
   {
     return mConsole;
   }
 
   void
   Dump(JSContext* aCx, const Optional<nsAString>& aString) const;
 
+  // Override DispatchTrait API to target the worker thread.  Dispatch may
+  // return failure if the worker thread is not alive.
+  nsresult
+  Dispatch(const char* aName, TaskCategory aCategory,
+           already_AddRefed<nsIRunnable>&& aRunnable) override;
+
+  nsISerialEventTarget*
+  EventTargetFor(TaskCategory aCategory) const override;
+
+  AbstractThread*
+  AbstractMainThreadFor(TaskCategory aCategory) override;
+
 private:
   virtual ~WorkerDebuggerGlobalScope();
 };
 
 } // namespace dom
 } // namespace mozilla
 
 inline nsISupports*
