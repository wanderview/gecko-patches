# HG changeset patch
# Parent fb5391f4fec182de4f55255a7ee9b79fe38441df
# User Ben Kelly <ben@wanderview.com>
Bug 1133939 P2 interdiff 001 address review feedback

diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -661,24 +661,22 @@ TEST(Pipes, Clone_DuringWrite_ReadDuring
                 3);        // num streams to read after each write
 }
 
 TEST(Pipes, Write_AsyncWait)
 {
   nsCOMPtr<nsIAsyncInputStream> reader;
   nsCOMPtr<nsIAsyncOutputStream> writer;
 
-  uint32_t segmentSize = 1024;
-  uint32_t numSegments = 1;
+  const uint32_t segmentSize = 1024;
+  const uint32_t numSegments = 1;
 
-  // Use async input streams so we can NS_ConsumeStream() the current data
-  // while the pipe is still being written to.
   nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
-                           true, true,  // non-blocking - reader, writer
-                           segmentSize, numSegments);
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   nsTArray<char> inputData;
   testing::CreateData(segmentSize, inputData);
 
   uint32_t numWritten = 0;
   rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
@@ -699,24 +697,22 @@ TEST(Pipes, Write_AsyncWait)
   ASSERT_TRUE(cb->Called());
 }
 
 TEST(Pipes, Write_AsyncWait_Clone)
 {
   nsCOMPtr<nsIAsyncInputStream> reader;
   nsCOMPtr<nsIAsyncOutputStream> writer;
 
-  uint32_t segmentSize = 1024;
-  uint32_t numSegments = 1;
+  const uint32_t segmentSize = 1024;
+  const uint32_t numSegments = 1;
 
-  // Use async input streams so we can NS_ConsumeStream() the current data
-  // while the pipe is still being written to.
   nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
-                           true, true,  // non-blocking - reader, writer
-                           segmentSize, numSegments);
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   nsCOMPtr<nsIInputStream> clone;
   rv = NS_CloneInputStream(reader, getter_AddRefs(clone));
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   nsTArray<char> inputData;
   testing::CreateData(segmentSize, inputData);
@@ -745,24 +741,22 @@ TEST(Pipes, Write_AsyncWait_Clone)
   ASSERT_TRUE(cb->Called());
 }
 
 TEST(Pipes, Write_AsyncWait_Clone_CloseOriginal)
 {
   nsCOMPtr<nsIAsyncInputStream> reader;
   nsCOMPtr<nsIAsyncOutputStream> writer;
 
-  uint32_t segmentSize = 1024;
-  uint32_t numSegments = 1;
+  const uint32_t segmentSize = 1024;
+  const uint32_t numSegments = 1;
 
-  // Use async input streams so we can NS_ConsumeStream() the current data
-  // while the pipe is still being written to.
   nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
-                           true, true,  // non-blocking - reader, writer
-                           segmentSize, numSegments);
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   nsCOMPtr<nsIInputStream> clone;
   rv = NS_CloneInputStream(reader, getter_AddRefs(clone));
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   nsTArray<char> inputData;
   testing::CreateData(segmentSize, inputData);
