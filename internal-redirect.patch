# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  319e596fc832d8c2387069768fe15a4a297b94ea

diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -1839,27 +1839,20 @@ HttpChannelParent::StartRedirect(uint32_
     return NS_BINDING_ABORTED;
   }
 
   // If this is an internal redirect for service worker interception, then
   // hide it from the child process.  The original e10s interception code
   // was not designed with this in mind and its not necessary to replace
   // the HttpChannelChild/Parent objects in this case.
   if (redirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL) {
+    nsCOMPtr<nsIInterceptedChannel> oldIntercepted =
+        do_QueryInterface(static_cast<nsIChannel*>(mChannel.get()));
     nsCOMPtr<nsIInterceptedChannel> newIntercepted = do_QueryInterface(newChannel);
-    if (newIntercepted) {
-#ifdef DEBUG
-      // Note, InterceptedHttpChannel can also do an internal redirect
-      // for opaque response interception.  This should not actually
-      // happen here in e10s mode.
-      nsCOMPtr<nsIInterceptedChannel> oldIntercepted =
-        do_QueryInterface(static_cast<nsIChannel*>(mChannel.get()));
-      MOZ_ASSERT(!oldIntercepted);
-#endif
-
+    if (!oldIntercepted && newIntercepted) {
       // We need to move across the reserved and initial client information
       // to the new channel.  Normally this would be handled by the child
       // ClientChannelHelper, but that is not notified of this redirect since
       // we're not propagating it back to the child process.
       nsCOMPtr<nsILoadInfo> oldLoadInfo;
       Unused << mChannel->GetLoadInfo(getter_AddRefs(oldLoadInfo));
       nsCOMPtr<nsILoadInfo> newLoadInfo;
       Unused << newChannel->GetLoadInfo(getter_AddRefs(newLoadInfo));
