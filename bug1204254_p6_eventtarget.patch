# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  abfb373cac154323cb96b91f0b03fdc4c59bf86e
Bug 1204254 P6 Always use the worker's main thread event target. r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -377,30 +377,33 @@ private:
                  NS_LITERAL_CSTRING("InterceptionFailedWithURL"), mRequestURL);
       CancelRequest(NS_ERROR_INTERCEPTION_FAILED);
     }
   }
 };
 
 struct RespondWithClosure
 {
+  nsCOMPtr<nsIEventTarget> mMainThreadTarget;
   nsMainThreadPtrHandle<nsIInterceptedChannel> mInterceptedChannel;
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
   const nsString mRequestURL;
   const nsCString mRespondWithScriptSpec;
   const uint32_t mRespondWithLineNumber;
   const uint32_t mRespondWithColumnNumber;
 
-  RespondWithClosure(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
+  RespondWithClosure(nsIEventTarget* aMainThreadTarget,
+                     nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                      nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
                      const nsAString& aRequestURL,
                      const nsACString& aRespondWithScriptSpec,
                      uint32_t aRespondWithLineNumber,
                      uint32_t aRespondWithColumnNumber)
-    : mInterceptedChannel(aChannel)
+    : mMainThreadTarget(aMainThreadTarget)
+    , mInterceptedChannel(aChannel)
     , mRegistration(aRegistration)
     , mRequestURL(aRequestURL)
     , mRespondWithScriptSpec(aRespondWithScriptSpec)
     , mRespondWithLineNumber(aRespondWithLineNumber)
     , mRespondWithColumnNumber(aRespondWithColumnNumber)
   {
   }
 };
@@ -416,23 +419,18 @@ void RespondWithCopyComplete(void* aClos
              data->mRequestURL);
     event = new CancelChannelRunnable(data->mInterceptedChannel,
                                       data->mRegistration,
                                       NS_ERROR_INTERCEPTION_FAILED);
   } else {
     event = new FinishResponse(data->mInterceptedChannel);
   }
 
-  // In theory this can happen after the worker thread is terminated.
-  WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
-  if (worker) {
-    MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(event.forget()));
-  } else {
-    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(event.forget()));
-  }
+  MOZ_ALWAYS_SUCCEEDS(
+    data->mMainThreadTarget->Dispatch(event.forget(), NS_DISPATCH_NORMAL));
 }
 
 class MOZ_STACK_CLASS AutoCancel
 {
   RefPtr<RespondWithHandler> mOwner;
   nsCString mSourceSpec;
   uint32_t mLine;
   uint32_t mColumn;
@@ -645,17 +643,18 @@ RespondWithHandler::ResolvedCallback(JSC
   }
 
   nsCOMPtr<nsIRunnable> startRunnable = new StartResponse(mInterceptedChannel,
                                                           ir,
                                                           worker->GetChannelInfo(),
                                                           mScriptSpec,
                                                           responseURL);
 
-  nsAutoPtr<RespondWithClosure> closure(new RespondWithClosure(mInterceptedChannel,
+  nsAutoPtr<RespondWithClosure> closure(new RespondWithClosure(worker->MainThreadEventTarget(),
+                                                               mInterceptedChannel,
                                                                mRegistration,
                                                                mRequestURL,
                                                                mRespondWithScriptSpec,
                                                                mRespondWithLineNumber,
                                                                mRespondWithColumnNumber));
   nsCOMPtr<nsIInputStream> body;
   ir->GetUnfilteredBody(getter_AddRefs(body));
   // Errors and redirects may not have a body.
@@ -692,34 +691,27 @@ RespondWithHandler::ResolvedCallback(JSC
       responseBody = buffered;
     }
 
     nsCOMPtr<nsIEventTarget> stsThread = do_GetService(NS_STREAMTRANSPORTSERVICE_CONTRACTID, &rv);
     if (NS_WARN_IF(!stsThread)) {
       return;
     }
 
-    // Note, we cannot use the worker main thread event target here.  We must
-    // ensure the start runnable fires before the finish runnable.  The finish
-    // runnable, though, sometimes gets dispatched from places other than the
-    // worker thread (like at the end of copying).  Therefore it does not
-    // use the worker main thread event target either.
-    MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other,
-                                              startRunnable.forget()));
+    MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(startRunnable.forget()));
 
     // XXXnsm, Fix for Bug 1141332 means that if we decide to make this
     // streaming at some point, we'll need a different solution to that bug.
     rv = NS_AsyncCopy(body, responseBody, stsThread, NS_ASYNCCOPY_VIA_WRITESEGMENTS,
                       kCopySegmentSize, RespondWithCopyComplete, closure.forget());
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return;
     }
   } else {
-    MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other,
-                                              startRunnable.forget()));
+    MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(startRunnable.forget()));
     RespondWithCopyComplete(closure.forget(), NS_OK);
   }
 
   MOZ_ASSERT(!closure);
   autoCancel.Reset();
   mRequestWasHandled = true;
 }
 
@@ -741,25 +733,21 @@ RespondWithHandler::RejectedCallback(JSC
              mRequestURL, valueString);
 
   CancelRequest(NS_ERROR_INTERCEPTION_FAILED);
 }
 
 void
 RespondWithHandler::CancelRequest(nsresult aStatus)
 {
+  WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
+  MOZ_DIAGNOSTIC_ASSERT(worker);
   nsCOMPtr<nsIRunnable> runnable =
     new CancelChannelRunnable(mInterceptedChannel, mRegistration, aStatus);
-  // Note, this may run off the worker thread during worker termination.
-  WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
-  if (worker) {
-    MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(runnable.forget()));
-  } else {
-    MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable.forget()));
-  }
+  MOZ_ALWAYS_SUCCEEDS(worker->DispatchToMainThread(runnable.forget()));
   mRequestWasHandled = true;
 }
 
 } // namespace
 
 void
 FetchEvent::RespondWith(JSContext* aCx, Promise& aArg, ErrorResult& aRv)
 {
