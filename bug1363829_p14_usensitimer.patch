# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8c69ec0b747377f30d68abfe9514f4215ed3fcee
Bug 1363829 P14 Use the nsITimer::PreciseInitWithCallback() instead of rounding. r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -58,42 +58,18 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Convert the precise delay to integral milliseconds for nsITimer.  This
-  // will require some kind of rounding.  We adjust our heurestic based on
-  // whether the window is firing high or low precision timeouts at the moment.
-  TimeDuration delay;
-
-  // For high precision timeouts we favor rounding down here.  This will
-  // cause us to fire our timer slightly early in some cases.  If this
-  // happens we will get rescheduled by TimeoutManager so we can reschedule
-  // a 0-ms nsITimer.  This may occur a few times if the browser is idle,
-  // but if the browser is busy then the delays will prevent this case from
-  // occuring.
-  if (aPrecision == TimeoutPrecision::High) {
-    delay = aDeadline - aNow - TimeDuration::FromMilliseconds(0.1);
-  }
-
-  // For low precision timers we favor rounding up.  This will minimize the
-  // chance of firing additional runnables as we do in high precision mode.
-  // The cost, of course, is that we are much more likely to fire the timeout
-  // a few milliseconds late.
-  else {
-    delay = aDeadline - aNow + TimeDuration::FromMilliseconds(0.9);
-  }
-
-  // Finally, this truncates the float delay to integral milliseconds.
-  rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
-                                nsITimer::TYPE_ONE_SHOT);
+  rv = mTimer->PreciseInitWithCallback(this, aDeadline - aNow,
+                                       nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
