# HG changeset patch
# Parent b14a677346704bce4f6b6c48ca692b0e20cebbd8
# User Ben Kelly <ben@wanderview.com>
Bug 1110487 P3 interdiff 002 fix QuotaInitRunnable to handle sync resolve with threadsafety


diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
--- a/dom/cache/Action.cpp
+++ b/dom/cache/Action.cpp
@@ -5,18 +5,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Action.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action::Resolver);
-
 void
 Action::CancelOnInitiatingThread()
 {
   NS_ASSERT_OWNINGTHREAD(Action);
   // It is possible for cancellation to be duplicated.  For example, an
   // individual Cache could have its Actions canceled and then shutdown
   // could trigger a second action.
   mCanceled = true;
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
--- a/dom/cache/Action.h
+++ b/dom/cache/Action.h
@@ -13,31 +13,29 @@
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class Action
 {
 public:
-  class Resolver : public nsISupports
+  class Resolver
   {
-  protected:
-    // virtual because deleted through base class pointer
-    virtual ~Resolver() { }
-
   public:
     // Note: Action must drop Resolver ref after calling Resolve()!
     // Note: Must be called on the same thread used to execute
     //       Action::RunOnTarget().
     virtual void Resolve(nsresult aRv) = 0;
 
-    // We must use ISUPPORTS for our refcounting here because sub-classes also
-    // want to inherit interfaces like nsIRunnable.
-    NS_DECL_THREADSAFE_ISUPPORTS
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
   };
 
   // Execute operations on the target thread.  Once complete call
   // Resolver::Resolve().  This can be done sync or async.
   // Note: Action should hold Resolver ref until its ready to call Resolve().
   // Note: The "target" thread is determined when the Action is scheduled on
   //       Context.  The Action should not assume any particular thread is used.
   virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) = 0;
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -65,31 +65,29 @@ using mozilla::dom::quota::OriginOrPatte
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::dom::quota::PersistenceType;
 
 // Executed to perform the complicated dance of steps necessary to initialize
 // the QuotaManager.  This must be performed for each origin before any disk
 // IO occurrs.
 class Context::QuotaInitRunnable final : public nsIRunnable
-                                       , public Action::Resolver
 {
 public:
   QuotaInitRunnable(Context* aContext,
                     Manager* aManager,
                     Action* aQuotaIOThreadAction)
     : mContext(aContext)
     , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
     , mManager(aManager)
     , mQuotaIOThreadAction(aQuotaIOThreadAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mResult(NS_OK)
     , mState(STATE_INIT)
     , mNeedsQuotaRelease(false)
-    , mExecutingRun(false)
   {
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mInitiatingThread);
   }
 
   nsresult Dispatch()
   {
@@ -100,54 +98,59 @@ public:
     nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
-  virtual void Resolve(nsresult aRv) override
+private:
+  class SyncResolver final : public Action::Resolver
   {
-    // Depending on the error or success path, this can run on either the
-    // main thread or the QuotaManager IO thread.  The IO thread is an
-    // idle thread which may be destroyed and recreated, so its hard to
-    // assert on.
-    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aRv));
+  public:
+    SyncResolver()
+      : mResolved(false)
+      , mResult(NS_OK)
+    { }
 
-    // QuotaInitRunnable only supports resolving synchronously while within
-    // its Run() method.  This is mainly because the QM IO LazyIdleThread does
-    // not support self-dispatch, but also because it means we don't need
-    // to do a thread bounce to ensure the Action is done running before
-    // completion.
-    MOZ_ASSERT(mExecutingRun);
+    virtual void
+    Resolve(nsresult aRv) override
+    {
+      MOZ_ASSERT(!mResolved);
+      mResolved = true;
+      mResult = aRv;
+    };
 
-    MOZ_ASSERT(NS_SUCCEEDED(mResult));
-    mResult = aRv;
+    bool Resolved() const { return mResolved; }
+    nsresult Result() const { return mResult; }
 
-    // The end of the Run() method will then transition to completing.
-    mState = STATE_RESOLVING;
-  }
+  private:
+    ~SyncResolver() { }
 
-private:
+    bool mResolved;
+    nsresult mResult;
+
+    NS_INLINE_DECL_REFCOUNTING(Context::QuotaInitRunnable::SyncResolver)
+  };
+
   ~QuotaInitRunnable()
   {
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mQuotaIOThreadAction);
   }
 
   enum State
   {
     STATE_INIT,
     STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
     STATE_WAIT_FOR_OPEN_ALLOWED,
     STATE_ENSURE_ORIGIN_INITIALIZED,
     STATE_RUNNING,
-    STATE_RESOLVING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
     MOZ_ASSERT(mContext);
@@ -161,25 +164,23 @@ private:
   nsRefPtr<Manager> mManager;
   nsRefPtr<Action> mQuotaIOThreadAction;
   nsCOMPtr<nsIThread> mInitiatingThread;
   nsresult mResult;
   QuotaInfo mQuotaInfo;
   nsMainThreadPtrHandle<OfflineStorage> mOfflineStorage;
   State mState;
   bool mNeedsQuotaRelease;
-  bool mExecutingRun;
 
 public:
-  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
-NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
-                            Action::Resolver, nsIRunnable);
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::QuotaInitRunnable, nsIRunnable);
 
 // The QuotaManager init state machine is represented in the following diagram:
 //
 //    +---------------+
 //    |     Start     |      Resolve(error)
 //    | (Orig Thread) +---------------------+
 //    +-------+-------+                     |
 //            |                             |
@@ -210,38 +211,37 @@ NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom
 // The initialization process proceeds through the main states.  If an error
 // occurs, then we transition to Completing state back on the original thread.
 NS_IMETHODIMP
 Context::QuotaInitRunnable::Run()
 {
   // May run on different threads depending on the state.  See individual
   // state cases for thread assertions.
 
-  AutoRestore<bool> executingRun(mExecutingRun);
-  mExecutingRun = true;
+  nsRefPtr<SyncResolver> resolver = new SyncResolver();
 
   switch(mState) {
     // -----------------------------------
     case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
     {
       MOZ_ASSERT(NS_IsMainThread());
       QuotaManager* qm = QuotaManager::GetOrCreate();
       if (!qm) {
-        Resolve(NS_ERROR_FAILURE);
+        resolver->Resolve(NS_ERROR_FAILURE);
         break;
       }
 
       nsRefPtr<ManagerId> managerId = mManager->GetManagerId();
       nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
       nsresult rv = qm->GetInfoFromPrincipal(principal,
                                              &mQuotaInfo.mGroup,
                                              &mQuotaInfo.mOrigin,
                                              &mQuotaInfo.mIsApp);
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        Resolve(rv);
+        resolver->Resolve(rv);
         break;
       }
 
       QuotaManager::GetStorageId(PERSISTENCE_TYPE_DEFAULT,
                                  mQuotaInfo.mOrigin,
                                  Client::DOMCACHE,
                                  NS_LITERAL_STRING("cache"),
                                  mQuotaInfo.mStorageId);
@@ -249,17 +249,17 @@ Context::QuotaInitRunnable::Run()
       // QuotaManager::WaitForOpenAllowed() will hold a reference to us as
       // a callback.  We will then get executed again on the main thread when
       // it is safe to open the quota directory.
       mState = STATE_WAIT_FOR_OPEN_ALLOWED;
       rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mQuotaInfo.mOrigin),
                                   Nullable<PersistenceType>(PERSISTENCE_TYPE_DEFAULT),
                                   mQuotaInfo.mStorageId, this);
       if (NS_FAILED(rv)) {
-        Resolve(rv);
+        resolver->Resolve(rv);
         break;
       }
       break;
     }
     // ------------------------------
     case STATE_WAIT_FOR_OPEN_ALLOWED:
     {
       MOZ_ASSERT(NS_IsMainThread());
@@ -271,17 +271,17 @@ Context::QuotaInitRunnable::Run()
 
       nsRefPtr<OfflineStorage> offlineStorage =
         OfflineStorage::Register(mThreadsafeHandle, mQuotaInfo);
       mOfflineStorage = new nsMainThreadPtrHolder<OfflineStorage>(offlineStorage);
 
       mState = STATE_ENSURE_ORIGIN_INITIALIZED;
       nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
       if (NS_WARN_IF(NS_FAILED(rv))) {
-        Resolve(rv);
+        resolver->Resolve(rv);
         break;
       }
       break;
     }
     // ----------------------------------
     case STATE_ENSURE_ORIGIN_INITIALIZED:
     {
       // Can't assert quota IO thread because its an idle thread that can get
@@ -292,31 +292,31 @@ Context::QuotaInitRunnable::Run()
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
-        Resolve(rv);
+        resolver->Resolve(rv);
         break;
       }
 
       mState = STATE_RUNNING;
 
       if (!mQuotaIOThreadAction) {
-        Resolve(NS_OK);
+        resolver->Resolve(NS_OK);
         break;
       }
 
-      // Execute the provided initialization Action.  We pass ourselves as the
-      // Resolver.  The Action must either call Resolve() immediately or hold
-      // a ref to us and call Resolve() later.
-      mQuotaIOThreadAction->RunOnTarget(this, mQuotaInfo);
+      // Execute the provided initialization Action.  The Action must Resolve()
+      // before returning.
+      mQuotaIOThreadAction->RunOnTarget(resolver, mQuotaInfo);
+      MOZ_ASSERT(resolver->Resolved());
 
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       if (mQuotaIOThreadAction) {
@@ -338,17 +338,22 @@ Context::QuotaInitRunnable::Run()
     }
     // -----
     default:
     {
       MOZ_CRASH("unexpected state in QuotaInitRunnable");
     }
   }
 
-  if (mState == STATE_RESOLVING) {
+  if (resolver->Resolved()) {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(resolver->Result()));
+
+    MOZ_ASSERT(NS_SUCCEEDED(mResult));
+    mResult = resolver->Result();
+
     mState = STATE_COMPLETING;
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
       mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL)));
   }
 
   return NS_OK;
 }
 
@@ -467,22 +472,21 @@ private:
   nsCOMPtr<nsIThread> mInitiatingThread;
   State mState;
   nsresult mResult;
 
   // Only accessible on target thread;
   bool mExecutingRunOnTarget;
 
 public:
-  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
-NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
-                            Action::Resolver, nsIRunnable);
+NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::ActionRunnable, nsIRunnable);
 
 // The ActionRunnable has a simpler state machine.  It basically needs to run
 // the action on the target thread and then complete on the original thread.
 //
 //   +-------------+
 //   |    Start    |
 //   |(Orig Thread)|
 //   +-----+-------+
