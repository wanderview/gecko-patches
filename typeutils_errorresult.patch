# HG changeset patch
# Parent 995c6118e1a93cdceba93b7a6988ac1ec6300050
# User Ben Kelly <ben@wanderview.com>
Use ErrorResult in Cache TypeUtils module.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -45,75 +45,80 @@ Cache::Cache(nsISupports* aOwner, nsIGlo
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
   , mActor(static_cast<CacheChild*>(aActor))
 {
   MOZ_ASSERT(mActor);
   mActor->SetListener(*this);
 }
 
-nsresult
-Cache::ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn)
+// TODO: factor this out to TypeUtils
+void
+Cache::ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn,
+                       bool aReadBody, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(mGlobal);
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return TypeUtils::ToPCacheRequest(global, aOut, aIn);
+  TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
 }
 
-nsresult
-Cache::ToPCacheRequest(PCacheRequest& aOut, const OwningRequestOrScalarValueString& aIn)
+// TODO: factor this out to TypeUtils
+void
+Cache::ToPCacheRequest(PCacheRequest& aOut, const OwningRequestOrScalarValueString& aIn,
+                       bool aReadBody, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(mGlobal);
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return TypeUtils::ToPCacheRequest(global, aOut, aIn);
+  return TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
 }
 
-nsresult
+// TODO: factor this out to TypeUtils
+void
 Cache::ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
-                             const Optional<RequestOrScalarValueString>& aIn)
+                             const Optional<RequestOrScalarValueString>& aIn,
+                             bool aReadBody, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(mGlobal);
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return TypeUtils::ToPCacheRequestOrVoid(global, aOut, aIn);
+  return TypeUtils::ToPCacheRequestOrVoid(global, aOut, aIn, aReadBody, aRv);
 }
 
 already_AddRefed<Promise>
 Cache::Match(const RequestOrScalarValueString& aRequest,
              const QueryParams& aParams, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  nsresult rv = ToPCacheRequest(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequest(request, aRequest, false, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendMatch(requestId, request, params);
@@ -128,20 +133,19 @@ Cache::MatchAll(const Optional<RequestOr
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequestOrVoid request;
-  nsresult rv = ToPCacheRequestOrVoid(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequestOrVoid(request, aRequest, false, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendMatchAll(requestId, request, params);
@@ -155,20 +159,19 @@ Cache::Add(const RequestOrScalarValueStr
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  nsresult rv = ToPCacheRequest(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequest(request, aRequest, true, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendAdd(requestId, request);
 
   return promise.forget();
 }
@@ -182,20 +185,19 @@ Cache::AddAll(const Sequence<OwningReque
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   nsTArray<PCacheRequest> requests;
   for(uint32_t i = 0; i < aRequests.Length(); ++i) {
     PCacheRequest* request = requests.AppendElement();
-    nsresult rv = ToPCacheRequest(*request, aRequests[i]);
-    if (NS_FAILED(rv)) {
-      promise->MaybeReject(rv);
-      return promise.forget();
+    ToPCacheRequest(*request, aRequests[i], true, aRv);
+    if (aRv.Failed()) {
+      return nullptr;
     }
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendAddAll(requestId, requests);
 
   return promise.forget();
@@ -208,27 +210,25 @@ Cache::Put(const RequestOrScalarValueStr
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  nsresult rv = ToPCacheRequest(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequest(request, aRequest, true, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   PCacheResponse response;
-  rv = TypeUtils::ToPCacheResponse(response, aResponse);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  TypeUtils::ToPCacheResponse(response, aResponse, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendPut(requestId, request, response);
 
   return promise.forget();
 }
@@ -240,20 +240,19 @@ Cache::Delete(const RequestOrScalarValue
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequest request;
-  nsresult rv = ToPCacheRequest(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequest(request, aRequest, false, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendDelete(requestId, request, params);
@@ -268,20 +267,19 @@ Cache::Keys(const Optional<RequestOrScal
   MOZ_ASSERT(mActor);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
   PCacheRequestOrVoid request;
-  nsresult rv = ToPCacheRequestOrVoid(request, aRequest);
-  if (NS_FAILED(rv)) {
-    promise->MaybeReject(rv);
-    return promise.forget();
+  ToPCacheRequestOrVoid(request, aRequest, false, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
   }
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendKeys(requestId, request, params);
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -97,22 +97,25 @@ public:
                    const nsTArray<PCacheRequest>& aRequests,
                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
 
 private:
   virtual ~Cache();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
-  nsresult ToPCacheRequest(PCacheRequest& aOut,
-                           const RequestOrScalarValueString& aIn);
-  nsresult ToPCacheRequest(PCacheRequest& aOut,
-                           const OwningRequestOrScalarValueString& aIn);
-  nsresult ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
-                                 const Optional<RequestOrScalarValueString>& aIn);
+  void ToPCacheRequest(PCacheRequest& aOut,
+                       const RequestOrScalarValueString& aIn, bool aReadBody,
+                       ErrorResult& aRv);
+  void ToPCacheRequest(PCacheRequest& aOut,
+                       const OwningRequestOrScalarValueString& aIn,
+                       bool aReadBody, ErrorResult& aRv);
+  void ToPCacheRequestOrVoid(PCacheRequestOrVoid& aOut,
+                             const Optional<RequestOrScalarValueString>& aIn,
+                             bool aReadBody, ErrorResult& aRv);
 
 private:
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -103,17 +103,21 @@ CacheStorage::Match(const RequestOrScala
       entry->mRequest.SetAsRequest() =
         &aRequest.GetAsRequest();
     }
 
     return promise.forget();
   }
 
   PCacheRequest request;
-  ToPCacheRequest(request, aRequest);
+  ToPCacheRequest(request, aRequest, false, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    nsRefPtr<Promise> unused = RemoveRequestPromise(requestId);
+    return nullptr;
+  }
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   unused << mActor->SendMatch(requestId, request, params);
 
   return promise.forget();
 }
@@ -286,17 +290,25 @@ CacheStorage::ActorCreated(PBackgroundCh
 
   for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
     Entry& entry = mPendingRequests[i];
     RequestId requestId = entry.mRequestId;
     switch(entry.mOp) {
       case OP_MATCH:
       {
         PCacheRequest request;
-        ToPCacheRequest(request, entry.mRequest);
+        ErrorResult rv;
+        ToPCacheRequest(request, entry.mRequest, false, rv);
+        if (NS_WARN_IF(rv.Failed())) {
+          nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
+          if (promise) {
+            promise->MaybeReject(rv);
+          }
+          return;
+        }
 
         PCacheQueryParams params;
         TypeUtils::ToPCacheQueryParams(params, entry.mParams);
 
         unused << mActor->SendMatch(requestId, request, params);
         break;
       }
       case OP_HAS:
@@ -498,25 +510,28 @@ CacheStorage::RemoveRequestPromise(Reque
       ref.swap(promise);
       mRequestPromises.RemoveElementAt(i);
       return ref.forget();
     }
   }
   return nullptr;
 }
 
-nsresult
-CacheStorage::ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn)
+// TODO: factor this out to TypeUtils
+void
+CacheStorage::ToPCacheRequest(PCacheRequest& aOut,
+                              const RequestOrScalarValueString& aIn,
+                              bool aReadBody, ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(mGlobal);
   JSContext* cx = jsapi.cx();
   JS::Rooted<JSObject*> jsGlobal(cx, mGlobal->GetGlobalJSObject());
   JSAutoCompartment ac(cx, jsGlobal);
 
   GlobalObject global(cx, jsGlobal);
 
-  return TypeUtils::ToPCacheRequest(global, aOut, aIn);
+  TypeUtils::ToPCacheRequest(global, aOut, aIn, aReadBody, aRv);
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -82,18 +82,19 @@ public:
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
   virtual ~CacheStorage();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
-  nsresult
-  ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn);
+  void
+  ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn,
+                  bool aReadyBody, ErrorResult& aRv);
 
   const Namespace mNamespace;
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheStorageChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -706,17 +706,17 @@ DBSchema::MatchByVaryHeader(mozIStorageC
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Should not have called this function if this was not the case
   MOZ_ASSERT(varyValues.Length() > 0);
 
   state->Reset();
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT name, value FROM request_headers "
-    "WHERE AND entry_id=?1;"
+    "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, entryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsRefPtr<InternalHeaders> cachedHeaders = new InternalHeaders(HeadersGuardEnum::MozNone);
 
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -430,17 +430,16 @@ public:
     }
 
     nsresult rv = StartStreamCopy(mRequestBodyStream, &mRequestBodyId,
                                   getter_AddRefs(mRequestBodyCopyContext));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       DoResolve(rv);
       return;
     }
-    MOZ_ASSERT(mRequestBodyCopyContext);
 
     rv = StartStreamCopy(mResponseBodyStream, &mResponseBodyId,
                          getter_AddRefs(mResponseBodyCopyContext));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       CancelStreamCopy(mRequestBodyStream, mRequestBodyCopyContext,
                        mRequestBodyId);
       mRequestBodyCopyContext = nullptr;
       DoResolve(rv);
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -22,63 +22,67 @@
 #include "nsURLParsers.h"
 
 // TODO: remove stream testing code
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 
 namespace {
 
+using mozilla::ErrorResult;
+using mozilla::unused;
 using mozilla::void_t;
-using mozilla::unused;
 using mozilla::dom::cache::PCacheReadStream;
 using mozilla::dom::cache::PCacheReadStreamOrVoid;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
 
 // Utility function to remove the query from a URL.  We're not using nsIURL
 // or URL to do this because they require going to the main thread.
-static nsresult
-GetURLWithoutQuery(const nsAString& aUrl, nsAString& aUrlWithoutQueryOut)
+static void
+GetURLWithoutQuery(const nsAString& aUrl, nsAString& aUrlWithoutQueryOut,
+                   ErrorResult& aRv)
 {
   NS_ConvertUTF16toUTF8 flatURL(aUrl);
   const char* url = flatURL.get();
 
   nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
-  NS_ENSURE_TRUE(urlParser, NS_ERROR_OUT_OF_MEMORY);
 
   uint32_t pathPos;
   int32_t pathLen;
-
   nsresult rv = urlParser->ParseURL(url, flatURL.Length(),
                                     nullptr, nullptr,       // ignore scheme
                                     nullptr, nullptr,       // ignore authority
                                     &pathPos, &pathLen);
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return;
+  }
 
   uint32_t queryPos;
   int32_t queryLen;
 
   rv = urlParser->ParsePath(url + pathPos, flatURL.Length() - pathPos,
                             nullptr, nullptr,               // ignore filepath
                             &queryPos, &queryLen,
                             nullptr, nullptr);              // ignore ref
-  NS_ENSURE_SUCCESS(rv, rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRv.Throw(rv);
+    return;
+  }
 
   // ParsePath gives us query position relative to the start of the path
   queryPos += pathPos;
 
   // We want everything before and after the query
   aUrlWithoutQueryOut = Substring(aUrl, 0, queryPos);
   aUrlWithoutQueryOut.Append(Substring(aUrl, queryPos + queryLen,
                                        aUrl.Length() - queryPos - queryLen));
-
-  return NS_OK;
 }
 
 void
 SerializeCacheStream(nsIInputStream* aStream, PCacheReadStreamOrVoid* aStreamOut)
 {
   MOZ_ASSERT(aStreamOut);
   if (!aStream) {
     *aStreamOut = void_t();
@@ -121,134 +125,142 @@ namespace cache {
 
 using mozilla::void_t;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
 
 // static
-nsresult
-TypeUtils::ToPCacheRequest(PCacheRequest& aOut, const Request& aIn)
+void
+TypeUtils::ToPCacheRequest(PCacheRequest& aOut, const Request& aIn,
+                           bool aReadBody, ErrorResult& aRv)
 {
   aIn.GetMethod(aOut.method());
   aIn.GetUrl(aOut.url());
-  nsresult rv = GetURLWithoutQuery(aOut.url(), aOut.urlWithoutQuery());
-  if(NS_FAILED(rv)) {
-    return rv;
+  GetURLWithoutQuery(aOut.url(), aOut.urlWithoutQuery(), aRv);
+  if (aRv.Failed()) {
+    return;
   }
   aIn.GetReferrer(aOut.referrer());
   nsRefPtr<InternalHeaders> headers = aIn.GetInternalHeaders();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
   aOut.mode() = aIn.Mode();
   aOut.credentials() = aIn.Credentials();
 
+  if (!aReadBody) {
+    aOut.body() = void_t();
+    return;
+  }
+
   if (aIn.BodyUsed()) {
-    return NS_ERROR_TYPE_ERR;
+    aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
+    return;
   }
 
   nsRefPtr<InternalRequest> internalRequest = aIn.GetInternalRequest();
   MOZ_ASSERT(internalRequest);
   nsCOMPtr<nsIInputStream> stream;
 
-  // TODO: internalRequest->GetBody(getter_AddRefs(stream));
+  internalRequest->GetBody(getter_AddRefs(stream));
   // TODO: set Request body used
 
-  // TODO: remove stream testing code
-  rv = NS_NewCStringInputStream(getter_AddRefs(stream),
-                NS_LITERAL_CSTRING("request body stream beep beep boop!"));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
   // TODO: Provide way to send PCacheRequest without serializing body for
   //       read-only operations that do not use body.
   SerializeCacheStream(stream, &aOut.body());
-
-  return NS_OK;
 }
 
 // static
-nsresult
+void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal,
                            PCacheRequest& aOut,
-                           const RequestOrScalarValueString& aIn)
+                           const RequestOrScalarValueString& aIn,
+                           bool aReadBody, ErrorResult& aRv)
 {
+  if (aIn.IsRequest()) {
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
+    return;
+  }
+
   RequestInit init;
-  ErrorResult result;
-  nsRefPtr<Request> request = Request::Constructor(aGlobal, aIn, init, result);
-  if (NS_WARN_IF(result.Failed())) {
-    return result.ErrorCode();
+  nsRefPtr<Request> request = Request::Constructor(aGlobal, aIn, init, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
   }
-  return ToPCacheRequest(aOut, *request);
+  ToPCacheRequest(aOut, *request, aReadBody, aRv);
 }
 
 // static
-nsresult
+void
 TypeUtils::ToPCacheRequestOrVoid(const GlobalObject& aGlobal, PCacheRequestOrVoid& aOut,
-                                 const Optional<RequestOrScalarValueString>& aIn)
+                                 const Optional<RequestOrScalarValueString>& aIn,
+                                 bool aReadBody, ErrorResult& aRv)
 {
   if (!aIn.WasPassed()) {
     aOut = void_t();
-    return NS_OK;
+    return;
   }
   PCacheRequest request;
-  nsresult rv = ToPCacheRequest(aGlobal, request, aIn.Value());
+  ToPCacheRequest(aGlobal, request, aIn.Value(), aReadBody, aRv);
+  if (aRv.Failed()) {
+    return;
+  }
   aOut = request;
-  return rv;
 }
 
 // static
-nsresult
+void
 TypeUtils::ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
-                           const OwningRequestOrScalarValueString& aIn)
+                           const OwningRequestOrScalarValueString& aIn,
+                           bool aReadBody, ErrorResult& aRv)
 {
+  if (aIn.IsRequest()) {
+    ToPCacheRequest(aOut, aIn.GetAsRequest(), aReadBody, aRv);
+    return;
+  }
+
   RequestOrScalarValueString input;
   RequestInit init;
-  ErrorResult result;
+  nsString str;
+  str.Assign(aIn.GetAsScalarValueString());
+  input.SetAsScalarValueString().Rebind(str.Data(), str.Length());
 
-  if (aIn.IsRequest()) {
-    input.SetAsRequest() = aIn.GetAsRequest();
-  } else {
-    nsString str;
-    str.Assign(aIn.GetAsScalarValueString());
-    input.SetAsScalarValueString().Rebind(str.Data(), str.Length());
+  nsRefPtr<Request> request = Request::Constructor(aGlobal, input, init, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
   }
-
-  nsRefPtr<Request> request = Request::Constructor(aGlobal, input, init, result);
-  if (NS_WARN_IF(result.Failed())) {
-    return result.ErrorCode();
-  }
-  return ToPCacheRequest(aOut, *request);
+  ToPCacheRequest(aOut, *request, aReadBody, aRv);
 }
 
 // static
-nsresult
-TypeUtils::ToPCacheResponse(PCacheResponse& aOut, const Response& aIn)
+void
+TypeUtils::ToPCacheResponse(PCacheResponse& aOut, const Response& aIn,
+                            ErrorResult& aRv)
 {
   aOut.type() = aIn.Type();
   aIn.GetUrl(aOut.url());
   aOut.status() = aIn.Status();
   aIn.GetStatusText(aOut.statusText());
   nsRefPtr<InternalHeaders> headers = aIn.GetInternalHeaders();
   MOZ_ASSERT(headers);
   headers->GetPHeaders(aOut.headers());
   aOut.headersGuard() = headers->Guard();
 
   if (aIn.BodyUsed()) {
-    return NS_ERROR_TYPE_ERR;
+    aRv.ThrowTypeError(MSG_REQUEST_BODY_CONSUMED_ERROR);
+    return;
   }
 
   nsCOMPtr<nsIInputStream> stream;
   aIn.GetBody(getter_AddRefs(stream));
   // TODO: set body stream used in Response
 
   SerializeCacheStream(stream, &aOut.body());
-
-  return NS_OK;
 }
 
 // static
 void
 TypeUtils::ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -32,33 +32,38 @@ class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheStreamControlChild;
 
 class TypeUtils
 {
 public:
-  static nsresult
-  ToPCacheRequest(PCacheRequest& aOut, const Request& aIn);
+  static void
+  ToPCacheRequest(PCacheRequest& aOut, const Request& aIn, bool aReadBody,
+                  ErrorResult& aRv);
 
-  static nsresult
-  ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut, const RequestOrScalarValueString& aIn);
+  static void
+  ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
+                  const RequestOrScalarValueString& aIn, bool aReadBody,
+                  ErrorResult& aRv);
 
-  static nsresult
+  static void
   ToPCacheRequestOrVoid(const GlobalObject& aGlobal,
                         PCacheRequestOrVoid& aOut,
-                        const Optional<RequestOrScalarValueString>& aIn);
+                        const Optional<RequestOrScalarValueString>& aIn,
+                        bool aReadBody, ErrorResult& aRv);
 
-  static nsresult
+  static void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
-                  const OwningRequestOrScalarValueString& aIn);
+                  const OwningRequestOrScalarValueString& aIn,
+                  bool aReadBody, ErrorResult& aRv);
 
-  static nsresult
-  ToPCacheResponse(PCacheResponse& aOut, const Response& aIn);
+  static void
+  ToPCacheResponse(PCacheResponse& aOut, const Response& aIn, ErrorResult& aRv);
 
   static void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   static already_AddRefed<Response>
   ToResponse(nsIGlobalObject* aOwner, const PCacheResponse& aIn,
              PCacheStreamControlChild* aStreamControl);
 
