# HG changeset patch
# Parent 2cb22c058add3ad58b68adae3ab06596fd4f723f
# User Ben Kelly <ben@wanderview.com>
Bug 1100398 P0 Break out helper routines to support gtests for more stream types. r=froydnj

diff --git a/xpcom/tests/gtest/Helpers.cpp b/xpcom/tests/gtest/Helpers.cpp
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/gtest/Helpers.cpp
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* Helper routines for xpcom gtests. */
+
+#include "Helpers.h"
+
+#include <algorithm>
+#include "gtest/gtest.h"
+#include "nsIOutputStream.h"
+#include "nsStreamUtils.h"
+#include "nsTArray.h"
+
+namespace testing {
+
+// Populate an array with the given number of bytes.  Data is lorem ipsum
+// random text, but deterministic across multiple calls.
+void
+CreateData(uint32_t aNumBytes, nsTArray<char>& aDataOut)
+{
+  static const char data[] =
+    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec egestas "
+    "purus eu condimentum iaculis. In accumsan leo eget odio porttitor, non "
+    "rhoncus nulla vestibulum. Etiam lacinia consectetur nisl nec "
+    "sollicitudin. Sed fringilla accumsan diam, pulvinar varius massa. Duis "
+    "mollis dignissim felis, eget tempus nisi tristique ut. Fusce euismod, "
+    "lectus non lacinia tempor, tellus diam suscipit quam, eget hendrerit "
+    "lacus nunc fringilla ante. Sed ultrices massa vitae risus molestie, ut "
+    "finibus quam laoreet nullam.";
+  static const uint32_t dataLength = sizeof(data) - 1;
+
+  aDataOut.SetCapacity(aNumBytes);
+
+  while (aNumBytes > 0) {
+    uint32_t amount = std::min(dataLength, aNumBytes);
+    aDataOut.AppendElements(data, amount);
+    aNumBytes -= amount;
+  }
+}
+
+// Write the given number of bytes out to the stream.  Loop until expected
+// bytes count is reached or an error occurs.
+void
+Write(nsIOutputStream* aStream, const nsTArray<char>& aData, uint32_t aOffset,
+      uint32_t aNumBytes)
+{
+  uint32_t remaining =
+    std::min(aNumBytes, static_cast<uint32_t>(aData.Length() - aOffset));
+
+  while (remaining > 0) {
+    uint32_t numWritten;
+    nsresult rv = aStream->Write(aData.Elements() + aOffset, remaining,
+                                 &numWritten);
+    ASSERT_TRUE(NS_SUCCEEDED(rv));
+    if (numWritten < 1) {
+      break;
+    }
+    aOffset += numWritten;
+    remaining -= numWritten;
+  }
+}
+
+// Write the given number of bytes and then close the stream.
+void
+WriteAllAndClose(nsIOutputStream* aStream, const nsTArray<char>& aData)
+{
+  Write(aStream, aData, 0, aData.Length());
+  aStream->Close();
+}
+
+// Synchronously consume the given input stream and validate the resulting data
+// against the given array of expected values.
+void
+ConsumeAndValidateStream(nsIInputStream* aStream,
+                         const nsTArray<char>& aExpectedData)
+{
+  nsDependentCSubstring data(aExpectedData.Elements(), aExpectedData.Length());
+  ConsumeAndValidateStream(aStream, data);
+}
+
+// Synchronously consume the given input stream and validate the resulting data
+// against the given string of expected values.
+void
+ConsumeAndValidateStream(nsIInputStream* aStream,
+                         const nsACString& aExpectedData)
+{
+  nsAutoCString outputData;
+  nsresult rv = NS_ConsumeStream(aStream, UINT32_MAX, outputData);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+  ASSERT_EQ(aExpectedData.Length(), outputData.Length());
+  ASSERT_TRUE(aExpectedData.Equals(outputData));
+}
+
+} // namespace testing
diff --git a/xpcom/tests/gtest/Helpers.h b/xpcom/tests/gtest/Helpers.h
new file mode 100644
--- /dev/null
+++ b/xpcom/tests/gtest/Helpers.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __Helpers_h
+#define __Helpers_h
+
+#include "nsString.h"
+#include <stdint.h>
+
+class nsIInputStream;
+class nsIOutputStream;
+template <class T> class nsTArray;
+
+namespace testing {
+
+void
+CreateData(uint32_t aNumBytes, nsTArray<char>& aDataOut);
+
+void
+Write(nsIOutputStream* aStream, const nsTArray<char>& aData, uint32_t aOffset,
+      uint32_t aNumBytes);
+
+void
+WriteAllAndClose(nsIOutputStream* aStream, const nsTArray<char>& aData);
+
+void
+ConsumeAndValidateStream(nsIInputStream* aStream,
+                         const nsTArray<char>& aExpectedData);
+
+void
+ConsumeAndValidateStream(nsIInputStream* aStream,
+                         const nsACString& aExpectedData);
+
+} // namespace testing
+
+#endif // __Helpers_h
diff --git a/xpcom/tests/gtest/TestSnappyStreams.cpp b/xpcom/tests/gtest/TestSnappyStreams.cpp
--- a/xpcom/tests/gtest/TestSnappyStreams.cpp
+++ b/xpcom/tests/gtest/TestSnappyStreams.cpp
@@ -1,70 +1,30 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <algorithm>
 #include "gtest/gtest.h"
+#include "Helpers.h"
 #include "mozilla/SnappyCompressOutputStream.h"
 #include "mozilla/SnappyUncompressInputStream.h"
 #include "nsIPipe.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsStringStream.h"
 #include "nsTArray.h"
 
 namespace {
 
 using mozilla::SnappyCompressOutputStream;
 using mozilla::SnappyUncompressInputStream;
 
-static void CreateData(uint32_t aNumBytes, nsTArray<char>& aDataOut)
-{
-  static const char data[] =
-    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec egestas "
-    "purus eu condimentum iaculis. In accumsan leo eget odio porttitor, non "
-    "rhoncus nulla vestibulum. Etiam lacinia consectetur nisl nec "
-    "sollicitudin. Sed fringilla accumsan diam, pulvinar varius massa. Duis "
-    "mollis dignissim felis, eget tempus nisi tristique ut. Fusce euismod, "
-    "lectus non lacinia tempor, tellus diam suscipit quam, eget hendrerit "
-    "lacus nunc fringilla ante. Sed ultrices massa vitae risus molestie, ut "
-    "finibus quam laoreet nullam.";
-  static const uint32_t dataLength = sizeof(data) - 1;
-
-  aDataOut.SetCapacity(aNumBytes);
-
-  while (aNumBytes > 0) {
-    uint32_t amount = std::min(dataLength, aNumBytes);
-    aDataOut.AppendElements(data, amount);
-    aNumBytes -= amount;
-  }
-}
-
-static void
-WriteAllAndClose(nsIOutputStream* aStream, const nsTArray<char>& aData)
-{
-  uint32_t offset = 0;
-  uint32_t remaining = aData.Length();
-  while (remaining > 0) {
-    uint32_t numWritten;
-    nsresult rv = aStream->Write(aData.Elements() + offset, remaining,
-                                 &numWritten);
-    ASSERT_TRUE(NS_SUCCEEDED(rv));
-    if (numWritten < 1) {
-      break;
-    }
-    offset += numWritten;
-    remaining -= numWritten;
-  }
-  aStream->Close();
-}
-
 static already_AddRefed<nsIOutputStream>
 CompressPipe(nsIInputStream** aReaderOut)
 {
   nsCOMPtr<nsIOutputStream> pipeWriter;
 
   nsresult rv = NS_NewPipe(aReaderOut, getter_AddRefs(pipeWriter));
   if (NS_FAILED(rv)) { return nullptr; }
 
@@ -80,19 +40,19 @@ static void TestCompress(uint32_t aNumBy
   // bloat very small content.
   ASSERT_GT(aNumBytes, 1024u);
 
   nsCOMPtr<nsIInputStream> pipeReader;
   nsCOMPtr<nsIOutputStream> compress = CompressPipe(getter_AddRefs(pipeReader));
   ASSERT_TRUE(compress);
 
   nsTArray<char> inputData;
-  CreateData(aNumBytes, inputData);
+  testing::CreateData(aNumBytes, inputData);
 
-  WriteAllAndClose(compress, inputData);
+  testing::WriteAllAndClose(compress, inputData);
 
   nsAutoCString outputData;
   nsresult rv = NS_ConsumeStream(pipeReader, UINT32_MAX, outputData);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   ASSERT_LT(outputData.Length(), inputData.Length());
 }
 
@@ -103,19 +63,19 @@ static void TestCompressUncompress(uint3
   nsCOMPtr<nsIInputStream> pipeReader;
   nsCOMPtr<nsIOutputStream> compress = CompressPipe(getter_AddRefs(pipeReader));
   ASSERT_TRUE(compress);
 
   nsCOMPtr<nsIInputStream> uncompress =
     new SnappyUncompressInputStream(pipeReader);
 
   nsTArray<char> inputData;
-  CreateData(aNumBytes, inputData);
+  testing::CreateData(aNumBytes, inputData);
 
-  WriteAllAndClose(compress, inputData);
+  testing::WriteAllAndClose(compress, inputData);
 
   nsAutoCString outputData;
   nsresult rv = NS_ConsumeStream(uncompress, UINT32_MAX, outputData);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
   ASSERT_EQ(inputData.Length(), outputData.Length());
   for (uint32_t i = 0; i < inputData.Length(); ++i) {
     EXPECT_EQ(inputData[i], outputData.get()[i]) << "Byte " << i;
diff --git a/xpcom/tests/gtest/moz.build b/xpcom/tests/gtest/moz.build
--- a/xpcom/tests/gtest/moz.build
+++ b/xpcom/tests/gtest/moz.build
@@ -1,15 +1,16 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 UNIFIED_SOURCES += [
+    'Helpers.cpp',
     'TestCRT.cpp',
     'TestEncoding.cpp',
     'TestExpirationTracker.cpp',
     'TestPipes.cpp',
     'TestPriorityQueue.cpp',
     'TestSnappyStreams.cpp',
     'TestStorageStream.cpp',
     'TestStrings.cpp',
