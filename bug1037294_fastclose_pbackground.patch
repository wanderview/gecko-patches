# HG changeset patch
# Parent 717cd9d89a801ec222a2800b1a7bcf7f4dc2e75d
# User Ben Kelly <ben@wanderview.com>
Bug 1037294: Close PBackground actor immediately when worker leaves Running state.


diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -2734,21 +2734,19 @@ WorkerThreadPrimaryRunnable::Run()
       {
         JSAutoRequest ar(cx);
 
         mWorkerPrivate->DoRunLoop(cx);
 
         JS_ReportPendingException(cx);
       }
 
-#ifdef ENABLE_TESTS
-      mThread->TestPBackground();
-#endif
-
-      BackgroundChild::CloseForCurrentThread();
+      // WorkerPrivate should have closed the actor when it cleared
+      // its event loop on close/cancel/terminate.
+      MOZ_ASSERT(!BackgroundChild::GetForCurrentThread());
 
 #ifdef MOZ_ENABLE_PROFILER_SPS
       if (stack) {
         stack->sampleRuntime(nullptr);
       }
 #endif
     }
 
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -79,16 +79,22 @@
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "ServiceWorkerManager.h"
 #include "SharedWorker.h"
 #include "WorkerFeature.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 
+#include "BackgroundChild.h"
+// Fix win32 brain damage
+#ifdef CreateFile
+#undef CreateFile
+#endif
+
 // JS_MaybeGC will run once every second during normal execution.
 #define PERIODIC_GC_TIMER_DELAY_SEC 1
 
 // A shrinking GC will run five seconds after the last event is processed.
 #define IDLE_GC_TIMER_DELAY_SEC 5
 
 #define PREF_WORKERS_ENABLED "dom.workers.enabled"
 
@@ -4505,33 +4511,46 @@ WorkerPrivate::ProcessAllControlRunnable
   }
 
   return result;
 }
 
 void
 WorkerPrivate::ClearMainEventQueue(WorkerRanOrNot aRanOrNot)
 {
+  using mozilla::ipc::BackgroundChild;
+
   AssertIsOnWorkerThread();
 
+  // In order to ensure that the event queue remains empty
+  // we must stop any IPC traffic in progress.
+  // XXX: This prevents PBackground usage by the script after
+  //      it calls close().  Also, prevents usage during close
+  //      event handler.
+  if (BackgroundChild::GetForCurrentThread()) {
+    BackgroundChild::CloseForCurrentThread();
+  }
+
   MOZ_ASSERT(!mCancelAllPendingRunnables);
   mCancelAllPendingRunnables = true;
 
   if (WorkerNeverRan == aRanOrNot) {
     for (uint32_t count = mPreStartRunnables.Length(), index = 0;
          index < count;
          index++) {
       nsRefPtr<WorkerRunnable> runnable = mPreStartRunnables[index].forget();
       static_cast<nsIRunnable*>(runnable.get())->Run();
     }
   } else {
     nsIThread* currentThread = NS_GetCurrentThread();
     MOZ_ASSERT(currentThread);
 
     NS_ProcessPendingEvents(currentThread);
+    // XXX: If we must permit PBackground IPC traffic after we leave the
+    //      Running state, then this assertion cannot be guaranteed.
     MOZ_ASSERT(!NS_HasPendingEvents(currentThread));
   }
 
   MOZ_ASSERT(mCancelAllPendingRunnables);
   mCancelAllPendingRunnables = false;
 }
 
 uint32_t
