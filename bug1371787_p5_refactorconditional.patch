# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f759ad4b35cee35e3aa60c04add15146124817ef
Bug 1371787 P5 Move the Timeout conditional checking into DOMMinTimeoutValue(). r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -223,39 +223,47 @@ TimeoutManager::IsInvalidFiringId(uint32
   // Finally, fall back to verifying the firing id is not anywhere
   // in the stack.  This could be slow for a large stack, but that
   // should be rare.  It can only happen with deeply nested event
   // loop spinning.  For example, a page that does a lot of timers
   // and a lot of sync XHRs within those timers could be slow here.
   return !mFiringIdStack.Contains(aFiringId);
 }
 
+// The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
+// uses 5.
+#define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
+
 int32_t
 TimeoutManager::DOMMinTimeoutValue(Timeout* aTimeout) const {
   MOZ_DIAGNOSTIC_ASSERT(aTimeout);
-  bool throttleTracking = aTimeout->mIsTracking && mThrottleTrackingTimeouts;
-  auto minValue = throttleTracking ? gMinTrackingTimeoutValue
-                                   : gMinClampTimeoutValue;
-  return minValue;
+  int32_t result = 0;
+
+  if (aTimeout->mIsInterval ||
+      aTimeout->mNestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
+    result = std::max(result, gMinClampTimeoutValue);
+  }
+
+  if (aTimeout->mIsTracking && mThrottleTrackingTimeouts) {
+    result = std::max(result, gMinTrackingTimeoutValue);
+  }
+
+  return result;
 }
 
 #define TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY 0 // Consider all timeouts coming from tracking scripts as tracking
 // These strategies are useful for testing.
 #define ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY        1 // Consider all timeouts as normal
 #define ALTERNATE_TIMEOUT_BUCKETING_STRATEGY         2 // Put every other timeout in the list of tracking timeouts
 #define RANDOM_TIMEOUT_BUCKETING_STRATEGY            3 // Put timeouts into either the normal or tracking timeouts list randomly
 static int32_t gTimeoutBucketingStrategy = 0;
 
 #define DEFAULT_TRACKING_TIMEOUT_THROTTLING_DELAY  -1  // Only positive integers cause us to introduce a delay for tracking
                                                        // timeout throttling.
 
-// The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
-// uses 5.
-#define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
-
 // The longest interval (as PRIntervalTime) we permit, or that our
 // timer code can handle, really. See DELAY_INTERVAL_LIMIT in
 // nsTimerImpl.h for details.
 #define DOM_MAX_TIMEOUT_VALUE    DELAY_INTERVAL_LIMIT
 
 uint32_t TimeoutManager::sNestingLevel = 0;
 
 namespace {
@@ -417,24 +425,18 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   uint32_t nestingLevel = sNestingLevel + 1;
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
 
   // Now clamp the actual interval we will use for the timer based on
-  uint32_t realInterval = interval;
-  if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL ||
-      timeout->mIsTracking) {
-    // Don't allow timeouts less than DOMMinTimeoutValue() from
-    // now...
-    realInterval = std::max(realInterval,
-                            uint32_t(DOMMinTimeoutValue(timeout)));
-  }
+  uint32_t realInterval =
+    std::max(interval, DOMMinTimeoutValue(timeout));
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
   timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     nsresult rv = mExecutor->MaybeSchedule(timeout->When(),
                                            MinSchedulingDelay());
