# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  33e2a90496f40c2702a7ced995f353f78294c9ea
Bug 1466681 P6 Make ServiceWorkerRegistration::Inner::Unregister() use callbacks instead of MozPromise. r=asuth

diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -246,28 +246,22 @@ ServiceWorkerRegistration::Unregister(Er
     return nullptr;
   }
 
   RefPtr<Promise> outer = Promise::Create(global, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  RefPtr<DOMMozPromiseRequestHolder<GenericPromise>> holder =
-    new DOMMozPromiseRequestHolder<GenericPromise>(global);
-
-  mInner->Unregister()->Then(
-    global->EventTargetFor(TaskCategory::Other), __func__,
-    [outer, holder] (bool aSuccess) {
-      holder->Complete();
+  mInner->Unregister(
+    [outer] (bool aSuccess) {
       outer->MaybeResolve(aSuccess);
-    }, [outer, holder] (nsresult aRv) {
-      holder->Complete();
+    }, [outer] (ErrorResult& aRv) {
       outer->MaybeReject(aRv);
-    })->Track(*holder);
+    });
 
   return outer.forget();
 }
 
 already_AddRefed<PushManager>
 ServiceWorkerRegistration::GetPushManager(JSContext* aCx, ErrorResult& aRv)
 {
   if (!mPushManager) {
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -43,18 +43,19 @@ public:
 
     virtual void
     ClearServiceWorkerRegistration(ServiceWorkerRegistration* aReg) = 0;
 
     virtual void
     Update(ServiceWorkerRegistrationCallback&& aSuccessCB,
            ServiceWorkerFailureCallback&& aFailureCB) = 0;
 
-    virtual RefPtr<GenericPromise>
-    Unregister() = 0;
+    virtual void
+    Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
+               ServiceWorkerFailureCallback&& aFailureCB) = 0;
   };
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_SERVICEWORKERREGISTRATION_IID)
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
   IMPL_EVENT_HANDLER(updatefound)
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -554,44 +554,62 @@ ServiceWorkerRegistrationMainThread::Upd
       holder->Complete();
       successCB(aDescriptor);
     }, [failureCB = std::move(aFailureCB), holder] (const CopyableErrorResult& aRv) {
       holder->Complete();
       failureCB(CopyableErrorResult(aRv));
     })->Track(*holder);
 }
 
-RefPtr<GenericPromise>
-ServiceWorkerRegistrationMainThread::Unregister()
+void
+ServiceWorkerRegistrationMainThread::Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
+                                                ServiceWorkerFailureCallback&& aFailureCB)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mOuter);
 
+  nsIGlobalObject* global = mOuter->GetParentObject();
+  if (!global) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
   nsCOMPtr<nsIServiceWorkerManager> swm =
     mozilla::services::GetServiceWorkerManager();
   if (!swm) {
-    return GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
   }
 
   nsCOMPtr<nsIPrincipal> principal = mDescriptor.GetPrincipal();
   if (!principal) {
-    return GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
-                                           __func__);
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
   }
 
   RefPtr<UnregisterCallback> cb = new UnregisterCallback();
 
   nsresult rv = swm->Unregister(principal, cb,
                                 NS_ConvertUTF8toUTF16(mDescriptor.Scope()));
   if (NS_FAILED(rv)) {
-    return GenericPromise::CreateAndReject(rv, __func__);
+    aFailureCB(CopyableErrorResult(rv));
+    return;
   }
 
-  return cb->Promise();
+  auto holder = MakeRefPtr<DOMMozPromiseRequestHolder<GenericPromise>>(global);
+
+  cb->Promise()->Then(
+    global->EventTargetFor(TaskCategory::Other), __func__,
+    [successCB = std::move(aSuccessCB), holder] (bool aResult) {
+      holder->Complete();
+      successCB(aResult);
+    }, [failureCB = std::move(aFailureCB), holder] (nsresult aRv) {
+      holder->Complete();
+      failureCB(CopyableErrorResult(aRv));
+    })->Track(*holder);
 }
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
   const nsString mScope;
@@ -789,50 +807,66 @@ ServiceWorkerRegistrationWorkerThread::U
 
   nsresult rv = workerRef->Private()->DispatchToMainThread(r.forget());
   if (NS_FAILED(rv)) {
     promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
     return;
   }
 }
 
-RefPtr<GenericPromise>
-ServiceWorkerRegistrationWorkerThread::Unregister()
+void
+ServiceWorkerRegistrationWorkerThread::Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
+                                                  ServiceWorkerFailureCallback&& aFailureCB)
 {
   if (NS_WARN_IF(!mWorkerRef->GetPrivate())) {
-    return GenericPromise::CreateAndReject(
-      NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
   }
 
   RefPtr<StrongWorkerRef> workerRef =
     StrongWorkerRef::Create(mWorkerRef->GetPrivate(), __func__);
   if (NS_WARN_IF(!workerRef)) {
-    return GenericPromise::CreateAndReject(
-      NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
   }
 
   // Eventually we need to support all workers, but for right now this
   // code assumes we're on a service worker global as self.registration.
   if (NS_WARN_IF(!workerRef->Private()->IsServiceWorker())) {
-    return GenericPromise::CreateAndReject(
-      NS_ERROR_DOM_SECURITY_ERR, __func__);
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
+  nsIGlobalObject* global = workerRef->Private()->GlobalScope();
+  if (!global) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
   }
 
-  RefPtr<GenericPromise::Private> outer = new GenericPromise::Private(__func__);
+  auto promise = MakeRefPtr<GenericPromise::Private>(__func__);
+  auto holder = MakeRefPtr<DOMMozPromiseRequestHolder<GenericPromise>>(global);
+
+  promise->Then(
+    global->EventTargetFor(TaskCategory::Other), __func__,
+    [successCB = std::move(aSuccessCB), holder] (bool aResult) {
+      holder->Complete();
+      successCB(aResult);
+    }, [failureCB = std::move(aFailureCB), holder] (nsresult aRv) {
+      holder->Complete();
+      failureCB(CopyableErrorResult(aRv));
+    })->Track(*holder);
 
   RefPtr<StartUnregisterRunnable> r =
-    new StartUnregisterRunnable(workerRef, outer, mDescriptor);
+    new StartUnregisterRunnable(workerRef, promise, mDescriptor);
 
   nsresult rv = workerRef->Private()->DispatchToMainThread(r);
   if (NS_FAILED(rv)) {
-    outer->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    return outer.forget();
+    promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    return;
   }
-
-  return outer.forget();
 }
 
 void
 ServiceWorkerRegistrationWorkerThread::InitListener()
 {
   MOZ_ASSERT(!mListener);
   WorkerPrivate* worker = GetCurrentThreadWorkerPrivate();
   MOZ_ASSERT(worker);
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.h
@@ -41,18 +41,19 @@ public:
 
   void
   ClearServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
 
   void
   Update(ServiceWorkerRegistrationCallback&& aSuccessCB,
          ServiceWorkerFailureCallback&& aFailureCB) override;
 
-  RefPtr<GenericPromise>
-  Unregister() override;
+  void
+  Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
+             ServiceWorkerFailureCallback&& aFailureCB) override;
 
   // ServiceWorkerRegistrationListener
   void
   UpdateFound() override;
 
   void
   UpdateState(const ServiceWorkerRegistrationDescriptor& aDescriptor) override;
 
@@ -109,18 +110,19 @@ public:
 
   void
   ClearServiceWorkerRegistration(ServiceWorkerRegistration* aReg) override;
 
   void
   Update(ServiceWorkerRegistrationCallback&& aSuccessCB,
          ServiceWorkerFailureCallback&& aFailureCB) override;
 
-  RefPtr<GenericPromise>
-  Unregister() override;
+  void
+  Unregister(ServiceWorkerBoolCallback&& aSuccessCB,
+             ServiceWorkerFailureCallback&& aFailureCB) override;
 
   void
   UpdateFound();
 
 private:
   ~ServiceWorkerRegistrationWorkerThread();
 
   void
diff --git a/dom/serviceworkers/ServiceWorkerUtils.h b/dom/serviceworkers/ServiceWorkerUtils.h
--- a/dom/serviceworkers/ServiceWorkerUtils.h
+++ b/dom/serviceworkers/ServiceWorkerUtils.h
@@ -26,16 +26,19 @@ typedef MozPromise<nsTArray<ServiceWorke
         ServiceWorkerRegistrationListPromise;
 
 typedef std::function<void (const ServiceWorkerRegistrationDescriptor&)>
         ServiceWorkerRegistrationCallback;
 
 typedef std::function<void (const nsTArray<ServiceWorkerRegistrationDescriptor>&)>
         ServiceWorkerRegistrationListCallback;
 
+typedef std::function<void (bool)>
+        ServiceWorkerBoolCallback;
+
 typedef std::function<void (ErrorResult&)>
         ServiceWorkerFailureCallback;
 
 bool
 ServiceWorkerParentInterceptEnabled();
 
 bool
 ServiceWorkerRegistrationDataIsValid(const ServiceWorkerRegistrationData& aData);
