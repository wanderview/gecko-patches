# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2ed8007eae9730e9b0b8c06b290abbd70e18704f
Bug 1334383 P2 Make TimerThread::PostTimerEvent() keep its lock if the event target implements nsILockable. r=froydnj

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsTimerImpl.h"
 #include "TimerThread.h"
 
 #include "nsThreadUtils.h"
 #include "pratom.h"
 
+#include "nsILockable.h"
 #include "nsIObserverService.h"
 #include "nsIServiceManager.h"
 #include "mozilla/Services.h"
 #include "mozilla/ChaosMode.h"
 #include "mozilla/ArenaAllocator.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/BinarySearch.h"
 
@@ -747,20 +748,25 @@ TimerThread::PostTimerEvent(already_AddR
   // AutoSaveCurTraceInfo.
   AutoSaveCurTraceInfo saveCurTraceInfo;
   (timer->GetTracedTask()).SetTLSTraceInfo();
 #endif
 
   nsCOMPtr<nsIEventTarget> target = timer->mEventTarget;
   event->SetTimer(timer.forget());
 
-  nsresult rv;
-  {
-    // We release mMonitor around the Dispatch because if this timer is targeted
-    // at the TimerThread we'll deadlock.
+  nsresult rv = NS_OK;
+
+  // If the target allows locking around the Dispatch() method, then just
+  // call it.  Otherwise we must temporarily release mMonitor while
+  // calling Dispatch.  Otherwise its possible for a deadlock to occur.
+  nsCOMPtr<nsILockable> lockableTarget = do_QueryInterface(target);
+  if (lockableTarget) {
+    rv = target->Dispatch(event, NS_DISPATCH_NORMAL);
+  } else {
     MonitorAutoUnlock unlock(mMonitor);
     rv = target->Dispatch(event, NS_DISPATCH_NORMAL);
   }
 
   if (NS_FAILED(rv)) {
     timer = event->ForgetTimer();
     RemoveTimerInternal(timer);
     return timer.forget();
