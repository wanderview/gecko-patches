# HG changeset patch
# Parent 80431d4fd0dada87e7327eee3044146a3ec96c9f
# User Ben Kelly <ben@wanderview.com>
Bug 1025973 P1 Rename GlobalObject::GetContext() to Context()


diff --git a/content/base/src/WebSocket.cpp b/content/base/src/WebSocket.cpp
--- a/content/base/src/WebSocket.cpp
+++ b/content/base/src/WebSocket.cpp
@@ -554,17 +554,17 @@ WebSocket::Constructor(const GlobalObjec
       aRv.Throw(NS_ERROR_DOM_SYNTAX_ERR);
       return nullptr;
     }
 
     protocolArray.AppendElement(protocolElement);
   }
 
   nsRefPtr<WebSocket> webSocket = new WebSocket(ownerWindow);
-  nsresult rv = webSocket->Init(aGlobal.GetContext(), principal,
+  nsresult rv = webSocket->Init(aGlobal.Context(), principal,
                                 aUrl, protocolArray);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return nullptr;
   }
 
   return webSocket.forget();
 }
diff --git a/content/canvas/src/ImageData.cpp b/content/canvas/src/ImageData.cpp
--- a/content/canvas/src/ImageData.cpp
+++ b/content/canvas/src/ImageData.cpp
@@ -47,18 +47,18 @@ ImageData::Constructor(const GlobalObjec
     aRv.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
     return nullptr;
   }
   CheckedInt<uint32_t> length = CheckedInt<uint32_t>(aWidth) * aHeight * 4;
   if (!length.isValid()) {
     aRv.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
     return nullptr;
   }
-  js::AssertSameCompartment(aGlobal.GetContext(), aGlobal.Get());
-  JSObject* data = Uint8ClampedArray::Create(aGlobal.GetContext(),
+  js::AssertSameCompartment(aGlobal.Context(), aGlobal.Get());
+  JSObject* data = Uint8ClampedArray::Create(aGlobal.Context(),
                                              length.value());
   if (!data) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return nullptr;
   }
   return new ImageData(aWidth, aHeight, *data);
 }
 
diff --git a/content/media/eme/MediaKeyMessageEvent.cpp b/content/media/eme/MediaKeyMessageEvent.cpp
--- a/content/media/eme/MediaKeyMessageEvent.cpp
+++ b/content/media/eme/MediaKeyMessageEvent.cpp
@@ -81,19 +81,19 @@ MediaKeyMessageEvent::Constructor(const 
 {
   nsCOMPtr<EventTarget> owner = do_QueryInterface(aGlobal.GetAsSupports());
   nsRefPtr<MediaKeyMessageEvent> e = new MediaKeyMessageEvent(owner);
   bool trusted = e->Init(owner);
   e->InitEvent(aType, aEventInitDict.mBubbles, aEventInitDict.mCancelable);
   if (aEventInitDict.mMessage.WasPassed()) {
     const auto& a = aEventInitDict.mMessage.Value();
     a.ComputeLengthAndData();
-    e->mMessage = Uint8Array::Create(aGlobal.GetContext(), owner, a.Length(), a.Data());
+    e->mMessage = Uint8Array::Create(aGlobal.Context(), owner, a.Length(), a.Data());
   } else {
-    e->mMessage = Uint8Array::Create(aGlobal.GetContext(), owner, 0, nullptr);
+    e->mMessage = Uint8Array::Create(aGlobal.Context(), owner, 0, nullptr);
   }
   if (!e->mMessage) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return nullptr;
   }
   e->mDestinationURL = aEventInitDict.mDestinationURL;
   e->SetTrusted(trusted);
   return e.forget();
diff --git a/content/media/eme/MediaKeyNeededEvent.cpp b/content/media/eme/MediaKeyNeededEvent.cpp
--- a/content/media/eme/MediaKeyNeededEvent.cpp
+++ b/content/media/eme/MediaKeyNeededEvent.cpp
@@ -73,17 +73,17 @@ MediaKeyNeededEvent::Constructor(const G
   nsRefPtr<MediaKeyNeededEvent> e = new MediaKeyNeededEvent(owner);
   bool trusted = e->Init(owner);
   e->InitEvent(aType, aEventInitDict.mBubbles, aEventInitDict.mCancelable);
   e->mInitDataType = aEventInitDict.mInitDataType;
   if (aEventInitDict.mInitData.WasPassed() &&
       !aEventInitDict.mInitData.Value().IsNull()) {
     const auto& a = aEventInitDict.mInitData.Value().Value();
     a.ComputeLengthAndData();
-    e->mInitData = Uint8Array::Create(aGlobal.GetContext(), owner, a.Length(), a.Data());
+    e->mInitData = Uint8Array::Create(aGlobal.Context(), owner, a.Length(), a.Data());
     if (!e->mInitData) {
       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
       return nullptr;
     }
   }
   e->SetTrusted(trusted);
   return e.forget();
 }
diff --git a/dom/bindings/BindingDeclarations.h b/dom/bindings/BindingDeclarations.h
--- a/dom/bindings/BindingDeclarations.h
+++ b/dom/bindings/BindingDeclarations.h
@@ -65,17 +65,17 @@ public:
     return mGlobalJSObject;
   }
 
   nsISupports* GetAsSupports() const;
 
   // The context that this returns is not guaranteed to be in the compartment of
   // the object returned from Get(), in fact it's generally in the caller's
   // compartment.
-  JSContext* GetContext() const
+  JSContext* Context() const
   {
     return mCx;
   }
 
   bool Failed() const
   {
     return !Get();
   }
diff --git a/dom/bindings/BindingUtils.cpp b/dom/bindings/BindingUtils.cpp
--- a/dom/bindings/BindingUtils.cpp
+++ b/dom/bindings/BindingUtils.cpp
@@ -1830,16 +1830,17 @@ ReparentWrapper(JSContext* aCx, JS::Hand
   return NS_OK;
 }
 
 GlobalObject::GlobalObject(JSContext* aCx, JSObject* aObject)
   : mGlobalJSObject(aCx),
     mCx(aCx),
     mGlobalObject(nullptr)
 {
+  MOZ_ASSERT(mCx);
   JS::Rooted<JSObject*> obj(aCx, aObject);
   if (js::IsWrapper(obj)) {
     obj = js::CheckedUnwrap(obj, /* stopAtOuter = */ false);
     if (!obj) {
       // We should never end up here on a worker thread, since there shouldn't
       // be any security wrappers to worry about.
       if (!MOZ_LIKELY(NS_IsMainThread())) {
         MOZ_CRASH();
diff --git a/dom/promise/Promise.cpp b/dom/promise/Promise.cpp
--- a/dom/promise/Promise.cpp
+++ b/dom/promise/Promise.cpp
@@ -588,17 +588,17 @@ Promise::CreateThenableFunction(JSContex
 
   return obj;
 }
 
 /* static */ already_AddRefed<Promise>
 Promise::Constructor(const GlobalObject& aGlobal,
                      PromiseInit& aInit, ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
 
   nsCOMPtr<nsIGlobalObject> global;
   global = do_QueryInterface(aGlobal.GetAsSupports());
   if (!global) {
     aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
@@ -739,19 +739,19 @@ public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CountdownHolder)
 
   CountdownHolder(const GlobalObject& aGlobal, Promise* aPromise,
                   uint32_t aCountdown)
     : mPromise(aPromise), mCountdown(aCountdown)
   {
     MOZ_ASSERT(aCountdown != 0);
-    JSContext* cx = aGlobal.GetContext();
+    JSContext* cx = aGlobal.Context();
 
-    // The only time aGlobal.GetContext() and aGlobal.Get() are not
+    // The only time aGlobal.Context() and aGlobal.Get() are not
     // same-compartment is when we're called via Xrays, and in that situation we
     // in fact want to create the array in the callee compartment
 
     JSAutoCompartment ac(cx, aGlobal.Get());
     mValues = JS_NewArrayObject(cx, aCountdown);
     mozilla::HoldJSObjects(this);
   }
 
diff --git a/dom/src/notification/Notification.cpp b/dom/src/notification/Notification.cpp
--- a/dom/src/notification/Notification.cpp
+++ b/dom/src/notification/Notification.cpp
@@ -41,17 +41,17 @@ public:
   NotificationStorageCallback(const GlobalObject& aGlobal, nsPIDOMWindow* aWindow, Promise* aPromise)
     : mCount(0),
       mGlobal(aGlobal.Get()),
       mWindow(aWindow),
       mPromise(aPromise)
   {
     MOZ_ASSERT(aWindow);
     MOZ_ASSERT(aPromise);
-    JSContext* cx = aGlobal.GetContext();
+    JSContext* cx = aGlobal.Context();
     JSAutoCompartment ac(cx, mGlobal);
     mNotifications = JS_NewArrayObject(cx, 0);
     HoldData();
   }
 
   NS_IMETHOD Handle(const nsAString& aID,
                     const nsAString& aTitle,
                     const nsAString& aDir,
diff --git a/dom/workers/RuntimeService.cpp b/dom/workers/RuntimeService.cpp
--- a/dom/workers/RuntimeService.cpp
+++ b/dom/workers/RuntimeService.cpp
@@ -2118,17 +2118,17 @@ RuntimeService::CreateSharedWorkerIntern
                                            SharedWorker** aSharedWorker)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aType == WorkerTypeShared || aType == WorkerTypeService);
 
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal.GetAsSupports());
   MOZ_ASSERT(window);
 
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
 
   WorkerPrivate::LoadInfo loadInfo;
   nsresult rv = WorkerPrivate::GetLoadInfo(cx, window, nullptr, aScriptURL,
                                            false, &loadInfo);
   NS_ENSURE_SUCCESS(rv, rv);
 
   MOZ_ASSERT(loadInfo.mResolvedScriptURI);
 
diff --git a/dom/workers/URL.cpp b/dom/workers/URL.cpp
--- a/dom/workers/URL.cpp
+++ b/dom/workers/URL.cpp
@@ -470,17 +470,17 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 // static
 URL*
 URL::Constructor(const GlobalObject& aGlobal, const nsAString& aUrl,
                  URL& aBase, ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
   nsRefPtr<ConstructorRunnable> runnable =
     new ConstructorRunnable(workerPrivate, aUrl, aBase.GetURLProxy(), aRv);
 
   if (!runnable->Dispatch(cx)) {
     JS_ReportPendingException(cx);
   }
@@ -494,17 +494,17 @@ URL::Constructor(const GlobalObject& aGl
   return new URL(workerPrivate, proxy);
 }
 
 // static
 URL*
 URL::Constructor(const GlobalObject& aGlobal, const nsAString& aUrl,
                  const nsAString& aBase, ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
   nsRefPtr<ConstructorRunnable> runnable =
     new ConstructorRunnable(workerPrivate, aUrl, aBase, aRv);
 
   if (!runnable->Dispatch(cx)) {
     JS_ReportPendingException(cx);
   }
@@ -839,17 +839,17 @@ URL::SetHash(const nsAString& aHash)
 }
 
 // static
 void
 URL::CreateObjectURL(const GlobalObject& aGlobal, JSObject* aBlob,
                      const mozilla::dom::objectURLOptions& aOptions,
                      nsString& aResult, mozilla::ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
   nsCOMPtr<nsIDOMBlob> blob = file::GetDOMBlobFromJSObject(aBlob);
   if (!blob) {
     SetDOMStringToNull(aResult);
 
     NS_NAMED_LITERAL_STRING(argStr, "Argument 1 of URL.createObjectURL");
     NS_NAMED_LITERAL_STRING(blobStr, "Blob");
@@ -873,17 +873,17 @@ URL::CreateObjectURL(const GlobalObject&
 {
   return CreateObjectURL(aGlobal, &aBlob, aOptions, aResult, aRv);
 }
 
 // static
 void
 URL::RevokeObjectURL(const GlobalObject& aGlobal, const nsAString& aUrl)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
   nsRefPtr<RevokeURLRunnable> runnable =
     new RevokeURLRunnable(workerPrivate, aUrl);
 
   if (!runnable->Dispatch(cx)) {
     JS_ReportPendingException(cx);
   }
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -3624,17 +3624,17 @@ ChromeWorkerPrivate::WorkerAvailable(JSC
 // static
 already_AddRefed<WorkerPrivate>
 WorkerPrivate::Constructor(const GlobalObject& aGlobal,
                            const nsAString& aScriptURL,
                            bool aIsChromeWorker, WorkerType aWorkerType,
                            const nsACString& aSharedWorkerName,
                            LoadInfo* aLoadInfo, ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   return Constructor(cx, aScriptURL, aIsChromeWorker, aWorkerType,
                      aSharedWorkerName, aLoadInfo, aRv);
 }
 
 // static
 already_AddRefed<WorkerPrivate>
 WorkerPrivate::Constructor(JSContext* aCx,
                            const nsAString& aScriptURL,
diff --git a/dom/workers/XMLHttpRequest.cpp b/dom/workers/XMLHttpRequest.cpp
--- a/dom/workers/XMLHttpRequest.cpp
+++ b/dom/workers/XMLHttpRequest.cpp
@@ -1622,17 +1622,17 @@ XMLHttpRequest::WrapObject(JSContext* aC
 }
 
 // static
 already_AddRefed<XMLHttpRequest>
 XMLHttpRequest::Constructor(const GlobalObject& aGlobal,
                             const MozXMLHttpRequestParameters& aParams,
                             ErrorResult& aRv)
 {
-  JSContext* cx = aGlobal.GetContext();
+  JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
   MOZ_ASSERT(workerPrivate);
 
   nsRefPtr<XMLHttpRequest> xhr = new XMLHttpRequest(workerPrivate);
 
   if (workerPrivate->XHRParamsAllowed()) {
     if (aParams.mMozSystem)
       xhr->mMozAnon = true;
diff --git a/dom/workers/XMLHttpRequest.h b/dom/workers/XMLHttpRequest.h
--- a/dom/workers/XMLHttpRequest.h
+++ b/dom/workers/XMLHttpRequest.h
@@ -83,17 +83,17 @@ public:
               ErrorResult& aRv);
 
   static already_AddRefed<XMLHttpRequest>
   Constructor(const GlobalObject& aGlobal, const nsAString& ignored,
               ErrorResult& aRv)
   {
     // Pretend like someone passed null, so we can pick up the default values
     MozXMLHttpRequestParameters params;
-    if (!params.Init(aGlobal.GetContext(), JS::NullHandleValue)) {
+    if (!params.Init(aGlobal.Context(), JS::NullHandleValue)) {
       aRv.Throw(NS_ERROR_UNEXPECTED);
       return nullptr;
     }
 
     return Constructor(aGlobal, params, aRv);
   }
 
   void
