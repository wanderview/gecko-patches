# HG changeset patch
# Parent 14097418960c369025b3ab293bc01be5af065564
# User Ben Kelly <ben@wanderview.com>
Support async actor creation in CacheStorage.

diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -2,19 +2,19 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorage.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/CacheStorageBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
-#include "mozilla/dom/CacheStorageBinding.h"
 #include "mozilla/dom/cache/Cache.h"
 #include "mozilla/dom/cache/CacheStorageChild.h"
 #include "mozilla/dom/cache/PCacheChild.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "nsIGlobalObject.h"
@@ -47,16 +47,17 @@ CacheStorage::CacheStorage(Namespace aNa
                            const nsACString& aOrigin,
                            const nsACString& aBaseDomain)
   : mNamespace(aNamespace)
   , mOwner(aOwner)
   , mGlobal(aGlobal)
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
   , mActor(nullptr)
+  , mFailedActor(false)
 {
   MOZ_ASSERT(mGlobal);
 
   if (mOrigin.EqualsLiteral("null") || mBaseDomain.EqualsLiteral("")) {
     ActorFailed();
     return;
   }
 
@@ -70,138 +71,205 @@ CacheStorage::CacheStorage(Namespace aNa
     }
   }
 }
 
 already_AddRefed<Promise>
 CacheStorage::Match(const RequestOrScalarValueString& aRequest,
                     const QueryParams& aParams, ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_MATCH;
+    entry->mArgs.mMatchArgs.mParams = aParams;
+
+    if (aRequest.IsScalarValueString()) {
+      *entry->mArgs.mMatchArgs.mRequest.SetAsScalarValueString().ToAStringPtr() =
+        aRequest.GetAsScalarValueString();
+    } else {
+      entry->mArgs.mMatchArgs.mRequest.SetAsRequest() =
+        &aRequest.GetAsRequest();
+    }
+
+    return promise.forget();
   }
 
   PCacheRequest request;
   TypeUtils::ToPCacheRequest(request, aRequest);
 
   PCacheQueryParams params;
   TypeUtils::ToPCacheQueryParams(params, aParams);
 
   unused << mActor->SendMatch(requestId, request, params);
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Get(const nsAString& aKey, ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_GET;
+    entry->mArgs.mStandardArgs.mKey = aKey;
+
+    return promise.forget();
   }
 
   unused << mActor->SendGet(requestId, nsString(aKey));
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Has(const nsAString& aKey, ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_HAS;
+    entry->mArgs.mStandardArgs.mKey = aKey;
+
+    return promise.forget();
   }
 
   unused << mActor->SendHas(requestId, nsString(aKey));
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Create(const nsAString& aKey, ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_CREATE;
+    entry->mArgs.mStandardArgs.mKey = aKey;
+
+    return promise.forget();
   }
 
   unused << mActor->SendCreate(requestId, nsString(aKey));
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Delete(const nsAString& aKey, ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_DELETE;
+    entry->mArgs.mStandardArgs.mKey = aKey;
+
+    return promise.forget();
   }
 
   unused << mActor->SendDelete(requestId, nsString(aKey));
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 CacheStorage::Keys(ErrorResult& aRv)
 {
-  // TODO: properly handle async actor creation
-  MOZ_ASSERT(mActor);
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = Promise::Create(mGlobal, aRv);
   if (!promise) {
     return nullptr;
   }
 
+  if (mFailedActor) {
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+    return promise.forget();
+  }
+
   RequestId requestId = AddRequestPromise(promise, aRv);
-  if (requestId == INVALID_REQUEST_ID) {
-    return nullptr;
+
+  if (!mActor) {
+    Entry* entry = mPendingRequests.AppendElement();
+    entry->mRequestId = requestId;
+    entry->mOp = OP_KEYS;
+
+    return promise.forget();
   }
 
   unused << mActor->SendKeys(requestId);
 
   return promise.forget();
 }
 
 // static
@@ -221,16 +289,17 @@ JSObject*
 CacheStorage::WrapObject(JSContext* aContext)
 {
   return mozilla::dom::CacheStorageBinding::Wrap(aContext, this);
 }
 
 void
 CacheStorage::ActorCreated(PBackgroundChild* aActor)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(aActor);
 
   CacheStorageChild* newActor = new CacheStorageChild(*this);
   if (NS_WARN_IF(!newActor)) {
     ActorFailed();
     return;
   }
 
@@ -240,40 +309,88 @@ CacheStorage::ActorCreated(PBackgroundCh
 
   if (NS_WARN_IF(!constructedActor)) {
     ActorFailed();
     return;
   }
 
   MOZ_ASSERT(constructedActor == newActor);
   mActor = newActor;
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    Entry& entry = mPendingRequests[i];
+    RequestId requestId = entry.mRequestId;
+    switch(entry.mOp) {
+      case OP_MATCH:
+      {
+        PCacheRequest request;
+        TypeUtils::ToPCacheRequest(request, entry.mArgs.mMatchArgs.mRequest);
+
+        PCacheQueryParams params;
+        TypeUtils::ToPCacheQueryParams(params, entry.mArgs.mMatchArgs.mParams);
+
+        unused << mActor->SendMatch(requestId, request, params);
+        break;
+      }
+      case OP_GET:
+        unused << mActor->SendGet(requestId, entry.mArgs.mStandardArgs.mKey);
+        break;
+      case OP_HAS:
+        unused << mActor->SendHas(requestId, entry.mArgs.mStandardArgs.mKey);
+        break;
+      case OP_CREATE:
+        unused << mActor->SendCreate(requestId, entry.mArgs.mStandardArgs.mKey);
+        break;
+      case OP_DELETE:
+        unused << mActor->SendDelete(requestId, entry.mArgs.mStandardArgs.mKey);
+        break;
+      case OP_KEYS:
+        unused << mActor->SendKeys(requestId);
+        break;
+    }
+  }
+  mPendingRequests.Clear();
 }
 
 void
 CacheStorage::ActorFailed()
 {
-  // TODO: This should reject any pending Promises and cause all future
-  //       Promises created by this object to immediately reject.
-  MOZ_CRASH("not implemented");
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+  MOZ_ASSERT(!mFailedActor);
+
+  mFailedActor = true;
+
+  for (uint32_t i = 0; i < mPendingRequests.Length(); ++i) {
+    RequestId requestId = mPendingRequests[i].mRequestId;
+    nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
+    if (!promise) {
+      continue;
+    }
+    promise->MaybeReject(NS_ERROR_UNEXPECTED);
+  }
+  mPendingRequests.Clear();
 }
 
 void
 CacheStorage::ActorDestroy(IProtocol& aActor)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 CacheStorage::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                                 const PCacheResponseOrVoid& aResponse,
                                 PCacheStreamControlChild* aStreamControl)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
@@ -288,16 +405,18 @@ CacheStorage::RecvMatchResponse(RequestI
                                                       aStreamControl);
   promise->MaybeResolve(response);
 }
 
 void
 CacheStorage::RecvGetResponse(RequestId aRequestId, nsresult aRv,
                               PCacheChild* aActor)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     if (aActor) {
       PCacheChild::Send__delete__(aActor);
     }
     return;
   }
 
@@ -314,16 +433,18 @@ CacheStorage::RecvGetResponse(RequestId 
   nsRefPtr<Cache> cache = new Cache(mOwner, mGlobal, mOrigin, mBaseDomain,
                                     aActor);
   promise->MaybeResolve(cache);
 }
 
 void
 CacheStorage::RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
@@ -332,16 +453,18 @@ CacheStorage::RecvHasResponse(RequestId 
 
   promise->MaybeResolve(aSuccess);
 }
 
 void
 CacheStorage::RecvCreateResponse(RequestId aRequestId, nsresult aRv,
                                  PCacheChild* aActor)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     if (aActor) {
       PCacheChild::Send__delete__(aActor);
     }
     return;
   }
 
@@ -359,16 +482,18 @@ CacheStorage::RecvCreateResponse(Request
                                     aActor);
   promise->MaybeResolve(cache);
 }
 
 void
 CacheStorage::RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                  bool aSuccess)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
@@ -376,60 +501,60 @@ CacheStorage::RecvDeleteResponse(Request
 
   promise->MaybeResolve(aSuccess);
 }
 
 void
 CacheStorage::RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                                const nsTArray<nsString>& aKeys)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   promise->MaybeResolve(aKeys);
 }
 
 CacheStorage::~CacheStorage()
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
+
   if (mActor) {
     mActor->ClearListener();
     PCacheStorageChild::Send__delete__(mActor);
     // The actor will be deleted by the IPC manager
     mActor = nullptr;
   }
 }
 
 RequestId
 CacheStorage::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(aPromise);
 
-  nsRefPtr<Promise>* ref = mRequestPromises.AppendElement();
-  if (!ref) {
-    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
-    return INVALID_REQUEST_ID;
-  }
-
-  *ref = aPromise;
+  mRequestPromises.AppendElement(aPromise);
 
   // (Ab)use the promise pointer as our request ID.  This is a fast, thread-safe
   // way to get a unique ID for the promise to be resolved later.
   return reinterpret_cast<RequestId>(aPromise);
 }
 
 already_AddRefed<Promise>
 CacheStorage::RemoveRequestPromise(RequestId aRequestId)
 {
+  NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(aRequestId != INVALID_REQUEST_ID);
 
   for (uint32_t i = 0; i < mRequestPromises.Length(); ++i) {
     nsRefPtr<Promise>& promise = mRequestPromises.ElementAt(i);
     // To be safe, only cast promise pointers to our integer RequestId
     // type and never cast an integer to a pointer.
     if (aRequestId == reinterpret_cast<RequestId>(promise.get())) {
       nsRefPtr<Promise> ref;
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorage_h
 #define mozilla_dom_cache_CacheStorage_h
 
+#include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/cache/CacheStorageChildListener.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
@@ -24,18 +25,18 @@ class ErrorResult;
 
 namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
 
 class Promise;
-struct QueryParams;
-class RequestOrScalarValueString;
+//struct QueryParams;
+//class RequestOrScalarValueString;
 
 namespace cache {
 
 class CacheStorageChild;
 
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public CacheStorageChildListener
@@ -91,16 +92,60 @@ private:
   const Namespace mNamespace;
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheStorageChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
+  enum Op
+  {
+    OP_MATCH,
+    OP_GET,
+    OP_HAS,
+    OP_CREATE,
+    OP_DELETE,
+    OP_KEYS
+  };
+
+  struct MatchArgs
+  {
+    // Would prefer to use PCacheRequest/PCacheQueryParams, but can't
+    // because they introduce a header dependency on windows.h which
+    // breaks the bindings build.
+    RequestOrScalarValueString mRequest;
+    QueryParams mParams;
+  };
+
+  struct StandardArgs
+  {
+    nsString mKey;
+  };
+
+  union Args
+  {
+    Args() { }
+    ~Args() { }
+    MatchArgs mMatchArgs;
+    StandardArgs mStandardArgs;
+  };
+
+  struct Entry
+  {
+    Entry() { }
+    ~Entry() { }
+    RequestId mRequestId;
+    Op mOp;
+    Args mArgs;
+  };
+
+  nsTArray<Entry> mPendingRequests;
+  bool mFailedActor;
+
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CacheStorage)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
