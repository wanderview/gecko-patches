# HG changeset patch
# Parent 3459e7e21196a95135a1072a0f22a4c17a4b19b0
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -63,16 +63,17 @@ public:
   {
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
   {
     // Resolve success immediately.  This Action does no actual work.
     MOZ_ASSERT(aResolver);
+    printf_stderr("### ### NullAction::RunOnTarget()\n");
     aResolver->Resolve(NS_OK);
   }
 };
 
 } // anonymous namespace
 
 namespace mozilla {
 namespace dom {
@@ -86,39 +87,50 @@ using mozilla::dom::quota::PersistenceTy
 
 class Context::Data final : public Action::Data
 {
 public:
   Data(nsIThread* aTarget)
     : mTarget(aTarget)
   {
     MOZ_ASSERT(mTarget);
+    printf_stderr("### ### [%p] Data()\n", this);
   }
 
   virtual mozIStorageConnection*
   GetConnection() const
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     return mConnection;
   }
 
   virtual void
   SetConnection(mozIStorageConnection* aConn) override
   {
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     MOZ_ASSERT(!mConnection);
+    printf_stderr("### ### [%p] Data::SetConnection()\n", this);
     mConnection = aConn;
     MOZ_ASSERT(mConnection);
   }
 
 private:
   ~Data()
   {
+    printf_stderr("### ### [%p] ~Data() mConnection:%p\n", this, mConnection.get());
     if (mConnection) {
+      if (mTarget == NS_GetCurrentThread()) {
+        //printf_stderr("### ### [%p] ~Data() closing connection\n", this);
+        //mConnection->Close();
+        printf_stderr("### ### [%p] ~Data() release connection\n", this);
+      } else {
+        printf_stderr("### ### [%p] ~Data() proxy release connection\n", this);
+      }
       NS_ProxyRelease(mTarget, mConnection);
+      MOZ_ASSERT(!mConnection);
     }
   }
 
   nsCOMPtr<nsIThread> mTarget;
   nsCOMPtr<mozIStorageConnection> mConnection;
 
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(Context::Data)
 };
@@ -530,16 +542,17 @@ private:
     MOZ_ASSERT(!mAction);
   }
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mAction);
+    printf_stderr("### ### ActionRunnable::Clear()\n");
     mContext->RemoveActivity(this);
     mContext = nullptr;
     mAction = nullptr;
   }
 
   enum State
   {
     STATE_INIT,
@@ -797,16 +810,17 @@ Context::Create(Manager* aManager, nsITh
 
 Context::Context(Manager* aManager, nsIThread* aTarget)
   : mManager(aManager)
   , mTarget(aTarget)
   , mData(new Data(aTarget))
   , mState(STATE_CONTEXT_PREINIT)
 {
   MOZ_ASSERT(mManager);
+  printf_stderr("### ### [%p] Context()\n", this);
 }
 
 void
 Context::Dispatch(Action* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(aAction);
 
@@ -898,16 +912,18 @@ Context::CancelForCacheId(CacheId aCache
   }
 }
 
 Context::~Context()
 {
   NS_ASSERT_OWNINGTHREAD(Context);
   MOZ_ASSERT(mManager);
 
+  printf_stderr("### ### [%p] ~Context()\n", this);
+
   if (mThreadsafeHandle) {
     mThreadsafeHandle->ContextDestroyed(this);
   }
 
   mManager->RemoveContext(this);
 
   if (mNextContext) {
     mNextContext->Start();
@@ -1042,16 +1058,17 @@ Context::DoomTargetData()
   // We are about to drop our reference to the Data.  We need to ensure that
   // the ~Context() destructor does not run until contents of Data have been
   // released on the Target thread.
 
   // Dispatch a no-op Action.  This will hold the Context alive through a
   // roundtrip to the target thread and back to the owning thread.  The
   // ref to the Data object is cleared on the owning thread after creating
   // the ActionRunnable, but before dispatching it.
+  printf_stderr("### ### [%p] Context::DoomTargetData() mState:%u\n", this, mState);
   nsRefPtr<Action> action = new NullAction();
   DispatchAction(action, true /* doomed data */);
 
   MOZ_ASSERT(!mData);
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/OfflineStorage.cpp b/dom/cache/OfflineStorage.cpp
--- a/dom/cache/OfflineStorage.cpp
+++ b/dom/cache/OfflineStorage.cpp
@@ -58,23 +58,26 @@ OfflineStorage::OfflineStorage(Context::
                                Client* aClient)
   : mContext(aContext)
   , mQuotaInfo(aQuotaInfo)
   , mClient(aClient)
 {
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mClient);
 
+  printf_stderr("### ### [%p] OfflineStorage()\n", this);
+
   mPersistenceType = PERSISTENCE_TYPE_DEFAULT;
   mGroup = mQuotaInfo.mGroup;
 }
 
 OfflineStorage::~OfflineStorage()
 {
   MOZ_ASSERT(NS_IsMainThread());
+  printf_stderr("### ### [%p] ~OfflineStorage()\n", this);
   QuotaManager* qm = QuotaManager::Get();
   MOZ_ASSERT(qm);
   qm->UnregisterStorage(this);
   for (uint32_t i = 0; i < mDestroyCallbacks.Length(); ++i) {
     mDestroyCallbacks[i]->Run();
   }
 }
 
diff --git a/storage/src/mozStorageConnection.cpp b/storage/src/mozStorageConnection.cpp
--- a/storage/src/mozStorageConnection.cpp
+++ b/storage/src/mozStorageConnection.cpp
@@ -498,16 +498,17 @@ Connection::Connection(Service *aService
 , mStorageService(aService)
 , mAsyncOnly(aAsyncOnly)
 {
   mStorageService->registerConnection(this);
 }
 
 Connection::~Connection()
 {
+  printf_stderr("### ### [%p] ~Connection()\n", this);
   (void)Close();
 
   MOZ_ASSERT(!mAsyncExecutionThread,
              "AsyncClose has not been invoked on this connection!");
   MOZ_ASSERT(!mAsyncExecutionThreadIsAlive,
              "The async execution thread should have been shutdown!");
 }
 
@@ -1141,16 +1142,17 @@ Connection::GetInterface(const nsIID &aI
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 //// mozIStorageConnection
 
 NS_IMETHODIMP
 Connection::Close()
 {
+  printf_stderr("### ### [%p] Connection::Close()\n", this);
   if (!mDBConn)
     return NS_ERROR_NOT_INITIALIZED;
 
   { // Make sure we have not executed any asynchronous statements.
     // If this fails, the mDBConn will be left open, resulting in a leak.
     // Ideally we'd schedule some code to destroy the mDBConn once all its
     // async statements have finished executing;  see bug 704030.
     MutexAutoLock lockedScope(sharedAsyncExecutionMutex);
