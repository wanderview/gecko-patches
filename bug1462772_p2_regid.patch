# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dd38fbb0271c01d5d071e33a8936a3f87cbf7742
Bug 1462772 P2 Add the registration Id to the ServiceWorkerDescriptor. r=mrbkap

diff --git a/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh b/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
--- a/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
+++ b/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
@@ -10,16 +10,17 @@ namespace mozilla {
 namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Note that the state may be slightly out-of-sync
 // with the parent and should be updated dynamically if necessary.
 struct IPCServiceWorkerDescriptor
 {
   uint64_t id;
+  uint64_t registrationId;
   PrincipalInfo principalInfo;
   nsCString scope;
   nsCString scriptURL;
   ServiceWorkerState state;
 };
 
 union OptionalIPCServiceWorkerDescriptor
 {
diff --git a/dom/serviceworkers/ServiceWorkerDescriptor.cpp b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
@@ -11,37 +11,41 @@
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::PrincipalInfo;
 using mozilla::ipc::PrincipalInfoToPrincipal;
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(uint64_t aId,
+                                                 uint64_t aRegistrationId,
                                                  nsIPrincipal* aPrincipal,
                                                  const nsACString& aScope,
                                                  const nsACString& aScriptURL,
                                                  ServiceWorkerState aState)
   : mData(MakeUnique<IPCServiceWorkerDescriptor>())
 {
   MOZ_ALWAYS_SUCCEEDS(
     PrincipalToPrincipalInfo(aPrincipal, &mData->principalInfo()));
 
   mData->id() = aId;
+  mData->registrationId() = aRegistrationId;
   mData->scope() = aScope;
   mData->scriptURL() = aScriptURL;
   mData->state() = aState;
 }
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(uint64_t aId,
+                                                 uint64_t aRegistrationId,
                                                  const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                                                  const nsACString& aScope,
                                                  const nsACString& aScriptURL,
                                                  ServiceWorkerState aState)
-  : mData(MakeUnique<IPCServiceWorkerDescriptor>(aId, aPrincipalInfo,
+  : mData(MakeUnique<IPCServiceWorkerDescriptor>(aId, aRegistrationId,
+                                                 aPrincipalInfo,
                                                  nsCString(aScriptURL),
                                                  nsCString(aScope), aState))
 {
 }
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(const IPCServiceWorkerDescriptor& aDescriptor)
   : mData(MakeUnique<IPCServiceWorkerDescriptor>(aDescriptor))
 {
@@ -87,16 +91,22 @@ ServiceWorkerDescriptor::operator==(cons
 }
 
 uint64_t
 ServiceWorkerDescriptor::Id() const
 {
   return mData->id();
 }
 
+uint64_t
+ServiceWorkerDescriptor::RegistrationId() const
+{
+  return mData->registrationId();
+}
+
 const mozilla::ipc::PrincipalInfo&
 ServiceWorkerDescriptor::PrincipalInfo() const
 {
   return mData->principalInfo();
 }
 
 nsCOMPtr<nsIPrincipal>
 ServiceWorkerDescriptor::GetPrincipal() const
diff --git a/dom/serviceworkers/ServiceWorkerDescriptor.h b/dom/serviceworkers/ServiceWorkerDescriptor.h
--- a/dom/serviceworkers/ServiceWorkerDescriptor.h
+++ b/dom/serviceworkers/ServiceWorkerDescriptor.h
@@ -31,22 +31,24 @@ class ServiceWorkerDescriptor final
 {
   // This class is largely a wrapper around an IPDL generated struct.  We
   // need the wrapper class since IPDL generated code includes windows.h
   // which is in turn incompatible with bindings code.
   UniquePtr<IPCServiceWorkerDescriptor> mData;
 
 public:
   ServiceWorkerDescriptor(uint64_t aId,
+                          uint64_t aRegistrationId,
                           nsIPrincipal* aPrincipal,
                           const nsACString& aScope,
                           const nsACString& aScriptURL,
                           ServiceWorkerState aState);
 
   ServiceWorkerDescriptor(uint64_t aId,
+                          uint64_t aRegistrationId,
                           const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                           const nsACString& aScope,
                           const nsACString& aScriptURL,
                           ServiceWorkerState aState);
 
   explicit ServiceWorkerDescriptor(const IPCServiceWorkerDescriptor& aDescriptor);
 
   ServiceWorkerDescriptor(const ServiceWorkerDescriptor& aRight);
@@ -62,16 +64,19 @@ public:
   ~ServiceWorkerDescriptor();
 
   bool
   operator==(const ServiceWorkerDescriptor& aRight) const;
 
   uint64_t
   Id() const;
 
+  uint64_t
+  RegistrationId() const;
+
   const mozilla::ipc::PrincipalInfo&
   PrincipalInfo() const;
 
   nsCOMPtr<nsIPrincipal>
   GetPrincipal() const;
 
   const nsCString&
   Scope() const;
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -176,21 +176,22 @@ ServiceWorkerInfo::UpdateState(ServiceWo
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
   if (State() == ServiceWorkerState::Redundant) {
     serviceWorkerScriptCache::PurgeCache(mPrincipal, mCacheName);
   }
 }
 
 ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                                      const nsACString& aScope,
+                                     uint64_t aRegistrationId,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName,
                                      nsLoadFlags aImportsLoadFlags)
   : mPrincipal(aPrincipal)
-  , mDescriptor(GetNextID(), aPrincipal, aScope, aScriptSpec,
+  , mDescriptor(GetNextID(), aRegistrationId, aPrincipal, aScope, aScriptSpec,
                 ServiceWorkerState::Parsed)
   , mCacheName(aCacheName)
   , mImportsLoadFlags(aImportsLoadFlags)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mInstalledTime(0)
   , mActivatedTime(0)
   , mRedundantTime(0)
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -137,16 +137,17 @@ public:
   void SetSkipWaitingFlag()
   {
     MOZ_ASSERT(NS_IsMainThread());
     mSkipWaitingFlag = true;
   }
 
   ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                     const nsACString& aScope,
+                    uint64_t aRegistrationId,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName,
                     nsLoadFlags aLoadFlags);
 
   ServiceWorkerState
   State() const
   {
     return mDescriptor.State();
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -1569,16 +1569,17 @@ ServiceWorkerManager::LoadRegistration(
       ? nsIRequest::LOAD_NORMAL
       : nsIRequest::VALIDATE_ALWAYS;
 
   const nsCString& currentWorkerURL = aRegistration.currentWorkerURL();
   if (!currentWorkerURL.IsEmpty()) {
     registration->SetActive(
       new ServiceWorkerInfo(registration->Principal(),
                             registration->Scope(),
+                            registration->Id(),
                             currentWorkerURL,
                             aRegistration.cacheName(),
                             importsLoadFlags));
     registration->GetActive()->SetHandlesFetch(aRegistration.currentWorkerHandlesFetch());
     registration->GetActive()->SetInstalledTime(aRegistration.currentWorkerInstalledTime());
     registration->GetActive()->SetActivatedTime(aRegistration.currentWorkerActivatedTime());
   }
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -724,16 +724,22 @@ ServiceWorkerRegistrationInfo::SetLastUp
 }
 
 const ServiceWorkerRegistrationDescriptor&
 ServiceWorkerRegistrationInfo::Descriptor() const
 {
   return mDescriptor;
 }
 
+uint64_t
+ServiceWorkerRegistrationInfo::Id() const
+{
+  return mDescriptor.Id();
+}
+
 uint32_t
 ServiceWorkerRegistrationInfo::GetUpdateDelay()
 {
   uint32_t delay = Preferences::GetInt("dom.serviceWorkers.update_delay",
                                        1000);
   // This can potentially happen if you spam registration->Update(). We don't
   // want to wrap to a lower value.
   if (mDelayMultiplier >= INT_MAX / (delay ? delay : 1)) {
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
@@ -216,16 +216,19 @@ public:
   GetLastUpdateTime() const;
 
   void
   SetLastUpdateTime(const int64_t aTime);
 
   const ServiceWorkerRegistrationDescriptor&
   Descriptor() const;
 
+  uint64_t
+  Id() const;
+
   uint32_t
   GetUpdateDelay();
 
 private:
   // Roughly equivalent to [[Update Registration State algorithm]]. Make sure
   // this is called *before* updating SW instances' state, otherwise they
   // may get CC-ed.
   void
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -456,16 +456,17 @@ ServiceWorkerUpdateJob::ComparisonResult
   nsLoadFlags flags = aLoadFlags;
   if (GetUpdateViaCache() == ServiceWorkerUpdateViaCache::None) {
     flags |= nsIRequest::VALIDATE_ALWAYS;
   }
 
   RefPtr<ServiceWorkerInfo> sw =
     new ServiceWorkerInfo(mRegistration->Principal(),
                           mRegistration->Scope(),
+                          mRegistration->Id(),
                           mScriptSpec,
                           aNewCacheName,
                           flags);
 
   // If the registration is corrupt enough to force an uninstall if the
   // upgrade fails, then we want to make sure the upgrade takes effect
   // if it succeeds.  Therefore force the skip-waiting flag on to replace
   // the broken worker after install.
