# HG changeset patch
# Parent 41fd4412b269275007910d2f4f52f422a1a11a79
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 053 address shutdown review feedback


diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -135,17 +135,18 @@ namespace cache {
 
 // Singleton class to track Manager instances and ensure there is only
 // one for each unique ManagerId.
 class Manager::Factory
 {
 public:
   friend class StaticAutoPtr<Manager::Factory>;
 
-  static nsresult GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut)
+  static nsresult
+  GetOrCreate(ManagerId* aManagerId, Manager** aManagerOut)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     // Ensure there is a factory instance.  This forces the Get() call
     // below to use the same factory.
     nsresult rv = MaybeCreateInstance();
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -153,26 +154,27 @@ public:
     if (!ref) {
       // TODO: replace this with a thread pool (bug 1119864)
       nsCOMPtr<nsIThread> ioThread;
       rv = NS_NewNamedThread("DOMCacheThread", getter_AddRefs(ioThread));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
       ref = new Manager(aManagerId, ioThread);
 
-      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref.get()));
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
       sFactory->mManagerList.AppendElement(ref);
     }
 
     ref.forget(aManagerOut);
 
     return NS_OK;
   }
 
-  static already_AddRefed<Manager> Get(ManagerId* aManagerId)
+  static already_AddRefed<Manager>
+  Get(ManagerId* aManagerId)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     nsresult rv = MaybeCreateInstance();
     if (NS_WARN_IF(NS_FAILED(rv))) { return nullptr; }
 
     ManagerList::ForwardIterator iter(sFactory->mManagerList);
     while (iter.HasMore()) {
@@ -180,95 +182,95 @@ public:
       if (*manager->mManagerId == *aManagerId) {
         return manager.forget();
       }
     }
 
     return nullptr;
   }
 
-  static void Remove(Manager* aManager)
+  static void
+  Remove(Manager* aManager)
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(aManager);
-
-    nsresult rv = MaybeCreateInstance();
-    if (NS_FAILED(rv)) {
-      MOZ_CRASH("Removing Manager after Manager::Factory fully shutdown!");
-    }
+    MOZ_ASSERT(sFactory);
 
     MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
 
     // clean up the factory singleton if there are no more managers
     if (sFactory->mManagerList.IsEmpty()) {
       DestroyInstance();
     }
   }
 
-  static void StartShutdownAllOnMainThread()
+  static void
+  StartShutdownAllOnMainThread()
   {
     MOZ_ASSERT(NS_IsMainThread());
 
-    // Lock for sFactoryShutdown, sFactoryShutdownComplete, and
-    // sBackgroundThread.
+    // Lock for sFactoryShutdown and sBackgroundThread.
     StaticMutexAutoLock lock(sMutex);
 
     sFactoryShutdown = true;
 
     if (!sBackgroundThread) {
-      sFactoryShutdownComplete = true;
       return;
     }
 
     // Guaranteed to succeed because we should be shutdown before the
     // background thread is destroyed.
     nsCOMPtr<nsIRunnable> runnable = new ShutdownAllRunnable();
     nsresult rv = sBackgroundThread->Dispatch(runnable,
                                               nsIThread::DISPATCH_NORMAL);
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
   }
 
-  static bool IsShutdownAllCompleteOnMainThread()
+  static bool
+  IsShutdownAllCompleteOnMainThread()
   {
     MOZ_ASSERT(NS_IsMainThread());
     StaticMutexAutoLock lock(sMutex);
-    return sFactoryShutdownComplete;
+    // Infer whether we have shutdown using the sBackgroundThread value.  We
+    // guarantee this is nullptr when sFactory is destroyed.
+    return sFactoryShutdown && !sBackgroundThread;
   }
 
 private:
   Factory()
   {
     MOZ_COUNT_CTOR(cache::Manager::Factory);
   }
 
   ~Factory()
   {
     MOZ_COUNT_DTOR(cache::Manager::Factory);
     MOZ_ASSERT(mManagerList.IsEmpty());
   }
 
-  static nsresult MaybeCreateInstance()
+  static nsresult
+  MaybeCreateInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
       // Be clear about what we are locking.  sFactory is bg thread only, so
       // we don't need to lock it here.  Just protect sFactoryShutdown and
       // sBackgroundThread.
       {
         StaticMutexAutoLock lock(sMutex);
 
         if (sFactoryShutdown) {
           return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
         }
-        MOZ_ASSERT(!sFactoryShutdownComplete);
 
         // Cannot use ClearOnShutdown() because we're on the background thread.
         // This is automatically cleared when Factory::Remove() calls
         // DestroyInstance().
+        MOZ_ASSERT(!sBackgroundThread);
         sBackgroundThread = NS_GetCurrentThread();
       }
 
       // We cannot use ClearOnShutdown() here because we're not on the main
       // thread.  Instead, we delete sFactory in Factory::Remove() after the
       // last manager is removed.  ShutdownObserver ensures this happens
       // before shutdown.
       sFactory = new Factory();
@@ -277,65 +279,64 @@ private:
     // Never return sFactory to code outside Factory.  We need to delete it
     // out from under ourselves just before we return from Remove().  This
     // would be (even more) dangerous if other code had a pointer to the
     // factory itself.
 
     return NS_OK;
   }
 
-  static void DestroyInstance()
+  static void
+  DestroyInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(sFactory);
 
     // Be clear about what we are locking.  sFactory is bg thread only, so
-    // we don't need to lock it here.  Just protect sFactoryShutdown,
-    // sFactoryShutdownComplete, and sBackgroundThread.
+    // we don't need to lock it here.  Just protect sBackgroundThread.
     {
       StaticMutexAutoLock lock(sMutex);
-      MOZ_ASSERT(!sFactoryShutdownComplete);
-
-      if (sFactoryShutdown) {
-        sFactoryShutdownComplete = true;
-      }
-
+      MOZ_ASSERT(sBackgroundThread);
       sBackgroundThread = nullptr;
     }
 
     sFactory = nullptr;
   }
 
-  static void ShutdownAllOnBackgroundThread()
+  static void
+  ShutdownAllOnBackgroundThread()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     // The factory shutdown between when shutdown started on main thread and
     // when we could start shutdown on the worker thread.  Just declare
     // shutdown complete.  The sFactoryShutdown flag prevents the factory
     // from racing to restart here.
     if (!sFactory) {
+#ifdef DEBUG
       StaticMutexAutoLock lock(sMutex);
-      sFactoryShutdownComplete = true;
+      MOZ_ASSERT(!sBackgroundThread);
+#endif
       return;
     }
 
     MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
 
     ManagerList::ForwardIterator iter(sFactory->mManagerList);
     while (iter.HasMore()) {
       nsRefPtr<Manager> manager = iter.GetNext();
       manager->Shutdown();
     }
   }
 
-  class ShutdownAllRunnable : public nsRunnable
+  class ShutdownAllRunnable MOZ_FINAL : public nsRunnable
   {
   public:
-    NS_IMETHOD Run()
+    NS_IMETHOD
+    Run() MOZ_OVERRIDE
     {
       mozilla::ipc::AssertIsOnBackgroundThread();
       ShutdownAllOnBackgroundThread();
       return NS_OK;
     }
   private:
     ~ShutdownAllRunnable() { }
   };
@@ -347,21 +348,16 @@ private:
 
   // protects following static attributes
   static StaticMutex sMutex;
 
   // Indicate if shutdown has occurred to block re-creation of sFactory.
   // Must hold sMutex to access.
   static bool sFactoryShutdown;
 
-  // Set after ShutdownAll() and after all Manager objects have removed
-  // themselves.
-  // Must hold sMutex to access.
-  static bool sFactoryShutdownComplete;
-
   // Background thread owning all Manager objects.  Only set while sFactory is
   // set.
   // Must hold sMutex to access.
   static StaticRefPtr<nsIThread> sBackgroundThread;
 
   // Weak references as we don't want to keep Manager objects alive forever.
   // When a Manager is destroyed it calls Factory::Remove() to clear itself.
   // PBackground thread only.
@@ -374,19 +370,16 @@ StaticAutoPtr<Manager::Factory> Manager:
 
 // static
 StaticMutex Manager::Factory::sMutex;
 
 // static
 bool Manager::Factory::sFactoryShutdown = false;
 
 // static
-bool Manager::Factory::sFactoryShutdownComplete = false;
-
-// static
 StaticRefPtr<nsIThread> Manager::Factory::sBackgroundThread;
 
 // ----------------------------------------------------------------------------
 
 // Abstract class to help implement the various Actions.  The vast majority
 // of Actions are synchronous and need to report back to a Listener on the
 // Manager.
 class Manager::BaseAction : public SyncDBAction
