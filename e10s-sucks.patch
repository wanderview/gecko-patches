# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  620c6ea2a425b90c116dbb03f223ebec28dee034

diff --git a/dom/workers/test/serviceworkers/fetch/fetch_tests.js b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
--- a/dom/workers/test/serviceworkers/fetch/fetch_tests.js
+++ b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
@@ -30,16 +30,17 @@ function redirectURL(hops) {
   return hops[0].server + corsServerPath + "?hop=1&hops=" +
          encodeURIComponent(hops.toSource());
 }
 
 function fetchXHR(name, onload, onerror, headers) {
   return fetchXHRWithMethod(name, 'GET', onload, onerror, headers);
 }
 
+/*
 fetchXHR('bare-synthesized.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "synthesized response body", "load should have synthesized response");
   finish();
 });
 
 fetchXHR('test-respondwith-response.txt', function(xhr) {
   my_ok(xhr.status == 200, "test-respondwith-response load should be successful");
@@ -54,24 +55,26 @@ fetchXHR('synthesized-404.txt', function
 });
 
 fetchXHR('synthesized-headers.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.getResponseHeader("X-Custom-Greeting") === "Hello", "custom header should be set");
   my_ok(xhr.responseText == "synthesized response body", "custom header load should have synthesized response");
   finish();
 });
+*/
 
 fetchXHR('synthesized-redirect-real-file.txt', function(xhr) {
 dump("Got status AARRGH " + xhr.status + " " + xhr.responseText + "\n");
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "This is a real file.\n", "Redirect to real file should complete.");
   finish();
 });
 
+/*
 fetchXHR('synthesized-redirect-twice-real-file.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "This is a real file.\n", "Redirect to real file (twice) should complete.");
   finish();
 });
 
 fetchXHR('synthesized-redirect-synthesized.txt', function(xhr) {
   my_ok(xhr.status == 200, "synth+redirect+synth load should be successful");
@@ -447,8 +450,9 @@ fetch('fetchevent-request')
   return res.text();
 }).then(function(body) {
   my_ok(body == "non-nullable", "FetchEvent.request must be non-nullable");
   finish();
 }, function(err) {
   my_ok(false, "A promise was rejected with " + err);
   finish();
 });
+*/
diff --git a/dom/workers/test/serviceworkers/fetch/index.html b/dom/workers/test/serviceworkers/fetch/index.html
--- a/dom/workers/test/serviceworkers/fetch/index.html
+++ b/dom/workers/test/serviceworkers/fetch/index.html
@@ -73,16 +73,17 @@
   function expectAsyncResult() {
     gExpected++;
   }
 
   my_ok(navigator.serviceWorker.controller != null, "should be controlled");
 </script>
 <script src="fetch_tests.js"></script>
 <script>
+  /*
   test_onload(function() {
     var elem = document.createElement('img');
     elem.src = "nonexistent_image.gifs";
     elem.id = 'intercepted-img';
     return elem;
   }, function() {
     my_ok(this.complete, "image should be complete");
     my_ok(this.naturalWidth == 1 && this.naturalHeight == 1, "image should be 1x1 gif");
@@ -172,12 +173,13 @@
       gExpected++;
     } else if (e.data.type == "ok") {
       my_ok(e.data.value, "Fetch test on worker: " + e.data.msg);
     }
   };
   worker.onerror = function() {
     my_ok(false, "worker should not cause any errors");
   };
+  */
 </script>
 </pre>
 </body>
 </html>
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -14,16 +14,17 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 #include "HttpBackgroundChannelParent.h"
 #include "HttpChannelParentListener.h"
+#include "InterceptedHttpChannel.h"
 #include "nsHttpHandler.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPriority.h"
 #include "nsIAuthPromptProvider.h"
 #include "nsIBackgroundChannelRegistrar.h"
 #include "nsSerializationHelper.h"
 #include "nsISerializable.h"
@@ -230,35 +231,38 @@ HttpChannelParent::CleanupBackgroundChan
   if (mBgParent) {
     RefPtr<HttpBackgroundChannelParent> bgParent = mBgParent.forget();
     bgParent->OnChannelClosed();
     return;
   }
 
   // The nsHttpChannel may have a reference to this parent, release it
   // to avoid circular references.
-  if (mChannel) {
-    mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
   }
 
   if (!mPromise.IsEmpty()) {
     mRequest.DisconnectIfExists();
     mPromise.Reject(NS_ERROR_FAILURE, __func__);
 
     if (!mChannel) {
       return;
     }
 
     // This HttpChannelParent might still have a reference from
     // BackgroundChannelRegistrar.
     nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
       do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
     MOZ_ASSERT(registrar);
 
-    registrar->DeleteChannel(mChannel->ChannelId());
+    uint64_t channelId = 0;
+    MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+    registrar->DeleteChannel(channelId);
 
     // If mAsyncOpenBarrier is greater than zero, it means AsyncOpen procedure
     // is still on going. we need to abort AsyncOpen with failure to destroy
     // PHttpChannel actor.
     if (mAsyncOpenBarrier) {
       TryInvokeAsyncOpen(NS_ERROR_FAILURE);
     }
   }
@@ -510,84 +514,123 @@ HttpChannelParent::DoAsyncOpen(  const U
     return SendFailedAsyncOpen(rv);
   }
 
   if (!loadInfo) {
     return SendFailedAsyncOpen(NS_ERROR_UNEXPECTED);
   }
 
   nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
-                             nullptr, nullptr, aLoadFlags, ios);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
+
+  if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
+    const nsHttpResponseHead& head =
+      aSynthesizedResponseHead.get_nsHttpResponseHead();
+
+    nsCOMPtr<nsIInputStream> body;
+    rv = NS_NewCStringInputStream(getter_AddRefs(body), EmptyCString());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    channel = InterceptedHttpChannel::CreateForSynthesis(&head, body);
+    if (NS_WARN_IF(!channel)) {
+      return SendFailedAsyncOpen(rv);
+    }
+  } else {
+    rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
+                               nullptr, nullptr, aLoadFlags, ios);
+    if (NS_FAILED(rv)) {
+      return SendFailedAsyncOpen(rv);
+    }
   }
 
-  RefPtr<nsHttpChannel> httpChannel = do_QueryObject(channel, &rv);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
+  nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsITimedChannel> timedChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsIPrivateBrowsingChannel> privateChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsIResumableChannel> resumableChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsIHttpChannelInternal> httpInternalChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsICacheInfoChannel> cacheChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsISupportsPriority> priorityChannel = do_QueryInterface(channel);
+  nsCOMPtr<nsIClassOfService> classChannel = do_QueryInterface(channel);
+  if (!httpChannel || !timedChannel || !privateChannel || !resumableChannel) {
+    return SendFailedAsyncOpen(NS_ERROR_FAILURE);
   }
 
   // Set the channelId allocated in child to the parent instance
-  httpChannel->SetChannelId(aChannelId);
-  httpChannel->SetTopLevelContentWindowId(aContentWindowId);
-  httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  rv = httpChannel->SetChannelId(aChannelId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelContentWindowId(aContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
-  httpChannel->SetWarningReporter(this);
-  httpChannel->SetTimingEnabled(true);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(channel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
+  timedChannel->SetTimingEnabled(true);
   if (mPBOverride != kPBOverride_Unset) {
-    httpChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
+    privateChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
   }
 
-  if (doResumeAt)
-    httpChannel->ResumeAt(startPos, entityID);
+  if (doResumeAt) {
+    resumableChannel->ResumeAt(startPos, entityID);
+  }
 
   if (originalUri)
     httpChannel->SetOriginalURI(originalUri);
-  if (docUri)
-    httpChannel->SetDocumentURI(docUri);
+  if (docUri) {
+    rv = httpInternalChannel->SetDocumentURI(docUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (referrerUri) {
-    rv = httpChannel->SetReferrerWithPolicyInternal(referrerUri, aReferrerPolicy);
+    rv = httpChannel->SetReferrerWithPolicy(referrerUri, aReferrerPolicy);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
-  if (apiRedirectToUri)
-    httpChannel->RedirectTo(apiRedirectToUri);
+  if (apiRedirectToUri) {
+    rv = httpChannel->RedirectTo(apiRedirectToUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (topWindowUri) {
-    rv = httpChannel->SetTopWindowURI(topWindowUri);
+    rv = httpInternalChannel->SetTopWindowURIIfUnknown(topWindowUri);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
   if (aLoadFlags != nsIRequest::LOAD_NORMAL)
     httpChannel->SetLoadFlags(aLoadFlags);
 
   if (aForceMainDocumentChannel) {
-    httpChannel->SetIsMainDocumentChannel(true);
+    rv = httpChannel->SetIsMainDocumentChannel(true);
+    MOZ_ALWAYS_SUCCEEDS(rv);
   }
 
   for (uint32_t i = 0; i < requestHeaders.Length(); i++) {
     if (requestHeaders[i].mEmpty) {
-      httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      rv = httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     } else {
-      httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
-                                 requestHeaders[i].mValue,
-                                 requestHeaders[i].mMerge);
+      rv = httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
+                                         requestHeaders[i].mValue,
+                                         requestHeaders[i].mMerge);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     }
   }
 
   RefPtr<HttpChannelParentListener> parentListener
     = new HttpChannelParentListener(this);
 
-  httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  rv = httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   if (aCorsPreflightArgs.type() == OptionalCorsPreflightArgs::TCorsPreflightArgs) {
     const CorsPreflightArgs& args = aCorsPreflightArgs.get_CorsPreflightArgs();
-    httpChannel->SetCorsPreflightParameters(args.unsafeHeaders());
+    httpInternalChannel->SetCorsPreflightParameters(args.unsafeHeaders());
   }
 
   nsCOMPtr<nsIInputStream> stream = DeserializeIPCStream(uploadStream);
-  if (stream) {
+  if (stream && httpChannelImpl) {
     // FIXME: The fast path of using the existing stream currently only applies to streams
     //   that have had their entire contents serialized from the child at this point.
     //   Once bug 1294446 and bug 1294450 are fixed it is worth revisiting this heuristic.
     nsCOMPtr<nsIIPCSerializableInputStream> completeStream = do_QueryInterface(stream);
     if (!completeStream) {
       // Wait for completion of async copying IPC upload stream to a local input stream.
       ++mAsyncOpenBarrier;
 
@@ -630,23 +673,24 @@ HttpChannelParent::DoAsyncOpen(  const U
       // the AsyncOpen process once the full stream has been received.
       rv = NS_AsyncCopy(stream, sink, target, NS_ASYNCCOPY_VIA_READSEGMENTS,
                         kBufferSize, // copy segment size
                         UploadCopyComplete, closure.release());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return SendFailedAsyncOpen(rv);
       }
 
-      httpChannel->InternalSetUploadStream(newUploadStream);
+      httpChannelImpl->InternalSetUploadStream(newUploadStream);
     } else {
-      httpChannel->InternalSetUploadStream(stream);
+      httpChannelImpl->InternalSetUploadStream(stream);
     }
-    httpChannel->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
+    httpChannelImpl->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
+  /*
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
     parentListener->SetupInterception(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mWillSynthesizeResponse = true;
     httpChannel->SetCouldBeSynthesized();
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
@@ -654,57 +698,67 @@ HttpChannelParent::DoAsyncOpen(  const U
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   } else {
     nsLoadFlags newLoadFlags;
     httpChannel->GetLoadFlags(&newLoadFlags);
     newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
     httpChannel->SetLoadFlags(newLoadFlags);
   }
+  */
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   rv = cacheKey->SetData(aCacheKey);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
-  httpChannel->SetCacheKey(cacheKey);
-  httpChannel->PreferAlternativeDataType(aPreferredAlternativeType);
+  cacheChannel->SetCacheKey(cacheKey);
+  cacheChannel->PreferAlternativeDataType(aPreferredAlternativeType);
 
-  httpChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
+  cacheChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
 
   httpChannel->SetContentType(aContentTypeHint);
 
   if (priority != nsISupportsPriority::PRIORITY_NORMAL) {
-    httpChannel->SetPriority(priority);
+    priorityChannel->SetPriority(priority);
   }
   if (classOfService) {
-    httpChannel->SetClassFlags(classOfService);
+    classChannel->SetClassFlags(classOfService);
   }
-  httpChannel->SetRedirectionLimit(redirectionLimit);
-  httpChannel->SetAllowSTS(allowSTS);
-  httpChannel->SetThirdPartyFlags(thirdPartyFlags);
-  httpChannel->SetAllowSpdy(allowSpdy);
-  httpChannel->SetAllowAltSvc(allowAltSvc);
-  httpChannel->SetBeConservative(beConservative);
-  httpChannel->SetTlsFlags(tlsFlags);
-  httpChannel->SetInitialRwin(aInitialRwin);
-  httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  rv = httpChannel->SetRedirectionLimit(redirectionLimit);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowSTS(allowSTS);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetThirdPartyFlags(thirdPartyFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetAllowSpdy(allowSpdy);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetAllowAltSvc(allowAltSvc);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetBeConservative(beConservative);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetTlsFlags(tlsFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetInitialRwin(aInitialRwin);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpInternalChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
-  httpChannel->SetLaunchServiceWorkerStart(aLaunchServiceWorkerStart);
-  httpChannel->SetLaunchServiceWorkerEnd(aLaunchServiceWorkerEnd);
-  httpChannel->SetDispatchFetchEventStart(aDispatchFetchEventStart);
-  httpChannel->SetDispatchFetchEventEnd(aDispatchFetchEventEnd);
-  httpChannel->SetHandleFetchEventStart(aHandleFetchEventStart);
-  httpChannel->SetHandleFetchEventEnd(aHandleFetchEventEnd);
+  timedChannel->SetLaunchServiceWorkerStart(aLaunchServiceWorkerStart);
+  timedChannel->SetLaunchServiceWorkerEnd(aLaunchServiceWorkerEnd);
+  timedChannel->SetDispatchFetchEventStart(aDispatchFetchEventStart);
+  timedChannel->SetDispatchFetchEventEnd(aDispatchFetchEventEnd);
+  timedChannel->SetHandleFetchEventStart(aHandleFetchEventStart);
+  timedChannel->SetHandleFetchEventEnd(aHandleFetchEventEnd);
 
   nsCOMPtr<nsIApplicationCacheChannel> appCacheChan =
     do_QueryObject(httpChannel);
   nsCOMPtr<nsIApplicationCacheService> appCacheService =
     do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
 
   bool setChooseApplicationCache = chooseApplicationCache;
   if (appCacheChan && appCacheService) {
@@ -733,17 +787,18 @@ HttpChannelParent::DoAsyncOpen(  const U
       // This works because we've already called SetNotificationCallbacks and
       // done mPBOverride logic by this point.
       chooseAppCache = NS_ShouldCheckAppCache(principal);
 
       appCacheChan->SetChooseApplicationCache(chooseAppCache);
     }
   }
 
-  httpChannel->SetRequestContextID(aRequestContextID);
+  rv = httpChannel->SetRequestContextID(aRequestContextID);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   // Store the strong reference of channel and parent listener object until
   // all the initialization procedure is complete without failure, to remove
   // cycle reference in fail case and to avoid memory leakage.
   mChannel = httpChannel.forget();
   mParentListener = parentListener.forget();
   mChannel->SetNotificationCallbacks(mParentListener);
 
@@ -776,17 +831,19 @@ HttpChannelParent::WaitForBgParent()
   LOG(("HttpChannelParent::WaitForBgParent [this=%p]\n", this));
   MOZ_ASSERT(!mBgParent);
   MOZ_ASSERT(mChannel);
 
 
   nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
     do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
   MOZ_ASSERT(registrar);
-  registrar->LinkHttpChannel(mChannel->ChannelId(), this);
+  uint64_t channelId = 0;
+  MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+  registrar->LinkHttpChannel(channelId, this);
 
   if (mBgParent) {
     already_AddRefed<GenericPromise> promise = mPromise.Ensure(__func__);
     // resolve promise immediatedly if bg channel is ready.
     mPromise.Resolve(true, __func__);
     return promise;
   }
 
@@ -807,26 +864,29 @@ HttpChannelParent::ConnectChannel(const 
     // This makes the channel delete itself safely.  It's the only thing
     // we can do now, since this parent channel cannot be used and there is
     // no other way to tell the child side there were something wrong.
     Delete();
     return true;
   }
 
   LOG(("  found channel %p, rv=%08" PRIx32, channel.get(), static_cast<uint32_t>(rv)));
-  mChannel = do_QueryObject(channel);
+  mChannel = do_QueryInterface(channel);
   if (!mChannel) {
     LOG(("  but it's not nsHttpChannel"));
     Delete();
     return true;
   }
 
   LOG(("  and it is nsHttpChannel %p", mChannel.get()));
 
-  mChannel->SetWarningReporter(this);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
 
   nsCOMPtr<nsINetworkInterceptController> controller;
   NS_QueryNotificationCallbacks(channel, controller);
   RefPtr<HttpChannelParentListener> parentListener = do_QueryObject(controller);
   MOZ_ASSERT(parentListener);
   parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
 
   if (mPBOverride != kPBOverride_Unset) {
@@ -855,33 +915,35 @@ HttpChannelParent::ConnectChannel(const 
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSetPriority(const int16_t& priority)
 {
   LOG(("HttpChannelParent::RecvSetPriority [this=%p, priority=%d]\n",
        this, priority));
 
-  if (mChannel) {
-    mChannel->SetPriority(priority);
+  nsCOMPtr<nsISupportsPriority> priorityChannel = do_QueryInterface(mChannel);
+  if (priorityChannel) {
+    priorityChannel->SetPriority(priority);
   }
 
   nsCOMPtr<nsISupportsPriority> priorityRedirectChannel =
       do_QueryInterface(mRedirectChannel);
   if (priorityRedirectChannel)
     priorityRedirectChannel->SetPriority(priority);
 
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSetClassOfService(const uint32_t& cos)
 {
-  if (mChannel) {
-    mChannel->SetClassFlags(cos);
+  nsCOMPtr<nsIClassOfService> classChannel = do_QueryInterface(mChannel);
+  if (classChannel) {
+    classChannel->SetClassFlags(cos);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSuspend()
 {
   LOG(("HttpChannelParent::RecvSuspend [this=%p]\n", this));
@@ -1273,18 +1335,19 @@ HttpChannelParent::DivertOnStopRequest(c
     FailDiversion(NS_ERROR_UNEXPECTED);
     return;
   }
 
   // Honor the channel's status even if the underlying transaction completed.
   nsresult status = NS_FAILED(mStatus) ? mStatus : statusCode;
 
   // Reset fake pending status in case OnStopRequest has already been called.
-  if (mChannel) {
-    mChannel->ForcePending(false);
+  nsCOMPtr<nsIForcePendingChannel> forceChannel = do_QueryInterface(mChannel);
+  if (forceChannel) {
+    forceChannel->ForcePending(false);
   }
 
   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
   mParentListener->OnStopRequest(mChannel, nullptr, status);
 }
 
 class DivertCompleteEvent : public MainThreadChannelEvent
 {
@@ -1536,38 +1599,48 @@ HttpChannelParent::OnStopRequest(nsIRequ
                                  nsresult aStatusCode)
 {
   LOG(("HttpChannelParent::OnStopRequest: [this=%p aRequest=%p status=%" PRIx32 "]\n",
        this, aRequest, static_cast<uint32_t>(aStatusCode)));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStopRequest if diverting is set!");
+
+  nsCOMPtr<nsITimedChannel> timedChannel = do_QueryInterface(mChannel);
+  nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel);
+
   ResourceTimingStruct timing;
-  mChannel->GetDomainLookupStart(&timing.domainLookupStart);
-  mChannel->GetDomainLookupEnd(&timing.domainLookupEnd);
-  mChannel->GetConnectStart(&timing.connectStart);
-  mChannel->GetSecureConnectionStart(&timing.secureConnectionStart);
-  mChannel->GetConnectEnd(&timing.connectEnd);
-  mChannel->GetRequestStart(&timing.requestStart);
-  mChannel->GetResponseStart(&timing.responseStart);
-  mChannel->GetResponseEnd(&timing.responseEnd);
-  mChannel->GetAsyncOpen(&timing.fetchStart);
-  mChannel->GetRedirectStart(&timing.redirectStart);
-  mChannel->GetRedirectEnd(&timing.redirectEnd);
-  mChannel->GetTransferSize(&timing.transferSize);
-  mChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  timedChannel->GetDomainLookupStart(&timing.domainLookupStart);
+  timedChannel->GetDomainLookupEnd(&timing.domainLookupEnd);
+  timedChannel->GetConnectStart(&timing.connectStart);
+  timedChannel->GetSecureConnectionStart(&timing.secureConnectionStart);
+  timedChannel->GetConnectEnd(&timing.connectEnd);
+  timedChannel->GetRequestStart(&timing.requestStart);
+  timedChannel->GetResponseStart(&timing.responseStart);
+  timedChannel->GetResponseEnd(&timing.responseEnd);
+  timedChannel->GetAsyncOpen(&timing.fetchStart);
+  timedChannel->GetRedirectStart(&timing.redirectStart);
+  timedChannel->GetRedirectEnd(&timing.redirectEnd);
+  nsresult rv = httpChannel->GetTransferSize(&timing.transferSize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
   // decodedBodySize can be computed in the child process so it doesn't need
   // to be passed down.
-  mChannel->GetProtocolVersion(timing.protocolVersion);
+  rv = httpChannel->GetProtocolVersion(timing.protocolVersion);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
-  mChannel->GetCacheReadStart(&timing.cacheReadStart);
-  mChannel->GetCacheReadEnd(&timing.cacheReadEnd);
+  timedChannel->GetCacheReadStart(&timing.cacheReadStart);
+  timedChannel->GetCacheReadEnd(&timing.cacheReadEnd);
 
-  mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
+  }
 
   // Either IPC channel is closed or background channel
   // is ready to send OnStopRequest.
   MOZ_ASSERT(mIPCClosed || mBgParent);
 
   if (mIPCClosed ||
       !mBgParent || !mBgParent->OnStopRequest(aStatusCode, timing)) {
     return NS_ERROR_UNEXPECTED;
@@ -1868,33 +1941,35 @@ HttpChannelParent::SuspendForDiversion()
 
   if (NS_WARN_IF(mDivertingFromChild)) {
     MOZ_ASSERT(!mDivertingFromChild, "Already suspended for diversion!");
     return NS_ERROR_UNEXPECTED;
   }
 
   // MessageDiversionStarted call will suspend mEventQ as many times as the
   // channel has been suspended, so that channel and this queue are in sync.
-  mChannel->MessageDiversionStarted(this);
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(mChannel);
+  divertChannel->MessageDiversionStarted(this);
 
   nsresult rv = NS_OK;
 
   // Try suspending the channel. Allow it to fail, since OnStopRequest may have
   // been called and thus the channel may not be pending.  If we've already
   // automatically suspended after synthesizing the response, then we don't
   // need to suspend again here.
   if (!mSuspendAfterSynthesizeResponse) {
     // We need to suspend only nsHttpChannel (i.e. we should not suspend
     // mEventQ). Therefore we call mChannel->SuspendInternal() and not
     // mChannel->Suspend().
     // We are suspending only nsHttpChannel here because we want to stop
     // OnDataAvailable until diversion is over. At the same time we should
     // send the diverted OnDataAvailable-s to the listeners and not queue them
     // in mEventQ.
-    rv = mChannel->SuspendInternal();
+    rv = divertChannel->SuspendInternal();
     MOZ_ASSERT(NS_SUCCEEDED(rv) || rv == NS_ERROR_NOT_AVAILABLE);
     mSuspendedForDiversion = NS_SUCCEEDED(rv);
   } else {
     // Take ownership of the automatic suspend that occurred after synthesizing
     // the response.
     mSuspendedForDiversion = true;
 
     // If mSuspendAfterSynthesizeResponse is true channel has been already
@@ -1939,21 +2014,23 @@ HttpChannelParent::ResumeForDiversion()
   LOG(("HttpChannelParent::ResumeForDiversion [this=%p]\n", this));
   MOZ_ASSERT(mChannel);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot ResumeForDiversion if not diverting!");
     return NS_ERROR_UNEXPECTED;
   }
 
-  mChannel->MessageDiversionStop();
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(mChannel);
+  divertChannel->MessageDiversionStop();
 
   if (mSuspendedForDiversion) {
     // The nsHttpChannel will deliver remaining OnData/OnStop for the transfer.
-    nsresult rv = mChannel->ResumeInternal();
+    nsresult rv = divertChannel->ResumeInternal();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
     mSuspendedForDiversion = false;
   }
 
   if (NS_WARN_IF(mIPCClosed || !DoSendDeleteSelf())) {
     return NS_ERROR_UNEXPECTED;
@@ -2001,18 +2078,19 @@ HttpChannelParent::StartDiversion()
   LOG(("HttpChannelParent::StartDiversion [this=%p]\n", this));
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot StartDiversion if diverting is not set!");
     return;
   }
 
   // Fake pending status in case OnStopRequest has already been called.
-  if (mChannel) {
-    mChannel->ForcePending(true);
+  nsCOMPtr<nsIForcePendingChannel> forceChannel = do_QueryInterface(mChannel);
+  if (forceChannel) {
+    forceChannel->ForcePending(true);
   }
 
   {
     AutoEventEnqueuer ensureSerialDispatch(mEventQ);
 
     // Call OnStartRequest for the "DivertTo" listener.
     nsresult rv = mDivertListener->OnStartRequest(mChannel, nullptr);
     if (NS_FAILED(rv)) {
@@ -2023,19 +2101,21 @@ HttpChannelParent::StartDiversion()
     }
   }
   mDivertedOnStartRequest = true;
 
   // After OnStartRequest has been called, setup content decoders if needed.
   //
   // Create a content conversion chain based on mDivertListener and update
   // mDivertListener.
+  nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(mChannel);
   nsCOMPtr<nsIStreamListener> converterListener;
-  Unused << mChannel->DoApplyContentConversions(mDivertListener,
-                                                getter_AddRefs(converterListener));
+  Unused << encodedChannel->DoApplyContentConversions(mDivertListener,
+                                                      getter_AddRefs(converterListener),
+                                                      nullptr);
   if (converterListener) {
     mDivertListener = converterListener.forget();
   }
 
   // Now mParentListener can be diverted to mDivertListener.
   DebugOnly<nsresult> rvdbg = mParentListener->DivertTo(mDivertListener);
   MOZ_ASSERT(NS_SUCCEEDED(rvdbg));
   mDivertListener = nullptr;
@@ -2091,32 +2171,35 @@ HttpChannelParent::NotifyDiversionFailed
        this, static_cast<uint32_t>(aErrorCode)));
   MOZ_RELEASE_ASSERT(NS_FAILED(aErrorCode));
   MOZ_RELEASE_ASSERT(mDivertingFromChild);
   MOZ_RELEASE_ASSERT(mParentListener);
   MOZ_RELEASE_ASSERT(mChannel);
 
   mChannel->Cancel(aErrorCode);
 
-  mChannel->ForcePending(false);
+  nsCOMPtr<nsIForcePendingChannel> forceChannel = do_QueryInterface(mChannel);
+  forceChannel->ForcePending(false);
 
   bool isPending = false;
   nsresult rv = mChannel->IsPending(&isPending);
   MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));
 
   // Resume only if we suspended earlier.
   if (mSuspendedForDiversion) {
-    mChannel->ResumeInternal();
+    nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+      do_QueryInterface(mChannel);
+    divertChannel->ResumeInternal();
   }
   // Channel has already sent OnStartRequest to the child, so ensure that we
   // call it here if it hasn't already been called.
   if (!mDivertedOnStartRequest) {
-    mChannel->ForcePending(true);
+    forceChannel->ForcePending(true);
     mParentListener->OnStartRequest(mChannel, nullptr);
-    mChannel->ForcePending(false);
+    forceChannel->ForcePending(false);
   }
   // If the channel is pending, it will call OnStopRequest itself; otherwise, do
   // it here.
   if (!isPending) {
     mParentListener->OnStopRequest(mChannel, nullptr, aErrorCode);
   }
 
   if (!mIPCClosed) {
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -90,18 +90,19 @@ public:
   void StartDiversion();
 
   // Handles calling OnStart/Stop if there are errors during diversion.
   // Called asynchronously from FailDiversion.
   void NotifyDiversionFailed(nsresult aErrorCode);
 
   // Forwarded to nsHttpChannel::SetApplyConversion.
   void SetApplyConversion(bool aApplyConversion) {
-    if (mChannel) {
-      mChannel->SetApplyConversion(aApplyConversion);
+    nsCOMPtr<nsIEncodedChannel> encoded = do_QueryInterface(mChannel);
+    if (encoded) {
+      encoded->SetApplyConversion(aApplyConversion);
     }
   }
 
   MOZ_MUST_USE nsresult OpenAlternativeOutputStream(const nsACString & type,
                                                     nsIOutputStream * *_retval);
 
   // Callbacks for each asynchronous tasks required in AsyncOpen
   // procedure, will call InvokeAsyncOpen when all the expected
@@ -255,17 +256,17 @@ private:
   // DocumentChannelCleanup.
   void CleanupBackgroundChannel();
 
   friend class HttpBackgroundChannelParent;
   friend class DivertDataAvailableEvent;
   friend class DivertStopRequestEvent;
   friend class DivertCompleteEvent;
 
-  RefPtr<nsHttpChannel>       mChannel;
+  nsCOMPtr<nsIHttpChannel>       mChannel;
   nsCOMPtr<nsICacheEntry>       mCacheEntry;
   nsCOMPtr<nsIAssociatedContentSecurity>  mAssociatedContentSecurity;
   bool mIPCClosed;                // PHttpChannel actor has been Closed()
 
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
 
   nsAutoPtr<class nsHttpChannel::OfflineCacheEntryAsForeignMarker> mOfflineForeignMarker;
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -13,25 +13,49 @@ namespace net {
 
 NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
                             HttpBaseChannel,
                             nsIInterceptedChannel,
                             nsIAsyncVerifyRedirectCallback,
                             nsIRequestObserver,
                             nsIStreamListener)
 
+InterceptedHttpChannel::InterceptedHttpChannel()
+  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+}
+
 InterceptedHttpChannel::~InterceptedHttpChannel()
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
 }
 
-InterceptedHttpChannel::InterceptedHttpChannel()
-  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForInterception()
 {
-  printf_stderr("### ### [%p] %s\n", this, __func__);
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+  return ref.forget();
+}
+
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForSynthesis(const nsHttpResponseHead* aHead,
+                                           nsIInputStream* aBody)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aHead);
+  MOZ_DIAGNOSTIC_ASSERT(aBody);
+
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+
+  ref->mBodyReader = aBody;
+  ref->mResponseHead = new nsHttpResponseHead(*aHead);
+
+  return ref.forget();
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::Cancel(nsresult aStatus)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return CancelInterception(aStatus);
 }
@@ -384,17 +408,18 @@ InterceptedHttpChannel::FinishSynthesize
     responseURI = mURI;
   }
 
   bool equal = false;
   Unused << mURI->Equals(responseURI, &equal);
   if (!equal) {
     nsresult rv = NS_OK;
 
-    RefPtr<InterceptedHttpChannel> newChannel = new InterceptedHttpChannel();
+    RefPtr<InterceptedHttpChannel> newChannel =
+      CreateForSynthesis(mResponseHead, mBodyReader);
 
     rv = newChannel->Init(responseURI, mCaps,
                           static_cast<nsProxyInfo*>(mProxyInfo.get()),
                           mProxyResolveFlags, mProxyURI, mChannelId);
 
     uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
 
     nsCOMPtr<nsILoadInfo> redirectLoadInfo =
@@ -409,18 +434,18 @@ InterceptedHttpChannel::FinishSynthesize
       nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
       rv = newChannel->GetLoadFlags(&loadFlags);
       NS_ENSURE_SUCCESS(rv, rv);
       loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
       rv = newChannel->SetLoadFlags(loadFlags);
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
-    newChannel->mBodyReader = mBodyReader.forget();
-    newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
+    //newChannel->mBodyReader = mBodyReader.forget();
+    //newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
 
     mRedirectChannel = newChannel;
 
     rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
 
     if (NS_FAILED(rv)) {
       OnRedirectVerifyCallback(rv);
     }
@@ -508,23 +533,37 @@ InterceptedHttpChannel::GetInternalConte
 NS_IMETHODIMP
 InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector** aConsoleReportCollector)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerStart(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerEnd(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp)
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -25,20 +25,25 @@ class InterceptedHttpChannel final : pub
   UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIInputStream> mBodyReader;
   nsCOMPtr<nsIOutputStream> mBodyWriter;
   nsCOMPtr<nsISupports> mReleaseHandle;
   nsCOMPtr<nsIProgressEventSink> mProgressSink;
   RefPtr<nsInputStreamPump> mPump;
 
+  InterceptedHttpChannel();
   ~InterceptedHttpChannel();
 
 public:
-  InterceptedHttpChannel();
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForInterception();
+
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody);
 
   NS_IMETHOD
   Cancel(nsresult aStatus) override;
 
   NS_IMETHOD
   Suspend(void) override;
 
   NS_IMETHOD
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -550,17 +550,17 @@ nsHttpChannel::Connect()
     if (mInterceptCache == MAYBE_INTERCEPT) {
       mInterceptCache = INTERCEPTED;
 
       nsCOMPtr<nsINetworkInterceptController> controller;
       GetCallback(controller);
 
       printf_stderr("### ### nsHttpChannel mListener is %p when creating InterceptedHttpChannel\n", mListener.get());
       RefPtr<InterceptedHttpChannel> intercepted =
-        new InterceptedHttpChannel();
+        InterceptedHttpChannel::CreateForInterception();
 
       rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
                              mProxyResolveFlags, mProxyURI, mChannelId);
 
       nsCOMPtr<nsILoadInfo> redirectLoadInfo =
         CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
       intercepted->SetLoadInfo(redirectLoadInfo);
 
