# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  620c6ea2a425b90c116dbb03f223ebec28dee034

diff --git a/dom/workers/test/serviceworkers/fetch/fetch_tests.js b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
--- a/dom/workers/test/serviceworkers/fetch/fetch_tests.js
+++ b/dom/workers/test/serviceworkers/fetch/fetch_tests.js
@@ -30,16 +30,17 @@ function redirectURL(hops) {
   return hops[0].server + corsServerPath + "?hop=1&hops=" +
          encodeURIComponent(hops.toSource());
 }
 
 function fetchXHR(name, onload, onerror, headers) {
   return fetchXHRWithMethod(name, 'GET', onload, onerror, headers);
 }
 
+/*
 fetchXHR('bare-synthesized.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "synthesized response body", "load should have synthesized response");
   finish();
 });
 
 fetchXHR('test-respondwith-response.txt', function(xhr) {
   my_ok(xhr.status == 200, "test-respondwith-response load should be successful");
@@ -54,24 +55,28 @@ fetchXHR('synthesized-404.txt', function
 });
 
 fetchXHR('synthesized-headers.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.getResponseHeader("X-Custom-Greeting") === "Hello", "custom header should be set");
   my_ok(xhr.responseText == "synthesized response body", "custom header load should have synthesized response");
   finish();
 });
+*/
 
 fetchXHR('synthesized-redirect-real-file.txt', function(xhr) {
 dump("Got status AARRGH " + xhr.status + " " + xhr.responseText + "\n");
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "This is a real file.\n", "Redirect to real file should complete.");
   finish();
+}, function() {
+  dump('### ### got error\n');
 });
 
+/*
 fetchXHR('synthesized-redirect-twice-real-file.txt', function(xhr) {
   my_ok(xhr.status == 200, "load should be successful");
   my_ok(xhr.responseText == "This is a real file.\n", "Redirect to real file (twice) should complete.");
   finish();
 });
 
 fetchXHR('synthesized-redirect-synthesized.txt', function(xhr) {
   my_ok(xhr.status == 200, "synth+redirect+synth load should be successful");
@@ -447,8 +452,9 @@ fetch('fetchevent-request')
   return res.text();
 }).then(function(body) {
   my_ok(body == "non-nullable", "FetchEvent.request must be non-nullable");
   finish();
 }, function(err) {
   my_ok(false, "A promise was rejected with " + err);
   finish();
 });
+*/
diff --git a/dom/workers/test/serviceworkers/fetch/index.html b/dom/workers/test/serviceworkers/fetch/index.html
--- a/dom/workers/test/serviceworkers/fetch/index.html
+++ b/dom/workers/test/serviceworkers/fetch/index.html
@@ -73,16 +73,17 @@
   function expectAsyncResult() {
     gExpected++;
   }
 
   my_ok(navigator.serviceWorker.controller != null, "should be controlled");
 </script>
 <script src="fetch_tests.js"></script>
 <script>
+  /*
   test_onload(function() {
     var elem = document.createElement('img');
     elem.src = "nonexistent_image.gifs";
     elem.id = 'intercepted-img';
     return elem;
   }, function() {
     my_ok(this.complete, "image should be complete");
     my_ok(this.naturalWidth == 1 && this.naturalHeight == 1, "image should be 1x1 gif");
@@ -172,12 +173,13 @@
       gExpected++;
     } else if (e.data.type == "ok") {
       my_ok(e.data.value, "Fetch test on worker: " + e.data.msg);
     }
   };
   worker.onerror = function() {
     my_ok(false, "worker should not cause any errors");
   };
+  */
 </script>
 </pre>
 </body>
 </html>
diff --git a/netwerk/protocol/http/HttpBaseChannel.h b/netwerk/protocol/http/HttpBaseChannel.h
--- a/netwerk/protocol/http/HttpBaseChannel.h
+++ b/netwerk/protocol/http/HttpBaseChannel.h
@@ -366,16 +366,28 @@ public: /* Necko internal use only... */
 
     void SetIsTrackingResource();
 
     const uint64_t& ChannelId() const
     {
       return mChannelId;
     }
 
+    MOZ_MUST_USE nsresult
+    SetReferrerWithPolicyInternal(nsIURI *referrer, uint32_t referrerPolicy)
+    {
+        nsAutoCString spec;
+        nsresult rv = referrer->GetAsciiSpec(spec);
+        if (NS_FAILED(rv)) return rv;
+        mReferrer = referrer;
+        mReferrerPolicy = referrerPolicy;
+        rv = mRequestHead.SetHeader(nsHttp::Referer, spec);
+        return rv;
+    }
+
 protected:
   // Handle notifying listener, removing from loadgroup if request failed.
   void     DoNotifyListener();
   virtual void DoNotifyListenerCleanup() = 0;
 
   // drop reference to listener, its callbacks, and the progress sink
   virtual void ReleaseListeners();
 
diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -178,16 +178,17 @@ HttpChannelChild::HttpChannelChild()
   , mRedirectingForSubsequentSynthesizedResponse(false)
   , mPostRedirectChannelShouldIntercept(false)
   , mPostRedirectChannelShouldUpgrade(false)
   , mShouldParentIntercept(false)
   , mSuspendParentAfterSynthesizeResponse(false)
   , mBgChildMutex("HttpChannelChild::BgChildMutex")
   , mEventTargetMutex("HttpChannelChild::EventTargetMutex")
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("Creating HttpChannelChild @%p\n", this));
 
   mChannelCreationTime = PR_Now();
   mChannelCreationTimestamp = TimeStamp::Now();
   mAsyncOpenTime = TimeStamp::Now();
   mEventQ = new ChannelEventQueue(static_cast<nsIHttpChannel*>(this));
 
 #if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION) || defined(DEBUG)
@@ -203,24 +204,26 @@ HttpChannelChild::HttpChannelChild()
   // IPC HTTP channel is created.
   // We require that the parent cookie service actor exists while
   // processing HTTP responses.
   CookieServiceChild::GetSingleton();
 }
 
 HttpChannelChild::~HttpChannelChild()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("Destroying HttpChannelChild @%p\n", this));
 
   ReleaseMainThreadOnlyReferences();
 }
 
 void
 HttpChannelChild::ReleaseMainThreadOnlyReferences()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (NS_IsMainThread()) {
       // Already on main thread, let dtor to
       // take care of releasing references
       return;
   }
 
   nsTArray<nsCOMPtr<nsISupports>> arrayToRelease;
   arrayToRelease.AppendElement(mCacheKey.forget());
@@ -290,32 +293,35 @@ NS_INTERFACE_MAP_END_INHERITING(HttpBase
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::PHttpChannelChild
 //-----------------------------------------------------------------------------
 
 void
 HttpChannelChild::AddIPDLReference()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(!mIPCOpen, "Attempt to retain more than one IPDL reference");
   mIPCOpen = true;
   AddRef();
 }
 
 void
 HttpChannelChild::ReleaseIPDLReference()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(mIPCOpen, "Attempt to release nonexistent IPDL reference");
   mIPCOpen = false;
   Release();
 }
 
 void
 HttpChannelChild::OnBackgroundChildReady(HttpBackgroundChannelChild* aBgChild)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnBackgroundChildReady [this=%p, bgChild=%p]\n",
        this, aBgChild));
   MOZ_ASSERT(OnSocketThread());
 
   {
     MutexAutoLock lock(mBgChildMutex);
 
     // mBgChild might be removed or replaced while the original background
@@ -327,16 +333,17 @@ HttpChannelChild::OnBackgroundChildReady
     MOZ_ASSERT(mBgInitFailCallback);
     mBgInitFailCallback = nullptr;
   }
 }
 
 void
 HttpChannelChild::OnBackgroundChildDestroyed(HttpBackgroundChannelChild* aBgChild)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnBackgroundChildDestroyed [this=%p]\n", this));
   // This function might be called during shutdown phase, so OnSocketThread()
   // might return false even on STS thread. Use IsOnCurrentThreadInfallible()
   // to get correct information.
   MOZ_ASSERT(gSocketTransportService);
   MOZ_ASSERT(gSocketTransportService->IsOnCurrentThreadInfallible());
 
   nsCOMPtr<nsIRunnable> callback;
@@ -375,26 +382,28 @@ class AssociateApplicationCacheEvent : p
     nsCString groupID;
     nsCString clientID;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvAssociateApplicationCache(const nsCString &groupID,
                                                 const nsCString &clientID)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RecvAssociateApplicationCache [this=%p]\n", this));
   mEventQ->RunOrEnqueue(new AssociateApplicationCacheEvent(this, groupID,
                                                            clientID));
   return IPC_OK();
 }
 
 void
 HttpChannelChild::AssociateApplicationCache(const nsCString &groupID,
                                             const nsCString &clientID)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::AssociateApplicationCache [this=%p]\n", this));
   nsresult rv;
   mApplicationCache = do_CreateInstance(NS_APPLICATIONCACHE_CONTRACTID, &rv);
   if (NS_FAILED(rv))
     return;
 
   mLoadedFromApplicationCache = true;
   mApplicationCache->InitAsHandle(groupID, clientID);
@@ -478,16 +487,17 @@ HttpChannelChild::RecvOnStartRequest(con
                                      const nsCString& securityInfoSerialization,
                                      const NetAddr& selfAddr,
                                      const NetAddr& peerAddr,
                                      const int16_t& redirectCount,
                                      const uint32_t& cacheKey,
                                      const nsCString& altDataType,
                                      const int64_t& altDataLen)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RecvOnStartRequest [this=%p]\n", this));
   // mFlushedForDiversion and mDivertingToParent should NEVER be set at this
   // stage, as they are set in the listener's OnStartRequest.
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "mFlushedForDiversion should be unset before OnStartRequest!");
   MOZ_RELEASE_ASSERT(!mDivertingToParent,
     "mDivertingToParent should be unset before OnStartRequest!");
 
@@ -537,16 +547,17 @@ HttpChannelChild::OnStartRequest(const n
                                  const nsCString& cachedCharset,
                                  const nsCString& securityInfoSerialization,
                                  const NetAddr& selfAddr,
                                  const NetAddr& peerAddr,
                                  const uint32_t& cacheKey,
                                  const nsCString& altDataType,
                                  const int64_t& altDataLen)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnStartRequest [this=%p]\n", this));
 
   // mFlushedForDiversion and mDivertingToParent should NEVER be set at this
   // stage, as they are set in the listener's OnStartRequest.
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "mFlushedForDiversion should be unset before OnStartRequest!");
   MOZ_RELEASE_ASSERT(!mDivertingToParent,
     "mDivertingToParent should be unset before OnStartRequest!");
@@ -659,16 +670,17 @@ public:
 
 NS_IMPL_ISUPPORTS(SyntheticDiversionListener, nsIStreamListener);
 
 } // anonymous namespace
 
 void
 HttpChannelChild::DoOnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoOnStartRequest [this=%p]\n", this));
 
   // In theory mListener should not be null, but in practice sometimes it is.
   MOZ_ASSERT(mListener);
   if (!mListener) {
     Cancel(NS_ERROR_FAILURE);
     return;
   }
@@ -747,16 +759,17 @@ class TransportAndDataEvent : public Cha
 
 void
 HttpChannelChild::ProcessOnTransportAndData(const nsresult& aChannelStatus,
                                             const nsresult& aTransportStatus,
                                             const uint64_t& aOffset,
                                             const uint32_t& aCount,
                                             const nsCString& aData)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessOnTransportAndData [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
                      "Should not be receiving any more callbacks from parent!");
   mEventQ->RunOrEnqueue(new TransportAndDataEvent(this, aChannelStatus,
                                                   aTransportStatus, aData,
                                                   aOffset, aCount),
                         mDivertingToParent);
@@ -785,30 +798,32 @@ class MaybeDivertOnDataHttpEvent : publi
   uint32_t mCount;
 };
 
 void
 HttpChannelChild::MaybeDivertOnData(const nsCString& data,
                                     const uint64_t& offset,
                                     const uint32_t& count)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::MaybeDivertOnData [this=%p]", this));
 
   if (mDivertingToParent) {
     SendDivertOnDataAvailable(data, offset, count);
   }
 }
 
 void
 HttpChannelChild::OnTransportAndData(const nsresult& channelStatus,
                                      const nsresult& transportStatus,
                                      const uint64_t& offset,
                                      const uint32_t& count,
                                      const nsCString& data)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnTransportAndData [this=%p]\n", this));
 
   if (!mCanceled && NS_SUCCEEDED(mStatus)) {
     mStatus = channelStatus;
   }
 
   // For diversion to parent, just SendDivertOnDataAvailable.
   if (mDivertingToParent) {
@@ -881,16 +896,17 @@ HttpChannelChild::OnTransportAndData(con
 
   DoOnDataAvailable(this, mListenerContext, stringStream, offset, count);
   stringStream->Close();
 }
 
 void
 HttpChannelChild::DoOnStatus(nsIRequest* aRequest, nsresult status)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoOnStatus [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mCanceled)
     return;
 
   // cache the progress sink so we don't have to query for it each time.
   if (!mProgressSink)
@@ -916,16 +932,17 @@ HttpChannelChild::DoOnStatus(nsIRequest*
     mProgressSink->OnStatus(aRequest, nullptr, status,
                             NS_ConvertUTF8toUTF16(host).get());
   }
 }
 
 void
 HttpChannelChild::DoOnProgress(nsIRequest* aRequest, int64_t progress, int64_t progressMax)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoOnProgress [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mCanceled)
     return;
 
   // cache the progress sink so we don't have to query for it each time.
   if (!mProgressSink)
@@ -944,16 +961,17 @@ HttpChannelChild::DoOnProgress(nsIReques
   }
 }
 
 void
 HttpChannelChild::DoOnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
                                     nsIInputStream* aStream,
                                     uint64_t offset, uint32_t count)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoOnDataAvailable [this=%p]\n", this));
   if (mCanceled)
     return;
 
   nsresult rv = mListener->OnDataAvailable(aRequest, aContext, aStream, offset, count);
   if (NS_FAILED(rv)) {
     CancelOnMainThread(rv);
   }
@@ -975,16 +993,17 @@ class StopRequestEvent : public NeckoTar
   nsresult mChannelStatus;
   ResourceTimingStruct mTiming;
 };
 
 void
 HttpChannelChild::ProcessOnStopRequest(const nsresult& aChannelStatus,
                                        const ResourceTimingStruct& aTiming)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessOnStopRequest [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
     "Should not be receiving any more callbacks from parent!");
 
   mEventQ->RunOrEnqueue(new StopRequestEvent(this, aChannelStatus, aTiming),
                         mDivertingToParent);
 }
@@ -1005,29 +1024,31 @@ class MaybeDivertOnStopHttpEvent : publi
 
  private:
   nsresult mChannelStatus;
 };
 
 void
 HttpChannelChild::MaybeDivertOnStop(const nsresult& aChannelStatus)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::MaybeDivertOnStop [this=%p, "
        "mDivertingToParent=%d status=%" PRIx32 "]", this,
        static_cast<bool>(mDivertingToParent),
        static_cast<uint32_t>(aChannelStatus)));
   if (mDivertingToParent) {
     SendDivertOnStopRequest(aChannelStatus);
   }
 }
 
 void
 HttpChannelChild::OnStopRequest(const nsresult& channelStatus,
                                 const ResourceTimingStruct& timing)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnStopRequest [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(channelStatus)));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mDivertingToParent) {
     MOZ_RELEASE_ASSERT(!mFlushedForDiversion,
       "Should not be processing any more callbacks from parent!");
 
@@ -1110,30 +1131,32 @@ HttpChannelChild::OnStopRequest(const ns
     // making sure not to send any more messages after that.
     TrySendDeletingChannel();
   }
 }
 
 void
 HttpChannelChild::DoPreOnStopRequest(nsresult aStatus)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoPreOnStopRequest [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aStatus)));
   mIsPending = false;
 
   if (!mCanceled && NS_SUCCEEDED(mStatus)) {
     mStatus = aStatus;
   }
 
   CollectOMTTelemetry();
 }
 
 void
 HttpChannelChild::CollectOMTTelemetry()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(NS_IsMainThread());
 
   // Only collect telemetry for HTTP channel that is loaded successfully and
   // completely.
   if (mCanceled || NS_FAILED(mStatus)) {
     return;
   }
 
@@ -1145,16 +1168,17 @@ HttpChannelChild::CollectOMTTelemetry()
   nsAutoCString key(NS_CP_ContentTypeName(type));
 
   Telemetry::AccumulateCategoricalKeyed(key, mOMTResult);
 }
 
 void
 HttpChannelChild::DoOnStopRequest(nsIRequest* aRequest, nsresult aChannelStatus, nsISupports* aContext)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoOnStopRequest [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mIsPending);
 
   // NB: We use aChannelStatus here instead of mStatus because if there was an
   // nsCORSListenerProxy on this request, it will override the tracking
   // protection's return value.
   if (aChannelStatus == NS_ERROR_TRACKING_URI ||
@@ -1216,25 +1240,27 @@ class ProgressEvent : public NeckoTarget
  private:
   int64_t mProgress, mProgressMax;
 };
 
 void
 HttpChannelChild::ProcessOnProgress(const int64_t& aProgress,
                                     const int64_t& aProgressMax)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessOnProgress [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   mEventQ->RunOrEnqueue(new ProgressEvent(this, aProgress, aProgressMax));
 }
 
 void
 HttpChannelChild::OnProgress(const int64_t& progress,
                              const int64_t& progressMax)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnProgress [this=%p progress=%" PRId64 "/%" PRId64 "]\n",
        this, progress, progressMax));
 
   if (mCanceled)
     return;
 
   // cache the progress sink so we don't have to query for it each time.
   if (!mProgressSink) {
@@ -1264,24 +1290,26 @@ class StatusEvent : public NeckoTargetCh
 
  private:
   nsresult mStatus;
 };
 
 void
 HttpChannelChild::ProcessOnStatus(const nsresult& aStatus)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessOnStatus [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   mEventQ->RunOrEnqueue(new StatusEvent(this, aStatus));
 }
 
 void
 HttpChannelChild::OnStatus(const nsresult& status)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnStatus [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(status)));
 
   if (mCanceled)
     return;
 
   // cache the progress sink so we don't have to query for it each time.
   if (!mProgressSink)
@@ -1312,36 +1340,39 @@ class FailedAsyncOpenEvent : public Neck
 
  private:
   nsresult mStatus;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvFailedAsyncOpen(const nsresult& status)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RecvFailedAsyncOpen [this=%p]\n", this));
   mEventQ->RunOrEnqueue(new FailedAsyncOpenEvent(this, status));
   return IPC_OK();
 }
 
 // We need to have an implementation of this function just so that we can keep
 // all references to mCallOnResume of type HttpChannelChild:  it's not OK in C++
 // to set a member function ptr to a base class function.
 void
 HttpChannelChild::HandleAsyncAbort()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   HttpAsyncAborter<HttpChannelChild>::HandleAsyncAbort();
 
   // Ignore all the messages from background channel after channel aborted.
   CleanupBackgroundChannel();
 }
 
 void
 HttpChannelChild::FailedAsyncOpen(const nsresult& status)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::FailedAsyncOpen [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(status)));
   MOZ_ASSERT(NS_IsMainThread());
 
   // Might be called twice in race condition in theory.
   // (one by RecvFailedAsyncOpen, another by
   // HttpBackgroundChannelChild::ActorFailed)
   if (NS_WARN_IF(NS_FAILED(mStatus))) {
@@ -1356,16 +1387,17 @@ HttpChannelChild::FailedAsyncOpen(const 
   if (mIPCOpen) {
     TrySendDeletingChannel();
   }
 }
 
 void
 HttpChannelChild::CleanupBackgroundChannel()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MutexAutoLock lock(mBgChildMutex);
 
   LOG(("HttpChannelChild::CleanupBackgroundChannel [this=%p bgChild=%p]\n",
        this, mBgChild.get()));
 
   mBgInitFailCallback = nullptr;
 
   if (!mBgChild) {
@@ -1384,16 +1416,17 @@ HttpChannelChild::CleanupBackgroundChann
   } else {
     bgChild->OnChannelClosed();
   }
 }
 
 void
 HttpChannelChild::DoNotifyListenerCleanup()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DoNotifyListenerCleanup [this=%p]\n", this));
 
   if (mInterceptListener) {
     mInterceptListener->Cleanup();
     mInterceptListener = nullptr;
   }
 }
 
@@ -1403,16 +1436,17 @@ class DeleteSelfEvent : public NeckoTarg
   explicit DeleteSelfEvent(HttpChannelChild* child)
   : NeckoTargetChannelEvent<HttpChannelChild>(child) {}
   void Run() { mChild->DeleteSelf(); }
 };
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvDeleteSelf()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RecvDeleteSelf [this=%p]\n", this));
   mEventQ->RunOrEnqueue(new DeleteSelfEvent(this));
   return IPC_OK();
 }
 
 HttpChannelChild::OverrideRunnable::OverrideRunnable(
   HttpChannelChild* aChannel,
   HttpChannelChild* aNewChannel,
@@ -1426,24 +1460,26 @@ HttpChannelChild::OverrideRunnable::Over
   mListener = aListener;
   mInput = aInput;
   mHead = aHead;
 }
 
 void
 HttpChannelChild::OverrideRunnable::OverrideWithSynthesizedResponse()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (mNewChannel) {
     mNewChannel->OverrideWithSynthesizedResponse(mHead, mInput, mListener);
   }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::OverrideRunnable::Run()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   bool ret = mChannel->Redirect3Complete(this);
 
   // If the method returns false, it means the IPDL connection is being
   // asyncly torn down and reopened, and OverrideWithSynthesizedResponse
   // will be called later from FinishInterceptedRedirect. This object will
   // be assigned to HttpChannelChild::mOverrideRunnable in order to do so.
   // If it is true, we can call the method right now.
   if (ret) {
@@ -1451,16 +1487,17 @@ HttpChannelChild::OverrideRunnable::Run(
   }
 
   return NS_OK;
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvFinishInterceptedRedirect()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   // Hold a ref to this to keep it from being deleted by Send__delete__()
   RefPtr<HttpChannelChild> self(this);
   Send__delete__(this);
 
   {
     // Reset the event target since the IPC actor is about to be destroyed.
     // Following channel event should be handled on main thread.
     MutexAutoLock lock(mEventTargetMutex);
@@ -1479,21 +1516,23 @@ HttpChannelChild::RecvFinishInterceptedR
     NS_DISPATCH_NORMAL);
 
   return IPC_OK();
 }
 
 void
 HttpChannelChild::DeleteSelf()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   Send__delete__(this);
 }
 
 void HttpChannelChild::FinishInterceptedRedirect()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsresult rv;
   if (mLoadInfo && mLoadInfo->GetEnforceSecurity()) {
     MOZ_ASSERT(!mInterceptedRedirectContext, "the context should be null!");
     rv = AsyncOpen2(mInterceptedRedirectListener);
   } else {
     rv = AsyncOpen(mInterceptedRedirectListener, mInterceptedRedirectContext);
   }
   mInterceptedRedirectListener = nullptr;
@@ -1509,16 +1548,17 @@ void HttpChannelChild::FinishIntercepted
     mOverrideRunnable = nullptr;
   }
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvReportSecurityMessage(const nsString& messageTag,
                                             const nsString& messageCategory)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   DebugOnly<nsresult> rv = AddSecurityMessage(messageTag, messageCategory);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
   return IPC_OK();
 }
 
 class Redirect1Event : public NeckoTargetChannelEvent<HttpChannelChild>
 {
  public:
@@ -1557,16 +1597,17 @@ mozilla::ipc::IPCResult
 HttpChannelChild::RecvRedirect1Begin(const uint32_t& registrarId,
                                      const URIParams& newUri,
                                      const uint32_t& redirectFlags,
                                      const nsHttpResponseHead& responseHead,
                                      const nsCString& securityInfoSerialization,
                                      const uint64_t& channelId,
                                      const NetAddr& oldPeerAddr)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   // TODO: handle security info
   LOG(("HttpChannelChild::RecvRedirect1Begin [this=%p]\n", this));
   // We set peer address of child to the old peer,
   // Then it will be updated to new peer in OnStartRequest
   mPeerAddr = oldPeerAddr;
 
   mEventQ->RunOrEnqueue(new Redirect1Event(this, registrarId, newUri,
                                            redirectFlags, responseHead,
@@ -1576,16 +1617,17 @@ HttpChannelChild::RecvRedirect1Begin(con
 }
 
 nsresult
 HttpChannelChild::SetupRedirect(nsIURI* uri,
                                 const nsHttpResponseHead* responseHead,
                                 const uint32_t& redirectFlags,
                                 nsIChannel** outChannel)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::SetupRedirect [this=%p]\n", this));
 
   nsresult rv;
   nsCOMPtr<nsIIOService> ioService;
   rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIChannel> newChannel;
@@ -1640,16 +1682,17 @@ HttpChannelChild::SetupRedirect(nsIURI* 
 void
 HttpChannelChild::Redirect1Begin(const uint32_t& registrarId,
                                  const URIParams& newOriginalURI,
                                  const uint32_t& redirectFlags,
                                  const nsHttpResponseHead& responseHead,
                                  const nsACString& securityInfoSerialization,
                                  const uint64_t& channelId)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsresult rv;
 
   LOG(("HttpChannelChild::Redirect1Begin [this=%p]\n", this));
 
   nsCOMPtr<nsIURI> uri = DeserializeURI(newOriginalURI);
 
   if (!securityInfoSerialization.IsEmpty()) {
     NS_DeserializeObject(securityInfoSerialization,
@@ -1685,16 +1728,17 @@ HttpChannelChild::Redirect1Begin(const u
   if (NS_FAILED(rv))
     OnRedirectVerifyCallback(rv);
 }
 
 void
 HttpChannelChild::BeginNonIPCRedirect(nsIURI* responseURI,
                                       const nsHttpResponseHead* responseHead)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::BeginNonIPCRedirect [this=%p]\n", this));
 
   nsCOMPtr<nsIChannel> newChannel;
   nsresult rv = SetupRedirect(responseURI,
                               responseHead,
                               nsIChannelEventSink::REDIRECT_INTERNAL,
                               getter_AddRefs(newChannel));
 
@@ -1720,32 +1764,34 @@ HttpChannelChild::BeginNonIPCRedirect(ns
 
   if (NS_FAILED(rv))
     OnRedirectVerifyCallback(rv);
 }
 
 void
 HttpChannelChild::OverrideSecurityInfoForNonIPCRedirect(nsISupports* securityInfo)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mResponseCouldBeSynthesized = true;
   DebugOnly<nsresult> rv = OverrideSecurityInfo(securityInfo);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
 class Redirect3Event : public NeckoTargetChannelEvent<HttpChannelChild>
 {
  public:
   explicit Redirect3Event(HttpChannelChild* child)
   : NeckoTargetChannelEvent<HttpChannelChild>(child) {}
   void Run() { mChild->Redirect3Complete(nullptr); }
 };
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvRedirect3Complete()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RecvRedirect3Complete [this=%p]\n", this));
   mEventQ->RunOrEnqueue(new Redirect3Event(this));
   return IPC_OK();
 }
 
 class HttpFlushedForDiversionEvent : public NeckoTargetChannelEvent<HttpChannelChild>
 {
  public:
@@ -1759,26 +1805,28 @@ class HttpFlushedForDiversionEvent : pub
   {
     mChild->FlushedForDiversion();
   }
 };
 
 void
 HttpChannelChild::ProcessFlushedForDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessFlushedForDiversion [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   MOZ_RELEASE_ASSERT(mDivertingToParent);
 
   mEventQ->RunOrEnqueue(new HttpFlushedForDiversionEvent(this), true);
 }
 
 void
 HttpChannelChild::ProcessNotifyTrackingProtectionDisabled()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessNotifyTrackingProtectionDisabled [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
 
   RefPtr<HttpChannelChild> self = this;
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   neckoTarget->Dispatch(
     NS_NewRunnableFunction(
       "nsChannelClassifier::NotifyTrackingProtectionDisabled",
@@ -1786,56 +1834,60 @@ HttpChannelChild::ProcessNotifyTrackingP
         nsChannelClassifier::NotifyTrackingProtectionDisabled(self);
       }),
     NS_DISPATCH_NORMAL);
 }
 
 void
 HttpChannelChild::ProcessNotifyTrackingResource()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessNotifyTrackingResource [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
 
   SetIsTrackingResource();
 }
 
 void
 HttpChannelChild::FlushedForDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::FlushedForDiversion [this=%p]\n", this));
   MOZ_RELEASE_ASSERT(mDivertingToParent);
 
   // Once this is set, it should not be unset before HttpChannelChild is taken
   // down. After it is set, no OnStart/OnData/OnStop callbacks should be
   // received from the parent channel, nor dequeued from the ChannelEventQueue.
   mFlushedForDiversion = true;
 
   SendDivertComplete();
 }
 
 void
 HttpChannelChild::ProcessSetClassifierMatchedInfo(const nsCString& aList,
                                                   const nsCString& aProvider,
                                                   const nsCString& aPrefix)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessSetClassifierMatchedInfo [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
 
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   neckoTarget->Dispatch(
     NewRunnableMethod<const nsCString, const nsCString, const nsCString>
       ("HttpChannelChild::SetMatchedInfo",
        this, &HttpChannelChild::SetMatchedInfo,
        aList, aProvider, aPrefix),
     NS_DISPATCH_NORMAL);
 }
 
 void
 HttpChannelChild::ProcessDivertMessages()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ProcessDivertMessages [this=%p]\n", this));
   MOZ_ASSERT(OnSocketThread());
   MOZ_RELEASE_ASSERT(mDivertingToParent);
 
   // DivertTo() has been called on parent, so we can now start sending queued
   // IPDL messages back to parent listener.
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   MOZ_ASSERT(neckoTarget);
@@ -1852,16 +1904,17 @@ HttpChannelChild::ProcessDivertMessages(
 // Returns true if has actually completed the redirect and cleaned up the
 // channel, or false the interception logic kicked in and we need to asyncly
 // call FinishInterceptedRedirect and CleanupRedirectingChannel.
 // The argument is an optional OverrideRunnable that we pass to the redirected
 // channel.
 bool
 HttpChannelChild::Redirect3Complete(OverrideRunnable* aRunnable)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::Redirect3Complete [this=%p]\n", this));
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIHttpChannelChild> chan = do_QueryInterface(mRedirectChannelChild);
   RefPtr<HttpChannelChild> httpChannelChild = static_cast<HttpChannelChild*>(chan.get());
   // Chrome channel has been AsyncOpen'd.  Reflect this in child.
   if (mRedirectChannelChild) {
     if (httpChannelChild) {
@@ -1883,16 +1936,17 @@ HttpChannelChild::Redirect3Complete(Over
     return true;
   }
   return false;
 }
 
 void
 HttpChannelChild::CleanupRedirectingChannel(nsresult rv)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   // Redirecting to new channel: shut this down and init new channel
   if (mLoadGroup)
     mLoadGroup->RemoveRequest(this, nullptr, NS_BINDING_ABORTED);
 
   if (NS_SUCCEEDED(rv)) {
     if (mLoadInfo) {
       nsCString remoteAddress;
       Unused << GetRemoteAddress(remoteAddress);
@@ -1918,16 +1972,17 @@ HttpChannelChild::CleanupRedirectingChan
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIChildChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::ConnectParent(uint32_t registrarId)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ConnectParent [this=%p, id=%" PRIu32 "]\n", this, registrarId));
   mozilla::dom::TabChild* tabChild = nullptr;
   nsCOMPtr<nsITabChild> iTabChild;
   GetCallback(iTabChild);
   if (iTabChild) {
     tabChild = static_cast<mozilla::dom::TabChild*>(iTabChild.get());
   }
   if (MissingRequiredTabChild(tabChild, "http")) {
@@ -2000,16 +2055,17 @@ HttpChannelChild::ConnectParent(uint32_t
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::CompleteRedirectSetup(nsIStreamListener *listener,
                                         nsISupports *aContext)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::FinishRedirectSetup [this=%p]\n", this));
 
   NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 
   if (mShouldParentIntercept) {
     // This is a redirected channel, and the corresponding parent channel has started
     // AsyncOpen but was intercepted and suspended. We must tear it down and start
@@ -2061,16 +2117,17 @@ HttpChannelChild::CompleteRedirectSetup(
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIAsyncVerifyRedirectCallback
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::OnRedirectVerifyCallback(nsresult result)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::OnRedirectVerifyCallback [this=%p]\n", this));
   nsresult rv;
   OptionalURIParams redirectURI;
 
   uint32_t referrerPolicy = REFERRER_POLICY_UNSET;
   OptionalURIParams referrerURI;
   SerializeURI(nullptr, referrerURI);
 
@@ -2194,16 +2251,17 @@ HttpChannelChild::OnRedirectVerifyCallba
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::Cancel(nsresult status)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::Cancel [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!mCanceled) {
     // If this cancel occurs before nsHttpChannel has been set up, AsyncOpen
     // is responsible for cleaning up.
     mCanceled = true;
     mStatus = status;
@@ -2215,16 +2273,17 @@ HttpChannelChild::Cancel(nsresult status
     mInterceptListener = nullptr;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::Suspend()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::Suspend [this=%p, mSuspendCount=%" PRIu32 ", "
        "mDivertingToParent=%d]\n", this, mSuspendCount + 1,
        static_cast<bool>(mDivertingToParent)));
   NS_ENSURE_TRUE(RemoteChannelExists() || mInterceptListener,
                  NS_ERROR_NOT_AVAILABLE);
 
   // SendSuspend only once, when suspend goes from 0 to 1.
   // Don't SendSuspend at all if we're diverting callbacks to the parent;
@@ -2241,16 +2300,17 @@ HttpChannelChild::Suspend()
   mEventQ->Suspend();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::Resume()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::Resume [this=%p, mSuspendCount=%" PRIu32 ", "
        "mDivertingToParent=%d]\n", this, mSuspendCount - 1,
        static_cast<bool>(mDivertingToParent)));
   NS_ENSURE_TRUE(RemoteChannelExists() || mInterceptListener,
                  NS_ERROR_NOT_AVAILABLE);
   NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
 
   nsresult rv = NS_OK;
@@ -2279,24 +2339,26 @@ HttpChannelChild::Resume()
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::GetSecurityInfo(nsISupports **aSecurityInfo)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG_POINTER(aSecurityInfo);
   NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::AsyncOpen(nsIStreamListener *listener, nsISupports *aContext)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(!mLoadInfo ||
              mLoadInfo->GetSecurityMode() == 0 ||
              mLoadInfo->GetInitialSecurityCheckDone() ||
              (mLoadInfo->GetSecurityMode() == nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL &&
               nsContentUtils::IsSystemPrincipal(mLoadInfo->LoadingPrincipal())),
              "security flags in loadInfo but asyncOpen2() not called");
 
   LOG(("HttpChannelChild::AsyncOpen [this=%p uri=%s]\n", this, mSpec.get()));
@@ -2391,30 +2453,32 @@ HttpChannelChild::AsyncOpen(nsIStreamLis
   }
 
   return ContinueAsyncOpen();
 }
 
 NS_IMETHODIMP
 HttpChannelChild::AsyncOpen2(nsIStreamListener *aListener)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIStreamListener> listener = aListener;
   nsresult rv = nsContentSecurityManager::doContentSecurityCheck(this, listener);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     ReleaseListeners();
     return rv;
   }
   return AsyncOpen(listener, nullptr);
 }
 
 // Assigns an nsIEventTarget to our IPDL actor so that IPC messages are sent to
 // the correct DocGroup/TabGroup.
 void
 HttpChannelChild::SetEventTarget()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsILoadInfo> loadInfo;
   GetLoadInfo(getter_AddRefs(loadInfo));
 
   nsCOMPtr<nsIEventTarget> target =
     nsContentUtils::GetEventTargetByLoadInfo(loadInfo, TaskCategory::Network);
 
   if (!target) {
     return;
@@ -2426,46 +2490,49 @@ HttpChannelChild::SetEventTarget()
     MutexAutoLock lock(mEventTargetMutex);
     mNeckoTarget = target;
   }
 }
 
 already_AddRefed<nsIEventTarget>
 HttpChannelChild::GetNeckoTarget()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIEventTarget> target;
   {
     MutexAutoLock lock(mEventTargetMutex);
     target = mNeckoTarget;
   }
 
   if (!target) {
     target = GetMainThreadEventTarget();
   }
   return target.forget();
 }
 
 already_AddRefed<nsIEventTarget>
 HttpChannelChild::GetODATarget()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIEventTarget> target;
   {
     MutexAutoLock lock(mEventTargetMutex);
     target = mODATarget ? mODATarget : mNeckoTarget;
   }
 
   if (!target) {
     target = GetMainThreadEventTarget();
   }
   return target.forget();
 }
 
 nsresult
 HttpChannelChild::ContinueAsyncOpen()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCString appCacheClientId;
   if (mInheritApplicationCache) {
     // Pick up an application cache from the notification
     // callbacks if available
     nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
     GetCallback(appCacheContainer);
 
     if (appCacheContainer) {
@@ -2686,16 +2753,17 @@ HttpChannelChild::ContinueAsyncOpen()
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIHttpChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::SetReferrerWithPolicy(nsIURI *referrer,
                                        uint32_t referrerPolicy)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   ENSURE_CALLED_BEFORE_CONNECT();
 
   // remove old referrer if any, loop backwards
   for (int i = mClientSetRequestHeaders.Length() - 1; i >= 0; --i) {
     if (NS_LITERAL_CSTRING("Referer").Equals(mClientSetRequestHeaders[i].mHeader)) {
       mClientSetRequestHeaders.RemoveElementAt(i);
     }
   }
@@ -2706,16 +2774,17 @@ HttpChannelChild::SetReferrerWithPolicy(
   return NS_OK;
 
 }
 NS_IMETHODIMP
 HttpChannelChild::SetRequestHeader(const nsACString& aHeader,
                                    const nsACString& aValue,
                                    bool aMerge)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::SetRequestHeader [this=%p]\n", this));
   nsresult rv = HttpBaseChannel::SetRequestHeader(aHeader, aValue, aMerge);
   if (NS_FAILED(rv))
     return rv;
 
   RequestHeaderTuple* tuple = mClientSetRequestHeaders.AppendElement();
   if (!tuple)
     return NS_ERROR_OUT_OF_MEMORY;
@@ -2725,16 +2794,17 @@ HttpChannelChild::SetRequestHeader(const
   tuple->mMerge = aMerge;
   tuple->mEmpty = false;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::SetEmptyRequestHeader(const nsACString& aHeader)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::SetEmptyRequestHeader [this=%p]\n", this));
   nsresult rv = HttpBaseChannel::SetEmptyRequestHeader(aHeader);
   if (NS_FAILED(rv))
     return rv;
 
   RequestHeaderTuple* tuple = mClientSetRequestHeaders.AppendElement();
   if (!tuple)
     return NS_ERROR_OUT_OF_MEMORY;
@@ -2743,148 +2813,163 @@ HttpChannelChild::SetEmptyRequestHeader(
   tuple->mMerge = false;
   tuple->mEmpty = true;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::RedirectTo(nsIURI *newURI)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   // disabled until/unless addons run in child or something else needs this
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetProtocolVersion(nsACString& aProtocolVersion)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   aProtocolVersion = mProtocolVersion;
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIHttpChannelInternal
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::SetupFallbackChannel(const char *aFallbackKey)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   DROP_DEAD();
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsICacheInfoChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::GetCacheTokenFetchCount(int32_t *_retval)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG_POINTER(_retval);
   if (!mCacheEntryAvailable && !mAltDataCacheEntryAvailable) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   *_retval = mCacheFetchCount;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetCacheTokenExpirationTime(uint32_t *_retval)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG_POINTER(_retval);
   if (!mCacheEntryAvailable)
     return NS_ERROR_NOT_AVAILABLE;
 
   *_retval = mCacheExpirationTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetCacheTokenCachedCharset(nsACString &_retval)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (!mCacheEntryAvailable)
     return NS_ERROR_NOT_AVAILABLE;
 
   _retval = mCachedCharset;
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::SetCacheTokenCachedCharset(const nsACString &aCharset)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (!mCacheEntryAvailable || !RemoteChannelExists())
     return NS_ERROR_NOT_AVAILABLE;
 
   mCachedCharset = aCharset;
   if (!SendSetCacheTokenCachedCharset(PromiseFlatCString(aCharset))) {
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::IsFromCache(bool *value)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (!mIsPending)
     return NS_ERROR_NOT_AVAILABLE;
 
   *value = mIsFromCache;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetCacheKey(nsISupports **cacheKey)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_IF_ADDREF(*cacheKey = mCacheKey);
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::SetCacheKey(nsISupports *cacheKey)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
 
   mCacheKey = cacheKey;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::SetAllowStaleCacheContent(bool aAllowStaleCacheContent)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mAllowStaleCacheContent = aAllowStaleCacheContent;
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::GetAllowStaleCacheContent(bool *aAllowStaleCacheContent)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG(aAllowStaleCacheContent);
   *aAllowStaleCacheContent = mAllowStaleCacheContent;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::PreferAlternativeDataType(const nsACString & aType)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
   mPreferredCachedAltDataType = aType;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetAlternativeDataType(nsACString & aType)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   // Must be called during or after OnStartRequest
   if (!mAfterOnStartRequestBegun) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   aType = mAvailableCachedAltDataType;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::OpenAlternativeOutputStream(const nsACString & aType, nsIOutputStream * *_retval)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(NS_IsMainThread(), "Main thread only");
 
   if (!mIPCOpen) {
     return NS_ERROR_NOT_AVAILABLE;
   }
   if (static_cast<ContentChild*>(gNeckoChild->Manager())->IsShuttingDown()) {
     return NS_ERROR_NOT_AVAILABLE;
   }
@@ -2909,16 +2994,17 @@ HttpChannelChild::OpenAlternativeOutputS
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIResumableChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::ResumeAt(uint64_t startPos, const nsACString& entityID)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::ResumeAt [this=%p]\n", this));
   ENSURE_CALLED_BEFORE_CONNECT();
   mStartPos = startPos;
   mEntityID = entityID;
   mSendResumeAt = true;
   return NS_OK;
 }
 
@@ -2926,16 +3012,17 @@ HttpChannelChild::ResumeAt(uint64_t star
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsISupportsPriority
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::SetPriority(int32_t aPriority)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::SetPriority %p p=%d", this, aPriority));
 
   int16_t newValue = clamped<int32_t>(aPriority, INT16_MIN, INT16_MAX);
   if (mPriority == newValue)
     return NS_OK;
   mPriority = newValue;
   if (RemoteChannelExists())
     SendSetPriority(mPriority);
@@ -2943,16 +3030,17 @@ HttpChannelChild::SetPriority(int32_t aP
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIClassOfService
 //-----------------------------------------------------------------------------
 NS_IMETHODIMP
 HttpChannelChild::SetClassFlags(uint32_t inFlags)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (mClassOfService == inFlags) {
     return NS_OK;
   }
 
   mClassOfService = inFlags;
 
   LOG(("HttpChannelChild %p ClassOfService=%u", this, mClassOfService));
 
@@ -2960,29 +3048,31 @@ HttpChannelChild::SetClassFlags(uint32_t
     SendSetClassOfService(mClassOfService);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::AddClassFlags(uint32_t inFlags)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mClassOfService |= inFlags;
 
   LOG(("HttpChannelChild %p ClassOfService=%u", this, mClassOfService));
 
   if (RemoteChannelExists()) {
     SendSetClassOfService(mClassOfService);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::ClearClassFlags(uint32_t inFlags)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mClassOfService &= ~inFlags;
 
   LOG(("HttpChannelChild %p ClassOfService=%u", this, mClassOfService));
 
   if (RemoteChannelExists()) {
     SendSetClassOfService(mClassOfService);
   }
   return NS_OK;
@@ -2990,106 +3080,118 @@ HttpChannelChild::ClearClassFlags(uint32
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIProxiedChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::GetProxyInfo(nsIProxyInfo **aProxyInfo)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   DROP_DEAD();
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIApplicationCacheContainer
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::GetApplicationCache(nsIApplicationCache **aApplicationCache)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::SetApplicationCache(nsIApplicationCache *aApplicationCache)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 
   mApplicationCache = aApplicationCache;
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIApplicationCacheChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::GetApplicationCacheForWrite(nsIApplicationCache **aApplicationCache)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   *aApplicationCache = nullptr;
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::SetApplicationCacheForWrite(nsIApplicationCache *aApplicationCache)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
 
   // Child channels are not intended to be used for cache writes
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetLoadedFromApplicationCache(bool *aLoadedFromApplicationCache)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetInheritApplicationCache(bool *aInherit)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   *aInherit = mInheritApplicationCache;
   return NS_OK;
 }
 NS_IMETHODIMP
 HttpChannelChild::SetInheritApplicationCache(bool aInherit)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mInheritApplicationCache = aInherit;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetChooseApplicationCache(bool *aChoose)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   *aChoose = mChooseApplicationCache;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::SetChooseApplicationCache(bool aChoose)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mChooseApplicationCache = aChoose;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::MarkOfflineCacheEntryAsForeign()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   SendMarkOfflineCacheEntryAsForeign();
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIAssociatedContentSecurity
 //-----------------------------------------------------------------------------
 
 bool
 HttpChannelChild::GetAssociatedContentSecurity(
                     nsIAssociatedContentSecurity** _result)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (!mSecurityInfo)
     return false;
 
   nsCOMPtr<nsIAssociatedContentSecurity> assoc =
       do_QueryInterface(mSecurityInfo);
   if (!assoc)
     return false;
 
@@ -3097,55 +3199,60 @@ HttpChannelChild::GetAssociatedContentSe
     assoc.forget(_result);
   return true;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetCountSubRequestsBrokenSecurity(
                     int32_t *aSubRequestsBrokenSecurity)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
     return NS_OK;
 
   return assoc->GetCountSubRequestsBrokenSecurity(aSubRequestsBrokenSecurity);
 }
 NS_IMETHODIMP
 HttpChannelChild::SetCountSubRequestsBrokenSecurity(
                     int32_t aSubRequestsBrokenSecurity)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
     return NS_OK;
 
   return assoc->SetCountSubRequestsBrokenSecurity(aSubRequestsBrokenSecurity);
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetCountSubRequestsNoSecurity(int32_t *aSubRequestsNoSecurity)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
     return NS_OK;
 
   return assoc->GetCountSubRequestsNoSecurity(aSubRequestsNoSecurity);
 }
 NS_IMETHODIMP
 HttpChannelChild::SetCountSubRequestsNoSecurity(int32_t aSubRequestsNoSecurity)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
     return NS_OK;
 
   return assoc->SetCountSubRequestsNoSecurity(aSubRequestsNoSecurity);
 }
 
 NS_IMETHODIMP
 HttpChannelChild::Flush()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
     return NS_OK;
 
   nsresult rv;
   int32_t broken, no;
 
   rv = assoc->GetCountSubRequestsBrokenSecurity(&broken);
@@ -3160,42 +3267,46 @@ HttpChannelChild::Flush()
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIHttpChannelChild
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP HttpChannelChild::AddCookiesToRequest()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   HttpBaseChannel::AddCookiesToRequest();
   return NS_OK;
 }
 
 NS_IMETHODIMP HttpChannelChild::GetClientSetRequestHeaders(RequestHeaderTuples **aRequestHeaders)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   *aRequestHeaders = &mClientSetRequestHeaders;
   return NS_OK;
 }
 
 void
 HttpChannelChild::GetClientSetCorsPreflightParameters(OptionalCorsPreflightArgs& aArgs)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (mRequireCORSPreflight) {
     CorsPreflightArgs args;
     args.unsafeHeaders() = mUnsafeHeaders;
     aArgs = args;
   } else {
     aArgs = mozilla::void_t();
   }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::RemoveCorsPreflightCacheEntry(nsIURI* aURI,
                                                 nsIPrincipal* aPrincipal)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   URIParams uri;
   SerializeURI(aURI, uri);
   PrincipalInfo principalInfo;
   nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
   bool result = false;
@@ -3208,16 +3319,17 @@ HttpChannelChild::RemoveCorsPreflightCac
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIDivertableChannel
 //-----------------------------------------------------------------------------
 NS_IMETHODIMP
 HttpChannelChild::DivertToParent(ChannelDiverterChild **aChild)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::DivertToParent [this=%p]\n", this));
   MOZ_RELEASE_ASSERT(aChild);
   MOZ_RELEASE_ASSERT(gNeckoChild);
   MOZ_RELEASE_ASSERT(!mDivertingToParent);
 
   nsresult rv = NS_OK;
 
   // If the channel was intercepted, then we likely do not have an IPC actor
@@ -3257,27 +3369,29 @@ HttpChannelChild::DivertToParent(Channel
   *aChild = static_cast<ChannelDiverterChild*>(diverter);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::UnknownDecoderInvolvedKeepData()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::UnknownDecoderInvolvedKeepData [this=%p]",
        this));
   MOZ_ASSERT(NS_IsMainThread());
 
   mUnknownDecoderInvolved = true;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::UnknownDecoderInvolvedOnStartRequestCalled()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::UnknownDecoderInvolvedOnStartRequestCalled "
        "[this=%p, mDivertingToParent=%d]", this,
        static_cast<bool>(mDivertingToParent)));
   MOZ_ASSERT(NS_IsMainThread());
 
   mUnknownDecoderInvolved = false;
 
   nsresult rv = NS_OK;
@@ -3288,28 +3402,30 @@ HttpChannelChild::UnknownDecoderInvolved
   mUnknownDecoderEventQ.Clear();
 
   return rv;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetDivertingToParent(bool* aDiverting)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG_POINTER(aDiverting);
   *aDiverting = mDivertingToParent;
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIThreadRetargetableRequest
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelChild::RetargetDeliveryTo(nsIEventTarget* aNewTarget)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::RetargetDeliveryTo [this=%p, aNewTarget=%p]",
        this, aNewTarget));
 
   MOZ_ASSERT(NS_IsMainThread(), "Should be called on main thread only");
   MOZ_ASSERT(!mODATarget);
   MOZ_ASSERT(aNewTarget);
 
   NS_ENSURE_ARG(aNewTarget);
@@ -3344,16 +3460,17 @@ HttpChannelChild::RetargetDeliveryTo(nsI
 
   mOMTResult = LABELS_HTTP_CHILD_OMT_STATS::success;
   return NS_OK;
 }
 
 void
 HttpChannelChild::ResetInterception()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_TRUE_VOID(gNeckoChild != nullptr);
 
   if (mInterceptListener) {
     mInterceptListener->Cleanup();
   }
   mInterceptListener = nullptr;
 
   // The chance to intercept any further requests associated with this channel
@@ -3367,24 +3484,26 @@ HttpChannelChild::ResetInterception()
   if (NS_WARN_IF(NS_FAILED(rv))) {
     Unused << AsyncAbort(rv);
   }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetResponseSynthesized(bool* aSynthesized)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   NS_ENSURE_ARG_POINTER(aSynthesized);
   *aSynthesized = mSynthesizedResponse;
   return NS_OK;
 }
 
 void
 HttpChannelChild::TrySendDeletingChannel()
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (!mDeletingChannelSent.compareExchange(false, true)) {
     // SendDeletingChannel is already sent.
     return;
   }
 
   if (NS_IsMainThread()) {
     if (NS_WARN_IF(!mIPCOpen)) {
       // IPC actor is detroyed already, do not send more messages.
@@ -3404,31 +3523,33 @@ HttpChannelChild::TrySendDeletingChannel
                                &HttpChannelChild::TrySendDeletingChannel),
     NS_DISPATCH_NORMAL);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
 void
 HttpChannelChild::OnCopyComplete(nsresult aStatus)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIRunnable> runnable = NewRunnableMethod<nsresult>(
     "net::HttpBaseChannel::EnsureUploadStreamIsCloneableComplete",
     this,
     &HttpChannelChild::EnsureUploadStreamIsCloneableComplete,
     aStatus);
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   MOZ_ASSERT(neckoTarget);
 
   Unused << neckoTarget->Dispatch(runnable, NS_DISPATCH_NORMAL);
 }
 
 nsresult
 HttpChannelChild::AsyncCall(void (HttpChannelChild::*funcPtr)(),
                             nsRunnableMethod<HttpChannelChild> **retval)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsresult rv;
 
   RefPtr<nsRunnableMethod<HttpChannelChild>> event =
     NewRunnableMethod("net::HttpChannelChild::AsyncCall", this, funcPtr);
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   MOZ_ASSERT(neckoTarget);
 
   rv = neckoTarget->Dispatch(event, NS_DISPATCH_NORMAL);
@@ -3458,16 +3579,17 @@ public:
 
 private:
   const nsresult mRv;
 };
 
 void
 HttpChannelChild::CancelOnMainThread(nsresult aRv)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   LOG(("HttpChannelChild::CancelOnMainThread [this=%p]", this));
 
   if (NS_IsMainThread()) {
     Cancel(aRv);
     return;
   }
 
   mEventQ->Suspend();
@@ -3479,16 +3601,17 @@ HttpChannelChild::CancelOnMainThread(nsr
   mEventQ->Resume();
 }
 
 void
 HttpChannelChild::OverrideWithSynthesizedResponse(nsAutoPtr<nsHttpResponseHead>& aResponseHead,
                                                   nsIInputStream* aSynthesizedInput,
                                                   InterceptStreamListener* aStreamListener)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mInterceptListener = aStreamListener;
 
   // Intercepted responses should already be decoded.  If its a redirect,
   // however, we want to respect the encoding of the final result instead.
   if (!nsHttpChannel::WillRedirect(aResponseHead)) {
     SetApplyConversion(false);
   }
 
@@ -3543,52 +3666,57 @@ HttpChannelChild::OverrideWithSynthesize
     mSynthesizedResponsePump->Cancel(mStatus);
   }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::ForceIntercepted(bool aPostRedirectChannelShouldIntercept,
                                    bool aPostRedirectChannelShouldUpgrade)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mShouldParentIntercept = true;
   mPostRedirectChannelShouldIntercept = aPostRedirectChannelShouldIntercept;
   mPostRedirectChannelShouldUpgrade = aPostRedirectChannelShouldUpgrade;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelChild::ForceIntercepted(uint64_t aInterceptionID)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 void
 HttpChannelChild::ForceIntercepted(nsIInputStream* aSynthesizedInput)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mSynthesizedInput = aSynthesizedInput;
   mSynthesizedResponse = true;
   mRedirectingForSubsequentSynthesizedResponse = true;
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvIssueDeprecationWarning(const uint32_t& warning,
                                               const bool& asError)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   nsCOMPtr<nsIDeprecationWarner> warner;
   GetCallback(warner);
   if (warner) {
     warner->IssueWarning(warning, asError);
   }
   return IPC_OK();
 }
 
 bool
 HttpChannelChild::ShouldInterceptURI(nsIURI* aURI,
                                      bool& aShouldUpgrade)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   bool isHttps = false;
   nsresult rv = aURI->SchemeIs("https", &isHttps);
   NS_ENSURE_SUCCESS(rv, false);
   nsCOMPtr<nsIPrincipal> resultPrincipal;
   if (!isHttps && mLoadInfo) {
       nsContentUtils::GetSecurityManager()->
         GetChannelResultPrincipal(this, getter_AddRefs(resultPrincipal));
   }
@@ -3610,43 +3738,47 @@ HttpChannelChild::ShouldInterceptURI(nsI
   }
 
   return ShouldIntercept(upgradedURI ? upgradedURI.get() : aURI);
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvSetPriority(const int16_t& aPriority)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   mPriority = aPriority;
   return IPC_OK();
 }
 
 void
 HttpChannelChild::ActorDestroy(ActorDestroyReason aWhy)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   MOZ_ASSERT(NS_IsMainThread());
 
   // OnStartRequest might be dropped if IPDL is destroyed abnormally
   // and BackgroundChild might have pending IPC messages.
   // Clean up BackgroundChild at this time to prevent memleak.
   if (aWhy != Deletion) {
     CleanupBackgroundChannel();
   }
 }
 
 mozilla::ipc::IPCResult
 HttpChannelChild::RecvLogBlockedCORSRequest(const nsString& aMessage)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   Unused << LogBlockedCORSRequest(aMessage);
   return IPC_OK();
 }
 
 NS_IMETHODIMP
 HttpChannelChild::LogBlockedCORSRequest(const nsAString & aMessage)
 {
+  printf_stderr("### ### [%p] HttpChannelChild::%s\n", this, __func__);
   if (mLoadInfo) {
     uint64_t innerWindowID = mLoadInfo->GetInnerWindowID();
     nsCORSListenerProxy::LogBlockedCORSRequest(innerWindowID, aMessage);
   }
   return NS_OK;
 }
 
 } // namespace net
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -14,16 +14,17 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 #include "HttpBackgroundChannelParent.h"
 #include "HttpChannelParentListener.h"
+#include "InterceptedHttpChannel.h"
 #include "nsHttpHandler.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPriority.h"
 #include "nsIAuthPromptProvider.h"
 #include "nsIBackgroundChannelRegistrar.h"
 #include "nsSerializationHelper.h"
 #include "nsISerializable.h"
@@ -73,16 +74,17 @@ HttpChannelParent::HttpChannelParent(con
   , mPendingDiversion(false)
   , mDivertingFromChild(false)
   , mDivertedOnStartRequest(false)
   , mSuspendedForDiversion(false)
   , mSuspendAfterSynthesizeResponse(false)
   , mWillSynthesizeResponse(false)
   , mNestedFrameId(0)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("Creating HttpChannelParent [this=%p]\n", this));
 
   // Ensure gHttpHandler is initialized: we need the atom table up and running.
   nsCOMPtr<nsIHttpProtocolHandler> dummyInitializer =
     do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http");
 
   MOZ_ASSERT(gHttpHandler);
   mHttpHandler = gHttpHandler;
@@ -93,23 +95,25 @@ HttpChannelParent::HttpChannelParent(con
     mNestedFrameId = iframeEmbedding.get_TabId();
   }
 
   mEventQ = new ChannelEventQueue(static_cast<nsIParentRedirectingChannel*>(this));
 }
 
 HttpChannelParent::~HttpChannelParent()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("Destroying HttpChannelParent [this=%p]\n", this));
   CleanupBackgroundChannel();
 }
 
 void
 HttpChannelParent::ActorDestroy(ActorDestroyReason why)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // We may still have refcount>0 if nsHttpChannel hasn't called OnStopRequest
   // yet, but child process has crashed.  We must not try to send any more msgs
   // to child, or IPDL will kill chrome process, too.
   mIPCClosed = true;
 
   // If this is an intercepted channel, we need to make sure that any resources are
   // cleaned up to avoid leaks.
   if (mParentListener) {
@@ -117,16 +121,17 @@ HttpChannelParent::ActorDestroy(ActorDes
   }
 
   CleanupBackgroundChannel();
 }
 
 bool
 HttpChannelParent::Init(const HttpChannelCreationArgs& aArgs)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::Init [this=%p]\n", this));
   switch (aArgs.type()) {
   case HttpChannelCreationArgs::THttpChannelOpenArgs:
   {
     const HttpChannelOpenArgs& a = aArgs.get_HttpChannelOpenArgs();
     return DoAsyncOpen(a.uri(), a.original(), a.doc(), a.referrer(),
                        a.referrerPolicy(), a.apiRedirectTo(), a.topWindowURI(),
                        a.loadFlags(), a.requestHeaders(),
@@ -161,16 +166,17 @@ HttpChannelParent::Init(const HttpChanne
     NS_NOTREACHED("unknown open type");
     return false;
   }
 }
 
 void
 HttpChannelParent::TryInvokeAsyncOpen(nsresult aRv)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::TryInvokeAsyncOpen [this=%p barrier=%u rv=%" PRIx32
        "]\n", this, mAsyncOpenBarrier, static_cast<uint32_t>(aRv)));
   MOZ_ASSERT(NS_IsMainThread());
 
   // TryInvokeAsyncOpen is called more than we expected.
   // Assert in nightly build but ignore it in release channel.
   MOZ_DIAGNOSTIC_ASSERT(mAsyncOpenBarrier > 0);
   if (NS_WARN_IF(!mAsyncOpenBarrier)) {
@@ -184,29 +190,31 @@ HttpChannelParent::TryInvokeAsyncOpen(ns
 
   InvokeAsyncOpen(aRv);
 }
 
 void
 HttpChannelParent::OnBackgroundParentReady(
                                          HttpBackgroundChannelParent* aBgParent)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnBackgroundParentReady [this=%p bgParent=%p]\n",
        this, aBgParent));
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mBgParent);
 
   mBgParent = aBgParent;
 
   mPromise.ResolveIfExists(true, __func__);
 }
 
 void
 HttpChannelParent::OnBackgroundParentDestroyed()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnBackgroundParentDestroyed [this=%p]\n", this));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (!mPromise.IsEmpty()) {
     MOZ_ASSERT(!mBgParent);
     mPromise.Reject(NS_ERROR_FAILURE, __func__);
     return;
   }
@@ -218,47 +226,51 @@ HttpChannelParent::OnBackgroundParentDes
   // Background channel is closed unexpectly, abort PHttpChannel operation.
   mBgParent = nullptr;
   Delete();
 }
 
 void
 HttpChannelParent::CleanupBackgroundChannel()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::CleanupBackgroundChannel [this=%p bgParent=%p]\n",
        this, mBgParent.get()));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (mBgParent) {
     RefPtr<HttpBackgroundChannelParent> bgParent = mBgParent.forget();
     bgParent->OnChannelClosed();
     return;
   }
 
   // The nsHttpChannel may have a reference to this parent, release it
   // to avoid circular references.
-  if (mChannel) {
-    mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
   }
 
   if (!mPromise.IsEmpty()) {
     mRequest.DisconnectIfExists();
     mPromise.Reject(NS_ERROR_FAILURE, __func__);
 
     if (!mChannel) {
       return;
     }
 
     // This HttpChannelParent might still have a reference from
     // BackgroundChannelRegistrar.
     nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
       do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
     MOZ_ASSERT(registrar);
 
-    registrar->DeleteChannel(mChannel->ChannelId());
+    uint64_t channelId = 0;
+    MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+    registrar->DeleteChannel(channelId);
 
     // If mAsyncOpenBarrier is greater than zero, it means AsyncOpen procedure
     // is still on going. we need to abort AsyncOpen with failure to destroy
     // PHttpChannel actor.
     if (mAsyncOpenBarrier) {
       TryInvokeAsyncOpen(NS_ERROR_FAILURE);
     }
   }
@@ -344,32 +356,34 @@ HttpChannelParent::GetInterface(const ns
 
 //-----------------------------------------------------------------------------
 // HttpChannelParent::PHttpChannelParent
 //-----------------------------------------------------------------------------
 
 void
 HttpChannelParent::AsyncOpenFailed(nsresult aRv)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(NS_FAILED(aRv));
 
   // Break the reference cycle among HttpChannelParent,
   // HttpChannelParentListener, and nsHttpChannel to avoid memory leakage.
   mChannel = nullptr;
   mParentListener = nullptr;
 
   if (!mIPCClosed) {
     Unused << SendFailedAsyncOpen(aRv);
   }
 }
 
 void
 HttpChannelParent::InvokeAsyncOpen(nsresult rv)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::InvokeAsyncOpen [this=%p rv=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(rv)));
   MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_FAILED(rv)) {
     AsyncOpenFailed(rv);
     return;
   }
@@ -477,16 +491,17 @@ HttpChannelParent::DoAsyncOpen(  const U
                                  const TimeStamp&           aLaunchServiceWorkerStart,
                                  const TimeStamp&           aLaunchServiceWorkerEnd,
                                  const TimeStamp&           aDispatchFetchEventStart,
                                  const TimeStamp&           aDispatchFetchEventEnd,
                                  const TimeStamp&           aHandleFetchEventStart,
                                  const TimeStamp&           aHandleFetchEventEnd,
                                  const bool&                aForceMainDocumentChannel)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsCOMPtr<nsIURI> uri = DeserializeURI(aURI);
   if (!uri) {
     // URIParams does MOZ_ASSERT if null, but we need to protect opt builds from
     // null deref here.
     return false;
   }
   nsCOMPtr<nsIURI> originalUri = DeserializeURI(aOriginalURI);
   nsCOMPtr<nsIURI> docUri = DeserializeURI(aDocURI);
@@ -509,85 +524,130 @@ HttpChannelParent::DoAsyncOpen(  const U
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   if (!loadInfo) {
     return SendFailedAsyncOpen(NS_ERROR_UNEXPECTED);
   }
 
-  nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
-                             nullptr, nullptr, aLoadFlags, ios);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
+  RefPtr<HttpBaseChannel> httpChannel;
+
+  if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
+    const nsHttpResponseHead& head =
+      aSynthesizedResponseHead.get_nsHttpResponseHead();
+
+    nsCOMPtr<nsIInputStream> body;
+    rv = NS_NewCStringInputStream(getter_AddRefs(body), EmptyCString());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    httpChannel = InterceptedHttpChannel::CreateForSynthesis(&head, body);
+    if (NS_WARN_IF(!httpChannel)) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    rv = httpChannel->Init(uri, 0, nullptr, 0, nullptr, aChannelId);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    rv = httpChannel->SetLoadInfo(loadInfo);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+  } else {
+    nsCOMPtr<nsIChannel> channel;
+    rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
+                               nullptr, nullptr, aLoadFlags, ios);
+    if (NS_FAILED(rv)) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    httpChannel = do_QueryObject(channel);
+    if (!httpChannel) {
+      return SendFailedAsyncOpen(NS_ERROR_FAILURE);
+    }
   }
 
-  RefPtr<nsHttpChannel> httpChannel = do_QueryObject(channel, &rv);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
-  }
+  MOZ_DIAGNOSTIC_ASSERT(httpChannel);
 
   // Set the channelId allocated in child to the parent instance
-  httpChannel->SetChannelId(aChannelId);
-  httpChannel->SetTopLevelContentWindowId(aContentWindowId);
-  httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  rv = httpChannel->SetChannelId(aChannelId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelContentWindowId(aContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
-  httpChannel->SetWarningReporter(this);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
   httpChannel->SetTimingEnabled(true);
   if (mPBOverride != kPBOverride_Unset) {
     httpChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
   }
 
-  if (doResumeAt)
+  if (doResumeAt) {
     httpChannel->ResumeAt(startPos, entityID);
+  }
 
   if (originalUri)
     httpChannel->SetOriginalURI(originalUri);
-  if (docUri)
-    httpChannel->SetDocumentURI(docUri);
+  if (docUri) {
+    rv = httpChannel->SetDocumentURI(docUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (referrerUri) {
     rv = httpChannel->SetReferrerWithPolicyInternal(referrerUri, aReferrerPolicy);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
-  if (apiRedirectToUri)
-    httpChannel->RedirectTo(apiRedirectToUri);
+  if (apiRedirectToUri) {
+    rv = httpChannel->RedirectTo(apiRedirectToUri);
+    MOZ_ALWAYS_SUCCEEDS(rv);
+  }
   if (topWindowUri) {
-    rv = httpChannel->SetTopWindowURI(topWindowUri);
+    rv = httpChannel->SetTopWindowURIIfUnknown(topWindowUri);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
   if (aLoadFlags != nsIRequest::LOAD_NORMAL)
     httpChannel->SetLoadFlags(aLoadFlags);
 
   if (aForceMainDocumentChannel) {
-    httpChannel->SetIsMainDocumentChannel(true);
+    rv = httpChannel->SetIsMainDocumentChannel(true);
+    MOZ_ALWAYS_SUCCEEDS(rv);
   }
 
   for (uint32_t i = 0; i < requestHeaders.Length(); i++) {
     if (requestHeaders[i].mEmpty) {
-      httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      rv = httpChannel->SetEmptyRequestHeader(requestHeaders[i].mHeader);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     } else {
-      httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
-                                 requestHeaders[i].mValue,
-                                 requestHeaders[i].mMerge);
+      rv = httpChannel->SetRequestHeader(requestHeaders[i].mHeader,
+                                         requestHeaders[i].mValue,
+                                         requestHeaders[i].mMerge);
+      MOZ_ALWAYS_SUCCEEDS(rv);
     }
   }
 
   RefPtr<HttpChannelParentListener> parentListener
     = new HttpChannelParentListener(this);
 
-  httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  rv = httpChannel->SetRequestMethod(nsDependentCString(requestMethod.get()));
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   if (aCorsPreflightArgs.type() == OptionalCorsPreflightArgs::TCorsPreflightArgs) {
     const CorsPreflightArgs& args = aCorsPreflightArgs.get_CorsPreflightArgs();
     httpChannel->SetCorsPreflightParameters(args.unsafeHeaders());
   }
 
   nsCOMPtr<nsIInputStream> stream = DeserializeIPCStream(uploadStream);
-  if (stream) {
+  if (stream && httpChannelImpl) {
     // FIXME: The fast path of using the existing stream currently only applies to streams
     //   that have had their entire contents serialized from the child at this point.
     //   Once bug 1294446 and bug 1294450 are fixed it is worth revisiting this heuristic.
     nsCOMPtr<nsIIPCSerializableInputStream> completeStream = do_QueryInterface(stream);
     if (!completeStream) {
       // Wait for completion of async copying IPC upload stream to a local input stream.
       ++mAsyncOpenBarrier;
 
@@ -630,23 +690,24 @@ HttpChannelParent::DoAsyncOpen(  const U
       // the AsyncOpen process once the full stream has been received.
       rv = NS_AsyncCopy(stream, sink, target, NS_ASYNCCOPY_VIA_READSEGMENTS,
                         kBufferSize, // copy segment size
                         UploadCopyComplete, closure.release());
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return SendFailedAsyncOpen(rv);
       }
 
-      httpChannel->InternalSetUploadStream(newUploadStream);
+      httpChannelImpl->InternalSetUploadStream(newUploadStream);
     } else {
-      httpChannel->InternalSetUploadStream(stream);
+      httpChannelImpl->InternalSetUploadStream(stream);
     }
-    httpChannel->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
+    httpChannelImpl->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
+  /*
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
     parentListener->SetupInterception(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mWillSynthesizeResponse = true;
     httpChannel->SetCouldBeSynthesized();
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
@@ -654,50 +715,64 @@ HttpChannelParent::DoAsyncOpen(  const U
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   } else {
     nsLoadFlags newLoadFlags;
     httpChannel->GetLoadFlags(&newLoadFlags);
     newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
     httpChannel->SetLoadFlags(newLoadFlags);
   }
+  */
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   rv = cacheKey->SetData(aCacheKey);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
-  httpChannel->SetCacheKey(cacheKey);
-  httpChannel->PreferAlternativeDataType(aPreferredAlternativeType);
+  nsCOMPtr<nsICacheInfoChannel> cacheChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(httpChannel));
+  if (cacheChannel) {
+    cacheChannel->SetCacheKey(cacheKey);
+    cacheChannel->PreferAlternativeDataType(aPreferredAlternativeType);
 
-  httpChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
+    cacheChannel->SetAllowStaleCacheContent(aAllowStaleCacheContent);
+  }
 
   httpChannel->SetContentType(aContentTypeHint);
 
   if (priority != nsISupportsPriority::PRIORITY_NORMAL) {
     httpChannel->SetPriority(priority);
   }
   if (classOfService) {
     httpChannel->SetClassFlags(classOfService);
   }
-  httpChannel->SetRedirectionLimit(redirectionLimit);
-  httpChannel->SetAllowSTS(allowSTS);
-  httpChannel->SetThirdPartyFlags(thirdPartyFlags);
-  httpChannel->SetAllowSpdy(allowSpdy);
-  httpChannel->SetAllowAltSvc(allowAltSvc);
-  httpChannel->SetBeConservative(beConservative);
-  httpChannel->SetTlsFlags(tlsFlags);
-  httpChannel->SetInitialRwin(aInitialRwin);
-  httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  rv = httpChannel->SetRedirectionLimit(redirectionLimit);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowSTS(allowSTS);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetThirdPartyFlags(thirdPartyFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowSpdy(allowSpdy);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetAllowAltSvc(allowAltSvc);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetBeConservative(beConservative);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetTlsFlags(tlsFlags);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetInitialRwin(aInitialRwin);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = httpChannel->SetBlockAuthPrompt(aBlockAuthPrompt);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   httpChannel->SetLaunchServiceWorkerStart(aLaunchServiceWorkerStart);
   httpChannel->SetLaunchServiceWorkerEnd(aLaunchServiceWorkerEnd);
   httpChannel->SetDispatchFetchEventStart(aDispatchFetchEventStart);
   httpChannel->SetDispatchFetchEventEnd(aDispatchFetchEventEnd);
   httpChannel->SetHandleFetchEventStart(aHandleFetchEventStart);
   httpChannel->SetHandleFetchEventEnd(aHandleFetchEventEnd);
 
@@ -733,17 +808,18 @@ HttpChannelParent::DoAsyncOpen(  const U
       // This works because we've already called SetNotificationCallbacks and
       // done mPBOverride logic by this point.
       chooseAppCache = NS_ShouldCheckAppCache(principal);
 
       appCacheChan->SetChooseApplicationCache(chooseAppCache);
     }
   }
 
-  httpChannel->SetRequestContextID(aRequestContextID);
+  rv = httpChannel->SetRequestContextID(aRequestContextID);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   // Store the strong reference of channel and parent listener object until
   // all the initialization procedure is complete without failure, to remove
   // cycle reference in fail case and to avoid memory leakage.
   mChannel = httpChannel.forget();
   mParentListener = parentListener.forget();
   mChannel->SetNotificationCallbacks(mParentListener);
 
@@ -768,39 +844,43 @@ HttpChannelParent::DoAsyncOpen(  const U
          ->Track(mRequest);
 
   return true;
 }
 
 already_AddRefed<GenericPromise>
 HttpChannelParent::WaitForBgParent()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::WaitForBgParent [this=%p]\n", this));
   MOZ_ASSERT(!mBgParent);
   MOZ_ASSERT(mChannel);
 
 
   nsCOMPtr<nsIBackgroundChannelRegistrar> registrar =
     do_GetService(NS_BACKGROUNDCHANNELREGISTRAR_CONTRACTID);
   MOZ_ASSERT(registrar);
-  registrar->LinkHttpChannel(mChannel->ChannelId(), this);
+  uint64_t channelId = 0;
+  MOZ_ALWAYS_SUCCEEDS(mChannel->GetChannelId(&channelId));
+  registrar->LinkHttpChannel(channelId, this);
 
   if (mBgParent) {
     already_AddRefed<GenericPromise> promise = mPromise.Ensure(__func__);
     // resolve promise immediatedly if bg channel is ready.
     mPromise.Resolve(true, __func__);
     return promise;
   }
 
   return mPromise.Ensure(__func__);;
 }
 
 bool
 HttpChannelParent::ConnectChannel(const uint32_t& registrarId, const bool& shouldIntercept)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsresult rv;
 
   LOG(("HttpChannelParent::ConnectChannel: Looking for a registered channel "
        "[this=%p, id=%" PRIu32 "]\n", this, registrarId));
   nsCOMPtr<nsIChannel> channel;
   rv = NS_LinkRedirectChannels(registrarId, this, getter_AddRefs(channel));
   if (NS_FAILED(rv)) {
     NS_ERROR("Could not find the http channel to connect its IPC parent");
@@ -816,17 +896,20 @@ HttpChannelParent::ConnectChannel(const 
   if (!mChannel) {
     LOG(("  but it's not nsHttpChannel"));
     Delete();
     return true;
   }
 
   LOG(("  and it is nsHttpChannel %p", mChannel.get()));
 
-  mChannel->SetWarningReporter(this);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(this);
+  }
 
   nsCOMPtr<nsINetworkInterceptController> controller;
   NS_QueryNotificationCallbacks(channel, controller);
   RefPtr<HttpChannelParentListener> parentListener = do_QueryObject(controller);
   MOZ_ASSERT(parentListener);
   parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
 
   if (mPBOverride != kPBOverride_Unset) {
@@ -852,16 +935,17 @@ HttpChannelParent::ConnectChannel(const 
                 })
          ->Track(mRequest);
   return true;
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSetPriority(const int16_t& priority)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvSetPriority [this=%p, priority=%d]\n",
        this, priority));
 
   if (mChannel) {
     mChannel->SetPriority(priority);
   }
 
   nsCOMPtr<nsISupportsPriority> priorityRedirectChannel =
@@ -870,69 +954,75 @@ HttpChannelParent::RecvSetPriority(const
     priorityRedirectChannel->SetPriority(priority);
 
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSetClassOfService(const uint32_t& cos)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mChannel) {
     mChannel->SetClassFlags(cos);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSuspend()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvSuspend [this=%p]\n", this));
 
   if (mChannel) {
     mChannel->Suspend();
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvResume()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvResume [this=%p]\n", this));
 
   if (mChannel) {
     mChannel->Resume();
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvCancel(const nsresult& status)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvCancel [this=%p]\n", this));
 
   // May receive cancel before channel has been constructed!
   if (mChannel) {
     mChannel->Cancel(status);
   }
   return IPC_OK();
 }
 
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvSetCacheTokenCachedCharset(const nsCString& charset)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mCacheEntry)
     mCacheEntry->SetMetaDataElement("charset", charset.get());
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvUpdateAssociatedContentSecurity(const int32_t& broken,
                                                        const int32_t& no)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mAssociatedContentSecurity) {
     mAssociatedContentSecurity->SetCountSubRequestsBrokenSecurity(broken);
     mAssociatedContentSecurity->SetCountSubRequestsNoSecurity(no);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
@@ -942,16 +1032,17 @@ HttpChannelParent::RecvRedirect2Verify(c
                                        const uint32_t& referrerPolicy,
                                        const OptionalURIParams& aReferrerURI,
                                        const OptionalURIParams& aAPIRedirectURI,
                                        const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                        const bool& aForceHSTSPriming,
                                        const bool& aMixedContentWouldBlock,
                                        const bool& aChooseAppcache)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvRedirect2Verify [this=%p result=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(result)));
   nsresult rv;
   if (NS_SUCCEEDED(result)) {
     nsCOMPtr<nsIHttpChannel> newHttpChannel =
         do_QueryInterface(mRedirectChannel);
 
     if (newHttpChannel) {
@@ -1073,16 +1164,17 @@ HttpChannelParent::ContinueVerification(
                   callback->ReadyToVerify(aResult);
                 });
   return NS_OK;
 }
 
 void
 HttpChannelParent::ContinueRedirect2Verify(const nsresult& aResult)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::ContinueRedirect2Verify [this=%p result=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aResult)));
 
   if (!mRedirectCallback) {
     // This should according the logic never happen, log the situation.
     if (mReceivedRedirect2Verify)
       LOG(("RecvRedirect2Verify[%p]: Duplicate fire", this));
     if (mSentRedirect1BeginFailed)
@@ -1107,26 +1199,28 @@ HttpChannelParent::ContinueRedirect2Veri
     mRedirectCallback->OnRedirectVerifyCallback(aResult);
     mRedirectCallback = nullptr;
   }
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvDocumentChannelCleanup()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // From now on only using mAssociatedContentSecurity.  Free everything else.
   CleanupBackgroundChannel(); // Background channel can be closed.
   mChannel = nullptr;          // Reclaim some memory sooner.
   mCacheEntry = nullptr;  // Else we'll block other channels reading same URI
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvMarkOfflineCacheEntryAsForeign()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mOfflineForeignMarker) {
     mOfflineForeignMarker->MarkAsForeign();
     mOfflineForeignMarker = 0;
   }
 
   return IPC_OK();
 }
 
@@ -1156,16 +1250,17 @@ private:
   uint32_t mCount;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvDivertOnDataAvailable(const nsCString& data,
                                              const uint64_t& offset,
                                              const uint32_t& count)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvDivertOnDataAvailable [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot RecvDivertOnDataAvailable if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return IPC_FAIL_NO_REASON(this);
@@ -1181,16 +1276,17 @@ HttpChannelParent::RecvDivertOnDataAvail
   return IPC_OK();
 }
 
 void
 HttpChannelParent::DivertOnDataAvailable(const nsCString& data,
                                          const uint64_t& offset,
                                          const uint32_t& count)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::DivertOnDataAvailable [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot DivertOnDataAvailable if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return;
@@ -1242,16 +1338,17 @@ public:
 private:
   HttpChannelParent* mParent;
   nsresult mStatusCode;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvDivertOnStopRequest(const nsresult& statusCode)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvDivertOnStopRequest [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot RecvDivertOnStopRequest if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return IPC_FAIL_NO_REASON(this);
@@ -1259,16 +1356,17 @@ HttpChannelParent::RecvDivertOnStopReque
 
   mEventQ->RunOrEnqueue(new DivertStopRequestEvent(this, statusCode));
   return IPC_OK();
 }
 
 void
 HttpChannelParent::DivertOnStopRequest(const nsresult& statusCode)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::DivertOnStopRequest [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot DivertOnStopRequest if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return;
@@ -1300,16 +1398,17 @@ public:
 
 private:
   HttpChannelParent* mParent;
 };
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvDivertComplete()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvDivertComplete [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot RecvDivertComplete if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return IPC_FAIL_NO_REASON(this);
@@ -1317,16 +1416,17 @@ HttpChannelParent::RecvDivertComplete()
 
   mEventQ->RunOrEnqueue(new DivertCompleteEvent(this));
   return IPC_OK();
 }
 
 void
 HttpChannelParent::DivertComplete()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::DivertComplete [this=%p]\n", this));
 
   MOZ_ASSERT(mParentListener);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot DivertComplete if diverting is not set!");
     FailDiversion(NS_ERROR_UNEXPECTED);
     return;
@@ -1339,16 +1439,17 @@ HttpChannelParent::DivertComplete()
   }
 
   mParentListener = nullptr;
 }
 
 void
 HttpChannelParent::MaybeFlushPendingDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (!mPendingDiversion) {
     return;
   }
 
   mPendingDiversion = false;
 
   nsresult rv = SuspendForDiversion();
   if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -1359,16 +1460,17 @@ HttpChannelParent::MaybeFlushPendingDive
     DivertTo(mDivertListener);
   }
 
 }
 
 void
 HttpChannelParent::ResponseSynthesized()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // Suspend now even though the FinishSynthesizeResponse runnable has
   // not executed.  We want to suspend after we get far enough to trigger
   // the synthesis, but not actually allow the nsHttpChannel to trigger
   // any OnStartRequests().
   if (mSuspendAfterSynthesizeResponse) {
     mChannel->Suspend();
   }
 
@@ -1376,16 +1478,17 @@ HttpChannelParent::ResponseSynthesized()
 
   MaybeFlushPendingDiversion();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvRemoveCorsPreflightCacheEntry(const URIParams& uri,
   const mozilla::ipc::PrincipalInfo& requestingPrincipal)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsCOMPtr<nsIURI> deserializedURI = DeserializeURI(uri);
   if (!deserializedURI) {
     return IPC_FAIL_NO_REASON(this);
   }
   nsCOMPtr<nsIPrincipal> principal =
     PrincipalInfoToPrincipal(requestingPrincipal);
   if (!principal) {
     return IPC_FAIL_NO_REASON(this);
@@ -1397,107 +1500,119 @@ HttpChannelParent::RecvRemoveCorsPreflig
 
 //-----------------------------------------------------------------------------
 // HttpChannelParent::nsIRequestObserver
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::OnStartRequest(nsIRequest *aRequest, nsISupports *aContext)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnStartRequest [this=%p, aRequest=%p]\n",
        this, aRequest));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStartRequest if diverting is set!");
 
-  RefPtr<nsHttpChannel> chan = do_QueryObject(aRequest);
+  RefPtr<HttpBaseChannel> chan = do_QueryObject(aRequest);
   if (!chan) {
-    LOG(("  aRequest is not nsHttpChannel"));
-    NS_ERROR("Expecting only nsHttpChannel as aRequest in HttpChannelParent::OnStartRequest");
+    LOG(("  aRequest is not HttpBaseChannel"));
+    NS_ERROR("Expecting only HttpBaseChannel as aRequest in HttpChannelParent::OnStartRequest");
     return NS_ERROR_UNEXPECTED;
   }
 
   MOZ_ASSERT(mChannel == chan,
-             "HttpChannelParent getting OnStartRequest from a different nsHttpChannel instance");
+             "HttpChannelParent getting OnStartRequest from a different HttpBaseChannel instance");
 
   // Send down any permissions which are relevant to this URL if we are
   // performing a document load. We can't do that is mIPCClosed is set.
   if (!mIPCClosed) {
     PContentParent* pcp = Manager()->Manager();
     MOZ_ASSERT(pcp, "We should have a manager if our IPC isn't closed");
     DebugOnly<nsresult> rv =
       static_cast<ContentParent*>(pcp)->AboutToLoadHttpFtpWyciwygDocumentForChild(chan);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 
   nsHttpResponseHead *responseHead = chan->GetResponseHead();
   nsHttpRequestHead  *requestHead = chan->GetRequestHead();
+
   bool isFromCache = false;
-  chan->IsFromCache(&isFromCache);
   int32_t fetchCount = 0;
-  chan->GetCacheTokenFetchCount(&fetchCount);
   uint32_t expirationTime = nsICacheEntry::NO_EXPIRATION_TIME;
-  chan->GetCacheTokenExpirationTime(&expirationTime);
   nsCString cachedCharset;
-  chan->GetCacheTokenCachedCharset(cachedCharset);
 
-  bool loadedFromApplicationCache;
-  chan->GetLoadedFromApplicationCache(&loadedFromApplicationCache);
-  if (loadedFromApplicationCache) {
-    mOfflineForeignMarker = chan->GetOfflineCacheEntryAsForeignMarker();
-    nsCOMPtr<nsIApplicationCache> appCache;
-    chan->GetApplicationCache(getter_AddRefs(appCache));
-    nsCString appCacheGroupId;
-    nsCString appCacheClientId;
-    appCache->GetGroupID(appCacheGroupId);
-    appCache->GetClientID(appCacheClientId);
-    if (mIPCClosed ||
-        !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
-    {
-      return NS_ERROR_UNEXPECTED;
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(chan);
+
+  if (httpChannelImpl) {
+    httpChannelImpl->IsFromCache(&isFromCache);
+    httpChannelImpl->GetCacheTokenFetchCount(&fetchCount);
+    httpChannelImpl->GetCacheTokenExpirationTime(&expirationTime);
+    httpChannelImpl->GetCacheTokenCachedCharset(cachedCharset);
+  }
+
+  bool loadedFromApplicationCache = false;
+
+  if (httpChannelImpl) {
+    httpChannelImpl->GetLoadedFromApplicationCache(&loadedFromApplicationCache);
+    if (loadedFromApplicationCache) {
+      mOfflineForeignMarker = httpChannelImpl->GetOfflineCacheEntryAsForeignMarker();
+      nsCOMPtr<nsIApplicationCache> appCache;
+      httpChannelImpl->GetApplicationCache(getter_AddRefs(appCache));
+      nsCString appCacheGroupId;
+      nsCString appCacheClientId;
+      appCache->GetGroupID(appCacheGroupId);
+      appCache->GetClientID(appCacheClientId);
+      if (mIPCClosed ||
+          !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
+      {
+        return NS_ERROR_UNEXPECTED;
+      }
     }
   }
 
-  nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(aRequest);
-  if (encodedChannel)
-    encodedChannel->SetApplyConversion(false);
+  chan->SetApplyConversion(false);
 
   // Keep the cache entry for future use in RecvSetCacheTokenCachedCharset().
   // It could be already released by nsHttpChannel at that time.
   nsCOMPtr<nsISupports> cacheEntry;
-  chan->GetCacheToken(getter_AddRefs(cacheEntry));
-  mCacheEntry = do_QueryInterface(cacheEntry);
+  nsresult channelStatus = NS_OK;
+  uint32_t cacheKeyValue = 0;
+  nsAutoCString altDataType;
 
-  nsresult channelStatus = NS_OK;
-  chan->GetStatus(&channelStatus);
+  if (httpChannelImpl) {
+    httpChannelImpl->GetCacheToken(getter_AddRefs(cacheEntry));
+    mCacheEntry = do_QueryInterface(cacheEntry);
+
+    httpChannelImpl->GetStatus(&channelStatus);
+
+    nsCOMPtr<nsISupports> cacheKey;
+    httpChannelImpl->GetCacheKey(getter_AddRefs(cacheKey));
+    if (cacheKey) {
+      nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(cacheKey);
+      if (!container) {
+        return NS_ERROR_ILLEGAL_VALUE;
+      }
+
+      nsresult rv = container->GetData(&cacheKeyValue);
+      if (NS_FAILED(rv)) {
+        return rv;
+      }
+    }
+
+    httpChannelImpl->GetAlternativeDataType(altDataType);
+  }
 
   nsCString secInfoSerialization;
   UpdateAndSerializeSecurityInfo(secInfoSerialization);
 
   uint16_t redirectCount = 0;
   chan->GetRedirectCount(&redirectCount);
 
-  nsCOMPtr<nsISupports> cacheKey;
-  chan->GetCacheKey(getter_AddRefs(cacheKey));
-  uint32_t cacheKeyValue = 0;
-  if (cacheKey) {
-    nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(cacheKey);
-    if (!container) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-
-    nsresult rv = container->GetData(&cacheKeyValue);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-  }
-
-  nsAutoCString altDataType;
-  chan->GetAlternativeDataType(altDataType);
   int64_t altDataLen = chan->GetAltDataLength();
 
   // !!! We need to lock headers and please don't forget to unlock them !!!
   requestHead->Enter();
   nsresult rv = NS_OK;
   if (mIPCClosed ||
       !SendOnStartRequest(channelStatus,
                           responseHead ? *responseHead : nsHttpResponseHead(),
@@ -1530,44 +1645,52 @@ HttpChannelParent::OnStartRequest(nsIReq
   return rv;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::OnStopRequest(nsIRequest *aRequest,
                                  nsISupports *aContext,
                                  nsresult aStatusCode)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnStopRequest: [this=%p aRequest=%p status=%" PRIx32 "]\n",
        this, aRequest, static_cast<uint32_t>(aStatusCode)));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStopRequest if diverting is set!");
+
   ResourceTimingStruct timing;
   mChannel->GetDomainLookupStart(&timing.domainLookupStart);
   mChannel->GetDomainLookupEnd(&timing.domainLookupEnd);
   mChannel->GetConnectStart(&timing.connectStart);
   mChannel->GetSecureConnectionStart(&timing.secureConnectionStart);
   mChannel->GetConnectEnd(&timing.connectEnd);
   mChannel->GetRequestStart(&timing.requestStart);
   mChannel->GetResponseStart(&timing.responseStart);
   mChannel->GetResponseEnd(&timing.responseEnd);
   mChannel->GetAsyncOpen(&timing.fetchStart);
   mChannel->GetRedirectStart(&timing.redirectStart);
   mChannel->GetRedirectEnd(&timing.redirectEnd);
-  mChannel->GetTransferSize(&timing.transferSize);
-  mChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  nsresult rv = mChannel->GetTransferSize(&timing.transferSize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
+  rv = mChannel->GetEncodedBodySize(&timing.encodedBodySize);
+  MOZ_ALWAYS_SUCCEEDS(rv);
   // decodedBodySize can be computed in the child process so it doesn't need
   // to be passed down.
-  mChannel->GetProtocolVersion(timing.protocolVersion);
+  rv = mChannel->GetProtocolVersion(timing.protocolVersion);
+  MOZ_ALWAYS_SUCCEEDS(rv);
 
   mChannel->GetCacheReadStart(&timing.cacheReadStart);
   mChannel->GetCacheReadEnd(&timing.cacheReadEnd);
 
-  mChannel->SetWarningReporter(nullptr);
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl) {
+    httpChannelImpl->SetWarningReporter(nullptr);
+  }
 
   // Either IPC channel is closed or background channel
   // is ready to send OnStopRequest.
   MOZ_ASSERT(mIPCClosed || mBgParent);
 
   if (mIPCClosed ||
       !mBgParent || !mBgParent->OnStopRequest(aStatusCode, timing)) {
     return NS_ERROR_UNEXPECTED;
@@ -1582,29 +1705,32 @@ HttpChannelParent::OnStopRequest(nsIRequ
 
 NS_IMETHODIMP
 HttpChannelParent::OnDataAvailable(nsIRequest *aRequest,
                                    nsISupports *aContext,
                                    nsIInputStream *aInputStream,
                                    uint64_t aOffset,
                                    uint32_t aCount)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnDataAvailable [this=%p aRequest=%p offset=%" PRIu64
        " count=%" PRIu32 "]\n", this, aRequest, aOffset, aCount));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnDataAvailable if diverting is set!");
 
   nsresult channelStatus = NS_OK;
   mChannel->GetStatus(&channelStatus);
 
-  nsresult transportStatus =
-    (mChannel->IsReadingFromCache()) ? NS_NET_STATUS_READING
-                                     : NS_NET_STATUS_RECEIVING_FROM;
+  nsresult transportStatus = NS_NET_STATUS_RECEIVING_FROM;
+  RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
+  if (httpChannelImpl && httpChannelImpl->IsReadingFromCache()) {
+    transportStatus = NS_NET_STATUS_READING;
+  }
 
   static uint32_t const kCopyChunkSize = 128 * 1024;
   uint32_t toRead = std::min<uint32_t>(aCount, kCopyChunkSize);
 
   nsCString data;
   if (!data.SetCapacity(toRead, fallible)) {
     LOG(("  out of memory!"));
     return NS_ERROR_OUT_OF_MEMORY;
@@ -1639,16 +1765,17 @@ HttpChannelParent::OnDataAvailable(nsIRe
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::OnProgress(nsIRequest *aRequest,
                               nsISupports *aContext,
                               int64_t aProgress,
                               int64_t aProgressMax)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnStatus [this=%p progress=%" PRId64 "max=%" PRId64
        "]\n", this, aProgress, aProgressMax));
   MOZ_ASSERT(NS_IsMainThread());
 
   // If it indicates this precedes OnDataAvailable, child can derive the value in ODA.
   if (mIgnoreProgress) {
     mIgnoreProgress = false;
     return NS_OK;
@@ -1670,16 +1797,17 @@ HttpChannelParent::OnProgress(nsIRequest
 }
 
 NS_IMETHODIMP
 HttpChannelParent::OnStatus(nsIRequest *aRequest,
                             nsISupports *aContext,
                             nsresult aStatus,
                             const char16_t *aStatusArg)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::OnStatus [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aStatus)));
   MOZ_ASSERT(NS_IsMainThread());
 
   // If this precedes OnDataAvailable, transportStatus will be derived in ODA.
   if (aStatus == NS_NET_STATUS_RECEIVING_FROM ||
       aStatus == NS_NET_STATUS_READING) {
     // The transport status and progress generated by ODA will be coalesced
@@ -1703,80 +1831,86 @@ HttpChannelParent::OnStatus(nsIRequest *
 
 //-----------------------------------------------------------------------------
 // HttpChannelParent::nsIParentChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::SetParentListener(HttpChannelParentListener* aListener)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::SetParentListener [this=%p aListener=%p]\n",
        this, aListener));
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(!mParentListener, "SetParentListener should only be called for "
                                "new HttpChannelParents after a redirect, when "
                                "mParentListener is null.");
   mParentListener = aListener;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::NotifyTrackingProtectionDisabled()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::NotifyTrackingProtectionDisabled [this=%p]\n", this));
   if (!mIPCClosed) {
     MOZ_ASSERT(mBgParent);
     Unused << mBgParent->OnNotifyTrackingProtectionDisabled();
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::SetClassifierMatchedInfo(const nsACString& aList,
                                             const nsACString& aProvider,
                                             const nsACString& aPrefix)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::SetClassifierMatchedInfo [this=%p]\n", this));
   if (!mIPCClosed) {
     MOZ_ASSERT(mBgParent);
     Unused << mBgParent->OnSetClassifierMatchedInfo(aList, aProvider, aPrefix);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::NotifyTrackingResource()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::NotifyTrackingResource [this=%p]\n", this));
   if (!mIPCClosed) {
     MOZ_ASSERT(mBgParent);
     Unused << mBgParent->OnNotifyTrackingResource();
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::Delete()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (!mIPCClosed)
     Unused << DoSendDeleteSelf();
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelParent::nsIParentRedirectingChannel
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::StartRedirect(uint32_t registrarId,
                                  nsIChannel* newChannel,
                                  uint32_t redirectFlags,
                                  nsIAsyncVerifyRedirectCallback* callback)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsresult rv;
 
   LOG(("HttpChannelParent::StartRedirect [this=%p, registrarId=%" PRIu32 " "
        "newChannel=%p callback=%p]\n", this, registrarId, newChannel,
        callback));
 
   if (mIPCClosed)
     return NS_BINDING_ABORTED;
@@ -1793,26 +1927,24 @@ HttpChannelParent::StartRedirect(uint32_
   SerializeURI(newOriginalURI, uriParams);
 
   nsCString secInfoSerialization;
   UpdateAndSerializeSecurityInfo(secInfoSerialization);
 
   // If the channel is a HTTP channel, we also want to inform the child
   // about the parent's channelId attribute, so that both parent and child
   // share the same ID. Useful for monitoring channel activity in devtools.
-  uint64_t channelId;
-  nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
-  if (httpChannel) {
-    rv = httpChannel->GetChannelId(&channelId);
-    NS_ENSURE_SUCCESS(rv, NS_BINDING_ABORTED);
-  }
+  uint64_t channelId = 0;
+  rv = mChannel->GetChannelId(&channelId);
+  NS_ENSURE_SUCCESS(rv, NS_BINDING_ABORTED);
 
   nsHttpResponseHead *responseHead = mChannel->GetResponseHead();
   bool result = false;
   if (!mIPCClosed) {
+    printf_stderr("### ### [%p] HttpChannelParent::%s - calling SendRedirect1Begin()\n", this, __func__);
     result = SendRedirect1Begin(registrarId, uriParams, redirectFlags,
                                 responseHead ? *responseHead
                                              : nsHttpResponseHead(),
                                 secInfoSerialization,
                                 channelId,
                                 mChannel->GetPeerAddr());
   }
   if (!result) {
@@ -1831,16 +1963,17 @@ HttpChannelParent::StartRedirect(uint32_
   mRedirectChannel = newChannel;
   mRedirectCallback = callback;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::CompleteRedirect(bool succeeded)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::CompleteRedirect [this=%p succeeded=%d]\n",
        this, succeeded));
 
   if (succeeded && !mIPCClosed) {
     // TODO: check return value: assume child dead if failed
     Unused << SendRedirect3Complete();
   }
 
@@ -1849,16 +1982,17 @@ HttpChannelParent::CompleteRedirect(bool
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelParent::ADivertableParentChannel
 //-----------------------------------------------------------------------------
 nsresult
 HttpChannelParent::SuspendForDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::SuspendForDiversion [this=%p]\n", this));
   MOZ_ASSERT(mChannel);
   MOZ_ASSERT(mParentListener);
 
   // If we're in the process of opening a synthesized response, we must wait
   // to perform the diversion.  Some of our diversion listeners clear callbacks
   // which breaks the synthesis process.
   if (mWillSynthesizeResponse) {
@@ -1868,33 +2002,35 @@ HttpChannelParent::SuspendForDiversion()
 
   if (NS_WARN_IF(mDivertingFromChild)) {
     MOZ_ASSERT(!mDivertingFromChild, "Already suspended for diversion!");
     return NS_ERROR_UNEXPECTED;
   }
 
   // MessageDiversionStarted call will suspend mEventQ as many times as the
   // channel has been suspended, so that channel and this queue are in sync.
-  mChannel->MessageDiversionStarted(this);
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+  divertChannel->MessageDiversionStarted(this);
 
   nsresult rv = NS_OK;
 
   // Try suspending the channel. Allow it to fail, since OnStopRequest may have
   // been called and thus the channel may not be pending.  If we've already
   // automatically suspended after synthesizing the response, then we don't
   // need to suspend again here.
   if (!mSuspendAfterSynthesizeResponse) {
     // We need to suspend only nsHttpChannel (i.e. we should not suspend
     // mEventQ). Therefore we call mChannel->SuspendInternal() and not
     // mChannel->Suspend().
     // We are suspending only nsHttpChannel here because we want to stop
     // OnDataAvailable until diversion is over. At the same time we should
     // send the diverted OnDataAvailable-s to the listeners and not queue them
     // in mEventQ.
-    rv = mChannel->SuspendInternal();
+    rv = divertChannel->SuspendInternal();
     MOZ_ASSERT(NS_SUCCEEDED(rv) || rv == NS_ERROR_NOT_AVAILABLE);
     mSuspendedForDiversion = NS_SUCCEEDED(rv);
   } else {
     // Take ownership of the automatic suspend that occurred after synthesizing
     // the response.
     mSuspendedForDiversion = true;
 
     // If mSuspendAfterSynthesizeResponse is true channel has been already
@@ -1912,63 +2048,69 @@ HttpChannelParent::SuspendForDiversion()
   mDivertingFromChild = true;
 
   return NS_OK;
 }
 
 nsresult
 HttpChannelParent::SuspendMessageDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::SuspendMessageDiversion [this=%p]", this));
   // This only needs to suspend message queue.
   mEventQ->Suspend();
   return NS_OK;
 }
 
 nsresult
 HttpChannelParent::ResumeMessageDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::SuspendMessageDiversion [this=%p]", this));
   // This only needs to resumes message queue.
   mEventQ->Resume();
   return NS_OK;
 }
 
 /* private, supporting function for ADivertableParentChannel */
 nsresult
 HttpChannelParent::ResumeForDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::ResumeForDiversion [this=%p]\n", this));
   MOZ_ASSERT(mChannel);
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot ResumeForDiversion if not diverting!");
     return NS_ERROR_UNEXPECTED;
   }
 
-  mChannel->MessageDiversionStop();
+  nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+    do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+  divertChannel->MessageDiversionStop();
 
   if (mSuspendedForDiversion) {
     // The nsHttpChannel will deliver remaining OnData/OnStop for the transfer.
-    nsresult rv = mChannel->ResumeInternal();
+    nsresult rv = divertChannel->ResumeInternal();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
     }
     mSuspendedForDiversion = false;
   }
 
   if (NS_WARN_IF(mIPCClosed || !DoSendDeleteSelf())) {
     return NS_ERROR_UNEXPECTED;
   }
   return NS_OK;
 }
 
 void
 HttpChannelParent::DivertTo(nsIStreamListener *aListener)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::DivertTo [this=%p aListener=%p]\n",
        this, aListener));
   MOZ_ASSERT(mParentListener);
 
   // If we're in the process of opening a synthesized response, we must wait
   // to perform the diversion.  Some of our diversion listeners clear callbacks
   // which breaks the synthesis process.
   if (mWillSynthesizeResponse) {
@@ -1993,16 +2135,17 @@ HttpChannelParent::DivertTo(nsIStreamLis
     NewRunnableMethod("net::HttpChannelParent::StartDiversion",
                       this,
                       &HttpChannelParent::StartDiversion));
 }
 
 void
 HttpChannelParent::StartDiversion()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::StartDiversion [this=%p]\n", this));
   if (NS_WARN_IF(!mDivertingFromChild)) {
     MOZ_ASSERT(mDivertingFromChild,
                "Cannot StartDiversion if diverting is not set!");
     return;
   }
 
   // Fake pending status in case OnStopRequest has already been called.
@@ -2025,17 +2168,18 @@ HttpChannelParent::StartDiversion()
   mDivertedOnStartRequest = true;
 
   // After OnStartRequest has been called, setup content decoders if needed.
   //
   // Create a content conversion chain based on mDivertListener and update
   // mDivertListener.
   nsCOMPtr<nsIStreamListener> converterListener;
   Unused << mChannel->DoApplyContentConversions(mDivertListener,
-                                                getter_AddRefs(converterListener));
+                                                getter_AddRefs(converterListener),
+                                                nullptr);
   if (converterListener) {
     mDivertListener = converterListener.forget();
   }
 
   // Now mParentListener can be diverted to mDivertListener.
   DebugOnly<nsresult> rvdbg = mParentListener->DivertTo(mDivertListener);
   MOZ_ASSERT(NS_SUCCEEDED(rvdbg));
   mDivertListener = nullptr;
@@ -2070,28 +2214,30 @@ public:
 private:
   RefPtr<HttpChannelParent> mChannelParent;
   nsresult mErrorCode;
 };
 
 void
 HttpChannelParent::FailDiversion(nsresult aErrorCode)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   MOZ_RELEASE_ASSERT(NS_FAILED(aErrorCode));
   MOZ_RELEASE_ASSERT(mDivertingFromChild);
   MOZ_RELEASE_ASSERT(mParentListener);
   MOZ_RELEASE_ASSERT(mChannel);
 
   NS_DispatchToCurrentThread(
     new HTTPFailDiversionEvent(this, aErrorCode));
 }
 
 void
 HttpChannelParent::NotifyDiversionFailed(nsresult aErrorCode)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::NotifyDiversionFailed [this=%p aErrorCode=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aErrorCode)));
   MOZ_RELEASE_ASSERT(NS_FAILED(aErrorCode));
   MOZ_RELEASE_ASSERT(mDivertingFromChild);
   MOZ_RELEASE_ASSERT(mParentListener);
   MOZ_RELEASE_ASSERT(mChannel);
 
   mChannel->Cancel(aErrorCode);
@@ -2099,17 +2245,19 @@ HttpChannelParent::NotifyDiversionFailed
   mChannel->ForcePending(false);
 
   bool isPending = false;
   nsresult rv = mChannel->IsPending(&isPending);
   MOZ_RELEASE_ASSERT(NS_SUCCEEDED(rv));
 
   // Resume only if we suspended earlier.
   if (mSuspendedForDiversion) {
-    mChannel->ResumeInternal();
+    nsCOMPtr<nsIChannelWithDivertableParentListener> divertChannel =
+      do_QueryInterface(static_cast<nsIChannel*>(mChannel));
+    divertChannel->ResumeInternal();
   }
   // Channel has already sent OnStartRequest to the child, so ensure that we
   // call it here if it hasn't already been called.
   if (!mDivertedOnStartRequest) {
     mChannel->ForcePending(true);
     mParentListener->OnStartRequest(mChannel, nullptr);
     mChannel->ForcePending(false);
   }
@@ -2128,74 +2276,80 @@ HttpChannelParent::NotifyDiversionFailed
   // Thus we need to keep mChannel until DoSendDeleteSelf is done.
   mParentListener = nullptr;
   mChannel = nullptr;
 }
 
 nsresult
 HttpChannelParent::OpenAlternativeOutputStream(const nsACString & type, nsIOutputStream * *_retval)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // We need to make sure the child does not call SendDocumentChannelCleanup()
   // before opening the altOutputStream, because that clears mCacheEntry.
   if (!mCacheEntry) {
     return NS_ERROR_NOT_AVAILABLE;
   }
   return mCacheEntry->OpenAlternativeOutputStream(type, _retval);
 }
 
 NS_IMETHODIMP
 HttpChannelParent::GetAuthPrompt(uint32_t aPromptReason, const nsIID& iid,
                                  void** aResult)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsCOMPtr<nsIAuthPrompt2> prompt =
     new NeckoParent::NestedFrameAuthPrompt(Manager(), mNestedFrameId);
   prompt.forget(aResult);
   return NS_OK;
 }
 
 void
 HttpChannelParent::UpdateAndSerializeSecurityInfo(nsACString& aSerializedSecurityInfoOut)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   nsCOMPtr<nsISupports> secInfoSupp;
   mChannel->GetSecurityInfo(getter_AddRefs(secInfoSupp));
   if (secInfoSupp) {
     mAssociatedContentSecurity = do_QueryInterface(secInfoSupp);
     nsCOMPtr<nsISerializable> secInfoSer = do_QueryInterface(secInfoSupp);
     if (secInfoSer) {
       NS_SerializeToString(secInfoSer, aSerializedSecurityInfoOut);
     }
   }
 }
 
 bool
 HttpChannelParent::DoSendDeleteSelf()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   bool rv = SendDeleteSelf();
   mIPCClosed = true;
 
   CleanupBackgroundChannel();
 
   return rv;
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvDeletingChannel()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // We need to ensure that the parent channel will not be sending any more IPC
   // messages after this, as the child is going away. DoSendDeleteSelf will
   // set mIPCClosed = true;
   if (!DoSendDeleteSelf()) {
     return IPC_FAIL_NO_REASON(this);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvFinishInterceptedRedirect()
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   // We make sure not to send any more messages until the IPC channel is torn
   // down by the child.
   mIPCClosed = true;
   if (!SendFinishInterceptedRedirect()) {
     return IPC_FAIL_NO_REASON(this);
   }
   return IPC_OK();
 }
@@ -2203,58 +2357,63 @@ HttpChannelParent::RecvFinishIntercepted
 //-----------------------------------------------------------------------------
 // HttpChannelSecurityWarningReporter
 //-----------------------------------------------------------------------------
 
 nsresult
 HttpChannelParent::ReportSecurityMessage(const nsAString& aMessageTag,
                                          const nsAString& aMessageCategory)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mIPCClosed ||
       NS_WARN_IF(!SendReportSecurityMessage(nsString(aMessageTag),
                                             nsString(aMessageCategory)))) {
     return NS_ERROR_UNEXPECTED;
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpChannelParent::IssueWarning(uint32_t aWarning, bool aAsError)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   Unused << SendIssueDeprecationWarning(aWarning, aAsError);
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // nsIAsyncVerifyRedirectReadyCallback
 //-----------------------------------------------------------------------------
 
 NS_IMETHODIMP
 HttpChannelParent::ReadyToVerify(nsresult aResult)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   LOG(("HttpChannelParent::RecvRedirect2Verify [this=%p result=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aResult)));
   MOZ_ASSERT(NS_IsMainThread());
 
   ContinueRedirect2Verify(aResult);
 
   return NS_OK;
 }
 
 void
 HttpChannelParent::DoSendSetPriority(int16_t aValue)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (!mIPCClosed) {
     Unused << SendSetPriority(aValue);
   }
 }
 
 nsresult
 HttpChannelParent::LogBlockedCORSRequest(const nsAString& aMessage)
 {
+  printf_stderr("### ### [%p] HttpChannelParent::%s\n", this, __func__);
   if (mIPCClosed ||
       NS_WARN_IF(!SendLogBlockedCORSRequest(nsString(aMessage)))) {
     return NS_ERROR_UNEXPECTED;
   }
   return NS_OK;
 }
 
 } // namespace net
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -255,17 +255,17 @@ private:
   // DocumentChannelCleanup.
   void CleanupBackgroundChannel();
 
   friend class HttpBackgroundChannelParent;
   friend class DivertDataAvailableEvent;
   friend class DivertStopRequestEvent;
   friend class DivertCompleteEvent;
 
-  RefPtr<nsHttpChannel>       mChannel;
+  RefPtr<HttpBaseChannel>       mChannel;
   nsCOMPtr<nsICacheEntry>       mCacheEntry;
   nsCOMPtr<nsIAssociatedContentSecurity>  mAssociatedContentSecurity;
   bool mIPCClosed;                // PHttpChannel actor has been Closed()
 
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mRedirectCallback;
 
   nsAutoPtr<class nsHttpChannel::OfflineCacheEntryAsForeignMarker> mOfflineForeignMarker;
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -156,16 +156,17 @@ HttpChannelParentListener::GetInterface(
 
 NS_IMETHODIMP
 HttpChannelParentListener::AsyncOnChannelRedirect(
                                     nsIChannel *oldChannel,
                                     nsIChannel *newChannel,
                                     uint32_t redirectFlags,
                                     nsIAsyncVerifyRedirectCallback* callback)
 {
+  printf_stderr("### ### [%p] HttpChannelParentListener::%s\n", this, __func__);
   LOG(("HttpChannelParentListener::AsyncOnChannelRedirect [this=%p, old=%p, new=%p, flags=%u]",
        this, oldChannel, newChannel, redirectFlags));
 
   nsresult rv;
 
   nsCOMPtr<nsIParentRedirectingChannel> activeRedirectingChannel =
       do_QueryInterface(mNextListener);
   if (!activeRedirectingChannel) {
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -13,25 +13,49 @@ namespace net {
 
 NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
                             HttpBaseChannel,
                             nsIInterceptedChannel,
                             nsIAsyncVerifyRedirectCallback,
                             nsIRequestObserver,
                             nsIStreamListener)
 
+InterceptedHttpChannel::InterceptedHttpChannel()
+  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+}
+
 InterceptedHttpChannel::~InterceptedHttpChannel()
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
 }
 
-InterceptedHttpChannel::InterceptedHttpChannel()
-  : HttpAsyncAborter<InterceptedHttpChannel>(this)
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForInterception()
 {
-  printf_stderr("### ### [%p] %s\n", this, __func__);
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+  return ref.forget();
+}
+
+// static
+already_AddRefed<InterceptedHttpChannel>
+InterceptedHttpChannel::CreateForSynthesis(const nsHttpResponseHead* aHead,
+                                           nsIInputStream* aBody)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aHead);
+  MOZ_DIAGNOSTIC_ASSERT(aBody);
+
+  RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
+
+  ref->mBodyReader = aBody;
+  ref->mResponseHead = new nsHttpResponseHead(*aHead);
+
+  return ref.forget();
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::Cancel(nsresult aStatus)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return CancelInterception(aStatus);
 }
@@ -78,21 +102,96 @@ InterceptedHttpChannel::AsyncOpen(nsIStr
 
   if (NS_WARN_IF(!controller)) {
     ReleaseListeners();
     return NS_ERROR_FAILURE;
   }
 
   mResponseCouldBeSynthesized = true;
 
-  mLoadGroup->AddRequest(this, nullptr);
+  if (mLoadGroup) {
+    mLoadGroup->AddRequest(this, nullptr);
+  }
 
   // If we already have a synthesized body then this is a "fake redirect"
   // from a channel synthesized with an opaque response.
   if (mBodyReader) {
+    if (nsHttpChannel::WillRedirect(mResponseHead) &&
+        !mLoadInfo->GetDontFollowRedirects()) {
+      printf_stderr("### ### will redirect\n");
+      nsCOMPtr<nsIIOService> ioService;
+      nsresult rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsAutoCString location;
+      rv = mResponseHead->GetHeader(nsHttp::Location, location);
+      NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+      // make sure non-ASCII characters in the location header are escaped.
+      nsAutoCString locationBuf;
+      if (NS_EscapeURL(location.get(), -1, esc_OnlyNonASCII, locationBuf)) {
+        location = locationBuf;
+      }
+
+      if (NS_WARN_IF(mRedirectionLimit == 0)) {
+        return NS_ERROR_REDIRECT_LOOP;
+      }
+
+      nsCOMPtr<nsIURI> redirectURI;
+      rv = ioService->NewURI(nsDependentCString(location.get()),
+                             nullptr,
+                             mURI,
+                             getter_AddRefs(redirectURI));
+      NS_ENSURE_SUCCESS(rv, NS_ERROR_CORRUPTED_CONTENT);
+
+      uint32_t redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
+      if (nsHttp::IsPermanentRedirect(mResponseHead->Status())) {
+        redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
+      }
+
+      bool rewriteToGET = ShouldRewriteRedirectToGET(mResponseHead->Status(),
+                                                     mRequestHead.ParsedMethod());
+
+      nsCOMPtr<nsIChannel> newChannel;
+      nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+        CloneLoadInfoForRedirect(redirectURI, redirectFlags);
+      rv = NS_NewChannelInternal(getter_AddRefs(newChannel),
+                                 redirectURI,
+                                 redirectLoadInfo,
+                                 nullptr, // aLoadGroup
+                                 nullptr, // aCallbacks
+                                 mLoadFlags,
+                                 ioService);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = SetupReplacementChannel(redirectURI, newChannel, !rewriteToGET,
+                                   redirectFlags);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      if (mRedirectMode != nsIHttpChannelInternal::REDIRECT_MODE_MANUAL) {
+        nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
+        rv = newChannel->GetLoadFlags(&loadFlags);
+        NS_ENSURE_SUCCESS(rv, rv);
+        loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
+        rv = newChannel->SetLoadFlags(loadFlags);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+
+      mRedirectChannel = newChannel.forget();
+
+      rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, redirectFlags);
+
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        OnRedirectVerifyCallback(rv);
+      }
+
+      printf_stderr("### ### will redirect complete - %s\n", (NS_SUCCEEDED(rv) ? "succeeded" : "failed"));
+      return rv;
+    }
+
     nsresult rv = nsInputStreamPump::Create(getter_AddRefs(mPump),
                                             mBodyReader,
                                             int64_t(-1), int64_t(-1), 0, 0, true);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = mPump->AsyncRead(this, mListenerContext);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -185,17 +284,19 @@ InterceptedHttpChannel::ResumeAt(uint64_
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 void
 InterceptedHttpChannel::DoNotifyListenerCleanup()
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
-  mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
 }
 
 
 NS_IMETHODIMP
 InterceptedHttpChannel::ResetInterception(void)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
 
@@ -384,17 +485,18 @@ InterceptedHttpChannel::FinishSynthesize
     responseURI = mURI;
   }
 
   bool equal = false;
   Unused << mURI->Equals(responseURI, &equal);
   if (!equal) {
     nsresult rv = NS_OK;
 
-    RefPtr<InterceptedHttpChannel> newChannel = new InterceptedHttpChannel();
+    RefPtr<InterceptedHttpChannel> newChannel =
+      CreateForSynthesis(mResponseHead, mBodyReader);
 
     rv = newChannel->Init(responseURI, mCaps,
                           static_cast<nsProxyInfo*>(mProxyInfo.get()),
                           mProxyResolveFlags, mProxyURI, mChannelId);
 
     uint32_t flags = nsIChannelEventSink::REDIRECT_INTERNAL;
 
     nsCOMPtr<nsILoadInfo> redirectLoadInfo =
@@ -409,18 +511,18 @@ InterceptedHttpChannel::FinishSynthesize
       nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
       rv = newChannel->GetLoadFlags(&loadFlags);
       NS_ENSURE_SUCCESS(rv, rv);
       loadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
       rv = newChannel->SetLoadFlags(loadFlags);
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
-    newChannel->mBodyReader = mBodyReader.forget();
-    newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
+    //newChannel->mBodyReader = mBodyReader.forget();
+    //newChannel->mResponseHead = new nsHttpResponseHead(*mResponseHead);
 
     mRedirectChannel = newChannel;
 
     rv = gHttpHandler->AsyncOnChannelRedirect(this, mRedirectChannel, flags);
 
     if (NS_FAILED(rv)) {
       OnRedirectVerifyCallback(rv);
     }
@@ -508,23 +610,37 @@ InterceptedHttpChannel::GetInternalConte
 NS_IMETHODIMP
 InterceptedHttpChannel::GetConsoleReportCollector(nsIConsoleReportCollector** aConsoleReportCollector)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerStart(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 InterceptedHttpChannel::SetLaunchServiceWorkerStart(mozilla::TimeStamp aTimeStamp)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+InterceptedHttpChannel::GetLaunchServiceWorkerEnd(mozilla::TimeStamp* aTimeStamp)
+{
+  printf_stderr("### ### [%p] %s\n", this, __func__);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 InterceptedHttpChannel::SetLaunchServiceWorkerEnd(mozilla::TimeStamp aTimeStamp)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::SetDispatchFetchEventStart(mozilla::TimeStamp aTimeStamp)
@@ -624,17 +740,19 @@ InterceptedHttpChannel::OnRedirectVerify
 
   if (NS_FAILED(rv)) {
     // Cancel the channel here, the update to https had been vetoed
     // but from the security reasons we have to discard the whole channel
     // load.
     Cancel(rv);
   }
 
-  mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnStartRequest(nsIRequest* aRequest,
                                        nsISupports* aContext)
 {
@@ -650,17 +768,19 @@ InterceptedHttpChannel::OnStopRequest(ns
                                       nsISupports* aContext,
                                       nsresult aStatus)
 {
   printf_stderr("### ### [%p] %s\n", this, __func__);
   if (mListener) {
     mListener->OnStopRequest(this, mListenerContext, aStatus);
   }
   ReleaseListeners();
-  mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  if (mLoadGroup) {
+    mLoadGroup->RemoveRequest(this, nullptr, mStatus);
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnDataAvailable(nsIRequest* aRequest,
                                         nsISupports* aContext,
                                         nsIInputStream* aInputStream,
                                         uint64_t aOffset,
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -25,20 +25,25 @@ class InterceptedHttpChannel final : pub
   UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIInputStream> mBodyReader;
   nsCOMPtr<nsIOutputStream> mBodyWriter;
   nsCOMPtr<nsISupports> mReleaseHandle;
   nsCOMPtr<nsIProgressEventSink> mProgressSink;
   RefPtr<nsInputStreamPump> mPump;
 
+  InterceptedHttpChannel();
   ~InterceptedHttpChannel();
 
 public:
-  InterceptedHttpChannel();
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForInterception();
+
+  static already_AddRefed<InterceptedHttpChannel>
+  CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody);
 
   NS_IMETHOD
   Cancel(nsresult aStatus) override;
 
   NS_IMETHOD
   Suspend(void) override;
 
   NS_IMETHOD
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -550,17 +550,17 @@ nsHttpChannel::Connect()
     if (mInterceptCache == MAYBE_INTERCEPT) {
       mInterceptCache = INTERCEPTED;
 
       nsCOMPtr<nsINetworkInterceptController> controller;
       GetCallback(controller);
 
       printf_stderr("### ### nsHttpChannel mListener is %p when creating InterceptedHttpChannel\n", mListener.get());
       RefPtr<InterceptedHttpChannel> intercepted =
-        new InterceptedHttpChannel();
+        InterceptedHttpChannel::CreateForInterception();
 
       rv = intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
                              mProxyResolveFlags, mProxyURI, mChannelId);
 
       nsCOMPtr<nsILoadInfo> redirectLoadInfo =
         CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
       intercepted->SetLoadInfo(redirectLoadInfo);
 
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -200,27 +200,16 @@ public: /* internal necko use only */
 
     using InitLocalBlockListCallback = std::function<void(bool)>;
 
     void InternalSetUploadStream(nsIInputStream *uploadStream)
       { mUploadStream = uploadStream; }
     void SetUploadStreamHasHeaders(bool hasHeaders)
       { mUploadStreamHasHeaders = hasHeaders; }
 
-    MOZ_MUST_USE nsresult
-    SetReferrerWithPolicyInternal(nsIURI *referrer, uint32_t referrerPolicy) {
-        nsAutoCString spec;
-        nsresult rv = referrer->GetAsciiSpec(spec);
-        if (NS_FAILED(rv)) return rv;
-        mReferrer = referrer;
-        mReferrerPolicy = referrerPolicy;
-        rv = mRequestHead.SetHeader(nsHttp::Referer, spec);
-        return rv;
-    }
-
     MOZ_MUST_USE nsresult SetTopWindowURI(nsIURI* aTopWindowURI) {
         mTopWindowURI = aTopWindowURI;
         return NS_OK;
     }
 
     uint32_t GetRequestTime() const
     {
         return mRequestTime;
