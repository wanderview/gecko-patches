# HG changeset patch
# Parent c720892f4f366ed67ab7a64e7344c19d05b8c348
# User Ben Kelly <ben@wanderview.com>
Fix compile issues in patch from bug 1039846.

diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -13,16 +13,17 @@
 #include "nsIUnicodeDecoder.h"
 #include "nsIUnicodeEncoder.h"
 
 #include "nsDOMString.h"
 #include "nsNetUtil.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 
+#include "mozilla/DebugOnly.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "mozilla/dom/FetchDriver.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
@@ -171,17 +172,17 @@ public:
     AssertIsOnMainThread();
     // AddFeature() call failed, don't bother running.
     if (!mResolver) {
       return NS_OK;
     }
 
     nsCOMPtr<nsIPrincipal> principal = mResolver->GetWorkerPrivate()->GetPrincipal();
     nsRefPtr<FetchDriver> fetch = new FetchDriver(mRequest, principal);
-    nsresult rv = fetch->Fetch(mResolver);
+    DebugOnly<nsresult> rv = fetch->Fetch(mResolver);
     // Right now we only support async fetch, which should never directly fail.
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     return NS_OK;
   }
 };
 
 already_AddRefed<Promise>
 FetchRequest(nsIGlobalObject* aGlobal, const RequestOrUSVString& aInput,
@@ -259,17 +260,17 @@ MainThreadFetchResolver::OnResponseAvail
   nsCOMPtr<nsIGlobalObject> go = mPromise->GetParentObject();
   mResponse = new Response(go, aResponse);
   mPromise->MaybeResolve(mResponse);
 }
 
 void
 MainThreadFetchResolver::OnResponseEnd()
 {
-  NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver)
+  NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
   AssertIsOnMainThread();
   MOZ_ASSERT(mResponse);
 }
 
 MainThreadFetchResolver::~MainThreadFetchResolver()
 {
   NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
 }
@@ -842,16 +843,21 @@ FetchBody<Derived>::FetchBody()
   if (!NS_IsMainThread()) {
     mWorkerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(mWorkerPrivate);
   } else {
     mWorkerPrivate = nullptr;
   }
 }
 
+template <class Derived>
+FetchBody<Derived>::~FetchBody()
+{
+}
+
 // Returns true if addref succeeded.
 // Always succeeds on main thread.
 // May fail on worker if RegisterFeature() fails. In that case, it will release
 // the object before returning false.
 template <class Derived>
 bool
 FetchBody<Derived>::AddRefObject()
 {
@@ -1152,24 +1158,16 @@ FetchBody<Derived>::ConsumeBody(ConsumeT
     mConsumePromise = nullptr;
     return nullptr;
   }
 
   nsRefPtr<Promise> promise = mConsumePromise;
   return promise.forget();
 }
 
-template
-already_AddRefed<Promise>
-FetchBody<Request>::ConsumeBody(ConsumeType aType, ErrorResult& aRv);
-
-template
-already_AddRefed<Promise>
-FetchBody<Response>::ConsumeBody(ConsumeType aType, ErrorResult& aRv);
-
 template <class Derived>
 void
 FetchBody<Derived>::SetMimeType(ErrorResult& aRv)
 {
   // Extract mime type.
   nsTArray<nsCString> contentTypeValues;
   MOZ_ASSERT(DerivedClass()->GetInternalHeaders());
   DerivedClass()->GetInternalHeaders()->GetAll(NS_LITERAL_CSTRING("Content-Type"), contentTypeValues, aRv);
@@ -1180,17 +1178,12 @@ FetchBody<Derived>::SetMimeType(ErrorRes
   // HTTP ABNF states Content-Type may have only one value.
   // This is from the "parse a header value" of the fetch spec.
   if (contentTypeValues.Length() == 1) {
     mMimeType = contentTypeValues[0];
     ToLowerCase(mMimeType);
   }
 }
 
-template
-void
-FetchBody<Request>::SetMimeType(ErrorResult& aRv);
-
-template
-void
-FetchBody<Response>::SetMimeType(ErrorResult& aRv);
+template class FetchBody<Request>;
+template class FetchBody<Response>;
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -140,19 +140,17 @@ public:
 
   // Set when consuming the body is attempted on a worker.
   // Unset when consumption is done/aborted.
   nsAutoPtr<FetchBodyFeature<Derived>> mFeature;
 
 protected:
   FetchBody();
 
-  virtual ~FetchBody()
-  {
-  }
+  virtual ~FetchBody();
 
   void
   SetBodyUsed()
   {
     mBodyUsed = true;
   }
 
   void
diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -12,16 +12,17 @@
 #include "nsIScriptSecurityManager.h"
 #include "nsIThreadRetargetableRequest.h"
 #include "nsIUploadChannel2.h"
 
 #include "nsContentPolicyUtils.h"
 #include "nsDataHandler.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsNetUtil.h"
+#include "nsStreamUtils.h"
 #include "nsStringStream.h"
 
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/workers/Workers.h"
 
 #include "Fetch.h"
 #include "InternalRequest.h"
 #include "InternalResponse.h"
@@ -264,43 +265,43 @@ nsresult
 FetchDriver::HttpFetch(bool aCORSFlag, bool aPreflightCORSFlag, bool aAuthenticationFlag)
 {
   mResponse = nullptr;
 
   // XXXnsm: The ServiceWorker interception should happen automatically.
   return ContinueHttpFetchAfterServiceWorker();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterServiceWorker()
 {
   if (!mResponse) {
     // FIXME(nsm): Set skip SW flag.
     // FIXME(nsm): Deal with CORS flags cases which will also call
     // ContinueHttpFetchAfterCORSPreflight().
     return ContinueHttpFetchAfterCORSPreflight();
   }
 
   // Otherwise ServiceWorker replied with a response.
   return ContinueHttpFetchAfterNetworkFetch();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterCORSPreflight()
 {
   // mResponse is currently the CORS response.
   // We may have to pass it via argument.
   if (mResponse && mResponse->IsError()) {
     return FailWithNetworkError();
   }
 
   return HttpNetworkFetch();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::HttpNetworkFetch()
 {
   nsRefPtr<InternalRequest> httpRequest = new InternalRequest(*mRequest);
   // FIXME(nsm): Figure out how to tee request's body.
 
   // FIXME(nsm): Http network fetch steps 2-7.
   nsresult rv;
 
@@ -334,17 +335,17 @@ FetchDriver::HttpNetworkFetch()
     mRequest->GetMethod(method);
     rv = httpChan->SetRequestMethod(method);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return chan->AsyncOpen(this, nullptr);
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterNetworkFetch()
 {
   workers::AssertIsOnMainThread();
   MOZ_ASSERT(mResponse);
   MOZ_ASSERT(!mResponse->IsError());
 
   /*switch (mResponse->GetStatus()) {
     default:
diff --git a/dom/fetch/FetchDriver.h b/dom/fetch/FetchDriver.h
--- a/dom/fetch/FetchDriver.h
+++ b/dom/fetch/FetchDriver.h
@@ -5,16 +5,17 @@
 
 #ifndef mozilla_dom_FetchDriver_h
 #define mozilla_dom_FetchDriver_h
 
 #include "nsAutoPtr.h"
 #include "nsIStreamListener.h"
 #include "nsRefPtr.h"
 
+class nsIAsyncOutputStream;
 class nsIPrincipal;
 class nsPIDOMWindow;
 
 namespace mozilla {
 namespace dom {
 
 class BlobSet;
 class InternalRequest;
diff --git a/dom/fetch/moz.build b/dom/fetch/moz.build
--- a/dom/fetch/moz.build
+++ b/dom/fetch/moz.build
@@ -10,17 +10,17 @@ EXPORTS.mozilla.dom += [
     'Headers.h',
     'InternalHeaders.h',
     'InternalRequest.h',
     'InternalResponse.h',
     'Request.h',
     'Response.h',
 ]
 
-UNIFIED_SOURCES += [
+SOURCES += [
     'Fetch.cpp',
     'FetchDriver.cpp',
     'Headers.cpp',
     'InternalHeaders.cpp',
     'InternalRequest.cpp',
     'InternalResponse.cpp',
     'Request.cpp',
     'Response.cpp',
