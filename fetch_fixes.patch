# HG changeset patch
# Parent c6052e88f0d6ee4c1fd97a6c611abb58cb6688fc
# User Ben Kelly <ben@wanderview.com>
Fix compile issues in patch from bug 1039846.


diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -13,16 +13,17 @@
 #include "nsIUnicodeDecoder.h"
 #include "nsIUnicodeEncoder.h"
 
 #include "nsDOMString.h"
 #include "nsNetUtil.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 
+#include "mozilla/DebugOnly.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "mozilla/dom/FetchDriver.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
@@ -171,17 +172,17 @@ public:
     AssertIsOnMainThread();
     // AddFeature() call failed, don't bother running.
     if (!mResolver) {
       return NS_OK;
     }
 
     nsCOMPtr<nsIPrincipal> principal = mResolver->GetWorkerPrivate()->GetPrincipal();
     nsRefPtr<FetchDriver> fetch = new FetchDriver(mRequest, principal);
-    nsresult rv = fetch->Fetch(mResolver);
+    DebugOnly<nsresult> rv = fetch->Fetch(mResolver);
     // Right now we only support async fetch, which should never directly fail.
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     return NS_OK;
   }
 };
 
 already_AddRefed<Promise>
 FetchRequest(nsIGlobalObject* aGlobal, const RequestOrUSVString& aInput,
@@ -259,17 +260,17 @@ MainThreadFetchResolver::OnResponseAvail
   nsCOMPtr<nsIGlobalObject> go = mPromise->GetParentObject();
   mResponse = new Response(go, aResponse);
   mPromise->MaybeResolve(mResponse);
 }
 
 void
 MainThreadFetchResolver::OnResponseEnd()
 {
-  NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver)
+  NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
   AssertIsOnMainThread();
   MOZ_ASSERT(mResponse);
 }
 
 MainThreadFetchResolver::~MainThreadFetchResolver()
 {
   NS_ASSERT_OWNINGTHREAD(MainThreadFetchResolver);
 }
@@ -842,16 +843,21 @@ FetchBody<Derived>::FetchBody()
   if (!NS_IsMainThread()) {
     mWorkerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_ASSERT(mWorkerPrivate);
   } else {
     mWorkerPrivate = nullptr;
   }
 }
 
+template <class Derived>
+FetchBody<Derived>::~FetchBody()
+{
+}
+
 // Returns true if addref succeeded.
 // Always succeeds on main thread.
 // May fail on worker if RegisterFeature() fails. In that case, it will release
 // the object before returning false.
 template <class Derived>
 bool
 FetchBody<Derived>::AddRefObject()
 {
diff --git a/dom/fetch/Fetch.h b/dom/fetch/Fetch.h
--- a/dom/fetch/Fetch.h
+++ b/dom/fetch/Fetch.h
@@ -140,19 +140,17 @@ public:
 
   // Set when consuming the body is attempted on a worker.
   // Unset when consumption is done/aborted.
   nsAutoPtr<FetchBodyFeature<Derived>> mFeature;
 
 protected:
   FetchBody();
 
-  virtual ~FetchBody()
-  {
-  }
+  virtual ~FetchBody();
 
   void
   SetBodyUsed()
   {
     mBodyUsed = true;
   }
 
   void
diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -264,43 +264,43 @@ nsresult
 FetchDriver::HttpFetch(bool aCORSFlag, bool aPreflightCORSFlag, bool aAuthenticationFlag)
 {
   mResponse = nullptr;
 
   // XXXnsm: The ServiceWorker interception should happen automatically.
   return ContinueHttpFetchAfterServiceWorker();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterServiceWorker()
 {
   if (!mResponse) {
     // FIXME(nsm): Set skip SW flag.
     // FIXME(nsm): Deal with CORS flags cases which will also call
     // ContinueHttpFetchAfterCORSPreflight().
     return ContinueHttpFetchAfterCORSPreflight();
   }
 
   // Otherwise ServiceWorker replied with a response.
   return ContinueHttpFetchAfterNetworkFetch();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterCORSPreflight()
 {
   // mResponse is currently the CORS response.
   // We may have to pass it via argument.
   if (mResponse && mResponse->IsError()) {
     return FailWithNetworkError();
   }
 
   return HttpNetworkFetch();
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::HttpNetworkFetch()
 {
   nsRefPtr<InternalRequest> httpRequest = new InternalRequest(*mRequest);
   // FIXME(nsm): Figure out how to tee request's body.
 
   // FIXME(nsm): Http network fetch steps 2-7.
   nsresult rv;
 
@@ -334,17 +334,17 @@ FetchDriver::HttpNetworkFetch()
     mRequest->GetMethod(method);
     rv = httpChan->SetRequestMethod(method);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return chan->AsyncOpen(this, nullptr);
 }
 
-NS_IMETHODIMP
+nsresult
 FetchDriver::ContinueHttpFetchAfterNetworkFetch()
 {
   workers::AssertIsOnMainThread();
   MOZ_ASSERT(mResponse);
   MOZ_ASSERT(!mResponse->IsError());
 
   /*switch (mResponse->GetStatus()) {
     default:
