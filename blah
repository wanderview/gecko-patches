# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4634b326682e3df5ca6b8ebe8024f1383b2f21f5

diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -9,16 +9,17 @@
 #include "mozilla/dom/cache/Connection.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/quota/PersistenceType.h"
 #include "mozilla/net/nsFileProtocolHandler.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
 #include "mozStorageCID.h"
+#include "mozStorageHelper.h"
 #include "nsIFile.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
@@ -172,21 +173,52 @@ DBAction::OpenConnection(const QuotaInfo
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (schemaVersion > 0 && schemaVersion < db::kMaxWipeSchemaVersion) {
     conn = nullptr;
     rv = WipeDatabase(dbFile, aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = conn->GetSchemaVersion(&schemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   rv = db::InitializeConnection(conn);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  if (schemaVersion == 0) {
+    rv = conn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "PRAGMA auto_vacuum = INCREMENTAL; "
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = conn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("VACUUM;"));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = conn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA auto_vacuum;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t mode;
+  rv = state->GetInt32(0, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  printf_stderr("### ### auto_vacuum mode is %d\n", mode);
+
+  if (NS_WARN_IF(mode != 2)) { return NS_ERROR_UNEXPECTED; }
+
   conn.forget(aConnOut);
 
   return rv;
 }
 
 nsresult
 DBAction::WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir)
 {
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -225,36 +225,54 @@ static nsresult CreateAndBindKeyStatemen
 } // anonymous namespace
 
 nsresult
 CreateSchema(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
-  nsAutoCString pragmas(
-    // Enable auto-vaccum but in incremental mode in order to avoid doing a lot
-    // of work at the end of each transaction.
-    // NOTE: This must be done here instead of InitializeConnection() because it
-    //       only works when the database is empty.
-    "PRAGMA auto_vacuum = INCREMENTAL; "
-  );
-
-  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
   int32_t schemaVersion;
-  rv = aConn->GetSchemaVersion(&schemaVersion);
+  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (schemaVersion == kLatestSchemaVersion) {
     // We already have the correct schema, so just get started.
     return rv;
   }
 
+  printf_stderr("### ### setting auto_vacuum mode to 2\n");
+
+  nsAutoCString pragmas(
+    // Enable auto-vaccum but in incremental mode in order to avoid doing a lot
+    // of work at the end of each transaction.
+    // NOTE: This must be done here instead of InitializeConnection() because it
+    //       only works when the database is empty.
+    "PRAGMA auto_vacuum = 2; "
+  );
+
+  rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA auto_vacuum;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t mode;
+  rv = state->GetInt32(0, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  printf_stderr("### ### auto_vacuum mode is %d\n", mode);
+
   if (!schemaVersion) {
     // The caches table is the single source of truth about what Cache
     // objects exist for the origin.  The contents of the Cache are stored
     // in the entries table that references back to caches.
     //
     // The caches table is also referenced from storage.  Rows in storage
     // represent named Cache objects.  There are cases, however, where
     // a Cache can still exist, but not be in a named Storage.  For example,
@@ -387,16 +405,22 @@ nsresult
 InitializeConnection(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // This function needs to perform per-connection initialization tasks that
   // need to happen regardless of the schema.
 
+  int32_t schemaVersion = 0;
+  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  printf_stderr("### ### setting pragmas for version %d\n", schemaVersion);
+
   nsPrintfCString pragmas(
     // Use a smaller page size to improve perf/footprint; default is too large
     "PRAGMA page_size = %u; "
     // WAL journal can grow to given number of *pages*
     "PRAGMA wal_autocheckpoint = %u; "
     // Always truncate the journal back to given number of *bytes*
     "PRAGMA journal_size_limit = %u; "
     // WAL must be enabled at the end to allow page size to be changed, etc.
@@ -407,27 +431,45 @@ InitializeConnection(mozIStorageConnecti
     kWalAutoCheckpointSize
   );
 
   // Note, the default encoding of UTF-8 is preferred.  mozStorage does all
   // the work necessary to convert UTF-16 nsString values for us.  We don't
   // need ordering and the binary equality operations are correct.  So, do
   // NOT set PRAGMA encoding to UTF-16.
 
-  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  rv = aConn->ExecuteSimpleSQL(pragmas);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Limit fragmentation by growing the database by many pages at once.
   rv = aConn->SetGrowthIncrement(kGrowthSize, EmptyCString());
   if (rv == NS_ERROR_FILE_TOO_BIG) {
     NS_WARNING("Not enough disk space to set sqlite growth increment.");
     rv = NS_OK;
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  /*
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA auto_vacuum;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t mode;
+  rv = state->GetInt32(0, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  printf_stderr("### ### auto_vacuum mode is %d\n", mode);
+  */
+
   return NS_OK;
 }
 
 nsresult
 CreateCacheId(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
