# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6661c077325c35af028f1cdaa660f673cbea39be

diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -5,73 +5,38 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerService.h"
 
 #include "ClientManagerParent.h"
 #include "ClientNavigateOpParent.h"
 #include "ClientOpenWindowOpParent.h"
 #include "ClientOpenWindowUtils.h"
+#include "ClientPrincipalUtils.h"
 #include "ClientSourceParent.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/SystemGroup.h"
 #include "nsIAsyncShutdown.h"
 #include "nsIXULRuntime.h"
 #include "nsProxyRelease.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
-using mozilla::ipc::ContentPrincipalInfo;
 using mozilla::ipc::PrincipalInfo;
 
 namespace {
 
 ClientManagerService* sClientManagerServiceInstance = nullptr;
 bool sClientManagerServiceShutdownRegistered = false;
 
-bool
-MatchPrincipalInfo(const PrincipalInfo& aLeft, const PrincipalInfo& aRight)
-{
-  if (aLeft.type() != aRight.type()) {
-    return false;
-  }
-
-  switch (aLeft.type()) {
-    case PrincipalInfo::TContentPrincipalInfo:
-    {
-      const ContentPrincipalInfo& leftContent = aLeft.get_ContentPrincipalInfo();
-      const ContentPrincipalInfo& rightContent = aRight.get_ContentPrincipalInfo();
-      return leftContent.attrs() == rightContent.attrs() &&
-             leftContent.originNoSuffix() == rightContent.originNoSuffix();
-    }
-    case PrincipalInfo::TSystemPrincipalInfo:
-    {
-      // system principal always matches
-      return true;
-    }
-    case PrincipalInfo::TNullPrincipalInfo:
-    {
-      // null principal never matches
-      return false;
-    }
-    default:
-    {
-      break;
-    }
-  }
-
-  // Clients (windows/workers) should never have an expanded principal type.
-  MOZ_CRASH("unexpected principal type!");
-}
-
 class ClientShutdownBlocker final : public nsIAsyncShutdownBlocker
 {
   RefPtr<GenericPromise::Private> mPromise;
 
   ~ClientShutdownBlocker() = default;
 
 public:
   explicit ClientShutdownBlocker(GenericPromise::Private* aPromise)
@@ -273,17 +238,17 @@ ClientManagerService::FindSource(const n
 
   auto entry = mSourceTable.Lookup(aID);
   if (!entry) {
     return nullptr;
   }
 
   ClientSourceParent* source = entry.Data();
   if (source->IsFrozen() ||
-      !MatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
+      !ClientMatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
     return nullptr;
   }
 
   return source;
 }
 
 void
 ClientManagerService::AddManager(ClientManagerParent* aManager)
@@ -450,17 +415,17 @@ ClientManagerService::MatchAll(const Cli
       continue;
     }
 
     if (aArgs.type() != ClientType::All &&
         source->Info().Type() != aArgs.type()) {
       continue;
     }
 
-    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
+    if (!ClientMatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
       continue;
     }
 
     if (!aArgs.includeUncontrolled()) {
       const Maybe<ServiceWorkerDescriptor>& controller =
         source->GetController();
       if (controller.isNothing()) {
         continue;
@@ -496,17 +461,17 @@ ClientManagerService::Claim(const Client
   for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
     ClientSourceParent* source = iter.UserData();
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
       continue;
     }
 
-    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
+    if (!ClientMatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
       continue;
     }
 
     const Maybe<ServiceWorkerDescriptor>& controller = source->GetController();
     if (controller.isSome() &&
         controller.ref().Scope() == serviceWorker.scope() &&
         controller.ref().Id() == serviceWorker.id()) {
       continue;
diff --git a/dom/clients/manager/ClientPrincipalUtils.cpp b/dom/clients/manager/ClientPrincipalUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientPrincipalUtils.cpp
@@ -0,0 +1,51 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientPrincipalUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::ContentPrincipalInfo;
+using mozilla::ipc::PrincipalInfo;
+
+bool
+ClientMatchPrincipalInfo(const PrincipalInfo& aLeft, const PrincipalInfo& aRight)
+{
+  if (aLeft.type() != aRight.type()) {
+    return false;
+  }
+
+  switch (aLeft.type()) {
+    case PrincipalInfo::TContentPrincipalInfo:
+    {
+      const ContentPrincipalInfo& leftContent = aLeft.get_ContentPrincipalInfo();
+      const ContentPrincipalInfo& rightContent = aRight.get_ContentPrincipalInfo();
+      return leftContent.attrs() == rightContent.attrs() &&
+             leftContent.originNoSuffix() == rightContent.originNoSuffix();
+    }
+    case PrincipalInfo::TSystemPrincipalInfo:
+    {
+      // system principal always matches
+      return true;
+    }
+    case PrincipalInfo::TNullPrincipalInfo:
+    {
+      // null principal never matches
+      return false;
+    }
+    default:
+    {
+      break;
+    }
+  }
+
+  // Clients (windows/workers) should never have an expanded principal type.
+  MOZ_CRASH("unexpected principal type!");
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientPrincipalUtils.h b/dom/clients/manager/ClientPrincipalUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientPrincipalUtils.h
@@ -0,0 +1,24 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientPrincipaltils_h
+#define _mozilla_dom_ClientPrincipaltils_h
+
+namespace mozilla {
+
+namespace ipc {
+class PrincipalInfo;
+} // namespace ipc
+
+namespace dom {
+
+bool
+ClientMatchPrincipalInfo(const mozilla::ipc::PrincipalInfo& aLeft,
+                         const mozilla::ipc::PrincipalInfo& aRight);
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientPrincipalUtils_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSource.h"
 
 #include "ClientManager.h"
 #include "ClientManagerChild.h"
+#include "ClientPrincipalUtils.h"
 #include "ClientSourceChild.h"
 #include "ClientState.h"
 #include "ClientValidation.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/Navigator.h"
@@ -367,16 +368,21 @@ ClientSource::WorkerSyncPing(WorkerPriva
   GetActor()->SendWorkerSyncPing();
 }
 
 void
 ClientSource::SetController(const ServiceWorkerDescriptor& aServiceWorker)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
+  // We should never have a cross-origin controller.  Since this would be
+  // same-origin policy violation we do a full release assertion here.
+  MOZ_RELEASE_ASSERT(ClientMatchPrincipalInfo(mClientInfo.PrincipalInfo(),
+                                              aServiceWorker.PrincipalInfo()));
+
   // A client in private browsing mode should never be controlled by
   // a service worker.  The principal origin attributes should guarantee
   // this invariant.
   MOZ_DIAGNOSTIC_ASSERT(!mClientInfo.IsPrivateBrowsing());
 
   // A client without access to storage should never be controlled a
   // a service worker.  If we are already execution ready with a real
   // window or worker, then verify assert the storage policy is correct.
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -35,16 +35,17 @@ UNIFIED_SOURCES += [
   'ClientManagerService.cpp',
   'ClientNavigateOpChild.cpp',
   'ClientNavigateOpParent.cpp',
   'ClientOpenWindowOpActors.cpp',
   'ClientOpenWindowOpChild.cpp',
   'ClientOpenWindowOpParent.cpp',
   'ClientOpenWindowUtils.cpp',
   'ClientPrefs.cpp',
+  'ClientPrincipalUtils.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ClientState.cpp',
   'ClientValidation.cpp',
 ]
