# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c64f5e2ab5208c348bfb78b13b489fee42ebcd74
Bug 1471706 P1 Track each registration state change with a version number stored on the descriptor. r=mrbkap

diff --git a/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh b/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
--- a/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
+++ b/dom/serviceworkers/IPCServiceWorkerDescriptor.ipdlh
@@ -11,16 +11,17 @@ namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Note that the state may be slightly out-of-sync
 // with the parent and should be updated dynamically if necessary.
 struct IPCServiceWorkerDescriptor
 {
   uint64_t id;
   uint64_t registrationId;
+  uint64_t registrationVersion;
   PrincipalInfo principalInfo;
   nsCString scope;
   nsCString scriptURL;
   ServiceWorkerState state;
 };
 
 union OptionalIPCServiceWorkerDescriptor
 {
diff --git a/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh b/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
--- a/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
+++ b/dom/serviceworkers/IPCServiceWorkerRegistrationDescriptor.ipdlh
@@ -11,16 +11,17 @@ namespace mozilla {
 namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Note that the state may be slightly out-of-sync
 // with the parent and should be updated dynamically if necessary.
 struct IPCServiceWorkerRegistrationDescriptor
 {
   uint64_t id;
+  uint64_t version;
 
   // These values should match the principal and scope in each
   // associated worker.  It may be possible to optimize in the future,
   // but for now we duplicate the information here to ensure correctness.
   // Its possible we may need to reference a registration before the
   // worker is installed yet, etc.
   PrincipalInfo principalInfo;
   nsCString scope;
diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -88,16 +88,17 @@ ServiceWorker::ServiceWorker(nsIGlobalOb
 
   // This will update our state too.
   mInner->AddServiceWorker(this);
 
   // Attempt to get an existing binding object for the registration
   // associated with this ServiceWorker.
   RefPtr<ServiceWorkerRegistration> reg = aGlobal->GetServiceWorkerRegistration(
     ServiceWorkerRegistrationDescriptor(mDescriptor.RegistrationId(),
+                                        mDescriptor.RegistrationVersion(),
                                         mDescriptor.PrincipalInfo(),
                                         mDescriptor.Scope(),
                                         ServiceWorkerUpdateViaCache::Imports));
   if (reg) {
     MaybeAttachToRegistration(reg);
   } else {
     RefPtr<ServiceWorker> self = this;
 
diff --git a/dom/serviceworkers/ServiceWorkerDescriptor.cpp b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerDescriptor.cpp
@@ -12,39 +12,43 @@
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::PrincipalInfo;
 using mozilla::ipc::PrincipalInfoToPrincipal;
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(uint64_t aId,
                                                  uint64_t aRegistrationId,
+                                                 uint64_t aRegistrationVersion,
                                                  nsIPrincipal* aPrincipal,
                                                  const nsACString& aScope,
                                                  const nsACString& aScriptURL,
                                                  ServiceWorkerState aState)
   : mData(MakeUnique<IPCServiceWorkerDescriptor>())
 {
   MOZ_ALWAYS_SUCCEEDS(
     PrincipalToPrincipalInfo(aPrincipal, &mData->principalInfo()));
 
   mData->id() = aId;
   mData->registrationId() = aRegistrationId;
+  mData->registrationVersion() = aRegistrationVersion;
   mData->scope() = aScope;
   mData->scriptURL() = aScriptURL;
   mData->state() = aState;
 }
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(uint64_t aId,
                                                  uint64_t aRegistrationId,
+                                                 uint64_t aRegistrationVersion,
                                                  const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                                                  const nsACString& aScope,
                                                  const nsACString& aScriptURL,
                                                  ServiceWorkerState aState)
   : mData(MakeUnique<IPCServiceWorkerDescriptor>(aId, aRegistrationId,
+                                                 aRegistrationVersion,
                                                  aPrincipalInfo,
                                                  nsCString(aScriptURL),
                                                  nsCString(aScope), aState))
 {
 }
 
 ServiceWorkerDescriptor::ServiceWorkerDescriptor(const IPCServiceWorkerDescriptor& aDescriptor)
   : mData(MakeUnique<IPCServiceWorkerDescriptor>(aDescriptor))
@@ -97,16 +101,22 @@ ServiceWorkerDescriptor::Id() const
 }
 
 uint64_t
 ServiceWorkerDescriptor::RegistrationId() const
 {
   return mData->registrationId();
 }
 
+uint64_t
+ServiceWorkerDescriptor::RegistrationVersion() const
+{
+  return mData->registrationVersion();
+}
+
 const mozilla::ipc::PrincipalInfo&
 ServiceWorkerDescriptor::PrincipalInfo() const
 {
   return mData->principalInfo();
 }
 
 nsCOMPtr<nsIPrincipal>
 ServiceWorkerDescriptor::GetPrincipal() const
@@ -135,16 +145,23 @@ ServiceWorkerDescriptor::State() const
 }
 
 void
 ServiceWorkerDescriptor::SetState(ServiceWorkerState aState)
 {
   mData->state() = aState;
 }
 
+void
+ServiceWorkerDescriptor::SetRegistrationVersion(uint64_t aVersion)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aVersion > mData->registrationVersion());
+  mData->registrationVersion() = aVersion;
+}
+
 bool
 ServiceWorkerDescriptor::Matches(const ServiceWorkerDescriptor& aDescriptor) const
 {
   return Id() == aDescriptor.Id() &&
          Scope() == aDescriptor.Scope() &&
          ScriptURL() == aDescriptor.ScriptURL() &&
          PrincipalInfo() == aDescriptor.PrincipalInfo();
 }
diff --git a/dom/serviceworkers/ServiceWorkerDescriptor.h b/dom/serviceworkers/ServiceWorkerDescriptor.h
--- a/dom/serviceworkers/ServiceWorkerDescriptor.h
+++ b/dom/serviceworkers/ServiceWorkerDescriptor.h
@@ -32,23 +32,25 @@ class ServiceWorkerDescriptor final
   // This class is largely a wrapper around an IPDL generated struct.  We
   // need the wrapper class since IPDL generated code includes windows.h
   // which is in turn incompatible with bindings code.
   UniquePtr<IPCServiceWorkerDescriptor> mData;
 
 public:
   ServiceWorkerDescriptor(uint64_t aId,
                           uint64_t aRegistrationId,
+                          uint64_t aRegistrationVersion,
                           nsIPrincipal* aPrincipal,
                           const nsACString& aScope,
                           const nsACString& aScriptURL,
                           ServiceWorkerState aState);
 
   ServiceWorkerDescriptor(uint64_t aId,
                           uint64_t aRegistrationId,
+                          uint64_t aRegistrationVersion,
                           const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                           const nsACString& aScope,
                           const nsACString& aScriptURL,
                           ServiceWorkerState aState);
 
   explicit ServiceWorkerDescriptor(const IPCServiceWorkerDescriptor& aDescriptor);
 
   ServiceWorkerDescriptor(const ServiceWorkerDescriptor& aRight);
@@ -67,16 +69,19 @@ public:
   operator==(const ServiceWorkerDescriptor& aRight) const;
 
   uint64_t
   Id() const;
 
   uint64_t
   RegistrationId() const;
 
+  uint64_t
+  RegistrationVersion() const;
+
   const mozilla::ipc::PrincipalInfo&
   PrincipalInfo() const;
 
   nsCOMPtr<nsIPrincipal>
   GetPrincipal() const;
 
   const nsCString&
   Scope() const;
@@ -85,16 +90,19 @@ public:
   ScriptURL() const;
 
   ServiceWorkerState
   State() const;
 
   void
   SetState(ServiceWorkerState aState);
 
+  void
+  SetRegistrationVersion(uint64_t aVersion);
+
   // Try to determine if two workers match each other.  This is less strict
   // than an operator==() call since it ignores mutable values like State().
   bool
   Matches(const ServiceWorkerDescriptor& aDescriptor) const;
 
   // Expose the underlying IPC type so that it can be passed via IPC.
   const IPCServiceWorkerDescriptor&
   ToIPC() const;
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -145,22 +145,23 @@ ServiceWorkerInfo::UpdateState(ServiceWo
   if (State() == ServiceWorkerState::Redundant) {
     serviceWorkerScriptCache::PurgeCache(mPrincipal, mCacheName);
   }
 }
 
 ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                                      const nsACString& aScope,
                                      uint64_t aRegistrationId,
+                                     uint64_t aRegistrationVersion,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName,
                                      nsLoadFlags aImportsLoadFlags)
   : mPrincipal(aPrincipal)
-  , mDescriptor(GetNextID(), aRegistrationId, aPrincipal, aScope, aScriptSpec,
-                ServiceWorkerState::Parsed)
+  , mDescriptor(GetNextID(), aRegistrationId, aRegistrationVersion, aPrincipal,
+                aScope, aScriptSpec, ServiceWorkerState::Parsed)
   , mCacheName(aCacheName)
   , mImportsLoadFlags(aImportsLoadFlags)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mInstalledTime(0)
   , mActivatedTime(0)
   , mRedundantTime(0)
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
@@ -231,10 +232,16 @@ ServiceWorkerInfo::UpdateRedundantTime()
   MOZ_ASSERT(State() == ServiceWorkerState::Redundant);
   MOZ_ASSERT(mRedundantTime == 0);
 
   mRedundantTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
+void
+ServiceWorkerInfo::SetRegistrationVersion(uint64_t aVersion)
+{
+  mDescriptor.SetRegistrationVersion(aVersion);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -115,16 +115,17 @@ public:
   {
     MOZ_ASSERT(NS_IsMainThread());
     mSkipWaitingFlag = true;
   }
 
   ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                     const nsACString& aScope,
                     uint64_t aRegistrationId,
+                    uint64_t aRegistrationVersion,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName,
                     nsLoadFlags aLoadFlags);
 
   ServiceWorkerState
   State() const
   {
     return mDescriptor.State();
@@ -174,16 +175,19 @@ public:
   void
   SetHandlesFetch(bool aHandlesFetch)
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch == Unknown);
     mHandlesFetch = aHandlesFetch ? Enabled : Disabled;
   }
 
+  void
+  SetRegistrationVersion(uint64_t aVersion);
+
   bool
   HandlesFetch() const
   {
     MOZ_ASSERT(NS_IsMainThread());
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch != Unknown);
     return mHandlesFetch != Disabled;
   }
 
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -1569,16 +1569,17 @@ ServiceWorkerManager::LoadRegistration(
       : nsIRequest::VALIDATE_ALWAYS;
 
   const nsCString& currentWorkerURL = aRegistration.currentWorkerURL();
   if (!currentWorkerURL.IsEmpty()) {
     registration->SetActive(
       new ServiceWorkerInfo(registration->Principal(),
                             registration->Scope(),
                             registration->Id(),
+                            registration->Version(),
                             currentWorkerURL,
                             aRegistration.cacheName(),
                             importsLoadFlags));
     registration->GetActive()->SetHandlesFetch(aRegistration.currentWorkerHandlesFetch());
     registration->GetActive()->SetInstalledTime(aRegistration.currentWorkerInstalledTime());
     registration->GetActive()->SetActivatedTime(aRegistration.currentWorkerActivatedTime());
   }
 }
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.cpp
@@ -27,38 +27,42 @@ ServiceWorkerRegistrationDescriptor::New
   } else if (mData->active().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     result.emplace(mData->active().get_IPCServiceWorkerDescriptor());
   }
   return result;
 }
 
 ServiceWorkerRegistrationDescriptor::ServiceWorkerRegistrationDescriptor(
                                     uint64_t aId,
+                                    uint64_t aVersion,
                                     nsIPrincipal* aPrincipal,
                                     const nsACString& aScope,
                                     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : mData(MakeUnique<IPCServiceWorkerRegistrationDescriptor>())
 {
   MOZ_ALWAYS_SUCCEEDS(
     PrincipalToPrincipalInfo(aPrincipal, &mData->principalInfo()));
 
   mData->id() = aId;
+  mData->version() = aVersion;
   mData->scope() = aScope;
   mData->updateViaCache() = aUpdateViaCache;
   mData->installing() = void_t();
   mData->waiting() = void_t();
   mData->active() = void_t();
 }
 
 ServiceWorkerRegistrationDescriptor::ServiceWorkerRegistrationDescriptor(
                                     uint64_t aId,
+                                    uint64_t aVersion,
                                     const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                                     const nsACString& aScope,
                                     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : mData(MakeUnique<IPCServiceWorkerRegistrationDescriptor>(aId,
+                                                             aVersion,
                                                              aPrincipalInfo,
                                                              nsCString(aScope),
                                                              aUpdateViaCache,
                                                              void_t(),
                                                              void_t(),
                                                              void_t()))
 {
 }
@@ -116,16 +120,22 @@ ServiceWorkerRegistrationDescriptor::ope
 }
 
 uint64_t
 ServiceWorkerRegistrationDescriptor::Id() const
 {
   return mData->id();
 }
 
+uint64_t
+ServiceWorkerRegistrationDescriptor::Version() const
+{
+  return mData->version();
+}
+
 ServiceWorkerUpdateViaCache
 ServiceWorkerRegistrationDescriptor::UpdateViaCache() const
 {
   return mData->updateViaCache();
 }
 
 const mozilla::ipc::PrincipalInfo&
 ServiceWorkerRegistrationDescriptor::PrincipalInfo() const
@@ -265,45 +275,44 @@ ServiceWorkerRegistrationDescriptor::Set
 }
 
 void
 ServiceWorkerRegistrationDescriptor::SetWorkers(ServiceWorkerInfo* aInstalling,
                                                 ServiceWorkerInfo* aWaiting,
                                                 ServiceWorkerInfo* aActive)
 {
   if (aInstalling) {
+    aInstalling->SetRegistrationVersion(Version());
     mData->installing() = aInstalling->Descriptor().ToIPC();
   } else {
     mData->installing() = void_t();
   }
 
   if (aWaiting) {
+    aWaiting->SetRegistrationVersion(Version());
     mData->waiting() = aWaiting->Descriptor().ToIPC();
   } else {
     mData->waiting() = void_t();
   }
 
   if (aActive) {
+    aActive->SetRegistrationVersion(Version());
     mData->active() = aActive->Descriptor().ToIPC();
   } else {
     mData->active() = void_t();
   }
 
   MOZ_DIAGNOSTIC_ASSERT(IsValid());
 }
 
 void
-ServiceWorkerRegistrationDescriptor::SetWorkers(const OptionalIPCServiceWorkerDescriptor& aInstalling,
-                                                const OptionalIPCServiceWorkerDescriptor& aWaiting,
-                                                const OptionalIPCServiceWorkerDescriptor& aActive)
+ServiceWorkerRegistrationDescriptor::SetVersion(uint64_t aVersion)
 {
-  mData->installing() = aInstalling;
-  mData->waiting() = aWaiting;
-  mData->active() = aActive;
-  MOZ_DIAGNOSTIC_ASSERT(IsValid());
+  MOZ_DIAGNOSTIC_ASSERT(aVersion > mData->version());
+  mData->version() = aVersion;
 }
 
 const IPCServiceWorkerRegistrationDescriptor&
 ServiceWorkerRegistrationDescriptor::ToIPC() const
 {
   return *mData;
 }
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationDescriptor.h
@@ -33,21 +33,23 @@ class ServiceWorkerRegistrationDescripto
   // which is in turn incompatible with bindings code.
   UniquePtr<IPCServiceWorkerRegistrationDescriptor> mData;
 
   Maybe<IPCServiceWorkerDescriptor>
   NewestInternal() const;
 
 public:
   ServiceWorkerRegistrationDescriptor(uint64_t aId,
+                                      uint64_t aVersion,
                                       nsIPrincipal* aPrincipal,
                                       const nsACString& aScope,
                                       ServiceWorkerUpdateViaCache aUpdateViaCache);
 
   ServiceWorkerRegistrationDescriptor(uint64_t aId,
+                                      uint64_t aVersion,
                                       const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                                       const nsACString& aScope,
                                       ServiceWorkerUpdateViaCache aUpdateViaCache);
 
   explicit ServiceWorkerRegistrationDescriptor(const IPCServiceWorkerRegistrationDescriptor& aDescriptor);
 
   ServiceWorkerRegistrationDescriptor(const ServiceWorkerRegistrationDescriptor& aRight);
 
@@ -62,16 +64,19 @@ public:
   ~ServiceWorkerRegistrationDescriptor();
 
   bool
   operator==(const ServiceWorkerRegistrationDescriptor& aRight) const;
 
   uint64_t
   Id() const;
 
+  uint64_t
+  Version() const;
+
   ServiceWorkerUpdateViaCache
   UpdateViaCache() const;
 
   const mozilla::ipc::PrincipalInfo&
   PrincipalInfo() const;
 
   nsCOMPtr<nsIPrincipal>
   GetPrincipal() const;
@@ -101,19 +106,17 @@ public:
   SetUpdateViaCache(ServiceWorkerUpdateViaCache aUpdateViaCache);
 
   void
   SetWorkers(ServiceWorkerInfo* aInstalling,
              ServiceWorkerInfo* aWaiting,
              ServiceWorkerInfo* aActive);
 
   void
-  SetWorkers(const OptionalIPCServiceWorkerDescriptor& aInstalling,
-             const OptionalIPCServiceWorkerDescriptor& aWaiting,
-             const OptionalIPCServiceWorkerDescriptor& aActive);
+  SetVersion(uint64_t aVersion);
 
   // Expose the underlying IPC type so that it can be passed via IPC.
   const IPCServiceWorkerRegistrationDescriptor&
   ToIPC() const;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -93,17 +93,18 @@ ServiceWorkerRegistrationInfo::IsCorrupt
   return mCorrupt;
 }
 
 ServiceWorkerRegistrationInfo::ServiceWorkerRegistrationInfo(
     const nsACString& aScope,
     nsIPrincipal* aPrincipal,
     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : mPrincipal(aPrincipal)
-  , mDescriptor(GetNextId(), aPrincipal, aScope, aUpdateViaCache)
+  , mDescriptor(GetNextId(), GetNextVersion(), aPrincipal, aScope,
+                aUpdateViaCache)
   , mControlledClientsCounter(0)
   , mDelayMultiplier(0)
   , mUpdateState(NoUpdate)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mLastUpdateTime(0)
   , mPendingUninstall(false)
   , mCorrupt(false)
@@ -375,18 +376,16 @@ ServiceWorkerRegistrationInfo::FinishAct
       mActiveWorker->State() != ServiceWorkerState::Activating) {
     return;
   }
 
   // Activation never fails, so aSuccess is ignored.
   mActiveWorker->UpdateState(ServiceWorkerState::Activated);
   mActiveWorker->UpdateActivatedTime();
 
-  mDescriptor.SetWorkers(mInstallingWorker, mWaitingWorker, mActiveWorker);
-
   UpdateRegistrationState();
   NotifyChromeRegistrationListeners();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // browser shutdown started during async activation completion step
     return;
   }
@@ -426,20 +425,33 @@ ServiceWorkerRegistrationInfo::IsLastUpd
     return true;
   }
   return false;
 }
 
 void
 ServiceWorkerRegistrationInfo::UpdateRegistrationState()
 {
+  UpdateRegistrationState(mDescriptor.UpdateViaCache());
+}
+
+void
+ServiceWorkerRegistrationInfo::UpdateRegistrationState(ServiceWorkerUpdateViaCache aUpdateViaCache)
+{
   MOZ_ASSERT(NS_IsMainThread());
 
+  // We are going to modify the descriptor, so increase its version number.
+  mDescriptor.SetVersion(GetNextVersion());
+
+  // Note, this also sets the new version number on the ServiceWorkerInfo
+  // objects before we copy over their updated descriptors.
   mDescriptor.SetWorkers(mInstallingWorker, mWaitingWorker, mActiveWorker);
 
+  mDescriptor.SetUpdateViaCache(aUpdateViaCache);
+
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mInstanceList);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     target->UpdateState(mDescriptor);
   }
 }
 
 void
@@ -701,18 +713,17 @@ ServiceWorkerRegistrationInfo::GetUpdate
 {
   return mDescriptor.UpdateViaCache();
 }
 
 void
 ServiceWorkerRegistrationInfo::SetUpdateViaCache(
     ServiceWorkerUpdateViaCache aUpdateViaCache)
 {
-  mDescriptor.SetUpdateViaCache(aUpdateViaCache);
-  UpdateRegistrationState();
+  UpdateRegistrationState(aUpdateViaCache);
 }
 
 int64_t
 ServiceWorkerRegistrationInfo::GetLastUpdateTime() const
 {
   return mLastUpdateTime;
 }
 
@@ -733,16 +744,22 @@ ServiceWorkerRegistrationInfo::Descripto
 }
 
 uint64_t
 ServiceWorkerRegistrationInfo::Id() const
 {
   return mDescriptor.Id();
 }
 
+uint64_t
+ServiceWorkerRegistrationInfo::Version() const
+{
+  return mDescriptor.Version();
+}
+
 uint32_t
 ServiceWorkerRegistrationInfo::GetUpdateDelay()
 {
   uint32_t delay = Preferences::GetInt("dom.serviceWorkers.update_delay",
                                        1000);
   // This can potentially happen if you spam registration->Update(). We don't
   // want to wrap to a lower value.
   if (mDelayMultiplier >= INT_MAX / (delay ? delay : 1)) {
@@ -782,10 +799,19 @@ ServiceWorkerRegistrationInfo::NotifyRem
 uint64_t
 ServiceWorkerRegistrationInfo::GetNextId()
 {
   MOZ_ASSERT(NS_IsMainThread());
   static uint64_t sNextId = 0;
   return ++sNextId;
 }
 
+// static
+uint64_t
+ServiceWorkerRegistrationInfo::GetNextVersion()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  static uint64_t sNextVersion = 0;
+  return ++sNextVersion;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
@@ -229,39 +229,48 @@ public:
   SetLastUpdateTime(const int64_t aTime);
 
   const ServiceWorkerRegistrationDescriptor&
   Descriptor() const;
 
   uint64_t
   Id() const;
 
+  uint64_t
+  Version() const;
+
   uint32_t
   GetUpdateDelay();
 
   void
   FireUpdateFound();
 
   void
   NotifyRemoved();
 
 private:
   // Roughly equivalent to [[Update Registration State algorithm]]. Make sure
   // this is called *before* updating SW instances' state, otherwise they
   // may get CC-ed.
   void
   UpdateRegistrationState();
 
+  void
+  UpdateRegistrationState(ServiceWorkerUpdateViaCache aUpdateViaCache);
+
   // Used by devtools to track changes to the properties of *nsIServiceWorkerRegistrationInfo*.
   // Note, this doesn't necessarily need to be in sync with the DOM registration objects, but
   // it does need to be called in the same task that changed |mInstallingWorker|,
   // |mWaitingWorker| or |mActiveWorker|.
   void
   NotifyChromeRegistrationListeners();
 
   static uint64_t
   GetNextId();
+
+  static uint64_t
+  GetNextVersion();
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_serviceworkerregistrationinfo_h
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -457,16 +457,17 @@ ServiceWorkerUpdateJob::ComparisonResult
   if (GetUpdateViaCache() == ServiceWorkerUpdateViaCache::None) {
     flags |= nsIRequest::VALIDATE_ALWAYS;
   }
 
   RefPtr<ServiceWorkerInfo> sw =
     new ServiceWorkerInfo(mRegistration->Principal(),
                           mRegistration->Scope(),
                           mRegistration->Id(),
+                          mRegistration->Version(),
                           mScriptSpec,
                           aNewCacheName,
                           flags);
 
   // If the registration is corrupt enough to force an uninstall if the
   // upgrade fails, then we want to make sure the upgrade takes effect
   // if it succeeds.  Therefore force the skip-waiting flag on to replace
   // the broken worker after install.
