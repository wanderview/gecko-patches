# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c10e958c67aef16527660ad4401aaa92f4ef2bf1

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -56,18 +56,30 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
+  // Convert the precise delay to integral milliseconds for nsITimer.  We can
+  // round down as long as its within our mFlexTime.  If we round down more
+  // than this than we might have to trigger another nsITimer after this one
+  // fires.  Instead, round up to the next integral millisecond if rounding
+  // down would exceed our mFlexTime.
+  //
+  // For example:
+  //  * if delay is 5.4ms and our flex time is 0.25ms, then round up to 6ms
+  //  * if delay is 5.4ms and our flex time is 0.5ms, then round down to 5ms
   TimeDuration delay = aDeadline - aNow;
-  rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
+  uint32_t delayMS = static_cast<uint32_t>(delay.ToMilliseconds() +
+                                           1.0 - mFlexTime.ToMilliseconds());
+
+  rv = mTimer->InitWithCallback(this, delayMS,
                                 nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
