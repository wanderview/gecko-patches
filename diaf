# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  3ad1eaf1f06be7f8e1aeae62c20f76422eb82246

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -54,17 +54,17 @@ Client::GetEndPoint(ClientEndPoint& aEnd
       aEndPointOut = clientInfo.ref();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
         aEndPointOut = workerPrivate->GetClientInfo();
         return NS_OK;
       }
     }
   }
 
@@ -186,17 +186,17 @@ Client::Focus(ErrorResult& aRv)
   }
 
   ClientEndPoint endpoint;
   aRv = GetEndPoint(endpoint);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
-  if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
+  if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_DIAGNOSTIC_ASSERT(workerPrivate);
     if (!workerPrivate->GlobalScope()->WindowInteractionAllowed()) {
       outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
       return outerPromise.forget();
     }
   }
 
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -45,17 +45,17 @@ Clients::GetEndPoint(ClientEndPoint& aEn
       aEndPointOut = clientInfo.ref();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
         aEndPointOut = workerPrivate->GetClientInfo();
         return NS_OK;
       }
     }
   }
 
@@ -102,18 +102,18 @@ Clients::Get(const nsAString& aClientID,
     // If we can't get an endpoint then we don't have a recognizeable
     // principal and we won't effectively match anything.  Resolve
     // undefined indicating "not found".
     outerPromise->MaybeResolveWithUndefined();
     return outerPromise.forget();
   }
 
   const PrincipalInfo& principalInfo =
-    endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor
-      ? endpoint.get_ServiceWorkerDescriptor().principalInfo()
+    endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor
+      ? endpoint.get_IPCServiceWorkerDescriptor().principalInfo()
       : endpoint.get_ClientInfo().principalInfo();
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo));
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
@@ -219,23 +219,23 @@ Clients::Claim(ErrorResult& aRv)
 
   ClientEndPoint endpoint;
   nsresult rv = GetEndPoint(endpoint);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return outerPromise.forget();
   }
 
-  if (endpoint.type() != ClientEndPoint::TServiceWorkerDescriptor) {
+  if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
-  const ServiceWorkerDescriptor& serviceWorker =
-    endpoint.get_ServiceWorkerDescriptor();
+  const IPCServiceWorkerDescriptor& serviceWorker =
+    endpoint.get_IPCServiceWorkerDescriptor();
 
   if (serviceWorker.state() != ServiceWorkerState::Activating &&
       serviceWorker.state() != ServiceWorkerState::Activated) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   RefPtr<ClientOpPromise> innerPromise =
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandle.h"
 
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
 #include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
 
@@ -105,17 +106,17 @@ ClientHandle::Info() const
 
 already_AddRefed<GenericPromise>
 ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
-    StartOp(ClientControlledArgs(aServiceWorker));
+    StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -1,16 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
-include ServiceWorkerDescriptor;
+include IPCServiceWorkerDescriptor;
 using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
@@ -59,34 +59,34 @@ struct ClientInfoAndState
 struct ClientSourceExecutionReadyArgs
 {
   nsCString url;
   FrameType frameType;
 };
 
 struct ClientControlledArgs
 {
-  ServiceWorkerDescriptor serviceWorker;
+  IPCServiceWorkerDescriptor serviceWorker;
 };
 
 struct ClientFocusArgs
 {
 };
 
 struct ClientNavigateArgs
 {
   ClientInfo target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientEndPoint
 {
   ClientInfo;
-  ServiceWorkerDescriptor;
+  IPCServiceWorkerDescriptor;
 };
 
 struct ClientPostMessageArgs
 {
   ClonedMessageData clonedData;
   ClientEndPoint endpoint;
 };
 
@@ -99,17 +99,17 @@ struct ClientMatchAllArgs
   ClientEndPoint endpoint;
   ClientType type;
   bool includeUncontrolled;
   bool includeReserved;
 };
 
 struct ClientClaimArgs
 {
-  ServiceWorkerDescriptor serviceWorker;
+  IPCServiceWorkerDescriptor serviceWorker;
 };
 
 struct ClientGetInfoAndStateArgs
 {
   nsID id;
   PrincipalInfo principalInfo;
 };
 
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -290,17 +290,17 @@ ClientManagerService::MatchAll(const Cli
 {
   AssertIsOnBackgroundThread();
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
 
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TClientInfo
       ? endpoint.get_ClientInfo().principalInfo()
-      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+      : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   RefPtr<PromiseListHolder> promiseList =
     new PromiseListHolder(mBackgroundThread);
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
@@ -312,32 +312,32 @@ ClientManagerService::MatchAll(const Cli
     }
 
     if (aArgs.type() != ClientType::All &&
         source->Info().type() != aArgs.type()) {
       continue;
     }
 
     if (!aArgs.includeUncontrolled()) {
-      if (endpoint.type() != ClientEndPoint::TServiceWorkerDescriptor) {
+      if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
         continue;
       }
 
 
       const Maybe<ServiceWorkerDescriptor>& controller =
         source->GetController();
       if (controller.isNothing()) {
         continue;
       }
 
-      const ServiceWorkerDescriptor serviceWorker =
-        endpoint.get_ServiceWorkerDescriptor();
+      const IPCServiceWorkerDescriptor& serviceWorker =
+        endpoint.get_IPCServiceWorkerDescriptor();
 
-      if(controller.ref().id() != serviceWorker.id() ||
-         controller.ref().scope() != serviceWorker.scope()) {
+      if(controller.ref().Id() != serviceWorker.id() ||
+         controller.ref().Scope() != serviceWorker.scope()) {
         continue;
       }
     }
 
     if (!aArgs.includeReserved() && !source->ExecutionReady()) {
       continue;
     }
 
@@ -352,17 +352,17 @@ ClientManagerService::MatchAll(const Cli
   return promiseList->GetResultPromise();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientManagerService::Claim(const ClientClaimArgs& aArgs)
 {
   AssertIsOnBackgroundThread();
 
-  const ServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
+  const IPCServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
   const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
 
   RefPtr<PromiseListHolder> promiseList =
     new PromiseListHolder(mBackgroundThread);
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
@@ -371,18 +371,18 @@ ClientManagerService::Claim(const Client
     }
 
     if (!MatchPrincipalInfo(source->Info().principalInfo(), principalInfo)) {
       continue;
     }
 
     const Maybe<ServiceWorkerDescriptor>& controller = source->GetController();
     if (controller.isSome() &&
-        controller.ref().scope() == serviceWorker.scope() &&
-        controller.ref().id() == serviceWorker.id()) {
+        controller.ref().Scope() == serviceWorker.scope() &&
+        controller.ref().Id() == serviceWorker.id()) {
       continue;
     }
 
     // TODO: This logic to determine if a service worker should control
     //       a particular client should be moved to the ServiceWorkerManager.
     //       This can't happen until the SWM is moved to the parent process,
     //       though.
     if (!source->ExecutionReady() ||
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -271,17 +271,17 @@ ClientSource::SetController(const Servic
   }
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::Control(const ClientControlledArgs& aArgs)
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
 
-  SetController(aArgs.serviceWorker());
+  SetController(ServiceWorkerDescriptor(aArgs.serviceWorker()));
 
   RefPtr<ClientOpPromise> ref =
     ClientOpPromise::CreateAndResolve(NS_OK, __func__);
   return ref.forget();;
 }
 
 const Maybe<ServiceWorkerDescriptor>&
 ClientSource::GetController() const
@@ -334,17 +334,17 @@ ClientSource::PostMessage(const ClientPo
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TClientInfo
       ? endpoint.get_ClientInfo().principalInfo()
-      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+      : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
   // TODO: this should probably not require strict spec matching
   if (false && !(mClientInfo.principalInfo() == principalInfo)) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
   StructuredCloneData clonedData;
@@ -440,18 +440,18 @@ ClientSource::PostMessage(const ClientPo
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // Shutting down. Just don't deliver this message.
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
-  if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
-    const ServiceWorkerDescriptor& swd = endpoint.get_ServiceWorkerDescriptor();
+  if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
+    const IPCServiceWorkerDescriptor& swd = endpoint.get_IPCServiceWorkerDescriptor();
     RefPtr<ServiceWorkerRegistrationInfo> reg =
       swm->GetRegistration(principal, swd.scope());
     if (reg) {
       RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(swd.id());
       if (serviceWorker) {
         init.mSource.SetValue().SetAsServiceWorker() =
           serviceWorker->GetOrCreateInstance(GetInnerWindow());
       }
@@ -491,37 +491,39 @@ ClientSource::GetState(const ClientGetSt
   return ref.forget();
 }
 
 already_AddRefed<ClientOpPromise>
 ClientSource::Claim(const ClientClaimArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
+  ServiceWorkerDescriptor swd(aArgs.serviceWorker());
+
   // Today the ServiceWorkerManager maintains its own list of
   // nsIDocument objects controlled by each service worker.  We
   // need to try to update that data structure for now.  If we
   // can't, however, then simply mark the Client as controlled.
   // In the future this will be enough for the SWM as well since
   // it will eventually hold ClientHandle objects instead of
   // nsIDocuments.
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   nsPIDOMWindowInner* innerWindow = GetInnerWindow();
   nsIDocument* doc = innerWindow ? innerWindow->GetExtantDoc() : nullptr;
   if (!swm || !doc) {
-    SetController(aArgs.serviceWorker());
+    SetController(swd);
 
     ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
     return ref.forget();
   }
 
   RefPtr<ClientOpPromise::Private> outerPromise =
     new ClientOpPromise::Private(__func__);
 
-  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, aArgs.serviceWorker());
+  RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
   p->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise] (bool aResult) {
       outerPromise->Resolve(NS_OK, __func__);
     }, [outerPromise] (nsresult aResult) {
       outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise;
diff --git a/dom/workers/ServiceWorkerDescriptor.ipdlh b/dom/workers/IPCServiceWorkerDescriptor.ipdlh
rename from dom/workers/ServiceWorkerDescriptor.ipdlh
rename to dom/workers/IPCServiceWorkerDescriptor.ipdlh
--- a/dom/workers/ServiceWorkerDescriptor.ipdlh
+++ b/dom/workers/IPCServiceWorkerDescriptor.ipdlh
@@ -7,17 +7,17 @@ include PBackgroundSharedTypes;
 using ServiceWorkerState from "mozilla/dom/ServiceWorkerIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Today this just includes data require to look
 // up the ServiceWorkerInfo from the ServiceWorkerManager.
-struct ServiceWorkerDescriptor
+struct IPCServiceWorkerDescriptor
 {
   uint64_t id;
   PrincipalInfo principalInfo;
   nsCString scope;
   ServiceWorkerState state;
 };
 
 } // namespace dom
diff --git a/dom/workers/ServiceWorkerIPCUtils.h b/dom/workers/ServiceWorkerIPCUtils.h
--- a/dom/workers/ServiceWorkerIPCUtils.h
+++ b/dom/workers/ServiceWorkerIPCUtils.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ServiceWorkerIPCUtils_h
 #define _mozilla_dom_ServiceWorkerIPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/dom/ServiceWorkerBinding.h"
 
 namespace IPC {
+
   template<>
   struct ParamTraits<mozilla::dom::ServiceWorkerState> :
     public ContiguousEnumSerializer<mozilla::dom::ServiceWorkerState,
                                     mozilla::dom::ServiceWorkerState::Installing,
                                     mozilla::dom::ServiceWorkerState::EndGuard_>
   {};
 
 } // namespace IPC
diff --git a/dom/workers/ServiceWorkerInfo.cpp b/dom/workers/ServiceWorkerInfo.cpp
--- a/dom/workers/ServiceWorkerInfo.cpp
+++ b/dom/workers/ServiceWorkerInfo.cpp
@@ -41,17 +41,17 @@ ServiceWorkerInfo::GetCacheName(nsAStrin
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetState(uint16_t* aState)
 {
   MOZ_ASSERT(aState);
   AssertIsOnMainThread();
-  *aState = static_cast<uint16_t>(mState);
+  *aState = static_cast<uint16_t>(State());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetDebugger(nsIWorkerDebugger** aResult)
 {
   if (NS_WARN_IF(!aResult)) {
     return NS_ERROR_FAILURE;
@@ -176,68 +176,74 @@ private:
 void
 ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
 {
   AssertIsOnMainThread();
 #ifdef DEBUG
   // Any state can directly transition to redundant, but everything else is
   // ordered.
   if (aState != ServiceWorkerState::Redundant) {
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::EndGuard_, aState == ServiceWorkerState::Installing);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installing, aState == ServiceWorkerState::Installed);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Installed, aState == ServiceWorkerState::Activating);
-    MOZ_ASSERT_IF(mState == ServiceWorkerState::Activating, aState == ServiceWorkerState::Activated);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::EndGuard_,
+                  aState == ServiceWorkerState::Installing);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Installing,
+                  aState == ServiceWorkerState::Installed);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Installed,
+                  aState == ServiceWorkerState::Activating);
+    MOZ_ASSERT_IF(State() == ServiceWorkerState::Activating,
+                  aState == ServiceWorkerState::Activated);
   }
   // Activated can only go to redundant.
-  MOZ_ASSERT_IF(mState == ServiceWorkerState::Activated, aState == ServiceWorkerState::Redundant);
+  MOZ_ASSERT_IF(State() == ServiceWorkerState::Activated,
+                aState == ServiceWorkerState::Redundant);
 #endif
   // Flush any pending functional events to the worker when it transitions to the
   // activated state.
   // TODO: Do we care that these events will race with the propagation of the
   //       state change?
-  if (mState != aState) {
+  if (State() != aState) {
     mServiceWorkerPrivate->UpdateState(aState);
   }
-  mState = aState;
-  nsCOMPtr<nsIRunnable> r = new ChangeStateUpdater(mInstances, mState);
+  mDescriptor.SetState(aState);
+  nsCOMPtr<nsIRunnable> r =
+    new ChangeStateUpdater(mInstances, State());
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
-  if (mState == ServiceWorkerState::Redundant) {
+  if (State() == ServiceWorkerState::Redundant) {
     serviceWorkerScriptCache::PurgeCache(mPrincipal, mCacheName);
   }
 }
 
 ServiceWorkerInfo::ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                                      const nsACString& aScope,
                                      const nsACString& aScriptSpec,
                                      const nsAString& aCacheName,
                                      nsLoadFlags aLoadFlags)
   : mPrincipal(aPrincipal)
   , mScriptSpec(aScriptSpec)
   , mCacheName(aCacheName)
   , mLoadFlags(aLoadFlags)
-  , mState(ServiceWorkerState::EndGuard_)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mInstalledTime(0)
   , mActivatedTime(0)
   , mRedundantTime(0)
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
   , mSkipWaitingFlag(false)
   , mHandlesFetch(Unknown)
 {
   MOZ_ASSERT(mPrincipal);
   // cache origin attributes so we can use them off main thread
   mOriginAttributes = mPrincipal->OriginAttributesRef();
   MOZ_ASSERT(!mScriptSpec.IsEmpty());
   MOZ_ASSERT(!mCacheName.IsEmpty());
 
-  mDescriptor.id() = GetNextID();
-  mDescriptor.scope() = aScope;
-  MOZ_ALWAYS_SUCCEEDS(
-    PrincipalToPrincipalInfo(aPrincipal, &mDescriptor.principalInfo()));
+  PrincipalInfo principalInfo;
+  MOZ_ALWAYS_SUCCEEDS(PrincipalToPrincipalInfo(aPrincipal, &principalInfo));
+
+  mDescriptor = ServiceWorkerDescriptor(GetNextID(), principalInfo, aScope,
+                                        ServiceWorkerState::EndGuard_);
 }
 
 ServiceWorkerInfo::~ServiceWorkerInfo()
 {
   MOZ_ASSERT(mServiceWorkerPrivate);
   mServiceWorkerPrivate->NoteDeadServiceWorkerInfo();
 }
 
@@ -270,39 +276,39 @@ ServiceWorkerInfo::GetOrCreateInstance(n
   }
 
   return ref.forget();
 }
 
 void
 ServiceWorkerInfo::UpdateInstalledTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Installed);
+  MOZ_ASSERT(State()== ServiceWorkerState::Installed);
   MOZ_ASSERT(mInstalledTime == 0);
 
   mInstalledTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 void
 ServiceWorkerInfo::UpdateActivatedTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Activated);
+  MOZ_ASSERT(State() == ServiceWorkerState::Activated);
   MOZ_ASSERT(mActivatedTime == 0);
 
   mActivatedTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 void
 ServiceWorkerInfo::UpdateRedundantTime()
 {
-  MOZ_ASSERT(mState == ServiceWorkerState::Redundant);
+  MOZ_ASSERT(State() == ServiceWorkerState::Redundant);
   MOZ_ASSERT(mRedundantTime == 0);
 
   mRedundantTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -27,17 +27,16 @@ class ServiceWorkerPrivate;
 class ServiceWorkerInfo final : public nsIServiceWorkerInfo
 {
 private:
   nsCOMPtr<nsIPrincipal> mPrincipal;
   ServiceWorkerDescriptor mDescriptor;
   const nsCString mScriptSpec;
   const nsString mCacheName;
   const nsLoadFlags mLoadFlags;
-  ServiceWorkerState mState;
   OriginAttributes mOriginAttributes;
 
   // Timestamp to track SW's state
   PRTime mCreationTime;
   TimeStamp mCreationTimeStamp;
 
   // The time of states are 0, if SW has not reached that state yet. Besides, we
   // update each of them after UpdateState() is called in SWRegistrationInfo.
@@ -88,17 +87,17 @@ public:
   ScriptSpec() const
   {
     return mScriptSpec;
   }
 
   const nsCString&
   Scope() const
   {
-    return mDescriptor.scope();
+    return mDescriptor.Scope();
   }
 
   bool SkipWaitingFlag() const
   {
     AssertIsOnMainThread();
     return mSkipWaitingFlag;
   }
 
@@ -112,17 +111,17 @@ public:
                     const nsACString& aScope,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName,
                     nsLoadFlags aLoadFlags);
 
   ServiceWorkerState
   State() const
   {
-    return mState;
+    return mDescriptor.State();
   }
 
   const OriginAttributes&
   GetOriginAttributes() const
   {
     return mOriginAttributes;
   }
 
@@ -136,34 +135,34 @@ public:
   GetLoadFlags() const
   {
     return mLoadFlags;
   }
 
   uint64_t
   ID() const
   {
-    return mDescriptor.id();
+    return mDescriptor.Id();
   }
 
   const ServiceWorkerDescriptor&
   Descriptor() const
   {
     return mDescriptor;
   }
 
   void
   UpdateState(ServiceWorkerState aState);
 
   // Only used to set initial state when loading from disk!
   void
   SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
   {
     AssertIsOnMainThread();
-    mState = aState;
+    mDescriptor.SetState(aState);
   }
 
   void
   SetHandlesFetch(bool aHandlesFetch)
   {
     AssertIsOnMainThread();
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch == Unknown);
     mHandlesFetch = aHandlesFetch ? Enabled : Disabled;
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2908,17 +2908,17 @@ ServiceWorkerManager::GetDocumentControl
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(scopeKey, controller.ref().scope());
+    GetRegistration(scopeKey, controller.ref().Scope());
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   RefPtr<ServiceWorkerInfo> active = registration->GetActive();
   if (NS_WARN_IF(!active) ||
       NS_WARN_IF(!(active->Descriptor() == controller.ref()))) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
@@ -3426,24 +3426,24 @@ ServiceWorkerManager::MaybeClaimClient(n
 
 already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
                                        const ServiceWorkerDescriptor& aServiceWorker)
 {
   RefPtr<GenericPromise> ref;
 
   nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(aServiceWorker.principalInfo());
+    PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
   if (!principal) {
     ref = GenericPromise::CreateAndResolve(false, __func__);
     return ref.forget();
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(principal, aServiceWorker.scope());
+    GetRegistration(principal, aServiceWorker.Scope());
   if (!registration) {
     ref = GenericPromise::CreateAndResolve(false, __func__);
     return ref.forget();
   }
 
   ref = MaybeClaimClient(aDoc, registration);
   return ref.forget();
 }
diff --git a/dom/workers/ServiceWorkerManagerService.h b/dom/workers/ServiceWorkerManagerService.h
--- a/dom/workers/ServiceWorkerManagerService.h
+++ b/dom/workers/ServiceWorkerManagerService.h
@@ -5,16 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerManagerService_h
 #define mozilla_dom_ServiceWorkerManagerService_h
 
 #include "nsISupportsImpl.h"
 #include "nsHashKeys.h"
 #include "nsTHashtable.h"
+#include "nsTArray.h"
 
 namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -519,23 +519,23 @@ public:
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
   uint64_t
   ServiceWorkerID() const
   {
-    return GetServiceWorkerDescriptor().id();
+    return GetServiceWorkerDescriptor().Id();
   }
 
   const nsCString&
   ServiceWorkerScope() const
   {
-    return GetServiceWorkerDescriptor().scope();
+    return GetServiceWorkerDescriptor().Scope();
   }
 
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
@@ -566,17 +566,17 @@ public:
     return mLoadInfo.mServiceWorkerDescriptor.ref();
   }
 
   void
   UpdateServiceWorkerState(ServiceWorkerState aState)
   {
     MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
     MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
-    mLoadInfo.mServiceWorkerDescriptor.ref().state() = aState;
+    mLoadInfo.mServiceWorkerDescriptor.ref().SetState(aState);
   }
 
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mLoadInfo.mChannelInfo;
   }
 
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -7,16 +7,17 @@
 with Files("**"):
     BUG_COMPONENT = ("Core", "DOM: Workers")
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
     'FileReaderSync.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
+    'ServiceWorkerDescriptor.h',
     'ServiceWorkerEvents.h',
     'ServiceWorkerIPCUtils.h',
     'ServiceWorkerRegistrar.h',
     'ServiceWorkerRegistration.h',
     'WorkerLocation.h',
     'WorkerNavigator.h',
     'WorkerPrefs.h',
     'WorkerPrivate.h',
@@ -52,16 +53,17 @@ UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerContainer.cpp',
+    'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
@@ -83,19 +85,19 @@ UNIFIED_SOURCES += [
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
 IPDL_SOURCES += [
+    'IPCServiceWorkerDescriptor.ipdlh',
     'PServiceWorkerManager.ipdl',
     'PServiceWorkerUpdater.ipdl',
-    'ServiceWorkerDescriptor.ipdlh',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
     '/dom/base',
     '/dom/bindings',
