# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  3ad1eaf1f06be7f8e1aeae62c20f76422eb82246

diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -54,17 +54,17 @@ Client::GetEndPoint(ClientEndPoint& aEnd
       aEndPointOut = clientInfo.ref();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
         aEndPointOut = workerPrivate->GetClientInfo();
         return NS_OK;
       }
     }
   }
 
@@ -186,17 +186,17 @@ Client::Focus(ErrorResult& aRv)
   }
 
   ClientEndPoint endpoint;
   aRv = GetEndPoint(endpoint);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
-  if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
+  if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     MOZ_DIAGNOSTIC_ASSERT(workerPrivate);
     if (!workerPrivate->GlobalScope()->WindowInteractionAllowed()) {
       outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
       return outerPromise.forget();
     }
   }
 
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -45,17 +45,17 @@ Clients::GetEndPoint(ClientEndPoint& aEn
       aEndPointOut = clientInfo.ref();
       return NS_OK;
     }
   } else {
     MOZ_ASSERT(!NS_IsMainThread());
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
     if (workerPrivate) {
       if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor();
+        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
         return NS_OK;
       } else {
         aEndPointOut = workerPrivate->GetClientInfo();
         return NS_OK;
       }
     }
   }
 
@@ -102,18 +102,18 @@ Clients::Get(const nsAString& aClientID,
     // If we can't get an endpoint then we don't have a recognizeable
     // principal and we won't effectively match anything.  Resolve
     // undefined indicating "not found".
     outerPromise->MaybeResolveWithUndefined();
     return outerPromise.forget();
   }
 
   const PrincipalInfo& principalInfo =
-    endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor
-      ? endpoint.get_ServiceWorkerDescriptor().principalInfo()
+    endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor
+      ? endpoint.get_IPCServiceWorkerDescriptor().principalInfo()
       : endpoint.get_ClientInfo().principalInfo();
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   RefPtr<ClientOpPromise> innerPromise =
     ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo));
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
@@ -219,23 +219,23 @@ Clients::Claim(ErrorResult& aRv)
 
   ClientEndPoint endpoint;
   nsresult rv = GetEndPoint(endpoint);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return outerPromise.forget();
   }
 
-  if (endpoint.type() != ClientEndPoint::TServiceWorkerDescriptor) {
+  if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
-  const ServiceWorkerDescriptor& serviceWorker =
-    endpoint.get_ServiceWorkerDescriptor();
+  const IPCServiceWorkerDescriptor& serviceWorker =
+    endpoint.get_IPCServiceWorkerDescriptor();
 
   if (serviceWorker.state() != ServiceWorkerState::Activating &&
       serviceWorker.state() != ServiceWorkerState::Activated) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   RefPtr<ClientOpPromise> innerPromise =
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandle.h"
 
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
 #include "mozilla/dom/PClientManagerChild.h"
+#include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
 
@@ -105,17 +106,17 @@ ClientHandle::Info() const
 
 already_AddRefed<GenericPromise>
 ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
-    StartOp(ClientControlledArgs(aServiceWorker));
+    StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -1,16 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
-include ServiceWorkerDescriptor;
+include IPCServiceWorkerDescriptor;
 using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
@@ -59,34 +59,34 @@ struct ClientInfoAndState
 struct ClientSourceExecutionReadyArgs
 {
   nsCString url;
   FrameType frameType;
 };
 
 struct ClientControlledArgs
 {
-  ServiceWorkerDescriptor serviceWorker;
+  IPCServiceWorkerDescriptor serviceWorker;
 };
 
 struct ClientFocusArgs
 {
 };
 
 struct ClientNavigateArgs
 {
   ClientInfo target;
   nsCString url;
   nsCString baseURL;
 };
 
 union ClientEndPoint
 {
   ClientInfo;
-  ServiceWorkerDescriptor;
+  IPCServiceWorkerDescriptor;
 };
 
 struct ClientPostMessageArgs
 {
   ClonedMessageData clonedData;
   ClientEndPoint endpoint;
 };
 
@@ -99,17 +99,17 @@ struct ClientMatchAllArgs
   ClientEndPoint endpoint;
   ClientType type;
   bool includeUncontrolled;
   bool includeReserved;
 };
 
 struct ClientClaimArgs
 {
-  ServiceWorkerDescriptor serviceWorker;
+  IPCServiceWorkerDescriptor serviceWorker;
 };
 
 struct ClientGetInfoAndStateArgs
 {
   nsID id;
   PrincipalInfo principalInfo;
 };
 
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -290,17 +290,17 @@ ClientManagerService::MatchAll(const Cli
 {
   AssertIsOnBackgroundThread();
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
 
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TClientInfo
       ? endpoint.get_ClientInfo().principalInfo()
-      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+      : endpoint.get_ServiceWorkerDescriptor().PrincipalInfo();
 
   RefPtr<PromiseListHolder> promiseList =
     new PromiseListHolder(mBackgroundThread);
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
@@ -326,18 +326,18 @@ ClientManagerService::MatchAll(const Cli
         source->GetController();
       if (controller.isNothing()) {
         continue;
       }
 
       const ServiceWorkerDescriptor serviceWorker =
         endpoint.get_ServiceWorkerDescriptor();
 
-      if(controller.ref().id() != serviceWorker.id() ||
-         controller.ref().scope() != serviceWorker.scope()) {
+      if(controller.ref().ID() != serviceWorker.ID() ||
+         controller.ref().Scope() != serviceWorker.Scope()) {
         continue;
       }
     }
 
     if (!aArgs.includeReserved() && !source->ExecutionReady()) {
       continue;
     }
 
@@ -353,17 +353,17 @@ ClientManagerService::MatchAll(const Cli
 }
 
 already_AddRefed<ClientOpPromise>
 ClientManagerService::Claim(const ClientClaimArgs& aArgs)
 {
   AssertIsOnBackgroundThread();
 
   const ServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
-  const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
+  const PrincipalInfo& principalInfo = serviceWorker.PrincipalInfo();
 
   RefPtr<PromiseListHolder> promiseList =
     new PromiseListHolder(mBackgroundThread);
 
   for (ClientSourceParent* source : mSourceList) {
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -334,17 +334,17 @@ ClientSource::PostMessage(const ClientPo
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   RefPtr<ClientOpPromise> ref;
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TClientInfo
       ? endpoint.get_ClientInfo().principalInfo()
-      : endpoint.get_ServiceWorkerDescriptor().principalInfo();
+      : endpoint.get_ServiceWorkerDescriptor().PrincipalInfo();
 
   // TODO: this should probably not require strict spec matching
   if (false && !(mClientInfo.principalInfo() == principalInfo)) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
   StructuredCloneData clonedData;
@@ -443,19 +443,19 @@ ClientSource::PostMessage(const ClientPo
     // Shutting down. Just don't deliver this message.
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
   if (endpoint.type() == ClientEndPoint::TServiceWorkerDescriptor) {
     const ServiceWorkerDescriptor& swd = endpoint.get_ServiceWorkerDescriptor();
     RefPtr<ServiceWorkerRegistrationInfo> reg =
-      swm->GetRegistration(principal, swd.scope());
+      swm->GetRegistration(principal, swd.Scope());
     if (reg) {
-      RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(swd.id());
+      RefPtr<ServiceWorkerInfo> serviceWorker = reg->GetByID(swd.ID());
       if (serviceWorker) {
         init.mSource.SetValue().SetAsServiceWorker() =
           serviceWorker->GetOrCreateInstance(GetInnerWindow());
       }
     }
   }
 
   // Eventually we should expose Client in MessageEvent.source.
diff --git a/dom/workers/ServiceWorkerDescriptor.ipdlh b/dom/workers/IPCServiceWorkerDescriptor.ipdlh
rename from dom/workers/ServiceWorkerDescriptor.ipdlh
rename to dom/workers/IPCServiceWorkerDescriptor.ipdlh
--- a/dom/workers/ServiceWorkerDescriptor.ipdlh
+++ b/dom/workers/IPCServiceWorkerDescriptor.ipdlh
@@ -7,17 +7,17 @@ include PBackgroundSharedTypes;
 using ServiceWorkerState from "mozilla/dom/ServiceWorkerIPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 
 // IPC type with enough information to create a ServiceWorker DOM object
 // in a child process.  Today this just includes data require to look
 // up the ServiceWorkerInfo from the ServiceWorkerManager.
-struct ServiceWorkerDescriptor
+struct IPCServiceWorkerDescriptor
 {
   uint64_t id;
   PrincipalInfo principalInfo;
   nsCString scope;
   ServiceWorkerState state;
 };
 
 } // namespace dom
diff --git a/dom/workers/ServiceWorkerIPCUtils.h b/dom/workers/ServiceWorkerIPCUtils.h
--- a/dom/workers/ServiceWorkerIPCUtils.h
+++ b/dom/workers/ServiceWorkerIPCUtils.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ServiceWorkerIPCUtils_h
 #define _mozilla_dom_ServiceWorkerIPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozilla/dom/ServiceWorkerBinding.h"
 
 namespace IPC {
+
   template<>
   struct ParamTraits<mozilla::dom::ServiceWorkerState> :
     public ContiguousEnumSerializer<mozilla::dom::ServiceWorkerState,
                                     mozilla::dom::ServiceWorkerState::Installing,
                                     mozilla::dom::ServiceWorkerState::EndGuard_>
   {};
 
 } // namespace IPC
diff --git a/dom/workers/ServiceWorkerInfo.h b/dom/workers/ServiceWorkerInfo.h
--- a/dom/workers/ServiceWorkerInfo.h
+++ b/dom/workers/ServiceWorkerInfo.h
@@ -88,17 +88,17 @@ public:
   ScriptSpec() const
   {
     return mScriptSpec;
   }
 
   const nsCString&
   Scope() const
   {
-    return mDescriptor.scope();
+    return mDescriptor.Scope();
   }
 
   bool SkipWaitingFlag() const
   {
     AssertIsOnMainThread();
     return mSkipWaitingFlag;
   }
 
@@ -136,17 +136,17 @@ public:
   GetLoadFlags() const
   {
     return mLoadFlags;
   }
 
   uint64_t
   ID() const
   {
-    return mDescriptor.id();
+    return mDescriptor.ID();
   }
 
   const ServiceWorkerDescriptor&
   Descriptor() const
   {
     return mDescriptor;
   }
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2908,17 +2908,17 @@ ServiceWorkerManager::GetDocumentControl
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(principal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(scopeKey, controller.ref().scope());
+    GetRegistration(scopeKey, controller.ref().Scope());
   if (NS_WARN_IF(!registration)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   RefPtr<ServiceWorkerInfo> active = registration->GetActive();
   if (NS_WARN_IF(!active) ||
       NS_WARN_IF(!(active->Descriptor() == controller.ref()))) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
@@ -3426,24 +3426,24 @@ ServiceWorkerManager::MaybeClaimClient(n
 
 already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
                                        const ServiceWorkerDescriptor& aServiceWorker)
 {
   RefPtr<GenericPromise> ref;
 
   nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(aServiceWorker.principalInfo());
+    PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
   if (!principal) {
     ref = GenericPromise::CreateAndResolve(false, __func__);
     return ref.forget();
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetRegistration(principal, aServiceWorker.scope());
+    GetRegistration(principal, aServiceWorker.Scope());
   if (!registration) {
     ref = GenericPromise::CreateAndResolve(false, __func__);
     return ref.forget();
   }
 
   ref = MaybeClaimClient(aDoc, registration);
   return ref.forget();
 }
diff --git a/dom/workers/ServiceWorkerManagerService.h b/dom/workers/ServiceWorkerManagerService.h
--- a/dom/workers/ServiceWorkerManagerService.h
+++ b/dom/workers/ServiceWorkerManagerService.h
@@ -5,16 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_ServiceWorkerManagerService_h
 #define mozilla_dom_ServiceWorkerManagerService_h
 
 #include "nsISupportsImpl.h"
 #include "nsHashKeys.h"
 #include "nsTHashtable.h"
+#include "nsTArray.h"
 
 namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -519,23 +519,23 @@ public:
   WindowID() const
   {
     return mLoadInfo.mWindowID;
   }
 
   uint64_t
   ServiceWorkerID() const
   {
-    return GetServiceWorkerDescriptor().id();
+    return GetServiceWorkerDescriptor().ID();
   }
 
   const nsCString&
   ServiceWorkerScope() const
   {
-    return GetServiceWorkerDescriptor().scope();
+    return GetServiceWorkerDescriptor().Scope();
   }
 
   nsIURI*
   GetBaseURI() const
   {
     AssertIsOnMainThread();
     return mLoadInfo.mBaseURI;
   }
@@ -566,17 +566,17 @@ public:
     return mLoadInfo.mServiceWorkerDescriptor.ref();
   }
 
   void
   UpdateServiceWorkerState(ServiceWorkerState aState)
   {
     MOZ_DIAGNOSTIC_ASSERT(IsServiceWorker());
     MOZ_DIAGNOSTIC_ASSERT(mLoadInfo.mServiceWorkerDescriptor.isSome());
-    mLoadInfo.mServiceWorkerDescriptor.ref().state() = aState;
+    mLoadInfo.mServiceWorkerDescriptor.ref().SetState(aState);
   }
 
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mLoadInfo.mChannelInfo;
   }
 
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -7,16 +7,17 @@
 with Files("**"):
     BUG_COMPONENT = ("Core", "DOM: Workers")
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
     'FileReaderSync.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
+    'ServiceWorkerDescriptor.h',
     'ServiceWorkerEvents.h',
     'ServiceWorkerIPCUtils.h',
     'ServiceWorkerRegistrar.h',
     'ServiceWorkerRegistration.h',
     'WorkerLocation.h',
     'WorkerNavigator.h',
     'WorkerPrefs.h',
     'WorkerPrivate.h',
@@ -52,16 +53,17 @@ UNIFIED_SOURCES += [
     'ChromeWorkerScope.cpp',
     'FileReaderSync.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
     'ServiceWorker.cpp',
     'ServiceWorkerContainer.cpp',
+    'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
@@ -83,19 +85,19 @@ UNIFIED_SOURCES += [
     'WorkerNavigator.cpp',
     'WorkerPrivate.cpp',
     'WorkerRunnable.cpp',
     'WorkerScope.cpp',
     'WorkerThread.cpp',
 ]
 
 IPDL_SOURCES += [
+    'IPCServiceWorkerDescriptor.ipdlh',
     'PServiceWorkerManager.ipdl',
     'PServiceWorkerUpdater.ipdl',
-    'ServiceWorkerDescriptor.ipdlh',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
     '/dom/base',
     '/dom/bindings',
