# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  548cd4494d48d9bc4a96faf8ecf9faa89f534e4e

diff --git a/dom/serviceworkers/ServiceWorkerProxy.cpp b/dom/serviceworkers/ServiceWorkerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerProxy.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerProxy.h"
 
 #include "mozilla/ipc/BackgroundParent.h"
+#include "ServiceWorkerInfo.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
 ServiceWorkerProxy::~ServiceWorkerProxy()
 {
@@ -26,34 +27,21 @@ ServiceWorkerProxy::MaybeShutdownOnBGThr
   AssertIsOnBackgroundThread();
   if (!mActor) {
     return;
   }
   mActor->MaybeSendDelete();
 }
 
 void
-ServiceWorkerProxy::SetStateOnBGThread(ServiceWorkerState aState)
-{
-  AssertIsOnBackgroundThread();
-  if (!mActor) {
-    return;
-  }
-  Unused << mActor->SendSetState(aState);
-}
-
-void
 ServiceWorkerProxy::InitOnMainThread()
 {
   AssertIsOnMainThread();
 
   auto scopeExit = MakeScopeExit([&] {
-    // If we can't find the service worker, then move the binding object
-    // to the redundant state automatically.
-    SetState(ServiceWorkerState::Redundant);
     MaybeShutdownOnMainThread();
   });
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   NS_ENSURE_TRUE_VOID(swm);
 
   RefPtr<ServiceWorkerRegistrationInfo> reg =
     swm->GetRegistration(mDescriptor.PrincipalInfo(), mDescriptor.Scope());
@@ -61,20 +49,16 @@ ServiceWorkerProxy::InitOnMainThread()
 
   RefPtr<ServiceWorkerInfo> info = reg->GetByDescriptor(mDescriptor);
   NS_ENSURE_TRUE_VOID(info);
 
   scopeExit.release();
 
   mInfo = new nsMainThreadPtrHolder<ServiceWorkerInfo>("ServiceWorkerProxy::mInfo",
                                                        info);
-
-  // The ServiceWorkerInfo will automatically update our state when we
-  // add ourself as a listener.
-  mInfo->AddListener(this);
 }
 
 void
 ServiceWorkerProxy::MaybeShutdownOnMainThread()
 {
   AssertIsOnMainThread();
 
   nsCOMPtr<nsIRunnable> r =
@@ -83,43 +67,19 @@ ServiceWorkerProxy::MaybeShutdownOnMainT
 
   MOZ_ALWAYS_SUCCEEDS(mEventTarget->Dispatch(r.forget(), NS_DISPATCH_NORMAL));
 }
 
 void
 ServiceWorkerProxy::StopListeningOnMainThread()
 {
   AssertIsOnMainThread();
-
-  if (!mInfo) {
-    return;
-  }
-
-  mInfo->RemoveListener(this);
   mInfo = nullptr;
 }
 
-void
-ServiceWorkerProxy::SetState(ServiceWorkerState aState)
-{
-  AssertIsOnMainThread();
-
-  if (mDescriptor.State() == aState) {
-    return;
-  }
-  mDescriptor.SetState(aState);
-
-  nsCOMPtr<nsIRunnable> r =
-    NewRunnableMethod<ServiceWorkerState>(__func__, this,
-                                          &ServiceWorkerProxy::SetStateOnBGThread,
-                                          aState);
-
-  MOZ_ALWAYS_SUCCEEDS(mEventTarget->Dispatch(r.forget(), NS_DISPATCH_NORMAL));
-}
-
 ServiceWorkerProxy::ServiceWorkerProxy(const ServiceWorkerDescriptor& aDescriptor)
   : mActor(nullptr)
   , mEventTarget(GetCurrentThreadSerialEventTarget())
   , mDescriptor(aDescriptor)
 {
 }
 
 void
diff --git a/dom/serviceworkers/ServiceWorkerProxy.h b/dom/serviceworkers/ServiceWorkerProxy.h
--- a/dom/serviceworkers/ServiceWorkerProxy.h
+++ b/dom/serviceworkers/ServiceWorkerProxy.h
@@ -4,29 +4,28 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef moz_dom_ServiceWorkerProxy_h
 #define moz_dom_ServiceWorkerProxy_h
 
 #include "nsProxyRelease.h"
 #include "ServiceWorkerDescriptor.h"
-#include "ServiceWorkerInfo.h"
 
 namespace mozilla {
 namespace dom {
 
 namespace ipc {
 class StructuredCloneData;
 } // namespace ipc
 
 class ServiceWorkerInfo;
 class ServiceWorkerParent;
 
-class ServiceWorkerProxy final : public ServiceWorkerInfo::Listener
+class ServiceWorkerProxy final
 {
   // Background thread only
   ServiceWorkerParent* mActor;
 
   // Written on background thread and read on main thread
   nsCOMPtr<nsISerialEventTarget> mEventTarget;
 
   // Main thread only
@@ -47,33 +46,29 @@ class ServiceWorkerProxy final : public 
   InitOnMainThread();
 
   void
   MaybeShutdownOnMainThread();
 
   void
   StopListeningOnMainThread();
 
-  // ServiceWorkerInfo::Listener interface
-  void
-  SetState(ServiceWorkerState aState) override;
-
 public:
   explicit ServiceWorkerProxy(const ServiceWorkerDescriptor& aDescriptor);
 
   void
   Init(ServiceWorkerParent* aActor);
 
   void
   RevokeActor(ServiceWorkerParent* aActor);
 
   void
   PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aState);
 
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerProxy, override);
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerProxy);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // moz_dom_ServiceWorkerProxy_h
