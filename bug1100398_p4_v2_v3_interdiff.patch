# HG changeset patch
# Parent 82c608592b3a67f11dcf961b25adfab201f5f2f8
# User Ben Kelly <ben@wanderview.com>
Bug 1100398 P4 v2 to v3 interdiff.

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -112,44 +112,36 @@ struct nsPipeReadState
 class nsPipeInputStream
   : public nsIAsyncInputStream
   , public nsISeekableStream
   , public nsISearchableInputStream
   , public nsICloneableInputStream
   , public nsIClassInfo
 {
 public:
-  // since this class will be allocated as a member of the pipe, we do not
-  // need our own ref count.  instead, we share the lifetime (the ref count)
-  // of the entire pipe.  this macro is just convenience since it does not
-  // declare a mRefCount variable; however, don't let the name fool you...
-  // we are not inheriting from nsPipe ;-)
-  NS_DECL_ISUPPORTS_INHERITED
-
+  NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
   NS_DECL_NSIASYNCINPUTSTREAM
   NS_DECL_NSISEEKABLESTREAM
   NS_DECL_NSISEARCHABLEINPUTSTREAM
   NS_DECL_NSICLONEABLEINPUTSTREAM
   NS_DECL_NSICLASSINFO
 
   explicit nsPipeInputStream(nsPipe* aPipe)
     : mPipe(aPipe)
-    , mReaderRefCnt(0)
     , mLogicalOffset(0)
     , mBlocking(true)
     , mClosed(false)
     , mBlocked(false)
     , mAvailable(0)
     , mCallbackFlags(0)
   { }
 
   explicit nsPipeInputStream(const nsPipeInputStream& aOther)
     : mPipe(aOther.mPipe)
-    , mReaderRefCnt(0)
     , mLogicalOffset(aOther.mLogicalOffset)
     , mBlocking(aOther.mBlocking)
     , mClosed(aOther.mClosed)
     , mBlocked(false)
     , mAvailable(aOther.mAvailable)
     , mCallbackFlags(0)
     , mReadState(aOther.mReadState)
   { }
@@ -179,20 +171,20 @@ public:
   }
 
   const nsPipeReadState& ReadState() const
   {
     return mReadState;
   }
 
 private:
-  nsPipe*                        mPipe;
+  virtual ~nsPipeInputStream();
 
-  // separate refcnt so that we know when to close the consumer
-  mozilla::ThreadSafeAutoRefCnt  mReaderRefCnt;
+  nsRefPtr<nsPipe>               mPipe;
+
   int64_t                        mLogicalOffset;
   bool                           mBlocking;
   bool                           mClosed;
 
   // these variables can only be accessed while inside the pipe's monitor
   bool                           mBlocked;
   uint32_t                       mAvailable;
   nsCOMPtr<nsIInputStreamCallback> mCallback;
@@ -314,19 +306,25 @@ protected:
   void UpdateAllReadCursors(char* aWriteCursor);
   void ValidateAllReadCursors();
 
   // We can't inherit from both nsIInputStream and nsIOutputStream
   // because they collide on their Close method. Consequently we nest their
   // implementations to avoid the extra object allocation.
   nsPipeOutputStream  mOutput;
 
-  // Since the input stream can be cloned, we may have more than one.  There
-  // will always be at least one stream in this list.
-  nsTArray<nsRefPtr<nsPipeInputStream>> mInputList;
+  // Since the input stream can be cloned, we may have more than one.  Use
+  // a weak reference as the streams will clear their entry here in their
+  // destructor.  Using a strong reference would create a reference cycle.
+  nsTArray<nsPipeInputStream*> mInputList;
+
+  // But hold a strong ref to our original input stream.  For backward
+  // compatibility we need to be able to consistently return this same
+  // object from GetInputStream().
+  nsRefPtr<nsPipeInputStream> mOriginalInput;
 
   ReentrantMonitor    mReentrantMonitor;
   nsSegmentedBuffer   mBuffer;
 
   int32_t             mWriteSegment;
   char*               mWriteCursor;
   char*               mWriteLimit;
 
@@ -374,31 +372,50 @@ protected:
 //
 
 //-----------------------------------------------------------------------------
 // nsPipe methods:
 //-----------------------------------------------------------------------------
 
 nsPipe::nsPipe()
   : mOutput(MOZ_THIS_IN_INITIALIZER_LIST())
+  , mOriginalInput(new nsPipeInputStream(MOZ_THIS_IN_INITIALIZER_LIST()))
   , mReentrantMonitor("nsPipe.mReentrantMonitor")
   , mWriteSegment(-1)
   , mWriteCursor(nullptr)
   , mWriteLimit(nullptr)
   , mStatus(NS_OK)
   , mInited(false)
 {
-  mInputList.AppendElement(new nsPipeInputStream(this));
+  mInputList.AppendElement(mOriginalInput);
 }
 
 nsPipe::~nsPipe()
 {
 }
 
-NS_IMPL_ISUPPORTS(nsPipe, nsIPipe)
+NS_IMPL_ADDREF(nsPipe)
+NS_IMPL_QUERY_INTERFACE(nsPipe, nsIPipe)
+
+NS_IMETHODIMP_(MozExternalRefCountType)
+nsPipe::Release()
+{
+  MOZ_ASSERT(int32_t(mRefCnt) > 0, "dup release");
+  nsrefcnt count = --mRefCnt;
+  NS_LOG_RELEASE(this, count, "nsPipe");
+  if (count == 0) {
+    delete (this);
+    return 0;
+  }
+  if (mOriginalInput && count == 1) {
+    mOriginalInput = nullptr;
+    return 1;
+  }
+  return count;
+}
 
 NS_IMETHODIMP
 nsPipe::Init(bool aNonBlockingIn,
              bool aNonBlockingOut,
              uint32_t aSegmentSize,
              uint32_t aSegmentCount)
 {
   mInited = true;
@@ -416,28 +433,26 @@ nsPipe::Init(bool aNonBlockingIn,
     aSegmentCount = maxCount;
   }
 
   nsresult rv = mBuffer.Init(aSegmentSize, aSegmentSize * aSegmentCount);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  MOZ_ASSERT(mInputList.Length() == 1);
-  mInputList[0]->SetNonBlocking(aNonBlockingIn);
+  mOutput.SetNonBlocking(aNonBlockingOut);
+  mOriginalInput->SetNonBlocking(aNonBlockingIn);
 
-  mOutput.SetNonBlocking(aNonBlockingOut);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPipe::GetInputStream(nsIAsyncInputStream** aInputStream)
 {
-  MOZ_ASSERT(mInputList.Length() > 0);
-  nsRefPtr<nsPipeInputStream> ref = mInputList[0];
+  nsRefPtr<nsPipeInputStream> ref = mOriginalInput;
   ref.forget(aInputStream);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsPipe::GetOutputStream(nsIAsyncOutputStream** aOutputStream)
 {
   if (NS_WARN_IF(!mInited)) {
@@ -646,17 +661,17 @@ nsPipe::AdvanceWriteCursor(uint32_t aByt
 void
 nsPipe::CloseInputStream(nsPipeInputStream* aStream, nsresult aReason)
 {
   nsPipeEvents events;
   {
     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 
     for (uint32_t i = 0; i < mInputList.Length(); ++i) {
-      if (mInputList[i].get() != aStream) {
+      if (mInputList[i] != aStream) {
         continue;
       }
 
       // If there are more input streams open, then simply notify
       // this stream, remove it from the list, and allow the remaining
       // streams to continue functioning
       if (mInputList.Length() > 1) {
         if (mInputList[i]->OnInputException(aReason, events)) {
@@ -665,16 +680,17 @@ nsPipe::CloseInputStream(nsPipeInputStre
         mInputList.RemoveElementAt(i);
         return;
       }
 
       // Otherwise, this is the last input stream being closed.  Since
       // there will be no way to get another open input stream, just
       // shut the whole pipe down.
       OnPipeException(aReason);
+      mInputList.RemoveElementAt(i);
       return;
     }
   }
 
   MOZ_ASSERT_UNREACHABLE("Closing unknown pipe stream!");
 }
 
 void
@@ -837,16 +853,19 @@ nsPipeEvents::~nsPipeEvents()
     mOutputStream = 0;
   }
 }
 
 //-----------------------------------------------------------------------------
 // nsPipeInputStream methods:
 //-----------------------------------------------------------------------------
 
+NS_IMPL_ADDREF(nsPipeInputStream);
+NS_IMPL_RELEASE(nsPipeInputStream);
+
 NS_IMPL_QUERY_INTERFACE(nsPipeInputStream,
                         nsIInputStream,
                         nsIAsyncInputStream,
                         nsISeekableStream,
                         nsISearchableInputStream,
                         nsICloneableInputStream,
                         nsIClassInfo)
 
@@ -917,32 +936,16 @@ nsPipeInputStream::OnInputException(nsre
     mCallbackFlags = 0;
   } else if (mBlocked) {
     result = true;
   }
 
   return result;
 }
 
-NS_IMETHODIMP_(MozExternalRefCountType)
-nsPipeInputStream::AddRef(void)
-{
-  ++mReaderRefCnt;
-  return mPipe->AddRef();
-}
-
-NS_IMETHODIMP_(MozExternalRefCountType)
-nsPipeInputStream::Release(void)
-{
-  if (--mReaderRefCnt == 0) {
-    Close();
-  }
-  return mPipe->Release();
-}
-
 NS_IMETHODIMP
 nsPipeInputStream::CloseWithStatus(nsresult aReason)
 {
   LOG(("III CloseWithStatus [this=%x reason=%x]\n", this, aReason));
 
   if (mClosed) {
     return NS_OK;
   }
@@ -964,16 +967,18 @@ nsPipeInputStream::Close()
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::Available(uint64_t* aResult)
 {
   // nsPipeInputStream supports under 4GB stream only
   ReentrantMonitorAutoEnter mon(mPipe->mReentrantMonitor);
 
+  // TODO: check per-stream status
+
   // return error if pipe closed
   if (!mAvailable && NS_FAILED(mPipe->mStatus)) {
     return mPipe->mStatus;
   }
 
   *aResult = (uint64_t)mAvailable;
   return NS_OK;
 }
@@ -986,16 +991,18 @@ nsPipeInputStream::ReadSegments(nsWriteS
 {
   LOG(("III ReadSegments [this=%x count=%u]\n", this, aCount));
 
   nsresult rv = NS_OK;
 
   const char* segment;
   uint32_t segmentLen;
 
+  // TODO: check per-stream status
+
   *aReadCount = 0;
   while (aCount) {
     rv = mPipe->GetReadSegment(mReadState, segment, segmentLen);
     if (NS_FAILED(rv)) {
       // ignore this error if we've already read something.
       if (*aReadCount > 0) {
         rv = NS_OK;
         break;
@@ -1089,16 +1096,18 @@ nsPipeInputStream::AsyncWait(nsIInputStr
     }
 
     nsCOMPtr<nsIInputStreamCallback> proxy;
     if (aTarget) {
       proxy = NS_NewInputStreamReadyEvent(aCallback, aTarget);
       aCallback = proxy;
     }
 
+    // TODO: check per-stream status
+
     if (NS_FAILED(mPipe->mStatus) ||
         (mAvailable && !(aFlags & WAIT_CLOSURE_ONLY))) {
       // stream is already closed or readable; post event.
       pipeEvents.NotifyInputReady(this, aCallback);
     } else {
       // queue up callback object to be notified when data becomes available
       mCallback = aCallback;
       mCallbackFlags = aFlags;
@@ -1114,16 +1123,18 @@ nsPipeInputStream::Seek(int32_t aWhence,
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::Tell(int64_t* aOffset)
 {
   ReentrantMonitorAutoEnter mon(mPipe->mReentrantMonitor);
 
+  // TODO: check per-stream status
+
   // return error if pipe closed
   if (!mAvailable && NS_FAILED(mPipe->mStatus)) {
     return mPipe->mStatus;
   }
 
   *aOffset = mLogicalOffset;
   return NS_OK;
 }
@@ -1226,16 +1237,21 @@ nsPipeInputStream::GetCloneable(bool* aC
 }
 
 NS_IMETHODIMP
 nsPipeInputStream::Clone(nsIInputStream** aCloneOut)
 {
   return mPipe->CloneInputStream(this, aCloneOut);
 }
 
+nsPipeInputStream::~nsPipeInputStream()
+{
+  Close();
+}
+
 //-----------------------------------------------------------------------------
 // nsPipeOutputStream methods:
 //-----------------------------------------------------------------------------
 
 NS_IMPL_QUERY_INTERFACE(nsPipeOutputStream,
                         nsIOutputStream,
                         nsIAsyncOutputStream,
                         nsIClassInfo)
