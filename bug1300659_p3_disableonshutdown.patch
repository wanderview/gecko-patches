# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  013b2af51e108dce8bd6435b0f0fbf5015c2a2b2
Bug 1300659 P3 Don't create new window MainThreadTaskQueue objects after xpcom-shutdown. r=bz

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -271,16 +271,17 @@ using mozilla::TimeStamp;
 using mozilla::TimeDuration;
 using mozilla::dom::cache::CacheStorage;
 
 static LazyLogModule gDOMLeakPRLog("DOMLeak");
 
 nsGlobalWindow::WindowByIdTable *nsGlobalWindow::sWindowsById = nullptr;
 bool nsGlobalWindow::sWarnedAboutWindowInternal = false;
 bool nsGlobalWindow::sIdleObserversAPIFuzzTimeDisabled = false;
+bool nsGlobalWindow::sXPCOMShutdown = false;
 
 static int32_t              gRefCnt                    = 0;
 static int32_t              gOpenPopupSpamCount        = 0;
 static PopupControlState    gPopupControlState         = openAbused;
 static int32_t              gRunningTimeoutDepth       = 0;
 static bool                 gMouseDown                 = false;
 static bool                 gDragServiceDisabled       = false;
 static FILE                *gDumpFile                  = nullptr;
@@ -1526,16 +1527,17 @@ nsGlobalWindow::CleanUp()
 
   DisconnectEventTargetObjects();
 
   if (mObserver) {
     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
     if (os) {
       os->RemoveObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC);
       os->RemoveObserver(mObserver, "dom-storage2-changed");
+      os->RemoveObserver(mObserver, "xpcom-shutdown");
     }
 
 #ifdef MOZ_B2G
     DisableNetworkEvent(eNetworkUpload);
     DisableNetworkEvent(eNetworkDownload);
 #endif // MOZ_B2G
 
     if (mIdleService) {
@@ -3594,17 +3596,18 @@ nsGlobalWindow::MaybeCreateMainThreadTas
   MOZ_ASSERT(!mMainThreadTaskQueue);
 
   // For now we do not throttle events on chrome windows.  This is for a couple
   // reasons. First, we may not want to throttle chrome events since they should
   // be well behaved and we want to maximize throughput of these events.  Second,
   // it makes it hard to clean up the final top level chrome window during shutdown
   // if it has a TaskQueue with more runnables in it.  We could solve this in
   // the future, though.
-  if (GetPrincipal() == nsContentUtils::GetSystemPrincipal()) {
+  if (sXPCOMShutdown ||
+      GetPrincipal() == nsContentUtils::GetSystemPrincipal()) {
     return;
   }
 
   nsCOMPtr<nsIEventTarget> target;
 
   nsCOMPtr<nsPIDOMWindowOuter> parent = GetParent();
   if (parent) {
     target = parent->GetMainThreadTaskQueue();
@@ -11684,16 +11687,17 @@ nsGlobalWindow::Observe(nsISupports* aSu
     event->InitEvent(NS_LITERAL_STRING("languagechange"), false, false);
     event->SetTrusted(true);
 
     bool dummy;
     return DispatchEvent(event, &dummy);
   }
 
   if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
+    sXPCOMShutdown = true;
     MaybeShutdownMainThreadTaskQueue();
     return NS_OK;
   }
 
   NS_WARNING("unrecognized topic in nsGlobalWindow::Observe");
   return NS_ERROR_FAILURE;
 }
 
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1942,16 +1942,17 @@ protected:
 
   friend class nsDOMScriptableHelper;
   friend class nsDOMWindowUtils;
   friend class mozilla::dom::PostMessageEvent;
   friend class DesktopNotification;
 
   static WindowByIdTable* sWindowsById;
   static bool sWarnedAboutWindowInternal;
+  static bool sXPCOMShutdown;
 };
 
 inline nsISupports*
 ToSupports(nsGlobalWindow *p)
 {
     return static_cast<nsIDOMEventTarget*>(p);
 }
 
