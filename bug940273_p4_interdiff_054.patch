# HG changeset patch
# Parent 92fc5df8b5a46026e0738ffa51acef56120ac65f
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P4 interdiff 054 make promise hold dom objects alive


diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -511,32 +511,54 @@ Cache::GetGlobalObject() const
 #ifdef DEBUG
 void
 Cache::AssertOwningThread() const
 {
   NS_ASSERT_OWNINGTHREAD(Cache);
 }
 #endif
 
+void
+Cache::ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
+{
+  // Do nothing.  The Promise will automatically drop the ref to us after
+  // calling the callback.  This is what we want as we only registered in order
+  // to be held alive via the Promise handle.
+}
+
+void
+Cache::RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
+{
+  // Do nothing.  The Promise will automatically drop the ref to us after
+  // calling the callback.  This is what we want as we only registered in order
+  // to be held alive via the Promise handle.
+}
+
 Cache::~Cache()
 {
   if (mActor) {
     mActor->StartDestroy();
     // DestroyInternal() is called synchronously by StartDestroy().  So we
     // should have already cleared the mActor.
     MOZ_ASSERT(!mActor);
   }
 }
 
 RequestId
 Cache::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
 {
   MOZ_ASSERT(aPromise);
   MOZ_ASSERT(!mRequestPromises.Contains(aPromise));
 
+  // Register ourself as a promise handler so that the promise will hold us
+  // alive.  This allows the client code to drop the ref to the Cache
+  // object and just keep their promise.  This is fairly common in promise
+  // chaining code.
+  aPromise->AppendNativeHandler(this);
+
   mRequestPromises.AppendElement(aPromise);
 
   // (Ab)use the promise pointer as our request ID.  This is a fast, thread-safe
   // way to get a unique ID for the promise to be resolved later.
   return reinterpret_cast<RequestId>(aPromise);
 }
 
 already_AddRefed<Promise>
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Cache_h
 #define mozilla_dom_cache_Cache_h
 
+#include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
@@ -38,17 +39,17 @@ namespace cache {
 
 class CacheChild;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheResponseOrVoid;
 class PCacheStreamControlChild;
 
-class Cache MOZ_FINAL : public nsISupports
+class Cache MOZ_FINAL : public PromiseNativeHandler
                       , public nsWrapperCache
                       , public TypeUtils
 {
 public:
   Cache(nsIGlobalObject* aGlobal, CacheChild* aActor);
 
   // webidl interface methods
   already_AddRefed<Promise>
@@ -97,16 +98,23 @@ public:
   // TypeUtils methods
   virtual nsIGlobalObject*
   GetGlobalObject() const MOZ_OVERRIDE;
 
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
+  // PromiseNativeHandler methods
+  virtual void
+  ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) MOZ_OVERRIDE;
+
+  virtual void
+  RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) MOZ_OVERRIDE;
+
 private:
   ~Cache();
 
   // TODO: Replace with actor-per-request model during refactor (bug 1110485)
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
   already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
   nsCOMPtr<nsIGlobalObject> mGlobal;
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -502,16 +502,32 @@ CacheStorage::GetGlobalObject() const
 #ifdef DEBUG
 void
 CacheStorage::AssertOwningThread() const
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 }
 #endif
 
+void
+CacheStorage::ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
+{
+  // Do nothing.  The Promise will automatically drop the ref to us after
+  // calling the callback.  This is what we want as we only registered in order
+  // to be held alive via the Promise handle.
+}
+
+void
+CacheStorage::RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
+{
+  // Do nothing.  The Promise will automatically drop the ref to us after
+  // calling the callback.  This is what we want as we only registered in order
+  // to be held alive via the Promise handle.
+}
+
 CacheStorage::~CacheStorage()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   if (mActor) {
     mActor->StartDestroy();
     // DestroyInternal() is called synchronously by StartDestroy().  So we
     // should have already cleared the mActor.
@@ -571,16 +587,22 @@ CacheStorage::MaybeRunPendingRequests()
 
 RequestId
 CacheStorage::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(aPromise);
   MOZ_ASSERT(!mRequestPromises.Contains(aPromise));
 
+  // Register ourself as a promise handler so that the promise will hold us
+  // alive.  This allows the client code to drop the ref to the CacheStorage
+  // object and just keep their promise.  This is fairly common in promise
+  // chaining code.
+  aPromise->AppendNativeHandler(this);
+
   mRequestPromises.AppendElement(aPromise);
 
   // (Ab)use the promise pointer as our request ID.  This is a fast, thread-safe
   // way to get a unique ID for the promise to be resolved later.
   return reinterpret_cast<RequestId>(aPromise);
 }
 
 already_AddRefed<Promise>
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorage_h
 #define mozilla_dom_cache_CacheStorage_h
 
 #include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
@@ -42,16 +43,17 @@ class CacheChild;
 class CacheStorageChild;
 class Feature;
 class PCacheRequest;
 class PCacheResponseOrVoid;
 
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public TypeUtils
+                             , public PromiseNativeHandler
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
   static already_AddRefed<CacheStorage>
   CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal, ErrorResult& aRv);
 
@@ -86,22 +88,29 @@ public:
                          const PCacheResponseOrVoid& aResponse);
   void RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
                         CacheChild* aActor);
   void RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                         const nsTArray<nsString>& aKeys);
 
-  // TypeUtils method
+  // TypeUtils methods
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
+  // PromiseNativeHandler methods
+  virtual void
+  ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) MOZ_OVERRIDE;
+
+  virtual void
+  RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) MOZ_OVERRIDE;
+
 private:
   CacheStorage(Namespace aNamespace, nsIGlobalObject* aGlobal,
                const mozilla::ipc::PrincipalInfo& aPrincipalInfo, Feature* aFeature);
   ~CacheStorage();
 
   void MaybeRunPendingRequests();
 
   RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
@@ -140,16 +149,17 @@ private:
     nsString mKey;
   };
 
   nsTArray<Entry> mPendingRequests;
   bool mFailedActor;
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CacheStorage)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(CacheStorage,
+                                           nsIIPCBackgroundChildCreateCallback)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorage_h
