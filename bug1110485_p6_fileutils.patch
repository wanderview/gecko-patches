# HG changeset patch
# Parent 557897d5cdb082604e3dc832163af1b8151c7233
# User Ben Kelly <ben@wanderview.com>
Bug 1110485 P6 Replace useless cache::FileUtils type with cache::file namespace. r=ehsan


diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -165,17 +165,17 @@ DBAction::OpenConnection(const QuotaInfo
 
 nsresult
 DBAction::WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir)
 {
   nsresult rv = aDBFile->Remove(false);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   // Delete the morgue as well.
-  rv = FileUtils::BodyDeleteDir(aDBDir);
+  rv = file::BodyDeleteDir(aDBDir);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 SyncDBAction::SyncDBAction(Mode aMode)
   : DBAction(aMode)
 {
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -14,25 +14,39 @@
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
+namespace file {
 
 using mozilla::dom::quota::FileInputStream;
 using mozilla::dom::quota::FileOutputStream;
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
-using mozilla::unused;
+
+namespace {
+
+enum BodyFileType
+{
+  BODY_FILE_FINAL,
+  BODY_FILE_TMP
+};
+
+nsresult
+BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+             nsIFile** aBodyFileOut);
+
+} // anonymous namespace
 
 // static
 nsresult
-FileUtils::BodyCreateDir(nsIFile* aBaseDir)
+BodyCreateDir(nsIFile* aBaseDir)
 {
   MOZ_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> aBodyDir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
@@ -44,17 +58,17 @@ FileUtils::BodyCreateDir(nsIFile* aBaseD
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyDeleteDir(nsIFile* aBaseDir)
+BodyDeleteDir(nsIFile* aBaseDir)
 {
   MOZ_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> aBodyDir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aBodyDir->Append(NS_LITERAL_STRING("morgue"));
@@ -67,18 +81,17 @@ FileUtils::BodyDeleteDir(nsIFile* aBaseD
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
-                           nsIFile** aCacheDirOut)
+BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId, nsIFile** aCacheDirOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aCacheDirOut);
 
   *aCacheDirOut = nullptr;
 
   nsresult rv = aBaseDir->Clone(aCacheDirOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -102,21 +115,21 @@ FileUtils::BodyGetCacheDir(nsIFile* aBas
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyStartWriteStream(const QuotaInfo& aQuotaInfo,
-                                nsIFile* aBaseDir, nsIInputStream* aSource,
-                                void* aClosure,
-                                nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
-                                nsISupports** aCopyContextOut)
+BodyStartWriteStream(const QuotaInfo& aQuotaInfo,
+                     nsIFile* aBaseDir, nsIInputStream* aSource,
+                     void* aClosure,
+                     nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                     nsISupports** aCopyContextOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aSource);
   MOZ_ASSERT(aClosure);
   MOZ_ASSERT(aCallback);
   MOZ_ASSERT(aIdOut);
   MOZ_ASSERT(aCopyContextOut);
 
@@ -163,31 +176,31 @@ FileUtils::BodyStartWriteStream(const Qu
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 void
-FileUtils::BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext)
+BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aCopyContext);
 
   nsresult rv = NS_CancelAsyncCopy(aCopyContext, NS_ERROR_ABORT);
   unused << NS_WARN_IF(NS_FAILED(rv));
 
   // The partially written file must be cleaned up after the async copy
   // makes its callback.
 }
 
 // static
 nsresult
-FileUtils::BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
+BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId)
 {
   MOZ_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> tmpFile;
   nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_TMP, getter_AddRefs(tmpFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<nsIFile> finalFile;
@@ -201,18 +214,18 @@ FileUtils::BodyFinalizeWrite(nsIFile* aB
   rv = tmpFile->RenameTo(nullptr, finalFileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
-                    const nsID& aId, nsIInputStream** aStreamOut)
+BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
+         nsIInputStream** aStreamOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aStreamOut);
 
   nsCOMPtr<nsIFile> finalFile;
   nsresult rv = BodyIdToFile(aBaseDir, aId, BODY_FILE_FINAL,
                              getter_AddRefs(finalFile));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -229,17 +242,17 @@ FileUtils::BodyOpen(const QuotaInfo& aQu
 
   fileStream.forget(aStreamOut);
 
   return rv;
 }
 
 // static
 nsresult
-FileUtils::BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList)
+BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList)
 {
   nsresult rv = NS_OK;
 
   for (uint32_t i = 0; i < aIdList.Length(); ++i) {
     nsCOMPtr<nsIFile> tmpFile;
     rv = BodyIdToFile(aBaseDir, aIdList[i], BODY_FILE_TMP,
                       getter_AddRefs(tmpFile));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -268,20 +281,21 @@ FileUtils::BodyDeleteFiles(nsIFile* aBas
 
     // Again, only treat removal as hard failure in debug build.
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 
   return NS_OK;
 }
 
-// static
+namespace {
+
 nsresult
-FileUtils::BodyIdToFile(nsIFile* aBaseDir, const nsID& aId,
-                        BodyFileType aType, nsIFile** aBodyFileOut)
+BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
+             nsIFile** aBodyFileOut)
 {
   MOZ_ASSERT(aBaseDir);
   MOZ_ASSERT(aBodyFileOut);
 
   *aBodyFileOut = nullptr;
 
   nsresult rv = BodyGetCacheDir(aBaseDir, aId, aBodyFileOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -299,11 +313,14 @@ FileUtils::BodyIdToFile(nsIFile* aBaseDi
   }
 
   rv = (*aBodyFileOut)->Append(fileName);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
+} // anonymous namespace
+
+} // namespace file
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -13,60 +13,47 @@
 #include "nsTArrayForwardDeclare.h"
 
 struct nsID;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
+namespace file {
 
-// TODO: remove static class and use functions in cache namespace (bug 1110485)
-class FileUtils final
-{
-public:
-  enum BodyFileType
-  {
-    BODY_FILE_FINAL,
-    BODY_FILE_TMP
-  };
+nsresult
+BodyCreateDir(nsIFile* aBaseDir);
 
-  static nsresult BodyCreateDir(nsIFile* aBaseDir);
-  // Note that this function can only be used during the initialization of the
-  // database.  We're unlikely to be able to delete the DB successfully past
-  // that point due to the file being in use.
-  static nsresult BodyDeleteDir(nsIFile* aBaseDir);
-  static nsresult BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
-                                  nsIFile** aCacheDirOut);
+// Note that this function can only be used during the initialization of the
+// database.  We're unlikely to be able to delete the DB successfully past
+// that point due to the file being in use.
+nsresult
+BodyDeleteDir(nsIFile* aBaseDir);
 
-  static nsresult
-  BodyStartWriteStream(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
-                       nsIInputStream* aSource, void* aClosure,
-                       nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
-                       nsISupports** aCopyContextOut);
+nsresult
+BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId, nsIFile** aCacheDirOut);
 
-  static void
-  BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext);
+nsresult
+BodyStartWriteStream(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir,
+                     nsIInputStream* aSource, void* aClosure,
+                     nsAsyncCopyCallbackFun aCallback, nsID* aIdOut,
+                     nsISupports** aCopyContextOut);
 
-  static nsresult
-  BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
+void
+BodyCancelWrite(nsIFile* aBaseDir, nsISupports* aCopyContext);
 
-  static nsresult
-  BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
-           nsIInputStream** aStreamOut);
+nsresult
+BodyFinalizeWrite(nsIFile* aBaseDir, const nsID& aId);
 
-  static nsresult
-  BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
+nsresult
+BodyOpen(const QuotaInfo& aQuotaInfo, nsIFile* aBaseDir, const nsID& aId,
+         nsIInputStream** aStreamOut);
 
-private:
-  static nsresult
-  BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
-               nsIFile** aBodyFileOut);
+nsresult
+BodyDeleteFiles(nsIFile* aBaseDir, const nsTArray<nsID>& aIdList);
 
-  FileUtils() = delete;
-  ~FileUtils() = delete;
-};
-
+} // namespace file
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_FileUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -29,20 +29,21 @@
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
 #include "nsTObserverArray.h"
 
 namespace {
 
 using mozilla::unused;
 using mozilla::dom::cache::Action;
-using mozilla::dom::cache::FileUtils;
 using mozilla::dom::cache::QuotaInfo;
 using mozilla::dom::cache::SyncDBAction;
 using mozilla::dom::cache::db::CreateSchema;
+using mozilla::dom::cache::file::BodyCreateDir;
+using mozilla::dom::cache::file::BodyDeleteFiles;
 
 // An Action that is executed when a Context is first created.  It ensures that
 // the directory and database are setup properly.  This lets other actions
 // not worry about these details.
 class SetupAction final : public SyncDBAction
 {
 public:
   SetupAction()
@@ -54,17 +55,17 @@ public:
                         mozIStorageConnection* aConn) override
   {
     // TODO: init maintainance marker (bug 1110446)
     // TODO: perform maintainance if necessary (bug 1110446)
     // TODO: find orphaned caches in database (bug 1110446)
     // TODO: have Context create/delete marker files in constructor/destructor
     //       and only do expensive maintenance if that marker is present (bug 1110446)
 
-    nsresult rv = FileUtils::BodyCreateDir(aDBDir);
+    nsresult rv = BodyCreateDir(aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     mozStorageTransaction trans(aConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     rv = CreateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -108,17 +109,17 @@ public:
     }
 
     rv = dbDir->Append(NS_LITERAL_STRING("cache"));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
 
-    rv = FileUtils::BodyDeleteFiles(dbDir, mDeletedBodyIdList);
+    rv = BodyDeleteFiles(dbDir, mDeletedBodyIdList);
     unused << NS_WARN_IF(NS_FAILED(rv));
 
     aResolver->Resolve(rv);
   }
 
 private:
   nsTArray<nsID> mDeletedBodyIdList;
 };
@@ -503,18 +504,18 @@ public:
                                  mArgs.params(), &mFoundResponse, &mResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId,
-                             getter_AddRefs(stream));
+    rv = file::BodyOpen(aQuotaInfo, aDBDir, mResponse.mBodyId,
+                        getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mResponse.mBodyId, stream);
 
     return rv;
   }
 
@@ -567,19 +568,18 @@ public:
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     for (uint32_t i = 0; i < mSavedResponses.Length(); ++i) {
       if (!mSavedResponses[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
-                               mSavedResponses[i].mBodyId,
-                               getter_AddRefs(stream));
+      rv = file::BodyOpen(aQuotaInfo, aDBDir, mSavedResponses[i].mBodyId,
+                          getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedResponses[i].mBodyId, stream);
     }
 
     return rv;
   }
@@ -754,24 +754,24 @@ private:
 
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
 
     nsresult rv = NS_OK;
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       Entry& e = mList[i];
       if (e.mRequestStream) {
-        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mRequestBodyId);
+        rv = file::BodyFinalizeWrite(mDBDir, e.mRequestBodyId);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           DoResolve(rv);
           return;
         }
       }
       if (e.mResponseStream) {
-        rv = FileUtils::BodyFinalizeWrite(mDBDir, e.mResponseBodyId);
+        rv = file::BodyFinalizeWrite(mDBDir, e.mResponseBodyId);
         if (NS_WARN_IF(NS_FAILED(rv))) {
           DoResolve(rv);
           return;
         }
       }
 
       rv = db::CachePut(mConn, mCacheId, e.mRequest,
                         e.mRequestStream ? &e.mRequestBodyId : nullptr,
@@ -866,20 +866,19 @@ private:
     }
 
     if (!source) {
       return NS_OK;
     }
 
     nsCOMPtr<nsISupports> copyContext;
 
-    nsresult rv = FileUtils::BodyStartWriteStream(aQuotaInfo, mDBDir, source,
-                                                  this, AsyncCopyCompleteFunc,
-                                                  bodyId,
-                                                  getter_AddRefs(copyContext));
+    nsresult rv = file::BodyStartWriteStream(aQuotaInfo, mDBDir, source, this,
+                                             AsyncCopyCompleteFunc, bodyId,
+                                             getter_AddRefs(copyContext));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     mBodyIdWrittenList.AppendElement(*bodyId);
 
     if (copyContext) {
       MutexAutoLock lock(mMutex);
       mCopyContextList.AppendElement(copyContext);
     }
@@ -890,17 +889,17 @@ private:
   }
 
   void
   CancelAllStreamCopying()
   {
     // May occur on either owning thread or target thread
     MutexAutoLock lock(mMutex);
     for (uint32_t i = 0; i < mCopyContextList.Length(); ++i) {
-      FileUtils::BodyCancelWrite(mDBDir, mCopyContextList[i]);
+      file::BodyCancelWrite(mDBDir, mCopyContextList[i]);
     }
     mCopyContextList.Clear();
   }
 
   static void
   AsyncCopyCompleteFunc(void* aClosure, nsresult aRv)
   {
     // May be on any thread, including STS event target.
@@ -933,17 +932,17 @@ private:
     {
       MutexAutoLock lock(mMutex);
       MOZ_ASSERT(mCopyContextList.IsEmpty());
     }
 #endif
 
     // Clean up any files we might have written before hitting the error.
     if (NS_FAILED(aRv)) {
-      FileUtils::BodyDeleteFiles(mDBDir, mBodyIdWrittenList);
+      file::BodyDeleteFiles(mDBDir, mBodyIdWrittenList);
     }
 
     // Must be released on the target thread where it was opened.
     mConn = nullptr;
 
     // Drop our ref to the target thread as we are done with this thread.
     // Also makes our thread assertions catch any incorrect method calls
     // after resolve.
@@ -1058,19 +1057,18 @@ public:
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     for (uint32_t i = 0; i < mSavedRequests.Length(); ++i) {
       if (!mSavedRequests[i].mHasBodyId) {
         continue;
       }
 
       nsCOMPtr<nsIInputStream> stream;
-      rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir,
-                               mSavedRequests[i].mBodyId,
-                               getter_AddRefs(stream));
+      rv = file::BodyOpen(aQuotaInfo, aDBDir, mSavedRequests[i].mBodyId,
+                          getter_AddRefs(stream));
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
       mStreamList->Add(mSavedRequests[i].mBodyId, stream);
     }
 
     return rv;
   }
@@ -1121,18 +1119,18 @@ public:
                                    &mSavedResponse);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     if (!mFoundResponse || !mSavedResponse.mHasBodyId) {
       return rv;
     }
 
     nsCOMPtr<nsIInputStream> stream;
-    rv = FileUtils::BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
-                             getter_AddRefs(stream));
+    rv = file::BodyOpen(aQuotaInfo, aDBDir, mSavedResponse.mBodyId,
+                        getter_AddRefs(stream));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     if (NS_WARN_IF(!stream)) { return NS_ERROR_FILE_NOT_FOUND; }
 
     mStreamList->Add(mSavedResponse.mBodyId, stream);
 
     return rv;
   }
 
