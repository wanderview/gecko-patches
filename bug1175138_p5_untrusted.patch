# HG changeset patch
# Parent 1523f5db672ac24fb6db4d292a2ef2c9642b5f10
# User Ben Kelly <ben@wanderview.com>
Bug 1175138 P5 Make CacheStorage reject on untrusted origins. r=ehsan

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -10502,19 +10502,27 @@ nsGlobalWindow::GetInterface(JSContext* 
 {
   dom::GetInterface(aCx, this, aIID, aRetval, aError);
 }
 
 already_AddRefed<CacheStorage>
 nsGlobalWindow::GetCaches(ErrorResult& aRv)
 {
   if (!mCacheStorage) {
+    bool forceTrustedOrigin = false;
+    if (IsOuterWindow()) {
+      forceTrustedOrigin = GetServiceWorkersTestingEnabled();
+    } else {
+      nsRefPtr<nsGlobalWindow> outer = GetOuterWindowInternal();
+      forceTrustedOrigin = outer->GetServiceWorkersTestingEnabled();
+    }
     mCacheStorage = CacheStorage::CreateOnMainThread(cache::DEFAULT_NAMESPACE,
                                                      this, GetPrincipal(),
-                                                     IsPrivateBrowsing(), aRv);
+                                                     IsPrivateBrowsing(),
+                                                     forceTrustedOrigin, aRv);
   }
 
   nsRefPtr<CacheStorage> ref = mCacheStorage;
   return ref.forget();
 }
 
 void
 nsGlobalWindow::FireOfflineStatusEventIfChanged()
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "nsIDocument.h"
 #include "nsIGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsURLParsers.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ErrorResult;
@@ -57,64 +58,128 @@ struct CacheStorage::Entry final
 {
   nsRefPtr<Promise> mPromise;
   CacheOpArgs mArgs;
   // We cannot add the requests until after the actor is present.  So store
   // the request data separately for now.
   nsRefPtr<InternalRequest> mRequest;
 };
 
+namespace {
+
+bool
+IsTrusted(const PrincipalInfo& aPrincipalInfo, bool aTestingPrefEnabled)
+{
+  // Can happen on main thread or worker thread
+
+  if (aPrincipalInfo.type() == PrincipalInfo::TSystemPrincipalInfo) {
+    return true;
+  }
+
+  // Require a ContentPrincipal to avoid null principal, etc.
+  //
+  // Also, an unknown appId means that this principal was created for the
+  // codebase without all the security information from the end document or
+  // worker.  We require exact knowledge of this information before allowing
+  // the caller to touch the disk using the Cache API.
+  if (NS_WARN_IF(aPrincipalInfo.type() != PrincipalInfo::TContentPrincipalInfo ||
+                 aPrincipalInfo.get_ContentPrincipalInfo().appId() ==
+                 nsIScriptSecurityManager::UNKNOWN_APP_ID)) {
+    return false;
+  }
+
+  // If we're in testing mode, then don't do any more work to determing if
+  // the origin is trusted.  We have to run some tests as http.
+  if (aTestingPrefEnabled) {
+    return true;
+  }
+
+  // Now parse the scheme of the principal's origin.  This is a short term
+  // method for determining "trust".  In the long term we need to implement
+  // the full algorithm here:
+  //
+  // https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-secure
+  //
+  // TODO: Implement full secure setting algorithm. (bug 1177856)
+
+  const nsCString& flatURL = aPrincipalInfo.get_ContentPrincipalInfo().spec();
+  const char* url = flatURL.get();
+
+  // off the main thread URL parsing using nsStdURLParser.
+  nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
+
+  uint32_t schemePos;
+  int32_t schemeLen;
+  uint32_t authPos;
+  int32_t authLen;
+  nsresult rv = urlParser->ParseURL(url, flatURL.Length(),
+                                    &schemePos, &schemeLen,
+                                    &authPos, &authLen,
+                                    nullptr, nullptr);      // ignore path
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  nsAutoCString scheme(Substring(flatURL, schemePos, schemeLen));
+  if (scheme.LowerCaseEqualsLiteral("https") ||
+      scheme.LowerCaseEqualsLiteral("app") ||
+      scheme.LowerCaseEqualsLiteral("file")) {
+    return true;
+  }
+
+  uint32_t hostPos;
+  int32_t hostLen;
+
+  rv = urlParser->ParseAuthority(url + authPos, authLen,
+                                 nullptr, nullptr,          // ignore username
+                                 nullptr, nullptr,          // ignore password
+                                 &hostPos, &hostLen,
+                                 nullptr);                  // ignore port
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  nsDependentCSubstring hostname(url + authPos + hostPos, hostLen);
+
+  return hostname.EqualsLiteral("localhost") ||
+         hostname.EqualsLiteral("127.0.0.1") ||
+         hostname.EqualsLiteral("::1");
+}
+
+} // anonymous namespace
+
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                                  nsIPrincipal* aPrincipal, bool aPrivateBrowsing,
-                                 ErrorResult& aRv)
+                                 bool aForceTrustedOrigin, ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   if (aPrivateBrowsing) {
     NS_WARNING("CacheStorage not supported during private browsing.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  bool nullPrincipal;
-  nsresult rv = aPrincipal->GetIsNullPrincipal(&nullPrincipal);
+  PrincipalInfo principalInfo;
+  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aRv.Throw(rv);
     return nullptr;
   }
 
-  if (nullPrincipal) {
-    NS_WARNING("CacheStorage not supported on null principal.");
+  bool testingEnabled = aForceTrustedOrigin ||
+    Preferences::GetBool("dom.caches.testing.enabled", false) ||
+    Preferences::GetBool("dom.serviceWorkers.testing.enabled", false);
+
+  if (!IsTrusted(principalInfo, testingEnabled)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  // An unknown appId means that this principal was created for the codebase
-  // without all the security information from the end document or worker.
-  // We require exact knowledge of this information before allowing the
-  // caller to touch the disk using the Cache API.
-  bool unknownAppId = false;
-  aPrincipal->GetUnknownAppId(&unknownAppId);
-  if (unknownAppId) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
-
-  PrincipalInfo principalInfo;
-  rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
-    return nullptr;
-  }
-
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, nullptr);
   return ref.forget();
 }
 
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
@@ -133,26 +198,23 @@ CacheStorage::CreateOnWorker(Namespace a
   nsRefPtr<Feature> feature = Feature::Create(aWorkerPrivate);
   if (!feature) {
     NS_WARNING("Worker thread is shutting down.");
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
-  if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
-    NS_WARNING("CacheStorage not supported on null principal.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
 
-  if (principalInfo.type() == PrincipalInfo::TContentPrincipalInfo &&
-      principalInfo.get_ContentPrincipalInfo().appId() ==
-      nsIScriptSecurityManager::UNKNOWN_APP_ID) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
+  bool testingEnabled = aWorkerPrivate->DOMCachesTestingEnabled() ||
+                        aWorkerPrivate->ServiceWorkersTestingEnabled() ||
+                        aWorkerPrivate->ServiceWorkersTestingInWindow();
+
+  if (!IsTrusted(principalInfo, testingEnabled)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, feature);
   return ref.forget();
 }
@@ -363,17 +425,20 @@ CacheStorage::Constructor(const GlobalOb
   if (window) {
     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
     if (doc) {
       nsCOMPtr<nsILoadContext> loadContext = doc->GetLoadContext();
       privateBrowsing = loadContext && loadContext->UsePrivateBrowsing();
     }
   }
 
-  return CreateOnMainThread(ns, global, aPrincipal, privateBrowsing, aRv);
+  // Create a CacheStorage object bypassing the trusted origin checks
+  // since this is a chrome-only constructor.
+  return CreateOnMainThread(ns, global, aPrincipal, privateBrowsing,
+                            true /* force trusted origin */, aRv);
 }
 
 nsISupports*
 CacheStorage::GetParentObject() const
 {
   return mGlobal;
 }
 
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -45,17 +45,17 @@ class CacheStorage final : public nsIIPC
                          , public TypeUtils
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
   static already_AddRefed<CacheStorage>
   CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal, bool aPrivateBrowsing,
-                     ErrorResult& aRv);
+                     bool aForceTrustedOrigin, ErrorResult& aRv);
 
   static already_AddRefed<CacheStorage>
   CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
                  workers::WorkerPrivate* aWorkerPrivate, ErrorResult& aRv);
 
   // webidl interface methods
   already_AddRefed<Promise> Match(const RequestOrUSVString& aRequest,
                                   const CacheQueryOptions& aOptions,
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -1208,21 +1208,25 @@ CacheCreator::CreateCacheStorage(nsIPrin
 
   // If we're in private browsing mode, don't even try to create the
   // CacheStorage.  Instead, just fail immediately to terminate the
   // ServiceWorker load.
   if (NS_WARN_IF(mPrivateBrowsing)) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
+  // Create a CacheStorage bypassing its trusted origin checks.  The
+  // ServiceWorker has already performed its own checks before getting
+  // to this point.
   ErrorResult error;
   mCacheStorage =
     CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                      mSandboxGlobalObject,
                                      aPrincipal, mPrivateBrowsing,
+                                     true /* force trusted origin */,
                                      error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   return NS_OK;
 }
 
diff --git a/dom/workers/ServiceWorkerScriptCache.cpp b/dom/workers/ServiceWorkerScriptCache.cpp
--- a/dom/workers/ServiceWorkerScriptCache.cpp
+++ b/dom/workers/ServiceWorkerScriptCache.cpp
@@ -52,19 +52,25 @@ CreateCacheStorage(nsIPrincipal* aPrinci
     sandbox.forget(aHolder);
   }
 
   // We assume private browsing is not enabled here.  The ScriptLoader
   // explicitly fails for private browsing so there should never be
   // a service worker running in private browsing mode.  Therefore if
   // we are purging scripts or running a comparison algorithm we cannot
   // be in private browing.
+  //
+  // Also, bypass the CacheStorage trusted origin checks.  The ServiceWorker
+  // has validated the origin prior to this point.  All the information
+  // to revalidate is not available now.
   return CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                           sandboxGlobalObject, aPrincipal,
-                                          false /* private browsing */, aRv);
+                                          false /* private browsing */,
+                                          true /* force trusted origin */,
+                                          aRv);
 }
 
 class CompareManager;
 
 // This class downloads a URL from the network and then it calls
 // NetworkFinished() in the CompareManager.
 class CompareNetwork final : public nsIStreamLoaderObserver,
                              public nsIRequestObserver
