# HG changeset patch
# Parent 6add806d4fdf3e55f5e53fd894b8ab77a827e3fb
# User Ben Kelly <ben@wanderview.com>
Bug 1175138 P5 Make CacheStorage reject on untrusted origins. r=ehsan

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -10502,19 +10502,28 @@ nsGlobalWindow::GetInterface(JSContext* 
 {
   dom::GetInterface(aCx, this, aIID, aRetval, aError);
 }
 
 already_AddRefed<CacheStorage>
 nsGlobalWindow::GetCaches(ErrorResult& aRv)
 {
   if (!mCacheStorage) {
+    bool serviceWorkersTestingInWindow = false;
+    if (IsOuterWindow()) {
+      serviceWorkersTestingInWindow = GetServiceWorkersTestingEnabled();
+    } else {
+      nsRefPtr<nsGlobalWindow> outer = GetOuterWindowInternal();
+      serviceWorkersTestingInWindow = outer->GetServiceWorkersTestingEnabled();
+    }
     mCacheStorage = CacheStorage::CreateOnMainThread(cache::DEFAULT_NAMESPACE,
                                                      this, GetPrincipal(),
-                                                     IsPrivateBrowsing(), aRv);
+                                                     IsPrivateBrowsing(),
+                                                     serviceWorkersTestingInWindow,
+                                                     aRv);
   }
 
   nsRefPtr<CacheStorage> ref = mCacheStorage;
   return ref.forget();
 }
 
 void
 nsGlobalWindow::FireOfflineStatusEventIfChanged()
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/cache/TypeUtils.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "nsIDocument.h"
 #include "nsIGlobalObject.h"
 #include "nsIScriptSecurityManager.h"
+#include "nsURLParsers.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ErrorResult;
@@ -57,64 +58,129 @@ struct CacheStorage::Entry final
 {
   nsRefPtr<Promise> mPromise;
   CacheOpArgs mArgs;
   // We cannot add the requests until after the actor is present.  So store
   // the request data separately for now.
   nsRefPtr<InternalRequest> mRequest;
 };
 
+namespace {
+
+bool
+IsTrusted(const PrincipalInfo& aPrincipalInfo, bool aTestingPrefEnabled)
+{
+  // Can happen on main thread or worker thread
+
+  if (aPrincipalInfo.type() == PrincipalInfo::TSystemPrincipalInfo) {
+    return true;
+  }
+
+  // Require a ContentPrincipal to avoid null principal, etc.
+  //
+  // Also, an unknown appId means that this principal was created for the
+  // codebase without all the security information from the end document or
+  // worker.  We require exact knowledge of this information before allowing
+  // the caller to touch the disk using the Cache API.
+  if (NS_WARN_IF(aPrincipalInfo.type() != PrincipalInfo::TContentPrincipalInfo ||
+                 aPrincipalInfo.get_ContentPrincipalInfo().appId() ==
+                 nsIScriptSecurityManager::UNKNOWN_APP_ID)) {
+    return false;
+  }
+
+  // If we're in testing mode, then don't do any more work to determing if
+  // the origin is trusted.  We have to run some tests as http.
+  if (aTestingPrefEnabled) {
+    return true;
+  }
+
+  // Now parse the scheme of the principal's origin.  This is a short term
+  // method for determining "trust".  In the long term we need to implement
+  // the full algorithm here:
+  //
+  // https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-secure
+  //
+  // TODO: Implement full secure setting algorithm. (bug 1177856)
+
+  const nsCString& flatURL = aPrincipalInfo.get_ContentPrincipalInfo().spec();
+  const char* url = flatURL.get();
+
+  // off the main thread URL parsing using nsStdURLParser.
+  nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
+
+  uint32_t schemePos;
+  int32_t schemeLen;
+  uint32_t authPos;
+  int32_t authLen;
+  nsresult rv = urlParser->ParseURL(url, flatURL.Length(),
+                                    &schemePos, &schemeLen,
+                                    &authPos, &authLen,
+                                    nullptr, nullptr);      // ignore path
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  nsAutoCString scheme(Substring(flatURL, schemePos, schemeLen));
+  if (scheme.LowerCaseEqualsLiteral("https") ||
+      scheme.LowerCaseEqualsLiteral("app") ||
+      scheme.LowerCaseEqualsLiteral("file")) {
+    return true;
+  }
+
+  uint32_t hostPos;
+  int32_t hostLen;
+
+  rv = urlParser->ParseAuthority(url + authPos, authLen,
+                                 nullptr, nullptr,          // ignore username
+                                 nullptr, nullptr,          // ignore password
+                                 &hostPos, &hostLen,
+                                 nullptr);                  // ignore port
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  nsDependentCSubstring hostname(url + authPos + hostPos, hostLen);
+
+  return hostname.EqualsLiteral("localhost") ||
+         hostname.EqualsLiteral("127.0.0.1") ||
+         hostname.EqualsLiteral("::1");
+}
+
+} // anonymous namespace
+
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                                  nsIPrincipal* aPrincipal, bool aPrivateBrowsing,
+                                 bool aServiceWorkersTestingEnabledInWindow,
                                  ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   if (aPrivateBrowsing) {
     NS_WARNING("CacheStorage not supported during private browsing.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  bool nullPrincipal;
-  nsresult rv = aPrincipal->GetIsNullPrincipal(&nullPrincipal);
+  PrincipalInfo principalInfo;
+  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aRv.Throw(rv);
     return nullptr;
   }
 
-  if (nullPrincipal) {
-    NS_WARNING("CacheStorage not supported on null principal.");
+  bool testingEnabled = aServiceWorkersTestingEnabledInWindow ||
+    Preferences::GetBool("dom.caches.testing.enabled", false) ||
+    Preferences::GetBool("dom.serviceWorkers.testing.enabled", false);
+
+  if (!IsTrusted(principalInfo, testingEnabled)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
-  // An unknown appId means that this principal was created for the codebase
-  // without all the security information from the end document or worker.
-  // We require exact knowledge of this information before allowing the
-  // caller to touch the disk using the Cache API.
-  bool unknownAppId = false;
-  aPrincipal->GetUnknownAppId(&unknownAppId);
-  if (unknownAppId) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
-
-  PrincipalInfo principalInfo;
-  rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
-    return nullptr;
-  }
-
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, nullptr);
   return ref.forget();
 }
 
 // static
 already_AddRefed<CacheStorage>
 CacheStorage::CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
@@ -133,26 +199,23 @@ CacheStorage::CreateOnWorker(Namespace a
   nsRefPtr<Feature> feature = Feature::Create(aWorkerPrivate);
   if (!feature) {
     NS_WARNING("Worker thread is shutting down.");
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
-  if (principalInfo.type() == PrincipalInfo::TNullPrincipalInfo) {
-    NS_WARNING("CacheStorage not supported on null principal.");
-    nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
-    return ref.forget();
-  }
 
-  if (principalInfo.type() == PrincipalInfo::TContentPrincipalInfo &&
-      principalInfo.get_ContentPrincipalInfo().appId() ==
-      nsIScriptSecurityManager::UNKNOWN_APP_ID) {
-    NS_WARNING("CacheStorage not supported on principal with unknown appId.");
+  bool testingEnabled = aWorkerPrivate->DOMCachesTestingEnabled() ||
+                        aWorkerPrivate->ServiceWorkersTestingEnabled() ||
+                        aWorkerPrivate->ServiceWorkersTestingInWindow();
+
+  if (!IsTrusted(principalInfo, testingEnabled)) {
+    NS_WARNING("CacheStorage not supported on untrusted origins.");
     nsRefPtr<CacheStorage> ref = new CacheStorage(NS_ERROR_DOM_SECURITY_ERR);
     return ref.forget();
   }
 
   nsRefPtr<CacheStorage> ref = new CacheStorage(aNamespace, aGlobal,
                                                 principalInfo, feature);
   return ref.forget();
 }
@@ -354,26 +417,32 @@ CacheStorage::Constructor(const GlobalOb
                 "Chrome namespace should match webidl Chrome enum");
   static_assert(NUMBER_OF_NAMESPACES == (uint32_t)CacheStorageNamespace::EndGuard_,
                 "Number of namespace should match webidl endguard enum");
 
   Namespace ns = static_cast<Namespace>(aNamespace);
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aGlobal.GetAsSupports());
 
   bool privateBrowsing = false;
+  bool serviceWorkersTestingInWindow = false;
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(global);
   if (window) {
     nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
     if (doc) {
       nsCOMPtr<nsILoadContext> loadContext = doc->GetLoadContext();
       privateBrowsing = loadContext && loadContext->UsePrivateBrowsing();
     }
+    nsCOMPtr<nsPIDOMWindow> outerWindow = window->GetOuterWindow();
+    if (outerWindow) {
+      serviceWorkersTestingInWindow = outerWindow->GetServiceWorkersTestingEnabled();
+    }
   }
 
-  return CreateOnMainThread(ns, global, aPrincipal, privateBrowsing, aRv);
+  return CreateOnMainThread(ns, global, aPrincipal, privateBrowsing,
+                            serviceWorkersTestingInWindow, aRv);
 }
 
 nsISupports*
 CacheStorage::GetParentObject() const
 {
   return mGlobal;
 }
 
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -45,16 +45,17 @@ class CacheStorage final : public nsIIPC
                          , public TypeUtils
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
   static already_AddRefed<CacheStorage>
   CreateOnMainThread(Namespace aNamespace, nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal, bool aPrivateBrowsing,
+                     bool aServiceWorkersTestingEnabledInWindow,
                      ErrorResult& aRv);
 
   static already_AddRefed<CacheStorage>
   CreateOnWorker(Namespace aNamespace, nsIGlobalObject* aGlobal,
                  workers::WorkerPrivate* aWorkerPrivate, ErrorResult& aRv);
 
   // webidl interface methods
   already_AddRefed<Promise> Match(const RequestOrUSVString& aRequest,
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -309,20 +309,23 @@ private:
 class CacheScriptLoader;
 
 class CacheCreator final : public PromiseNativeHandler
 {
 public:
   explicit CacheCreator(WorkerPrivate* aWorkerPrivate)
     : mCacheName(aWorkerPrivate->ServiceWorkerCacheName())
     , mPrivateBrowsing(aWorkerPrivate->IsInPrivateBrowsing())
+    , mServiceWorkersTestingInWindow(aWorkerPrivate->ServiceWorkersTestingInWindow())
   {
     MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
     MOZ_ASSERT(aWorkerPrivate->LoadScriptAsPartOfLoadingServiceWorkerScript());
     AssertIsOnMainThread();
+    printf_stderr("### ### CacheCreator has testing %s\n",
+                  (mServiceWorkersTestingInWindow ? "true" : "false"));
   }
 
   void
   AddLoader(CacheScriptLoader* aLoader)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(!mCacheStorage);
     mLoaders.AppendElement(aLoader);
@@ -370,16 +373,17 @@ private:
 
   nsRefPtr<Cache> mCache;
   nsRefPtr<CacheStorage> mCacheStorage;
   nsCOMPtr<nsIGlobalObject> mSandboxGlobalObject;
   nsTArray<nsRefPtr<CacheScriptLoader>> mLoaders;
 
   nsString mCacheName;
   bool mPrivateBrowsing;
+  bool mServiceWorkersTestingInWindow;
 };
 
 class CacheScriptLoader final : public PromiseNativeHandler
                                   , public nsIStreamLoaderObserver
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSISTREAMLOADEROBSERVER
@@ -1213,16 +1217,17 @@ CacheCreator::CreateCacheStorage(nsIPrin
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
   ErrorResult error;
   mCacheStorage =
     CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                      mSandboxGlobalObject,
                                      aPrincipal, mPrivateBrowsing,
+                                     mServiceWorkersTestingInWindow,
                                      error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
   return NS_OK;
 }
 
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -878,44 +878,48 @@ class ServiceWorkerRegisterJob final : p
 
   enum
   {
     REGISTER_JOB = 0,
     UPDATE_JOB = 1,
   } mJobType;
 
   bool mCanceled;
+  bool mServiceWorkersTestingInWindow;
 
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // [[Register]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            const nsCString& aScope,
                            const nsCString& aScriptSpec,
+                           bool aServiceWorkersTestingInWindow,
                            ServiceWorkerUpdateFinishCallback* aCallback,
                            nsIPrincipal* aPrincipal)
     : ServiceWorkerJob(aQueue)
     , mScope(aScope)
     , mScriptSpec(aScriptSpec)
     , mCallback(aCallback)
     , mPrincipal(aPrincipal)
     , mJobType(REGISTER_JOB)
     , mCanceled(false)
+    , mServiceWorkersTestingInWindow(aServiceWorkersTestingInWindow)
   { }
 
   // [[Update]]
   ServiceWorkerRegisterJob(ServiceWorkerJobQueue* aQueue,
                            ServiceWorkerRegistrationInfo* aRegistration,
                            ServiceWorkerUpdateFinishCallback* aCallback)
     : ServiceWorkerJob(aQueue)
     , mRegistration(aRegistration)
     , mCallback(aCallback)
     , mJobType(UPDATE_JOB)
     , mCanceled(false)
+    , mServiceWorkersTestingInWindow(false)
   { }
 
   bool
   IsRegisterJob() const override
   {
     return true;
   }
 
@@ -1225,16 +1229,17 @@ private:
     // byte-for-byte match with the script resource of newestWorker...
     if (workerInfo && workerInfo->ScriptSpec().Equals(mRegistration->mScriptSpec)) {
       cacheName = workerInfo->CacheName();
     }
 
     nsresult rv =
       serviceWorkerScriptCache::Compare(mRegistration->mPrincipal, cacheName,
                                         NS_ConvertUTF8toUTF16(mRegistration->mScriptSpec),
+                                        mServiceWorkersTestingInWindow,
                                         this);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return Fail(rv);
     }
   }
 
   void
   Succeed()
@@ -1529,18 +1534,33 @@ ServiceWorkerManager::Register(nsIDOMWin
   }
 
   ServiceWorkerJobQueue* queue = GetOrCreateJobQueue(originSuffix, cleanedScope);
   MOZ_ASSERT(queue);
 
   nsRefPtr<ServiceWorkerResolveWindowPromiseOnUpdateCallback> cb =
     new ServiceWorkerResolveWindowPromiseOnUpdateCallback(window, promise);
 
+  bool serviceWorkersTestingInWindow = false;
+  nsCOMPtr<nsPIDOMWindow> pWindow = do_QueryInterface(window);
+  if (pWindow) {
+    if (pWindow->IsOuterWindow()) {
+      serviceWorkersTestingInWindow = pWindow->GetServiceWorkersTestingEnabled();
+    } else {
+      nsCOMPtr<nsPIDOMWindow> outer = pWindow->GetOuterWindow();
+      if (outer) {
+        serviceWorkersTestingInWindow = outer->GetServiceWorkersTestingEnabled();
+      }
+    }
+  }
+
   nsRefPtr<ServiceWorkerRegisterJob> job =
-    new ServiceWorkerRegisterJob(queue, cleanedScope, spec, cb, documentPrincipal);
+    new ServiceWorkerRegisterJob(queue, cleanedScope, spec,
+                                 serviceWorkersTestingInWindow,
+                                 cb, documentPrincipal);
   queue->Append(job);
 
   AssertIsOnMainThread();
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
 }
diff --git a/dom/workers/ServiceWorkerScriptCache.cpp b/dom/workers/ServiceWorkerScriptCache.cpp
--- a/dom/workers/ServiceWorkerScriptCache.cpp
+++ b/dom/workers/ServiceWorkerScriptCache.cpp
@@ -19,17 +19,18 @@ using mozilla::dom::cache::CacheStorage;
 
 BEGIN_WORKERS_NAMESPACE
 
 namespace serviceWorkerScriptCache {
 
 namespace {
 
 already_AddRefed<CacheStorage>
-CreateCacheStorage(nsIPrincipal* aPrincipal, ErrorResult& aRv,
+CreateCacheStorage(nsIPrincipal* aPrincipal, bool aServiceWorkersTestingInWindow,
+                   ErrorResult& aRv,
                    nsIXPConnectJSObjectHolder** aHolder = nullptr)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
 
   nsIXPConnect* xpc = nsContentUtils::XPConnect();
   MOZ_ASSERT(xpc, "This should never be null!");
 
@@ -54,17 +55,19 @@ CreateCacheStorage(nsIPrincipal* aPrinci
 
   // We assume private browsing is not enabled here.  The ScriptLoader
   // explicitly fails for private browsing so there should never be
   // a service worker running in private browsing mode.  Therefore if
   // we are purging scripts or running a comparison algorithm we cannot
   // be in private browing.
   return CacheStorage::CreateOnMainThread(cache::CHROME_ONLY_NAMESPACE,
                                           sandboxGlobalObject, aPrincipal,
-                                          false /* private browsing */, aRv);
+                                          false /* private browsing */,
+                                          aServiceWorkersTestingInWindow,
+                                          aRv);
 }
 
 class CompareManager;
 
 // This class downloads a URL from the network and then it calls
 // NetworkFinished() in the CompareManager.
 class CompareNetwork final : public nsIStreamLoaderObserver,
                              public nsIRequestObserver
@@ -268,39 +271,41 @@ private:
   bool mAborted;
 };
 
 NS_IMPL_ISUPPORTS(CompareCache, nsIStreamLoaderObserver)
 
 class CompareManager final : public PromiseNativeHandler
 {
 public:
-  explicit CompareManager(CompareCallback* aCallback)
+  CompareManager(CompareCallback* aCallback, bool aServiceWorkersTestingInWindow)
     : mCallback(aCallback)
     , mState(WaitingForOpen)
     , mNetworkFinished(false)
     , mCacheFinished(false)
     , mInCache(false)
+    , mServiceWorkersTestingInWindow(aServiceWorkersTestingInWindow)
   {
     AssertIsOnMainThread();
   }
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL,
              const nsAString& aCacheName)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aPrincipal);
 
     mURL = aURL;
 
     // Always create a CacheStorage since we want to write the network entry to
     // the cache even if there isn't an existing one.
     ErrorResult result;
-    mCacheStorage = CreateCacheStorage(aPrincipal, result, getter_AddRefs(mSandbox));
+    mCacheStorage = CreateCacheStorage(aPrincipal, mServiceWorkersTestingInWindow,
+                                       result, getter_AddRefs(mSandbox));
     if (NS_WARN_IF(result.Failed())) {
       MOZ_ASSERT(!result.IsErrorWithMessage());
       return result.StealNSResult();
     }
 
     mCN = new CompareNetwork(this);
     nsresult rv = mCN->Initialize(aPrincipal, aURL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -588,16 +593,17 @@ private:
   enum {
     WaitingForOpen,
     WaitingForPut
   } mState;
 
   bool mNetworkFinished;
   bool mCacheFinished;
   bool mInCache;
+  bool mServiceWorkersTestingInWindow;
 };
 
 NS_IMETHODIMP
 CompareNetwork::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
   AssertIsOnMainThread();
 
   // If no channel, Abort() has been called.
@@ -895,17 +901,18 @@ PurgeCache(nsIPrincipal* aPrincipal, con
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
 
   if (aCacheName.IsEmpty()) {
     return NS_OK;
   }
 
   ErrorResult rv;
-  nsRefPtr<CacheStorage> cacheStorage = CreateCacheStorage(aPrincipal, rv);
+  nsRefPtr<CacheStorage> cacheStorage =
+    CreateCacheStorage(aPrincipal, false /* sw testing in window */, rv);
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   // We use the ServiceWorker scope as key for the cacheStorage.
   nsRefPtr<Promise> promise =
     cacheStorage->Delete(aCacheName, rv);
   if (NS_WARN_IF(rv.Failed())) {
@@ -936,24 +943,26 @@ GenerateCacheName(nsAString& aName)
   id.ToProvidedString(chars);
   aName.AssignASCII(chars, NSID_LENGTH);
 
   return NS_OK;
 }
 
 nsresult
 Compare(nsIPrincipal* aPrincipal, const nsAString& aCacheName,
-        const nsAString& aURL, CompareCallback* aCallback)
+        const nsAString& aURL, bool aServiceWorkersTestingInWindow,
+        CompareCallback* aCallback)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aURL.IsEmpty());
   MOZ_ASSERT(aCallback);
 
-  nsRefPtr<CompareManager> cm = new CompareManager(aCallback);
+  nsRefPtr<CompareManager> cm =
+    new CompareManager(aCallback, aServiceWorkersTestingInWindow);
 
   nsresult rv = cm->Initialize(aPrincipal, aURL, aCacheName);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
diff --git a/dom/workers/ServiceWorkerScriptCache.h b/dom/workers/ServiceWorkerScriptCache.h
--- a/dom/workers/ServiceWorkerScriptCache.h
+++ b/dom/workers/ServiceWorkerScriptCache.h
@@ -39,17 +39,18 @@ public:
                    const nsACString& aMaxScope) = 0;
 
   NS_IMETHOD_(MozExternalRefCountType) AddRef() = 0;
   NS_IMETHOD_(MozExternalRefCountType) Release() = 0;
 };
 
 nsresult
 Compare(nsIPrincipal* aPrincipal, const nsAString& aCacheName,
-        const nsAString& aURL, CompareCallback* aCallback);
+        const nsAString& aURL, bool aServiceWorkersTestingInWindow,
+        CompareCallback* aCallback);
 
 } // serviceWorkerScriptCache namespace
 
 } // workers namespace
 } // dom namespace
 } // mozilla namespace
 
 #endif // mozilla_dom_workers_ServiceWorkerScriptCache_h
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -4960,16 +4960,19 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
 
     loadInfo.mDomain = aParent->Domain();
     loadInfo.mFromWindow = aParent->IsFromWindow();
     loadInfo.mWindowID = aParent->WindowID();
     loadInfo.mIndexedDBAllowed = aParent->IsIndexedDBAllowed();
     loadInfo.mPrivateBrowsing = aParent->IsInPrivateBrowsing();
     loadInfo.mServiceWorkersTestingInWindow =
       aParent->ServiceWorkersTestingInWindow();
+
+    printf_stderr("### ### load info parent SW testing %s\n",
+                  (loadInfo.mServiceWorkersTestingInWindow ? "true" : "false"));
   } else {
     AssertIsOnMainThread();
 
     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
     MOZ_ASSERT(ssm);
 
     bool isChrome = nsContentUtils::IsCallerChrome();
 
@@ -5007,18 +5010,25 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
       // Only use the current inner window, and only use it if the caller can
       // access it.
       nsPIDOMWindow* outerWindow = globalWindow->GetOuterWindow();
       if (outerWindow) {
         loadInfo.mWindow = outerWindow->GetCurrentInnerWindow();
         // TODO: fix this for SharedWorkers with multiple documents (bug 1177935)
         loadInfo.mServiceWorkersTestingInWindow =
           outerWindow->GetServiceWorkersTestingEnabled();
+      } else {
+        // TODO: fix this for SharedWorkers with multiple documents (bug 1177935)
+        loadInfo.mServiceWorkersTestingInWindow =
+          globalWindow->GetServiceWorkersTestingEnabled();
       }
 
+      printf_stderr("### ### load info SW testing %s\n",
+                    (loadInfo.mServiceWorkersTestingInWindow ? "true" : "false"));
+
       if (!loadInfo.mWindow ||
           (globalWindow != loadInfo.mWindow &&
             !nsContentUtils::CanCallerAccess(loadInfo.mWindow))) {
         return NS_ERROR_DOM_SECURITY_ERR;
       }
 
       nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(loadInfo.mWindow);
       MOZ_ASSERT(sgo);
