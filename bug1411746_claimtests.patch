# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b77c955e192f20dea92216797851b841b8c38a62
Bug 1411746 Make tests that wait for controller change also wait for SW activation before claim(). r=tt

diff --git a/dom/workers/test/serviceworkers/test_devtools_bypass_serviceworker.html b/dom/workers/test/serviceworkers/test_devtools_bypass_serviceworker.html
--- a/dom/workers/test/serviceworkers/test_devtools_bypass_serviceworker.html
+++ b/dom/workers/test/serviceworkers/test_devtools_bypass_serviceworker.html
@@ -5,16 +5,17 @@
   <script src="/tests/SimpleTest/SimpleTest.js"></script>
   <script src="/tests/SimpleTest/SpawnTask.js"></script>
   <script src="error_reporting_helpers.js"></script>
   <link rel="stylesheet" href="/tests/SimpleTest/test.css"/>
   <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
 </head>
 <body>
 <div id="content" style="display: none"></div>
+<script src="utils.js"></script>
 <script type="text/javascript">
 "use strict";
 
 async function testBypassSW () {
   // Bypass SW imitates the "Disable Cache" option in dev-tools.
   // Note: if we put the setter/getter into dev-tools, we should take care of
   // the implementation of enabling/disabling cache since it just overwrite the
   // defaultLoadFlags of docShell.
@@ -89,25 +90,22 @@ add_task(function setupPrefs() {
     ["dom.serviceWorkers.testing.enabled", true],
   ]});
 });
 
 add_task(async function test_bypassServiceWorker() {
   const swURL = "fetch.js";
   let registration = await navigator.serviceWorker.register(swURL);
 
-  // Wait for the service worker to control the document
-  let waitForControlled = new Promise(resolve => {
-    navigator.serviceWorker.oncontrollerchange = resolve;
-  });
-
   let sw =
     registration.active || registration.waiting || registration.installing;
+
+  await waitForState(sw, 'activated');
   sw.postMessage("claim");
-  await waitForControlled;
+  await waitForControlled(window);
 
   try {
     await testBypassSW();
   } catch (e) {
     ok(false, "Reason:" + e);
   }
 
   await registration.unregister();
diff --git a/dom/workers/test/serviceworkers/test_fetch_integrity.html b/dom/workers/test/serviceworkers/test_fetch_integrity.html
--- a/dom/workers/test/serviceworkers/test_fetch_integrity.html
+++ b/dom/workers/test/serviceworkers/test_fetch_integrity.html
@@ -5,16 +5,17 @@
   <script src="/tests/SimpleTest/SimpleTest.js"></script>
   <script src="/tests/SimpleTest/SpawnTask.js"></script>
   <script src="error_reporting_helpers.js"></script>
   <link rel="stylesheet" href="/tests/SimpleTest/test.css"/>
   <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
 </head>
 <body>
 <div id="content" style="display: none"></div>
+<script src="utils.js"></script>
 <script type="text/javascript">
 "use strict";
 
 let security_localizer =
   stringBundleService.createBundle("chrome://global/locale/security/security.properties");
 
 function expect_security_console_message(/* msgId, args, ... */) {
   let expectations = [];
@@ -44,26 +45,22 @@ add_task(function setupPrefs() {
     ["browser.newtab.preload", false],
   ]});
 });
 
 add_task(async function test_integrity_serviceWorker() {
   var filename = make_absolute_url("fetch.js");
   var filename2 = make_absolute_url("fake.html");
 
-  // The SW will claim us once it activates; this is async, start listening now.
-  let waitForControlled = new Promise((resolve) => {
-    navigator.serviceWorker.oncontrollerchange = resolve;
-  });
-
   let registration = await navigator.serviceWorker.register("fetch.js",
                                                             { scope: "./" });
   let worker = registration.installing || registration.active;
+  await waitForState(worker, 'activated');
   worker.postMessage('claim');
-  await waitForControlled;
+  await waitForControlled(window);
 
   info("Test for mNavigationInterceptions.")
   // The client_win will reload to another URL after opening filename2.
   let client_win = window.open(filename2);
 
   // XXX windowID should be innerWindowID
   let mainWindowID = SpecialPowers.getDOMWindowUtils(window).outerWindowID;
   let clientWindowID = SpecialPowers.getDOMWindowUtils(client_win).outerWindowID;
diff --git a/dom/workers/test/serviceworkers/test_unresolved_fetch_interception.html b/dom/workers/test/serviceworkers/test_unresolved_fetch_interception.html
--- a/dom/workers/test/serviceworkers/test_unresolved_fetch_interception.html
+++ b/dom/workers/test/serviceworkers/test_unresolved_fetch_interception.html
@@ -17,16 +17,17 @@
 <a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1188545">Mozilla Bug 118845</a>
 <p id="display"></p>
 <div id="content" style="display: none">
 
 </div>
 <pre id="test">
 </pre>
 
+<script src="utils.js"></script>
 <script class="testbody" type="text/javascript">
 // (This doesn't really need to be its own task, but it allows the actual test
 // case to be self-contained.)
 add_task(function setupPrefs() {
   return SpecialPowers.pushPrefEnv({"set": [
     ["dom.serviceWorkers.enabled", true],
     ["dom.serviceWorkers.testing.enabled", true],
   ]});
@@ -34,24 +35,23 @@ add_task(function setupPrefs() {
 
 add_task(async function grace_timeout_termination_with_interrupted_intercept() {
   // Setup timeouts so that the service worker will go into grace timeout after
   // a zero-length idle timeout.
   await SpecialPowers.pushPrefEnv({"set": [
     ["dom.serviceWorkers.idle_timeout", 0],
     ["dom.serviceWorkers.idle_extended_timeout", 299999]]});
 
-  // The SW will claim us once it activates; this is async, start listening now.
-  let waitForControlled = new Promise((resolve) => {
-    navigator.serviceWorker.oncontrollerchange = resolve;
-  });
-
   let registration = await navigator.serviceWorker.register(
     "unresolved_fetch_worker.js", { scope: "./"} );
-  await waitForControlled;
+
+  let worker = registration.installing || registration.active;
+  await waitForState(worker, 'activated');
+  worker.postMessage('claim');
+  await waitForControlled(window);
   ok(navigator.serviceWorker.controller, "Controlled"); // double check!
 
   // We want to make sure the SW is active and processing the fetch before we
   // try and kill it.  It sends us a message when it has done so.
   let waitForFetchActive = new Promise((resolve) => {
     navigator.serviceWorker.onmessage = resolve;
   });
 
diff --git a/dom/workers/test/serviceworkers/unresolved_fetch_worker.js b/dom/workers/test/serviceworkers/unresolved_fetch_worker.js
--- a/dom/workers/test/serviceworkers/unresolved_fetch_worker.js
+++ b/dom/workers/test/serviceworkers/unresolved_fetch_worker.js
@@ -9,11 +9,12 @@ onfetch = function(event) {
            })
   );
 
   // Never resolve, and keep it alive on our global so it can't get GC'ed and
   // make this test weird and intermittent.
   event.respondWith((keepPromiseAlive = new Promise(function(res, rej) {})));
 }
 
-onactivate = function(event) {
+onmessage = function(event) {
   event.waitUntil(clients.claim());
+  self.onmessage = null;
 }
