# HG changeset patch
# User Ehsan Akhgari <ehsan@mozilla.com>

Bug 1133763 - Part 4: Store the response's security info in the cache database; r=bkelly

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
index 1acb0c5..80b56e3 100644
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -15,18 +15,18 @@
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 
-const int32_t DBSchema::kMaxWipeSchemaVersion = 1;
-const int32_t DBSchema::kLatestSchemaVersion = 1;
+const int32_t DBSchema::kMaxWipeSchemaVersion = 2;
+const int32_t DBSchema::kLatestSchemaVersion = 2;
 const int32_t DBSchema::kMaxEntriesPerStatement = 255;
 
 using mozilla::void_t;
 
 // static
 nsresult
 DBSchema::CreateSchema(mozIStorageConnection* aConn)
 {
@@ -92,16 +92,17 @@ DBSchema::CreateSchema(mozIStorageConnection* aConn)
         "request_credentials INTEGER NOT NULL, "
         "request_body_id TEXT NULL, "
         "response_type INTEGER NOT NULL, "
         "response_url TEXT NOT NULL, "
         "response_status INTEGER NOT NULL, "
         "response_status_text TEXT NOT NULL, "
         "response_headers_guard INTEGER NOT NULL, "
         "response_body_id TEXT NULL, "
+        "response_security_info BLOB NULL, "
         "cache_id INTEGER NOT NULL REFERENCES caches(id) ON DELETE CASCADE"
       ");"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // TODO: see if we can remove these indices on TEXT columns (bug 1110458)
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE INDEX entries_request_url_index "
@@ -934,18 +935,19 @@ DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
       "request_credentials, "
       "request_body_id, "
       "response_type, "
       "response_url, "
       "response_status, "
       "response_status_text, "
       "response_headers_guard, "
       "response_body_id, "
+      "response_security_info, "
       "cache_id "
-    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)"
+    ") VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16)"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringParameter(0, aRequest.method());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindStringParameter(1, aRequest.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -984,17 +986,22 @@ DBSchema::InsertEntry(mozIStorageConnection* aConn, CacheId aCacheId,
 
   rv = state->BindInt32Parameter(12,
     static_cast<int32_t>(aResponse.headersGuard()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindId(state, 13, aResponseBodyId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindInt32Parameter(14, aCacheId);
+  rv = state->BindBlobParameter(14, reinterpret_cast<const uint8_t*>
+                                  (aResponse.securityInfo().get()),
+                                aResponse.securityInfo().Length());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(15, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT last_insert_rowid()"
   ), getter_AddRefs(state));
@@ -1071,17 +1078,18 @@ DBSchema::ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "response_type, "
       "response_url, "
       "response_status, "
       "response_status_text, "
       "response_headers_guard, "
-      "response_body_id "
+      "response_body_id, "
+      "response_security_info "
     "FROM entries "
     "WHERE id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aEntryId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1116,16 +1124,23 @@ DBSchema::ReadResponse(mozIStorageConnection* aConn, EntryId aEntryId,
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedResponseOut->mHasBodyId = !nullBody;
 
   if (aSavedResponseOut->mHasBodyId) {
     rv = ExtractId(state, 5, &aSavedResponseOut->mBodyId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
+  uint8_t* data = nullptr;
+  uint32_t dataLength = 0;
+  rv = state->GetBlob(6, &dataLength, &data);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aSavedResponseOut->mValue.securityInfo().Adopt(
+    reinterpret_cast<char*>(const_cast<uint8_t*>(data)), dataLength);
+
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "name, "
       "value "
     "FROM response_headers "
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
