# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  4f85b8fc9d00d31403565e6a9130c69d7c8fa619

diff --git a/dom/file/nsHostObjectProtocolHandler.cpp b/dom/file/nsHostObjectProtocolHandler.cpp
--- a/dom/file/nsHostObjectProtocolHandler.cpp
+++ b/dom/file/nsHostObjectProtocolHandler.cpp
@@ -18,16 +18,17 @@
 #include "mozilla/LoadInfo.h"
 #include "mozilla/ModuleUtils.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/SystemGroup.h"
 #include "nsClassHashtable.h"
 #include "nsContentUtils.h"
 #include "nsError.h"
 #include "nsHostObjectURI.h"
+#include "nsIAsyncShutdown.h"
 #include "nsIMemoryReporter.h"
 #include "nsIPrincipal.h"
 #include "nsIUUIDGenerator.h"
 #include "nsNetUtil.h"
 
 #define RELEASING_TIMER 5000
 
 using namespace mozilla;
@@ -432,87 +433,164 @@ class BlobURLsReporter final : public ns
     }
   }
 };
 
 NS_IMPL_ISUPPORTS(BlobURLsReporter, nsIMemoryReporter)
 
 class ReleasingTimerHolder final : public nsITimerCallback
                                  , public nsINamed
+                                 , public nsIAsyncShutdownBlocker
 {
 public:
   NS_DECL_ISUPPORTS
 
   static void
   Create(const nsACString& aURI, bool aBroadcastToOtherProcesses)
   {
     RefPtr<ReleasingTimerHolder> holder =
       new ReleasingTimerHolder(aURI, aBroadcastToOtherProcesses);
+
+    auto raii = mozilla::MakeScopeExit([&] {
+      holder->CancelTimerAndRevokeURI();
+    });
+
     nsresult rv = NS_NewTimerWithCallback(getter_AddRefs(holder->mTimer),
                                           holder, RELEASING_TIMER,
                                           nsITimer::TYPE_ONE_SHOT,
                                           SystemGroup::EventTargetFor(TaskCategory::Other));
     NS_ENSURE_SUCCESS_VOID(rv);
+
+    nsCOMPtr<nsIAsyncShutdownClient> phase = GetShutdownPhase();
+    NS_ENSURE_TRUE_VOID(!!phase);
+
+    rv = phase->AddBlocker(holder, NS_LITERAL_STRING(__FILE__), __LINE__,
+                           NS_LITERAL_STRING("ReleasingTimerHolder shutdown"));
+    NS_ENSURE_SUCCESS_VOID(rv);
+
+    raii.release();
   }
 
+  // nsITimerCallback interface
+
   NS_IMETHOD
   Notify(nsITimer* aTimer) override
   {
+    RevokeURI(mBroadcastToOtherProcesses);
+    return NS_OK;
+  }
+
+  // nsINamed interface
+
+  NS_IMETHOD
+  GetName(nsACString& aName) override
+  {
+    aName.AssignLiteral("ReleasingTimerHolder");
+    return NS_OK;
+  }
+
+  // nsIAsyncShutdownBlocker interface
+
+  NS_IMETHOD
+  GetName(nsAString& aName) override
+  {
+    aName.AssignLiteral("ReleasingTimerHolder");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  BlockShutdown(nsIAsyncShutdownClient* aClient) override
+  {
+    CancelTimerAndRevokeURI();
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  GetState(nsIPropertyBag**) override
+  {
+    return NS_OK;
+  }
+
+private:
+  ReleasingTimerHolder(const nsACString& aURI, bool aBroadcastToOtherProcesses)
+    : mURI(aURI)
+    , mBroadcastToOtherProcesses(aBroadcastToOtherProcesses)
+  {}
+
+  ~ReleasingTimerHolder()
+  {}
+
+  void
+  RevokeURI(bool aBroadcastToOtherProcesses)
+  {
+    // Remove the shutting down blocker
+    nsCOMPtr<nsIAsyncShutdownClient> phase = GetShutdownPhase();
+    if (phase) {
+      phase->RemoveBlocker(this);
+    }
+
     // If we have to broadcast the unregistration, let's do it now.
-    if (mBroadcastToOtherProcesses) {
+    if (aBroadcastToOtherProcesses) {
       BroadcastBlobURLUnregistration(mURI);
     }
 
     DataInfo* info = GetDataInfo(mURI, true /* We care about revoked dataInfo */);
     if (!info) {
       // Already gone!
-      return NS_OK;
+      return;
     }
 
     MOZ_ASSERT(info->mRevoked);
 
     for (uint32_t i = 0; i < info->mURIs.Length(); ++i) {
       nsCOMPtr<nsIURI> uri = do_QueryReferent(info->mURIs[i]);
       if (uri) {
         static_cast<nsHostObjectURI*>(uri.get())->ForgetBlobImpl();
       }
     }
 
     gDataTable->Remove(mURI);
     if (gDataTable->Count() == 0) {
       delete gDataTable;
       gDataTable = nullptr;
     }
-
-    return NS_OK;
   }
 
-  NS_IMETHOD
-  GetName(nsACString& aName) override
+  void
+  CancelTimerAndRevokeURI()
   {
-    aName.AssignLiteral("ReleasingTimerHolder");
-    return NS_OK;
+    if (mTimer) {
+      mTimer->Cancel();
+      mTimer = nullptr;
+    }
+
+    RevokeURI(false /* aBroadcastToOtherProcesses */);
   }
 
-private:
-  ReleasingTimerHolder(const nsACString& aURI, bool aBroadcastToOtherProcesses)
-    : mURI(aURI)
-    , mBroadcastToOtherProcesses(aBroadcastToOtherProcesses)
-  {}
+  static nsCOMPtr<nsIAsyncShutdownClient>
+  GetShutdownPhase()
+  {
+    nsCOMPtr<nsIAsyncShutdownService> svc = services::GetAsyncShutdown();
+    NS_ENSURE_TRUE(!!svc, nullptr);
 
-  ~ReleasingTimerHolder()
-  {}
+    nsCOMPtr<nsIAsyncShutdownClient> phase;
+    nsresult rv = svc->GetXpcomWillShutdown(getter_AddRefs(phase));
+    NS_ENSURE_SUCCESS(rv, nullptr);
+
+    return Move(phase);
+  }
 
   nsCString mURI;
   bool mBroadcastToOtherProcesses;
 
   nsCOMPtr<nsITimer> mTimer;
 };
 
-NS_IMPL_ISUPPORTS(ReleasingTimerHolder, nsITimerCallback, nsINamed)
+NS_IMPL_ISUPPORTS(ReleasingTimerHolder, nsITimerCallback, nsINamed,
+                  nsIAsyncShutdownBlocker)
 
 } // namespace mozilla
 
 template<typename T>
 static nsresult
 AddDataEntryInternal(const nsACString& aURI, T aObject,
                      nsIPrincipal* aPrincipal)
 {
