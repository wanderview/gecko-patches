# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c40ca7a1bdd93632c6bdc5e23bd33d984d508b19
Bug 1311324 P1 Update the MessageEvent webidl and implementation class. r=bz

diff --git a/dom/base/PostMessageEvent.cpp b/dom/base/PostMessageEvent.cpp
--- a/dom/base/PostMessageEvent.cpp
+++ b/dom/base/PostMessageEvent.cpp
@@ -140,17 +140,17 @@ PostMessageEvent::Run()
   }
 
   // Create the event
   nsCOMPtr<mozilla::dom::EventTarget> eventTarget = do_QueryObject(targetWindow);
   RefPtr<MessageEvent> event =
     new MessageEvent(eventTarget, nullptr, nullptr);
 
 
-  Nullable<WindowProxyOrMessagePort> source;
+  Nullable<WindowProxyOrMessagePortOrServiceWorker> source;
   source.SetValue().SetAsWindowProxy() = mSource ? mSource->AsOuter() : nullptr;
 
   Sequence<OwningNonNull<MessagePort>> ports;
   if (!TakeTransferredPortsAsSequence(ports)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   event->InitMessageEvent(nullptr, NS_LITERAL_STRING("message"),
diff --git a/dom/events/MessageEvent.cpp b/dom/events/MessageEvent.cpp
--- a/dom/events/MessageEvent.cpp
+++ b/dom/events/MessageEvent.cpp
@@ -3,36 +3,39 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/MessagePortBinding.h"
+#include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
 #include "mozilla/HoldDropJSObjects.h"
 #include "jsapi.h"
 #include "nsGlobalWindow.h" // So we can assign an nsGlobalWindow* to mWindowSource
 
 namespace mozilla {
 namespace dom {
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(MessageEvent)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(MessageEvent, Event)
   tmp->mData.setUndefined();
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mWindowSource)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPortSource)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mServiceWorkerSource)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPorts)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(MessageEvent, Event)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mWindowSource)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPortSource)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mServiceWorkerSource)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPorts)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(MessageEvent, Event)
   NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK(mData)
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(MessageEvent)
@@ -79,22 +82,24 @@ MessageEvent::GetOrigin(nsAString& aOrig
 
 void
 MessageEvent::GetLastEventId(nsAString& aLastEventId) const
 {
   aLastEventId = mLastEventId;
 }
 
 void
-MessageEvent::GetSource(Nullable<OwningWindowProxyOrMessagePort>& aValue) const
+MessageEvent::GetSource(Nullable<OwningWindowProxyOrMessagePortOrServiceWorker>& aValue) const
 {
   if (mWindowSource) {
-    aValue.SetValue().SetAsWindowProxy() = mWindowSource->GetOuterWindow();
+    aValue.SetValue().SetAsWindowProxy() = mWindowSource;
   } else if (mPortSource) {
     aValue.SetValue().SetAsMessagePort() = mPortSource;
+  } else if (mServiceWorkerSource) {
+    aValue.SetValue().SetAsServiceWorker() = mServiceWorkerSource;
   }
 }
 
 /* static */ already_AddRefed<MessageEvent>
 MessageEvent::Constructor(const GlobalObject& aGlobal,
                           const nsAString& aType,
                           const MessageEventInit& aParam,
                           ErrorResult& aRv)
@@ -118,56 +123,60 @@ MessageEvent::Constructor(EventTarget* a
   event->mData = aParam.mData;
 
   mozilla::HoldJSObjects(event.get());
 
   event->mOrigin = aParam.mOrigin;
   event->mLastEventId = aParam.mLastEventId;
 
   if (!aParam.mSource.IsNull()) {
-    if (aParam.mSource.Value().IsWindow()) {
-      event->mWindowSource = aParam.mSource.Value().GetAsWindow()->AsInner();
+    if (aParam.mSource.Value().IsWindowProxy()) {
+      event->mWindowSource = aParam.mSource.Value().GetAsWindowProxy();
+    } else if (aParam.mSource.Value().IsMessagePort()) {
+      event->mPortSource = aParam.mSource.Value().GetAsMessagePort();
     } else {
-      event->mPortSource = aParam.mSource.Value().GetAsMessagePort();
+      event->mServiceWorkerSource = aParam.mSource.Value().GetAsServiceWorker();
     }
 
-    MOZ_ASSERT(event->mWindowSource || event->mPortSource);
+    MOZ_ASSERT(event->mWindowSource || event->mPortSource || event->mServiceWorkerSource);
   }
 
   event->mPorts.AppendElements(aParam.mPorts);
 
   return event.forget();
 }
 
 void
 MessageEvent::InitMessageEvent(JSContext* aCx, const nsAString& aType,
                                bool aCanBubble, bool aCancelable,
                                JS::Handle<JS::Value> aData,
                                const nsAString& aOrigin,
                                const nsAString& aLastEventId,
-                               const Nullable<WindowProxyOrMessagePort>& aSource,
+                               const Nullable<WindowProxyOrMessagePortOrServiceWorker>& aSource,
                                const Sequence<OwningNonNull<MessagePort>>& aPorts)
 {
   NS_ENSURE_TRUE_VOID(!mEvent->mFlags.mIsBeingDispatched);
 
   Event::InitEvent(aType, aCanBubble, aCancelable);
   mData = aData;
   mozilla::HoldJSObjects(this);
   mOrigin = aOrigin;
   mLastEventId = aLastEventId;
 
   mWindowSource = nullptr;
   mPortSource = nullptr;
+  mServiceWorkerSource = nullptr;
 
   if (!aSource.IsNull()) {
     if (aSource.Value().IsWindowProxy()) {
-      auto* windowProxy = aSource.Value().GetAsWindowProxy();
-      mWindowSource = windowProxy ? windowProxy->GetCurrentInnerWindow() : nullptr;
+      mWindowSource = aSource.Value().GetAsWindowProxy();
+    } else if (aSource.Value().IsMessagePort()) {
+      mPortSource = &aSource.Value().GetAsMessagePort();
     } else {
-      mPortSource = &aSource.Value().GetAsMessagePort();
+      mServiceWorkerSource = &aSource.Value().GetAsServiceWorker();
     }
   }
 
   mPorts.Clear();
   mPorts.AppendElements(aPorts);
   MessageEventBinding::ClearCachedPortsValue(this);
 }
 
diff --git a/dom/events/MessageEvent.h b/dom/events/MessageEvent.h
--- a/dom/events/MessageEvent.h
+++ b/dom/events/MessageEvent.h
@@ -11,18 +11,22 @@
 #include "mozilla/dom/BindingUtils.h"
 #include "nsCycleCollectionParticipant.h"
 
 namespace mozilla {
 namespace dom {
 
 struct MessageEventInit;
 class MessagePort;
-class OwningWindowProxyOrMessagePort;
-class WindowProxyOrMessagePort;
+class OwningWindowProxyOrMessagePortOrServiceWorker;
+class WindowProxyOrMessagePortOrServiceWorker;
+
+namespace workers {
+class ServiceWorker;
+}
 
 /**
  * Implements the MessageEvent event, used for cross-document messaging and
  * server-sent events.
  *
  * See http://www.whatwg.org/specs/web-apps/current-work/#messageevent for
  * further details.
  */
@@ -40,17 +44,17 @@ public:
   NS_FORWARD_TO_EVENT
 
   virtual JSObject* WrapObjectInternal(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   void GetData(JSContext* aCx, JS::MutableHandle<JS::Value> aData,
                ErrorResult& aRv);
   void GetOrigin(nsAString&) const;
   void GetLastEventId(nsAString&) const;
-  void GetSource(Nullable<OwningWindowProxyOrMessagePort>& aValue) const;
+  void GetSource(Nullable<OwningWindowProxyOrMessagePortOrServiceWorker>& aValue) const;
 
   void GetPorts(nsTArray<RefPtr<MessagePort>>& aPorts);
 
   static already_AddRefed<MessageEvent>
   Constructor(const GlobalObject& aGlobal,
               const nsAString& aType,
               const MessageEventInit& aEventInit,
               ErrorResult& aRv);
@@ -59,28 +63,29 @@ public:
   Constructor(EventTarget* aEventTarget,
               const nsAString& aType,
               const MessageEventInit& aEventInit,
               ErrorResult& aRv);
 
   void InitMessageEvent(JSContext* aCx, const nsAString& aType, bool aCanBubble,
                         bool aCancelable, JS::Handle<JS::Value> aData,
                         const nsAString& aOrigin, const nsAString& aLastEventId,
-                        const Nullable<WindowProxyOrMessagePort>& aSource,
+                        const Nullable<WindowProxyOrMessagePortOrServiceWorker>& aSource,
                         const Sequence<OwningNonNull<MessagePort>>& aPorts);
 
 protected:
   ~MessageEvent();
 
 private:
   JS::Heap<JS::Value> mData;
   nsString mOrigin;
   nsString mLastEventId;
-  RefPtr<nsPIDOMWindowInner> mWindowSource;
+  RefPtr<nsPIDOMWindowOuter> mWindowSource;
   RefPtr<MessagePort> mPortSource;
+  RefPtr<workers::ServiceWorker> mServiceWorkerSource;
 
   nsTArray<RefPtr<MessagePort>> mPorts;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_MessageEvent_h_
diff --git a/dom/webidl/MessageEvent.webidl b/dom/webidl/MessageEvent.webidl
--- a/dom/webidl/MessageEvent.webidl
+++ b/dom/webidl/MessageEvent.webidl
@@ -1,15 +1,15 @@
 /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * For more information on this interface, please see
- * http://www.whatwg.org/specs/web-apps/current-work/#messageevent
+ * https://html.spec.whatwg.org/#messageevent
  */
 
 [Constructor(DOMString type, optional MessageEventInit eventInitDict),
  Exposed=(Window,Worker,System)]
 interface MessageEvent : Event {
   /**
    * Custom data associated with this event.
    */
@@ -17,42 +17,44 @@ interface MessageEvent : Event {
   readonly attribute any data;
 
   /**
    * The origin of the site from which this event originated, which is the
    * scheme, ":", and if the URI has a host, "//" followed by the
    * host, and if the port is not the default for the given scheme,
    * ":" followed by that port.  This value does not have a trailing slash.
    */
-  readonly attribute DOMString origin;
+  readonly attribute USVString origin;
 
   /**
    * The last event ID string of the event source, for server-sent DOM events; this
    * value is the empty string for cross-origin messaging.
    */
   readonly attribute DOMString lastEventId;
 
   /**
    * The window or port which originated this event.
    */
-  readonly attribute (WindowProxy or MessagePort)? source;
+  readonly attribute MessageEventSource? source;
 
   /**
    * Initializes this event with the given data, in a manner analogous to
    * the similarly-named method on the nsIDOMEvent interface, also setting the
    * data, origin, source, and lastEventId attributes of this appropriately.
    */
   [Pure, Cached, Frozen]
   readonly attribute sequence<MessagePort> ports;
 
   void initMessageEvent(DOMString type, boolean bubbles, boolean cancelable,
                         any data, DOMString origin, DOMString lastEventId,
-                        (WindowProxy or MessagePort)? source,
+                        MessageEventSource? source,
                         sequence<MessagePort> ports);
 };
 
 dictionary MessageEventInit : EventInit {
   any data = null;
   DOMString origin = "";
   DOMString lastEventId = "";
-  (Window or MessagePort)? source = null;
+  MessageEventSource? source = null;
   sequence<MessagePort> ports = [];
 };
+
+typedef (WindowProxy or MessagePort or ServiceWorker) MessageEventSource;
