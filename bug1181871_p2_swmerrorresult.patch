# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c31ad8f0fd12f3659c4bdbd3ec4dab19e93ee417
Bug 1181871 P2 Fix ServiceWorkerManager usage of stack-based ErrorResult. r=ehsan

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1634,25 +1634,27 @@ DispatchExtendableEventOnWorkerScope(JSC
   MOZ_ASSERT(aWorkerScope);
   MOZ_ASSERT(aEvent);
   nsCOMPtr<nsIGlobalObject> sgo = aWorkerScope;
   WidgetEvent* internalEvent = aEvent->GetInternalNSEvent();
 
   ErrorResult result;
   result = aWorkerScope->DispatchDOMEvent(nullptr, aEvent, nullptr, nullptr);
   if (result.Failed() || internalEvent->mFlags.mExceptionHasBeenRisen) {
+    result.SuppressException();
     return nullptr;
   }
 
   nsRefPtr<Promise> waitUntilPromise = aEvent->GetPromise();
   if (!waitUntilPromise) {
     ErrorResult result;
     waitUntilPromise =
       Promise::Resolve(sgo, aCx, JS::UndefinedHandleValue, result);
     if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
       return nullptr;
     }
   }
 
   MOZ_ASSERT(waitUntilPromise);
   return waitUntilPromise.forget();
 }
 }; // anonymous namespace
@@ -2135,16 +2137,17 @@ public:
     pei.mData.Construct(mData);
     pei.mBubbles = false;
     pei.mCancelable = true;
 
     ErrorResult result;
     nsRefPtr<PushEvent> event =
       PushEvent::Constructor(globalObj, NS_LITERAL_STRING("push"), pei, result);
     if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
       return false;
     }
 
     event->SetTrusted(true);
     event->PostInit(mServiceWorker);
 
     nsRefPtr<Promise> waitUntilPromise =
       DispatchExtendableEventOnWorkerScope(aCx, aWorkerPrivate->GlobalScope(), event);
@@ -3474,30 +3477,32 @@ private:
     reqInit.mMethod.Construct(mMethod);
 
     nsRefPtr<InternalHeaders> internalHeaders = new InternalHeaders(HeadersGuardEnum::Request);
     MOZ_ASSERT(mHeaderNames.Length() == mHeaderValues.Length());
     for (uint32_t i = 0; i < mHeaderNames.Length(); i++) {
       ErrorResult result;
       internalHeaders->Set(mHeaderNames[i], mHeaderValues[i], result);
       if (NS_WARN_IF(result.Failed())) {
+        result.SuppressException();
         return false;
       }
     }
 
     nsRefPtr<Headers> headers = new Headers(globalObj.GetAsSupports(), internalHeaders);
     reqInit.mHeaders.Construct();
     reqInit.mHeaders.Value().SetAsHeaders() = headers;
 
     reqInit.mMode.Construct(mRequestMode);
     reqInit.mCredentials.Construct(mRequestCredentials);
 
     ErrorResult result;
     nsRefPtr<Request> request = Request::Constructor(globalObj, requestInfo, reqInit, result);
     if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
       return false;
     }
     // For Telemetry, note that this Request object was created by a Fetch event.
     nsRefPtr<InternalRequest> internalReq = request->GetInternalRequest();
     MOZ_ASSERT(internalReq);
     internalReq->SetCreatedByFetchEvent();
 
     internalReq->SetBody(mUploadStream);
@@ -3509,16 +3514,17 @@ private:
     init.mRequest.Construct();
     init.mRequest.Value() = request;
     init.mBubbles = false;
     init.mCancelable = true;
     init.mIsReload.Construct(mIsReload);
     nsRefPtr<FetchEvent> event =
       FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, result);
     if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
       return false;
     }
 
     event->PostInit(mInterceptedChannel, mServiceWorker, mClientInfo);
     event->SetTrusted(true);
 
     nsRefPtr<EventTarget> target = do_QueryObject(aWorkerPrivate->GlobalScope());
     nsresult rv2 = target->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
@@ -3944,16 +3950,17 @@ FireControllerChangeOnDocument(nsIDocume
   if (NS_WARN_IF(!window)) {
     NS_WARNING("No valid nsGlobalWindow");
     return;
   }
 
   ErrorResult result;
   dom::Navigator* navigator = window->GetNavigator(result);
   if (NS_WARN_IF(result.Failed())) {
+    result.SuppressException();
     return;
   }
 
   nsRefPtr<ServiceWorkerContainer> container = navigator->ServiceWorker();
   container->ControllerChanged(result);
   if (result.Failed()) {
     NS_WARNING("Failed to dispatch controllerchange event");
   }
