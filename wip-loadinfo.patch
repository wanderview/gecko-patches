# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b013fe3b5b20cdbbcb672464d167074904e3bcf0

diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -63,16 +63,17 @@
 #endif
 
 #ifdef MOZ_GECKO_PROFILER
 #include "ProfilerMarkerPayload.h"
 #endif
 
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
+using mozilla::ipc::LoadInfoToLoadInfoArgs;
 
 namespace mozilla {
 namespace net {
 
 #if defined(NIGHTLY_BUILD) || defined(MOZ_DEV_EDITION) || defined(DEBUG)
 static bool gIPCSecurityDisabled = false;
 #endif
 
@@ -2293,16 +2294,26 @@ HttpChannelChild::OnRedirectVerifyCallba
     return NS_OK;
   }
 
   RequestHeaderTuples emptyHeaders;
   RequestHeaderTuples* headerTuples = &emptyHeaders;
   nsLoadFlags loadFlags = 0;
   OptionalCorsPreflightArgs corsPreflightArgs = mozilla::void_t();
 
+  nsCOMPtr<nsILoadInfo> loadInfo = newHttpChannel
+                                 ? newHttpChannel->GetLoadInfo()
+                                 : nullptr;
+
+  OptionalLoadInfoArgs optionalLoadInfoArgs = void_t();
+  rv = LoadInfoToLoadInfoArgs(loadInfo, &optionalLoadInfoArgs);
+  if (NS_FAILED(rv)) {
+    result = rv;
+  }
+
   nsCOMPtr<nsIHttpChannelChild> newHttpChannelChild =
       do_QueryInterface(mRedirectChannelChild);
   if (newHttpChannelChild && NS_SUCCEEDED(result)) {
     rv = newHttpChannelChild->AddCookiesToRequest();
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     rv = newHttpChannelChild->GetClientSetRequestHeaders(&headerTuples);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
     newHttpChannelChild->GetClientSetCorsPreflightParameters(corsPreflightArgs);
@@ -2343,20 +2354,21 @@ HttpChannelChild::OnRedirectVerifyCallba
 
   bool chooseAppcache = false;
   nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
     do_QueryInterface(newHttpChannel);
   if (appCacheChannel) {
     appCacheChannel->GetChooseApplicationCache(&chooseAppcache);
   }
 
-  if (mIPCOpen)
-    SendRedirect2Verify(result, *headerTuples, loadFlags, referrerPolicy,
-                        referrerURI, redirectURI, corsPreflightArgs,
-                        chooseAppcache);
+  if (mIPCOpen) {
+    SendRedirect2Verify(result, *headerTuples, optionalLoadInfoArgs, loadFlags,
+                        referrerPolicy, referrerURI, redirectURI,
+                        corsPreflightArgs, chooseAppcache);
+  }
 
   return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelChild::nsIRequest
 //-----------------------------------------------------------------------------
 
diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -53,16 +53,17 @@
 #include "nsIStorageStream.h"
 #include "nsThreadUtils.h"
 #include "nsQueryObject.h"
 #include "nsIURIClassifier.h"
 
 using mozilla::BasePrincipal;
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
+using mozilla::ipc::LoadInfoArgsToLoadInfo;
 
 namespace mozilla {
 namespace net {
 
 HttpChannelParent::HttpChannelParent(const PBrowserOrId& iframeEmbedding,
                                      nsILoadContext* aLoadContext,
                                      PBOverrideStatus aOverrideStatus)
   : mIPCClosed(false)
@@ -876,16 +877,17 @@ HttpChannelParent::RecvUpdateAssociatedC
     mAssociatedContentSecurity->SetCountSubRequestsNoSecurity(no);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvRedirect2Verify(const nsresult& result,
                                        const RequestHeaderTuples& changedHeaders,
+                                       const OptionalLoadInfoArgs& aOptionalLoadInfoArgs,
                                        const uint32_t& loadFlags,
                                        const uint32_t& referrerPolicy,
                                        const OptionalURIParams& aReferrerURI,
                                        const OptionalURIParams& aAPIRedirectURI,
                                        const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                        const bool& aChooseAppcache)
 {
   LOG(("HttpChannelParent::RecvRedirect2Verify [this=%p result=%" PRIx32 "]\n",
@@ -909,16 +911,23 @@ HttpChannelParent::RecvRedirect2Verify(c
         } else {
           rv = newHttpChannel->SetRequestHeader(changedHeaders[i].mHeader,
                                                 changedHeaders[i].mValue,
                                                 changedHeaders[i].mMerge);
         }
         MOZ_ASSERT(NS_SUCCEEDED(rv));
       }
 
+      nsCOMPtr<nsILoadInfo> newLoadInfo;
+      rv = mozilla::ipc::LoadInfoArgsToLoadInfo(aOptionalLoadInfoArgs,
+                                                getter_AddRefs(newLoadInfo));
+      if (NS_SUCCEEDED(rv) && newLoadInfo) {
+        newHttpChannel->SetLoadInfo(newLoadInfo);
+      }
+
       // A successfully redirected channel must have the LOAD_REPLACE flag.
       MOZ_ASSERT(loadFlags & nsIChannel::LOAD_REPLACE);
       if (loadFlags & nsIChannel::LOAD_REPLACE) {
         newHttpChannel->SetLoadFlags(loadFlags);
       }
 
       if (aCorsPreflightArgs.type() == OptionalCorsPreflightArgs::TCorsPreflightArgs) {
         nsCOMPtr<nsIHttpChannelInternal> newInternalChannel =
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -184,16 +184,17 @@ protected:
   virtual mozilla::ipc::IPCResult RecvSetPriority(const int16_t& priority) override;
   virtual mozilla::ipc::IPCResult RecvSetClassOfService(const uint32_t& cos) override;
   virtual mozilla::ipc::IPCResult RecvSetCacheTokenCachedCharset(const nsCString& charset) override;
   virtual mozilla::ipc::IPCResult RecvSuspend() override;
   virtual mozilla::ipc::IPCResult RecvResume() override;
   virtual mozilla::ipc::IPCResult RecvCancel(const nsresult& status) override;
   virtual mozilla::ipc::IPCResult RecvRedirect2Verify(const nsresult& result,
                                                       const RequestHeaderTuples& changedHeaders,
+                                                      const OptionalLoadInfoArgs& aOptionalLoadInfoArgs,
                                                       const uint32_t& loadFlags,
                                                       const uint32_t& referrerPolicy,
                                                       const OptionalURIParams& aReferrerURI,
                                                       const OptionalURIParams& apiRedirectUri,
                                                       const OptionalCorsPreflightArgs& aCorsPreflightArgs,
                                                       const bool& aChooseAppcache) override;
   virtual mozilla::ipc::IPCResult RecvUpdateAssociatedContentSecurity(const int32_t& broken,
                                                    const int32_t& no) override;
diff --git a/netwerk/protocol/http/PHttpChannel.ipdl b/netwerk/protocol/http/PHttpChannel.ipdl
--- a/netwerk/protocol/http/PHttpChannel.ipdl
+++ b/netwerk/protocol/http/PHttpChannel.ipdl
@@ -39,16 +39,17 @@ parent:
                                         int32_t no);
   async Suspend();
   async Resume();
 
   async Cancel(nsresult status);
 
   // Reports approval/veto of redirect by child process redirect observers
   async Redirect2Verify(nsresult result, RequestHeaderTuples changedHeaders,
+                        OptionalLoadInfoArgs optionalLoadInfo,
                         uint32_t loadFlags, uint32_t referrerPolicy,
                         OptionalURIParams referrerUri,
                         OptionalURIParams apiRedirectTo,
                         OptionalCorsPreflightArgs corsPreflightArgs,
                         bool chooseAppcache);
 
   // For document loads we keep this protocol open after child's
   // OnStopRequest, and send this msg (instead of __delete__) to allow
