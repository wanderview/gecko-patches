# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7419b8d03469c962448d65af6ddf472b60fcdaa2
Bug 1459209 P15 Implement RemoteServiceWorkerContainerImpl::Register() across IPC to the parent-side SWM. r=baku

diff --git a/dom/serviceworkers/PServiceWorkerContainer.ipdl b/dom/serviceworkers/PServiceWorkerContainer.ipdl
--- a/dom/serviceworkers/PServiceWorkerContainer.ipdl
+++ b/dom/serviceworkers/PServiceWorkerContainer.ipdl
@@ -1,22 +1,29 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 
+include ClientIPCTypes;
+include IPCServiceWorkerRegistrationDescriptor;
+
 namespace mozilla {
 namespace dom {
 
 protocol PServiceWorkerContainer
 {
   manager PBackground;
 
 parent:
   async Teardown();
 
+  async Register(IPCClientInfo aClientInfo, nsCString aScopeURL, nsCString aScriptURL,
+                 ServiceWorkerUpdateViaCache aUpdateViaCache)
+        returns (IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult aResult);
+
 child:
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp b/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
--- a/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
+++ b/dom/serviceworkers/RemoteServiceWorkerContainerImpl.cpp
@@ -10,16 +10,17 @@
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "ServiceWorkerContainerChild.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::ResponseRejectReason;
 
 RemoteServiceWorkerContainerImpl::~RemoteServiceWorkerContainerImpl()
 {
   Shutdown();
 }
 
 void
 RemoteServiceWorkerContainerImpl::Shutdown()
@@ -33,22 +34,47 @@ RemoteServiceWorkerContainerImpl::Shutdo
     mActor->RevokeOwner(this);
     mActor->MaybeStartTeardown();
     mActor = nullptr;
   }
 }
 
 RefPtr<ServiceWorkerRegistrationPromise>
 RemoteServiceWorkerContainerImpl::Register(const ClientInfo& aClientInfo,
-         const nsACString& aScopeURL,
-         const nsACString& aScriptURL,
-         ServiceWorkerUpdateViaCache aUpdateViaCache) const
+                                           const nsACString& aScopeURL,
+                                           const nsACString& aScriptURL,
+                                           ServiceWorkerUpdateViaCache aUpdateViaCache) const
 {
-  // TODO
-  return nullptr;
+  if (!mActor) {
+    return ServiceWorkerRegistrationPromise::CreateAndReject(
+      NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+  }
+
+  RefPtr<ServiceWorkerRegistrationPromise::Private> promise =
+    new ServiceWorkerRegistrationPromise::Private(__func__);
+
+  mActor->SendRegister(aClientInfo.ToIPC(), nsCString(aScopeURL),
+                       nsCString(aScriptURL), aUpdateViaCache,
+    [promise] (const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aResult) {
+      if (aResult.type() == IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::TCopyableErrorResult) {
+        // application layer error
+        auto& rv = aResult.get_CopyableErrorResult();
+        MOZ_DIAGNOSTIC_ASSERT(rv.Failed());
+        promise->Reject(rv, __func__);
+        return;
+      }
+      // success
+      auto& ipcDesc = aResult.get_IPCServiceWorkerRegistrationDescriptor();
+      promise->Resolve(ServiceWorkerRegistrationDescriptor(ipcDesc), __func__);
+    }, [promise] (ResponseRejectReason aReason) {
+      // IPC layer error
+      promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+    });
+
+  return promise.forget();
 }
 
 RefPtr<ServiceWorkerRegistrationPromise>
 RemoteServiceWorkerContainerImpl::GetRegistration(const ClientInfo& aClientInfo,
                 const nsACString& aURL) const
 {
   // TODO
   return nullptr;
diff --git a/dom/serviceworkers/ServiceWorkerContainerParent.cpp b/dom/serviceworkers/ServiceWorkerContainerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerContainerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainerParent.cpp
@@ -24,16 +24,39 @@ ServiceWorkerContainerParent::ActorDestr
 
 IPCResult
 ServiceWorkerContainerParent::RecvTeardown()
 {
   Unused << Send__delete__(this);
   return IPC_OK();
 }
 
+IPCResult
+ServiceWorkerContainerParent::RecvRegister(const IPCClientInfo& aClientInfo,
+                                           const nsCString& aScopeURL,
+                                           const nsCString& aScriptURL,
+                                           const ServiceWorkerUpdateViaCache& aUpdateViaCache,
+                                           RegisterResolver&& aResolver)
+{
+  if (!mProxy) {
+    aResolver(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return IPC_OK();
+  }
+
+  mProxy->Register(ClientInfo(aClientInfo), aScopeURL, aScriptURL, aUpdateViaCache)->Then(
+    GetCurrentThreadSerialEventTarget(), __func__,
+    [aResolver] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+      aResolver(aDescriptor.ToIPC());
+    }, [aResolver] (const CopyableErrorResult& aResult) {
+      aResolver(aResult);
+    });
+
+  return IPC_OK();
+}
+
 ServiceWorkerContainerParent::ServiceWorkerContainerParent()
 {
 }
 
 ServiceWorkerContainerParent::~ServiceWorkerContainerParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(!mProxy);
 }
diff --git a/dom/serviceworkers/ServiceWorkerContainerParent.h b/dom/serviceworkers/ServiceWorkerContainerParent.h
--- a/dom/serviceworkers/ServiceWorkerContainerParent.h
+++ b/dom/serviceworkers/ServiceWorkerContainerParent.h
@@ -21,16 +21,22 @@ class ServiceWorkerContainerParent final
 
   // PServiceWorkerContainerParent
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
+  mozilla::ipc::IPCResult
+  RecvRegister(const IPCClientInfo& aClientInfo, const nsCString& aScopeURL,
+               const nsCString& aScriptURL,
+               const ServiceWorkerUpdateViaCache& aUpdateViaCache,
+               RegisterResolver&& aResolver) override;
+
 public:
   ServiceWorkerContainerParent();
   ~ServiceWorkerContainerParent();
 
   void
   Init();
 };
 
diff --git a/dom/serviceworkers/ServiceWorkerContainerProxy.cpp b/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
--- a/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainerProxy.cpp
@@ -34,10 +34,41 @@ void
 ServiceWorkerContainerProxy::RevokeActor(ServiceWorkerContainerParent* aActor)
 {
   AssertIsOnBackgroundThread();
   MOZ_DIAGNOSTIC_ASSERT(mActor);
   MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
   mActor = nullptr;
 }
 
+RefPtr<ServiceWorkerRegistrationPromise>
+ServiceWorkerContainerProxy::Register(const ClientInfo& aClientInfo,
+                                      const nsCString& aScopeURL,
+                                      const nsCString& aScriptURL,
+                                      ServiceWorkerUpdateViaCache aUpdateViaCache)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ServiceWorkerRegistrationPromise::Private> promise =
+    new ServiceWorkerRegistrationPromise::Private(__func__);
+
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(__func__,
+    [aClientInfo, aScopeURL, aScriptURL, aUpdateViaCache, promise] () mutable {
+      auto scopeExit = MakeScopeExit([&] {
+        promise->Reject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
+      });
+
+      RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+      NS_ENSURE_TRUE_VOID(swm);
+
+      swm->Register(aClientInfo, aScopeURL, aScriptURL, aUpdateViaCache)
+         ->ChainTo(promise.forget(), __func__);
+
+      scopeExit.release();
+    });
+
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+  return promise;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerContainerProxy.h b/dom/serviceworkers/ServiceWorkerContainerProxy.h
--- a/dom/serviceworkers/ServiceWorkerContainerProxy.h
+++ b/dom/serviceworkers/ServiceWorkerContainerProxy.h
@@ -20,15 +20,20 @@ class ServiceWorkerContainerProxy final
   ~ServiceWorkerContainerProxy();
 
 public:
   explicit ServiceWorkerContainerProxy(ServiceWorkerContainerParent* aActor);
 
   void
   RevokeActor(ServiceWorkerContainerParent* aActor);
 
+  RefPtr<ServiceWorkerRegistrationPromise>
+  Register(const ClientInfo& aClientInfo, const nsCString& aScopeURL,
+           const nsCString& aScriptURL,
+           ServiceWorkerUpdateViaCache aUpdateViaCache);
+
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerContainerProxy);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // moz_dom_ServiceWorkerContainerProxy_h
