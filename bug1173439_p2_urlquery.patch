# HG changeset patch
# Parent 847efa715644a28583f6ec86edfe574d38664585
# User Ben Kelly <ben@wanderview.com>
Bug 1173439 P2 Parse Response URL query as a separate field. r=ehsan

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -36,17 +36,17 @@ namespace {
 bool
 IsValidPutRequestURL(const nsAString& aUrl, ErrorResult& aRv)
 {
   bool validScheme = false;
 
   // make a copy because ProcessURL strips the fragmet
   NS_ConvertUTF16toUTF8 url(aUrl);
 
-  TypeUtils::ProcessURL(url, &validScheme, nullptr, aRv);
+  TypeUtils::ProcessURL(url, &validScheme, nullptr, nullptr, aRv);
   if (aRv.Failed()) {
     return false;
   }
 
   if (!validScheme) {
     NS_NAMED_LITERAL_STRING(label, "Request");
     aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aUrl);
     return false;
diff --git a/dom/cache/CacheTypes.ipdlh b/dom/cache/CacheTypes.ipdlh
--- a/dom/cache/CacheTypes.ipdlh
+++ b/dom/cache/CacheTypes.ipdlh
@@ -50,16 +50,17 @@ struct HeadersEntry
   nsCString value;
 };
 
 struct CacheRequest
 {
   nsCString method;
   nsCString url;
   nsCString urlWithoutQuery;
+  nsCString urlQuery;
   HeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
   CacheReadStreamOrVoid body;
   uint32_t contentPolicyType;
   RequestCache requestCache;
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -258,16 +258,17 @@ CreateSchema(mozIStorageConnection* aCon
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE entries ("
         "id INTEGER NOT NULL PRIMARY KEY, "
         "request_method TEXT NOT NULL, "
         "request_url TEXT NOT NULL, "
         "request_url_no_query TEXT NOT NULL, "
+        "request_url_query TEXT NOT NULL, "
         "request_referrer TEXT NOT NULL, "
         "request_headers_guard INTEGER NOT NULL, "
         "request_mode INTEGER NOT NULL, "
         "request_credentials INTEGER NOT NULL, "
         "request_contentpolicytype INTEGER NOT NULL, "
         "request_cache INTEGER NOT NULL, "
         "request_body_id TEXT NULL, "
         "response_type INTEGER NOT NULL, "
@@ -1428,16 +1429,17 @@ InsertEntry(mozIStorageConnection* aConn
   }
 
   nsCOMPtr<mozIStorageStatement> state;
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO entries ("
       "request_method, "
       "request_url, "
       "request_url_no_query, "
+      "request_url_query, "
       "request_referrer, "
       "request_headers_guard, "
       "request_mode, "
       "request_credentials, "
       "request_contentpolicytype, "
       "request_cache, "
       "request_body_id, "
       "response_type, "
@@ -1449,16 +1451,17 @@ InsertEntry(mozIStorageConnection* aConn
       "response_security_info_id, "
       "response_redirected, "
       "response_redirected_url, "
       "cache_id "
     ") VALUES ("
       ":request_method, "
       ":request_url, "
       ":request_url_no_query, "
+      ":request_url_query, "
       ":request_referrer, "
       ":request_headers_guard, "
       ":request_mode, "
       ":request_credentials, "
       ":request_contentpolicytype, "
       ":request_cache, "
       ":request_body_id, "
       ":response_type, "
@@ -1482,16 +1485,20 @@ InsertEntry(mozIStorageConnection* aConn
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_url"),
                                    aRequest.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_url_no_query"),
                                    aRequest.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_url_query"),
+                                   aRequest.urlQuery());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
   rv = state->BindStringByName(NS_LITERAL_CSTRING("request_referrer"),
                                aRequest.referrer());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32ByName(NS_LITERAL_CSTRING("request_headers_guard"),
     static_cast<int32_t>(aRequest.headersGuard()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1740,16 +1747,17 @@ ReadRequest(mozIStorageConnection* aConn
   MOZ_ASSERT(aSavedRequestOut);
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "request_method, "
       "request_url, "
       "request_url_no_query, "
+      "request_url_query, "
       "request_referrer, "
       "request_headers_guard, "
       "request_mode, "
       "request_credentials, "
       "request_contentpolicytype, "
       "request_cache, "
       "request_body_id "
     "FROM entries "
@@ -1768,55 +1776,58 @@ ReadRequest(mozIStorageConnection* aConn
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->GetUTF8String(1, aSavedRequestOut->mValue.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->GetUTF8String(2, aSavedRequestOut->mValue.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->GetString(3, aSavedRequestOut->mValue.referrer());
+  rv = state->GetUTF8String(3, aSavedRequestOut->mValue.urlQuery());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->GetString(4, aSavedRequestOut->mValue.referrer());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t guard;
-  rv = state->GetInt32(4, &guard);
+  rv = state->GetInt32(5, &guard);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mValue.headersGuard() =
     static_cast<HeadersGuardEnum>(guard);
 
   int32_t mode;
-  rv = state->GetInt32(5, &mode);
+  rv = state->GetInt32(6, &mode);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mValue.mode() = static_cast<RequestMode>(mode);
 
   int32_t credentials;
-  rv = state->GetInt32(6, &credentials);
+  rv = state->GetInt32(7, &credentials);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mValue.credentials() =
     static_cast<RequestCredentials>(credentials);
 
   int32_t requestContentPolicyType;
-  rv = state->GetInt32(7, &requestContentPolicyType);
+  rv = state->GetInt32(8, &requestContentPolicyType);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mValue.contentPolicyType() =
     static_cast<nsContentPolicyType>(requestContentPolicyType);
 
   int32_t requestCache;
-  rv = state->GetInt32(8, &requestCache);
+  rv = state->GetInt32(9, &requestCache);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mValue.requestCache() =
     static_cast<RequestCache>(requestCache);
 
   bool nullBody = false;
-  rv = state->GetIsNull(9, &nullBody);
+  rv = state->GetIsNull(10, &nullBody);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedRequestOut->mHasBodyId = !nullBody;
 
   if (aSavedRequestOut->mHasBodyId) {
-    rv = ExtractId(state, 9, &aSavedRequestOut->mBodyId);
+    rv = ExtractId(state, 10, &aSavedRequestOut->mBodyId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "name, "
       "value "
     "FROM request_headers "
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -149,17 +149,18 @@ TypeUtils::ToCacheRequest(CacheRequest& 
 {
   MOZ_ASSERT(aIn);
 
   aIn->GetMethod(aOut.method());
 
   aIn->GetURL(aOut.url());
 
   bool schemeValid;
-  ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
+  ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(),
+             &aOut.urlQuery(), aRv);
   if (aRv.Failed()) {
     return;
   }
 
   if (!schemeValid) {
     if (aSchemeAction == TypeErrorOnInvalidScheme) {
       NS_NAMED_LITERAL_STRING(label, "Request");
       NS_ConvertUTF8toUTF16 url(aOut.url());
@@ -200,17 +201,17 @@ TypeUtils::ToCacheResponseWithoutBody(Ca
 {
   aOut.type() = aIn.Type();
 
   aIn.GetUrl(aOut.url());
 
   if (aOut.url() != EmptyCString()) {
     // Pass all Response URL schemes through... The spec only requires we take
     // action on invalid schemes for Request objects.
-    ProcessURL(aOut.url(), nullptr, nullptr, aRv);
+    ProcessURL(aOut.url(), nullptr, nullptr, nullptr, aRv);
     if (aRv.Failed()) {
       return;
     }
   }
 
   aOut.status() = aIn.GetStatus();
   aOut.statusText() = aIn.GetStatusText();
   nsRefPtr<InternalHeaders> headers = aIn.UnfilteredHeaders();
@@ -368,17 +369,18 @@ TypeUtils::ToInternalHeaders(const nsTAr
 }
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
 // static
 void
 TypeUtils::ProcessURL(nsACString& aUrl, bool* aSchemeValidOut,
-                      nsACString* aUrlWithoutQueryOut, ErrorResult& aRv)
+                      nsACString* aUrlWithoutQueryOut,nsACString* aUrlQueryOut,
+                      ErrorResult& aRv)
 {
   const nsAFlatCString& flatURL = PromiseFlatCString(aUrl);
   const char* url = flatURL.get();
 
   // off the main thread URL parsing using nsStdURLParser.
   nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
 
   uint32_t pathPos;
@@ -417,27 +419,29 @@ TypeUtils::ProcessURL(nsACString& aUrl, 
 
     aUrl = Substring(aUrl, 0, refPos - 1);
   }
 
   if (!aUrlWithoutQueryOut) {
     return;
   }
 
+  MOZ_ASSERT(aUrlQueryOut);
+
   if (queryLen < 0) {
     *aUrlWithoutQueryOut = aUrl;
+    *aUrlQueryOut = EmptyCString();
     return;
   }
 
   // ParsePath gives us query position relative to the start of the path
   queryPos += pathPos;
 
-  // We want everything before the query sine we already removed the trailing
-  // fragment
   *aUrlWithoutQueryOut = Substring(aUrl, 0, queryPos - 1);
+  *aUrlQueryOut = Substring(aUrl, queryPos - 1, queryLen + 1);
 }
 
 void
 TypeUtils::CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                                ErrorResult& aRv)
 {
   MOZ_ASSERT(aRequest);
 
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -103,21 +103,26 @@ public:
   // Utility method for parsing a URL and doing associated operations.  A mix
   // of things are done in this one method to avoid duplicated parsing:
   //
   //  1) The aUrl argument is modified to strip the fragment
   //  2) If aSchemaValidOut is set, then a boolean value is set indicating
   //     if the aUrl's scheme is valid or not for storing in the cache.
   //  3) If aUrlWithoutQueryOut is set, then a url string is provided without
   //     the search section.
+  //  4) If aUrlQueryOut is set then its populated with the search section
+  //     of the URL.  Note, this parameter must be set if aUrlWithoutQueryOut
+  //     is set.  They must either both be nullptr or set to valid string
+  //     pointers.
   //
   // Any errors are thrown on ErrorResult.
   static void
   ProcessURL(nsACString& aUrl, bool* aSchemeValidOut,
-             nsACString* aUrlWithoutQueryOut, ErrorResult& aRv);
+             nsACString* aUrlWithoutQueryOut, nsACString* aUrlQueryOut,
+             ErrorResult& aRv);
 
 private:
   void
   CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                       ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const nsAString& aIn, ErrorResult& aRv);
