# HG changeset patch
# Parent 1f87da3eaba57a1c3ea1b946cf63f35c7c4a8d72
# User Ben Kelly <ben@wanderview.com>
Bug 1133939 P2 interdiff 003 fix try build errors on non-debug and windows


diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -782,17 +782,17 @@ TEST(Pipes, Write_AsyncWait_Clone_CloseO
 
   reader->Close();
 
   ASSERT_TRUE(cb->Called());
 }
 
 namespace {
 
-nsresult
+NS_METHOD
 CloseDuringReadFunc(nsIInputStream *aReader,
                     void* aClosure,
                     const char* aFromSegment,
                     uint32_t aToOffset,
                     uint32_t aCount,
                     uint32_t* aWriteCountOut)
 {
   MOZ_ASSERT(aReader);
@@ -801,18 +801,17 @@ CloseDuringReadFunc(nsIInputStream *aRea
   MOZ_ASSERT(aWriteCountOut);
   MOZ_ASSERT(aToOffset == 0);
 
   // This is insanity and you probably should not do this under normal
   // conditions.  We want to simulate the case where the pipe is closed
   // (possibly from other end on another thread) simultaneously with the
   // read.  This is the easiest way to do trigger this case in a synchronous
   // gtest.
-  nsresult rv = aReader->Close();
-  MOZ_ASSERT(NS_SUCCEEDED(rv));
+  MOZ_ALWAYS_TRUE(NS_SUCCEEDED(aReader->Close()));
 
   nsTArray<char>* buffer = static_cast<nsTArray<char>*>(aClosure);
   buffer->AppendElements(aFromSegment, aCount);
 
   *aWriteCountOut = aCount;
 
   return NS_OK;
 }
