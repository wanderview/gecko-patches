# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  72d9d47bd7fb1ff678c7230962158dd6071f8f40
Bug 1273070 P1 Fix fetch() WorkerRunnable classes to allow it to work with nested Workers. r=khuey

diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -266,17 +266,17 @@ class WorkerFetchResponseRunnable final 
 {
   RefPtr<WorkerFetchResolver> mResolver;
   // Passed from main thread to worker thread after being initialized.
   RefPtr<InternalResponse> mInternalResponse;
 public:
   WorkerFetchResponseRunnable(WorkerPrivate* aWorkerPrivate,
                               WorkerFetchResolver* aResolver,
                               InternalResponse* aResponse)
-    : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+    : WorkerRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
     , mResolver(aResolver)
     , mInternalResponse(aResponse)
   {
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
@@ -291,16 +291,35 @@ public:
       promise->MaybeResolve(response);
     } else {
       ErrorResult result;
       result.ThrowTypeError<MSG_FETCH_FAILED>();
       promise->MaybeReject(result);
     }
     return true;
   }
+
+  bool
+  PreDispatch(WorkerPrivate* aWorkerPrivate) override
+  {
+    // Don't call default PreDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+    return true;
+  }
+
+  void
+  PostDispatch(WorkerPrivate* aWorkerPrivate, bool aDispatchResult) override
+  {
+    // Don't call default PostDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+  }
 };
 
 class WorkerFetchResponseEndBase
 {
   RefPtr<PromiseWorkerProxy> mPromiseProxy;
 public:
   explicit WorkerFetchResponseEndBase(PromiseWorkerProxy* aPromiseProxy)
     : mPromiseProxy(aPromiseProxy)
@@ -318,17 +337,17 @@ public:
 };
 
 class WorkerFetchResponseEndRunnable final : public WorkerRunnable
                                            , public WorkerFetchResponseEndBase
 {
 public:
   explicit WorkerFetchResponseEndRunnable(PromiseWorkerProxy* aPromiseProxy)
     : WorkerRunnable(aPromiseProxy->GetWorkerPrivate(),
-                     WorkerThreadModifyBusyCount)
+                     WorkerThreadUnchangedBusyCount)
     , WorkerFetchResponseEndBase(aPromiseProxy)
   {
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     WorkerRunInternal(aWorkerPrivate);
@@ -338,25 +357,43 @@ public:
   nsresult
   Cancel() override
   {
     // Execute Run anyway to make sure we cleanup our promise proxy to avoid
     // leaking the worker thread
     Run();
     return WorkerRunnable::Cancel();
   }
+
+  bool
+  PreDispatch(WorkerPrivate* aWorkerPrivate) override
+  {
+    // Don't call default PreDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+    return true;
+  }
+
+  void
+  PostDispatch(WorkerPrivate* aWorkerPrivate, bool aDispatchResult) override
+  {
+    // Don't call default PostDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+  }
 };
 
-class WorkerFetchResponseEndControlRunnable final : public WorkerControlRunnable
+class WorkerFetchResponseEndControlRunnable final : public MainThreadWorkerControlRunnable
                                                   , public WorkerFetchResponseEndBase
 {
 public:
   explicit WorkerFetchResponseEndControlRunnable(PromiseWorkerProxy* aPromiseProxy)
-    : WorkerControlRunnable(aPromiseProxy->GetWorkerPrivate(),
-                            WorkerThreadUnchangedBusyCount)
+    : MainThreadWorkerControlRunnable(aPromiseProxy->GetWorkerPrivate())
     , WorkerFetchResponseEndBase(aPromiseProxy)
   {
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     WorkerRunInternal(aWorkerPrivate);
@@ -584,31 +621,50 @@ class ContinueConsumeBodyRunnable final 
   FetchBody<Derived>* mFetchBody;
   nsresult mStatus;
   uint32_t mLength;
   uint8_t* mResult;
 
 public:
   ContinueConsumeBodyRunnable(FetchBody<Derived>* aFetchBody, nsresult aStatus,
                               uint32_t aLength, uint8_t* aResult)
-    : WorkerRunnable(aFetchBody->mWorkerPrivate, WorkerThreadModifyBusyCount)
+    : WorkerRunnable(aFetchBody->mWorkerPrivate, WorkerThreadUnchangedBusyCount)
     , mFetchBody(aFetchBody)
     , mStatus(aStatus)
     , mLength(aLength)
     , mResult(aResult)
   {
     MOZ_ASSERT(NS_IsMainThread());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     mFetchBody->ContinueConsumeBody(mStatus, mLength, mResult);
     return true;
   }
+
+  bool
+  PreDispatch(WorkerPrivate* aWorkerPrivate) override
+  {
+    // Don't call default PreDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+    return true;
+  }
+
+  void
+  PostDispatch(WorkerPrivate* aWorkerPrivate, bool aDispatchResult) override
+  {
+    // Don't call default PostDispatch() since it incorrectly asserts we are
+    // dispatching from the parent worker thread.  We always dispatch from
+    // the main thread.
+    AssertIsOnMainThread();
+  }
 };
 
 // OnStreamComplete always adopts the buffer, utility class to release it in
 // a couple of places.
 class MOZ_STACK_CLASS AutoFreeBuffer final {
   uint8_t* mBuffer;
 
 public:
