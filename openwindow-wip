# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d943ca1bdac4c694d616ef8e4ec1941efa47510c

diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -199,19 +199,67 @@ Clients::MatchAll(const ClientQueryOptio
     });
 
   return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Clients::OpenWindow(const nsAString& aURL, ErrorResult& aRv)
 {
-  // TODO: OMG this will take a lot of work
-  aRv.Throw(NS_ERROR_FAILURE);
-  return nullptr;
+  RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
+  if (aRv.Failed()) {
+    return outerPromise.forget();
+  }
+
+  PrincipalInfo principalInfo;
+  nsCString baseURL;
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
+  if (window) {
+    nsCOMPtr<nsIURI> uri = window->GetDocBaseURI();
+    if (uri) {
+      Unused << uri->GetSpec(baseURL);
+    }
+    nsIDocument* doc = window->GetExtantDoc();
+    if (doc) {
+      nsIPrincipal* principal = doc->NodePrincipal();
+      if (principal) {
+        aRv = PrincipalToPrincipalInfo(principal, &principalInfo);
+        if (aRv.Failed()) {
+          return outerPromise.forget();
+        }
+      }
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      baseURL = workerPrivate->GetLocationInfo().mHref;
+      principalInfo = workerPrivate->GetPrincipalInfo();
+    }
+  }
+
+  nsCOMPtr<nsIGlobalObject> global = mGlobal;
+
+  ClientOpenWindowArgs args(principalInfo, NS_ConvertUTF16toUTF8(aURL), baseURL);
+  RefPtr<ClientOpPromise> innerPromise = ClientManager::OpenWindow(args);
+  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    [outerPromise, global] (const ClientOpResult& aResult) {
+      if (aResult.type() != ClientOpResult::TClientInfoAndState) {
+        outerPromise->MaybeResolve(JS::NullHandleValue);
+        return;
+      }
+      RefPtr<Client> client =
+        new Client(global, aResult.get_ClientInfoAndState());
+      outerPromise->MaybeResolve(client);
+    }, [outerPromise] (nsresult aResult) {
+      // TODO: get type error and message from site of error
+      outerPromise->MaybeReject(NS_ERROR_TYPE_ERR);
+    });
+
+  return outerPromise.forget();
 }
 
 already_AddRefed<Promise>
 Clients::Claim(ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -1,21 +1,21 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PClientSource;
 include DOMTypes;
 include PBackgroundSharedTypes;
 include ServiceWorkerDescriptor;
+include ProtocolTypes;
 using class mozilla::TimeStamp from "mozilla/TimeStamp.h";
 using ClientType from "mozilla/dom/ClientIPCUtils.h";
 using FrameType from "mozilla/dom/ClientIPCUtils.h";
 using VisibilityState from "mozilla/dom/ClientIPCUtils.h";
-using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
 
 struct ClientSourceConstructorArgs
 {
   nsID id;
   ClientType type;
@@ -108,26 +108,34 @@ struct ClientClaimArgs
 };
 
 struct ClientGetInfoAndStateArgs
 {
   nsID id;
   PrincipalInfo principalInfo;
 };
 
+struct ClientOpenWindowArgs
+{
+  PrincipalInfo principalInfo;
+  nsCString url;
+  nsCString baseURL;
+};
+
 union ClientOpConstructorArgs
 {
   ClientControlledArgs;
   ClientFocusArgs;
   ClientNavigateArgs;
   ClientPostMessageArgs;
   ClientGetStateArgs;
   ClientMatchAllArgs;
   ClientClaimArgs;
   ClientGetInfoAndStateArgs;
+  ClientOpenWindowArgs;
 };
 
 struct ClientList
 {
   ClientInfoAndState[] values;
 };
 
 struct ClientNavigateOpConstructorArgs
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -364,10 +364,18 @@ ClientManager::GetInfoAndState(const Cli
 // static
 already_AddRefed<ClientOpPromise>
 ClientManager::Navigate(const ClientNavigateArgs& aArgs)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->StartOp(aArgs);
 }
 
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::OpenWindow(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -93,15 +93,18 @@ public:
   Claim(const ClientClaimArgs& aArgs);
 
   static already_AddRefed<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
   static already_AddRefed<ClientOpPromise>
   Navigate(const ClientNavigateArgs& aArgs);
 
+  static already_AddRefed<ClientOpPromise>
+  OpenWindow(const ClientOpenWindowArgs& aArgs);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -64,16 +64,22 @@ ClientManagerOpParent::Init(const Client
       break;
     }
     case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
     {
       DoServiceOp(&ClientManagerService::GetInfoAndState,
                   aArgs.get_ClientGetInfoAndStateArgs());
       break;
     }
+    case ClientOpConstructorArgs::TClientOpenWindowArgs:
+    {
+      DoServiceOp(&ClientManagerService::OpenWindow,
+                  aArgs.get_ClientOpenWindowArgs());
+      break;
+    }
     default:
     {
       MOZ_ASSERT_UNREACHABLE("Unknown Client operation!");
       break;
     }
   }
 }
 
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -2,17 +2,22 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManagerService.h"
 
 #include "ClientNavigateOpParent.h"
+#include "ClientOpenWindowOpParent.h"
+#include "ClientOpenWindowUtils.h"
+#include "mozilla/dom/ContentParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/Unused.h"
+#include "nsIXULRuntime.h"
 #include "nsURLParsers.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 using mozilla::ipc::ContentPrincipalInfo;
 
@@ -410,10 +415,73 @@ ClientManagerService::GetInfoAndState(co
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
     return ref.forget();
   }
 
   // TODO: maybe change this to just GetState from source and use local info?
   return source->StartOp(aArgs);
 }
 
+namespace {
+
+class OpenWindowRunnable : public Runnable
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+  RefPtr<AbstractThread> mTarget;
+  const ClientOpenWindowArgs mArgs;
+
+public:
+  OpenWindowRunnable(ClientOpPromise::Private* aPromise,
+                     AbstractThread* aTarget,
+                     const ClientOpenWindowArgs& aArgs)
+    : mPromise(aPromise)
+    , mArgs(aArgs)
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mPromise);
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    if (!BrowserTabsRemoteAutostart()) {
+      RefPtr<ClientOpPromise> p = ClientOpenWindowInCurrentProcess(mArgs);
+      p->ChainTo(mPromise.forget(), __func__);
+      return NS_OK;
+    }
+
+    RefPtr<ContentParent> contentParent =
+      ContentParent::GetNewOrUsedBrowserProcess(NS_LITERAL_STRING(DEFAULT_REMOTE_TYPE),
+                                                ContentParent::GetInitialProcessPriority(nullptr),
+                                                nullptr);
+
+    ClientOpenWindowOpParent* actor =
+      new ClientOpenWindowOpParent(mArgs, mPromise);
+
+    // If this fails the actor will be automatically destroyed which will
+    // reject the promise.
+    Unused << contentParent->SendPClientOpenWindowOpConstructor(actor, mArgs);
+
+    return NS_OK;
+  }
+};
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientManagerService::OpenWindow(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise::Private> promise =
+    new ClientOpPromise::Private(__func__);
+
+  // TODO: How do we clean this up if bg thread and main thread shutdown?
+
+  nsCOMPtr<nsIRunnable> r =
+    new OpenWindowRunnable(promise, mBackgroundThread, aArgs);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
+
+  RefPtr<ClientOpPromise> ref = promise;
+  return ref.forget();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -55,15 +55,18 @@ public:
   MatchAll(const ClientMatchAllArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
+  already_AddRefed<ClientOpPromise>
+  OpenWindow(const ClientOpenWindowArgs& aArgs);
+
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManagerService)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManagerService_h
diff --git a/dom/clients/manager/ClientOpenWindowOpActors.cpp b/dom/clients/manager/ClientOpenWindowOpActors.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpActors.cpp
@@ -0,0 +1,52 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientOpenWindowOpActors.h"
+
+#include "ClientOpenWindowOpChild.h"
+#include "mozilla/dom/PClientOpenWindowOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+PClientOpenWindowOpChild*
+AllocClientOpenWindowOpChild()
+{
+  return new ClientOpenWindowOpChild();
+}
+
+void
+InitClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor,
+                            const ClientOpenWindowArgs& aArgs)
+{
+  auto actor = static_cast<ClientOpenWindowOpChild*>(aActor);
+  actor->Init(aArgs);
+}
+
+bool
+DeallocClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+PClientOpenWindowOpParent*
+AllocClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs)
+{
+  MOZ_CRASH("ClientOpenWindowOpParent must be explicitly allocated");
+  return nullptr;
+}
+
+bool
+DeallocClientOpenWindowOpParent(PClientOpenWindowOpParent* aActor)
+{
+  delete aActor;
+  return true;
+}
+
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpActors.h b/dom/clients/manager/ClientOpenWindowOpActors.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpActors.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpenWindowOpActors_h
+#define _mozilla_dom_ClientOpenWindowOpActors_h
+
+namespace mozilla {
+namespace dom {
+
+class ClientOpenWindowArgs;
+class PClientOpenWindowOpChild;
+class PClientOpenWindowOpParent;
+
+PClientOpenWindowOpChild*
+AllocClientOpenWindowOpChild();
+
+void
+InitClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor,
+                            const ClientOpenWindowArgs& aArgs);
+
+bool
+DeallocClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor);
+
+PClientOpenWindowOpParent*
+AllocClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs);
+
+bool
+DeallocClientOpenWindowOpParent(PClientOpenWindowOpParent* aActor);
+
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpenWindowOpActors_h
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -0,0 +1,42 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientOpenWindowOpChild.h"
+#include "ClientOpenWindowUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowOpChild::DoOpenWindow(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref =
+    ClientOpenWindowInCurrentProcess(aArgs);
+  return ref.forget();
+}
+
+void
+ClientOpenWindowOpChild::ActorDestroy(ActorDestroyReason aReason)
+{
+  mPromiseRequestHolder.DisconnectIfExists();
+}
+
+void
+ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+    [this] (const ClientOpResult& aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientOpenWindowOpChild::Send__delete__(this, aResult);
+    }, [this] (nsresult aResult) {
+      mPromiseRequestHolder.Complete();
+      PClientOpenWindowOpChild::Send__delete__(this, aResult);
+    })->Track(mPromiseRequestHolder);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.h b/dom/clients/manager/ClientOpenWindowOpChild.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpChild.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpenWindowOpChild_h
+#define _mozilla_dom_ClientOpenWindowOpChild_h
+
+#include "mozilla/dom/PClientOpenWindowOpChild.h"
+#include "ClientOpPromise.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientSource;
+
+class ClientOpenWindowOpChild final : public PClientOpenWindowOpChild
+{
+  MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+
+  already_AddRefed<ClientOpPromise>
+  DoOpenWindow(const ClientOpenWindowArgs& aArgs);
+
+  // PClientOpenWindowOpChild interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+public:
+  ClientOpenWindowOpChild() = default;
+  ~ClientOpenWindowOpChild() = default;
+
+  void
+  Init(const ClientOpenWindowArgs& aArgs);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpenWindowOpChild_h
diff --git a/dom/clients/manager/ClientOpenWindowOpParent.cpp b/dom/clients/manager/ClientOpenWindowOpParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpParent.cpp
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientOpenWindowOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::IPCResult;
+
+void
+ClientOpenWindowOpParent::ActorDestroy(ActorDestroyReason aReason)
+{
+  if (mPromise) {
+    mPromise->Reject(NS_ERROR_ABORT, __func__);
+    mPromise = nullptr;
+  }
+}
+
+IPCResult
+ClientOpenWindowOpParent::Recv__delete__(const ClientOpResult& aResult)
+{
+  if (aResult.type() == ClientOpResult::Tnsresult &&
+      NS_FAILED(aResult.get_nsresult())) {
+    mPromise->Reject(aResult.get_nsresult(), __func__);
+    mPromise = nullptr;
+    return IPC_OK();
+  }
+  mPromise->Resolve(aResult, __func__);
+  mPromise = nullptr;
+  return IPC_OK();
+}
+
+ClientOpenWindowOpParent::ClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs,
+                                                   ClientOpPromise::Private* aPromise)
+  : mPromise(aPromise)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mPromise);
+}
+
+ClientOpenWindowOpParent::~ClientOpenWindowOpParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mPromise);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowOpParent.h b/dom/clients/manager/ClientOpenWindowOpParent.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowOpParent.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpenWindowOpParent_h
+#define _mozilla_dom_ClientOpenWindowOpParent_h
+
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/PClientOpenWindowOpParent.h"
+
+namespace mozilla {
+namespace dom {
+
+class ClientOpenWindowOpParent final : public PClientOpenWindowOpParent
+{
+  RefPtr<ClientOpPromise::Private> mPromise;
+
+  // PClientOpenWindowOpParent interface
+  void
+  ActorDestroy(ActorDestroyReason aReason) override;
+
+  mozilla::ipc::IPCResult
+  Recv__delete__(const ClientOpResult& aResult) override;
+
+public:
+  ClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs,
+                           ClientOpPromise::Private* aPromise);
+
+  ~ClientOpenWindowOpParent();
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpenWindowOpParent_h
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -0,0 +1,320 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientOpenWindowUtils.h"
+
+#include "nsContentUtils.h"
+#include "nsIBrowserDOMWindow.h"
+#include "nsIDocShell.h"
+#include "nsIDOMChromeWindow.h"
+#include "nsIURI.h"
+#include "nsIWebProgress.h"
+#include "nsIWebProgressListener.h"
+#include "nsIWindowWatcher.h"
+#include "nsNetUtil.h"
+#include "nsPIDOMWindow.h"
+#include "nsPIWindowWatcher.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+class WebProgressListener final : public nsIWebProgressListener
+                                , public nsSupportsWeakReference
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  WebProgressListener(nsPIDOMWindowOuter* aWindow,
+                      nsIURI* aBaseURI)
+  : mPromise(new ClientOpPromise::Private(__func__))
+  , mWindow(aWindow)
+  , mBaseURI(aBaseURI)
+  {
+    MOZ_ASSERT(aWindow);
+    MOZ_ASSERT(aWindow->IsOuterWindow());
+    MOZ_ASSERT(aBaseURI);
+    MOZ_ASSERT(NS_IsMainThread());
+  }
+
+  ClientOpPromise*
+  Promise() const
+  {
+    return mPromise;
+  }
+
+  NS_IMETHOD
+  OnStateChange(nsIWebProgress* aWebProgress,
+                nsIRequest* aRequest,
+                uint32_t aStateFlags, nsresult aStatus) override
+  {
+    if (!(aStateFlags & STATE_IS_DOCUMENT) ||
+         !(aStateFlags & (STATE_STOP | STATE_TRANSFERRING))) {
+      return NS_OK;
+    }
+
+    // Our caller keeps a strong reference, so it is safe to remove the listener
+    // from ServiceWorkerPrivate.
+    aWebProgress->RemoveProgressListener(this);
+
+    nsCOMPtr<nsIDocument> doc = mWindow->GetExtantDoc();
+    if (NS_WARN_IF(!doc)) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    // Check same origin.
+    nsCOMPtr<nsIScriptSecurityManager> securityManager =
+      nsContentUtils::GetSecurityManager();
+    nsresult rv = securityManager->CheckSameOriginURI(doc->GetOriginalURI(),
+                                                      mBaseURI, false);
+    if (NS_FAILED(rv)) {
+      mPromise->Resolve(NS_OK, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
+    if (NS_WARN_IF(!innerWindow)) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    Maybe<ClientInfo> info = innerWindow->GetClientInfo();
+    Maybe<ClientState> state = innerWindow->GetClientState();
+
+    if (NS_WARN_IF(info.isNothing() || state.isNothing())) {
+      mPromise->Reject(NS_ERROR_FAILURE, __func__);
+      mPromise = nullptr;
+      return NS_OK;
+    }
+
+    mPromise->Resolve(ClientInfoAndState(info.ref(), state.ref()), __func__);
+    mPromise = nullptr;
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnProgressChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   int32_t aCurSelfProgress,
+                   int32_t aMaxSelfProgress,
+                   int32_t aCurTotalProgress,
+                   int32_t aMaxTotalProgress) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnLocationChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   nsIURI* aLocation,
+                   uint32_t aFlags) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnStatusChange(nsIWebProgress* aWebProgress,
+                 nsIRequest* aRequest,
+                 nsresult aStatus, const char16_t* aMessage) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  OnSecurityChange(nsIWebProgress* aWebProgress,
+                   nsIRequest* aRequest,
+                   uint32_t aState) override
+  {
+    MOZ_ASSERT(false, "Unexpected notification.");
+    return NS_OK;
+  }
+
+private:
+  ~WebProgressListener()
+  {
+    if (mPromise) {
+      mPromise->Reject(NS_ERROR_ABORT, __func__);
+      mPromise = nullptr;
+    }
+  }
+
+  RefPtr<ClientOpPromise::Private> mPromise;
+  // TODO: make window a weak ref and stop cycle collecting
+  nsCOMPtr<nsPIDOMWindowOuter> mWindow;
+  nsCOMPtr<nsIURI> mBaseURI;
+};
+
+NS_IMPL_ISUPPORTS(WebProgressListener, nsIWebProgressListener,
+                                       nsISupportsWeakReference);
+
+nsresult
+OpenWindow(const ClientOpenWindowArgs& aArgs,
+           nsPIDOMWindowOuter** aWindow)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aWindow);
+
+  // [[1. Let url be the result of parsing url with entry settings object's API
+  //   base URL.]]
+  nsCOMPtr<nsIURI> uri;
+
+  nsCOMPtr<nsIURI> baseURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NS_ERROR_TYPE_ERR;
+  }
+
+  rv = NS_NewURI(getter_AddRefs(uri), aArgs.url(), nullptr, baseURI);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return NS_ERROR_TYPE_ERR;
+  }
+
+  // [[6.1 Open Window]]
+  if (XRE_IsContentProcess()) {
+    // ContentProcess
+    nsCOMPtr<nsIWindowWatcher> wwatch =
+      do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+    nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
+    NS_ENSURE_STATE(pwwatch);
+
+    nsCString spec;
+    rv = uri->GetSpec(spec);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    nsCOMPtr<mozIDOMWindowProxy> newWindow;
+    rv = pwwatch->OpenWindow2(nullptr,
+                              spec.get(),
+                              nullptr,
+                              nullptr,
+                              false, false, true, nullptr,
+                              // Not a spammy popup; we got permission, we swear!
+                              /* aIsPopupSpam = */ false,
+                              // Don't force noopener.  We're not passing in an
+                              // opener anyway, and we _do_ want the returned
+                              // window.
+                              /* aForceNoOpener = */ false,
+                              /* aLoadInfp = */ nullptr,
+                              getter_AddRefs(newWindow));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+    nsCOMPtr<nsPIDOMWindowOuter> pwindow = nsPIDOMWindowOuter::From(newWindow);
+    pwindow.forget(aWindow);
+    MOZ_DIAGNOSTIC_ASSERT(*aWindow);
+    return NS_OK;
+  }
+
+  // Find the most recent browser window and open a new tab in it.
+  nsCOMPtr<nsPIDOMWindowOuter> browserWindow =
+    nsContentUtils::GetMostRecentNonPBWindow();
+  if (!browserWindow) {
+    // It is possible to be running without a browser window on Mac OS, so
+    // we need to open a new chrome window.
+    // TODO(catalinb): open new chrome window. Bug 1218080
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  nsCOMPtr<nsIDOMChromeWindow> chromeWin = do_QueryInterface(browserWindow);
+  if (NS_WARN_IF(!chromeWin)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<nsIBrowserDOMWindow> bwin;
+  chromeWin->GetBrowserDOMWindow(getter_AddRefs(bwin));
+
+  if (NS_WARN_IF(!bwin)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsCOMPtr<mozIDOMWindowProxy> win;
+  rv = bwin->OpenURI(uri, nullptr,
+                     nsIBrowserDOMWindow::OPEN_DEFAULTWINDOW,
+                     nsIBrowserDOMWindow::OPEN_NEW,
+                     getter_AddRefs(win));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  NS_ENSURE_STATE(win);
+
+  nsCOMPtr<nsPIDOMWindowOuter> pWin = nsPIDOMWindowOuter::From(win);
+  pWin.forget(aWindow);
+  MOZ_DIAGNOSTIC_ASSERT(*aWindow);
+
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs& aArgs)
+{
+  RefPtr<ClientOpPromise> ref;
+
+  nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
+  nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(outerWindow);
+
+  rv = nsContentUtils::DispatchFocusChromeEvent(outerWindow);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIURI> baseURI;
+  rv = NS_NewURI(getter_AddRefs(baseURI), aArgs.baseURL());
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  nsCOMPtr<nsIDocShell> docShell = outerWindow->GetDocShell();
+  nsCOMPtr<nsIWebProgress> webProgress = do_GetInterface(docShell);
+
+  if (NS_WARN_IF(!webProgress)) {
+    ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
+    return ref.forget();
+  }
+
+  RefPtr<WebProgressListener> listener =
+    new WebProgressListener(outerWindow, baseURI);
+
+  ref = listener->Promise();
+
+  rv = webProgress->AddProgressListener(listener,
+                                        nsIWebProgress::NOTIFY_STATE_DOCUMENT);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    ref = ClientOpPromise::CreateAndReject(rv, __func__);
+    return ref.forget();
+  }
+
+  // Hold the listener alive until the promise settles
+  ref->Then(AbstractThread::GetCurrent(), __func__,
+    [listener] (const ClientOpResult& aResult) { },
+    [listener] (nsresult aResult) { });
+
+  return ref.forget();
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientOpenWindowUtils.h b/dom/clients/manager/ClientOpenWindowUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientOpenWindowUtils.h
@@ -0,0 +1,21 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientOpenWindowUtils_h
+#define _mozilla_dom_ClientOpenWindowUtils_h
+
+#include "ClientOpPromise.h"
+#include "mozilla/dom/ClientIPCTypes.h"
+
+namespace mozilla {
+namespace dom {
+
+already_AddRefed<ClientOpPromise>
+ClientOpenWindowInCurrentProcess(const ClientOpenWindowArgs &aArgs);
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientOpenWindowUtils_h
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -1,35 +1,41 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSource.h"
 
+#include "ClientManager.h"
+#include "ClientManagerChild.h"
+#include "ClientSourceChild.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "mozilla/dom/ServiceWorkerContainer.h"
 #include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
+#include "nsGlobalWindow.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
 using mozilla::dom::workers::ServiceWorkerInfo;
 using mozilla::dom::workers::ServiceWorkerManager;
 using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
 using mozilla::dom::workers::WorkerPrivate;
+using mozilla::ipc::PrincipalInfo;
+using mozilla::ipc::PrincipalInfoToPrincipal;
 
 void
 ClientSource::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
   if (IsShutdown()) {
     return;
   }
diff --git a/dom/clients/manager/ClientSourceChild.cpp b/dom/clients/manager/ClientSourceChild.cpp
--- a/dom/clients/manager/ClientSourceChild.cpp
+++ b/dom/clients/manager/ClientSourceChild.cpp
@@ -1,22 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceChild.h"
 
+#include "ClientSource.h"
 #include "ClientSourceOpChild.h"
 #include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::IPCResult;
+
 void
 ClientSourceChild::ActorDestroy(ActorDestroyReason aReason)
 {
   if (mSource) {
     mSource->RevokeActor(this);
     MOZ_ASSERT(!mSource);
   }
 }
diff --git a/dom/clients/manager/PClientOpenWindowOp.ipdl b/dom/clients/manager/PClientOpenWindowOp.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/PClientOpenWindowOp.ipdl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PContent;
+include ClientIPCTypes;
+
+namespace mozilla {
+namespace dom {
+
+protocol PClientOpenWindowOp
+{
+  manager PContent;
+
+parent:
+  async __delete__(ClientOpResult aResult);
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -4,16 +4,17 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
   'ClientHandle.h',
   'ClientIPCUtils.h',
   'ClientManager.h',
   'ClientManagerActors.h',
+  'ClientOpenWindowOpActors.h',
   'ClientOpPromise.h',
   'ClientSource.h',
   'ClientThing.h',
   'ReservedClientHelper.h',
 ]
 
 UNIFIED_SOURCES += [
   'ClientHandle.cpp',
@@ -25,31 +26,36 @@ UNIFIED_SOURCES += [
   'ClientManagerActors.cpp',
   'ClientManagerChild.cpp',
   'ClientManagerOpChild.cpp',
   'ClientManagerOpParent.cpp',
   'ClientManagerParent.cpp',
   'ClientManagerService.cpp',
   'ClientNavigateOpChild.cpp',
   'ClientNavigateOpParent.cpp',
+  'ClientOpenWindowOpActors.cpp',
+  'ClientOpenWindowOpChild.cpp',
+  'ClientOpenWindowOpParent.cpp',
+  'ClientOpenWindowUtils.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ReservedClientHelper.cpp',
 ]
 
 IPDL_SOURCES += [
   'ClientIPCTypes.ipdlh',
   'PClientHandle.ipdl',
   'PClientHandleOp.ipdl',
   'PClientManager.ipdl',
   'PClientManagerOp.ipdl',
   'PClientNavigateOp.ipdl',
+  'PClientOpenWindowOp.ipdl',
   'PClientSource.ipdl',
   'PClientSourceOp.ipdl',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
   '/dom/base',
diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -133,16 +133,17 @@ MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLAT
                                           PRFileDesc,
                                           PR_Close);
 
 namespace dom {
 namespace indexedDB {
 
 using namespace mozilla::dom::quota;
 using namespace mozilla::ipc;
+using mozilla::dom::quota::Client;
 
 namespace {
 
 class ConnectionPool;
 class Cursor;
 class Database;
 struct DatabaseActorInfo;
 class DatabaseFile;
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -17,16 +17,17 @@
 #include "mozilla/Attributes.h"
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/ProcessHangMonitorIPC.h"
 #include "mozilla/Unused.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperChild.h"
 #include "mozilla/docshell/OfflineCacheUpdateChild.h"
 #include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientOpenWindowOpActors.h"
 #include "mozilla/dom/ContentBridgeChild.h"
 #include "mozilla/dom/ContentBridgeParent.h"
 #include "mozilla/dom/VideoDecoderManagerChild.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/DocGroup.h"
 #include "mozilla/dom/ExternalHelperAppChild.h"
 #include "mozilla/dom/FileCreatorHelper.h"
@@ -3349,10 +3350,30 @@ ContentChild::RecvSetPermissionsWithKey(
 mozilla::ipc::IPCResult
 ContentChild::RecvRefreshScreens(nsTArray<ScreenDetails>&& aScreens)
 {
   ScreenManager& screenManager = ScreenManager::GetSingleton();
   screenManager.Refresh(Move(aScreens));
   return IPC_OK();
 }
 
+PClientOpenWindowOpChild*
+ContentChild::AllocPClientOpenWindowOpChild(const ClientOpenWindowArgs& aArgs)
+{
+  return AllocClientOpenWindowOpChild();
+}
+
+IPCResult
+ContentChild::RecvPClientOpenWindowOpConstructor(PClientOpenWindowOpChild* aActor,
+                                                 const ClientOpenWindowArgs& aArgs)
+{
+  InitClientOpenWindowOpChild(aActor, aArgs);
+  return IPC_OK();
+}
+
+bool
+ContentChild::DeallocPClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor)
+{
+  return DeallocClientOpenWindowOpChild(aActor);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -649,16 +649,26 @@ public:
                       const nsAString& aFullPath, const nsAString& aType,
                       const nsAString& aName,
                       const Optional<int64_t>& aLastModified,
                       bool aExistenceCheck, bool aIsFromNsIFile);
 
   typedef std::function<void(PRFileDesc*)> AnonymousTemporaryFileCallback;
   nsresult AsyncOpenAnonymousTemporaryFile(AnonymousTemporaryFileCallback aCallback);
 
+  virtual PClientOpenWindowOpChild*
+  AllocPClientOpenWindowOpChild(const ClientOpenWindowArgs& aArgs) override;
+
+  virtual mozilla::ipc::IPCResult
+  RecvPClientOpenWindowOpConstructor(PClientOpenWindowOpChild* aActor,
+                                     const ClientOpenWindowArgs& aArgs) override;
+
+  virtual bool
+  DeallocPClientOpenWindowOpChild(PClientOpenWindowOpChild* aActor) override;
+
 private:
   static void ForceKillTimerCallback(nsITimer* aTimer, void* aClosure);
   void StartForceKillTimer();
 
   virtual void ActorDestroy(ActorDestroyReason why) override;
 
   virtual void ProcessingError(Result aCode, const char* aReason) override;
 
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -37,16 +37,17 @@
 #include "mozilla/a11y/AccessibleWrap.h"
 #endif
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/DataStorage.h"
 #include "mozilla/devtools/HeapSnapshotTempFileHelperParent.h"
 #include "mozilla/docshell/OfflineCacheUpdateParent.h"
 #include "mozilla/dom/ClientManager.h"
+#include "mozilla/dom/ClientOpenWindowOpActors.h"
 #include "mozilla/dom/DataTransfer.h"
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/FileCreatorHelper.h"
 #include "mozilla/dom/FileSystemSecurity.h"
 #include "mozilla/dom/ExternalHelperAppParent.h"
 #include "mozilla/dom/GetFilesHelper.h"
 #include "mozilla/dom/GeolocationBinding.h"
@@ -5116,16 +5117,28 @@ ContentParent::EnsurePermissionsByKey(co
 }
 
 bool
 ContentParent::NeedsPermissionsUpdate(const nsACString& aPermissionKey) const
 {
   return mActivePermissionKeys.Contains(aPermissionKey);
 }
 
+PClientOpenWindowOpParent*
+ContentParent::AllocPClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs)
+{
+  return AllocClientOpenWindowOpParent(aArgs);
+}
+
+bool
+ContentParent::DeallocPClientOpenWindowOpParent(PClientOpenWindowOpParent* aActor)
+{
+  return DeallocClientOpenWindowOpParent(aActor);
+}
+
 mozilla::ipc::IPCResult
 ContentParent::RecvAccumulateChildHistograms(
                 InfallibleTArray<Accumulation>&& aAccumulations)
 {
   TelemetryIPC::AccumulateChildHistograms(GeckoProcessType_Content, aAccumulations);
   return IPC_OK();
 }
 
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -657,16 +657,24 @@ public:
 
   // Use the PHangMonitor channel to ask the child to repaint a tab.
   void ForceTabPaint(TabParent* aTabParent, uint64_t aLayerObserverEpoch);
 
   nsresult TransmitPermissionsFor(nsIChannel* aChannel);
 
   nsresult TransmitPermissionsForPrincipal(nsIPrincipal* aPrincipal);
 
+  virtual PClientOpenWindowOpParent*
+  AllocPClientOpenWindowOpParent(const ClientOpenWindowArgs& aArgs) override;
+
+  virtual bool
+  DeallocPClientOpenWindowOpParent(PClientOpenWindowOpParent* aActor) override;
+
+  static hal::ProcessPriority GetInitialProcessPriority(Element* aFrameElement);
+
 protected:
   void OnChannelConnected(int32_t pid) override;
 
   virtual void ActorDestroy(ActorDestroyReason why) override;
 
   bool ShouldContinueFromReplyTimeout() override;
 
   void OnVarChanged(const GfxVarUpdate& aVar) override;
@@ -683,18 +691,16 @@ private:
    */
   static nsClassHashtable<nsStringHashKey, nsTArray<ContentParent*>>* sBrowserContentParents;
   static nsTArray<ContentParent*>* sPrivateContent;
   static StaticAutoPtr<LinkedList<ContentParent> > sContentParents;
 
   static void JoinProcessesIOThread(const nsTArray<ContentParent*>* aProcesses,
                                     Monitor* aMonitor, bool* aDone);
 
-  static hal::ProcessPriority GetInitialProcessPriority(Element* aFrameElement);
-
   static ContentBridgeParent* CreateContentBridgeParent(const TabContext& aContext,
                                                         const hal::ProcessPriority& aPriority,
                                                         const TabId& aOpenerTabId,
                                                         /*out*/ TabId* aTabId);
 
   // Hide the raw constructor methods since we don't want client code
   // using them.
   virtual PBrowserParent* SendPBrowserConstructor(
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -2,16 +2,17 @@
 /* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PBlob;
 include protocol PBrowser;
+include protocol PClientOpenWindowOp;
 include protocol PCompositorBridge;
 include protocol PContentBridge;
 include protocol PContentPermissionRequest;
 include protocol PCycleCollectWithLogs;
 include protocol PPSMContentDownloader;
 include protocol PExternalHelperApp;
 include protocol PHandlerService;
 include protocol PFileDescriptorSet;
@@ -52,16 +53,17 @@ include URIParams;
 include PluginTypes;
 include ProtocolTypes;
 include PBackgroundSharedTypes;
 include PContentPermission;
 include ServiceWorkerConfiguration;
 include GraphicsMessages;
 include ProfilerTypes;
 include MemoryReportTypes;
+include ClientIPCTypes;
 
 // Workaround to prevent error if PContentChild.cpp & PContentBridgeParent.cpp
 // are put into different UnifiedProtocolsXX.cpp files.
 // XXX Remove this once bug 1069073 is fixed
 include "mozilla/dom/PContentBridgeParent.h";
 
 using GeoPosition from "nsGeoPositionIPCSerialiser.h";
 using AlertNotificationType from "mozilla/AlertNotificationIPCSerializer.h";
@@ -274,16 +276,17 @@ struct XPCOMInitData
  * The PContent protocol is a top-level protocol between the UI process
  * and a content process. There is exactly one PContentParent/PContentChild pair
  * for each content process.
  */
 nested(upto inside_cpow) sync protocol PContent
 {
     manages PBlob;
     manages PBrowser;
+    manages PClientOpenWindowOp;
     manages PContentPermissionRequest;
     manages PCycleCollectWithLogs;
     manages PPSMContentDownloader;
     manages PExternalHelperApp;
     manages PFileDescriptorSet;
     manages PHal;
     manages PHandlerService;
     manages PHeapSnapshotTempFileHelper;
@@ -602,16 +605,18 @@ child:
     async PParentToChildStream();
 
     async ProvideAnonymousTemporaryFile(uint64_t aID, FileDescOrError aFD);
 
     async SetPermissionsWithKey(nsCString aPermissionKey, Permission[] aPermissions);
 
     async RefreshScreens(ScreenDetails[] aScreens);
 
+    async PClientOpenWindowOp(ClientOpenWindowArgs aArgs);
+
 parent:
     async InitBackground(Endpoint<PBackgroundParent> aEndpoint);
 
     sync CreateChildProcess(IPCTabContext context,
                             ProcessPriority priority,
                             TabId openerTabId)
         returns (ContentParentId cpId, bool isForBrowser, TabId tabId);
     sync BridgeToChildProcess(ContentParentId cpId)
diff --git a/dom/workers/test/serviceworkers/openWindow_worker.js b/dom/workers/test/serviceworkers/openWindow_worker.js
--- a/dom/workers/test/serviceworkers/openWindow_worker.js
+++ b/dom/workers/test/serviceworkers/openWindow_worker.js
@@ -55,37 +55,37 @@ onmessage = function(event) {
   if (event.data == "testNoPopup") {
     client = event.source;
 
     var results = [];
     var promises = [];
     promises.push(testForUrl("about:blank", "TypeError", null, results));
     promises.push(testForUrl("http://example.com", "InvalidAccessError", null, results));
     promises.push(testForUrl("_._*`InvalidURL", "InvalidAccessError", null, results));
-    Promise.all(promises).then(function(e) {
+    event.waitUntil(Promise.all(promises).then(function(e) {
       client.postMessage(results);
-    });
+    }));
   }
   if (event.data == "NEW_WINDOW") {
     window_count += 1;
     if (window_count == expected_window_count) {
       resolve_got_all_windows();
     }
   }
 
   if (event.data == "CHECK_NUMBER_OF_WINDOWS") {
-    got_all_windows.then(function() {
+    event.waitUntil(got_all_windows.then(function() {
       return clients.matchAll();
     }).then(function(cl) {
       event.source.postMessage({result: cl.length == expected_window_count,
                                 message: "The number of windows is correct."});
       for (i = 0; i < cl.length; i++) {
         cl[i].postMessage("CLOSE");
       }
-    });
+    }));
   }
 }
 
 onnotificationclick = function(e) {
   var results = [];
   var promises = [];
 
   var redirect = "http://mochi.test:8888/tests/dom/workers/test/serviceworkers/redirect.sjs?"
@@ -104,13 +104,13 @@ onnotificationclick = function(e) {
 			   {url: same_origin}, results));
   promises.push(testForUrl(redirect + different_origin, null, null, results));
 
   promises.push(testForUrl(redirect_xorigin + "open_window/client.html", null,
 			   null, results));
   promises.push(testForUrl(redirect_xorigin + same_origin, null,
 			   {url: same_origin}, results));
 
-  Promise.all(promises).then(function(e) {
+  e.waitUntil(Promise.all(promises).then(function(e) {
     client.postMessage(results);
-  });
+  }));
 }
 
