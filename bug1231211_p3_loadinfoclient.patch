# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  19df94c8738ae604fd37c9906c4686cd4ffed85b
Bug 1231211 P3 Serialize LoadInfo's mClientInfo, mReservedClientInfo, and mReservedClientInfo members across IPC. r=valentin

diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -29,16 +29,22 @@ struct IPCClientInfo
   nsID id;
   ClientType type;
   PrincipalInfo principalInfo;
   TimeStamp creationTime;
   nsCString url;
   FrameType frameType;
 };
 
+union OptionalIPCClientInfo
+{
+  IPCClientInfo;
+  void_t;
+};
+
 struct IPCClientWindowState
 {
   VisibilityState visibilityState;
   TimeStamp lastFocusTime;
   StorageAccess storageAccess;
   bool focused;
 };
 
diff --git a/ipc/glue/BackgroundUtils.cpp b/ipc/glue/BackgroundUtils.cpp
--- a/ipc/glue/BackgroundUtils.cpp
+++ b/ipc/glue/BackgroundUtils.cpp
@@ -363,16 +363,34 @@ LoadInfoToLoadInfoArgs(nsILoadInfo *aLoa
 
   nsTArray<PrincipalInfo> ancestorPrincipals;
   ancestorPrincipals.SetCapacity(aLoadInfo->AncestorPrincipals().Length());
   for (const auto& principal : aLoadInfo->AncestorPrincipals()) {
     rv = PrincipalToPrincipalInfo(principal, ancestorPrincipals.AppendElement());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  OptionalIPCClientInfo ipcClientInfo = mozilla::void_t();
+  const Maybe<ClientInfo>& clientInfo = aLoadInfo->GetClientInfo();
+  if (clientInfo.isSome()) {
+    ipcClientInfo = clientInfo.ref().ToIPC();
+  }
+
+  OptionalIPCClientInfo ipcReservedClientInfo = mozilla::void_t();
+  const Maybe<ClientInfo>& reservedClientInfo = aLoadInfo->GetReservedClientInfo();
+  if (reservedClientInfo.isSome()) {
+    ipcReservedClientInfo = reservedClientInfo.ref().ToIPC();
+  }
+
+  OptionalIPCClientInfo ipcInitialClientInfo = mozilla::void_t();
+  const Maybe<ClientInfo>& initialClientInfo = aLoadInfo->GetInitialClientInfo();
+  if (initialClientInfo.isSome()) {
+    ipcInitialClientInfo = initialClientInfo.ref().ToIPC();
+  }
+
   OptionalIPCServiceWorkerDescriptor ipcController = mozilla::void_t();
   const Maybe<ServiceWorkerDescriptor>& controller = aLoadInfo->GetController();
   if(controller.isSome()) {
     ipcController = controller.ref().ToIPC();
   }
 
   *aOptionalLoadInfoArgs =
     LoadInfoArgs(
@@ -398,16 +416,19 @@ LoadInfoToLoadInfoArgs(nsILoadInfo *aLoa
       aLoadInfo->GetInitialSecurityCheckDone(),
       aLoadInfo->GetIsInThirdPartyContext(),
       aLoadInfo->GetIsDocshellReload(),
       aLoadInfo->GetOriginAttributes(),
       redirectChainIncludingInternalRedirects,
       redirectChain,
       ancestorPrincipals,
       aLoadInfo->AncestorOuterWindowIDs(),
+      ipcClientInfo,
+      ipcReservedClientInfo,
+      ipcInitialClientInfo,
       ipcController,
       aLoadInfo->CorsUnsafeHeaders(),
       aLoadInfo->GetForcePreflight(),
       aLoadInfo->GetIsPreflight(),
       aLoadInfo->GetLoadTriggeredFromExternal(),
       aLoadInfo->GetServiceWorkerTaintingSynthesized()
       );
 
@@ -478,28 +499,83 @@ LoadInfoArgsToLoadInfo(const OptionalLoa
   ancestorPrincipals.SetCapacity(loadInfoArgs.ancestorPrincipals().Length());
   for (const PrincipalInfo& principalInfo : loadInfoArgs.ancestorPrincipals()) {
     nsCOMPtr<nsIPrincipal> ancestorPrincipal =
       PrincipalInfoToPrincipal(principalInfo, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     ancestorPrincipals.AppendElement(ancestorPrincipal.forget());
   }
 
+  Maybe<ClientInfo> clientInfo;
+  if (loadInfoArgs.clientInfo().type() != OptionalIPCClientInfo::Tvoid_t) {
+    clientInfo.emplace(ClientInfo(loadInfoArgs.clientInfo().get_IPCClientInfo()));
+
+    // If the ClientInfo is present, it's principal must match the loading
+    // principal.
+    nsCOMPtr<nsIPrincipal> p =
+      PrincipalInfoToPrincipal(clientInfo.ref().PrincipalInfo());
+    bool valid = p && p->Equals(loadingPrincipal);
+    MOZ_DIAGNOSTIC_ASSERT(valid);
+    NS_ENSURE_TRUE(valid, NS_ERROR_UNEXPECTED);
+  }
+
+  Maybe<ClientInfo> reservedClientInfo;
+  if (loadInfoArgs.reservedClientInfo().type() != OptionalIPCClientInfo::Tvoid_t) {
+    reservedClientInfo.emplace(
+      ClientInfo(loadInfoArgs.reservedClientInfo().get_IPCClientInfo()));
+  }
+
+  Maybe<ClientInfo> initialClientInfo;
+  if (loadInfoArgs.initialClientInfo().type() != OptionalIPCClientInfo::Tvoid_t) {
+    initialClientInfo.emplace(
+      ClientInfo(loadInfoArgs.initialClientInfo().get_IPCClientInfo()));
+
+    // If the initial ClientInfo is present, then its principal should
+    // match the principalToInherit.  According to nsILoadInfo we should
+    // fall back to triggering principal if that is null.
+    /* TODO
+    nsCOMPtr<nsIPrincipal> p =
+      PrincipalInfoToPrincipal(initialClientInfo.ref().PrincipalInfo());
+    nsIPrincipal* inherit = principalToInherit ? principalToInherit
+                                               : triggeringPrincipal;
+    bool valid = p && p->Equals(inherit);
+    if (!valid) {
+      nsAutoCString initialOrigin;
+      p->GetOrigin(initialOrigin);
+      nsAutoCString inheritOrigin;
+      inherit->GetOrigin(inheritOrigin);
+      printf_stderr("### ### initial: %s\n", initialOrigin.get());
+      printf_stderr("### ### inherit: %s\n", inheritOrigin.get());
+    }
+    MOZ_DIAGNOSTIC_ASSERT(valid);
+    NS_ENSURE_TRUE(valid, NS_ERROR_UNEXPECTED);
+    */
+  }
+
+  // We can have an initial client info or a reserved client info, but not both.
+  MOZ_DIAGNOSTIC_ASSERT(reservedClientInfo.isNothing() ||
+                        initialClientInfo.isNothing());
+  NS_ENSURE_TRUE(reservedClientInfo.isNothing() ||
+                 initialClientInfo.isNothing(), NS_ERROR_UNEXPECTED);
+
   Maybe<ServiceWorkerDescriptor> controller;
   if (loadInfoArgs.controller().type() != OptionalIPCServiceWorkerDescriptor::Tvoid_t) {
     controller.emplace(ServiceWorkerDescriptor(
       loadInfoArgs.controller().get_IPCServiceWorkerDescriptor()));
   }
 
   nsCOMPtr<nsILoadInfo> loadInfo =
     new mozilla::LoadInfo(loadingPrincipal,
                           triggeringPrincipal,
                           principalToInherit,
                           sandboxedLoadingPrincipal,
                           resultPrincipalURI,
+                          clientInfo,
+                          reservedClientInfo,
+                          initialClientInfo,
                           controller,
                           loadInfoArgs.securityFlags(),
                           loadInfoArgs.contentPolicyType(),
                           static_cast<LoadTainting>(loadInfoArgs.tainting()),
                           loadInfoArgs.upgradeInsecureRequests(),
                           loadInfoArgs.verifySignedContent(),
                           loadInfoArgs.enforceSRI(),
                           loadInfoArgs.forceAllowDataURI(),
diff --git a/netwerk/base/LoadInfo.cpp b/netwerk/base/LoadInfo.cpp
--- a/netwerk/base/LoadInfo.cpp
+++ b/netwerk/base/LoadInfo.cpp
@@ -347,16 +347,19 @@ LoadInfo::LoadInfo(const LoadInfo& rhs)
 {
 }
 
 LoadInfo::LoadInfo(nsIPrincipal* aLoadingPrincipal,
                    nsIPrincipal* aTriggeringPrincipal,
                    nsIPrincipal* aPrincipalToInherit,
                    nsIPrincipal* aSandboxedLoadingPrincipal,
                    nsIURI* aResultPrincipalURI,
+                   const Maybe<ClientInfo>& aClientInfo,
+                   const Maybe<ClientInfo>& aReservedClientInfo,
+                   const Maybe<ClientInfo>& aInitialClientInfo,
                    const Maybe<ServiceWorkerDescriptor>& aController,
                    nsSecurityFlags aSecurityFlags,
                    nsContentPolicyType aContentPolicyType,
                    LoadTainting aTainting,
                    bool aUpgradeInsecureRequests,
                    bool aVerifySignedContent,
                    bool aEnforceSRI,
                    bool aForceAllowDataURI,
@@ -379,16 +382,19 @@ LoadInfo::LoadInfo(nsIPrincipal* aLoadin
                    bool aForcePreflight,
                    bool aIsPreflight,
                    bool aLoadTriggeredFromExternal,
                    bool aServiceWorkerTaintingSynthesized)
   : mLoadingPrincipal(aLoadingPrincipal)
   , mTriggeringPrincipal(aTriggeringPrincipal)
   , mPrincipalToInherit(aPrincipalToInherit)
   , mResultPrincipalURI(aResultPrincipalURI)
+  , mClientInfo(aClientInfo)
+  , mReservedClientInfo(aReservedClientInfo)
+  , mInitialClientInfo(aInitialClientInfo)
   , mController(aController)
   , mSecurityFlags(aSecurityFlags)
   , mInternalContentPolicyType(aContentPolicyType)
   , mTainting(aTainting)
   , mUpgradeInsecureRequests(aUpgradeInsecureRequests)
   , mVerifySignedContent(aVerifySignedContent)
   , mEnforceSRI(aEnforceSRI)
   , mForceAllowDataURI(aForceAllowDataURI)
diff --git a/netwerk/base/LoadInfo.h b/netwerk/base/LoadInfo.h
--- a/netwerk/base/LoadInfo.h
+++ b/netwerk/base/LoadInfo.h
@@ -94,16 +94,19 @@ private:
   // HttpChannelParent and FTPChannelParent declared as friends undeneath.
   // In e10s we can not serialize nsINode, hence we store the innerWindowID.
   // Please note that aRedirectChain uses swapElements.
   LoadInfo(nsIPrincipal* aLoadingPrincipal,
            nsIPrincipal* aTriggeringPrincipal,
            nsIPrincipal* aPrincipalToInherit,
            nsIPrincipal* aSandboxedLoadingPrincipal,
            nsIURI* aResultPrincipalURI,
+           const Maybe<mozilla::dom::ClientInfo>& aClientInfo,
+           const Maybe<mozilla::dom::ClientInfo>& aReservedClientInfo,
+           const Maybe<mozilla::dom::ClientInfo>& aInitialClientInfo,
            const Maybe<mozilla::dom::ServiceWorkerDescriptor>& aController,
            nsSecurityFlags aSecurityFlags,
            nsContentPolicyType aContentPolicyType,
            LoadTainting aTainting,
            bool aUpgradeInsecureRequests,
            bool aVerifySignedContent,
            bool aEnforceSRI,
            bool aForceAllowDataURI,
diff --git a/netwerk/ipc/NeckoChannelParams.ipdlh b/netwerk/ipc/NeckoChannelParams.ipdlh
--- a/netwerk/ipc/NeckoChannelParams.ipdlh
+++ b/netwerk/ipc/NeckoChannelParams.ipdlh
@@ -4,16 +4,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PHttpChannel;
 include protocol PFTPChannel;
 include protocol PChildToParentStream;
 include BlobTypes;
+include ClientIPCTypes;
 include URIParams;
 include IPCServiceWorkerDescriptor;
 include IPCStream;
 include PBackgroundSharedTypes;
 
 using mozilla::OriginAttributes from "mozilla/ipc/BackgroundUtils.h";
 using struct mozilla::void_t from "ipc/IPCMessageUtils.h";
 using RequestHeaderTuples from "mozilla/net/PHttpChannelParams.h";
@@ -66,16 +67,32 @@ struct LoadInfoArgs
   /**
    * Ancestor data for use with the WebRequest API.
    * See nsILoadInfo.idl for details.
    */
   PrincipalInfo[]             ancestorPrincipals;
   uint64_t[]                  ancestorOuterWindowIDs;
 
   /**
+   * ClientInfo structure representing the window or worker that triggered
+   * this network request.  May be void_t if its a system internal request.
+   */
+  OptionalIPCClientInfo       clientInfo;
+
+  /**
+   * Non-subresource requests will result in the creation of a window or
+   * worker client.  The reserved and initial ClientInfo values represent
+   * this resulting client.  An initial ClientInfo represents an initial
+   * about:blank window that will be re-used while a reserved ClientInfo
+   * represents a to-be-newly-created window/worker.
+   */
+  OptionalIPCClientInfo       reservedClientInfo;
+  OptionalIPCClientInfo       initialClientInfo;
+
+  /**
    * Subresource loads may have a controller set based on their owning
    * window/worker client.  We must send this across IPC to support
    * performing interception in the parent.
    */
   OptionalIPCServiceWorkerDescriptor controller;
 
   nsCString[]                 corsUnsafeHeaders;
   bool                        forcePreflight;
