# HG changeset patch
# Parent 21cb38524f42115921932a42f1ff4a403669ed58
# User Ben Kelly <ben@wanderview.com>
Bug 1073231 Implement Request and Response Clone() methods. r=nsm r=baku

diff --git a/dom/fetch/InternalRequest.cpp b/dom/fetch/InternalRequest.cpp
--- a/dom/fetch/InternalRequest.cpp
+++ b/dom/fetch/InternalRequest.cpp
@@ -2,16 +2,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InternalRequest.h"
 
 #include "nsIContentPolicy.h"
 #include "nsIDocument.h"
+#include "nsStreamUtils.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/workers/Workers.h"
 
 #include "WorkerPrivate.h"
 
 namespace mozilla {
@@ -38,14 +39,52 @@ InternalRequest::GetRequestConstructorCo
 
   copy->mContext = nsIContentPolicy::TYPE_FETCH;
   copy->mMode = mMode;
   copy->mCredentialsMode = mCredentialsMode;
   copy->mCacheMode = mCacheMode;
   return copy.forget();
 }
 
+InternalRequest::InternalRequest(InternalRequest& aOther)
+  : mMethod(aOther.mMethod)
+  , mURL(aOther.mURL)
+  , mHeaders(aOther.mHeaders)
+  , mContext(aOther.mContext)
+  , mContextFrameType(aOther.mContextFrameType)
+  , mReferrer(aOther.mReferrer)
+  , mMode(aOther.mMode)
+  , mCredentialsMode(aOther.mCredentialsMode)
+  , mResponseTainting(aOther.mResponseTainting)
+  , mCacheMode(aOther.mCacheMode)
+  , mAuthenticationFlag(aOther.mAuthenticationFlag)
+  , mForceOriginHeader(aOther.mForceOriginHeader)
+  , mPreserveContentCodings(aOther.mPreserveContentCodings)
+  , mSameOriginDataURL(aOther.mSameOriginDataURL)
+  , mSandboxedStorageAreaURLs(aOther.mSandboxedStorageAreaURLs)
+  , mSkipServiceWorker(aOther.mSkipServiceWorker)
+  , mSynchronous(aOther.mSynchronous)
+  , mUnsafeRequest(aOther.mUnsafeRequest)
+  , mUseURLCredentials(aOther.mUseURLCredentials)
+{
+  if (!aOther.mBodyStream) {
+    return;
+  }
+
+  nsCOMPtr<nsIInputStream> clone;
+  nsCOMPtr<nsIInputStream> replacement;
+
+  nsresult rv = NS_CloneInputStream(aOther.mBodyStream, getter_AddRefs(clone),
+                                    getter_AddRefs(replacement));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  if (replacement) {
+    aOther.mBodyStream.swap(replacement);
+  }
+  mBodyStream.swap(clone);
+}
+
 InternalRequest::~InternalRequest()
 {
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/fetch/InternalRequest.h b/dom/fetch/InternalRequest.h
--- a/dom/fetch/InternalRequest.h
+++ b/dom/fetch/InternalRequest.h
@@ -71,39 +71,17 @@ public:
     , mSameOriginDataURL(true)
     , mSkipServiceWorker(false)
     , mSynchronous(false)
     , mUnsafeRequest(false)
     , mUseURLCredentials(false)
   {
   }
 
-  explicit InternalRequest(const InternalRequest& aOther)
-    : mMethod(aOther.mMethod)
-    , mURL(aOther.mURL)
-    , mHeaders(aOther.mHeaders)
-    , mBodyStream(aOther.mBodyStream)
-    , mContext(aOther.mContext)
-    , mContextFrameType(aOther.mContextFrameType)
-    , mReferrer(aOther.mReferrer)
-    , mMode(aOther.mMode)
-    , mCredentialsMode(aOther.mCredentialsMode)
-    , mResponseTainting(aOther.mResponseTainting)
-    , mCacheMode(aOther.mCacheMode)
-    , mAuthenticationFlag(aOther.mAuthenticationFlag)
-    , mForceOriginHeader(aOther.mForceOriginHeader)
-    , mPreserveContentCodings(aOther.mPreserveContentCodings)
-    , mSameOriginDataURL(aOther.mSameOriginDataURL)
-    , mSandboxedStorageAreaURLs(aOther.mSandboxedStorageAreaURLs)
-    , mSkipServiceWorker(aOther.mSkipServiceWorker)
-    , mSynchronous(aOther.mSynchronous)
-    , mUnsafeRequest(aOther.mUnsafeRequest)
-    , mUseURLCredentials(aOther.mUseURLCredentials)
-  {
-  }
+  explicit InternalRequest(InternalRequest& aOther);
 
   void
   GetMethod(nsCString& aMethod) const
   {
     aMethod.Assign(mMethod);
   }
 
   void
diff --git a/dom/fetch/InternalResponse.cpp b/dom/fetch/InternalResponse.cpp
--- a/dom/fetch/InternalResponse.cpp
+++ b/dom/fetch/InternalResponse.cpp
@@ -3,39 +3,62 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "InternalResponse.h"
 
 #include "nsIDOMFile.h"
 
 #include "mozilla/dom/InternalHeaders.h"
+#include "nsStreamUtils.h"
 
 namespace mozilla {
 namespace dom {
 
 InternalResponse::InternalResponse(uint16_t aStatus, const nsACString& aStatusText)
   : mType(ResponseType::Default)
   , mStatus(aStatus)
   , mStatusText(aStatusText)
   , mHeaders(new InternalHeaders(HeadersGuardEnum::Response))
 {
 }
 
 // Headers are not copied since BasicResponse and CORSResponse both need custom
 // header handling.
-InternalResponse::InternalResponse(const InternalResponse& aOther)
+InternalResponse::InternalResponse(InternalResponse& aOther)
   : mType(aOther.mType)
   , mTerminationReason(aOther.mTerminationReason)
   , mURL(aOther.mURL)
   , mStatus(aOther.mStatus)
   , mStatusText(aOther.mStatusText)
-  , mBody(aOther.mBody)
   , mContentType(aOther.mContentType)
 {
+  if (!aOther.mBody) {
+    return;
+  }
+
+  nsCOMPtr<nsIInputStream> clone;
+  nsCOMPtr<nsIInputStream> replacement;
+
+  nsresult rv = NS_CloneInputStream(aOther.mBody, getter_AddRefs(clone),
+                                    getter_AddRefs(replacement));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  if (replacement) {
+    aOther.mBody.swap(replacement);
+  }
+  mBody.swap(clone);
+}
+
+already_AddRefed<InternalResponse>
+InternalResponse::Clone()
+{
+  nsRefPtr<InternalResponse> ir = new InternalResponse(*this);
+  ir->mHeaders = new InternalHeaders(*mHeaders);
+  return ir.forget();
 }
 
 // static
 already_AddRefed<InternalResponse>
 InternalResponse::BasicResponse(InternalResponse* aInner)
 {
   MOZ_ASSERT(aInner);
   nsRefPtr<InternalResponse> basic = new InternalResponse(*aInner);
diff --git a/dom/fetch/InternalResponse.h b/dom/fetch/InternalResponse.h
--- a/dom/fetch/InternalResponse.h
+++ b/dom/fetch/InternalResponse.h
@@ -20,16 +20,18 @@ class InternalResponse MOZ_FINAL
 {
   friend class FetchDriver;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(InternalResponse)
 
   InternalResponse(uint16_t aStatus, const nsACString& aStatusText);
 
+  already_AddRefed<InternalResponse> Clone();
+
   static already_AddRefed<InternalResponse>
   NetworkError()
   {
     nsRefPtr<InternalResponse> response = new InternalResponse(0, EmptyCString());
     response->mType = ResponseType::Error;
     return response.forget();
   }
 
@@ -110,17 +112,17 @@ public:
   }
 
 private:
   ~InternalResponse()
   { }
 
   // Used to create filtered responses.
   // Does not copy headers.
-  explicit InternalResponse(const InternalResponse& aOther);
+  explicit InternalResponse(InternalResponse& aOther);
 
   ResponseType mType;
   nsCString mTerminationReason;
   nsCString mURL;
   const uint16_t mStatus;
   const nsCString mStatusText;
   nsRefPtr<InternalHeaders> mHeaders;
   nsCOMPtr<nsIInputStream> mBody;
diff --git a/dom/fetch/Request.cpp b/dom/fetch/Request.cpp
--- a/dom/fetch/Request.cpp
+++ b/dom/fetch/Request.cpp
@@ -251,18 +251,16 @@ Request::Constructor(const GlobalObject&
   nsRefPtr<Request> domRequest = new Request(global, request);
   domRequest->SetMimeType(aRv);
   return domRequest.forget();
 }
 
 already_AddRefed<Request>
 Request::Clone() const
 {
-  // FIXME(nsm): Bug 1073231. This is incorrect, but the clone method isn't
-  // well defined yet.
   nsRefPtr<Request> request = new Request(mOwner,
                                           new InternalRequest(*mRequest));
   return request.forget();
 }
 
 Headers*
 Request::Headers_()
 {
diff --git a/dom/fetch/Response.cpp b/dom/fetch/Response.cpp
--- a/dom/fetch/Response.cpp
+++ b/dom/fetch/Response.cpp
@@ -185,22 +185,22 @@ Response::Constructor(const GlobalObject
       return nullptr;
     }
   }
 
   r->SetMimeType(aRv);
   return r.forget();
 }
 
-// FIXME(nsm): Bug 1073231: This is currently unspecced!
 already_AddRefed<Response>
 Response::Clone()
 {
   nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(mOwner);
-  nsRefPtr<Response> response = new Response(global, mInternalResponse);
+  nsRefPtr<InternalResponse> ir = mInternalResponse->Clone();
+  nsRefPtr<Response> response = new Response(global, ir);
   return response.forget();
 }
 
 void
 Response::SetBody(nsIInputStream* aBody)
 {
   // FIXME(nsm): Do we flip bodyUsed here?
   mInternalResponse->SetBody(aBody);
