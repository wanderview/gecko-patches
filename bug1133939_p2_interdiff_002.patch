# HG changeset patch
# Parent 67fd5f02d452dabaf6805663ab9932b3c371385f
# User Ben Kelly <ben@wanderview.com>
Bug 1133939 P2 interdiff 002 Add test to force close-during-read condition.

diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -779,8 +779,87 @@ TEST(Pipes, Write_AsyncWait_Clone_CloseO
   testing::ConsumeAndValidateStream(clone, inputData);
 
   ASSERT_FALSE(cb->Called());
 
   reader->Close();
 
   ASSERT_TRUE(cb->Called());
 }
+
+namespace {
+
+nsresult
+CloseDuringReadFunc(nsIInputStream *aReader,
+                    void* aClosure,
+                    const char* aFromSegment,
+                    uint32_t aToOffset,
+                    uint32_t aCount,
+                    uint32_t* aWriteCountOut)
+{
+  MOZ_ASSERT(aReader);
+  MOZ_ASSERT(aClosure);
+  MOZ_ASSERT(aFromSegment);
+  MOZ_ASSERT(aWriteCountOut);
+  MOZ_ASSERT(aToOffset == 0);
+
+  // This is insanity and you probably should not do this under normal
+  // conditions.  We want to simulate the case where the pipe is closed
+  // (possibly from other end on another thread) simultaneously with the
+  // read.  This is the easiest way to do trigger this case in a synchronous
+  // gtest.
+  nsresult rv = aReader->Close();
+  MOZ_ASSERT(NS_SUCCEEDED(rv));
+
+  nsTArray<char>* buffer = static_cast<nsTArray<char>*>(aClosure);
+  buffer->AppendElements(aFromSegment, aCount);
+
+  *aWriteCountOut = aCount;
+
+  return NS_OK;
+}
+
+void
+TestCloseDuringRead(uint32_t aSegmentSize, uint32_t aDataSize)
+{
+  nsCOMPtr<nsIInputStream> reader;
+  nsCOMPtr<nsIOutputStream> writer;
+
+  const uint32_t maxSize = aSegmentSize;
+
+  nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer),
+                           aSegmentSize, maxSize);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+
+  testing::CreateData(aDataSize, inputData);
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> outputData;
+
+  uint32_t numRead = 0;
+  rv = reader->ReadSegments(CloseDuringReadFunc, &outputData,
+                            inputData.Length(), &numRead);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+  ASSERT_EQ(inputData.Length(), numRead);
+
+  ASSERT_EQ(inputData, outputData);
+
+  uint64_t available;
+  rv = reader->Available(&available);
+  ASSERT_EQ(NS_BASE_STREAM_CLOSED, rv);
+}
+
+} // anonymous namespace
+
+TEST(Pipes, Close_During_Read_Partial_Segment)
+{
+  TestCloseDuringRead(1024, 512);
+}
+
+TEST(Pipes, Close_During_Read_Full_Segment)
+{
+  TestCloseDuringRead(1024, 1024);
+}
