# HG changeset patch
# Parent 9696d1c4b3ba3c8dbf937ee7747cb16abefb3603
# User Ben Kelly <ben@wanderview.com>
Bug 1133939 P2 Add tests validating nsPipeOutputStream AsyncWait behavior. r=froydnj

diff --git a/xpcom/tests/gtest/Helpers.cpp b/xpcom/tests/gtest/Helpers.cpp
--- a/xpcom/tests/gtest/Helpers.cpp
+++ b/xpcom/tests/gtest/Helpers.cpp
@@ -89,9 +89,27 @@ ConsumeAndValidateStream(nsIInputStream*
 {
   nsAutoCString outputData;
   nsresult rv = NS_ConsumeStream(aStream, UINT32_MAX, outputData);
   ASSERT_TRUE(NS_SUCCEEDED(rv));
   ASSERT_EQ(aExpectedData.Length(), outputData.Length());
   ASSERT_TRUE(aExpectedData.Equals(outputData));
 }
 
+NS_IMPL_ISUPPORTS(OutputStreamCallback, nsIOutputStreamCallback);
+
+OutputStreamCallback::OutputStreamCallback()
+  : mCalled(false)
+{
+}
+
+OutputStreamCallback::~OutputStreamCallback()
+{
+}
+
+NS_IMETHODIMP
+OutputStreamCallback::OnOutputStreamReady(nsIAsyncOutputStream* aStream)
+{
+  mCalled = true;
+  return NS_OK;
+}
+
 } // namespace testing
diff --git a/xpcom/tests/gtest/Helpers.h b/xpcom/tests/gtest/Helpers.h
--- a/xpcom/tests/gtest/Helpers.h
+++ b/xpcom/tests/gtest/Helpers.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef __Helpers_h
 #define __Helpers_h
 
+#include "nsIAsyncOutputStream.h"
 #include "nsString.h"
 #include <stdint.h>
 
 class nsIInputStream;
 class nsIOutputStream;
 template <class T> class nsTArray;
 
 namespace testing {
@@ -29,11 +30,27 @@ WriteAllAndClose(nsIOutputStream* aStrea
 void
 ConsumeAndValidateStream(nsIInputStream* aStream,
                          const nsTArray<char>& aExpectedData);
 
 void
 ConsumeAndValidateStream(nsIInputStream* aStream,
                          const nsACString& aExpectedData);
 
+class OutputStreamCallback MOZ_FINAL : public nsIOutputStreamCallback
+{
+public:
+  OutputStreamCallback();
+
+  bool Called() const { return mCalled; }
+
+private:
+  ~OutputStreamCallback();
+
+  bool mCalled;
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIOUTPUTSTREAMCALLBACK
+};
+
 } // namespace testing
 
 #endif // __Helpers_h
diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -655,8 +655,138 @@ TEST(Pipes, Clone_DuringWrite_ReadDuring
 
   TestPipeClone(32 * 1024, // total bytes
                 16,        // num writes
                 1,         // num initial clones
                 1,         // num streams to close after each write
                 2,         // num clones to add after each write
                 3);        // num streams to read after each write
 }
+
+TEST(Pipes, Write_AsyncWait)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  uint32_t segmentSize = 1024;
+  uint32_t numSegments = 1;
+
+  // Use async input streams so we can NS_ConsumeStream() the current data
+  // while the pipe is still being written to.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                           true, true,  // non-blocking - reader, writer
+                           segmentSize, numSegments);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+  testing::CreateData(segmentSize, inputData);
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_EQ(NS_BASE_STREAM_WOULD_BLOCK, rv);
+
+  nsRefPtr<testing::OutputStreamCallback> cb =
+    new testing::OutputStreamCallback();
+
+  rv = writer->AsyncWait(cb, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb->Called());
+
+  testing::ConsumeAndValidateStream(reader, inputData);
+
+  ASSERT_TRUE(cb->Called());
+}
+
+TEST(Pipes, Write_AsyncWait_Clone)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  uint32_t segmentSize = 1024;
+  uint32_t numSegments = 1;
+
+  // Use async input streams so we can NS_ConsumeStream() the current data
+  // while the pipe is still being written to.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                           true, true,  // non-blocking - reader, writer
+                           segmentSize, numSegments);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIInputStream> clone;
+  rv = NS_CloneInputStream(reader, getter_AddRefs(clone));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+  testing::CreateData(segmentSize, inputData);
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_EQ(NS_BASE_STREAM_WOULD_BLOCK, rv);
+
+  nsRefPtr<testing::OutputStreamCallback> cb =
+    new testing::OutputStreamCallback();
+
+  rv = writer->AsyncWait(cb, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb->Called());
+
+  testing::ConsumeAndValidateStream(reader, inputData);
+
+  ASSERT_FALSE(cb->Called());
+
+  testing::ConsumeAndValidateStream(clone, inputData);
+
+  ASSERT_TRUE(cb->Called());
+}
+
+TEST(Pipes, Write_AsyncWait_Clone_CloseOriginal)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  uint32_t segmentSize = 1024;
+  uint32_t numSegments = 1;
+
+  // Use async input streams so we can NS_ConsumeStream() the current data
+  // while the pipe is still being written to.
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                           true, true,  // non-blocking - reader, writer
+                           segmentSize, numSegments);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIInputStream> clone;
+  rv = NS_CloneInputStream(reader, getter_AddRefs(clone));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsTArray<char> inputData;
+  testing::CreateData(segmentSize, inputData);
+
+  uint32_t numWritten = 0;
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  rv = writer->Write(inputData.Elements(), inputData.Length(), &numWritten);
+  ASSERT_EQ(NS_BASE_STREAM_WOULD_BLOCK, rv);
+
+  nsRefPtr<testing::OutputStreamCallback> cb =
+    new testing::OutputStreamCallback();
+
+  rv = writer->AsyncWait(cb, 0, 0, nullptr);
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  ASSERT_FALSE(cb->Called());
+
+  testing::ConsumeAndValidateStream(clone, inputData);
+
+  ASSERT_FALSE(cb->Called());
+
+  reader->Close();
+
+  ASSERT_TRUE(cb->Called());
+}
