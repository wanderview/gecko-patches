# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  af7c0cb0798f5425d5d344cbaf0ac0ecb1a72a86
Bug 1255070 P1 Make nsPipeInputStream implement nsIBufferedInputStream. r=froydnj

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <algorithm>
 #include "mozilla/Attributes.h"
 #include "mozilla/ReentrantMonitor.h"
+#include "nsIBufferedStreams.h"
 #include "nsICloneableInputStream.h"
 #include "nsIPipe.h"
 #include "nsIEventTarget.h"
 #include "nsISeekableStream.h"
 #include "mozilla/RefPtr.h"
 #include "nsSegmentedBuffer.h"
 #include "nsStreamUtils.h"
 #include "nsCOMPtr.h"
@@ -139,25 +140,27 @@ struct nsPipeReadState
 
 // an input end of a pipe (maintained as a list of refs within the pipe)
 class nsPipeInputStream final
   : public nsIAsyncInputStream
   , public nsISeekableStream
   , public nsISearchableInputStream
   , public nsICloneableInputStream
   , public nsIClassInfo
+  , public nsIBufferedInputStream
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
   NS_DECL_NSIASYNCINPUTSTREAM
   NS_DECL_NSISEEKABLESTREAM
   NS_DECL_NSISEARCHABLEINPUTSTREAM
   NS_DECL_NSICLONEABLEINPUTSTREAM
   NS_DECL_NSICLASSINFO
+  NS_DECL_NSIBUFFEREDINPUTSTREAM
 
   explicit nsPipeInputStream(nsPipe* aPipe)
     : mPipe(aPipe)
     , mLogicalOffset(0)
     , mInputStatus(NS_OK)
     , mBlocking(true)
     , mBlocked(false)
     , mCallbackFlags(0)
@@ -983,17 +986,18 @@ nsPipe::OnPipeException(nsresult aReason
 
 nsresult
 nsPipe::CloneInputStream(nsPipeInputStream* aOriginal,
                          nsIInputStream** aCloneOut)
 {
   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
   RefPtr<nsPipeInputStream> ref = new nsPipeInputStream(*aOriginal);
   mInputList.AppendElement(ref);
-  ref.forget(aCloneOut);
+  nsCOMPtr<nsIAsyncInputStream> downcast = ref.forget();
+  downcast.forget(aCloneOut);
   return NS_OK;
 }
 
 uint32_t
 nsPipe::CountSegmentReferences(int32_t aSegment)
 {
   mReentrantMonitor.AssertCurrentThreadIn();
   uint32_t count = 0;
@@ -1116,33 +1120,48 @@ nsPipeEvents::~nsPipeEvents()
 
 //-----------------------------------------------------------------------------
 // nsPipeInputStream methods:
 //-----------------------------------------------------------------------------
 
 NS_IMPL_ADDREF(nsPipeInputStream);
 NS_IMPL_RELEASE(nsPipeInputStream);
 
-NS_IMPL_QUERY_INTERFACE(nsPipeInputStream,
-                        nsIInputStream,
-                        nsIAsyncInputStream,
-                        nsISeekableStream,
-                        nsISearchableInputStream,
-                        nsICloneableInputStream,
-                        nsIClassInfo)
+NS_INTERFACE_TABLE_HEAD(nsPipeInputStream)
+  NS_INTERFACE_TABLE_BEGIN
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsIAsyncInputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsISeekableStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsISearchableInputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsICloneableInputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsIBufferedInputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeInputStream, nsIClassInfo)
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsPipeInputStream, nsIInputStream,
+                                       nsIAsyncInputStream)
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsPipeInputStream, nsISupports,
+                                       nsIAsyncInputStream)
+  NS_INTERFACE_TABLE_END
+NS_INTERFACE_TABLE_TAIL
 
 NS_IMPL_CI_INTERFACE_GETTER(nsPipeInputStream,
                             nsIInputStream,
                             nsIAsyncInputStream,
                             nsISeekableStream,
                             nsISearchableInputStream,
-                            nsICloneableInputStream)
+                            nsICloneableInputStream,
+                            nsIBufferedInputStream)
 
 NS_IMPL_THREADSAFE_CI(nsPipeInputStream)
 
+NS_IMETHODIMP
+nsPipeInputStream::Init(nsIInputStream*, uint32_t)
+{
+  MOZ_CRASH("nsPipeInputStream should never be initialized with "
+            "nsIBufferedInputStream::Init!\n");
+}
+
 uint32_t
 nsPipeInputStream::Available()
 {
   mPipe->mReentrantMonitor.AssertCurrentThreadIn();
   return mReadState.mAvailable;
 }
 
 nsresult
@@ -1295,18 +1314,18 @@ nsPipeInputStream::ReadSegments(nsWriteS
       mPipe->OnInputStreamException(this, rv);
       break;
     }
 
     uint32_t writeCount;
     while (segment.Length()) {
       writeCount = 0;
 
-      rv = aWriter(this, aClosure, segment.Data(), *aReadCount,
-                   segment.Length(), &writeCount);
+      rv = aWriter(static_cast<nsIAsyncInputStream*>(this), aClosure,
+                   segment.Data(), *aReadCount, segment.Length(), &writeCount);
 
       if (NS_FAILED(rv) || writeCount == 0) {
         aCount = 0;
         // any errors returned from the writer end here: do not
         // propagate to the caller of ReadSegments.
         rv = NS_OK;
         break;
       }
diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -7,20 +7,23 @@
 #include <algorithm>
 #include "gtest/gtest.h"
 #include "Helpers.h"
 #include "mozilla/ReentrantMonitor.h"
 #include "nsCOMPtr.h"
 #include "nsCRT.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
+#include "nsIBufferedStreams.h"
+#include "nsIClassInfo.h"
 #include "nsICloneableInputStream.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsIPipe.h"
+#include "nsISeekableStream.h"
 #include "nsIThread.h"
 #include "nsIRunnable.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsThreadUtils.h"
 #include "prprf.h"
 #include "prinrval.h"
 
@@ -940,8 +943,36 @@ TEST(Pipes, Close_During_Read_Partial_Se
 {
   TestCloseDuringRead(1024, 512);
 }
 
 TEST(Pipes, Close_During_Read_Full_Segment)
 {
   TestCloseDuringRead(1024, 1024);
 }
+
+TEST(Pipes, Interfaces)
+{
+  nsCOMPtr<nsIInputStream> reader;
+  nsCOMPtr<nsIOutputStream> writer;
+
+  nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer));
+  ASSERT_TRUE(NS_SUCCEEDED(rv));
+
+  nsCOMPtr<nsIAsyncInputStream> readerType1 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType1);
+
+  nsCOMPtr<nsISeekableStream> readerType2 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType2);
+
+  nsCOMPtr<nsISearchableInputStream> readerType3 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType3);
+
+  nsCOMPtr<nsICloneableInputStream> readerType4 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType4);
+
+  nsCOMPtr<nsIClassInfo> readerType5 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType5);
+
+  nsCOMPtr<nsIBufferedInputStream> readerType6 = do_QueryInterface(reader);
+  ASSERT_TRUE(readerType6);
+
+}
