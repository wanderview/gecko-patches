# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2b07ef4f3381eafab2183a46704bed50800bede3
Bug 1375287 Make TimeoutManager use a pref cache variable for dom.disable_open_click_delay. r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -270,16 +270,21 @@ uint32_t TimeoutManager::sNestingLevel =
 
 namespace {
 
 // The maximum number of milliseconds to allow consecutive timer callbacks
 // to run in a single event loop runnable.
 #define DEFAULT_MAX_CONSECUTIVE_CALLBACKS_MILLISECONDS 4
 uint32_t gMaxConsecutiveCallbacksMilliseconds;
 
+// Only propagate the open window click permission if the setTimeout() is equal
+// to or less than this value.
+#define DEFAULT_DISABLE_OPEN_CLICK_DELAY 0
+int32_t gDisableOpenClickDelay;
+
 } // anonymous namespace
 
 TimeoutManager::TimeoutManager(nsGlobalWindow& aWindow)
   : mWindow(aWindow),
     mExecutor(new TimeoutExecutor(this)),
     mNormalTimeouts(*this),
     mTrackingTimeouts(*this),
     mTimeoutIdCounter(1),
@@ -330,16 +335,20 @@ TimeoutManager::Initialize()
                               DEFAULT_TRACKING_TIMEOUT_THROTTLING_DELAY);
   Preferences::AddBoolVarCache(&gAnnotateTrackingChannels,
                                "privacy.trackingprotection.annotate_channels",
                                false);
 
   Preferences::AddUintVarCache(&gMaxConsecutiveCallbacksMilliseconds,
                                "dom.timeout.max_consecutive_callbacks_ms",
                                DEFAULT_MAX_CONSECUTIVE_CALLBACKS_MILLISECONDS);
+
+  Preferences::AddIntVarCache(&gDisableOpenClickDelay,
+                              "dom.disable_open_click_delay",
+                              0);
 }
 
 uint32_t
 TimeoutManager::GetTimeoutId(Timeout::Reason aReason)
 {
   switch (aReason) {
     case Timeout::Reason::eIdleCallbackTimeout:
       return ++mIdleCallbackTimeoutCounter;
@@ -446,23 +455,20 @@ TimeoutManager::SetTimeout(nsITimeoutHan
 
   if (gRunningTimeoutDepth == 0 &&
       mWindow.GetPopupControlState() < openAbused) {
     // This timeout is *not* set from another timeout and it's set
     // while popups are enabled. Propagate the state to the timeout if
     // its delay (interval) is equal to or less than what
     // "dom.disable_open_click_delay" is set to (in ms).
 
-    int32_t delay =
-      Preferences::GetInt("dom.disable_open_click_delay");
-
     // This is checking |interval|, not realInterval, on purpose,
     // because our lower bound for |realInterval| could be pretty high
     // in some cases.
-    if (interval <= delay) {
+    if (interval <= gDisableOpenClickDelay) {
       timeout->mPopupState = mWindow.GetPopupControlState();
     }
   }
 
   Timeouts::SortBy sort(mWindow.IsFrozen() ? Timeouts::SortBy::TimeRemaining
                                            : Timeouts::SortBy::TimeWhen);
   if (timeout->mIsTracking) {
     mTrackingTimeouts.Insert(timeout, sort);
