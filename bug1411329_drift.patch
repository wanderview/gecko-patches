# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  ea4ab2614b6a7311a70fa35fc6e62f6b95ae4e0a
Bug 1411329 Attempt to adjust for setInterval() drift. r=bz

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -961,29 +961,55 @@ TimeoutManager::RescheduleTimeout(Timeou
   }
 
   // Automatically increase the nesting level when a setInterval()
   // is rescheduled just as if it was using a chained setTimeout().
   if (aTimeout->mNestingLevel < DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
     aTimeout->mNestingLevel += 1;
   }
 
-  // Compute time to next timeout for interval timer.
-  // Make sure nextInterval is at least CalculateDelay().
+  // Compute time to next desired delay for the interval timer.
+  // This takes into account throttling, 4ms clamping, etc.
   TimeDuration nextInterval = CalculateDelay(aTimeout);
 
-  TimeStamp firingTime = aLastCallbackTime + nextInterval;
+  // Calculate how far we have drifted since the last timeout in
+  // the interval.  This accounts for:
+  // 1. Early or late firing from TimeoutExecutor.
+  // 2. Time spent executing the setInterval() callback.
+  TimeDuration drift = aLastCallbackTime - aTimeout->When();
+  if (!nextInterval.IsZero()) {
+    drift = drift % nextInterval;
+  }
+
+  // Calculate the new firing time using our target interval and
+  // drift adjustment.  Note, this can produce a delay smaller
+  // than our 4ms clamp value if there is negative drift.
+  TimeStamp firingTime = aLastCallbackTime + nextInterval - drift;
   TimeDuration delay = firingTime - aCurrentNow;
 
-  // And make sure delay is nonnegative; that might happen if the timer
-  // thread is firing our timers somewhat early or if they're taking a long
-  // time to run the callback.
-  if (delay < TimeDuration(0)) {
-    delay = TimeDuration(0);
-  }
+  TimeDuration firingDelay = aLastCallbackTime - aTimeout->When();
+  TimeDuration callbackDelay = aCurrentNow - aLastCallbackTime;
+
+  printf_stderr("### ### nextInterval:%3f drift:%3f (firing:%3f callback:%3f) delay:%3f\n",
+                nextInterval.ToMilliseconds(), drift.ToMilliseconds(),
+                firingDelay.ToMilliseconds(),
+                callbackDelay.ToMilliseconds(), delay.ToMilliseconds());
+
+  // NOTE: The delay can be negative here.  This is occurs when the
+  //       last callback took longer than the interval to execute.
+  //       While we don't have a time machine to fire the next
+  //       callback in the past, we do record the already-expired
+  //       desired time as our next target.  This allows us to keep
+  //       the interval synchronized to its original schedule once
+  //       the excessive delay has passed.  If we did not record this
+  //       negative delay here then we would essentially reset the
+  //       interval sequence to align to the current time.
+  //
+  //       Maintaining the original interval schedule is conformant
+  //       with other browsers.
 
   aTimeout->SetWhenOrTimeRemaining(aCurrentNow, delay);
 
   if (mWindow.IsSuspended()) {
     return true;
   }
 
   nsresult rv = MaybeSchedule(aTimeout->When(), aCurrentNow);
