# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8061f8cf414a4c7c8d12338f772c976fe5060801
Bug 1462772 P3 Make ServiceWorker binding objects get or create a handle to their associated registration. r=mrbkap

diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -58,17 +58,17 @@ ServiceWorker::Create(nsIGlobalObject* a
     return ref.forget();
   }
 
   RefPtr<ServiceWorkerInfo> info = reg->GetByDescriptor(aDescriptor);
   if (!info) {
     return ref.forget();
   }
 
-  RefPtr<ServiceWorker::Inner> inner = new ServiceWorkerImpl(info);
+  RefPtr<ServiceWorker::Inner> inner = new ServiceWorkerImpl(info, reg);
   ref = new ServiceWorker(aOwner, aDescriptor, inner);
   return ref.forget();
 }
 
 ServiceWorker::ServiceWorker(nsIGlobalObject* aGlobal,
                              const ServiceWorkerDescriptor& aDescriptor,
                              ServiceWorker::Inner* aInner)
   : DOMEventTargetHelper(aGlobal)
@@ -81,24 +81,53 @@ ServiceWorker::ServiceWorker(nsIGlobalOb
 
   KeepAliveIfHasListenersFor(NS_LITERAL_STRING("statechange"));
 
   // The error event handler is required by the spec currently, but is not used
   // anywhere.  Don't keep the object alive in that case.
 
   // This will update our state too.
   mInner->AddServiceWorker(this);
+
+  // Attempt to get an existing binding object for the registration
+  // associated with this ServiceWorker.
+  RefPtr<ServiceWorkerRegistration> reg = aGlobal->GetServiceWorkerRegistration(
+    ServiceWorkerRegistrationDescriptor(mDescriptor.RegistrationId(),
+                                        mDescriptor.PrincipalInfo(),
+                                        mDescriptor.Scope(),
+                                        ServiceWorkerUpdateViaCache::Imports));
+  if (reg) {
+    MaybeAttachToRegistration(reg);
+  } else {
+    RefPtr<ServiceWorker> self = this;
+
+    mInner->GetRegistration(
+      [self = std::move(self)] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+        nsIGlobalObject* global = self->GetParentObject();
+        NS_ENSURE_TRUE_VOID(global);
+        RefPtr<ServiceWorkerRegistration> reg =
+          global->GetOrCreateServiceWorkerRegistration(aDescriptor);
+        self->MaybeAttachToRegistration(reg);
+      }, [] (ErrorResult& aRv) {
+        // do nothing
+        aRv.SuppressException();
+      });
+  }
 }
 
 ServiceWorker::~ServiceWorker()
 {
   MOZ_ASSERT(NS_IsMainThread());
   mInner->RemoveServiceWorker(this);
 }
 
+NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorker,
+                                   DOMEventTargetHelper,
+                                   mRegistration);
+
 NS_IMPL_ADDREF_INHERITED(ServiceWorker, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorker, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorker)
   NS_INTERFACE_MAP_ENTRY(ServiceWorker)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 JSObject*
@@ -196,10 +225,19 @@ ServiceWorker::Descriptor() const
 }
 
 void
 ServiceWorker::DisconnectFromOwner()
 {
   DOMEventTargetHelper::DisconnectFromOwner();
 }
 
+void
+ServiceWorker::MaybeAttachToRegistration(ServiceWorkerRegistration* aRegistration)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aRegistration);
+  MOZ_DIAGNOSTIC_ASSERT(!mRegistration);
+
+  mRegistration = aRegistration;
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_serviceworker_h__
 #define mozilla_dom_serviceworker_h__
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/ServiceWorkerUtils.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 class nsIGlobalObject;
 
 namespace mozilla {
@@ -50,26 +51,32 @@ public:
     virtual void
     AddServiceWorker(ServiceWorker* aWorker) = 0;
 
     // This is called when the DOM ServiceWorker object is
     // destroyed and drops its ref to the Inner object.
     virtual void
     RemoveServiceWorker(ServiceWorker* aWorker) = 0;
 
+    // Get the associated registration for this ServiceWorker.
+    virtual void
+    GetRegistration(ServiceWorkerRegistrationCallback&& aSuccessCB,
+                    ServiceWorkerFailureCallback&& aFailureCB) = 0;
+
     virtual void
     PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                 const ClientInfo& aClientInfo,
                 const ClientState& aClientState) = 0;
 
     NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
   };
 
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_SERVICEWORKER_IID)
   NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorker, DOMEventTargetHelper)
 
   IMPL_EVENT_HANDLER(statechange)
   IMPL_EVENT_HANDLER(error)
 
   static already_AddRefed<ServiceWorker>
   Create(nsIGlobalObject* aOwner, const ServiceWorkerDescriptor& aDescriptor);
 
   virtual JSObject*
@@ -97,19 +104,23 @@ public:
 private:
   ServiceWorker(nsIGlobalObject* aWindow,
                 const ServiceWorkerDescriptor& aDescriptor,
                 Inner* aInner);
 
   // This class is reference-counted and will be destroyed from Release().
   ~ServiceWorker();
 
+  void
+  MaybeAttachToRegistration(ServiceWorkerRegistration* aRegistration);
+
   ServiceWorkerDescriptor mDescriptor;
 
   RefPtr<Inner> mInner;
+  RefPtr<ServiceWorkerRegistration> mRegistration;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(ServiceWorker, NS_DOM_SERVICEWORKER_IID)
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_serviceworker_h__
diff --git a/dom/serviceworkers/ServiceWorkerImpl.cpp b/dom/serviceworkers/ServiceWorkerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerImpl.cpp
@@ -32,16 +32,23 @@ void
 ServiceWorkerImpl::RemoveServiceWorker(ServiceWorker* aWorker)
 {
   MOZ_DIAGNOSTIC_ASSERT(mOuter);
   MOZ_DIAGNOSTIC_ASSERT(mOuter == aWorker);
   mOuter = nullptr;
 }
 
 void
+ServiceWorkerImpl::GetRegistration(ServiceWorkerRegistrationCallback&& aSuccessCB,
+                                   ServiceWorkerFailureCallback&& aFailureCB)
+{
+  aSuccessCB(mReg->Descriptor());
+}
+
+void
 ServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mInfo->PostMessage(std::move(aData), aClientInfo, aClientState);
 }
 
 void
@@ -49,17 +56,20 @@ ServiceWorkerImpl::SetState(ServiceWorke
 {
   if (!mOuter) {
     return;
   }
   mOuter->SetState(aState);
 }
 
 
-ServiceWorkerImpl::ServiceWorkerImpl(ServiceWorkerInfo* aInfo)
+ServiceWorkerImpl::ServiceWorkerImpl(ServiceWorkerInfo* aInfo,
+                                     ServiceWorkerRegistrationInfo* aReg)
   : mInfo(aInfo)
+  , mReg(aReg)
   , mOuter(nullptr)
 {
   MOZ_DIAGNOSTIC_ASSERT(mInfo);
+  MOZ_DIAGNOSTIC_ASSERT(mReg);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerImpl.h b/dom/serviceworkers/ServiceWorkerImpl.h
--- a/dom/serviceworkers/ServiceWorkerImpl.h
+++ b/dom/serviceworkers/ServiceWorkerImpl.h
@@ -9,43 +9,50 @@
 
 #include "ServiceWorker.h"
 #include "ServiceWorkerInfo.h"
 
 namespace mozilla {
 namespace dom {
 
 class ServiceWorkerInfo;
+class ServiceWorkerRegistrationInfo;
 
 class ServiceWorkerImpl final : public ServiceWorker::Inner
                               , public ServiceWorkerInfo::Listener
 {
   RefPtr<ServiceWorkerInfo> mInfo;
+  RefPtr<ServiceWorkerRegistrationInfo> mReg;
   ServiceWorker* mOuter;
 
   ~ServiceWorkerImpl();
 
   // ServiceWorker::Inner interface
   void
   AddServiceWorker(ServiceWorker* aWorker) override;
 
   void
   RemoveServiceWorker(ServiceWorker* aWorker) override;
 
   void
+  GetRegistration(ServiceWorkerRegistrationCallback&& aSuccessCB,
+                  ServiceWorkerFailureCallback&& aFailureCB) override;
+
+  void
   PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
               const ClientInfo& aClientInfo,
               const ClientState& aClientState) override;
 
   // ServiceWorkerInfo::Listener interface
   void
   SetState(ServiceWorkerState aState) override;
 
 public:
-  explicit ServiceWorkerImpl(ServiceWorkerInfo* aInfo);
+  ServiceWorkerImpl(ServiceWorkerInfo* aInfo,
+                    ServiceWorkerRegistrationInfo* aReg);
 
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerImpl, override);
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerImpl_h
