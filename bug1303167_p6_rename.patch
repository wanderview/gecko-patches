# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  73bade5a3f6648c9c7020de7f28c6211dcb27fba
Bug 1303167 P6 Rename new suspend and freeze methods to final names. r=smaug

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -8914,21 +8914,21 @@ nsDocShell::RestoreFromHistory()
                    "error in InsertChild");
     }
   }
 
   // If parent is suspended, increase suspension count.
   // This can't be done as early as event suppression since this
   // depends on docshell tree.
   MOZ_ASSERT(privWin->GetCurrentInnerWindow());
-  privWin->GetCurrentInnerWindow()->NewSyncSuspendAndFreezeStateToParentWindow();
+  privWin->GetCurrentInnerWindow()->SyncSuspendAndFreezeStateToParentWindow();
 
   // Now that all of the child docshells have been put into place, we can
   // restart the timers for the window and all of the child frames.
-  privWin->NewResume();
+  privWin->Resume();
 
   // Restore the refresh URI list.  The refresh timers will be restarted
   // when EndPageLoad() is called.
   mRefreshURIList = refreshURIList;
 
   // Meta-refresh timers have been restarted for this shell, but not
   // for our children.  Walk the child shells and restart their timers.
   nsTObserverArray<nsDocLoader*>::ForwardIterator iter(mChildList);
diff --git a/dom/base/nsDOMWindowUtils.cpp b/dom/base/nsDOMWindowUtils.cpp
--- a/dom/base/nsDOMWindowUtils.cpp
+++ b/dom/base/nsDOMWindowUtils.cpp
@@ -2274,28 +2274,28 @@ nsDOMWindowUtils::GetCurrentInnerWindowI
 }
 
 NS_IMETHODIMP
 nsDOMWindowUtils::SuspendTimeouts()
 {
   nsCOMPtr<nsPIDOMWindowOuter> window = do_QueryReferent(mWindow);
   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 
-  window->NewSuspend();
+  window->Suspend();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMWindowUtils::ResumeTimeouts()
 {
   nsCOMPtr<nsPIDOMWindowOuter> window = do_QueryReferent(mWindow);
   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 
-  window->NewResume();
+  window->Resume();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMWindowUtils::GetLayerManagerType(nsAString& aType)
 {
   nsCOMPtr<nsIWidget> widget = GetWidget();
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -8192,17 +8192,17 @@ nsDocument::EnumerateSubDocuments(nsSubD
 bool
 nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
 {
   if (EventHandlingSuppressed()) {
     return false;
   }
 
   nsPIDOMWindowInner* win = GetInnerWindow();
-  if (win && win->NewIsSuspended() && !win->NewIsFrozen()) {
+  if (win && win->IsSuspended() && !win->IsFrozen()) {
     return false;
   }
 
   // Check our event listener manager for unload/beforeunload listeners.
   nsCOMPtr<EventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
   if (piTarget) {
     EventListenerManager* manager = piTarget->GetExistingListenerManager();
     if (manager && manager->HasUnloadListeners()) {
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -1484,23 +1484,23 @@ nsFocusManager::AdjustWindowFocus(nsPIDO
       window->SetFocusedNode(frameElement);
     }
   }
 }
 
 bool
 nsFocusManager::IsWindowVisible(nsPIDOMWindowOuter* aWindow)
 {
-  if (!aWindow || aWindow->NewIsFrozen())
+  if (!aWindow || aWindow->IsFrozen())
     return false;
 
   // Check if the inner window is frozen as well. This can happen when a focus change
   // occurs while restoring a previous page.
   nsPIDOMWindowInner* innerWindow = aWindow->GetCurrentInnerWindow();
-  if (!innerWindow || innerWindow->NewIsFrozen())
+  if (!innerWindow || innerWindow->IsFrozen())
     return false;
 
   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
   nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(docShell));
   if (!baseWin)
     return false;
 
   bool visible = false;
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -1256,17 +1256,17 @@ nsGlobalWindow::nsGlobalWindow(nsGlobalW
         os->AddObserver(mObserver, "dom-storage2-changed", false);
       }
 
       Preferences::AddStrongObserver(mObserver, "intl.accept_languages");
     }
   } else {
     // |this| is an outer window. Outer windows start out frozen and
     // remain frozen until they get an inner window.
-    MOZ_ASSERT(NewIsFrozen());
+    MOZ_ASSERT(IsFrozen());
 
     // As an outer window, we may be the root of a constellation. This initial
     // static constellation may be overridden as this window is given a parent
     // window or an opener.
     mStaticConstellation = WindowID();
   }
 
   // We could have failed the first time through trying
@@ -2294,17 +2294,17 @@ NS_DEFINE_STATIC_IID_ACCESSOR(WindowStat
 
 WindowStateHolder::WindowStateHolder(nsGlobalWindow* aWindow)
   : mInnerWindow(aWindow),
     mInnerWindowReflector(RootingCx(), aWindow->GetWrapper())
 {
   NS_PRECONDITION(aWindow, "null window");
   NS_PRECONDITION(aWindow->IsInnerWindow(), "Saving an outer window");
 
-  aWindow->NewSuspend();
+  aWindow->Suspend();
 
   // When a global goes into the bfcache, we disable script.
   xpc::Scriptability::Get(mInnerWindowReflector).SetDocShellAllowsScript(false);
 }
 
 WindowStateHolder::~WindowStateHolder()
 {
   if (mInnerWindow) {
@@ -2634,17 +2634,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
   bool thisChrome = IsChromeWindow();
 
   nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
   NS_ASSERTION(!aState || wsh, "What kind of weird state are you giving me here?");
 
   JS::Rooted<JSObject*> newInnerGlobal(cx);
   if (reUseInnerWindow) {
     // We're reusing the current inner window.
-    NS_ASSERTION(!currentInner->NewIsFrozen(),
+    NS_ASSERTION(!currentInner->IsFrozen(),
                  "We should never be reusing a shared inner window");
     newInnerWindow = currentInner;
     newInnerGlobal = currentInner->GetWrapperPreserveColor();
 
     if (aDocument != oldDoc) {
       JS::ExposeObjectToActiveJS(newInnerGlobal);
     }
 
@@ -2744,17 +2744,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
                                              currentInner->mPerformance->GetDOMTiming(),
                                              currentInner->mPerformance->GetChannel(),
                                              currentInner->mPerformance->GetParentPerformance());
         }
       }
 
       // Don't free objects on our current inner window if it's going to be
       // held in the bfcache.
-      if (!currentInner->NewIsFrozen()) {
+      if (!currentInner->IsFrozen()) {
         currentInner->FreeInnerObjects();
       }
     }
 
     mInnerWindow = newInnerWindow->AsInner();
 
     if (!GetWrapperPreserveColor()) {
       JS::Rooted<JSObject*> outer(cx,
@@ -2844,17 +2844,17 @@ nsGlobalWindow::SetNewDocument(nsIDocume
     JS::Rooted<JSObject*> rootedJSObject(cx, GetWrapperPreserveColor());
     JS::Rooted<JSObject*> proto1(cx), proto2(cx);
     JS_GetPrototype(cx, rootedJSObject, &proto1);
     JS_GetPrototype(cx, newInnerGlobal, &proto2);
     NS_ASSERTION(proto1 == proto2,
                  "outer and inner globals should have the same prototype");
 #endif
 
-    newInnerWindow->NewSyncSuspendAndFreezeStateToParentWindow();
+    newInnerWindow->SyncSuspendAndFreezeStateToParentWindow();
   }
 
   // Add an extra ref in case we release mContext during GC.
   nsCOMPtr<nsIScriptContext> kungFuDeathGrip(mContext);
 
   aDocument->SetScriptGlobalObject(newInnerWindow);
 
   if (!aState) {
@@ -8788,17 +8788,17 @@ nsGlobalWindow::EnterModalState()
   if (topWin->mModalStateDepth == 0) {
     NS_ASSERTION(!topWin->mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
 
     topWin->mSuspendedDoc = topDoc;
     if (topDoc) {
       topDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly);
     }
 
-    topWin->NewSuspend();
+    topWin->Suspend();
   }
   topWin->mModalStateDepth++;
 }
 
 void
 nsGlobalWindow::LeaveModalState()
 {
   MOZ_ASSERT(IsOuterWindow(), "Modal state is maintained on outer windows");
@@ -8806,22 +8806,22 @@ nsGlobalWindow::LeaveModalState()
   nsGlobalWindow* topWin = GetScriptableTopInternal();
 
   if (!topWin) {
     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
     return;
   }
 
   MOZ_ASSERT(topWin->mModalStateDepth != 0);
-  MOZ_ASSERT(NewIsSuspended());
-  MOZ_ASSERT(topWin->NewIsSuspended());
+  MOZ_ASSERT(IsSuspended());
+  MOZ_ASSERT(topWin->IsSuspended());
   topWin->mModalStateDepth--;
 
   if (topWin->mModalStateDepth == 0) {
-    topWin->NewResume();
+    topWin->Resume();
 
     if (topWin->mSuspendedDoc) {
       nsCOMPtr<nsIDocument> currentDoc = topWin->GetExtantDoc();
       topWin->mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eAnimationsOnly,
                                                                   currentDoc == topWin->mSuspendedDoc);
       topWin->mSuspendedDoc = nullptr;
     }
   }
@@ -10209,17 +10209,17 @@ nsGlobalWindow::DispatchAsyncHashchange(
 
 nsresult
 nsGlobalWindow::FireHashchange(const nsAString &aOldURL,
                                const nsAString &aNewURL)
 {
   MOZ_ASSERT(IsInnerWindow());
 
   // Don't do anything if the window is frozen.
-  if (NewIsFrozen()) {
+  if (IsFrozen()) {
     return NS_OK;
   }
 
   // Get a presentation shell for use in creating the hashchange event.
   NS_ENSURE_STATE(AsInner()->IsCurrentInnerWindow());
 
   nsIPresShell *shell = mDoc->GetShell();
   RefPtr<nsPresContext> presContext;
@@ -10248,17 +10248,17 @@ nsGlobalWindow::DispatchSyncPopState()
 {
   MOZ_RELEASE_ASSERT(IsInnerWindow());
   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
                "Must be safe to run script here.");
 
   nsresult rv = NS_OK;
 
   // Bail if the window is frozen.
-  if (NewIsFrozen()) {
+  if (IsFrozen()) {
     return NS_OK;
   }
 
   // Get the document's pending state object -- it contains the data we're
   // going to send along with the popstate event.  The object is serialized
   // using structured clone.
   nsCOMPtr<nsIVariant> stateObj;
   rv = mDoc->GetStateObject(getter_AddRefs(stateObj));
@@ -11360,38 +11360,38 @@ nsGlobalWindow::UnregisterIdleObserver(n
   return NS_OK;
 }
 
 nsresult
 nsGlobalWindow::Observe(nsISupports* aSubject, const char* aTopic,
                         const char16_t* aData)
 {
   if (!nsCRT::strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC)) {
-    if (!NewIsFrozen()) {
+    if (!IsFrozen()) {
         // Fires an offline status event if the offline status has changed
         FireOfflineStatusEventIfChanged();
     }
     return NS_OK;
   }
 
   if (!nsCRT::strcmp(aTopic, OBSERVER_TOPIC_IDLE)) {
     mCurrentlyIdle = true;
-    if (NewIsFrozen()) {
+    if (IsFrozen()) {
       // need to fire only one idle event while the window is frozen.
       mNotifyIdleObserversIdleOnThaw = true;
       mNotifyIdleObserversActiveOnThaw = false;
     } else if (AsInner()->IsCurrentInnerWindow()) {
       HandleIdleActiveEvent();
     }
     return NS_OK;
   }
 
   if (!nsCRT::strcmp(aTopic, OBSERVER_TOPIC_ACTIVE)) {
     mCurrentlyIdle = false;
-    if (NewIsFrozen()) {
+    if (IsFrozen()) {
       mNotifyIdleObserversActiveOnThaw = true;
       mNotifyIdleObserversIdleOnThaw = false;
     } else if (AsInner()->IsCurrentInnerWindow()) {
       MOZ_ASSERT(IsInnerWindow());
       ScheduleActiveTimerCallback();
     }
     return NS_OK;
   }
@@ -11500,17 +11500,17 @@ nsGlobalWindow::Observe(nsISupports* aSu
 
     newEvent->SetTrusted(true);
 
     if (fireMozStorageChanged) {
       WidgetEvent* internalEvent = newEvent->WidgetEventPtr();
       internalEvent->mFlags.mOnlyChromeDispatch = true;
     }
 
-    if (NewIsFrozen()) {
+    if (IsFrozen()) {
       // This window is frozen, rather than firing the events here,
       // store the domain in which the change happened and fire the
       // events if we're ever thawed.
 
       mPendingStorageEvents.AppendElement(newEvent);
       return NS_OK;
     }
 
@@ -11625,22 +11625,22 @@ nsGlobalWindow::CloneStorageEvent(const 
 
   dict.mStorageArea = storage;
 
   RefPtr<StorageEvent> event = StorageEvent::Constructor(this, aType, dict);
   return event.forget();
 }
 
 void
-nsGlobalWindow::NewSuspend()
+nsGlobalWindow::Suspend()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  FORWARD_TO_INNER_VOID(NewSuspend, ());
-
-  CallOnChildren(&nsGlobalWindow::NewSuspend);
+  FORWARD_TO_INNER_VOID(Suspend, ());
+
+  CallOnChildren(&nsGlobalWindow::Suspend);
 
   mSuspendDepth += 1;
   if (mSuspendDepth != 1) {
     return;
   }
 
   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
   if (ac) {
@@ -11673,22 +11673,22 @@ nsGlobalWindow::NewSuspend()
   // Suspend all of the AudioContexts for this window
   for (uint32_t i = 0; i < mAudioContexts.Length(); ++i) {
     ErrorResult dummy;
     RefPtr<Promise> d = mAudioContexts[i]->Suspend(dummy);
   }
 }
 
 void
-nsGlobalWindow::NewResume()
+nsGlobalWindow::Resume()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  FORWARD_TO_INNER_VOID(NewResume, ());
-
-  CallOnChildren(&nsGlobalWindow::NewResume);
+  FORWARD_TO_INNER_VOID(Resume, ());
+
+  CallOnChildren(&nsGlobalWindow::Resume);
 
   MOZ_ASSERT(mSuspendDepth != 0);
   mSuspendDepth -= 1;
   if (mSuspendDepth != 0) {
     return;
   }
 
   // We should not be able to resume a frozen window.  It must be Thaw()'d first.
@@ -11757,40 +11757,40 @@ nsGlobalWindow::NewResume()
 
   // Resume all of the workers for this window.  We must do this
   // after timeouts since workers may have queued events that can trigger
   // a setTimeout().
   mozilla::dom::workers::ResumeWorkersForWindow(AsInner());
 }
 
 bool
-nsGlobalWindow::NewIsSuspended() const
+nsGlobalWindow::IsSuspended() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   // No inner means we are effectively suspended
-  FORWARD_TO_INNER(NewIsSuspended, (), true);
+  FORWARD_TO_INNER(IsSuspended, (), true);
   return mSuspendDepth != 0;
 }
 
 void
-nsGlobalWindow::NewFreeze()
+nsGlobalWindow::Freeze()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  FORWARD_TO_INNER_VOID(NewFreeze, ());
-  NewSuspend();
-  NewFreezeInternal();
-}
-
-void
-nsGlobalWindow::NewFreezeInternal()
+  FORWARD_TO_INNER_VOID(Freeze, ());
+  Suspend();
+  FreezeInternal();
+}
+
+void
+nsGlobalWindow::FreezeInternal()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(NewIsSuspended());
-
-  CallOnChildren(&nsGlobalWindow::NewFreezeInternal);
+  MOZ_ASSERT(IsSuspended());
+
+  CallOnChildren(&nsGlobalWindow::FreezeInternal);
 
   mFreezeDepth += 1;
   if (mFreezeDepth != 1) {
     return;
   }
 
   mozilla::dom::workers::FreezeWorkersForWindow(AsInner());
 
@@ -11810,31 +11810,31 @@ nsGlobalWindow::NewFreezeInternal()
     // this timeout entry.
     MOZ_ASSERT(!t->mTimer);
   }
 
   NotifyDOMWindowFrozen(this);
 }
 
 void
-nsGlobalWindow::NewThaw()
+nsGlobalWindow::Thaw()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  FORWARD_TO_INNER_VOID(NewThaw, ());
-  NewThawInternal();
-  NewResume();
-}
-
-void
-nsGlobalWindow::NewThawInternal()
+  FORWARD_TO_INNER_VOID(Thaw, ());
+  ThawInternal();
+  Resume();
+}
+
+void
+nsGlobalWindow::ThawInternal()
 {
   MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(NewIsSuspended());
-
-  CallOnChildren(&nsGlobalWindow::NewThawInternal);
+  MOZ_ASSERT(IsSuspended());
+
+  CallOnChildren(&nsGlobalWindow::ThawInternal);
 
   MOZ_ASSERT(mFreezeDepth != 0);
   mFreezeDepth -= 1;
   if (mFreezeDepth != 0) {
     return;
   }
 
   TimeStamp now = TimeStamp::Now();
@@ -11857,28 +11857,28 @@ nsGlobalWindow::NewThawInternal()
   }
 
   mozilla::dom::workers::ThawWorkersForWindow(AsInner());
 
   NotifyDOMWindowThawed(this);
 }
 
 bool
-nsGlobalWindow::NewIsFrozen() const
+nsGlobalWindow::IsFrozen() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   // No inner means we are effectively frozen
-  FORWARD_TO_INNER(NewIsFrozen, (), true);
+  FORWARD_TO_INNER(IsFrozen, (), true);
   bool frozen =  mFreezeDepth != 0;
-  MOZ_ASSERT_IF(frozen, NewIsSuspended());
+  MOZ_ASSERT_IF(frozen, IsSuspended());
   return frozen;
 }
 
 void
-nsGlobalWindow::NewSyncSuspendAndFreezeStateToParentWindow()
+nsGlobalWindow::SyncSuspendAndFreezeStateToParentWindow()
 {
   // This method should only be called on an inner window that has been
   // assigned to an outer window already.
   MOZ_ASSERT(IsInnerWindow());
   nsPIDOMWindowOuter* outer = GetOuterWindow();
   MOZ_ASSERT(outer);
 
   // Attempt to find our parent windows.
@@ -11889,35 +11889,35 @@ nsGlobalWindow::NewSyncSuspendAndFreezeS
     parentOuter ? nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow())
                 : nullptr;
 
   // If our outer is in a modal state, but our parent is not in a modal
   // state, then we must apply the suspend directly.  If our parent is
   // in a modal state then we should get the suspend automatically
   // via the parentSuspendDepth application below.
   if ((!parentInner || !parentInner->IsInModalState()) && IsInModalState()) {
-    NewSuspend();
+    Suspend();
   }
 
   uint32_t parentFreezeDepth = parentInner ? parentInner->mFreezeDepth : 0;
   uint32_t parentSuspendDepth = parentInner ? parentInner->mSuspendDepth : 0;
 
   // Since every Freeze() calls Suspend(), the suspend count must
   // be equal or greater to the freeze count.
   MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
 
   // First apply the Freeze() calls.
   for (uint32_t i = 0; i < parentFreezeDepth; ++i) {
-    NewFreeze();
+    Freeze();
   }
 
   // Now apply only the number of Suspend() calls to reach the target
   // suspend count after applying the Freeze() calls.
   for (uint32_t i = 0; i < (parentSuspendDepth - parentFreezeDepth); ++i) {
-    NewSuspend();
+    Suspend();
   }
 }
 
 template<typename Method>
 void
 nsGlobalWindow::CallOnChildren(Method aMethod)
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -12408,31 +12408,31 @@ nsGlobalWindow::SetTimeoutOrInterval(nsI
   if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
     // Don't allow timeouts less than DOMMinTimeoutValue() from
     // now...
     realInterval = std::max(realInterval, uint32_t(DOMMinTimeoutValue()));
   }
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
 
-  if (NewIsFrozen()) {
+  if (IsFrozen()) {
     // If we are frozen simply set timeout->mTimeRemaining to be the
     // "time remaining" in the timeout (i.e., the interval itself).  This
     // will be used to create a new mWhen time when the window is thawed.
     // The end effect is that time does not appear to pass for frozen windows.
     timeout->mTimeRemaining = delta;
   } else {
     // Since we are not frozen we must set a precise mWhen target wakeup
     // time.  Even if we are suspended we want to use this target time so
     // that it appears time passes while suspended.
     timeout->mWhen = TimeStamp::Now() + delta;
   }
 
   // If we're not suspended, then set the timer.
-  if (!NewIsSuspended()) {
+  if (!IsSuspended()) {
     MOZ_ASSERT(!timeout->mWhen.IsNull());
 
     nsresult rv;
     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
@@ -12685,17 +12685,17 @@ nsGlobalWindow::RescheduleTimeout(nsTime
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
   // time to run the callback.
   if (delay < TimeDuration(0)) {
     delay = TimeDuration(0);
   }
 
   if (!aTimeout->mTimer) {
-    NS_ASSERTION(NewIsFrozen() || NewIsSuspended(),
+    NS_ASSERTION(IsFrozen() || IsSuspended(),
                  "How'd our timer end up null if we're not frozen or "
                  "suspended?");
 
     aTimeout->mTimeRemaining = delay;
     return true;
   }
 
   aTimeout->mWhen = currentNow + delay;
@@ -12724,22 +12724,22 @@ nsGlobalWindow::RescheduleTimeout(nsTime
   }
 
   return true;
 }
 
 void
 nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
 {
-  if (NewIsSuspended()) {
+  if (IsSuspended()) {
     return;
   }
 
   NS_ASSERTION(IsInnerWindow(), "Timeout running on outer window!");
-  NS_ASSERTION(!NewIsFrozen(), "Timeout running on a window in the bfcache!");
+  NS_ASSERTION(!IsFrozen(), "Timeout running on a window in the bfcache!");
 
   nsTimeout *nextTimeout;
   nsTimeout *last_expired_timeout, *last_insertion_point;
   uint32_t firingDepth = mTimeoutFiringDepth + 1;
 
   // Make sure that the window and the script context don't go away as
   // a result of running timeouts
   nsCOMPtr<nsIScriptGlobalObject> windowKungFuDeathGrip(this);
@@ -12805,28 +12805,28 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
   RefPtr<nsTimeout> timeoutExtraRef(dummy_timeout);
 
   last_insertion_point = mTimeoutInsertionPoint;
   // If we ever start setting mTimeoutInsertionPoint to a non-dummy timeout,
   // the logic in ResetTimersForNonBackgroundWindow will need to change.
   mTimeoutInsertionPoint = dummy_timeout;
 
   for (nsTimeout *timeout = mTimeouts.getFirst();
-       timeout != dummy_timeout && !NewIsFrozen();
+       timeout != dummy_timeout && !IsFrozen();
        timeout = nextTimeout) {
     nextTimeout = timeout->getNext();
 
     if (timeout->mFiringDepth != firingDepth) {
       // We skip the timeout since it's on the list to run at another
       // depth.
 
       continue;
     }
 
-    if (NewIsSuspended()) {
+    if (IsSuspended()) {
       // Some timer did suspend us. Make sure the
       // rest of the timers get executed later.
       timeout->mFiringDepth = 0;
       continue;
     }
 
     // The timeout is on the list to run at this depth, go ahead and
     // process it.
@@ -12917,17 +12917,17 @@ nsGlobalWindow::ClearTimeoutOrInterval(i
   }
 }
 
 nsresult nsGlobalWindow::ResetTimersForNonBackgroundWindow()
 {
   FORWARD_TO_INNER(ResetTimersForNonBackgroundWindow, (),
                    NS_ERROR_NOT_INITIALIZED);
 
-  if (NewIsFrozen() || NewIsSuspended()) {
+  if (IsFrozen() || IsSuspended()) {
     return NS_OK;
   }
 
   TimeStamp now = TimeStamp::Now();
 
   // If mTimeoutInsertionPoint is non-null, we're in the middle of firing
   // timers and the timers we're planning to fire all come before
   // mTimeoutInsertionPoint; mTimeoutInsertionPoint itself is a dummy timeout
@@ -13056,17 +13056,17 @@ nsGlobalWindow::InsertTimeoutIntoList(ns
   // Start at mLastTimeout and go backwards.  Don't go further than
   // mTimeoutInsertionPoint, though.  This optimizes for the common case of
   // insertion at the end.
   nsTimeout* prevSibling;
   for (prevSibling = mTimeouts.getLast();
        prevSibling && prevSibling != mTimeoutInsertionPoint &&
          // This condition needs to match the one in SetTimeoutOrInterval that
          // determines whether to set mWhen or mTimeRemaining.
-         (NewIsFrozen() ?
+         (IsFrozen() ?
           prevSibling->mTimeRemaining > aTimeout->mTimeRemaining :
           prevSibling->mWhen > aTimeout->mWhen);
        prevSibling = prevSibling->getPrevious()) {
     /* Do nothing; just searching */
   }
 
   // Now link in aTimeout after prevSibling.
   if (prevSibling) {
@@ -13247,17 +13247,17 @@ nsGlobalWindow::SaveWindowState()
   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
   NS_ASSERTION(inner, "No inner window to save");
 
   // Don't do anything else to this inner window! After this point, all
   // calls to SetTimeoutOrInterval will create entries in the timeout
   // list that will only run after this window has come out of the bfcache.
   // Also, while we're frozen, we won't dispatch online/offline events
   // to the page.
-  inner->NewFreeze();
+  inner->Freeze();
 
   nsCOMPtr<nsISupports> state = new WindowStateHolder(inner);
 
 #ifdef DEBUG_PAGE_CACHE
   printf("saving window state, state = %p\n", (void*)state);
 #endif
 
   return state.forget();
@@ -13290,17 +13290,17 @@ nsGlobalWindow::RestoreWindowState(nsISu
     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
     if (fm) {
       nsCOMPtr<nsIDOMElement> focusedElement(do_QueryInterface(focusedNode));
       fm->SetFocus(focusedElement, nsIFocusManager::FLAG_NOSCROLL |
                                    nsIFocusManager::FLAG_SHOWRING);
     }
   }
 
-  inner->NewThaw();
+  inner->Thaw();
 
   holder->DidRestoreWindow();
 
   return NS_OK;
 }
 
 void
 nsGlobalWindow::EnableDeviceSensor(uint32_t aType)
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -434,23 +434,23 @@ public:
 
   virtual PopupControlState PushPopupControlState(PopupControlState state, bool aForce) const override;
   virtual void PopPopupControlState(PopupControlState state) const override;
   virtual PopupControlState GetPopupControlState() const override;
 
   virtual already_AddRefed<nsISupports> SaveWindowState() override;
   virtual nsresult RestoreWindowState(nsISupports *aState) override;
 
-  virtual void NewSuspend() override;
-  virtual void NewResume() override;
-  virtual bool NewIsSuspended() const override;
-  virtual void NewFreeze() override;
-  virtual void NewThaw() override;
-  virtual bool NewIsFrozen() const override;
-  virtual void NewSyncSuspendAndFreezeStateToParentWindow() override;
+  virtual void Suspend() override;
+  virtual void Resume() override;
+  virtual bool IsSuspended() const override;
+  virtual void Freeze() override;
+  virtual void Thaw() override;
+  virtual bool IsFrozen() const override;
+  virtual void SyncSuspendAndFreezeStateToParentWindow() override;
 
   virtual nsresult FireDelayedDOMEvents() override;
   virtual bool IsRunningTimeout() override { return mTimeoutFiringDepth > 0; }
 
   // Outer windows only.
   virtual bool WouldReuseInnerWindow(nsIDocument* aNewDocument) override;
 
   virtual void SetDocShell(nsIDocShell* aDocShell) override;
@@ -1491,18 +1491,18 @@ private:
                         nsISupports *aExtraArgument,
                         nsIDocShellLoadInfo* aLoadInfo,
                         bool aForceNoOpener,
                         nsPIDOMWindowOuter **aReturn);
 
   template<typename Method>
   void CallOnChildren(Method aMethod);
 
-  void NewFreezeInternal();
-  void NewThawInternal();
+  void FreezeInternal();
+  void ThawInternal();
 
 public:
   // Timeout Functions
   // Language agnostic timeout function (all args passed).
   // |interval| is in milliseconds.
   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
                                 int32_t interval,
                                 bool aIsInterval, int32_t* aReturn);
diff --git a/dom/base/nsPIDOMWindow.h b/dom/base/nsPIDOMWindow.h
--- a/dom/base/nsPIDOMWindow.h
+++ b/dom/base/nsPIDOMWindow.h
@@ -217,34 +217,34 @@ public:
 
   // Calling suspend should prevent any asynchronous tasks from
   // executing javascript for this window.  This means setTimeout,
   // requestAnimationFrame, and events should not be fired. Suspending
   // a window also suspends its children and workers.  Workers may
   // continue to perform computations in the background.  A window
   // can have Suspend() called multiple times and will only resume after
   // a matching number of Resume() calls.
-  virtual void NewSuspend() = 0;
-  virtual void NewResume() = 0;
-  virtual bool NewIsSuspended() const = 0;
+  virtual void Suspend() = 0;
+  virtual void Resume() = 0;
+  virtual bool IsSuspended() const = 0;
 
   // Calling Freeze() on a window will automatically Suspend() it.  In
   // addition, the window and its children are further treated as no longer
   // suitable for interaction with the user.  For example, it may be marked
   // non-visible, cannot be focused, etc.  All worker threads are also frozen
   // bringing them to a complete stop.  A window can have Freeze() called
   // multiple times and will only thaw after a matching number of Thaw()
   // calls.
-  virtual void NewFreeze() = 0;
-  virtual void NewThaw() = 0;
-  virtual bool NewIsFrozen() const = 0;
+  virtual void Freeze() = 0;
+  virtual void Thaw() = 0;
+  virtual bool IsFrozen() const = 0;
 
   // When a window is inserted into the tree it should inherit its parent
   // window's suspend and freeze state.
-  virtual void NewSyncSuspendAndFreezeStateToParentWindow() = 0;
+  virtual void SyncSuspendAndFreezeStateToParentWindow() = 0;
 
   // Fire any DOM notification events related to things that happened while
   // the window was frozen.
   virtual nsresult FireDelayedDOMEvents() = 0;
 
   nsPIDOMWindowOuter* GetOuterWindow()
   {
     return mIsInnerWindow ? mOuterWindow.get() : AsOuter();
diff --git a/dom/base/nsWindowMemoryReporter.cpp b/dom/base/nsWindowMemoryReporter.cpp
--- a/dom/base/nsWindowMemoryReporter.cpp
+++ b/dom/base/nsWindowMemoryReporter.cpp
@@ -275,17 +275,17 @@ CollectWindowReports(nsGlobalWindow *aWi
 
   if (top) {
     windowPath += NS_LITERAL_CSTRING("top(");
     AppendWindowURI(top, windowPath, aAnonymize);
     windowPath.AppendPrintf(", id=%llu)", top->WindowID());
 
     aTopWindowPaths->Put(aWindow->WindowID(), windowPath);
 
-    windowPath += aWindow->NewIsFrozen() ? NS_LITERAL_CSTRING("/cached/")
+    windowPath += aWindow->IsFrozen() ? NS_LITERAL_CSTRING("/cached/")
                                       : NS_LITERAL_CSTRING("/active/");
   } else {
     if (aGhostWindowIDs->Contains(aWindow->WindowID())) {
       windowPath += NS_LITERAL_CSTRING("top(none)/ghost/");
     } else {
       windowPath += NS_LITERAL_CSTRING("top(none)/detached/");
     }
   }
diff --git a/dom/bindings/BindingUtils.cpp b/dom/bindings/BindingUtils.cpp
--- a/dom/bindings/BindingUtils.cpp
+++ b/dom/bindings/BindingUtils.cpp
@@ -2728,17 +2728,17 @@ IsNonExposedGlobal(JSContext* aCx, JSObj
   return false;
 }
 
 void
 HandlePrerenderingViolation(nsPIDOMWindowInner* aWindow)
 {
   // Suspend the window and its workers, and its children too.
   // TODO: should this be a freeze?
-  aWindow->NewSuspend();
+  aWindow->Suspend();
 
   // Suspend event handling on the document
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
   if (doc) {
     doc->SuppressEventHandling(nsIDocument::eEvents);
   }
 }
 
diff --git a/dom/indexedDB/ActorsChild.cpp b/dom/indexedDB/ActorsChild.cpp
--- a/dom/indexedDB/ActorsChild.cpp
+++ b/dom/indexedDB/ActorsChild.cpp
@@ -1790,17 +1790,17 @@ BackgroundDatabaseChild::RecvVersionChan
     return true;
   }
 
   RefPtr<IDBDatabase> kungFuDeathGrip = mDatabase;
 
   // Handle bfcache'd windows.
   if (nsPIDOMWindowInner* owner = kungFuDeathGrip->GetOwner()) {
     // The database must be closed if the window is already frozen.
-    bool shouldAbortAndClose = owner->NewIsFrozen();
+    bool shouldAbortAndClose = owner->IsFrozen();
 
     // Anything in the bfcache has to be evicted and then we have to close the
     // database also.
     if (nsCOMPtr<nsIDocument> doc = owner->GetExtantDoc()) {
       if (nsCOMPtr<nsIBFCacheEntry> bfCacheEntry = doc->GetBFCacheEntry()) {
         bfCacheEntry->RemoveFromBFCacheSync();
         shouldAbortAndClose = true;
       }
diff --git a/dom/offline/nsDOMOfflineResourceList.cpp b/dom/offline/nsDOMOfflineResourceList.cpp
--- a/dom/offline/nsDOMOfflineResourceList.cpp
+++ b/dom/offline/nsDOMOfflineResourceList.cpp
@@ -553,17 +553,17 @@ nsDOMOfflineResourceList::SendEvent(cons
   RefPtr<Event> event = NS_NewDOMEvent(this, nullptr, nullptr);
   event->InitEvent(aEventName, false, true);
 
   // We assume anyone that managed to call SendEvent is trusted
   event->SetTrusted(true);
 
   // If the window is frozen or we're still catching up on events that were
   // queued while frozen, save the event for later.
-  if (GetOwner()->NewIsFrozen() || mPendingEvents.Count() > 0) {
+  if (GetOwner()->IsFrozen() || mPendingEvents.Count() > 0) {
     mPendingEvents.AppendObject(event);
     return NS_OK;
   }
 
   bool dummy;
   DispatchEvent(event, &dummy);
 
   return NS_OK;
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -2253,21 +2253,21 @@ WorkerPrivateParent<Derived>::WorkerPriv
         GetNavigationStartHighRes();
     } else {
       mNowBaseTimeStamp = CreationTimeStamp();
       mNowBaseTimeHighRes = CreationTime();
     }
 
     // Our parent can get suspended after it initiates the async creation
     // of a new worker thread.  In this case suspend the new worker as well.
-    if (mLoadInfo.mWindow && mLoadInfo.mWindow->NewIsSuspended()) {
+    if (mLoadInfo.mWindow && mLoadInfo.mWindow->IsSuspended()) {
       ParentWindowPaused();
     }
 
-    if (mLoadInfo.mWindow && mLoadInfo.mWindow->NewIsFrozen()) {
+    if (mLoadInfo.mWindow && mLoadInfo.mWindow->IsFrozen()) {
       Freeze(mLoadInfo.mWindow);
     }
   }
 }
 
 template <class Derived>
 WorkerPrivateParent<Derived>::~WorkerPrivateParent()
 {
diff --git a/dom/xhr/XMLHttpRequestMainThread.cpp b/dom/xhr/XMLHttpRequestMainThread.cpp
--- a/dom/xhr/XMLHttpRequestMainThread.cpp
+++ b/dom/xhr/XMLHttpRequestMainThread.cpp
@@ -131,17 +131,17 @@ NS_IMPL_ISUPPORTS(nsXHRParseEndListener,
 
 class nsResumeTimeoutsEvent : public Runnable
 {
 public:
   explicit nsResumeTimeoutsEvent(nsPIDOMWindowInner* aWindow) : mWindow(aWindow) {}
 
   NS_IMETHOD Run() override
   {
-    mWindow->NewResume();
+    mWindow->Resume();
     return NS_OK;
   }
 
 private:
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
 };
 
 
@@ -2918,17 +2918,17 @@ XMLHttpRequestMainThread::SendInternal(c
     nsCOMPtr<nsIRunnable> resumeTimeoutRunnable;
     if (GetOwner()) {
       if (nsCOMPtr<nsPIDOMWindowOuter> topWindow = GetOwner()->GetOuterWindow()->GetTop()) {
         if (nsCOMPtr<nsPIDOMWindowInner> topInner = topWindow->GetCurrentInnerWindow()) {
           suspendedDoc = topWindow->GetExtantDoc();
           if (suspendedDoc) {
             suspendedDoc->SuppressEventHandling(nsIDocument::eEvents);
           }
-          topWindow->NewSuspend();
+          topWindow->Suspend();
           resumeTimeoutRunnable = new nsResumeTimeoutsEvent(topInner);
         }
       }
     }
 
     StopProgressEventTimer();
 
     SyncTimeoutType syncTimeoutType = MaybeStartSyncTimeoutTimer();
diff --git a/layout/printing/nsPrintEngine.cpp b/layout/printing/nsPrintEngine.cpp
--- a/layout/printing/nsPrintEngine.cpp
+++ b/layout/printing/nsPrintEngine.cpp
@@ -3388,31 +3388,31 @@ nsPrintEngine::TurnScriptingOn(bool aDoT
       doc->GetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
                        &propThere);
       if (aDoTurnOn) {
         if (propThere != NS_PROPTABLE_PROP_NOT_THERE) {
           doc->DeleteProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview);
           if (go && go->GetGlobalJSObject()) {
             xpc::Scriptability::Get(go->GetGlobalJSObject()).Unblock();
           }
-          window->NewResume();
+          window->Resume();
         }
       } else {
         // Have to be careful, because people call us over and over again with
         // aDoTurnOn == false.  So don't set the property if it's already
         // set, since in that case we'd set it to the wrong value.
         if (propThere == NS_PROPTABLE_PROP_NOT_THERE) {
           // Stash the current value of IsScriptEnabled on the document, so
           // that layout code running in print preview doesn't get confused.
           doc->SetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
                            NS_INT32_TO_PTR(doc->IsScriptEnabled()));
           if (go && go->GetGlobalJSObject()) {
             xpc::Scriptability::Get(go->GetGlobalJSObject()).Block();
           }
-          window->NewSuspend();
+          window->Suspend();
         }
       }
     }
   }
 }
 
 //-----------------------------------------------------------------
 //-- Done: Misc Support Methods
