# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e90952ca218a7c13a8f22f00380f2c2459f22b1d

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -343,18 +343,16 @@ TimeoutManager::SetTimeout(nsITimeoutHan
 {
   // If we don't have a document (we could have been unloaded since
   // the call to setTimeout was made), do nothing.
   nsCOMPtr<nsIDocument> doc = mWindow.GetExtantDoc();
   if (!doc) {
     return NS_OK;
   }
 
-  printf_stderr("### ### [%p] SetTimeout %d\n", mExecutor.get(), interval);
-
   // Disallow negative intervals.  If aIsInterval also disallow 0,
   // because we use that as a "don't repeat" flag.
   interval = std::max(aIsInterval ? 1 : 0, interval);
 
   // Make sure we don't proceed with an interval larger than our timer
   // code can handle. (Note: we already forced |interval| to be non-negative,
   // so the uint32_t cast (to avoid compiler warnings) is ok.)
   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
@@ -363,16 +361,19 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   RefPtr<Timeout> timeout = new Timeout();
   timeout->mIsInterval = aIsInterval;
   timeout->mInterval = interval;
   timeout->mScriptHandler = aHandler;
   timeout->mReason = aReason;
 
+  printf_stderr("### ### [%p] SetTimeout %p with interval %d\n",
+                mExecutor.get(), timeout->mScriptHandler.get(), timeout->mInterval);
+
   switch (gTimeoutBucketingStrategy) {
   default:
   case TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY: {
     const char* filename = nullptr;
     uint32_t dummyLine = 0, dummyColumn = 0;
     aHandler->GetLocation(&filename, &dummyLine, &dummyColumn);
     timeout->mIsTracking = doc->IsScriptTracking(nsDependentCString(filename));
 
@@ -762,16 +763,19 @@ TimeoutManager::RunTimeout(const TimeSta
       if (!scx) {
         // No context means this window was closed or never properly
         // initialized for this language.  This timer will never fire
         // so just remove it.
         timeout->remove();
         continue;
       }
 
+      printf_stderr("### ### [%p] RunTimeoutHandler %p that had interval %d\n",
+                    mExecutor.get(), timeout->mScriptHandler.get(), timeout->mInterval);
+
       // This timeout is good to run
       bool timeout_was_cleared = mWindow.RunTimeoutHandler(timeout, scx);
       MOZ_LOG(gLog, LogLevel::Debug,
               ("Run%s(TimeoutManager=%p, timeout=%p, tracking=%d) returned %d\n", timeout->mIsInterval ? "Interval" : "Timeout",
                this, timeout.get(),
                int(timeout->mIsTracking),
                !!timeout_was_cleared));
 
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -13147,16 +13147,17 @@ nsGlobalWindow::RunTimeoutHandler(Timeou
 
     if (!callback) {
       // Evaluate the timeout expression.
       const nsAString& script = handler->GetHandlerText();
 
       const char* filename = nullptr;
       uint32_t lineNo = 0, dummyColumn = 0;
       handler->GetLocation(&filename, &lineNo, &dummyColumn);
+      printf_stderr("### ### calling js at %s line %u\n", filename, lineNo);
 
       // New script entry point required, due to the "Create a script" sub-step of
       // http://www.whatwg.org/specs/web-apps/current-work/#timer-initialisation-steps
       nsAutoMicroTask mt;
       AutoEntryScript aes(this, reason, true);
       JS::CompileOptions options(aes.cx());
       options.setFileAndLine(filename, lineNo).setVersion(JSVERSION_DEFAULT);
       options.setNoScriptRval(true);
@@ -13166,29 +13167,49 @@ nsGlobalWindow::RunTimeoutHandler(Timeou
         nsJSUtils::ExecutionContext exec(aes.cx(), global);
         rv = exec.CompileAndExec(options, script);
       }
 
       if (rv == NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE) {
         abortIntervalHandler = true;
       }
     } else {
+      {
+        JSObject* funo(callback->CallbackOrNull());
+        JSFunction* fun = JS_GetObjectFunction(funo);
+        if (fun) {
+          JSString* name = JS_GetFunctionDisplayId(fun);
+          if (name) {
+            JSFlatString* flat = JS_ASSERT_STRING_IS_FLAT(name);
+            nsAutoString chars;
+            AssignJSFlatString(chars, flat);
+            NS_ConvertUTF16toUTF8 fname(chars);
+            printf_stderr("### ### calling js function %s\n", fname.get());
+          }
+        }
+      }
       // Hold strong ref to ourselves while we call the callback.
       nsCOMPtr<nsISupports> me(static_cast<nsIDOMWindow*>(this));
       ErrorResult rv;
       JS::Rooted<JS::Value> ignoredVal(RootingCx());
       callback->Call(me, handler->GetArgs(), &ignoredVal, rv, reason);
       if (rv.IsUncatchableException()) {
         abortIntervalHandler = true;
       }
 
       rv.SuppressException();
     }
   } else {
     nsCOMPtr<nsITimeoutHandler> basicHandler(timeout->mScriptHandler);
+
+    const char* filename = nullptr;
+    uint32_t lineNo = 0, dummyColumn = 0;
+    basicHandler->GetLocation(&filename, &lineNo, &dummyColumn);
+    printf_stderr("### ### calling js at %s line %u\n", filename, lineNo);
+
     nsCOMPtr<nsISupports> kungFuDeathGrip(static_cast<nsIDOMWindow*>(this));
     mozilla::Unused << kungFuDeathGrip;
     basicHandler->Call();
   }
 
   // If we received an uncatchable exception, do not schedule the timeout again.
   // This allows the slow script dialog to break easy DoS attacks like
   // setInterval(function() { while(1); }, 100);
