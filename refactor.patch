# HG changeset patch
# Parent ef83d4c403d06c3c0db74c831636b40557bd774a
# User Ben Kelly <ben@wanderview.com>
Refactor Cache/CacheStorage backend.

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.cpp
@@ -0,0 +1,405 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/quota/OriginOrPatternString.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsIFile.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::Nullable;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
+{
+public:
+  QuotaReleaseRunnable(const nsACString& aOrigin, const nsACString& aQuotaId)
+    : mOrigin(aOrigin)
+    , mQuotaId(aQuotaId)
+  {
+  }
+
+private:
+  const nsCString mOrigin;
+  const nsCString mQuotaId;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
+
+NS_IMETHODIMP
+QuotaReleaseRunnable::Run()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mOrigin),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                              mQuotaId);
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+NS_IMPL_ISUPPORTS0(Context::ActionResolver);
+
+class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
+                                           , public Context::ActionResolver
+{
+public:
+  QuotaInitRunnable(Context* aContext,
+                    const nsACString& aOrigin,
+                    const nsACString& aBaseDomain,
+                    const nsACString& aQuotaId,
+                    Context::Action* aQuotaIOThreadAction)
+    : mContext(aContext)
+    , mOrigin(aOrigin)
+    , mBaseDomain(aBaseDomain)
+    , mQuotaId(aQuotaId)
+    , mQuotaIOThreadAction(aQuotaIOThreadAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    MOZ_ASSERT(mState == STATE_INIT);
+    MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+
+    mState = STATE_CALL_WAIT_FOR_OPEN_ALLOWED;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      mState = STATE_COMPLETE;
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
+    }
+  }
+
+protected:
+  virtual ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+  }
+
+private:
+  enum State
+  {
+    STATE_INIT,
+    STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
+    STATE_WAIT_FOR_OPEN_ALLOWED,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void DispatchError(nsresult aRv)
+  {
+    mResult = aRv;
+    mState = STATE_COMPLETE;
+    DebugOnly<nsresult> rv;
+    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+  }
+
+  nsRefPtr<Context> mContext;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  const nsCString mQuotaId;
+  nsRefPtr<Context::Action> mQuotaIOThreadAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  nsCOMPtr<nsIFile> mQuotaDir;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(Context::QuotaInitRunnable, Context::ActionResolver,
+                            nsIRunnable);
+
+NS_IMETHODIMP
+Context::QuotaInitRunnable::Run()
+{
+  QuotaManager* qm;
+  nsresult rv;
+
+  switch(mState) {
+    case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::GetOrCreate();
+      if (!qm) {
+        DispatchError(NS_ERROR_FAILURE);
+        return NS_OK;
+      }
+      mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mOrigin),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                                  mQuotaId, this);
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_WAIT_FOR_OPEN_ALLOWED:
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+      // TODO: MOZ_ASSERT(NS_GetCurrentThread() == QuotaManager::Get()->IOThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+                                         mBaseDomain,
+                                         mOrigin,
+                                         true, // aTrackQuota
+                                         getter_AddRefs(mQuotaDir));
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      mState = STATE_RUNNING;
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->RunOnTarget(this, mQuotaDir);
+      } else {
+        Resolve(NS_OK);
+      }
+      break;
+    case STATE_COMPLETING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
+      }
+      mContext->OnQuotaInit(mResult, mQuotaDir);
+      mState = STATE_COMPLETE;
+      break;
+    default:
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+      break;
+  }
+
+  return NS_OK;
+}
+
+class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
+                                        , public ActionResolver
+{
+public:
+  ActionRunnable(nsIEventTarget* aTarget, Context::Action* aAction,
+                 nsIFile* aQuotaDir)
+    : mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaDir(aQuotaDir)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    MOZ_ASSERT(mQuotaDir);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    MOZ_ASSERT(mState == STATE_INIT);
+    MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      mState = STATE_COMPLETE;
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+    }
+  }
+
+private:
+  virtual ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  nsCOMPtr<nsIEventTarget> mTarget;
+  nsRefPtr<Context::Action> mAction;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(Context::ActionRunnable, Context::ActionResolver,
+                            nsIRunnable);
+
+NS_IMETHODIMP
+Context::ActionRunnable::Run()
+{
+  switch(mState) {
+    case STATE_RUN_ON_TARGET:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaDir);
+      break;
+    case STATE_COMPLETING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mInitiatingThread);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      break;
+    default:
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+  }
+  return NS_OK;
+}
+
+Context::Context(Listener* aListener, const nsACString& aOrigin,
+                 const nsACString& aBaseDomain, Action* aQuotaIOThreadAction)
+  : mListener(aListener)
+  , mOrigin(aOrigin)
+  , mState(STATE_CONTEXT_INIT)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mListener);
+
+  nsRefPtr<QuotaInitRunnable> runnable =
+    new QuotaInitRunnable(this, aOrigin, aBaseDomain,
+                          NS_LITERAL_CSTRING("Cache"), aQuotaIOThreadAction);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+Context::Execute(RequestId aRequestId, nsIEventTarget* aTarget, Action* aAction)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aTarget);
+  MOZ_ASSERT(aAction);
+
+  if (mState != STATE_CONTEXT_READY) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mRequestId = aRequestId;
+    pending->mTarget = aTarget;
+    pending->mAction = aAction;
+    return;
+  }
+
+  nsRefPtr<ActionRunnable> runnable = new ActionRunnable(aTarget, aAction,
+                                                         mQuotaDir);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+}
+
+
+Context::~Context()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mListener);
+  mListener->RemoveContext(this);
+
+  // Unlock the quota dir as we go out of scope.
+  nsCOMPtr<nsIRunnable> runnable =
+    new QuotaReleaseRunnable(mOrigin, NS_LITERAL_CSTRING("Cache"));
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  }
+}
+
+void
+Context::OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+  mQuotaDir = aQuotaDir;
+  MOZ_ASSERT(mQuotaDir);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    nsRefPtr<ActionRunnable> runnable =
+      new ActionRunnable(mPendingActions[i].mTarget,
+                         mPendingActions[i].mAction,
+                         mQuotaDir);
+    nsresult rv = runnable->Dispatch();
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+    }
+  }
+  mPendingActions.Clear();
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.h
@@ -0,0 +1,91 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Context_h
+#define mozilla_dom_cache_Context_h
+
+#include "mozilla/dom/CacheTypes.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIEventTarget;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Context MOZ_FINAL
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+    virtual void RemoveContext(Context* aContext)=0;
+  };
+
+  class ActionResolver : public nsISupports
+  {
+  public:
+    virtual ~ActionResolver() { }
+    virtual void Resolve(nsresult aRv)=0;
+    NS_DECL_THREADSAFE_ISUPPORTS
+  };
+
+  class Action
+  {
+  public:
+    virtual ~Action() { }
+    virtual void RunOnTarget(ActionResolver* aResolver, nsIFile* aQuotaDir)=0;
+    virtual void CompleteOnInitiatingThread(nsresult aRv)=0;
+    NS_INLINE_DECL_REFCOUNTING(Action)
+  };
+
+  Context(Listener* aListener, const nsACString& aOrigin,
+          const nsACString& aBaseDomain, Action* aQuotaIOThreadAction);
+
+  void Execute(RequestId aRequestId, nsIEventTarget* aTarget, Action* aAction);
+
+private:
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY
+  };
+
+  struct PendingAction
+  {
+    RequestId mRequestId;
+    nsCOMPtr<nsIEventTarget> mTarget;
+    nsRefPtr<Action> mAction;
+  };
+
+  ~Context();
+  nsresult DispatchAction(nsIEventTarget* aTarget, Action* aAction);
+  void OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir);
+
+  Listener* mListener;
+  const nsCString mOrigin;
+  State mState;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsTArray<PendingAction> mPendingActions;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.cpp
@@ -0,0 +1,96 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsAutoPtr.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager::Factory
+{
+private:
+  struct Entry
+  {
+    nsCString mOrigin;
+    Manager* mManager;
+  };
+
+  static Factory* sFactory;
+  nsTArray<Entry> mManagerList;
+
+public:
+  static Factory& Instance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      sFactory = new Factory();
+    }
+    return *sFactory;
+  }
+
+  already_AddRefed<Manager> GetOrCreate(const nsACString& aOrigin)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i].mOrigin == aOrigin) {
+        nsRefPtr<Manager> ref = mManagerList[i].mManager;
+        return ref.forget();
+      }
+    }
+
+    nsRefPtr<Manager> ref = new Manager();
+
+    Entry* entry = mManagerList.AppendElement();
+    entry->mOrigin = aOrigin;
+    entry->mManager = ref;
+
+    return ref.forget();
+  }
+
+  void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i].mManager == aManager) {
+        mManagerList.RemoveElementAt(i);
+        return;
+      }
+    }
+  }
+};
+
+// static
+Manager::Factory* Manager::Factory::sFactory = nullptr;
+
+// static
+already_AddRefed<Manager>
+Manager::ForOrigin(const nsACString& aOrigin)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().GetOrCreate(aOrigin);
+}
+
+Manager::Manager()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+}
+
+Manager::~Manager()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  Factory::Instance().Remove(this);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Manager_h
+#define mozilla_dom_cache_Manager_h
+
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager MOZ_FINAL
+{
+public:
+  static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin);
+
+private:
+  Manager();
+  ~Manager();
+
+  class Factory;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -19,28 +19,35 @@ EXPORTS.mozilla.dom += [
     'CacheStorageChildListener.h',
     'CacheStorageDBConnection.h',
     'CacheStorageDBListener.h',
     'CacheStorageDBSchema.h',
     'CacheStorageParent.h',
     'CacheTypes.h',
 ]
 
-UNIFIED_SOURCES += [
+EXPORTS.mozilla.dom.cache += [
+    'Context.h',
+    'Manager.h',
+]
+
+SOURCES += [
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheDBConnection.cpp',
     'CacheDBSchema.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageDBConnection.cpp',
     'CacheStorageDBSchema.cpp',
     'CacheStorageParent.cpp',
+    'Context.cpp',
+    'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
     'PCacheStorage.ipdl',
