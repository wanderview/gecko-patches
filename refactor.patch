# HG changeset patch
# Parent ef83d4c403d06c3c0db74c831636b40557bd774a
# User Ben Kelly <ben@wanderview.com>
Refactor Cache/CacheStorage backend.

diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.cpp
@@ -0,0 +1,18 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Action.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+NS_IMPL_ISUPPORTS0(Action);
+NS_IMPL_ISUPPORTS0(Action::Resolver);
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Action_h
+#define mozilla_dom_cache_Action_h
+
+#include "nsISupportsImpl.h"
+
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action : public nsISupports
+{
+protected:
+  virtual ~Action() { }
+
+public:
+  enum Resolution
+  {
+    Resolved,
+    Canceled
+  };
+
+  class Resolver : public nsISupports
+  {
+  protected:
+    virtual ~Resolver() { }
+
+  public:
+
+    // Note: Action must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on Action's target thread.
+    virtual void Resolve(nsresult aRv)=0;
+
+    NS_DECL_THREADSAFE_ISUPPORTS
+  };
+
+  // Execute operations on target thread. Once complete call
+  // Resolver::Resolve().  This can be done sync or async.
+  // Note: Action should hold Resolver ref until its ready to call Resolve().
+  virtual void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)=0;
+
+  // Called on target thread if the Action is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: Action must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv,
+                                          Resolution aResolution=Resolved)=0;
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.cpp
@@ -0,0 +1,505 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Context.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/quota/OriginOrPatternString.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "nsIFile.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::Nullable;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
+{
+public:
+  QuotaReleaseRunnable(const nsACString& aOrigin, const nsACString& aQuotaId)
+    : mOrigin(aOrigin)
+    , mQuotaId(aQuotaId)
+  {
+  }
+
+private:
+  const nsCString mOrigin;
+  const nsCString mQuotaId;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
+
+NS_IMETHODIMP
+QuotaReleaseRunnable::Run()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mOrigin),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                              mQuotaId);
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
+                                           , public Action::Resolver
+{
+public:
+  QuotaInitRunnable(Context* aContext,
+                    const nsACString& aOrigin,
+                    const nsACString& aBaseDomain,
+                    const nsACString& aQuotaId,
+                    Action* aQuotaIOThreadAction)
+    : mContext(aContext)
+    , mOrigin(aOrigin)
+    , mBaseDomain(aBaseDomain)
+    , mQuotaId(aQuotaId)
+    , mQuotaIOThreadAction(aQuotaIOThreadAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_CALL_WAIT_FOR_OPEN_ALLOWED;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      mState = STATE_COMPLETE;
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
+    }
+  }
+
+protected:
+  virtual ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+  }
+
+private:
+  enum State
+  {
+    STATE_INIT,
+    STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
+    STATE_WAIT_FOR_OPEN_ALLOWED,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void DispatchError(nsresult aRv)
+  {
+    mResult = aRv;
+    mState = STATE_COMPLETE;
+    DebugOnly<nsresult> rv;
+    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+  }
+
+  nsRefPtr<Context> mContext;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  const nsCString mQuotaId;
+  nsRefPtr<Action> mQuotaIOThreadAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  nsCOMPtr<nsIFile> mQuotaDir;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(Context::QuotaInitRunnable, Action::Resolver,
+                            nsIRunnable);
+
+NS_IMETHODIMP
+Context::QuotaInitRunnable::Run()
+{
+  QuotaManager* qm;
+  nsresult rv;
+
+  switch(mState) {
+    case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::GetOrCreate();
+      if (!qm) {
+        DispatchError(NS_ERROR_FAILURE);
+        return NS_OK;
+      }
+      mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mOrigin),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                                  mQuotaId, this);
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+      // TODO: MOZ_ASSERT(NS_GetCurrentThread() == QuotaManager::Get()->IOThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+                                         mBaseDomain,
+                                         mOrigin,
+                                         true, // aTrackQuota
+                                         getter_AddRefs(mQuotaDir));
+      if (NS_FAILED(rv)) {
+        DispatchError(rv);
+        return NS_OK;
+      }
+      mState = STATE_RUNNING;
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->RunOnTarget(this, mQuotaDir);
+      } else {
+        Resolve(NS_OK);
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
+      }
+      mContext->OnQuotaInit(mResult, mQuotaDir);
+      mState = STATE_COMPLETE;
+      break;
+    default:
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+      break;
+  }
+
+  return NS_OK;
+}
+
+class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
+                                        , public Action::Resolver
+{
+public:
+  ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
+                 nsIFile* aQuotaDir)
+    : mContext(aContext)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaDir(aQuotaDir)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+    , mResolution(Action::Resolved)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    MOZ_ASSERT(mQuotaDir);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      mState = STATE_COMPLETE;
+    }
+    return rv;
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    nsresult rv;
+    switch(mState) {
+      case STATE_INIT:
+        mState = STATE_COMPLETE;
+        break;
+      case STATE_RUN_ON_TARGET:
+        mState = STATE_CANCELING;
+        break;
+      case STATE_RUNNING:
+        mState = STATE_CANCELING;
+        rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+        if (NS_FAILED(rv)) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+        }
+      case STATE_CANCELING:
+      case STATE_COMPLETING:
+      case STATE_COMPLETE:
+        break;
+      default:
+        MOZ_CRASH("unexpected state");
+        break;
+    }
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+    }
+  }
+
+private:
+  virtual ~ActionRunnable()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    mContext->OnActionRunnableComplete(this);
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_CANCELING,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  nsRefPtr<Context> mContext;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  nsRefPtr<Action> mAction;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  Action::Resolution mResolution;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(Context::ActionRunnable, Action::Resolver,
+                            nsIRunnable);
+
+NS_IMETHODIMP
+Context::ActionRunnable::Run()
+{
+  nsresult rv;
+  switch(mState) {
+    case STATE_RUN_ON_TARGET:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaDir);
+      break;
+    case STATE_CANCELING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_COMPLETING;
+      mResolution = Action::Canceled;
+      mAction->CancelOnTarget();
+      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      mAction->CompleteOnInitiatingThread(mResult, mResolution);
+      mState = STATE_COMPLETE;
+      break;
+    default:
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+  }
+  return NS_OK;
+}
+
+Context::Context(Listener* aListener, const nsACString& aOrigin,
+                 const nsACString& aBaseDomain, Action* aQuotaIOThreadAction)
+  : mListener(aListener)
+  , mOrigin(aOrigin)
+  , mState(STATE_CONTEXT_INIT)
+{
+  MOZ_ASSERT(mListener);
+
+  nsRefPtr<QuotaInitRunnable> runnable =
+    new QuotaInitRunnable(this, aOrigin, aBaseDomain,
+                          NS_LITERAL_CSTRING("Cache"), aQuotaIOThreadAction);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+Context::ClearListener()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+void
+Context::Dispatch(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aTarget);
+  MOZ_ASSERT(aAction);
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mTarget = aTarget;
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aTarget, aAction);
+}
+
+void
+Context::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    mActionRunnables[i]->Cancel();
+  }
+}
+
+Context::~Context()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  // Unlock the quota dir as we go out of scope.
+  nsCOMPtr<nsIRunnable> runnable =
+    new QuotaReleaseRunnable(mOrigin, NS_LITERAL_CSTRING("Cache"));
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  }
+
+  if (mListener) {
+    mListener->RemoveContext(this);
+  }
+}
+
+void
+Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  nsCOMPtr<nsIFile> quotaDir;
+  nsresult rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
+  if (NS_FAILED(rv)) {
+    aAction->CompleteOnInitiatingThread(rv);
+    return;
+  }
+
+  nsRefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, aTarget, aAction, quotaDir);
+  mActionRunnables.AppendElement(runnable);
+  rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+}
+
+void
+Context::OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+
+  if (NS_FAILED(aRv)) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  mQuotaDir = aQuotaDir;
+  MOZ_ASSERT(mQuotaDir);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aActionRunnable);
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (aActionRunnable == mActionRunnables[i]) {
+      mActionRunnables.RemoveElementAt(i);
+      return;
+    }
+  }
+  MOZ_ASSERT(false);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Context_h
+#define mozilla_dom_cache_Context_h
+
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIEventTarget;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action;
+
+class Context MOZ_FINAL
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+    // Called from the Context destructor on the thread that originally
+    // created the Context.
+    virtual void RemoveContext(Context* aContext)=0;
+  };
+
+  Context(Listener* aListener, const nsACString& aOrigin,
+          const nsACString& aBaseDomain, Action* aQuotaIOThreadAction);
+
+  void ClearListener();
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(nsIEventTarget* aTarget, Action* aAction);
+
+  // Cancel any Actions running or waiting to run.  This should allow the
+  // Context to be released and Listener::RemoveContext() will be called
+  // when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+private:
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    nsRefPtr<Action> mAction;
+  };
+
+  ~Context();
+  void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
+  void OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir);
+  void OnActionRunnableComplete(ActionRunnable* const aAction);
+
+  Listener* mListener;
+  const nsCString mOrigin;
+  State mState;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsTArray<PendingAction> mPendingActions;
+
+  // weak refs since ~ActionRunnable() removes itself from this list
+  nsTArray<ActionRunnable*> mActionRunnables;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.cpp
@@ -0,0 +1,136 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBAction.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode, const nsACString& aOrigin,
+                   const nsACString& aBaseDomain)
+  : mMode(aMode)
+  , mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaDir);
+
+  nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+  if (NS_FAILED(rv)) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
+  if (NS_FAILED(rv)) {
+    aResolver->Resolve(rv);
+    return;
+  }
+  MOZ_ASSERT(conn);
+  rv = RunSyncOnTarget(aQuotaDir, conn);
+  aResolver->Resolve(rv);
+}
+
+nsresult
+DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_FAILED(rv)) { return rv; }
+
+  if (!exists) {
+    if (mMode != Create) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_FAILED(rv)) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_FAILED(rv)) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
+  if (NS_FAILED(rv)) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_FAILED(rv)) { return rv; }
+
+  nsCOMPtr<nsIFile> dbTmpDir;
+  rv = aDBDir->Clone(getter_AddRefs(dbTmpDir));
+  if (NS_FAILED(rv)) { return rv; }
+
+  rv = dbTmpDir->Append(NS_LITERAL_STRING("db"));
+  if (NS_FAILED(rv)) { return rv; }
+
+  // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
+  //      but this is what IDB does to access mozIStorageConnection so
+  //      it seems at least this corner case mostly works.
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
+  if (NS_FAILED(rv)) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
+
+  rv = dbFileUrl->SetQuery(NS_LITERAL_CSTRING("persistenceType=") + type +
+                           NS_LITERAL_CSTRING("&group=") + mBaseDomain +
+                           NS_LITERAL_CSTRING("&origin=") + mOrigin);
+  if (NS_FAILED(rv)) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    dbFile->Remove(false);
+    if (NS_FAILED(rv)) { return rv; }
+
+    rv = dbTmpDir->Exists(&exists);
+    if (NS_FAILED(rv)) { return rv; }
+
+    if (exists) {
+      bool isDir;
+      rv = dbTmpDir->IsDirectory(&isDir);
+      if (NS_FAILED(rv)) { return rv; }
+      if (!isDir) { return NS_ERROR_UNEXPECTED; }
+      rv = dbTmpDir->Remove(true);
+      if (NS_FAILED(rv)) { return rv; }
+    }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  }
+  if (NS_FAILED(rv)) { return rv; }
+  MOZ_ASSERT(*aConnOut);
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBAction_h
+#define mozilla_dom_cache_DBAction_h
+
+#include "mozilla/dom/cache/Action.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBAction : public Action
+{
+public:
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  DBAction(Mode aMode, const nsACString& aOrigin,
+           const nsACString& aBaseDomain);
+
+  virtual ~DBAction() { }
+
+  virtual nsresult RunSyncOnTarget(nsIFile* aDBDir,
+                                   mozIStorageConnection* aConnection)=0;
+
+  virtual
+  void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
+
+  // Called on target thread if the DBAction is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: DBAction must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+private:
+  nsresult OpenConnection(nsIFile* aQuotaDir, mozIStorageConnection** aConnOut);
+
+  const Mode mMode;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.cpp
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBSchema.h"
+
+#include "mozilla/dom/CacheDBConnection.h"
+#include "mozilla/dom/PCacheQueryParams.h"
+#include "mozilla/dom/PCacheRequest.h"
+#include "mozilla/dom/PCacheResponse.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// static
+nsresult
+DBSchema::Create(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aConn);
+
+  nsAutoCString pragmas(
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
+    // Switch the journaling mode to TRUNCATE to avoid changing the directory
+    // structure at the conclusion of every transaction for devices with slower
+    // file systems.
+    "PRAGMA journal_mode = TRUNCATE; "
+#endif
+    "PRAGMA foreign_keys = ON; "
+  );
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_FAILED(rv)) { return rv; }
+
+  int32_t schemaVersion;
+  rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_FAILED(rv)) { return rv; }
+
+  if (schemaVersion == kLatestSchemaVersion) {
+    return NS_OK;
+  }
+
+  mozStorageTransaction trans(aConn, false,
+                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+  if (!schemaVersion) {
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE map ("
+        "id INTEGER NOT NULL PRIMARY KEY, "
+        "request_method TEXT NOT NULL, "
+        "request_url TEXT NOT NULL, "
+        "request_url_no_query TEXT NOT NULL, "
+        "request_mode INTEGER NOT NULL, "
+        "request_credentials INTEGER NOT NULL, "
+        //"request_body_file TEXT NOT NULL, "
+        "response_type INTEGER NOT NULL, "
+        "response_status INTEGER NOT NULL, "
+        "response_status_text TEXT NOT NULL "
+        //"response_body_file TEXT NOT NULL "
+      ");"
+    ));
+    if (NS_FAILED(rv)) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE request_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "map_id INTEGER NOT NULL REFERENCES map(id) "
+      ");"
+    ));
+    if (NS_FAILED(rv)) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE response_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "map_id INTEGER NOT NULL REFERENCES map(id) "
+      ");"
+    ));
+    if (NS_FAILED(rv)) { return rv; }
+
+    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
+    if (NS_FAILED(rv)) { return rv; }
+
+    rv = aConn->GetSchemaVersion(&schemaVersion);
+    if (NS_FAILED(rv)) { return rv; }
+  }
+
+  if (schemaVersion != kLatestSchemaVersion) {
+    return NS_ERROR_FAILURE;
+  }
+
+  rv = trans.Commit();
+  if (NS_FAILED(rv)) { return rv; }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.h
@@ -0,0 +1,35 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBSchema_h
+#define mozilla_dom_cache_DBSchema_h
+
+#include "mozilla/Attributes.h"
+#include "nsError.h"
+
+class mozIStorageConnection;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBSchema MOZ_FINAL
+{
+public:
+  static nsresult Create(mozIStorageConnection* aConn);
+
+private:
+  DBSchema() MOZ_DELETE;
+  ~DBSchema() MOZ_DELETE;
+
+  static const int32_t kLatestSchemaVersion = 1;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBSchema_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.cpp
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Manager.h"
+
+#include "mozilla/dom/cache/DBAction.h"
+#include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsAutoPtr.h"
+
+namespace {
+
+using mozilla::dom::cache::DBAction;
+using mozilla::dom::cache::DBSchema;
+
+class SetupAction MOZ_FINAL : public DBAction
+{
+public:
+  SetupAction(const nsACString& aOrigin, const nsACString& aBaseDomain)
+    : DBAction(DBAction::Create, aOrigin, aBaseDomain)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir,
+                  mozIStorageConnection* aConnection) MOZ_OVERRIDE
+  {
+    return DBSchema::Create(aConnection);
+  }
+
+  virtual void CompleteOnInitiatingThread(nsresult aRv,
+                                          Resolution aResolution) MOZ_OVERRIDE
+  {
+    // Nothing to do here. Errors in setup are handled by Context.
+  }
+
+protected:
+  virtual ~SetupAction() { }
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager::Factory
+{
+private:
+  static Factory* sFactory;
+  nsTArray<Manager*> mManagerList;
+
+public:
+  static Factory& Instance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      sFactory = new Factory();
+    }
+    return *sFactory;
+  }
+
+  already_AddRefed<Manager> GetOrCreate(const nsACString& aOrigin,
+                                        const nsACString& aBaseDomain)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i]->Origin() == aOrigin) {
+        nsRefPtr<Manager> ref = mManagerList[i];
+        return ref.forget();
+      }
+    }
+
+    nsRefPtr<Manager> ref = new Manager(aOrigin, aBaseDomain);
+
+    mManagerList.AppendElement(ref);
+
+    return ref.forget();
+  }
+
+  void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i] == aManager) {
+        mManagerList.RemoveElementAt(i);
+
+        if (mManagerList.Length() < 1) {
+          delete sFactory;
+          sFactory = nullptr;
+        }
+        return;
+      }
+    }
+  }
+};
+
+// static
+Manager::Factory* Manager::Factory::sFactory = nullptr;
+
+// static
+already_AddRefed<Manager>
+Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
+}
+
+void
+Manager::RemoveContext(Context* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+  mContext = nullptr;
+}
+
+Manager::Manager(const nsACString& aOrigin, const nsACString& aBaseDomain)
+  : mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+  , mContext(nullptr)
+{
+}
+
+Manager::~Manager()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  Factory::Instance().Remove(this);
+  if (mContext) {
+    mContext->ClearListener();
+  }
+}
+
+Context*
+Manager::GetContext()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  if (!mContext) {
+    nsRefPtr<Action> setupAction = new SetupAction(mOrigin, mBaseDomain);
+    mContext = new Context(this, mOrigin, mBaseDomain, setupAction);
+  }
+  return mContext;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Manager_h
+#define mozilla_dom_cache_Manager_h
+
+#include "mozilla/dom/cache/Context.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager MOZ_FINAL : public Context::Listener
+{
+public:
+  static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
+                                             const nsACString& aBaseDomain);
+
+  const nsCString& Origin() const { return mOrigin; }
+
+  // Context::Listener methods
+  virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
+
+private:
+  class Factory;
+
+  Manager(const nsACString& aOrigin, const nsACString& aBaseDomain);
+  ~Manager();
+  Context* GetContext();
+
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+
+  // weak ref as Context destructor clears this pointer
+  Context* mContext;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -19,28 +19,41 @@ EXPORTS.mozilla.dom += [
     'CacheStorageChildListener.h',
     'CacheStorageDBConnection.h',
     'CacheStorageDBListener.h',
     'CacheStorageDBSchema.h',
     'CacheStorageParent.h',
     'CacheTypes.h',
 ]
 
-UNIFIED_SOURCES += [
+EXPORTS.mozilla.dom.cache += [
+    'Action.h',
+    'Context.h',
+    'DBAction.h',
+    'DBSchema.h',
+    'Manager.h',
+]
+
+SOURCES += [
+    'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheDBConnection.cpp',
     'CacheDBSchema.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageDBConnection.cpp',
     'CacheStorageDBSchema.cpp',
     'CacheStorageParent.cpp',
+    'Context.cpp',
+    'DBAction.cpp',
+    'DBSchema.cpp',
+    'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
     'PCacheStorage.ipdl',
