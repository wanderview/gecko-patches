# HG changeset patch
# Parent ef83d4c403d06c3c0db74c831636b40557bd774a
# User Ben Kelly <ben@wanderview.com>
Refactor Cache/CacheStorage backend.

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -208,17 +208,17 @@
 #include "nsHTMLDocument.h"
 #include "nsWrapperCacheInlines.h"
 #include "mozilla/DOMEventTargetHelper.h"
 #include "prrng.h"
 #include "nsSandboxFlags.h"
 #include "TimeChangeObserver.h"
 #include "mozilla/dom/AudioContext.h"
 #include "mozilla/dom/BrowserElementDictionariesBinding.h"
-#include "mozilla/dom/CacheStorage.h"
+#include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/dom/Console.h"
 #include "mozilla/dom/Fetch.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/HashChangeEvent.h"
 #include "mozilla/dom/MozSelfSupportBinding.h"
 #include "mozilla/dom/PopStateEvent.h"
 #include "mozilla/dom/PopupBlockedEvent.h"
 #include "mozilla/dom/WindowBinding.h"
@@ -262,16 +262,17 @@ static PRLogModuleInfo* gDOMLeakPRLog;
 
 static const char kStorageEnabled[] = "dom.storage.enabled";
 
 using namespace mozilla;
 using namespace mozilla::dom;
 using namespace mozilla::dom::ipc;
 using mozilla::TimeStamp;
 using mozilla::TimeDuration;
+using mozilla::dom::cache::CacheStorage;
 
 nsGlobalWindow::WindowByIdTable *nsGlobalWindow::sWindowsById = nullptr;
 bool nsGlobalWindow::sWarnedAboutWindowInternal = false;
 bool nsGlobalWindow::sIdleObserversAPIFuzzTimeDisabled = false;
 
 static nsIEntropyCollector *gEntropyCollector          = nullptr;
 static int32_t              gRefCnt                    = 0;
 static int32_t              gOpenPopupSpamCount        = 0;
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -96,29 +96,31 @@ struct nsIntSize;
 struct nsRect;
 
 class nsWindowSizes;
 
 namespace mozilla {
 class DOMEventTargetHelper;
 namespace dom {
 class BarProp;
-class CacheStorage;
 class Console;
 class External;
 class Function;
 class Gamepad;
 class MediaQueryList;
 class MozSelfSupport;
 class Navigator;
 class OwningExternalOrWindowProxy;
 class Promise;
 class Selection;
 class SpeechSynthesis;
 class WakeLock;
+namespace cache {
+class CacheStorage;
+} // namespace cache
 namespace indexedDB {
 class IDBFactory;
 } // namespace indexedDB
 } // namespace dom
 } // namespace mozilla
 
 extern nsresult
 NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
@@ -845,17 +847,17 @@ public:
 
 protected:
   bool AlertOrConfirm(bool aAlert, const nsAString& aMessage,
                       mozilla::ErrorResult& aError);
 
 public:
   void Alert(mozilla::ErrorResult& aError);
   void Alert(const nsAString& aMessage, mozilla::ErrorResult& aError);
-  already_AddRefed<mozilla::dom::CacheStorage> Caches();
+  already_AddRefed<mozilla::dom::cache::CacheStorage> Caches();
   bool Confirm(const nsAString& aMessage, mozilla::ErrorResult& aError);
   already_AddRefed<mozilla::dom::Promise> Fetch(const mozilla::dom::RequestOrScalarValueString& aInput,
                                                 const mozilla::dom::RequestInit& aInit,
                                                 mozilla::ErrorResult& aRv);
   void Prompt(const nsAString& aMessage, const nsAString& aInitial,
               nsAString& aReturn, mozilla::ErrorResult& aError);
   void Print(mozilla::ErrorResult& aError);
   void ShowModalDialog(JSContext* aCx, const nsAString& aUrl,
@@ -1524,17 +1526,17 @@ protected:
   nsRefPtr<mozilla::dom::BarProp> mPersonalbar;
   nsRefPtr<mozilla::dom::BarProp> mStatusbar;
   nsRefPtr<mozilla::dom::BarProp> mScrollbars;
   nsRefPtr<nsDOMWindowUtils>    mWindowUtils;
   nsString                      mStatus;
   nsString                      mDefaultStatus;
   nsGlobalWindowObserver*       mObserver; // Inner windows only.
   nsCOMPtr<nsIDOMCrypto>        mCrypto;
-  nsRefPtr<mozilla::dom::CacheStorage> mCacheStorage;
+  nsRefPtr<mozilla::dom::cache::CacheStorage> mCacheStorage;
   nsRefPtr<mozilla::dom::Console> mConsole;
   // We need to store an nsISupports pointer to this object because the
   // mozilla::dom::External class doesn't exist on b2g and using the type
   // forward declared here means that ~nsGlobalWindow wouldn't compile because
   // it wouldn't see the ~External function's declaration.
   nsCOMPtr<nsISupports>         mExternal;
 
   nsRefPtr<mozilla::dom::MozSelfSupport> mMozSelfSupport;
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -181,16 +181,34 @@ DOMInterfaces = {
     'nativeType': 'mozilla::dom::bluetooth::BluetoothPairingHandle',
 },
 
 'BluetoothPairingListener': {
     'nativeType':
       'mozilla::dom::bluetooth::BluetoothPairingListener',
 },
 
+'Cache': [{
+    'headerFile': 'mozilla/dom/cache/Cache.h',
+    'nativeType': 'mozilla::dom::cache::Cache',
+}, {
+    'workers': True,
+    'headerFile': 'mozilla/dom/cache/Cache.h',
+    'nativeType': 'mozilla::dom::cache::Cache',
+}],
+
+'CacheStorage': [{
+    'headerFile': 'mozilla/dom/cache/CacheStorage.h',
+    'nativeType': 'mozilla::dom::cache::CacheStorage',
+}, {
+    'workers': True,
+    'headerFile': 'mozilla/dom/cache/CacheStorage.h',
+    'nativeType': 'mozilla::dom::cache::CacheStorage',
+}],
+
 'CameraCapabilities': {
     'nativeType': 'mozilla::dom::CameraCapabilities',
     'headerFile': 'DOMCameraCapabilities.h'
 },
 
 'CameraControl': {
     'nativeType': 'mozilla::nsDOMCameraControl',
     'headerFile': 'DOMCameraControl.h',
diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.cpp
@@ -0,0 +1,18 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Action.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action);
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action::Resolver);
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Action_h
+#define mozilla_dom_cache_Action_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsISupportsImpl.h"
+
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action : public nsISupports
+{
+protected:
+  virtual ~Action() { }
+
+public:
+  class Resolver : public nsISupports
+  {
+  protected:
+    virtual ~Resolver() { }
+
+  public:
+
+    // Note: Action must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on Action's target thread.
+    virtual void Resolve(nsresult aRv)=0;
+
+    NS_DECL_THREADSAFE_ISUPPORTS
+  };
+
+  // Execute operations on target thread. Once complete call
+  // Resolver::Resolve().  This can be done sync or async.
+  // Note: Action should hold Resolver ref until its ready to call Resolve().
+  virtual void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)=0;
+
+  // Called on target thread if the Action is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: Action must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread.  If this Action will operate on the
+  // given cache ID then override this to return true.
+  virtual bool MatchesCacheId(CacheId aCacheId) { return false; }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -1,36 +1,35 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/Cache.h"
+#include "mozilla/dom/cache/Cache.h"
 
-#include "mozilla/dom/CacheBinding.h"
-#include "mozilla/dom/CacheChild.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/CacheBinding.h"
+#include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/unused.h"
 #include "nsIGlobalObject.h"
 #include "nsNetUtil.h"
 #include "nsURLParsers.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 using mozilla::ErrorResult;
 using mozilla::unused;
 using mozilla::void_t;
-using mozilla::dom::cache::INVALID_REQUEST_ID;
-using mozilla::dom::cache::RequestId;
 
 // Utility function to remove the query from a URL.  We're not using nsIURL
 // or URL to do this because they require going to the main thread.
 static nsresult
 GetURLWithoutQuery(const nsAString& aUrl, nsAString& aUrlWithoutQueryOut)
 {
   NS_ConvertUTF16toUTF8 flatURL(aUrl);
   const char* url = flatURL.get();
@@ -163,18 +162,18 @@ ToResponse(Response& aOut, const PCacheR
 
 static void
 ToRequest(Request& aOut, const PCacheRequest& aIn)
 {
   // TODO: implement once real Request/Response are available
   NS_WARNING("Not filling in contents of Request returned from Cache.");
 }
 
-NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::Cache);
-NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::Cache);
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::Cache);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::Cache);
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Cache, mOwner, mGlobal)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Cache)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 Cache::Cache(nsISupports* aOwner, nsIGlobalObject* aGlobal,
@@ -649,10 +648,11 @@ Cache::RemoveRequestPromise(RequestId aR
       ref.swap(promise);
       mRequestPromises.RemoveElementAt(i);
       return ref.forget();
     }
   }
   return nullptr;
 }
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -1,41 +1,44 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_Cache_h
-#define mozilla_dom_Cache_h
+#ifndef mozilla_dom_cache_Cache_h
+#define mozilla_dom_cache_Cache_h
 
-#include "mozilla/dom/CacheChildListener.h"
+#include "mozilla/dom/cache/CacheChildListener.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
-class CacheChild;
 class OwningRequestOrScalarValueString;
 class Promise;
-class PCacheChild;
+struct QueryParams;
 class RequestOrScalarValueString;
-struct QueryParams;
 class Response;
 template<typename T> class Optional;
 template<typename T> class Sequence;
 
+namespace cache {
+
+class CacheChild;
+class PCacheChild;
+
 class Cache MOZ_FINAL : public nsISupports
                       , public nsWrapperCache
                       , public CacheChildListener
 {
 public:
   Cache(nsISupports* aOwner, nsIGlobalObject* aGlobal, const nsACString& aOrigin,
         const nsACString& aBaseDomain, PCacheChild* aActor);
 
@@ -65,52 +68,53 @@ public:
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
   virtual nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // CacheChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void
-  RecvMatchResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                     const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual void
-  RecvMatchAllResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                        const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
   virtual void
-  RecvAddResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvAddResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponse& aResponse) MOZ_OVERRIDE;
   virtual void
-  RecvAddAllResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
                      const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
   virtual void
-  RecvPutResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvPutResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual void
-  RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess) MOZ_OVERRIDE;
   virtual void
-  RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                    const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
 
 private:
   virtual ~Cache();
 
-  cache::RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
-  already_AddRefed<Promise> RemoveRequestPromise(cache::RequestId aRequestId);
+  RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
+  already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
 private:
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Cache)
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_Cache_h
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -1,20 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheChild.h"
+#include "mozilla/dom/cache/CacheChild.h"
 
-#include "mozilla/dom/CacheChildListener.h"
+#include "mozilla/dom/cache/CacheChildListener.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 CacheChild::CacheChild()
   : mListener(nullptr)
 {
 }
 
 CacheChild::~CacheChild()
 {
@@ -103,10 +104,11 @@ bool
 CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                              const nsTArray<PCacheRequest>& requests)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvKeysResponse(requestId, aRv, requests);
   return true;
 }
 
+} // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -2,20 +2,21 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheChild_h
 #define mozilla_dom_cache_CacheChild_h
 
-#include "mozilla/dom/PCacheChild.h"
+#include "mozilla/dom/cache/PCacheChild.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class CacheChildListener;
 
 class CacheChild MOZ_FINAL : public PCacheChild
 {
   CacheChildListener* mListener;
 
 public:
@@ -46,12 +47,13 @@ public:
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                    const nsTArray<PCacheRequest>& requests) MOZ_OVERRIDE;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheChild_h
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -1,57 +1,59 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_CacheChildListener_h
-#define mozilla_dom_CacheChildListener_h
+#ifndef mozilla_dom_cache_CacheChildListener_h
+#define mozilla_dom_cache_CacheChildListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 
 namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
+namespace cache {
 
 class PCacheRequest;
 class PCacheResponse;
 class PCacheResponseOrVoid;
 
 class CacheChildListener
 {
 public:
   virtual ~CacheChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
 
   virtual void
-  RecvMatchResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                     const PCacheResponseOrVoid& aResponse)=0;
   virtual void
-  RecvMatchAllResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                        const nsTArray<PCacheResponse>& aResponses)=0;
   virtual void
-  RecvAddResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvAddResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponse& aResponse)=0;
   virtual void
-  RecvAddAllResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvAddAllResponse(RequestId aRequestId, nsresult aRv,
                      const nsTArray<PCacheResponse>& aResponses)=0;
   virtual void
-  RecvPutResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvPutResponse(RequestId aRequestId, nsresult aRv,
                   const PCacheResponseOrVoid& aResponse)=0;
   virtual void
-  RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess)=0;
   virtual void
-  RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
+  RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                    const nsTArray<PCacheRequest>& aRequests)=0;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_CacheChildListener_h
diff --git a/dom/cache/CacheDBConnection.cpp b/dom/cache/CacheDBConnection.cpp
--- a/dom/cache/CacheDBConnection.cpp
+++ b/dom/cache/CacheDBConnection.cpp
@@ -1,39 +1,38 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheDBConnection.h"
+#include "mozilla/dom/cache/CacheDBConnection.h"
 
-#include "mozilla/dom/CacheDBListener.h"
-#include "mozilla/dom/CacheDBSchema.h"
-#include "mozilla/dom/CacheQuotaRunnable.h"
-#include "mozilla/dom/CacheTypes.h"
 #include "mozilla/dom/Headers.h"
-#include "mozilla/dom/PCacheQueryParams.h"
-#include "mozilla/dom/PCacheRequest.h"
-#include "mozilla/dom/PCacheResponse.h"
+#include "mozilla/dom/cache/CacheDBListener.h"
+#include "mozilla/dom/cache/CacheDBSchema.h"
+#include "mozilla/dom/cache/CacheQuotaRunnable.h"
+#include "mozilla/dom/cache/PCacheQueryParams.h"
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsServiceManagerUtils.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
 #include "mozIStorageStatement.h"
 #include "mozStorageCID.h"
 #include "mozStorageHelper.h"
 #include "nsIFile.h"
 #include "nsIUUIDGenerator.h"
 #include "nsNetUtil.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
-using mozilla::dom::cache::RequestId;
 using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
 using mozilla::dom::quota::PersistenceType;
 using mozilla::dom::quota::QuotaManager;
 
 class CacheDBConnection::OpenRunnable : public CacheQuotaRunnable
 {
 public:
   OpenRunnable(const nsACString& aOrigin, const nsACString& aBaseDomain,
@@ -55,17 +54,17 @@ protected:
 
   virtual ~OpenRunnable() { }
   virtual void RunOnQuotaIOThread(const nsACString& aOrigin,
                                   const nsACString& aBaseDomain,
                                   nsIFile* aQuotaDir) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aQuotaDir);
 
-    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cache-old"));
     if (NS_FAILED(mResult)) { return; }
 
     char cacheIdBuf[NSID_LENGTH];
     mCacheId.ToProvidedString(cacheIdBuf);
     mResult = aQuotaDir->Append(NS_ConvertUTF8toUTF16(cacheIdBuf));
     if (NS_FAILED(mResult)) { return; }
 
     bool exists;
@@ -403,17 +402,17 @@ CacheDBConnection::Put(RequestId aReques
     OnPutComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY,
                   PCacheResponseOrVoid(void_t()));
     return;
   }
   put->Dispatch();
 }
 
 void
-CacheDBConnection::Delete(cache::RequestId aRequestId,
+CacheDBConnection::Delete(RequestId aRequestId,
                           const PCacheRequest& aRequest,
                           const PCacheQueryParams& aParams)
 {
   nsRefPtr<DeleteRunnable> del = new DeleteRunnable(mOrigin, mBaseDomain,
                                                     mQuotaId, mCacheId,
                                                     aRequestId, aRequest,
                                                     aParams, this);
   if (!del) {
@@ -459,11 +458,11 @@ void
 CacheDBConnection::OnDeleteComplete(RequestId aRequestId, nsresult aRv,
                                     bool aSuccess)
 {
   if (mListener) {
     mListener->OnDelete(aRequestId, aRv, aSuccess);
   }
 }
 
-
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheDBConnection.h b/dom/cache/CacheDBConnection.h
--- a/dom/cache/CacheDBConnection.h
+++ b/dom/cache/CacheDBConnection.h
@@ -2,27 +2,28 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBConnection_h
 #define mozilla_dom_cache_CacheDBConnection_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 struct nsID;
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class CacheDBListener;
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheResponseOrVoid;
 
@@ -35,60 +36,61 @@ public:
   Create(CacheDBListener* aListener, const nsACString& aOrigin,
          const nsACString& aBaseDomain);
 
   CacheDBConnection(CacheDBListener* aListener, const nsACString& aOrigin,
                     const nsACString& aBaseDomain, const nsID& aCacheId);
 
   void ClearListener();
 
-  void Match(cache::RequestId aRequestId,
+  void Match(RequestId aRequestId,
              const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams);
 
-  void MatchAll(cache::RequestId aRequestId,
+  void MatchAll(RequestId aRequestId,
                 const PCacheRequestOrVoid& aRequest,
                 const PCacheQueryParams& aParams);
 
-  void Put(cache::RequestId aRequestId, const PCacheRequest& aRequest,
+  void Put(RequestId aRequestId, const PCacheRequest& aRequest,
            const PCacheResponse& aResponse);
 
-  void Delete(cache::RequestId aRequestId, const PCacheRequest& aRequest,
+  void Delete(RequestId aRequestId, const PCacheRequest& aRequest,
               const PCacheQueryParams& aParams);
 
 private:
   class OpenRunnable;
   class MatchRunnable;
   class MatchAllRunnable;
   class PutRunnable;
   class DeleteRunnable;
 
   ~CacheDBConnection();
 
   static already_AddRefed<CacheDBConnection>
   GetOrCreateInternal(CacheDBListener& aListener, const nsACString& aOrigin,
                       const nsACString& aBaseDomain, const nsID& aCacheId,
                       bool allowCreate);
 
-  void OnMatchComplete(cache::RequestId aRequestId, nsresult aRv,
+  void OnMatchComplete(RequestId aRequestId, nsresult aRv,
                        const PCacheResponseOrVoid& aResponse);
-  void OnMatchAllComplete(cache::RequestId aRequestId, nsresult aRv,
+  void OnMatchAllComplete(RequestId aRequestId, nsresult aRv,
                           const nsTArray<PCacheResponse>& aResponses);
-  void OnPutComplete(cache::RequestId aRequestId, nsresult aRv,
+  void OnPutComplete(RequestId aRequestId, nsresult aRv,
                      const PCacheResponseOrVoid& aResponse);
-  void OnDeleteComplete(cache::RequestId aRequestId, nsresult aRv,
+  void OnDeleteComplete(RequestId aRequestId, nsresult aRv,
                         bool aSuccess);
 
   static const int32_t kLatestSchemaVersion = 1;
   CacheDBListener* mListener;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   const nsID mCacheId;
   nsCString mQuotaId;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(CacheDBConnection)
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheDBConnection_h
diff --git a/dom/cache/CacheDBListener.h b/dom/cache/CacheDBListener.h
--- a/dom/cache/CacheDBListener.h
+++ b/dom/cache/CacheDBListener.h
@@ -2,38 +2,40 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBListener_h
 #define mozilla_dom_cache_CacheDBListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class PCacheResponse;
 class PCacheResponseOrVoid;
 
 class CacheDBListener
 {
   public:
     virtual ~CacheDBListener() { }
 
-    virtual void OnMatch(cache::RequestId aRequestId, nsresult aRv,
+    virtual void OnMatch(RequestId aRequestId, nsresult aRv,
                          const PCacheResponseOrVoid& aResponse)=0;
-    virtual void OnMatchAll(cache::RequestId aRequestId, nsresult aRv,
+    virtual void OnMatchAll(RequestId aRequestId, nsresult aRv,
                             const nsTArray<PCacheResponse>& aResponses)=0;
-    virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
+    virtual void OnPut(RequestId aRequestId, nsresult aRv,
                        const PCacheResponseOrVoid& aResponse)=0;
-    virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
+    virtual void OnDelete(RequestId aRequestId, nsresult aRv,
                           bool aSuccess)=0;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheDBListener_h
diff --git a/dom/cache/CacheDBSchema.cpp b/dom/cache/CacheDBSchema.cpp
--- a/dom/cache/CacheDBSchema.cpp
+++ b/dom/cache/CacheDBSchema.cpp
@@ -1,26 +1,27 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheDBSchema.h"
+#include "mozilla/dom/cache/CacheDBSchema.h"
 
-#include "mozilla/dom/CacheDBConnection.h"
-#include "mozilla/dom/PCacheQueryParams.h"
-#include "mozilla/dom/PCacheRequest.h"
-#include "mozilla/dom/PCacheResponse.h"
+#include "mozilla/dom/cache/CacheDBConnection.h"
+#include "mozilla/dom/cache/PCacheQueryParams.h"
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "mozStorageHelper.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 static const int32_t MAX_ENTRIES_PER_STATEMENT = 255;
 
 static void
 AppendListParamsToQuery(nsACString& aQuery,
                         const nsTArray<CacheDBConnection::EntryId>& aEntryIdList,
                         uint32_t aPos, int32_t aLen)
 {
@@ -706,11 +707,11 @@ CacheDBSchema::ReadResponse(mozIStorageC
 
     rv = statement->GetUTF8String(1, header->value());
     if (NS_FAILED(rv)) { return rv; }
   }
 
   return NS_OK;
 }
 
-
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheDBSchema.h b/dom/cache/CacheDBSchema.h
--- a/dom/cache/CacheDBSchema.h
+++ b/dom/cache/CacheDBSchema.h
@@ -3,24 +3,25 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBSchema_h
 #define mozilla_dom_cache_CacheDBSchema_h
 
 #include "mozilla/Attributes.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 
 class mozIStorageConnection;
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class PCacheQueryParams;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheResponseOrVoid;
 
 class CacheDBSchema MOZ_FINAL
@@ -69,12 +70,13 @@ private:
                                EntryId aEntryId, PCacheResponse& aResponseOut);
 
   CacheDBSchema() MOZ_DELETE;
   ~CacheDBSchema() MOZ_DELETE;
 
   static const int32_t kLatestSchemaVersion = 1;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheDBSchema_h
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -1,76 +1,74 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheParent.h"
+#include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/unused.h"
-#include "mozilla/dom/CacheDBConnection.h"
+#include "mozilla/dom/cache/CacheDBConnection.h"
 #include "nsCOMPtr.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
-using mozilla::dom::cache::RequestId;
-
-CacheParent::CacheParent(const nsACString& aOrigin,
-                         const nsACString& aBaseDomain)
-  : mOrigin(aOrigin)
-  , mBaseDomain(aBaseDomain)
-{
-  mDBConnection = CacheDBConnection::Create(this, aOrigin, aBaseDomain);
-  MOZ_ASSERT(mDBConnection);
-}
 
 CacheParent::CacheParent(const nsACString& aOrigin,
                          const nsACString& aBaseDomain,
-                         const nsID& aExistingCacheId)
-  : mOrigin(aOrigin)
-  , mBaseDomain(aBaseDomain)
+                         CacheId aCacheId)
+  : mCacheId(aCacheId)
+  , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
-  mDBConnection = new CacheDBConnection(this, aOrigin, aBaseDomain,
-                                        aExistingCacheId);
-  MOZ_ASSERT(mDBConnection);
+  MOZ_ASSERT(mManager);
+  mManager->AddRefCacheId(mCacheId);
+
+  // TODO: remove this stuff
+  nsID bogusId;
+  mDBConnection = new CacheDBConnection(this, aOrigin, aBaseDomain, bogusId);
 }
 
 CacheParent::~CacheParent()
 {
   MOZ_ASSERT(!mDBConnection);
 }
 
 void
 CacheParent::ActorDestroy(ActorDestroyReason aReason)
 {
+  MOZ_ASSERT(mManager);
+  mManager->RemoveListener(this);
+  mManager->ReleaseCacheId(mCacheId);
+  mManager = nullptr;
   MOZ_ASSERT(mDBConnection);
   mDBConnection->ClearListener();
   mDBConnection = nullptr;
 }
 
 bool
 CacheParent::RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
                        const PCacheQueryParams& aParams)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Match(aRequestId, aRequest, aParams);
+  MOZ_ASSERT(mManager);
+  mManager->CacheMatch(this, mCacheId, aRequestId, aRequest, aParams);
   return true;
 }
 
 bool
 CacheParent::RecvMatchAll(const RequestId& aRequestId,
                           const PCacheRequestOrVoid& aRequest,
                           const PCacheQueryParams& aParams)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->MatchAll(aRequestId, aRequest, aParams);
+  MOZ_ASSERT(mManager);
+  mManager->CacheMatchAll(this, mCacheId, aRequestId, aRequest, aParams);
   return true;
 }
 
 bool
 CacheParent::RecvAdd(const RequestId& aRequestId, const PCacheRequest& aRequest)
 {
   return false;
 }
@@ -105,24 +103,24 @@ bool
 CacheParent::RecvKeys(const RequestId& aRequestId,
                       const PCacheRequestOrVoid& aRequest,
                       const PCacheQueryParams& aParams)
 {
   return false;
 }
 
 void
-CacheParent::OnMatch(cache::RequestId aRequestId, nsresult aRv,
+CacheParent::OnMatch(RequestId aRequestId, nsresult aRv,
                      const PCacheResponseOrVoid& aResponse)
 {
   unused << SendMatchResponse(aRequestId, aRv, aResponse);
 }
 
 void
-CacheParent::OnMatchAll(cache::RequestId aRequestId, nsresult aRv,
+CacheParent::OnMatchAll(RequestId aRequestId, nsresult aRv,
                         const nsTArray<PCacheResponse>& aResponses)
 {
   unused << SendMatchAllResponse(aRequestId, aRv, aResponses);
 }
 
 void
 CacheParent::OnPut(RequestId aRequestId, nsresult aRv,
                    const PCacheResponseOrVoid& aResponse)
@@ -132,10 +130,25 @@ CacheParent::OnPut(RequestId aRequestId,
 
 void
 CacheParent::OnDelete(RequestId aRequestId, nsresult aRv,
                       bool aSuccess)
 {
   unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
 }
 
+void
+CacheParent::OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                          const PCacheResponseOrVoid& aResponse)
+{
+  unused << SendMatchResponse(aRequestId, aRv, aResponse);
+}
+
+void
+CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<PCacheResponse>& aResponses)
+{
+  unused << SendMatchAllResponse(aRequestId, aRv, aResponses);
+}
+
+} // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -2,35 +2,37 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheParent_h
 #define mozilla_dom_cache_CacheParent_h
 
-#include "mozilla/dom/CacheDBListener.h"
-#include "mozilla/dom/CacheTypes.h"
-#include "mozilla/dom/PCacheParent.h"
+#include "mozilla/dom/cache/CacheDBListener.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/PCacheParent.h"
+#include "mozilla/dom/cache/Types.h"
 
 struct nsID;
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class CacheDBConnection;
 
 class CacheParent MOZ_FINAL : public PCacheParent
                             , public CacheDBListener
+                            , public Manager::Listener
 {
 public:
-  CacheParent(const nsACString& aOrigin, const nsACString& aBaseDomain);
   CacheParent(const nsACString& aOrigin, const nsACString& aBaseDomain,
-              const nsID& aExistingCacheId);
+              CacheId aCacheId);
   virtual ~CacheParent();
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   // PCacheParent method
   virtual bool
   RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
             const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
@@ -48,27 +50,34 @@ public:
   virtual bool
   RecvDelete(const RequestId& aRequestId, const PCacheRequest& aRequest,
              const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvKeys(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
            const PCacheQueryParams& aParams) MOZ_OVERRIDE;
 
   // CacheDBListener methods
-  virtual void OnMatch(cache::RequestId aRequestId, nsresult aRv,
+  virtual void OnMatch(RequestId aRequestId, nsresult aRv,
                        const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
-  virtual void OnMatchAll(cache::RequestId aRequestId, nsresult aRv,
-                          const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
-  virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
+  virtual void OnMatchAll(RequestId aRequestId, nsresult aRv,
+                      const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+  virtual void OnPut(RequestId aRequestId, nsresult aRv,
                      const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
-  virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
+  virtual void OnDelete(RequestId aRequestId, nsresult aRv,
                         bool aSuccess) MOZ_OVERRIDE;
 
+  // Manager::Listener methods
+  virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                            const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
+  virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
+
 private:
-  const nsCString mOrigin;
-  const nsCString mBaseDomain;
+  const CacheId mCacheId;
+  nsRefPtr<mozilla::dom::cache::Manager> mManager;
   nsRefPtr<CacheDBConnection> mDBConnection;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheParent_h
diff --git a/dom/cache/CacheQuotaRunnable.cpp b/dom/cache/CacheQuotaRunnable.cpp
--- a/dom/cache/CacheQuotaRunnable.cpp
+++ b/dom/cache/CacheQuotaRunnable.cpp
@@ -1,24 +1,25 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheQuotaRunnable.h"
+#include "mozilla/dom/cache/CacheQuotaRunnable.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsIFile.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 using mozilla::dom::quota::OriginOrPatternString;
 using mozilla::dom::quota::QuotaManager;
 using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
 using mozilla::dom::quota::PersistenceType;
 
 NS_IMPL_ISUPPORTS(CacheQuotaRunnable, nsIRunnable);
 
@@ -138,10 +139,11 @@ CacheQuotaRunnable::DispatchError(nsresu
 {
   mResult = aRv;
   mState = STATE_COMPLETE;
   DebugOnly<nsresult> rv;
   rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheQuotaRunnable.h b/dom/cache/CacheQuotaRunnable.h
--- a/dom/cache/CacheQuotaRunnable.h
+++ b/dom/cache/CacheQuotaRunnable.h
@@ -1,26 +1,27 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_CacheQuotaRunnable_h
-#define mozilla_dom_CacheQuotaRunnable_h
+#ifndef mozilla_dom_cache_CacheQuotaRunnable_h
+#define mozilla_dom_cache_CacheQuotaRunnable_h
 
 #include "nsCOMPtr.h"
 #include "nsIRunnable.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 
 class nsIThread;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class CacheQuotaRunnable : public nsIRunnable
 {
 public:
   CacheQuotaRunnable(const nsACString& aOrigin,
                      const nsACString& aBaseDomain,
                      const nsACString& aQuotaId);
 
@@ -54,12 +55,13 @@ private:
   State mState;
   nsresult mResult;
 
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIRUNNABLE
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_CacheQuotaRunnable_h
+#endif // mozilla_dom_cache_CacheQuotaRunnable_h
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -1,50 +1,49 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheStorage.h"
+#include "mozilla/dom/cache/CacheStorage.h"
 
 #include "mozilla/unused.h"
-#include "mozilla/dom/Cache.h"
+#include "mozilla/dom/Promise.h"
 #include "mozilla/dom/CacheStorageBinding.h"
-#include "mozilla/dom/CacheStorageChild.h"
-#include "mozilla/dom/PCacheChild.h"
-#include "mozilla/dom/Promise.h"
+#include "mozilla/dom/cache/Cache.h"
+#include "mozilla/dom/cache/PCacheChild.h"
+#include "mozilla/dom/cache/CacheStorageChild.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "nsIGlobalObject.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 using mozilla::unused;
 using mozilla::ErrorResult;
-using mozilla::dom::cache::INVALID_REQUEST_ID;
-using mozilla::dom::cache::RequestId;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::IProtocol;
 
-NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::CacheStorage);
-NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::CacheStorage);
+NS_IMPL_CYCLE_COLLECTING_ADDREF(mozilla::dom::cache::CacheStorage);
+NS_IMPL_CYCLE_COLLECTING_RELEASE(mozilla::dom::cache::CacheStorage);
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(CacheStorage, mOwner,
                                                     mGlobal,
                                                     mRequestPromises)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(CacheStorage)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
   NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
 NS_INTERFACE_MAP_END
 
-CacheStorage::CacheStorage(cache::Namespace aNamespace,
+CacheStorage::CacheStorage(Namespace aNamespace,
                            nsISupports* aOwner,
                            nsIGlobalObject* aGlobal,
                            const nsACString& aOrigin,
                            const nsACString& aBaseDomain)
   : mNamespace(aNamespace)
   , mOwner(aOwner)
   , mGlobal(aGlobal)
   , mOrigin(aOrigin)
@@ -385,10 +384,11 @@ CacheStorage::RemoveRequestPromise(Reque
       ref.swap(promise);
       mRequestPromises.RemoveElementAt(i);
       return ref.forget();
     }
   }
   return nullptr;
 }
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -1,19 +1,19 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_CacheStorage_h
-#define mozilla_dom_CacheStorage_h
+#ifndef mozilla_dom_cache_CacheStorage_h
+#define mozilla_dom_cache_CacheStorage_h
 
-#include "mozilla/dom/CacheStorageChildListener.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/CacheStorageChildListener.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 
 class nsIGlobalObject;
@@ -23,29 +23,32 @@ namespace mozilla {
 class ErrorResult;
 
 namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
 
-class CacheStorageChild;
 class Promise;
 struct QueryParams;
 class RequestOrScalarValueString;
 
+namespace cache {
+
+class CacheStorageChild;
+
 class CacheStorage MOZ_FINAL : public nsIIPCBackgroundChildCreateCallback
                              , public nsWrapperCache
                              , public CacheStorageChildListener
 {
   typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
 
 public:
-  CacheStorage(cache::Namespace aNamespace, nsISupports* aOwner,
+  CacheStorage(Namespace aNamespace, nsISupports* aOwner,
                nsIGlobalObject* aGlobal, const nsACString& aOrigin,
                const nsACString& aBaseDomain);
 
   // webidl interface methods
   already_AddRefed<Promise> Match(const RequestOrScalarValueString& aRequest,
                                   const QueryParams& aParams, ErrorResult& aRv);
   already_AddRefed<Promise> Get(const nsAString& aKey, ErrorResult& aRv);
   already_AddRefed<Promise> Has(const nsAString& aKey, ErrorResult& aRv);
@@ -60,42 +63,43 @@ public:
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // nsIIPCbackgroundChildCreateCallback methods
   virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
   virtual void ActorFailed() MOZ_OVERRIDE;
 
   // CacheStorageChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
-  virtual void RecvGetResponse(cache::RequestId aRequestId, nsresult aRv,
+  virtual void RecvGetResponse(RequestId aRequestId, nsresult aRv,
                                PCacheChild* aActor) MOZ_OVERRIDE;
-  virtual void RecvHasResponse(cache::RequestId aRequestId, nsresult aRv,
+  virtual void RecvHasResponse(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) MOZ_OVERRIDE;
-  virtual void RecvCreateResponse(cache::RequestId aRequestId, nsresult aRv,
+  virtual void RecvCreateResponse(RequestId aRequestId, nsresult aRv,
                                   PCacheChild* aActor) MOZ_OVERRIDE;
-  virtual void RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
+  virtual void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                   bool aSuccess) MOZ_OVERRIDE;
-  virtual void RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
+  virtual void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
   virtual ~CacheStorage();
 
-  cache::RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
-  already_AddRefed<Promise> RemoveRequestPromise(cache::RequestId aRequestId);
+  RequestId AddRequestPromise(Promise* aPromise, ErrorResult& aRv);
+  already_AddRefed<Promise> RemoveRequestPromise(RequestId aRequestId);
 
-  const cache::Namespace mNamespace;
+  const Namespace mNamespace;
   nsCOMPtr<nsISupports> mOwner;
   nsCOMPtr<nsIGlobalObject> mGlobal;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
   CacheStorageChild* mActor;
   nsTArray<nsRefPtr<Promise>> mRequestPromises;
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CacheStorage)
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_CacheStorage_h
+#endif // mozilla_dom_cache_CacheStorage_h
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -1,22 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheStorageChild.h"
+#include "mozilla/dom/cache/CacheStorageChild.h"
 
-#include "mozilla/dom/CacheStorageChildListener.h"
+#include "mozilla/dom/cache/CacheStorageChildListener.h"
 
 namespace mozilla {
 namespace dom {
-
-using mozilla::dom::cache::RequestId;
+namespace cache {
 
 CacheStorageChild::CacheStorageChild(CacheStorageChildListener& aListener)
   : mListener(&aListener)
 {
 }
 
 CacheStorageChild::~CacheStorageChild()
 {
@@ -85,10 +84,11 @@ CacheStorageChild::RecvKeysResponse(cons
 
 void
 CacheStorageChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -2,21 +2,22 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorageChild_h
 #define mozilla_dom_cache_CacheStorageChild_h
 
-#include "mozilla/dom/CacheTypes.h"
-#include "mozilla/dom/PCacheStorageChild.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/cache/PCacheStorageChild.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 class CacheStorageChildListener;
 class PCacheChild;
 
 class CacheStorageChild MOZ_FINAL : public PCacheStorageChild
 {
 public:
   CacheStorageChild(CacheStorageChildListener& aListener);
@@ -38,12 +39,13 @@ public:
                                 const nsresult& aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
   void ClearListener();
 private:
   CacheStorageChildListener* mListener;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorageChild_h
diff --git a/dom/cache/CacheStorageChildListener.h b/dom/cache/CacheStorageChildListener.h
--- a/dom/cache/CacheStorageChildListener.h
+++ b/dom/cache/CacheStorageChildListener.h
@@ -1,30 +1,31 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_CacheStorageChildListener_h
-#define mozilla_dom_CacheStorageChildListener_h
+#ifndef mozilla_dom_cache_CacheStorageChildListener_h
+#define mozilla_dom_cache_CacheStorageChildListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 #include "nsString.h"
 
 template<class T> class nsTArray;
 
 namespace mozilla {
 
 namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
+namespace cache {
 
 class PCacheChild;
 
 class CacheStorageChildListener
 {
 public:
   virtual ~CacheStorageChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
@@ -35,12 +36,13 @@ public:
   virtual void RecvCreateResponse(cache::RequestId aRequestId, nsresult aRv,
                                   PCacheChild* aActor)=0;
   virtual void RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
                                   bool aSuccess)=0;
   virtual void RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
                                 const nsTArray<nsString>& aKeys)=0;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_CacheStorageChildListener_h
+#endif // mozilla_dom_cache_CacheStorageChildListener_h
diff --git a/dom/cache/CacheStorageDBConnection.cpp b/dom/cache/CacheStorageDBConnection.cpp
deleted file mode 100644
--- a/dom/cache/CacheStorageDBConnection.cpp
+++ /dev/null
@@ -1,464 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/CacheStorageDBConnection.h"
-
-#include "mozilla/dom/CacheQuotaRunnable.h"
-#include "mozilla/dom/CacheStorageDBListener.h"
-#include "mozilla/dom/CacheStorageDBSchema.h"
-#include "mozilla/dom/quota/QuotaManager.h"
-#include "mozilla/UniquePtr.h"
-#include "mozIStorageConnection.h"
-#include "mozIStorageService.h"
-#include "mozIStorageStatement.h"
-#include "mozStorageCID.h"
-#include "mozStorageHelper.h"
-#include "nsIFile.h"
-#include "nsNetUtil.h"
-
-namespace mozilla {
-namespace dom {
-
-using mozilla::UniquePtr;
-using mozilla::dom::cache::Namespace;
-using mozilla::dom::cache::RequestId;
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
-using mozilla::dom::quota::PersistenceType;
-using mozilla::dom::quota::QuotaManager;
-
-class CacheStorageDBConnection::OpenRunnable : public CacheQuotaRunnable
-{
-public:
-  OpenRunnable(Namespace aNamespace, const nsACString& aOrigin,
-               const nsACString& aBaseDomain, bool aAllowCreate,
-               RequestId aRequestId, const nsAString& aKey,
-               CacheStorageDBConnection* aCacheStorageDBConnection)
-    : CacheQuotaRunnable(aOrigin, aBaseDomain, NS_LITERAL_CSTRING("CacheStorage"))
-    , mNamespace(aNamespace)
-    , mAllowCreate(aAllowCreate)
-    , mRequestId(aRequestId)
-    , mKey(aKey)
-    , mCacheStorageDBConnection(aCacheStorageDBConnection)
-    , mResult(NS_OK)
-  {
-    MOZ_ASSERT(mCacheStorageDBConnection);
-  }
-
-protected:
-  virtual void AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection)=0;
-
-  virtual void RunOnQuotaIOThread(const nsACString& aOrigin,
-                                  const nsACString& aBaseDomain,
-                                  nsIFile* aQuotaDir) MOZ_OVERRIDE
-  {
-    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cachestorage"));
-    if (NS_FAILED(mResult)) { return; }
-
-    bool exists;
-    mResult = aQuotaDir->Exists(&exists);
-    if (NS_FAILED(mResult) || (!exists && !mAllowCreate)) { return; }
-
-    if (!exists) {
-      mResult = aQuotaDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
-      if (NS_FAILED(mResult)) { return; }
-    }
-
-    nsCOMPtr<nsIFile> dbFile;
-    mResult = aQuotaDir->Clone(getter_AddRefs(dbFile));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbFile->Exists(&exists);
-    if (NS_FAILED(mResult) || (!exists && !mAllowCreate)) { return; }
-
-    // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
-    //      but this is what IDB does to access mozIStorageConnection so
-    //      it seems at least this corner case mostly works.
-
-    nsCOMPtr<nsIFile> dbTmpDir;
-    mResult = aQuotaDir->Clone(getter_AddRefs(dbTmpDir));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbTmpDir->Append(NS_LITERAL_STRING("db"));
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<nsIURI> uri;
-    mResult = NS_NewFileURI(getter_AddRefs(uri), dbFile);
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
-    if (!dbFileUrl) {
-      mResult = NS_ERROR_FAILURE;
-      return;
-    }
-
-    nsAutoCString type;
-    PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
-
-    mResult = dbFileUrl->SetQuery(NS_LITERAL_CSTRING("persistenceType=") + type +
-                                  NS_LITERAL_CSTRING("&group=") + aBaseDomain +
-                                  NS_LITERAL_CSTRING("&origin=") + aOrigin);
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<mozIStorageService> ss =
-      do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
-    if (!ss) {
-      mResult = NS_ERROR_FAILURE;
-      return;
-    }
-
-    nsCOMPtr<mozIStorageConnection> conn;
-    mResult = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
-    if (mResult == NS_ERROR_FILE_CORRUPTED) {
-      mResult = dbFile->Remove(false);
-      if (NS_FAILED(mResult)) { return; }
-
-      mResult = dbTmpDir->Exists(&exists);
-      if (NS_FAILED(mResult)) { return; }
-
-      if (exists) {
-        bool isDir;
-        mResult = dbTmpDir->IsDirectory(&isDir);
-        if (NS_FAILED(mResult)) { return; }
-        if (!isDir) {
-          mResult = NS_ERROR_FAILURE;
-          return;
-        }
-        mResult = dbTmpDir->Remove(true);
-        if (NS_FAILED(mResult)) { return; }
-      }
-
-      mResult = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
-    }
-    if (NS_FAILED(mResult)) { return; }
-    MOZ_ASSERT(conn);
-
-    mResult = CacheStorageDBSchema::Create(conn);
-    if (NS_FAILED(mResult)) { return; }
-
-    AfterOpenOnQuotaIOThread(conn);
-  }
-
-protected:
-  virtual ~OpenRunnable() { }
-
-  const Namespace mNamespace;
-  const bool mAllowCreate;
-  const RequestId mRequestId;
-  const nsString mKey;
-  nsRefPtr<CacheStorageDBConnection> mCacheStorageDBConnection;
-  nsCOMPtr<mozIStorageConnection> mConnection;
-  nsresult mResult;
-};
-
-class CacheStorageDBConnection::GetRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  GetRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Get(aConnection, mNamespace, mKey,
-                                        &mSuccess, &mCacheId);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    if (NS_FAILED(rv) || !mSuccess) {
-      mCacheStorageDBConnection->OnGetComplete(mRequestId, rv, nullptr);
-      return;
-    }
-    mCacheStorageDBConnection->OnGetComplete(mRequestId, rv, &mCacheId);
-  }
-
-private:
-  virtual ~GetRunnable() { }
-  nsID mCacheId;
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::HasRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  HasRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Has(aConnection, mNamespace, mKey,
-                                        &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnHasComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~HasRunnable() { }
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::PutRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  PutRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey, const nsID& aCacheId,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, true, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mCacheId(aCacheId)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Put(aConnection, mNamespace, mKey, mCacheId,
-                                        &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnPutComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~PutRunnable() { }
-  const nsID mCacheId;
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::DeleteRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  DeleteRunnable(Namespace aNamespace, const nsACString& aOrigin,
-                 const nsACString& aBaseDomain, RequestId aRequestId,
-                 const nsAString& aKey,
-                 CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Delete(aConnection, mNamespace, mKey,
-                                           &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnDeleteComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~DeleteRunnable() { }
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::KeysRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  KeysRunnable(Namespace aNamespace, const nsACString& aOrigin,
-               const nsACString& aBaseDomain, RequestId aRequestId,
-               CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId,
-                   NS_LITERAL_STRING(""), aCacheStorageDBConnection)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Keys(aConnection, mNamespace, mKeys);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    if (NS_FAILED(rv)) {
-      mKeys.Clear();
-    }
-    mCacheStorageDBConnection->OnKeysComplete(mRequestId, rv, mKeys);
-  }
-
-private:
-  virtual ~KeysRunnable() { }
-  nsTArray<nsString> mKeys;
-};
-
-CacheStorageDBConnection::
-CacheStorageDBConnection(CacheStorageDBListener* aListener,
-                         Namespace aNamespace,
-                         const nsACString& aOrigin,
-                         const nsACString& aBaseDomain)
-  : mListener(aListener)
-  , mNamespace(aNamespace)
-  , mOrigin(aOrigin)
-  , mBaseDomain(aBaseDomain)
-{
-  MOZ_ASSERT(mListener);
-}
-
-void
-CacheStorageDBConnection::ClearListener()
-{
-  MOZ_ASSERT(mListener);
-  mListener = nullptr;
-}
-
-void
-CacheStorageDBConnection::Get(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<GetRunnable> get = new GetRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, this);
-  if (!get) {
-    OnGetComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, nullptr);
-    return;
-  }
-  get->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Has(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<HasRunnable> has = new HasRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, this);
-  if (!has) {
-    OnHasComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  has->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Put(RequestId aRequestId, const nsAString& aKey,
-                              const nsID& aCacheId)
-{
-  nsRefPtr<PutRunnable> put = new PutRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, aCacheId, this);
-  if (!put) {
-    OnPutComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  put->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Delete(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<DeleteRunnable> del = new DeleteRunnable(mNamespace, mOrigin,
-                                                    mBaseDomain, aRequestId,
-                                                    aKey, this);
-  if (!del) {
-    OnDeleteComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  del->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Keys(RequestId aRequestId)
-{
-  nsRefPtr<KeysRunnable> keys = new KeysRunnable(mNamespace, mOrigin,
-                                                 mBaseDomain, aRequestId, this);
-  if (!keys) {
-    OnKeysComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, nsTArray<nsString>());
-    return;
-  }
-  keys->Dispatch();
-}
-
-CacheStorageDBConnection::~CacheStorageDBConnection()
-{
-  MOZ_ASSERT(!mListener);
-}
-
-void
-CacheStorageDBConnection::OnGetComplete(RequestId aRequestId, nsresult aRv,
-                                        nsID* aCacheId)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnGet(aRequestId, aRv, aCacheId);
-  }
-}
-
-void
-CacheStorageDBConnection::OnHasComplete(cache::RequestId aRequestId,
-                                        nsresult aRv, bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnHas(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnPutComplete(RequestId aRequestId, nsresult aRv,
-                                        bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnPut(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnDeleteComplete(RequestId aRequestId, nsresult aRv,
-                                           bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnDelete(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnKeysComplete(RequestId aRequestId, nsresult aRv,
-                                         const nsTArray<nsString>& aKeys)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnKeys(aRequestId, aRv, aKeys);
-  }
-}
-
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/CacheStorageDBConnection.h b/dom/cache/CacheStorageDBConnection.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBConnection.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBConnection_h
-#define mozilla_dom_cache_CacheStorageDBConnection_h
-
-#include "mozilla/dom/CacheTypes.h"
-#include "nsCOMPtr.h"
-#include "nsISupportsImpl.h"
-#include "nsString.h"
-
-class mozIStorageConnection;
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBListener;
-
-class CacheStorageDBConnection MOZ_FINAL
-{
-public:
-  CacheStorageDBConnection(CacheStorageDBListener* aListener,
-                           cache::Namespace aNamespace,
-                           const nsACString& aOrigin,
-                           const nsACString& aBaseDomain);
-
-  void ClearListener();
-
-  void Get(cache::RequestId aRequestId, const nsAString& aKey);
-  void Has(cache::RequestId aRequestId, const nsAString& aKey);
-  void Put(cache::RequestId aRequestId, const nsAString& aKey,
-           const nsID& aCacheId);
-  void Delete(cache::RequestId aRequestId, const nsAString& aKey);
-  void Keys(cache::RequestId aRequestId);
-
-private:
-  class OpenRunnable;
-  class GetRunnable;
-  class HasRunnable;
-  class PutRunnable;
-  class DeleteRunnable;
-  class KeysRunnable;
-
-  ~CacheStorageDBConnection();
-  void OnGetComplete(cache::RequestId aRequestId, nsresult aRv, nsID* aCacheId);
-  void OnHasComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnPutComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnDeleteComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnKeysComplete(cache::RequestId aRequestId, nsresult aRv,
-                      const nsTArray<nsString>& aKeys);
-
-  CacheStorageDBListener* mListener;
-  const cache::Namespace mNamespace;
-  const nsCString mOrigin;
-  const nsCString mBaseDomain;
-
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(CacheStorageDBConnection)
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBConnection_h
diff --git a/dom/cache/CacheStorageDBListener.h b/dom/cache/CacheStorageDBListener.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBListener.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBListener_h
-#define mozilla_dom_cache_CacheStorageDBListener_h
-
-#include "mozilla/dom/CacheTypes.h"
-#include "nsError.h"
-#include "nsString.h"
-
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBListener
-{
-  public:
-    virtual ~CacheStorageDBListener() { }
-    virtual void OnGet(cache::RequestId aRequestId, nsresult aRv,
-                       nsID* aCacheId)=0;
-    virtual void OnHas(cache::RequestId aRequestId, nsresult aRv,
-                       bool aSuccess)=0;
-    virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
-                       bool aSuccess)=0;
-    virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
-                          bool aSuccess)=0;
-    virtual void OnKeys(cache::RequestId aRequestId, nsresult aRv,
-                        const nsTArray<nsString>& aKeys)=0;
-
-    // TODO: OnConnected
-    // TODO: OnError (or pass nsresult in each On*() method?
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBListener_h
diff --git a/dom/cache/CacheStorageDBSchema.cpp b/dom/cache/CacheStorageDBSchema.cpp
deleted file mode 100644
--- a/dom/cache/CacheStorageDBSchema.cpp
+++ /dev/null
@@ -1,246 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/CacheStorageDBSchema.h"
-#include "mozStorageHelper.h"
-#include "nsTArray.h"
-
-namespace mozilla {
-namespace dom {
-
-using mozilla::dom::cache::Namespace;
-
-// static
-nsresult
-CacheStorageDBSchema::Create(mozIStorageConnection* aConn)
-{
-  MOZ_ASSERT(aConn);
-  nsresult rv;
-
-#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
-  rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    // Switch the journaling mode to TRUNCATE to avoid changing the directory
-    // structure at the conclusion of every transaction for devices with slower
-    // file systems.
-    "PRAGMA journal_mode = TRUNCATE; "
-  ));
-  if (NS_FAILED(rv)) { return rv; }
-#endif
-
-  int32_t schemaVersion;
-  rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_FAILED(rv)) { return rv; }
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  if (!schemaVersion) {
-    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "CREATE TABLE caches ("
-        "namespace INTEGER NOT NULL, "
-        "key TEXT NOT NULL, "
-        "cache_uuid TEXT NOT NULL, "
-        "PRIMARY KEY(namespace, key)"
-      ");"
-    ));
-    if (NS_FAILED(rv)) { return rv; }
-
-    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
-    if (NS_FAILED(rv)) { return rv; }
-
-    rv = aConn->GetSchemaVersion(&schemaVersion);
-    if (NS_FAILED(rv)) { return rv; }
-  }
-
-  if (schemaVersion != kLatestSchemaVersion) {
-    rv = NS_ERROR_FAILURE;
-    return rv;
-  }
-
-  rv = trans.Commit();
-  if (NS_FAILED(rv)) { return rv; }
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Get(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, bool* aSuccessOut,
-                          nsID* aCacheIdOut)
-{
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aSuccessOut);
-  MOZ_ASSERT(aCacheIdOut);
-
-  *aSuccessOut = false;
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT cache_uuid FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  rv = statement->ExecuteStep(&hasMoreData);
-  if (NS_FAILED(rv)) { return rv; }
-
-  if (!hasMoreData) {
-    return NS_OK;
-  }
-
-  nsAutoCString uuidString;
-  rv = statement->GetUTF8String(0, uuidString);
-  if (NS_FAILED(rv)) { return rv; }
-
-  if (!aCacheIdOut->Parse(uuidString.get())) {
-    return NS_ERROR_FAILURE;
-  }
-
-  *aSuccessOut = true;
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Has(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT count(*) FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  rv = statement->ExecuteStep(&hasMoreData);
-  if (NS_FAILED(rv)) { return rv; }
-
-  int32_t count;
-  rv = statement->GetInt32(0, &count);
-  if (NS_FAILED(rv)) { return rv; }
-
-  *aSuccessOut = count > 0;
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Put(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, const nsID& aCacheId,
-                          bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "INSERT INTO caches (namespace, key, cache_uuid)VALUES(?1, ?2, ?3)"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  char uuidBuf[NSID_LENGTH];
-  aCacheId.ToProvidedString(uuidBuf);
-
-  rv = statement->BindUTF8StringParameter(2, nsAutoCString(uuidBuf));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->Execute();
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = trans.Commit();
-  *aSuccessOut = NS_SUCCEEDED(rv);
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Delete(mozIStorageConnection* aConn, Namespace aNamespace,
-                             const nsAString& aKey, bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "DELETE FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->Execute();
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = trans.Commit();
-  *aSuccessOut = NS_SUCCEEDED(rv);
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Keys(mozIStorageConnection* aConn, Namespace aNamespace,
-                           nsTArray<nsString>& aKeysOut)
-{
-  MOZ_ASSERT(aConn);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT key FROM caches WHERE namespace=?1 ORDER BY rowid"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  while(NS_SUCCEEDED(statement->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    nsString* key = aKeysOut.AppendElement();
-    if (!key) {
-      rv = NS_ERROR_OUT_OF_MEMORY;
-      return rv;
-    }
-    rv = statement->GetString(0, *key);
-    if (NS_FAILED(rv)) { return rv; }
-  }
-
-  return rv;
-}
-
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/CacheStorageDBSchema.h b/dom/cache/CacheStorageDBSchema.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBSchema.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBSchema_h
-#define mozilla_dom_cache_CacheStorageDBSchema_h
-
-#include "mozilla/Attributes.h"
-#include "mozilla/dom/CacheTypes.h"
-#include "nsError.h"
-#include "nsString.h"
-
-class mozIStorageConnection;
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBSchema MOZ_FINAL
-{
-public:
-  static nsresult Create(mozIStorageConnection* aConn);
-
-  static nsresult
-  Get(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, bool* aSuccessOut, nsID* aCacheIdOut);
-
-  static nsresult
-  Has(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, bool* aSuccessOut);
-
-  static nsresult
-  Put(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, const nsID& aCacheId, bool* aSuccessOut);
-
-  static nsresult
-  Delete(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-         const nsAString& aKey, bool* aSuccessOut);
-
-  static nsresult
-  Keys(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-       nsTArray<nsString>& aKeysOut);
-
-private:
-  CacheStorageDBSchema() MOZ_DELETE;
-  ~CacheStorageDBSchema() MOZ_DELETE;
-
-  static const int32_t kLatestSchemaVersion = 1;
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBSchema_h
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -1,154 +1,133 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "mozilla/dom/CacheStorageParent.h"
+#include "mozilla/dom/cache/CacheStorageParent.h"
 
-#include "mozilla/dom/CacheParent.h"
-#include "mozilla/dom/CacheStorageDBConnection.h"
+#include "mozilla/dom/cache/CacheParent.h"
+#include "mozilla/dom/cache/Manager.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
-using mozilla::dom::cache::RequestId;
-
-CacheStorageParent::CacheStorageParent(cache::Namespace aNamespace,
+CacheStorageParent::CacheStorageParent(Namespace aNamespace,
                                        const nsACString& aOrigin,
                                        const nsACString& aBaseDomain)
   : mNamespace(aNamespace)
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
+  , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
-  mDBConnection = new CacheStorageDBConnection(this, mNamespace, mOrigin,
-                                               mBaseDomain);
-  MOZ_ASSERT(mDBConnection);
+  MOZ_ASSERT(mManager);
 }
 
 CacheStorageParent::~CacheStorageParent()
 {
-  MOZ_ASSERT(!mDBConnection);
+  MOZ_ASSERT(!mManager);
 }
 
 void
 CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->ClearListener();
-  mDBConnection = nullptr;
+  MOZ_ASSERT(mManager);
+  mManager->RemoveListener(this);
+  mManager = nullptr;
 }
 
 bool
 CacheStorageParent::RecvGet(const RequestId& aRequestId, const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Get(aRequestId, aKey);
+  mManager->StorageGet(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvHas(const RequestId& aRequestId, const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Has(aRequestId, aKey);
+  mManager->StorageHas(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvCreate(const RequestId& aRequestId,
                                const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-
-  // TODO: perform a Has() check first
-  // TODO: create real DB-backed cache object
-  // TODO: get uuid from cache object
-  nsID uuid;
-
-  mDBConnection->Put(aRequestId, aKey, uuid);
-
+  mManager->StorageCreate(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvDelete(const RequestId& aRequestId,
                                const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Delete(aRequestId, aKey);
+  mManager->StorageDelete(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Keys(aRequestId);
+  mManager->StorageKeys(this, aRequestId, mNamespace);
   return true;
 }
 
 void
-CacheStorageParent::OnGet(cache::RequestId aRequestId, nsresult aRv,
-                          nsID* aCacheId)
+CacheStorageParent::OnStorageGet(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheFound, CacheId aCacheId)
 {
-  if (NS_FAILED(aRv) || !aCacheId) {
+  if (NS_FAILED(aRv) || !aCacheFound) {
     unused << SendGetResponse(aRequestId, aRv, nullptr);
     return;
   }
 
-  // TODO: create cache parent for given uuid
-  CacheParent* actor = new CacheParent(mOrigin, mBaseDomain);
-  if (actor) {
-    PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
-                                                          mBaseDomain);
-    actor = static_cast<CacheParent*>(base);
-  }
+  CacheParent* actor = new CacheParent(mOrigin, mBaseDomain, aCacheId);
+  PCacheParent* base = Manager()->SendPCacheConstructor(actor);
+  actor = static_cast<CacheParent*>(base);
   unused << SendGetResponse(aRequestId, aRv, actor);
 }
 
 void
-CacheStorageParent::OnHas(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageHas(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheFound)
 {
-  unused << SendHasResponse(aRequestId, aRv, aSuccess);
+  unused << SendHasResponse(aRequestId, aRv, aCacheFound);
 }
 
 void
-CacheStorageParent::OnPut(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageCreate(RequestId aRequestId, nsresult aRv,
+                                    CacheId aCacheId)
 {
   if (NS_FAILED(aRv)) {
     unused << SendCreateResponse(aRequestId, aRv, nullptr);
     return;
   }
 
-  CacheParent* actor = nullptr;
-  if (aSuccess) {
-    // TODO: retrieve DB-backed actor for uuid generated in RecvCreate()
-    actor = new CacheParent(mOrigin, mBaseDomain);
-    if (actor) {
-      PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
-                                                            mBaseDomain);
-      actor = static_cast<CacheParent*>(base);
-    }
-  }
+  CacheParent* actor = new CacheParent(mOrigin, mBaseDomain, aCacheId);
+  PCacheParent* base = Manager()->SendPCacheConstructor(actor);
+  actor = static_cast<CacheParent*>(base);
   unused << SendCreateResponse(aRequestId, aRv, actor);
 }
 
 void
-CacheStorageParent::OnDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                    bool aCacheDeleted)
 {
-  unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
+  unused << SendDeleteResponse(aRequestId, aRv, aCacheDeleted);
 }
 
 void
-CacheStorageParent::OnKeys(RequestId aRequestId, nsresult aRv,
-                           const nsTArray<nsString>& aKeys)
+CacheStorageParent::OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                                  const nsTArray<nsString>& aKeys)
 {
   unused << SendKeysResponse(aRequestId, aRv, aKeys);
 }
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -2,64 +2,63 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorageParent_h
 #define mozilla_dom_cache_CacheStorageParent_h
 
-#include "mozilla/dom/CacheStorageDBListener.h"
-#include "mozilla/dom/CacheTypes.h"
-#include "mozilla/dom/PCacheStorageParent.h"
+#include "mozilla/dom/cache/PCacheStorageParent.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/Types.h"
 
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
-
-class CacheStorageDBConnection;
-class CacheStorageManager;
+namespace cache {
 
 class CacheStorageParent MOZ_FINAL : public PCacheStorageParent
-                                   , public CacheStorageDBListener
+                                   , public Manager::Listener
 {
 public:
-  CacheStorageParent(cache::Namespace aNamespace, const nsACString& aOrigin,
+  CacheStorageParent(Namespace aNamespace, const nsACString& aOrigin,
                      const nsACString& mBaseDomain);
   virtual ~CacheStorageParent();
 
   // PCacheStorageParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
-  virtual bool RecvGet(const cache::RequestId& aRequestId,
+  virtual bool RecvGet(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
-  virtual bool RecvHas(const cache::RequestId& aRequestId,
+  virtual bool RecvHas(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
-  virtual bool RecvCreate(const cache::RequestId& aRequestId,
+  virtual bool RecvCreate(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
-  virtual bool RecvDelete(const cache::RequestId& aRequestId,
+  virtual bool RecvDelete(const RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
-  virtual bool RecvKeys(const cache::RequestId& aRequestId) MOZ_OVERRIDE;
+  virtual bool RecvKeys(const RequestId& aRequestId) MOZ_OVERRIDE;
 
-  // CacheStorageDBListener
-  virtual void OnGet(cache::RequestId aRequestId, nsresult aRv,
-                     nsID* aCacheId) MOZ_OVERRIDE;
-  virtual void OnHas(cache::RequestId aRequestId, nsresult aRv,
-                     bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
-                     bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
-                        bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnKeys(cache::RequestId aRequestId, nsresult aRv,
-                      const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
+  // Manager::Listener methods
+  virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
+                            bool aCacheFound,
+                            CacheId aCacheId) MOZ_OVERRIDE;
+  virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
+                            bool aCacheFound) MOZ_OVERRIDE;
+  virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
+                               CacheId aCacheId) MOZ_OVERRIDE;
+  virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                               bool aCacheDeleted) MOZ_OVERRIDE;
+  virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                             const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
-  const cache::Namespace mNamespace;
+  const Namespace mNamespace;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
-  nsRefPtr<CacheStorageDBConnection> mDBConnection;
-  nsTArray<nsString> mKeys;
+  nsRefPtr<mozilla::dom::cache::Manager> mManager;
 };
 
+} // namesapce cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorageParent_h
diff --git a/dom/cache/CacheTypes.h b/dom/cache/CacheTypes.h
deleted file mode 100644
--- a/dom/cache/CacheTypes.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_CacheTypes_h
-#define mozilla_dom_CacheTypes_h
-
-#include <stdint.h>
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-enum Namespace
-{
-  DEFAULT_NAMESPACE,
-  CHROME_ONLY_NAMESPACE,
-  NUMBER_OF_NAMESPACES
-};
-
-typedef uintptr_t RequestId;
-static const RequestId INVALID_REQUEST_ID = 0;
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_CacheTypes_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.cpp
@@ -0,0 +1,546 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Context.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/quota/OriginOrPatternString.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "nsIFile.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::Nullable;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
+{
+public:
+  QuotaReleaseRunnable(const nsACString& aOrigin, const nsACString& aQuotaId)
+    : mOrigin(aOrigin)
+    , mQuotaId(aQuotaId)
+  {
+  }
+
+private:
+  const nsCString mOrigin;
+  const nsCString mQuotaId;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
+
+NS_IMETHODIMP
+QuotaReleaseRunnable::Run()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mOrigin),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                              mQuotaId);
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
+                                           , public Action::Resolver
+{
+public:
+  QuotaInitRunnable(Context* aContext,
+                    const nsACString& aOrigin,
+                    const nsACString& aBaseDomain,
+                    const nsACString& aQuotaId,
+                    Action* aQuotaIOThreadAction)
+    : mContext(aContext)
+    , mOrigin(aOrigin)
+    , mBaseDomain(aBaseDomain)
+    , mQuotaId(aQuotaId)
+    , mQuotaIOThreadAction(aQuotaIOThreadAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_CALL_WAIT_FOR_OPEN_ALLOWED;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aRv));
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
+    }
+  }
+
+protected:
+  virtual ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mQuotaIOThreadAction);
+  }
+
+private:
+  enum State
+  {
+    STATE_INIT,
+    STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
+    STATE_WAIT_FOR_OPEN_ALLOWED,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mQuotaIOThreadAction = nullptr;
+  }
+
+  nsRefPtr<Context> mContext;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  const nsCString mQuotaId;
+  nsRefPtr<Action> mQuotaIOThreadAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  nsCOMPtr<nsIFile> mQuotaDir;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::QuotaInitRunnable::Run()
+{
+  QuotaManager* qm;
+  nsresult rv;
+
+  switch(mState) {
+    case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::GetOrCreate();
+      if (!qm) {
+        Resolve(NS_ERROR_FAILURE);
+        return NS_OK;
+      }
+      mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mOrigin),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                                  mQuotaId, this);
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+      // TODO: MOZ_ASSERT(NS_GetCurrentThread() == QuotaManager::Get()->IOThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+                                         mBaseDomain,
+                                         mOrigin,
+                                         true, // aTrackQuota
+                                         getter_AddRefs(mQuotaDir));
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      mState = STATE_RUNNING;
+      if (mQuotaIOThreadAction) {
+        nsCOMPtr<nsIFile> quotaDir;
+        rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
+        if (NS_FAILED(rv)) {
+          Resolve(rv);
+          return NS_OK;
+        }
+        mQuotaIOThreadAction->RunOnTarget(this, quotaDir);
+      } else {
+        Resolve(NS_OK);
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
+      }
+      mContext->OnQuotaInit(mResult, mQuotaDir);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    default:
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+      break;
+  }
+
+  return NS_OK;
+}
+
+class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
+                                        , public Action::Resolver
+{
+public:
+  ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
+                 nsIFile* aQuotaDir)
+    : mContext(aContext)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaDir(aQuotaDir)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    MOZ_ASSERT(mQuotaDir);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  bool MatchesCacheId(CacheId aCacheId) {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    return mAction->MatchesCacheId(aCacheId);
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    nsresult rv;
+    switch(mState) {
+      case STATE_INIT:
+        mState = STATE_COMPLETE;
+        break;
+      case STATE_RUN_ON_TARGET:
+        mState = STATE_CANCELING;
+        break;
+      case STATE_RUNNING:
+        mState = STATE_CANCELING;
+        rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+        }
+      case STATE_CANCELING:
+      case STATE_COMPLETING:
+      case STATE_COMPLETE:
+        break;
+      default:
+        MOZ_CRASH("unexpected state");
+        break;
+    }
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+    }
+  }
+
+private:
+  virtual ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->OnActionRunnableComplete(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_CANCELING,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  nsRefPtr<Context> mContext;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  nsRefPtr<Action> mAction;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::ActionRunnable::Run()
+{
+  nsresult rv;
+  switch(mState) {
+    case STATE_RUN_ON_TARGET:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaDir);
+      break;
+    case STATE_CANCELING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_COMPLETING;
+      mAction->CancelOnTarget();
+      mResult = NS_FAILED(mResult) ? mResult : NS_ERROR_FAILURE;
+      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    default:
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+  }
+  return NS_OK;
+}
+
+Context::Context(Listener* aListener, const nsACString& aOrigin,
+                 const nsACString& aBaseDomain, Action* aQuotaIOThreadAction)
+  : mListener(aListener)
+  , mOrigin(aOrigin)
+  , mState(STATE_CONTEXT_INIT)
+{
+  MOZ_ASSERT(mListener);
+
+  nsRefPtr<QuotaInitRunnable> runnable =
+    new QuotaInitRunnable(this, aOrigin, aBaseDomain,
+                          NS_LITERAL_CSTRING("Cache"), aQuotaIOThreadAction);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+Context::ClearListener()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+void
+Context::Dispatch(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aTarget);
+  MOZ_ASSERT(aAction);
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mTarget = aTarget;
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aTarget, aAction);
+}
+
+void
+Context::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    mActionRunnables[i]->Cancel();
+  }
+}
+
+void
+Context::CancelForCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (mActionRunnables[i]->MatchesCacheId(aCacheId)) {
+      mActionRunnables[i]->Cancel();
+    }
+  }
+}
+
+Context::~Context()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  // Unlock the quota dir as we go out of scope.
+  nsCOMPtr<nsIRunnable> runnable =
+    new QuotaReleaseRunnable(mOrigin, NS_LITERAL_CSTRING("Cache"));
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  }
+
+  if (mListener) {
+    mListener->RemoveContext(this);
+  }
+}
+
+void
+Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  nsCOMPtr<nsIFile> quotaDir;
+  nsresult rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aAction->CompleteOnInitiatingThread(rv);
+    return;
+  }
+
+  nsRefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, aTarget, aAction, quotaDir);
+  mActionRunnables.AppendElement(runnable);
+  rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+}
+
+void
+Context::OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+
+  if (NS_FAILED(aRv)) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  mQuotaDir = aQuotaDir;
+  MOZ_ASSERT(mQuotaDir);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aActionRunnable);
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (aActionRunnable == mActionRunnables[i]) {
+      mActionRunnables.RemoveElementAt(i);
+      return;
+    }
+  }
+  MOZ_ASSERT(false);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Context_h
+#define mozilla_dom_cache_Context_h
+
+#include "mozilla/dom/cache/Types.h"
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIEventTarget;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action;
+
+class Context MOZ_FINAL
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+    // Called from the Context destructor on the thread that originally
+    // created the Context.
+    virtual void RemoveContext(Context* aContext)=0;
+  };
+
+  Context(Listener* aListener, const nsACString& aOrigin,
+          const nsACString& aBaseDomain, Action* aQuotaIOThreadAction);
+
+  void ClearListener();
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(nsIEventTarget* aTarget, Action* aAction);
+
+  // Cancel any Actions running or waiting to run.  This should allow the
+  // Context to be released and Listener::RemoveContext() will be called
+  // when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+  // Cancel any Actions running or waiting to run that operate on the given
+  // cache ID.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelForCacheId(CacheId aCacheId);
+
+private:
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    nsRefPtr<Action> mAction;
+  };
+
+  ~Context();
+  void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
+  void OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir);
+  void OnActionRunnableComplete(ActionRunnable* const aAction);
+
+  Listener* mListener;
+  const nsCString mOrigin;
+  State mState;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsTArray<PendingAction> mPendingActions;
+
+  // weak refs since ~ActionRunnable() removes itself from this list
+  nsTArray<ActionRunnable*> mActionRunnables;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.cpp
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBAction.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode, const nsACString& aOrigin,
+                   const nsACString& aBaseDomain)
+  : mMode(aMode)
+  , mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaDir);
+
+  nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+  MOZ_ASSERT(conn);
+  RunWithDBOnTarget(aResolver, aQuotaDir, conn);
+}
+
+nsresult
+DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFile> dbTmpDir;
+  rv = aDBDir->Clone(getter_AddRefs(dbTmpDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbTmpDir->Append(NS_LITERAL_STRING("db"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
+  //      but this is what IDB does to access mozIStorageConnection so
+  //      it seems at least this corner case mostly works.
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
+
+  rv = dbFileUrl->SetQuery(NS_LITERAL_CSTRING("persistenceType=") + type +
+                           NS_LITERAL_CSTRING("&group=") + mBaseDomain +
+                           NS_LITERAL_CSTRING("&origin=") + mOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    dbFile->Remove(false);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dbTmpDir->Exists(&exists);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (exists) {
+      bool isDir;
+      rv = dbTmpDir->IsDirectory(&isDir);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!isDir)) { return NS_ERROR_UNEXPECTED; }
+      rv = dbTmpDir->Remove(true);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  MOZ_ASSERT(*aConnOut);
+  return rv;
+}
+
+SyncDBAction::SyncDBAction(Mode aMode, const nsACString& aOrigin,
+                           const nsACString& aBaseDomain)
+  : DBAction(aMode, aOrigin, aBaseDomain)
+{
+}
+
+void
+SyncDBAction::RunWithDBOnTarget(Resolver* aResolver, nsIFile* aQuotaDir,
+                                mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaDir);
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = RunSyncWithDBOnTarget(aQuotaDir, aConn);
+  aResolver->Resolve(rv);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.h
@@ -0,0 +1,67 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBAction_h
+#define mozilla_dom_cache_DBAction_h
+
+#include "mozilla/dom/cache/Action.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBAction : public Action
+{
+protected:
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  DBAction(Mode aMode, const nsACString& aOrigin,
+           const nsACString& aBaseDomain);
+
+  virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
+                                 mozIStorageConnection* aConn)=0;
+
+  virtual
+  void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
+
+  virtual ~DBAction() { }
+
+private:
+  nsresult OpenConnection(nsIFile* aQuotaDir, mozIStorageConnection** aConnOut);
+
+  const Mode mMode;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+};
+
+class SyncDBAction : public DBAction
+{
+protected:
+  SyncDBAction(Mode aMode, const nsACString& aOrigin,
+               const nsACString& aBaseDomain);
+
+  virtual ~SyncDBAction() { }
+
+  virtual nsresult RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                                         mozIStorageConnection* aConn)=0;
+
+  virtual void RunWithDBOnTarget(Resolver* aResolver, nsIFile* aDBDir,
+                                 mozIStorageConnection* aConn) MOZ_OVERRIDE;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.cpp
@@ -0,0 +1,663 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBSchema.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/dom/cache/PCacheQueryParams.h"
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::void_t;
+
+// static
+nsresult
+DBSchema::CreateSchema(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aConn);
+
+  nsAutoCString pragmas(
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
+    // Switch the journaling mode to TRUNCATE to avoid changing the directory
+    // structure at the conclusion of every transaction for devices with slower
+    // file systems.
+    "PRAGMA journal_mode = TRUNCATE; "
+#endif
+    "PRAGMA foreign_keys = ON; "
+  );
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t schemaVersion;
+  rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (schemaVersion == kLatestSchemaVersion) {
+    return rv;
+  }
+
+  if (!schemaVersion) {
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE caches ("
+        "id INTEGER NOT NULL PRIMARY KEY "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE entries ("
+        "id INTEGER NOT NULL PRIMARY KEY, "
+        "request_method TEXT NOT NULL, "
+        "request_url TEXT NOT NULL, "
+        "request_url_no_query TEXT NOT NULL, "
+        "request_mode INTEGER NOT NULL, "
+        "request_credentials INTEGER NOT NULL, "
+        //"request_body_file TEXT NOT NULL, "
+        "response_type INTEGER NOT NULL, "
+        "response_status INTEGER NOT NULL, "
+        "response_status_text TEXT NOT NULL, "
+        //"response_body_file TEXT NOT NULL "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_index "
+                "ON entries (request_url);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_no_query_index "
+                "ON entries (request_url_no_query);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE request_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE response_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) ON DELETE CASCADE"
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // We need an index on response_headers, but not on request_headers,
+    // because we quickly need to determine if a VARY header is present.
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX response_headers_name_index "
+                "ON response_headers (name);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE storage ("
+        "namespace INTEGER NOT NULL, "
+        "key TEXT NOT NULL, "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id), "
+        "PRIMARY KEY(namespace, key) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->GetSchemaVersion(&schemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  if (schemaVersion != kLatestSchemaVersion) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CreateCache(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aCacheIdOut);
+
+  nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "INSERT INTO caches DEFAULT VALUES;"
+  ));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT last_insert_rowid()"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!hasMoreData)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId)
+{
+  MOZ_ASSERT(aConn);
+
+  // Dependent data removed by ON DELETE CASCADE in schema definition.
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM caches WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::IsCacheOrphaned(mozIStorageConnection* aConn,
+                          CacheId aCacheId, bool* aOrphanedOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aOrphanedOut);
+
+  // err on the side of not deleting user data
+  *aOrphanedOut = false;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT COUNT(*) FROM storage WHERE cache_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  MOZ_ASSERT(hasMoreData);
+
+  int32_t refCount;
+  rv = state->GetInt32(0, &refCount);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aOrphanedOut = refCount < 1;
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
+                     const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams,
+                     PCacheResponseOrVoid* aResponseOrVoidOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aResponseOrVoidOut);
+
+  nsTArray<EntryId> matches;
+  nsresult rv = QueryCache(aConn, aCacheId, aRequest, aParams, matches);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (matches.Length() < 1) {
+    *aResponseOrVoidOut = void_t();
+    return rv;
+  }
+
+  PCacheResponse response;
+  rv = ReadResponse(aConn, matches[0], response);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aResponseOrVoidOut = response;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                        const PCacheRequestOrVoid& aRequestOrVoid,
+                        const PCacheQueryParams& aParams,
+                        nsTArray<PCacheResponse>& aResponsesOut)
+{
+  MOZ_ASSERT(aConn);
+  nsresult rv;
+
+  nsTArray<EntryId> matches;
+  if (aRequestOrVoid.type() == PCacheRequestOrVoid::Tvoid_t) {
+    rv = QueryAll(aConn, aCacheId, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  } else {
+    rv = QueryCache(aConn, aCacheId, aRequestOrVoid, aParams, matches);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // TODO: replace this with a bulk load using SQL IN clause
+  for (uint32_t i = 0; i < matches.Length(); ++i) {
+    PCacheResponse *response = aResponsesOut.AppendElement();
+    rv = ReadResponse(aConn, matches[i], *response);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageGetCacheId(mozIStorageConnection* aConn, Namespace aNamespace,
+                            const nsAString& aKey, bool* aFoundCacheOut,
+                            CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aFoundCacheOut);
+  MOZ_ASSERT(aCacheIdOut);
+
+  *aFoundCacheOut = false;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT cache_id FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!hasMoreData) {
+    return rv;
+  }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aFoundCacheOut = true;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StoragePutCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                          const nsAString& aKey, CacheId aCacheId)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO storage (namespace, key, cache_id) VALUES(?1, ?2, ?3);"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(2, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageForgetCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                             const nsAString& aKey)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageGetKeys(mozIStorageConnection* aConn, Namespace aNamespace,
+                         nsTArray<nsString>& aKeysOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT key FROM storage WHERE namespace=?1 ORDER BY rowid;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString* key = aKeysOut.AppendElement();
+    rv = state->GetString(0, *key);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                   nsTArray<EntryId>& aEntryIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT id FROM entries WHERE cache_id=?1 ORDER BY id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    EntryId* entryId = aEntryIdListOut.AppendElement();
+    rv = state->GetInt32(0, entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                     const PCacheRequest& aRequest,
+                     const PCacheQueryParams& aParams,
+                     nsTArray<EntryId>& aEntryIdListOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsTArray<PCacheRequest> requestArray;
+  nsTArray<PCacheResponse> responseArray;
+
+  // TODO: throw if new Request() would have failed:
+  // TODO:    - throw if aRequest is no CORS and method is not simple method
+
+  if (!aParams.ignoreMethod() && !aRequest.method().LowerCaseEqualsLiteral("get")
+                              && !aRequest.method().LowerCaseEqualsLiteral("head"))
+  {
+    return NS_OK;
+  }
+
+  nsAutoCString query(
+    "SELECT id, COUNT(response_headers.name) AS vary_count "
+    "FROM map "
+    "LEFT OUTER JOIN response_headers ON entries.id=response_headers.entry_id "
+                                    "AND response_headers.name='vary' "
+    "WHERE entries.cache_id=?1 "
+      "AND entries."
+  );
+
+  nsAutoString urlToMatch;
+  if (aParams.ignoreSearch()) {
+    urlToMatch = aRequest.urlWithoutQuery();
+    query.Append(NS_LITERAL_CSTRING("request_url_no_query"));
+  } else {
+    urlToMatch = aRequest.url();
+    query.Append(NS_LITERAL_CSTRING("request_url"));
+  }
+
+  nsAutoCString urlComparison;
+  if (aParams.prefixMatch()) {
+    urlToMatch.AppendLiteral("%");
+    query.Append(NS_LITERAL_CSTRING(" LIKE ?2 ESCAPE '\\'"));
+  } else {
+    query.Append(NS_LITERAL_CSTRING("=?2"));
+  }
+
+  query.Append(NS_LITERAL_CSTRING(" GROUP BY entries.id ORDER BY entries.id;"));
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (aParams.prefixMatch()) {
+    nsAutoString escapedUrlToMatch;
+    rv = state->EscapeStringForLIKE(urlToMatch, '\\', escapedUrlToMatch);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    urlToMatch = escapedUrlToMatch;
+  }
+
+  rv = state->BindStringParameter(1, urlToMatch);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    EntryId entryId;
+    rv = state->GetInt32(0, &entryId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t varyCount;
+    rv = state->GetInt32(1, &varyCount);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!aParams.ignoreVary() && varyCount > 0) {
+      bool matchedByVary;
+      rv = MatchByVaryHeader(aConn, aRequest, entryId, &matchedByVary);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (matchedByVary) {
+        continue;
+      }
+    }
+
+    aEntryIdListOut.AppendElement(entryId);
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::MatchByVaryHeader(mozIStorageConnection* aConn,
+                            const PCacheRequest& aRequest,
+                            EntryId entryId, bool* aSuccessOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT value FROM response_headers "
+    "WHERE name='vary' AND entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, entryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsTArray<nsCString> varyValues;
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsCString* value = varyValues.AppendElement();
+    rv = state->GetUTF8String(0, *value);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Should not have called this function if this was not the case
+  MOZ_ASSERT(varyValues.Length() > 0);
+
+  state->Reset();
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT name, value FROM request_headers "
+    "WHERE AND entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, entryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<Headers> cachedHeaders = new Headers(nullptr);
+
+  ErrorResult errorResult;
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsAutoCString name;
+    nsAutoCString value;
+    rv = state->GetUTF8String(0, name);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    rv = state->GetUTF8String(1, value);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    cachedHeaders->Append(name, value, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsRefPtr<Headers> queryHeaders = new Headers(nullptr, aRequest.headers());
+
+  for (uint32_t i = 0; i < varyValues.Length(); ++i) {
+    if (varyValues[i].EqualsLiteral("*")) {
+      continue;
+    }
+
+    nsAutoCString queryValue;
+    queryHeaders->Get(varyValues[i], queryValue, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+
+    nsAutoCString cachedValue;
+    cachedHeaders->Get(varyValues[i], cachedValue, errorResult);
+    if (errorResult.Failed()) { return errorResult.ErrorCode(); };
+
+    if (queryValue != cachedValue) {
+      *aSuccessOut = false;
+      return rv;
+    }
+  }
+
+  *aSuccessOut = true;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::ReadResponse(mozIStorageConnection* aConn,
+                       EntryId aEntryId, PCacheResponse& aResponseOut)
+{
+  MOZ_ASSERT(aConn);
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "response_type, "
+      "response_status, "
+      "response_status_text "
+    "FROM entries "
+    "WHERE id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t type;
+  rv = state->GetInt32(0, &type);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aResponseOut.type() = static_cast<ResponseType>(type);
+
+  int32_t status;
+  rv = state->GetInt32(1, &status);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  aResponseOut.status() = status;
+
+  rv = state->GetUTF8String(2, aResponseOut.statusText());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+      "name, "
+      "value "
+    "FROM response_headers "
+    "WHERE entry_id=?1;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aEntryId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    PHeadersEntry* header = aResponseOut.headers().AppendElement();
+
+    rv = state->GetUTF8String(0, header->name());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetUTF8String(1, header->value());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.h
@@ -0,0 +1,86 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBSchema_h
+#define mozilla_dom_cache_DBSchema_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsError.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheQueryParams;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+class PCacheResponseOrVoid;
+
+class DBSchema MOZ_FINAL
+{
+public:
+  static nsresult CreateSchema(mozIStorageConnection* aConn);
+
+  static nsresult CreateCache(mozIStorageConnection* aConn,
+                              CacheId* aCacheIdOut);
+  static nsresult DeleteCache(mozIStorageConnection* aConn, CacheId aCacheId);
+
+  static nsresult IsCacheOrphaned(mozIStorageConnection* aConn,
+                                  CacheId aCacheId, bool* aOrphanedOut);
+
+  static nsresult CacheMatch(mozIStorageConnection* aConn, CacheId aCacheId,
+                             const PCacheRequest& aRequest,
+                             const PCacheQueryParams& aParams,
+                             PCacheResponseOrVoid* aResponseOrVoidOut);
+  static nsresult CacheMatchAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                                const PCacheRequestOrVoid& aRequestOrVoid,
+                                const PCacheQueryParams& aParams,
+                                nsTArray<PCacheResponse>& aResponsesOut);
+
+  static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
+                                    Namespace aNamespace, const nsAString& aKey,
+                                    bool* aFoundCacheOut, CacheId* aCacheIdOut);
+  static nsresult StoragePutCache(mozIStorageConnection* aConn,
+                                  Namespace aNamespace, const nsAString& aKey,
+                                  CacheId aCacheId);
+  static nsresult StorageForgetCache(mozIStorageConnection* aConn,
+                                     Namespace aNamespace,
+                                     const nsAString& aKey);
+  static nsresult StorageGetKeys(mozIStorageConnection* aConn,
+                                 Namespace aNamespace,
+                                 nsTArray<nsString>& aKeysOut);
+
+private:
+  typedef int32_t EntryId;
+  static nsresult QueryAll(mozIStorageConnection* aConn, CacheId aCacheId,
+                           nsTArray<EntryId>& aEntryIdListOut);
+  static nsresult QueryCache(mozIStorageConnection* aConn, CacheId aCacheId,
+                             const PCacheRequest& aRequest,
+                             const PCacheQueryParams& aParams,
+                             nsTArray<EntryId>& aEntryIdListOut);
+  static nsresult MatchByVaryHeader(mozIStorageConnection* aConn,
+                                    const PCacheRequest& aRequest,
+                                    EntryId entryId, bool* aSuccessOut);
+  static nsresult ReadResponse(mozIStorageConnection* aConn,
+                               EntryId aEntryId, PCacheResponse& aResponseOut);
+
+  DBSchema() MOZ_DELETE;
+  ~DBSchema() MOZ_DELETE;
+
+  static const int32_t kLatestSchemaVersion = 1;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBSchema_h
diff --git a/dom/cache/CacheIPCUtils.h b/dom/cache/IPCUtils.h
rename from dom/cache/CacheIPCUtils.h
rename to dom/cache/IPCUtils.h
--- a/dom/cache/CacheIPCUtils.h
+++ b/dom/cache/IPCUtils.h
@@ -1,22 +1,22 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_CacheIPCUtils_h
-#define mozilla_dom_CacheIPCUtils_h
+#ifndef mozilla_dom_cache_IPCUtils_h
+#define mozilla_dom_cache_IPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 
 namespace IPC {
   template<>
   struct ParamTraits<mozilla::dom::cache::Namespace> :
     public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
                                     mozilla::dom::cache::DEFAULT_NAMESPACE,
                                     mozilla::dom::cache::NUMBER_OF_NAMESPACES>
   {};
 }
 
-#endif // mozilla_dom_CacheIPCUtils_h
+#endif // mozilla_dom_cache_IPCUtils_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.cpp
@@ -0,0 +1,691 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Manager.h"
+
+#include "mozilla/dom/cache/DBAction.h"
+#include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/PCacheQueryParams.h"
+#include "mozilla/dom/cache/PCacheRequest.h"
+#include "mozilla/dom/cache/PCacheResponse.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozStorageHelper.h"
+#include "nsAutoPtr.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::cache::DBSchema;
+using mozilla::dom::cache::SyncDBAction;
+
+class SetupAction MOZ_FINAL : public SyncDBAction
+{
+public:
+  SetupAction(const nsACString& aOrigin, const nsACString& aBaseDomain)
+    : SyncDBAction(DBAction::Create, aOrigin, aBaseDomain)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    // TODO: create body directory structure
+    // TODO: init maintainance marker
+    // TODO: perform maintainance if necessary
+    // TODO: find orphaned caches in database
+
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::CreateSchema(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+private:
+  virtual ~SetupAction() { }
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager::Factory
+{
+private:
+  static Factory* sFactory;
+  nsTArray<Manager*> mManagerList;
+
+public:
+  static Factory& Instance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      sFactory = new Factory();
+    }
+    return *sFactory;
+  }
+
+  already_AddRefed<Manager> GetOrCreate(const nsACString& aOrigin,
+                                        const nsACString& aBaseDomain)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i]->Origin() == aOrigin) {
+        nsRefPtr<Manager> ref = mManagerList[i];
+        return ref.forget();
+      }
+    }
+
+    nsRefPtr<Manager> ref = new Manager(aOrigin, aBaseDomain);
+
+    mManagerList.AppendElement(ref);
+
+    return ref.forget();
+  }
+
+  void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i] == aManager) {
+        mManagerList.RemoveElementAt(i);
+
+        if (mManagerList.Length() < 1) {
+          delete sFactory;
+          sFactory = nullptr;
+        }
+        return;
+      }
+    }
+  }
+};
+
+// static
+Manager::Factory* Manager::Factory::sFactory = nullptr;
+
+class Manager::BaseAction : public SyncDBAction
+{
+protected:
+  BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
+    : SyncDBAction(DBAction::Existing, aManager->Origin(),
+                   aManager->BaseDomain())
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId (aRequestId)
+  { }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv)=0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    Listener* listener = mManager->GetListener(mListenerId);
+    if (!listener) {
+      return;
+    }
+    Complete(listener, aRv);
+  }
+
+  virtual ~BaseAction() { }
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
+};
+
+class Manager::DeleteOrphanedCacheAction MOZ_FINAL : public SyncDBAction
+{
+public:
+  DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
+    : SyncDBAction(DBAction::Existing, aManager->Origin(),
+                   aManager->BaseDomain())
+    , mManager(aManager)
+    , mCacheId(aCacheId)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    // TODO: get body data file names
+
+    nsresult rv =  DBSchema::DeleteCache(aConn, mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // TODO: delete body data files
+
+    return rv;
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE { }
+
+private:
+  virtual ~DeleteOrphanedCacheAction() { }
+  nsRefPtr<Manager> mManager;
+  const CacheId mCacheId;
+};
+
+class Manager::CheckCacheOrphanedAction MOZ_FINAL : public SyncDBAction
+{
+public:
+  CheckCacheOrphanedAction(Manager* aManager, CacheId aCacheId)
+    : SyncDBAction(DBAction::Existing, aManager->Origin(),
+                   aManager->BaseDomain())
+    , mManager(aManager)
+    , mCacheId(aCacheId)
+    , mOrphaned(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    // Note: We need to do the check separately from the delete so we have the
+    //       opportunity to cancel pending IO actions in
+    //       CompleteOnInitiatingThread().
+    return DBSchema::IsCacheOrphaned(aConn, mCacheId, &mOrphaned);
+  }
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    if (!mOrphaned) {
+      return;
+    }
+
+    mManager->CurrentContext()->CancelForCacheId(mCacheId);
+
+    nsRefPtr<Action> action = new DeleteOrphanedCacheAction(mManager, mCacheId);
+    mManager->CurrentContext()->Dispatch(mManager->mIOThread, action);
+  }
+
+private:
+  virtual ~CheckCacheOrphanedAction() { }
+  nsRefPtr<Manager> mManager;
+  const CacheId mCacheId;
+  bool mOrphaned;
+};
+
+class Manager::CacheMatchAction : public Manager::BaseAction
+{
+public:
+  CacheMatchAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, CacheId aCacheId,
+                   const PCacheRequest& aRequest,
+                   const PCacheQueryParams& aParams)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequest(aRequest)
+    , mParams(aParams)
+    , mResponseOrVoid(void_t())
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::CacheMatch(aConn, mCacheId, mRequest, mParams,
+                                &mResponseOrVoid);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnCacheMatch(mRequestId, aRv, mResponseOrVoid);
+  }
+
+protected:
+  virtual ~CacheMatchAction() { }
+  const CacheId mCacheId;
+  const PCacheRequest mRequest;
+  const PCacheQueryParams mParams;
+  PCacheResponseOrVoid mResponseOrVoid;
+};
+
+class Manager::CacheMatchAllAction : public Manager::BaseAction
+{
+public:
+  CacheMatchAllAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, CacheId aCacheId,
+                      const PCacheRequestOrVoid& aRequestOrVoid,
+                      const PCacheQueryParams& aParams)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mCacheId(aCacheId)
+    , mRequestOrVoid(aRequestOrVoid)
+    , mParams(aParams)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::CacheMatchAll(aConn, mCacheId, mRequestOrVoid, mParams,
+                                   mResponses);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnCacheMatchAll(mRequestId, aRv, mResponses);
+  }
+
+protected:
+  virtual ~CacheMatchAllAction() { }
+  const CacheId mCacheId;
+  const PCacheRequestOrVoid mRequestOrVoid;
+  const PCacheQueryParams mParams;
+  nsTArray<PCacheResponse> mResponses;
+};
+
+class Manager::StorageGetAction : public Manager::BaseAction
+{
+public:
+  StorageGetAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, Namespace aNamespace,
+                   const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheFound(false)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
+                                       &mCacheFound, &mCacheId);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageGet(mRequestId, aRv, mCacheFound, mCacheId);
+  }
+
+protected:
+  virtual ~StorageGetAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheFound;
+  CacheId mCacheId;
+};
+
+class Manager::StorageHasAction MOZ_FINAL : public Manager::StorageGetAction
+{
+public:
+  StorageHasAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, Namespace aNamespace,
+                   const nsAString& aKey)
+    : StorageGetAction(aManager, aListenerId, aRequestId, aNamespace, aKey)
+  { }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageHas(mRequestId, aRv, mCacheFound);
+  }
+
+private:
+  virtual ~StorageHasAction() { }
+};
+
+class Manager::StorageCreateAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageCreateAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace,
+                      const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::CreateCache(aConn, &mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = DBSchema::StoragePutCache(aConn, mNamespace, mKey, mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageCreate(mRequestId, aRv, mCacheId);
+  }
+
+private:
+  virtual ~StorageCreateAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  CacheId mCacheId;
+};
+
+class Manager::StorageDeleteAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageDeleteAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace,
+                      const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheDeleted(false)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    bool exists;
+    CacheId cacheId;
+    nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey, &exists,
+                                              &cacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!exists) {
+      mCacheDeleted = false;
+      return NS_OK;
+    }
+
+    rv = DBSchema::StorageForgetCache(aConn, mNamespace, mKey);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    mCacheDeleted = true;
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageDelete(mRequestId, aRv, mCacheDeleted);
+  }
+
+private:
+  virtual ~StorageDeleteAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheDeleted;
+};
+
+class Manager::StorageKeysAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageKeysAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+  { }
+
+  virtual nsresult
+  RunSyncWithDBOnTarget(nsIFile* aDBDir,
+                        mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::StorageGetKeys(aConn, mNamespace, mKeys);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (NS_FAILED(aRv)) {
+      mKeys.Clear();
+    }
+    aListener->OnStorageKeys(mRequestId, aRv, mKeys);
+  }
+
+private:
+  virtual ~StorageKeysAction() { }
+  const Namespace mNamespace;
+  nsTArray<nsString> mKeys;
+};
+
+// static
+already_AddRefed<Manager>
+Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
+}
+
+void
+Manager::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+Manager::AddRefCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      mCacheIdRefs[i].mCount += 1;
+      return;
+    }
+  }
+  CacheIdRefCounter* entry = mCacheIdRefs.AppendElement();
+  entry->mCacheId = aCacheId;
+  entry->mCount = 1;
+}
+
+void
+Manager::ReleaseCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
+    if (mCacheIdRefs[i].mCacheId == aCacheId) {
+      DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
+      mCacheIdRefs[i].mCount -= 1;
+      MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
+      if (mCacheIdRefs[i].mCount < 1) {
+        mCacheIdRefs.RemoveElementAt(i);
+        nsRefPtr<Action> action = new CheckCacheOrphanedAction(this, aCacheId);
+        CurrentContext()->Dispatch(mIOThread, action);
+      }
+      return;
+    }
+  }
+  MOZ_ASSERT_UNREACHABLE("Attempt to release CacheId that is not referenced!");
+}
+
+void
+Manager::CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                    const PCacheRequest& aRequest,
+                    const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheMatchAction(this, listenerId, aRequestId,
+                                                 aCacheId, aRequest, aParams);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::CacheMatchAll(Listener* aListener, RequestId aRequestId,
+                       CacheId aCacheId, const PCacheRequestOrVoid& aRequest,
+                       const PCacheQueryParams& aParams)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new CacheMatchAllAction(this, listenerId, aRequestId,
+                                                    aCacheId, aRequest, aParams);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageGet(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageGetAction(this, listenerId, aRequestId,
+                                                 aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageHas(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageHasAction(this, listenerId, aRequestId,
+                                                 aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageCreate(Listener* aListener, RequestId aRequestId,
+                       Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageCreateAction(this, listenerId, aRequestId,
+                                                    aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageDelete(Listener* aListener, RequestId aRequestId,
+                       Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageDeleteAction(this, listenerId, aRequestId,
+                                                    aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageKeys(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<Action> action = new StorageKeysAction(this, listenerId, aRequestId,
+                                                  aNamespace);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::RemoveContext(Context* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+  mContext = nullptr;
+}
+
+Manager::Manager(const nsACString& aOrigin, const nsACString& aBaseDomain)
+  : mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+  , mContext(nullptr)
+{
+  nsresult rv = NS_NewNamedThread("DOMCacheThread",
+                                  getter_AddRefs(mIOThread));
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to spawn cache manager IO thread.");
+  }
+}
+
+Manager::~Manager()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  Factory::Instance().Remove(this);
+  if (mContext) {
+    mContext->CancelAll();
+    mContext->ClearListener();
+  }
+  mIOThread->Shutdown();
+}
+
+Context*
+Manager::CurrentContext()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  if (!mContext) {
+    nsRefPtr<Action> setupAction = new SetupAction(mOrigin, mBaseDomain);
+    mContext = new Context(this, mOrigin, mBaseDomain, setupAction);
+  }
+  return mContext;
+}
+
+Manager::ListenerId
+Manager::SaveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (mListeners[i] == aListener) {
+      return reinterpret_cast<ListenerId>(aListener);
+    }
+  }
+  mListeners.AppendElement(aListener);
+  return reinterpret_cast<ListenerId>(aListener);
+}
+
+Manager::Listener*
+Manager::GetListener(ListenerId aListenerId) const
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
+      return mListeners[i];
+    }
+  }
+  return nullptr;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.h
@@ -0,0 +1,132 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Manager_h
+#define mozilla_dom_cache_Manager_h
+
+#include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIThread;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class PCacheQueryParams;
+class PCacheRequest;
+class PCacheRequestOrVoid;
+class PCacheResponse;
+class PCacheResponseOrVoid;
+
+class Manager MOZ_FINAL : public Context::Listener
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+
+    virtual void OnCacheMatch(RequestId aRequestId, nsresult aRv,
+                              const PCacheResponseOrVoid& aResponseOrVoid) { }
+    virtual void OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
+                                 const nsTArray<PCacheResponse>& aResponses) { }
+
+    virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
+                              bool aCacheFound, CacheId aCacheId) { }
+    virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
+                              bool aCacheFound) { }
+    virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
+                                 CacheId aCacheId) { }
+    virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheDeleted) { }
+    virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                               const nsTArray<nsString>& aKeys) { }
+  };
+
+  static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
+                                             const nsACString& aBaseDomain);
+
+  void RemoveListener(Listener* aListener);
+  void AddRefCacheId(CacheId aCacheId);
+  void ReleaseCacheId(CacheId aCacheId);
+
+  void CacheMatch(Listener* aListener, RequestId aRequestId, CacheId aCacheId,
+                  const PCacheRequest& aRequest,
+                  const PCacheQueryParams& aParams);
+  void CacheMatchAll(Listener* aListener, RequestId aRequestId,
+                     CacheId aCacheId, const PCacheRequestOrVoid& aRequestOrVoid,
+                     const PCacheQueryParams& aParams);
+
+  void StorageGet(Listener* aListener, RequestId aRequestId,
+                  Namespace aNamespace, const nsAString& aKey);
+  void StorageHas(Listener* aListener, RequestId aRequestId,
+                  Namespace aNamespace, const nsAString& aKey);
+  void StorageCreate(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey);
+  void StorageDelete(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey);
+  void StorageKeys(Listener* aListener, RequestId aRequestId,
+                   Namespace aNamespace);
+
+  const nsCString& Origin() const { return mOrigin; }
+  const nsCString& BaseDomain() const { return mBaseDomain; }
+
+  // Context::Listener methods
+  virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
+
+private:
+  class Factory;
+  class BaseAction;
+  class CheckCacheOrphanedAction;
+  class DeleteOrphanedCacheAction;
+
+  class CacheMatchAction;
+  class CacheMatchAllAction;
+
+  class StorageGetAction;
+  class StorageHasAction;
+  class StorageCreateAction;
+  class StorageDeleteAction;
+  class StorageKeysAction;
+
+  typedef uintptr_t ListenerId;
+
+  Manager(const nsACString& aOrigin, const nsACString& aBaseDomain);
+  ~Manager();
+  Context* CurrentContext();
+
+  ListenerId SaveListener(Listener* aListener);
+  Listener* GetListener(ListenerId aListenerId) const;
+
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  nsCOMPtr<nsIThread> mIOThread;
+  nsTArray<Listener*> mListeners;
+
+  struct CacheIdRefCounter
+  {
+    CacheId mCacheId;
+    uint32_t mCount;
+  };
+  nsTArray<CacheIdRefCounter> mCacheIdRefs;
+
+  // weak ref as Context destructor clears this pointer
+  Context* mContext;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -2,20 +2,21 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include PCacheQueryParams;
 include PCacheRequest;
 include PCacheResponse;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/CacheTypes.h";
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 protocol PCache
 {
   manager PBackground;
 
 parent:
   Match(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
@@ -33,10 +34,11 @@ child:
   PutResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid response);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
   KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
 
 both:
   __delete__();
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheQueryParams.ipdlh b/dom/cache/PCacheQueryParams.ipdlh
--- a/dom/cache/PCacheQueryParams.ipdlh
+++ b/dom/cache/PCacheQueryParams.ipdlh
@@ -1,21 +1,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PHeaders;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 struct PCacheQueryParams
 {
   bool ignoreSearch;
   bool ignoreMethod;
   bool ignoreVary;
   bool prefixMatch;
   bool cacheNameSet;
   nsString cacheName;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheRequest.ipdlh b/dom/cache/PCacheRequest.ipdlh
--- a/dom/cache/PCacheRequest.ipdlh
+++ b/dom/cache/PCacheRequest.ipdlh
@@ -5,16 +5,17 @@
 include PHeaders;
 
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using struct mozilla::void_t from "ipc/IPCMessageUtils.h";
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
   PHeadersEntry[] headers;
   RequestMode mode;
@@ -22,10 +23,11 @@ struct PCacheRequest
 };
 
 union PCacheRequestOrVoid
 {
   void_t;
   PCacheRequest;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheResponse.ipdlh b/dom/cache/PCacheResponse.ipdlh
--- a/dom/cache/PCacheResponse.ipdlh
+++ b/dom/cache/PCacheResponse.ipdlh
@@ -4,25 +4,27 @@
 
 include PHeaders;
 
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 struct PCacheResponse
 {
   ResponseType type;
   uint32_t status;
   nsCString statusText;
   PHeadersEntry[] headers;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,19 +1,20 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/CacheIPCUtils.h";
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
+namespace cache {
 
 protocol PCacheStorage
 {
   manager PBackground;
 
 parent:
   Get(RequestId aRequestId, nsString aKey);
   Has(RequestId aRequestId, nsString aKey);
@@ -27,10 +28,11 @@ child:
   CreateResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
 
 both:
   __delete__();
 };
 
+} // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Types.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Types_h
+#define mozilla_dom_cache_Types_h
+
+#include <stdint.h>
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+enum Namespace
+{
+  DEFAULT_NAMESPACE,
+  CHROME_ONLY_NAMESPACE,
+  NUMBER_OF_NAMESPACES
+};
+
+typedef uintptr_t RequestId;
+static const RequestId INVALID_REQUEST_ID = 0;
+
+typedef int32_t CacheId;
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -1,46 +1,51 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-EXPORTS.mozilla.dom += [
+EXPORTS.mozilla.dom.cache += [
+    'Action.h',
     'Cache.h',
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheDBConnection.h',
     'CacheDBListener.h',
     'CacheDBSchema.h',
-    'CacheIPCUtils.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
-    'CacheStorageDBConnection.h',
-    'CacheStorageDBListener.h',
-    'CacheStorageDBSchema.h',
     'CacheStorageParent.h',
-    'CacheTypes.h',
+    'Context.h',
+    'DBAction.h',
+    'DBSchema.h',
+    'IPCUtils.h',
+    'Manager.h',
+    'Types.h',
 ]
 
-UNIFIED_SOURCES += [
+SOURCES += [
+    'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheDBConnection.cpp',
     'CacheDBSchema.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
-    'CacheStorageDBConnection.cpp',
-    'CacheStorageDBSchema.cpp',
     'CacheStorageParent.cpp',
+    'Context.cpp',
+    'DBAction.cpp',
+    'DBSchema.cpp',
+    'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
     'PCacheStorage.ipdl',
diff --git a/dom/webidl/Cache.webidl b/dom/webidl/Cache.webidl
--- a/dom/webidl/Cache.webidl
+++ b/dom/webidl/Cache.webidl
@@ -4,17 +4,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * The origin of this IDL file is
  * http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html
  *
  */
 
 [Exposed=(Window,Worker),
- Func="mozilla::dom::Cache::PrefEnabled"]
+ Func="mozilla::dom::cache::Cache::PrefEnabled"]
 interface Cache {
   [Throws]
   Promise<Response> match((Request or ScalarValueString) request,
                           optional QueryParams params);
   [Throws]
   Promise<sequence<Response>> matchAll(optional (Request or ScalarValueString) request,
                                        optional QueryParams params);
   [Throws]
diff --git a/dom/webidl/CacheStorage.webidl b/dom/webidl/CacheStorage.webidl
--- a/dom/webidl/CacheStorage.webidl
+++ b/dom/webidl/CacheStorage.webidl
@@ -4,17 +4,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  * The origin of this IDL file is
  * http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html
  *
  */
 
 [Exposed=(Window,Worker),
- Func="mozilla::dom::CacheStorage::PrefEnabled"]
+ Func="mozilla::dom::cache::CacheStorage::PrefEnabled"]
 interface CacheStorage {
    [Throws] Promise<Response> match((Request or ScalarValueString) request,
                                     optional QueryParams params);
    [Throws] Promise<Cache> get(DOMString cacheName);
    [Throws] Promise<boolean> has(DOMString cacheName);
    [Throws] Promise<Cache> create(DOMString cacheName);
    [Throws] Promise<boolean> delete(DOMString cacheName);
    [Throws] Promise<sequence<DOMString>> keys();
diff --git a/dom/webidl/WorkerGlobalScope.webidl b/dom/webidl/WorkerGlobalScope.webidl
--- a/dom/webidl/WorkerGlobalScope.webidl
+++ b/dom/webidl/WorkerGlobalScope.webidl
@@ -44,11 +44,11 @@ WorkerGlobalScope implements GlobalFetch
 partial interface WorkerGlobalScope {
   attribute EventHandler onclose;
 
   void dump(optional DOMString str);
 
   // XXXbz no spec for this yet, because the webperf WG is a bit dysfunctional
   readonly attribute Performance performance;
 
-  [Func="mozilla::dom::CacheStorage::PrefEnabled"]
+  [Func="mozilla::dom::cache::CacheStorage::PrefEnabled"]
   readonly attribute CacheStorage caches;
 };
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -8,17 +8,17 @@
 
 #include "jsapi.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/dom/Fetch.h"
 #include "mozilla/dom/FunctionBinding.h"
 #include "mozilla/dom/DedicatedWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
 #include "mozilla/dom/SharedWorkerGlobalScopeBinding.h"
-#include "mozilla/dom/CacheStorage.h"
+#include "mozilla/dom/cache/CacheStorage.h"
 #include "mozilla/dom/Console.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #include "Location.h"
 #include "Navigator.h"
@@ -29,16 +29,17 @@
 #include "Performance.h"
 
 #define UNWRAP_WORKER_OBJECT(Interface, obj, value)                           \
   UnwrapObject<prototypes::id::Interface##_workers,                           \
     mozilla::dom::Interface##Binding_workers::NativeType>(obj, value)
 
 using namespace mozilla;
 using namespace mozilla::dom;
+using mozilla::dom::cache::CacheStorage;
 USING_WORKERS_NAMESPACE
 
 BEGIN_WORKERS_NAMESPACE
 
 WorkerGlobalScope::WorkerGlobalScope(WorkerPrivate* aWorkerPrivate)
 : mWorkerPrivate(aWorkerPrivate)
 {
   mWorkerPrivate->AssertIsOnWorkerThread();
diff --git a/dom/workers/WorkerScope.h b/dom/workers/WorkerScope.h
--- a/dom/workers/WorkerScope.h
+++ b/dom/workers/WorkerScope.h
@@ -12,20 +12,23 @@
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/UnionTypes.h"
 
 #include "ServiceWorkerClients.h"
 
 namespace mozilla {
 namespace dom {
 
-class CacheStorage;
 class Console;
 class Function;
 
+namespace cache {
+class CacheStorage;
+}
+
 } // namespace dom
 } // namespace mozilla
 
 BEGIN_WORKERS_NAMESPACE
 
 class WorkerPrivate;
 class WorkerLocation;
 class WorkerNavigator;
@@ -33,17 +36,17 @@ class Performance;
 
 class WorkerGlobalScope : public DOMEventTargetHelper,
                           public nsIGlobalObject
 {
   nsRefPtr<Console> mConsole;
   nsRefPtr<WorkerLocation> mLocation;
   nsRefPtr<WorkerNavigator> mNavigator;
   nsRefPtr<Performance> mPerformance;
-  nsRefPtr<CacheStorage> mCacheStorage;
+  nsRefPtr<mozilla::dom::cache::CacheStorage> mCacheStorage;
 
 protected:
   WorkerPrivate* mWorkerPrivate;
 
   explicit WorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
   virtual ~WorkerGlobalScope();
 
 public:
@@ -127,17 +130,17 @@ public:
 
   Performance* GetPerformance();
 
   already_AddRefed<Promise>
   Fetch(const RequestOrScalarValueString& aInput,
         const RequestInit& aInit,
         ErrorResult& aRv);
 
-  already_AddRefed<CacheStorage> Caches();
+  already_AddRefed<mozilla::dom::cache::CacheStorage> Caches();
 };
 
 class DedicatedWorkerGlobalScope MOZ_FINAL : public WorkerGlobalScope
 {
   ~DedicatedWorkerGlobalScope() { }
 
 public:
   explicit DedicatedWorkerGlobalScope(WorkerPrivate* aWorkerPrivate);
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -1,23 +1,23 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
-#include "mozilla/dom/CacheChild.h"
 #include "mozilla/dom/MessagePortChild.h"
-#include "mozilla/dom/PCacheStorageChild.h"
+#include "mozilla/dom/cache/CacheChild.h"
+#include "mozilla/dom/cache/PCacheStorageChild.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
-using mozilla::dom::PCacheStorageChild;
-using mozilla::dom::CacheChild;
-using mozilla::dom::PCacheChild;
+using mozilla::dom::cache::PCacheStorageChild;
+using mozilla::dom::cache::CacheChild;
+using mozilla::dom::cache::PCacheChild;
 
 namespace {
 
 class TestChild MOZ_FINAL : public mozilla::ipc::PBackgroundTestChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
   nsCString mTestArg;
@@ -113,18 +113,17 @@ BackgroundChildImpl::DeallocPCacheStorag
 {
   // The CacheStorageChild actor is provided to the PBackground manager, but
   // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
 PCacheChild*
-BackgroundChildImpl::AllocPCacheChild(const nsCString& aOrigin,
-                                      const nsCString& aBaseDomain)
+BackgroundChildImpl::AllocPCacheChild()
 {
   return new CacheChild();
 }
 
 bool
 BackgroundChildImpl::DeallocPCacheChild(PCacheChild* aActor)
 {
   // The CacheChild actor is provided to the PBackground manager, but
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -7,18 +7,20 @@
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 
 template <class> class nsAutoPtr;
 
 namespace mozilla {
 namespace dom {
+namespace cache {
+  class PCacheChild;
   class PCacheStorageChild;
-  class PCacheChild;
+}
 }
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundChildImpl : public PBackgroundChild
 {
 public:
@@ -40,30 +42,28 @@ protected:
   ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
 
   virtual PBackgroundTestChild*
   AllocPBackgroundTestChild(const nsCString& aTestArg) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundTestChild(PBackgroundTestChild* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::PCacheStorageChild*
+  virtual mozilla::dom::cache::PCacheStorageChild*
   AllocPCacheStorageChild(const Namespace& aNamespace,
                           const nsCString& aOrigin,
                           const nsCString& aBaseDomain) MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheStorageChild(mozilla::dom::PCacheStorageChild* aActor) MOZ_OVERRIDE;
+  DeallocPCacheStorageChild(mozilla::dom::cache::PCacheStorageChild* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::PCacheChild*
-  AllocPCacheChild(const nsCString& aOrigin,
-                   const nsCString& aBaseDomain) MOZ_OVERRIDE;
+  virtual mozilla::dom::cache::PCacheChild* AllocPCacheChild() MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheChild(mozilla::dom::PCacheChild* aActor) MOZ_OVERRIDE;
+  DeallocPCacheChild(mozilla::dom::cache::PCacheChild* aActor) MOZ_OVERRIDE;
 
   virtual PMessagePortChild*
   AllocPMessagePortChild() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortChild(PMessagePortChild* aActor) MOZ_OVERRIDE;
 };
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -1,27 +1,30 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundParentImpl.h"
 
 #include "mozilla/Assertions.h"
+#include "mozilla/dom/MessagePortParent.h"
+#include "mozilla/dom/cache/CacheStorageParent.h"
+#include "mozilla/dom/cache/PCacheParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
-#include "mozilla/dom/MessagePortParent.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
-#include "mozilla/dom/CacheParent.h"
-#include "mozilla/dom/CacheStorageParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 
 using namespace mozilla::dom;
+using mozilla::dom::cache::PCacheParent;
+using mozilla::dom::cache::CacheStorageParent;
+using mozilla::dom::cache::PCacheStorageParent;
 
 namespace {
 
 void
 AssertIsInMainProcess()
 {
   MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Default);
 }
@@ -124,25 +127,27 @@ BackgroundParentImpl::AllocPCacheStorage
 bool
 BackgroundParentImpl::DeallocPCacheStorageParent(PCacheStorageParent* aActor)
 {
   delete aActor;
   return true;
 }
 
 PCacheParent*
-BackgroundParentImpl::AllocPCacheParent(const nsCString& aOrigin,
-                                        const nsCString& aBaseDomain)
+BackgroundParentImpl::AllocPCacheParent()
 {
-  return new CacheParent(aOrigin, aBaseDomain);
+  MOZ_CRASH("CacheParent actor must be provided to PBackground manager");
+  return nullptr;
 }
 
 bool
 BackgroundParentImpl::DeallocPCacheParent(PCacheParent* aActor)
 {
+  // The CacheParent actor is provided to the PBackground manager, but
+  // we own the object and must delete it.
   delete aActor;
   return true;
 }
 
 PMessagePortParent*
 BackgroundParentImpl::AllocPMessagePortParent()
 {
   AssertIsInMainProcess();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -5,18 +5,20 @@
 #ifndef mozilla_ipc_backgroundparentimpl_h__
 #define mozilla_ipc_backgroundparentimpl_h__
 
 #include "mozilla/Attributes.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 
 namespace mozilla {
 namespace dom {
+namespace cache {
+  class PCacheParent;
   class PCacheStorageParent;
-  class PCacheParent;
+}
 }
 namespace ipc {
 
 // Instances of this class should never be created directly. This class is meant
 // to be inherited in BackgroundImpl.
 class BackgroundParentImpl : public PBackgroundParent
 {
 protected:
@@ -31,30 +33,28 @@ protected:
 
   virtual bool
   RecvPBackgroundTestConstructor(PBackgroundTestParent* aActor,
                                  const nsCString& aTestArg) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundTestParent(PBackgroundTestParent* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::PCacheStorageParent*
+  virtual mozilla::dom::cache::PCacheStorageParent*
   AllocPCacheStorageParent(const Namespace& aNamespace,
                            const nsCString& aOrigin,
                            const nsCString& aBaseDomain) MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheStorageParent(mozilla::dom::PCacheStorageParent* aActor) MOZ_OVERRIDE;
+  DeallocPCacheStorageParent(mozilla::dom::cache::PCacheStorageParent* aActor) MOZ_OVERRIDE;
 
-  virtual mozilla::dom::PCacheParent*
-  AllocPCacheParent(const nsCString& aOrigin,
-                    const nsCString& aBaseDomain) MOZ_OVERRIDE;
+  virtual mozilla::dom::cache::PCacheParent* AllocPCacheParent() MOZ_OVERRIDE;
 
   virtual bool
-  DeallocPCacheParent(mozilla::dom::PCacheParent* aActor) MOZ_OVERRIDE;
+  DeallocPCacheParent(mozilla::dom::cache::PCacheParent* aActor) MOZ_OVERRIDE;
 
   virtual PMessagePortParent*
   AllocPMessagePortParent() MOZ_OVERRIDE;
 
   virtual bool
   DeallocPMessagePortParent(PMessagePortParent* aActor) MOZ_OVERRIDE;
 };
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundTest;
 include protocol PCacheStorage;
 include protocol PCache;
 include protocol PMessagePort;
 
-using mozilla::dom::cache::Namespace from "mozilla/dom/CacheTypes.h";
+using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace ipc {
 
 protocol PBackground
 {
   manages PBackgroundTest;
   manages PCacheStorage;
@@ -22,14 +22,14 @@ protocol PBackground
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PCacheStorage(Namespace namespaceEnum, nsCString origin, nsCString baseDomain);
 
   PMessagePort();
 
-both:
-  PCache(nsCString origin, nsCString baseDomain);
+child:
+  PCache();
 };
 
 } // namespace ipc
 } // namespace mozilla
