# HG changeset patch
# Parent ef83d4c403d06c3c0db74c831636b40557bd774a
# User Ben Kelly <ben@wanderview.com>
Refactor Cache/CacheStorage backend.

diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.cpp
@@ -0,0 +1,18 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Action.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action);
+NS_IMPL_ISUPPORTS0(mozilla::dom::cache::Action::Resolver);
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Action.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Action_h
+#define mozilla_dom_cache_Action_h
+
+#include "nsISupportsImpl.h"
+
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action : public nsISupports
+{
+protected:
+  virtual ~Action() { }
+
+public:
+  class Resolver : public nsISupports
+  {
+  protected:
+    virtual ~Resolver() { }
+
+  public:
+
+    // Note: Action must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on Action's target thread.
+    virtual void Resolve(nsresult aRv)=0;
+
+    NS_DECL_THREADSAFE_ISUPPORTS
+  };
+
+  // Execute operations on target thread. Once complete call
+  // Resolver::Resolve().  This can be done sync or async.
+  // Note: Action should hold Resolver ref until its ready to call Resolve().
+  virtual void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)=0;
+
+  // Called on target thread if the Action is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: Action must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_CacheChildListener_h
 #define mozilla_dom_CacheChildListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 
 namespace ipc {
   class IProtocol;
 }
 
diff --git a/dom/cache/CacheDBConnection.cpp b/dom/cache/CacheDBConnection.cpp
--- a/dom/cache/CacheDBConnection.cpp
+++ b/dom/cache/CacheDBConnection.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/CacheDBConnection.h"
 
 #include "mozilla/dom/CacheDBListener.h"
 #include "mozilla/dom/CacheDBSchema.h"
 #include "mozilla/dom/CacheQuotaRunnable.h"
-#include "mozilla/dom/CacheTypes.h"
 #include "mozilla/dom/Headers.h"
 #include "mozilla/dom/PCacheQueryParams.h"
 #include "mozilla/dom/PCacheRequest.h"
 #include "mozilla/dom/PCacheResponse.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsServiceManagerUtils.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
@@ -55,17 +54,17 @@ protected:
 
   virtual ~OpenRunnable() { }
   virtual void RunOnQuotaIOThread(const nsACString& aOrigin,
                                   const nsACString& aBaseDomain,
                                   nsIFile* aQuotaDir) MOZ_OVERRIDE
   {
     MOZ_ASSERT(aQuotaDir);
 
-    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cache-old"));
     if (NS_FAILED(mResult)) { return; }
 
     char cacheIdBuf[NSID_LENGTH];
     mCacheId.ToProvidedString(cacheIdBuf);
     mResult = aQuotaDir->Append(NS_ConvertUTF8toUTF16(cacheIdBuf));
     if (NS_FAILED(mResult)) { return; }
 
     bool exists;
diff --git a/dom/cache/CacheDBConnection.h b/dom/cache/CacheDBConnection.h
--- a/dom/cache/CacheDBConnection.h
+++ b/dom/cache/CacheDBConnection.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBConnection_h
 #define mozilla_dom_cache_CacheDBConnection_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 struct nsID;
 template<class T> class nsTArray;
 
diff --git a/dom/cache/CacheDBListener.h b/dom/cache/CacheDBListener.h
--- a/dom/cache/CacheDBListener.h
+++ b/dom/cache/CacheDBListener.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBListener_h
 #define mozilla_dom_cache_CacheDBListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
 
 class PCacheResponse;
diff --git a/dom/cache/CacheDBSchema.h b/dom/cache/CacheDBSchema.h
--- a/dom/cache/CacheDBSchema.h
+++ b/dom/cache/CacheDBSchema.h
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheDBSchema_h
 #define mozilla_dom_cache_CacheDBSchema_h
 
 #include "mozilla/Attributes.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 
 class mozIStorageConnection;
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
 
diff --git a/dom/cache/CacheIPCUtils.h b/dom/cache/CacheIPCUtils.h
--- a/dom/cache/CacheIPCUtils.h
+++ b/dom/cache/CacheIPCUtils.h
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_CacheIPCUtils_h
 #define mozilla_dom_CacheIPCUtils_h
 
 #include "ipc/IPCMessageUtils.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 
 namespace IPC {
   template<>
   struct ParamTraits<mozilla::dom::cache::Namespace> :
     public ContiguousEnumSerializer<mozilla::dom::cache::Namespace,
                                     mozilla::dom::cache::DEFAULT_NAMESPACE,
                                     mozilla::dom::cache::NUMBER_OF_NAMESPACES>
   {};
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheParent_h
 #define mozilla_dom_cache_CacheParent_h
 
 #include "mozilla/dom/CacheDBListener.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/PCacheParent.h"
 
 struct nsID;
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
 
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_CacheStorage_h
 #define mozilla_dom_CacheStorage_h
 
 #include "mozilla/dom/CacheStorageChildListener.h"
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "nsTArray.h"
 #include "nsWrapperCache.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 
 class nsIGlobalObject;
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorageChild_h
 #define mozilla_dom_cache_CacheStorageChild_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "mozilla/dom/PCacheStorageChild.h"
 
 namespace mozilla {
 namespace dom {
 
 class CacheStorageChildListener;
 class PCacheChild;
 
diff --git a/dom/cache/CacheStorageChildListener.h b/dom/cache/CacheStorageChildListener.h
--- a/dom/cache/CacheStorageChildListener.h
+++ b/dom/cache/CacheStorageChildListener.h
@@ -2,17 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_CacheStorageChildListener_h
 #define mozilla_dom_CacheStorageChildListener_h
 
-#include "mozilla/dom/CacheTypes.h"
+#include "mozilla/dom/cache/Types.h"
 #include "nsError.h"
 #include "nsString.h"
 
 template<class T> class nsTArray;
 
 namespace mozilla {
 
 namespace ipc {
diff --git a/dom/cache/CacheStorageDBConnection.cpp b/dom/cache/CacheStorageDBConnection.cpp
deleted file mode 100644
--- a/dom/cache/CacheStorageDBConnection.cpp
+++ /dev/null
@@ -1,464 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/CacheStorageDBConnection.h"
-
-#include "mozilla/dom/CacheQuotaRunnable.h"
-#include "mozilla/dom/CacheStorageDBListener.h"
-#include "mozilla/dom/CacheStorageDBSchema.h"
-#include "mozilla/dom/quota/QuotaManager.h"
-#include "mozilla/UniquePtr.h"
-#include "mozIStorageConnection.h"
-#include "mozIStorageService.h"
-#include "mozIStorageStatement.h"
-#include "mozStorageCID.h"
-#include "mozStorageHelper.h"
-#include "nsIFile.h"
-#include "nsNetUtil.h"
-
-namespace mozilla {
-namespace dom {
-
-using mozilla::UniquePtr;
-using mozilla::dom::cache::Namespace;
-using mozilla::dom::cache::RequestId;
-using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
-using mozilla::dom::quota::PersistenceType;
-using mozilla::dom::quota::QuotaManager;
-
-class CacheStorageDBConnection::OpenRunnable : public CacheQuotaRunnable
-{
-public:
-  OpenRunnable(Namespace aNamespace, const nsACString& aOrigin,
-               const nsACString& aBaseDomain, bool aAllowCreate,
-               RequestId aRequestId, const nsAString& aKey,
-               CacheStorageDBConnection* aCacheStorageDBConnection)
-    : CacheQuotaRunnable(aOrigin, aBaseDomain, NS_LITERAL_CSTRING("CacheStorage"))
-    , mNamespace(aNamespace)
-    , mAllowCreate(aAllowCreate)
-    , mRequestId(aRequestId)
-    , mKey(aKey)
-    , mCacheStorageDBConnection(aCacheStorageDBConnection)
-    , mResult(NS_OK)
-  {
-    MOZ_ASSERT(mCacheStorageDBConnection);
-  }
-
-protected:
-  virtual void AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection)=0;
-
-  virtual void RunOnQuotaIOThread(const nsACString& aOrigin,
-                                  const nsACString& aBaseDomain,
-                                  nsIFile* aQuotaDir) MOZ_OVERRIDE
-  {
-    mResult = aQuotaDir->Append(NS_LITERAL_STRING("cachestorage"));
-    if (NS_FAILED(mResult)) { return; }
-
-    bool exists;
-    mResult = aQuotaDir->Exists(&exists);
-    if (NS_FAILED(mResult) || (!exists && !mAllowCreate)) { return; }
-
-    if (!exists) {
-      mResult = aQuotaDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
-      if (NS_FAILED(mResult)) { return; }
-    }
-
-    nsCOMPtr<nsIFile> dbFile;
-    mResult = aQuotaDir->Clone(getter_AddRefs(dbFile));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbFile->Exists(&exists);
-    if (NS_FAILED(mResult) || (!exists && !mAllowCreate)) { return; }
-
-    // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
-    //      but this is what IDB does to access mozIStorageConnection so
-    //      it seems at least this corner case mostly works.
-
-    nsCOMPtr<nsIFile> dbTmpDir;
-    mResult = aQuotaDir->Clone(getter_AddRefs(dbTmpDir));
-    if (NS_FAILED(mResult)) { return; }
-
-    mResult = dbTmpDir->Append(NS_LITERAL_STRING("db"));
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<nsIURI> uri;
-    mResult = NS_NewFileURI(getter_AddRefs(uri), dbFile);
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
-    if (!dbFileUrl) {
-      mResult = NS_ERROR_FAILURE;
-      return;
-    }
-
-    nsAutoCString type;
-    PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
-
-    mResult = dbFileUrl->SetQuery(NS_LITERAL_CSTRING("persistenceType=") + type +
-                                  NS_LITERAL_CSTRING("&group=") + aBaseDomain +
-                                  NS_LITERAL_CSTRING("&origin=") + aOrigin);
-    if (NS_FAILED(mResult)) { return; }
-
-    nsCOMPtr<mozIStorageService> ss =
-      do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
-    if (!ss) {
-      mResult = NS_ERROR_FAILURE;
-      return;
-    }
-
-    nsCOMPtr<mozIStorageConnection> conn;
-    mResult = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
-    if (mResult == NS_ERROR_FILE_CORRUPTED) {
-      mResult = dbFile->Remove(false);
-      if (NS_FAILED(mResult)) { return; }
-
-      mResult = dbTmpDir->Exists(&exists);
-      if (NS_FAILED(mResult)) { return; }
-
-      if (exists) {
-        bool isDir;
-        mResult = dbTmpDir->IsDirectory(&isDir);
-        if (NS_FAILED(mResult)) { return; }
-        if (!isDir) {
-          mResult = NS_ERROR_FAILURE;
-          return;
-        }
-        mResult = dbTmpDir->Remove(true);
-        if (NS_FAILED(mResult)) { return; }
-      }
-
-      mResult = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
-    }
-    if (NS_FAILED(mResult)) { return; }
-    MOZ_ASSERT(conn);
-
-    mResult = CacheStorageDBSchema::Create(conn);
-    if (NS_FAILED(mResult)) { return; }
-
-    AfterOpenOnQuotaIOThread(conn);
-  }
-
-protected:
-  virtual ~OpenRunnable() { }
-
-  const Namespace mNamespace;
-  const bool mAllowCreate;
-  const RequestId mRequestId;
-  const nsString mKey;
-  nsRefPtr<CacheStorageDBConnection> mCacheStorageDBConnection;
-  nsCOMPtr<mozIStorageConnection> mConnection;
-  nsresult mResult;
-};
-
-class CacheStorageDBConnection::GetRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  GetRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Get(aConnection, mNamespace, mKey,
-                                        &mSuccess, &mCacheId);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    if (NS_FAILED(rv) || !mSuccess) {
-      mCacheStorageDBConnection->OnGetComplete(mRequestId, rv, nullptr);
-      return;
-    }
-    mCacheStorageDBConnection->OnGetComplete(mRequestId, rv, &mCacheId);
-  }
-
-private:
-  virtual ~GetRunnable() { }
-  nsID mCacheId;
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::HasRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  HasRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Has(aConnection, mNamespace, mKey,
-                                        &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnHasComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~HasRunnable() { }
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::PutRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  PutRunnable(Namespace aNamespace, const nsACString& aOrigin,
-              const nsACString& aBaseDomain, RequestId aRequestId,
-              const nsAString& aKey, const nsID& aCacheId,
-              CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, true, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mCacheId(aCacheId)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Put(aConnection, mNamespace, mKey, mCacheId,
-                                        &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnPutComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~PutRunnable() { }
-  const nsID mCacheId;
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::DeleteRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  DeleteRunnable(Namespace aNamespace, const nsACString& aOrigin,
-                 const nsACString& aBaseDomain, RequestId aRequestId,
-                 const nsAString& aKey,
-                 CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId, aKey,
-                   aCacheStorageDBConnection)
-    , mSuccess(false)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Delete(aConnection, mNamespace, mKey,
-                                           &mSuccess);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    mCacheStorageDBConnection->OnDeleteComplete(mRequestId, rv, mSuccess);
-  }
-
-private:
-  virtual ~DeleteRunnable() { }
-  bool mSuccess;
-};
-
-class CacheStorageDBConnection::KeysRunnable MOZ_FINAL :
-  public CacheStorageDBConnection::OpenRunnable
-{
-public:
-  KeysRunnable(Namespace aNamespace, const nsACString& aOrigin,
-               const nsACString& aBaseDomain, RequestId aRequestId,
-               CacheStorageDBConnection* aCacheStorageDBConnection)
-    : OpenRunnable(aNamespace, aOrigin, aBaseDomain, false, aRequestId,
-                   NS_LITERAL_STRING(""), aCacheStorageDBConnection)
-  { }
-
-protected:
-  virtual void
-  AfterOpenOnQuotaIOThread(mozIStorageConnection* aConnection) MOZ_OVERRIDE
-  {
-    mResult = CacheStorageDBSchema::Keys(aConnection, mNamespace, mKeys);
-  }
-
-  virtual void CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
-  {
-    nsresult rv = NS_FAILED(aRv) ? aRv : mResult;
-    if (NS_FAILED(rv)) {
-      mKeys.Clear();
-    }
-    mCacheStorageDBConnection->OnKeysComplete(mRequestId, rv, mKeys);
-  }
-
-private:
-  virtual ~KeysRunnable() { }
-  nsTArray<nsString> mKeys;
-};
-
-CacheStorageDBConnection::
-CacheStorageDBConnection(CacheStorageDBListener* aListener,
-                         Namespace aNamespace,
-                         const nsACString& aOrigin,
-                         const nsACString& aBaseDomain)
-  : mListener(aListener)
-  , mNamespace(aNamespace)
-  , mOrigin(aOrigin)
-  , mBaseDomain(aBaseDomain)
-{
-  MOZ_ASSERT(mListener);
-}
-
-void
-CacheStorageDBConnection::ClearListener()
-{
-  MOZ_ASSERT(mListener);
-  mListener = nullptr;
-}
-
-void
-CacheStorageDBConnection::Get(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<GetRunnable> get = new GetRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, this);
-  if (!get) {
-    OnGetComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, nullptr);
-    return;
-  }
-  get->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Has(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<HasRunnable> has = new HasRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, this);
-  if (!has) {
-    OnHasComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  has->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Put(RequestId aRequestId, const nsAString& aKey,
-                              const nsID& aCacheId)
-{
-  nsRefPtr<PutRunnable> put = new PutRunnable(mNamespace, mOrigin, mBaseDomain,
-                                              aRequestId, aKey, aCacheId, this);
-  if (!put) {
-    OnPutComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  put->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Delete(RequestId aRequestId, const nsAString& aKey)
-{
-  nsRefPtr<DeleteRunnable> del = new DeleteRunnable(mNamespace, mOrigin,
-                                                    mBaseDomain, aRequestId,
-                                                    aKey, this);
-  if (!del) {
-    OnDeleteComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, false);
-    return;
-  }
-  del->Dispatch();
-}
-
-void
-CacheStorageDBConnection::Keys(RequestId aRequestId)
-{
-  nsRefPtr<KeysRunnable> keys = new KeysRunnable(mNamespace, mOrigin,
-                                                 mBaseDomain, aRequestId, this);
-  if (!keys) {
-    OnKeysComplete(aRequestId, NS_ERROR_OUT_OF_MEMORY, nsTArray<nsString>());
-    return;
-  }
-  keys->Dispatch();
-}
-
-CacheStorageDBConnection::~CacheStorageDBConnection()
-{
-  MOZ_ASSERT(!mListener);
-}
-
-void
-CacheStorageDBConnection::OnGetComplete(RequestId aRequestId, nsresult aRv,
-                                        nsID* aCacheId)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnGet(aRequestId, aRv, aCacheId);
-  }
-}
-
-void
-CacheStorageDBConnection::OnHasComplete(cache::RequestId aRequestId,
-                                        nsresult aRv, bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnHas(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnPutComplete(RequestId aRequestId, nsresult aRv,
-                                        bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnPut(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnDeleteComplete(RequestId aRequestId, nsresult aRv,
-                                           bool aSuccess)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnDelete(aRequestId, aRv, aSuccess);
-  }
-}
-
-void
-CacheStorageDBConnection::OnKeysComplete(RequestId aRequestId, nsresult aRv,
-                                         const nsTArray<nsString>& aKeys)
-{
-  // TODO: assert on owning thread
-  if (mListener) {
-    mListener->OnKeys(aRequestId, aRv, aKeys);
-  }
-}
-
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/CacheStorageDBConnection.h b/dom/cache/CacheStorageDBConnection.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBConnection.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBConnection_h
-#define mozilla_dom_cache_CacheStorageDBConnection_h
-
-#include "mozilla/dom/CacheTypes.h"
-#include "nsCOMPtr.h"
-#include "nsISupportsImpl.h"
-#include "nsString.h"
-
-class mozIStorageConnection;
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBListener;
-
-class CacheStorageDBConnection MOZ_FINAL
-{
-public:
-  CacheStorageDBConnection(CacheStorageDBListener* aListener,
-                           cache::Namespace aNamespace,
-                           const nsACString& aOrigin,
-                           const nsACString& aBaseDomain);
-
-  void ClearListener();
-
-  void Get(cache::RequestId aRequestId, const nsAString& aKey);
-  void Has(cache::RequestId aRequestId, const nsAString& aKey);
-  void Put(cache::RequestId aRequestId, const nsAString& aKey,
-           const nsID& aCacheId);
-  void Delete(cache::RequestId aRequestId, const nsAString& aKey);
-  void Keys(cache::RequestId aRequestId);
-
-private:
-  class OpenRunnable;
-  class GetRunnable;
-  class HasRunnable;
-  class PutRunnable;
-  class DeleteRunnable;
-  class KeysRunnable;
-
-  ~CacheStorageDBConnection();
-  void OnGetComplete(cache::RequestId aRequestId, nsresult aRv, nsID* aCacheId);
-  void OnHasComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnPutComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnDeleteComplete(cache::RequestId aRequestId, nsresult aRv, bool aSuccess);
-  void OnKeysComplete(cache::RequestId aRequestId, nsresult aRv,
-                      const nsTArray<nsString>& aKeys);
-
-  CacheStorageDBListener* mListener;
-  const cache::Namespace mNamespace;
-  const nsCString mOrigin;
-  const nsCString mBaseDomain;
-
-public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(CacheStorageDBConnection)
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBConnection_h
diff --git a/dom/cache/CacheStorageDBListener.h b/dom/cache/CacheStorageDBListener.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBListener.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBListener_h
-#define mozilla_dom_cache_CacheStorageDBListener_h
-
-#include "mozilla/dom/CacheTypes.h"
-#include "nsError.h"
-#include "nsString.h"
-
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBListener
-{
-  public:
-    virtual ~CacheStorageDBListener() { }
-    virtual void OnGet(cache::RequestId aRequestId, nsresult aRv,
-                       nsID* aCacheId)=0;
-    virtual void OnHas(cache::RequestId aRequestId, nsresult aRv,
-                       bool aSuccess)=0;
-    virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
-                       bool aSuccess)=0;
-    virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
-                          bool aSuccess)=0;
-    virtual void OnKeys(cache::RequestId aRequestId, nsresult aRv,
-                        const nsTArray<nsString>& aKeys)=0;
-
-    // TODO: OnConnected
-    // TODO: OnError (or pass nsresult in each On*() method?
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBListener_h
diff --git a/dom/cache/CacheStorageDBSchema.cpp b/dom/cache/CacheStorageDBSchema.cpp
deleted file mode 100644
--- a/dom/cache/CacheStorageDBSchema.cpp
+++ /dev/null
@@ -1,246 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/CacheStorageDBSchema.h"
-#include "mozStorageHelper.h"
-#include "nsTArray.h"
-
-namespace mozilla {
-namespace dom {
-
-using mozilla::dom::cache::Namespace;
-
-// static
-nsresult
-CacheStorageDBSchema::Create(mozIStorageConnection* aConn)
-{
-  MOZ_ASSERT(aConn);
-  nsresult rv;
-
-#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
-  rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    // Switch the journaling mode to TRUNCATE to avoid changing the directory
-    // structure at the conclusion of every transaction for devices with slower
-    // file systems.
-    "PRAGMA journal_mode = TRUNCATE; "
-  ));
-  if (NS_FAILED(rv)) { return rv; }
-#endif
-
-  int32_t schemaVersion;
-  rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_FAILED(rv)) { return rv; }
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  if (!schemaVersion) {
-    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-      "CREATE TABLE caches ("
-        "namespace INTEGER NOT NULL, "
-        "key TEXT NOT NULL, "
-        "cache_uuid TEXT NOT NULL, "
-        "PRIMARY KEY(namespace, key)"
-      ");"
-    ));
-    if (NS_FAILED(rv)) { return rv; }
-
-    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
-    if (NS_FAILED(rv)) { return rv; }
-
-    rv = aConn->GetSchemaVersion(&schemaVersion);
-    if (NS_FAILED(rv)) { return rv; }
-  }
-
-  if (schemaVersion != kLatestSchemaVersion) {
-    rv = NS_ERROR_FAILURE;
-    return rv;
-  }
-
-  rv = trans.Commit();
-  if (NS_FAILED(rv)) { return rv; }
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Get(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, bool* aSuccessOut,
-                          nsID* aCacheIdOut)
-{
-  MOZ_ASSERT(aConn);
-  MOZ_ASSERT(aSuccessOut);
-  MOZ_ASSERT(aCacheIdOut);
-
-  *aSuccessOut = false;
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT cache_uuid FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  rv = statement->ExecuteStep(&hasMoreData);
-  if (NS_FAILED(rv)) { return rv; }
-
-  if (!hasMoreData) {
-    return NS_OK;
-  }
-
-  nsAutoCString uuidString;
-  rv = statement->GetUTF8String(0, uuidString);
-  if (NS_FAILED(rv)) { return rv; }
-
-  if (!aCacheIdOut->Parse(uuidString.get())) {
-    return NS_ERROR_FAILURE;
-  }
-
-  *aSuccessOut = true;
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Has(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT count(*) FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  rv = statement->ExecuteStep(&hasMoreData);
-  if (NS_FAILED(rv)) { return rv; }
-
-  int32_t count;
-  rv = statement->GetInt32(0, &count);
-  if (NS_FAILED(rv)) { return rv; }
-
-  *aSuccessOut = count > 0;
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Put(mozIStorageConnection* aConn, Namespace aNamespace,
-                          const nsAString& aKey, const nsID& aCacheId,
-                          bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "INSERT INTO caches (namespace, key, cache_uuid)VALUES(?1, ?2, ?3)"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  char uuidBuf[NSID_LENGTH];
-  aCacheId.ToProvidedString(uuidBuf);
-
-  rv = statement->BindUTF8StringParameter(2, nsAutoCString(uuidBuf));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->Execute();
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = trans.Commit();
-  *aSuccessOut = NS_SUCCEEDED(rv);
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Delete(mozIStorageConnection* aConn, Namespace aNamespace,
-                             const nsAString& aKey, bool* aSuccessOut)
-{
-  MOZ_ASSERT(aConn);
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "DELETE FROM caches WHERE namespace=?1 AND key=?2"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindStringParameter(1, aKey);
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->Execute();
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = trans.Commit();
-  *aSuccessOut = NS_SUCCEEDED(rv);
-
-  return rv;
-}
-
-// static
-nsresult
-CacheStorageDBSchema::Keys(mozIStorageConnection* aConn, Namespace aNamespace,
-                           nsTArray<nsString>& aKeysOut)
-{
-  MOZ_ASSERT(aConn);
-
-  nsCOMPtr<mozIStorageStatement> statement;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT key FROM caches WHERE namespace=?1 ORDER BY rowid"
-  ), getter_AddRefs(statement));
-  if (NS_FAILED(rv)) { return rv; }
-
-  rv = statement->BindInt32Parameter(0, aNamespace);
-  if (NS_FAILED(rv)) { return rv; }
-
-  bool hasMoreData;
-  while(NS_SUCCEEDED(statement->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    nsString* key = aKeysOut.AppendElement();
-    if (!key) {
-      rv = NS_ERROR_OUT_OF_MEMORY;
-      return rv;
-    }
-    rv = statement->GetString(0, *key);
-    if (NS_FAILED(rv)) { return rv; }
-  }
-
-  return rv;
-}
-
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/CacheStorageDBSchema.h b/dom/cache/CacheStorageDBSchema.h
deleted file mode 100644
--- a/dom/cache/CacheStorageDBSchema.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_CacheStorageDBSchema_h
-#define mozilla_dom_cache_CacheStorageDBSchema_h
-
-#include "mozilla/Attributes.h"
-#include "mozilla/dom/CacheTypes.h"
-#include "nsError.h"
-#include "nsString.h"
-
-class mozIStorageConnection;
-struct nsID;
-template<class T> class nsTArray;
-
-namespace mozilla {
-namespace dom {
-
-class CacheStorageDBSchema MOZ_FINAL
-{
-public:
-  static nsresult Create(mozIStorageConnection* aConn);
-
-  static nsresult
-  Get(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, bool* aSuccessOut, nsID* aCacheIdOut);
-
-  static nsresult
-  Has(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, bool* aSuccessOut);
-
-  static nsresult
-  Put(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-      const nsAString& aKey, const nsID& aCacheId, bool* aSuccessOut);
-
-  static nsresult
-  Delete(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-         const nsAString& aKey, bool* aSuccessOut);
-
-  static nsresult
-  Keys(mozIStorageConnection* aConn, cache::Namespace aNamespace,
-       nsTArray<nsString>& aKeysOut);
-
-private:
-  CacheStorageDBSchema() MOZ_DELETE;
-  ~CacheStorageDBSchema() MOZ_DELETE;
-
-  static const int32_t kLatestSchemaVersion = 1;
-};
-
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_CacheStorageDBSchema_h
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -2,153 +2,138 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/CacheStorageParent.h"
 
 #include "mozilla/dom/CacheParent.h"
-#include "mozilla/dom/CacheStorageDBConnection.h"
+#include "mozilla/dom/cache/Manager.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::dom::cache::Manager;
+using mozilla::dom::cache::CacheId;
 using mozilla::dom::cache::RequestId;
 
 CacheStorageParent::CacheStorageParent(cache::Namespace aNamespace,
                                        const nsACString& aOrigin,
                                        const nsACString& aBaseDomain)
   : mNamespace(aNamespace)
   , mOrigin(aOrigin)
   , mBaseDomain(aBaseDomain)
+  , mManager(Manager::ForOrigin(aOrigin, aBaseDomain))
 {
-  mDBConnection = new CacheStorageDBConnection(this, mNamespace, mOrigin,
-                                               mBaseDomain);
-  MOZ_ASSERT(mDBConnection);
+  MOZ_ASSERT(mManager);
 }
 
 CacheStorageParent::~CacheStorageParent()
 {
-  MOZ_ASSERT(!mDBConnection);
+  MOZ_ASSERT(!mManager);
 }
 
 void
 CacheStorageParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->ClearListener();
-  mDBConnection = nullptr;
+  MOZ_ASSERT(mManager);
+  mManager->RemoveListener(this);
+  mManager = nullptr;
 }
 
 bool
 CacheStorageParent::RecvGet(const RequestId& aRequestId, const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Get(aRequestId, aKey);
+  mManager->StorageGet(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvHas(const RequestId& aRequestId, const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Has(aRequestId, aKey);
+  mManager->StorageHas(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvCreate(const RequestId& aRequestId,
                                const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-
-  // TODO: perform a Has() check first
-  // TODO: create real DB-backed cache object
-  // TODO: get uuid from cache object
-  nsID uuid;
-
-  mDBConnection->Put(aRequestId, aKey, uuid);
-
+  mManager->StorageCreate(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvDelete(const RequestId& aRequestId,
                                const nsString& aKey)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Delete(aRequestId, aKey);
+  mManager->StorageDelete(this, aRequestId, mNamespace, aKey);
   return true;
 }
 
 bool
 CacheStorageParent::RecvKeys(const RequestId& aRequestId)
 {
-  MOZ_ASSERT(mDBConnection);
-  mDBConnection->Keys(aRequestId);
+  mManager->StorageKeys(this, aRequestId, mNamespace);
   return true;
 }
 
 void
-CacheStorageParent::OnGet(cache::RequestId aRequestId, nsresult aRv,
-                          nsID* aCacheId)
+CacheStorageParent::OnStorageGet(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheFound, CacheId aCacheId)
 {
-  if (NS_FAILED(aRv) || !aCacheId) {
+  if (NS_FAILED(aRv) || !aCacheFound) {
     unused << SendGetResponse(aRequestId, aRv, nullptr);
     return;
   }
 
-  // TODO: create cache parent for given uuid
+  // TODO: create cache parent for given CacheId
   CacheParent* actor = new CacheParent(mOrigin, mBaseDomain);
-  if (actor) {
-    PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
-                                                          mBaseDomain);
-    actor = static_cast<CacheParent*>(base);
-  }
+  PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
+                                                        mBaseDomain);
+  actor = static_cast<CacheParent*>(base);
   unused << SendGetResponse(aRequestId, aRv, actor);
 }
 
 void
-CacheStorageParent::OnHas(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageHas(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheFound)
 {
-  unused << SendHasResponse(aRequestId, aRv, aSuccess);
+  unused << SendHasResponse(aRequestId, aRv, aCacheFound);
 }
 
 void
-CacheStorageParent::OnPut(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageCreate(RequestId aRequestId, nsresult aRv,
+                                    CacheId aCacheId)
 {
   if (NS_FAILED(aRv)) {
     unused << SendCreateResponse(aRequestId, aRv, nullptr);
     return;
   }
 
-  CacheParent* actor = nullptr;
-  if (aSuccess) {
-    // TODO: retrieve DB-backed actor for uuid generated in RecvCreate()
-    actor = new CacheParent(mOrigin, mBaseDomain);
-    if (actor) {
-      PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
-                                                            mBaseDomain);
-      actor = static_cast<CacheParent*>(base);
-    }
-  }
+  // TODO: use cache ID
+  CacheParent* actor = new CacheParent(mOrigin, mBaseDomain);
+  PCacheParent* base = Manager()->SendPCacheConstructor(actor, mOrigin,
+                                                        mBaseDomain);
+  actor = static_cast<CacheParent*>(base);
   unused << SendCreateResponse(aRequestId, aRv, actor);
 }
 
 void
-CacheStorageParent::OnDelete(RequestId aRequestId, nsresult aRv, bool aSuccess)
+CacheStorageParent::OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                    bool aCacheDeleted)
 {
-  unused << SendDeleteResponse(aRequestId, aRv, aSuccess);
+  unused << SendDeleteResponse(aRequestId, aRv, aCacheDeleted);
 }
 
 void
-CacheStorageParent::OnKeys(RequestId aRequestId, nsresult aRv,
-                           const nsTArray<nsString>& aKeys)
+CacheStorageParent::OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                                  const nsTArray<nsString>& aKeys)
 {
   unused << SendKeysResponse(aRequestId, aRv, aKeys);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -2,30 +2,30 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_CacheStorageParent_h
 #define mozilla_dom_cache_CacheStorageParent_h
 
-#include "mozilla/dom/CacheStorageDBListener.h"
-#include "mozilla/dom/CacheTypes.h"
 #include "mozilla/dom/PCacheStorageParent.h"
+#include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/Types.h"
 
 template <class T> class nsRefPtr;
 
 namespace mozilla {
 namespace dom {
 
 class CacheStorageDBConnection;
 class CacheStorageManager;
 
 class CacheStorageParent MOZ_FINAL : public PCacheStorageParent
-                                   , public CacheStorageDBListener
+                                   , public cache::Manager::Listener
 {
 public:
   CacheStorageParent(cache::Namespace aNamespace, const nsACString& aOrigin,
                      const nsACString& mBaseDomain);
   virtual ~CacheStorageParent();
 
   // PCacheStorageParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
@@ -34,32 +34,32 @@ public:
   virtual bool RecvHas(const cache::RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvCreate(const cache::RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvDelete(const cache::RequestId& aRequestId,
                           const nsString& aKey) MOZ_OVERRIDE;
   virtual bool RecvKeys(const cache::RequestId& aRequestId) MOZ_OVERRIDE;
 
-  // CacheStorageDBListener
-  virtual void OnGet(cache::RequestId aRequestId, nsresult aRv,
-                     nsID* aCacheId) MOZ_OVERRIDE;
-  virtual void OnHas(cache::RequestId aRequestId, nsresult aRv,
-                     bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnPut(cache::RequestId aRequestId, nsresult aRv,
-                     bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnDelete(cache::RequestId aRequestId, nsresult aRv,
-                        bool aSuccess) MOZ_OVERRIDE;
-  virtual void OnKeys(cache::RequestId aRequestId, nsresult aRv,
-                      const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
+  // cache::Manager::Listener methods
+  virtual void OnStorageGet(cache::RequestId aRequestId, nsresult aRv,
+                            bool aCacheFound,
+                            cache::CacheId aCacheId) MOZ_OVERRIDE;
+  virtual void OnStorageHas(cache::RequestId aRequestId, nsresult aRv,
+                            bool aCacheFound) MOZ_OVERRIDE;
+  virtual void OnStorageCreate(cache::RequestId aRequestId, nsresult aRv,
+                               cache::CacheId aCacheId) MOZ_OVERRIDE;
+  virtual void OnStorageDelete(cache::RequestId aRequestId, nsresult aRv,
+                               bool aCacheDeleted) MOZ_OVERRIDE;
+  virtual void OnStorageKeys(cache::RequestId aRequestId, nsresult aRv,
+                             const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
 private:
   const cache::Namespace mNamespace;
   const nsCString mOrigin;
   const nsCString mBaseDomain;
-  nsRefPtr<CacheStorageDBConnection> mDBConnection;
-  nsTArray<nsString> mKeys;
+  nsRefPtr<cache::Manager> mManager;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStorageParent_h
diff --git a/dom/cache/CacheTypes.h b/dom/cache/CacheTypes.h
deleted file mode 100644
--- a/dom/cache/CacheTypes.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_CacheTypes_h
-#define mozilla_dom_CacheTypes_h
-
-#include <stdint.h>
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-enum Namespace
-{
-  DEFAULT_NAMESPACE,
-  CHROME_ONLY_NAMESPACE,
-  NUMBER_OF_NAMESPACES
-};
-
-typedef uintptr_t RequestId;
-static const RequestId INVALID_REQUEST_ID = 0;
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_CacheTypes_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.cpp
@@ -0,0 +1,528 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Context.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/quota/OriginOrPatternString.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "nsIFile.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::Nullable;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class QuotaReleaseRunnable MOZ_FINAL : public nsIRunnable
+{
+public:
+  QuotaReleaseRunnable(const nsACString& aOrigin, const nsACString& aQuotaId)
+    : mOrigin(aOrigin)
+    , mQuotaId(aQuotaId)
+  {
+  }
+
+private:
+  const nsCString mOrigin;
+  const nsCString mQuotaId;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(QuotaReleaseRunnable, nsIRunnable);
+
+NS_IMETHODIMP
+QuotaReleaseRunnable::Run()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+  qm->AllowNextSynchronizedOp(OriginOrPatternString::FromOrigin(mOrigin),
+                              Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                              mQuotaId);
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::OriginOrPatternString;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+class Context::QuotaInitRunnable MOZ_FINAL : public nsIRunnable
+                                           , public Action::Resolver
+{
+public:
+  QuotaInitRunnable(Context* aContext,
+                    const nsACString& aOrigin,
+                    const nsACString& aBaseDomain,
+                    const nsACString& aQuotaId,
+                    Action* aQuotaIOThreadAction)
+    : mContext(aContext)
+    , mOrigin(aOrigin)
+    , mBaseDomain(aBaseDomain)
+    , mQuotaId(aQuotaId)
+    , mQuotaIOThreadAction(aQuotaIOThreadAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_CALL_WAIT_FOR_OPEN_ALLOWED;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aRv));
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch QuotaInitRunnable to initiating thread.");
+    }
+  }
+
+protected:
+  virtual ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mQuotaIOThreadAction);
+  }
+
+private:
+  enum State
+  {
+    STATE_INIT,
+    STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
+    STATE_WAIT_FOR_OPEN_ALLOWED,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mQuotaIOThreadAction = nullptr;
+  }
+
+  nsRefPtr<Context> mContext;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  const nsCString mQuotaId;
+  nsRefPtr<Action> mQuotaIOThreadAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+  nsCOMPtr<nsIFile> mQuotaDir;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::QuotaInitRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::QuotaInitRunnable::Run()
+{
+  QuotaManager* qm;
+  nsresult rv;
+
+  switch(mState) {
+    case STATE_CALL_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::GetOrCreate();
+      if (!qm) {
+        Resolve(NS_ERROR_FAILURE);
+        return NS_OK;
+      }
+      mState = STATE_WAIT_FOR_OPEN_ALLOWED;
+      rv = qm->WaitForOpenAllowed(OriginOrPatternString::FromOrigin(mOrigin),
+                                  Nullable<PersistenceType>(PERSISTENCE_TYPE_PERSISTENT),
+                                  mQuotaId, this);
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_WAIT_FOR_OPEN_ALLOWED:
+      MOZ_ASSERT(NS_IsMainThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+      // TODO: MOZ_ASSERT(NS_GetCurrentThread() == QuotaManager::Get()->IOThread());
+      qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_PERSISTENT,
+                                         mBaseDomain,
+                                         mOrigin,
+                                         true, // aTrackQuota
+                                         getter_AddRefs(mQuotaDir));
+      if (NS_FAILED(rv)) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      mState = STATE_RUNNING;
+      if (mQuotaIOThreadAction) {
+        nsCOMPtr<nsIFile> quotaDir;
+        rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
+        if (NS_FAILED(rv)) {
+          Resolve(rv);
+          return NS_OK;
+        }
+        mQuotaIOThreadAction->RunOnTarget(this, quotaDir);
+      } else {
+        Resolve(NS_OK);
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      if (mQuotaIOThreadAction) {
+        mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
+      }
+      mContext->OnQuotaInit(mResult, mQuotaDir);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    default:
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+      break;
+  }
+
+  return NS_OK;
+}
+
+class Context::ActionRunnable MOZ_FINAL : public nsIRunnable
+                                        , public Action::Resolver
+{
+public:
+  ActionRunnable(Context* aContext, nsIEventTarget* aTarget, Action* aAction,
+                 nsIFile* aQuotaDir)
+    : mContext(aContext)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaDir(aQuotaDir)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    MOZ_ASSERT(mQuotaDir);
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    nsresult rv;
+    switch(mState) {
+      case STATE_INIT:
+        mState = STATE_COMPLETE;
+        break;
+      case STATE_RUN_ON_TARGET:
+        mState = STATE_CANCELING;
+        break;
+      case STATE_RUNNING:
+        mState = STATE_CANCELING;
+        rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+        }
+      case STATE_CANCELING:
+      case STATE_COMPLETING:
+      case STATE_COMPLETE:
+        break;
+      default:
+        MOZ_CRASH("unexpected state");
+        break;
+    }
+  }
+
+  virtual void Resolve(nsresult aRv) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING);
+    mResult = aRv;
+    mState = STATE_COMPLETING;
+    nsresult rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_FAILED(rv)) {
+      MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+    }
+  }
+
+private:
+  virtual ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->OnActionRunnableComplete(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_CANCELING,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  nsRefPtr<Context> mContext;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  nsRefPtr<Action> mAction;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS_INHERITED(mozilla::dom::cache::Context::ActionRunnable,
+                            Action::Resolver, nsIRunnable);
+
+NS_IMETHODIMP
+Context::ActionRunnable::Run()
+{
+  nsresult rv;
+  switch(mState) {
+    case STATE_RUN_ON_TARGET:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaDir);
+      break;
+    case STATE_CANCELING:
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      mState = STATE_COMPLETING;
+      mAction->CancelOnTarget();
+      mResult = NS_FAILED(mResult) ? mResult : NS_ERROR_FAILURE;
+      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_FAILED(rv)) {
+        MOZ_CRASH("Failed to dispatch ActionRunnable to initiating thread.");
+      }
+      break;
+    case STATE_COMPLETING:
+      NS_ASSERT_OWNINGTHREAD(Action::Resolver);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    default:
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+  }
+  return NS_OK;
+}
+
+Context::Context(Listener* aListener, const nsACString& aOrigin,
+                 const nsACString& aBaseDomain, Action* aQuotaIOThreadAction)
+  : mListener(aListener)
+  , mOrigin(aOrigin)
+  , mState(STATE_CONTEXT_INIT)
+{
+  MOZ_ASSERT(mListener);
+
+  nsRefPtr<QuotaInitRunnable> runnable =
+    new QuotaInitRunnable(this, aOrigin, aBaseDomain,
+                          NS_LITERAL_CSTRING("Cache"), aQuotaIOThreadAction);
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+Context::ClearListener()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mListener);
+  mListener = nullptr;
+}
+
+void
+Context::Dispatch(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aTarget);
+  MOZ_ASSERT(aAction);
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mTarget = aTarget;
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aTarget, aAction);
+}
+
+void
+Context::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    mActionRunnables[i]->Cancel();
+  }
+}
+
+Context::~Context()
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  // Unlock the quota dir as we go out of scope.
+  nsCOMPtr<nsIRunnable> runnable =
+    new QuotaReleaseRunnable(mOrigin, NS_LITERAL_CSTRING("Cache"));
+  nsresult rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch QuotaReleaseRunnable to main thread.");
+  }
+
+  if (mListener) {
+    mListener->RemoveContext(this);
+  }
+}
+
+void
+Context::DispatchAction(nsIEventTarget* aTarget, Action* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  nsCOMPtr<nsIFile> quotaDir;
+  nsresult rv = mQuotaDir->Clone(getter_AddRefs(quotaDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aAction->CompleteOnInitiatingThread(rv);
+    return;
+  }
+
+  nsRefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, aTarget, aAction, quotaDir);
+  mActionRunnables.AppendElement(runnable);
+  rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+}
+
+void
+Context::OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+
+  if (NS_FAILED(aRv)) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  mQuotaDir = aQuotaDir;
+  MOZ_ASSERT(mQuotaDir);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mTarget, mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+Context::OnActionRunnableComplete(ActionRunnable* aActionRunnable)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+  MOZ_ASSERT(aActionRunnable);
+  for (uint32_t i = 0; i < mActionRunnables.Length(); ++i) {
+    if (aActionRunnable == mActionRunnables[i]) {
+      mActionRunnables.RemoveElementAt(i);
+      return;
+    }
+  }
+  MOZ_ASSERT(false);
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Context.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Context_h
+#define mozilla_dom_cache_Context_h
+
+#include "nsAutoPtr.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIEventTarget;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Action;
+
+class Context MOZ_FINAL
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+    // Called from the Context destructor on the thread that originally
+    // created the Context.
+    virtual void RemoveContext(Context* aContext)=0;
+  };
+
+  Context(Listener* aListener, const nsACString& aOrigin,
+          const nsACString& aBaseDomain, Action* aQuotaIOThreadAction);
+
+  void ClearListener();
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(nsIEventTarget* aTarget, Action* aAction);
+
+  // Cancel any Actions running or waiting to run.  This should allow the
+  // Context to be released and Listener::RemoveContext() will be called
+  // when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+private:
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    nsRefPtr<Action> mAction;
+  };
+
+  ~Context();
+  void DispatchAction(nsIEventTarget* aTarget, Action* aAction);
+  void OnQuotaInit(nsresult aRv, nsIFile* aQuotaDir);
+  void OnActionRunnableComplete(ActionRunnable* const aAction);
+
+  Listener* mListener;
+  const nsCString mOrigin;
+  State mState;
+  nsCOMPtr<nsIFile> mQuotaDir;
+  nsTArray<PendingAction> mPendingActions;
+
+  // weak refs since ~ActionRunnable() removes itself from this list
+  nsTArray<ActionRunnable*> mActionRunnables;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Context)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.cpp
@@ -0,0 +1,136 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBAction.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsNetUtil.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_PERSISTENT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode, const nsACString& aOrigin,
+                   const nsACString& aBaseDomain)
+  : mMode(aMode)
+  , mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir)
+{
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaDir);
+
+  nsresult rv = aQuotaDir->Append(NS_LITERAL_STRING("cache"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+  rv = OpenConnection(aQuotaDir, getter_AddRefs(conn));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+  MOZ_ASSERT(conn);
+  rv = RunSyncOnTarget(aQuotaDir, conn);
+  aResolver->Resolve(rv);
+}
+
+nsresult
+DBAction::OpenConnection(nsIFile* aDBDir, mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFile> dbTmpDir;
+  rv = aDBDir->Clone(getter_AddRefs(dbTmpDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbTmpDir->Append(NS_LITERAL_STRING("db"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
+  //      but this is what IDB does to access mozIStorageConnection so
+  //      it seems at least this corner case mostly works.
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_PERSISTENT, type);
+
+  rv = dbFileUrl->SetQuery(NS_LITERAL_CSTRING("persistenceType=") + type +
+                           NS_LITERAL_CSTRING("&group=") + mBaseDomain +
+                           NS_LITERAL_CSTRING("&origin=") + mOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    dbFile->Remove(false);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dbTmpDir->Exists(&exists);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (exists) {
+      bool isDir;
+      rv = dbTmpDir->IsDirectory(&isDir);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      if (NS_WARN_IF(!isDir)) { return NS_ERROR_UNEXPECTED; }
+      rv = dbTmpDir->Remove(true);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  MOZ_ASSERT(*aConnOut);
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBAction.h
@@ -0,0 +1,57 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBAction_h
+#define mozilla_dom_cache_DBAction_h
+
+#include "mozilla/dom/cache/Action.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBAction : public Action
+{
+public:
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  DBAction(Mode aMode, const nsACString& aOrigin,
+           const nsACString& aBaseDomain);
+
+  virtual ~DBAction() { }
+
+  virtual nsresult RunSyncOnTarget(nsIFile* aDBDir,
+                                   mozIStorageConnection* aConnection)=0;
+
+  virtual
+  void RunOnTarget(Resolver* aResolver, nsIFile* aQuotaDir) MOZ_OVERRIDE;
+
+  // Called on target thread if the DBAction is being canceled.  Simply
+  // clean up and do not call Resolver::Resolve() in this case.
+  // Note: DBAction must drop Resolver ref if CancelOnTarget() is called!
+  virtual void CancelOnTarget() { }
+
+private:
+  nsresult OpenConnection(nsIFile* aQuotaDir, mozIStorageConnection** aConnOut);
+
+  const Mode mMode;
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBAction_h
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.cpp
@@ -0,0 +1,282 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/DBSchema.h"
+
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "nsCOMPtr.h"
+#include "nsTArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+// static
+nsresult
+DBSchema::CreateSchema(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aConn);
+
+  nsAutoCString pragmas(
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
+    // Switch the journaling mode to TRUNCATE to avoid changing the directory
+    // structure at the conclusion of every transaction for devices with slower
+    // file systems.
+    "PRAGMA journal_mode = TRUNCATE; "
+#endif
+    "PRAGMA foreign_keys = ON; "
+  );
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t schemaVersion;
+  rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (schemaVersion == kLatestSchemaVersion) {
+    return NS_OK;
+  }
+
+  if (!schemaVersion) {
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE caches ("
+        "id INTEGER NOT NULL PRIMARY KEY "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE entries ("
+        "id INTEGER NOT NULL PRIMARY KEY, "
+        "request_method TEXT NOT NULL, "
+        "request_url TEXT NOT NULL, "
+        "request_url_no_query TEXT NOT NULL, "
+        "request_mode INTEGER NOT NULL, "
+        "request_credentials INTEGER NOT NULL, "
+        //"request_body_file TEXT NOT NULL, "
+        "response_type INTEGER NOT NULL, "
+        "response_status INTEGER NOT NULL, "
+        "response_status_text TEXT NOT NULL, "
+        //"response_body_file TEXT NOT NULL "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_index "
+                "ON entries (request_url);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX entries_request_url_no_query_index "
+                "ON entries (request_url_no_query);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE request_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE response_headers ("
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "entry_id INTEGER NOT NULL REFERENCES entries(id) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // We need an index on response_headers, but not on request_headers,
+    // because we quickly need to determine if a VARY header is present.
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE INDEX response_headers_name_index "
+                "ON response_headers (name);"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+      "CREATE TABLE storage ("
+        "namespace INTEGER NOT NULL, "
+        "key TEXT NOT NULL, "
+        "cache_id INTEGER NOT NULL REFERENCES caches(id), "
+        "PRIMARY KEY(namespace, key) "
+      ");"
+    ));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->GetSchemaVersion(&schemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  if (schemaVersion != kLatestSchemaVersion) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::CreateCache(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aCacheIdOut);
+
+  nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+    "INSERT INTO caches DEFAULT VALUES;"
+  ));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT last_insert_rowid()"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (NS_WARN_IF(!hasMoreData)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageGetCacheId(mozIStorageConnection* aConn, Namespace aNamespace,
+                            const nsAString& aKey, bool* aFoundCacheOut,
+                            CacheId* aCacheIdOut)
+{
+  MOZ_ASSERT(aConn);
+  MOZ_ASSERT(aFoundCacheOut);
+  MOZ_ASSERT(aCacheIdOut);
+
+  *aFoundCacheOut = false;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT cache_id FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!hasMoreData) {
+    return NS_OK;
+  }
+
+  rv = state->GetInt32(0, aCacheIdOut);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  *aFoundCacheOut = true;
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StoragePutCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                          const nsAString& aKey, CacheId aCacheId)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO storage (namespace, key, cache_id) VALUES(?1, ?2, ?3);"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(2, aCacheId);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageForgetCache(mozIStorageConnection* aConn, Namespace aNamespace,
+                             const nsAString& aKey)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM storage WHERE namespace=?1 AND key=?2;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringParameter(1, aKey);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+// static
+nsresult
+DBSchema::StorageGetKeys(mozIStorageConnection* aConn, Namespace aNamespace,
+                         nsTArray<nsString>& aKeysOut)
+{
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT key FROM storage WHERE namespace=?1 ORDER BY rowid;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32Parameter(0, aNamespace);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData;
+  while(NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString* key = aKeysOut.AppendElement();
+    rv = state->GetString(0, *key);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/DBSchema.h
@@ -0,0 +1,54 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_DBSchema_h
+#define mozilla_dom_cache_DBSchema_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsError.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+template<class T> class nsTArray;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class DBSchema MOZ_FINAL
+{
+public:
+  static nsresult CreateSchema(mozIStorageConnection* aConn);
+  static nsresult CreateCache(mozIStorageConnection* aConn,
+                              CacheId* aCacheIdOut);
+
+  static nsresult StorageGetCacheId(mozIStorageConnection* aConn,
+                                    Namespace aNamespace, const nsAString& aKey,
+                                    bool* aFoundCacheOut, CacheId* aCacheIdOut);
+  static nsresult StoragePutCache(mozIStorageConnection* aConn,
+                                  Namespace aNamespace, const nsAString& aKey,
+                                  CacheId aCacheId);
+  static nsresult StorageForgetCache(mozIStorageConnection* aConn,
+                                     Namespace aNamespace,
+                                     const nsAString& aKey);
+  static nsresult StorageGetKeys(mozIStorageConnection* aConn,
+                                 Namespace aNamespace,
+                                 nsTArray<nsString>& aKeysOut);
+
+
+private:
+  DBSchema() MOZ_DELETE;
+  ~DBSchema() MOZ_DELETE;
+
+  static const int32_t kLatestSchemaVersion = 1;
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_DBSchema_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.cpp
@@ -0,0 +1,474 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/Manager.h"
+
+#include "mozilla/dom/cache/DBAction.h"
+#include "mozilla/dom/cache/DBSchema.h"
+#include "mozilla/dom/cache/Types.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozStorageHelper.h"
+#include "nsAutoPtr.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::cache::DBAction;
+using mozilla::dom::cache::DBSchema;
+
+class SetupAction MOZ_FINAL : public DBAction
+{
+public:
+  SetupAction(const nsACString& aOrigin, const nsACString& aBaseDomain)
+    : DBAction(DBAction::Create, aOrigin, aBaseDomain)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    // TODO: create body directory structure
+    // TODO: init maintainance marker
+    // TODO: perform maintainance if necessary
+
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::CreateSchema(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+private:
+  virtual ~SetupAction() { }
+};
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager::Factory
+{
+private:
+  static Factory* sFactory;
+  nsTArray<Manager*> mManagerList;
+
+public:
+  static Factory& Instance()
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      sFactory = new Factory();
+    }
+    return *sFactory;
+  }
+
+  already_AddRefed<Manager> GetOrCreate(const nsACString& aOrigin,
+                                        const nsACString& aBaseDomain)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i]->Origin() == aOrigin) {
+        nsRefPtr<Manager> ref = mManagerList[i];
+        return ref.forget();
+      }
+    }
+
+    nsRefPtr<Manager> ref = new Manager(aOrigin, aBaseDomain);
+
+    mManagerList.AppendElement(ref);
+
+    return ref.forget();
+  }
+
+  void Remove(Manager* aManager)
+  {
+    mozilla::ipc::AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+
+    for (uint32_t i = 0; i < mManagerList.Length(); ++i) {
+      if (mManagerList[i] == aManager) {
+        mManagerList.RemoveElementAt(i);
+
+        if (mManagerList.Length() < 1) {
+          delete sFactory;
+          sFactory = nullptr;
+        }
+        return;
+      }
+    }
+  }
+};
+
+// static
+Manager::Factory* Manager::Factory::sFactory = nullptr;
+
+class Manager::BaseAction : public DBAction
+{
+protected:
+  BaseAction(Manager* aManager, ListenerId aListenerId, RequestId aRequestId)
+    : DBAction(DBAction::Existing, aManager->Origin(), aManager->BaseDomain())
+    , mManager(aManager)
+    , mListenerId(aListenerId)
+    , mRequestId (aRequestId)
+  { }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv)=0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
+  {
+    Listener* listener = mManager->GetListener(mListenerId);
+    if (!listener) {
+      return;
+    }
+    Complete(listener, aRv);
+  }
+
+  virtual ~BaseAction() { }
+  nsRefPtr<Manager> mManager;
+  const ListenerId mListenerId;
+  const RequestId mRequestId;
+};
+
+class Manager::StorageGetAction : public Manager::BaseAction
+{
+public:
+  StorageGetAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, Namespace aNamespace,
+                   const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheFound(false)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::StorageGetCacheId(aConn, mNamespace, mKey,
+                                       &mCacheFound, &mCacheId);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageGet(mRequestId, aRv, mCacheFound, mCacheId);
+  }
+
+protected:
+  virtual ~StorageGetAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheFound;
+  CacheId mCacheId;
+};
+
+class Manager::StorageHasAction MOZ_FINAL : public Manager::StorageGetAction
+{
+public:
+  StorageHasAction(Manager* aManager, ListenerId aListenerId,
+                   RequestId aRequestId, Namespace aNamespace,
+                   const nsAString& aKey)
+    : StorageGetAction(aManager, aListenerId, aRequestId, aNamespace, aKey)
+  { }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageHas(mRequestId, aRv, mCacheFound);
+  }
+
+private:
+  virtual ~StorageHasAction() { }
+};
+
+class Manager::StorageCreateAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageCreateAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace,
+                      const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheId(0)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    nsresult rv = DBSchema::CreateCache(aConn, &mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = DBSchema::StoragePutCache(aConn, mNamespace, mKey, mCacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageCreate(mRequestId, aRv, mCacheId);
+  }
+
+private:
+  virtual ~StorageCreateAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  CacheId mCacheId;
+};
+
+class Manager::StorageDeleteAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageDeleteAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace,
+                      const nsAString& aKey)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+    , mKey(aKey)
+    , mCacheDeleted(false)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    mozStorageTransaction trans(aConn, false,
+                                mozIStorageConnection::TRANSACTION_IMMEDIATE);
+
+    bool exists;
+    CacheId cacheId;
+    nsresult rv = DBSchema::StorageGetCacheId(aConn, mNamespace, mKey, &exists,
+                                              &cacheId);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (!exists) {
+      mCacheDeleted = false;
+      return NS_OK;
+    }
+
+    rv = DBSchema::StorageForgetCache(aConn, mNamespace, mKey);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = trans.Commit();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    mCacheDeleted = true;
+    return rv;
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    aListener->OnStorageDelete(mRequestId, aRv, mCacheDeleted);
+  }
+
+private:
+  virtual ~StorageDeleteAction() { }
+  const Namespace mNamespace;
+  const nsString mKey;
+  bool mCacheDeleted;
+};
+
+class Manager::StorageKeysAction MOZ_FINAL : public Manager::BaseAction
+{
+public:
+  StorageKeysAction(Manager* aManager, ListenerId aListenerId,
+                      RequestId aRequestId, Namespace aNamespace)
+    : BaseAction(aManager, aListenerId, aRequestId)
+    , mNamespace(aNamespace)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(nsIFile* aDBDir, mozIStorageConnection* aConn) MOZ_OVERRIDE
+  {
+    return DBSchema::StorageGetKeys(aConn, mNamespace, mKeys);
+  }
+
+  virtual void
+  Complete(Listener* aListener, nsresult aRv) MOZ_OVERRIDE
+  {
+    if (NS_FAILED(aRv)) {
+      mKeys.Clear();
+    }
+    aListener->OnStorageKeys(mRequestId, aRv, mKeys);
+  }
+
+private:
+  virtual ~StorageKeysAction() { }
+  const Namespace mNamespace;
+  nsTArray<nsString> mKeys;
+};
+
+// static
+already_AddRefed<Manager>
+Manager::ForOrigin(const nsACString& aOrigin, const nsACString& aBaseDomain)
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+  return Factory::Instance().GetOrCreate(aOrigin, aBaseDomain);
+}
+
+void
+Manager::RemoveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  mListeners.RemoveElement(aListener);
+}
+
+void
+Manager::StorageGet(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<StorageGetAction> action = new StorageGetAction(this, listenerId,
+                                                           aRequestId,
+                                                           aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageHas(Listener* aListener, RequestId aRequestId,
+                    Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<StorageHasAction> action = new StorageHasAction(this, listenerId,
+                                                           aRequestId,
+                                                           aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageCreate(Listener* aListener, RequestId aRequestId,
+                       Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<StorageCreateAction> action = new StorageCreateAction(this, listenerId,
+                                                                 aRequestId,
+                                                                 aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageDelete(Listener* aListener, RequestId aRequestId,
+                       Namespace aNamespace, const nsAString& aKey)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<StorageDeleteAction> action = new StorageDeleteAction(this, listenerId,
+                                                                 aRequestId,
+                                                                 aNamespace, aKey);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::StorageKeys(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(aListener);
+  ListenerId listenerId = SaveListener(aListener);
+  nsRefPtr<StorageKeysAction> action = new StorageKeysAction(this, listenerId,
+                                                             aRequestId,
+                                                             aNamespace);
+  CurrentContext()->Dispatch(mIOThread, action);
+}
+
+void
+Manager::RemoveContext(Context* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+  mContext = nullptr;
+}
+
+Manager::Manager(const nsACString& aOrigin, const nsACString& aBaseDomain)
+  : mOrigin(aOrigin)
+  , mBaseDomain(aBaseDomain)
+  , mContext(nullptr)
+{
+  nsresult rv = NS_NewNamedThread("DOMCacheThread",
+                                  getter_AddRefs(mIOThread));
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("Failed to spawn cache manager IO thread.");
+  }
+}
+
+Manager::~Manager()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  Factory::Instance().Remove(this);
+  if (mContext) {
+    mContext->CancelAll();
+    mContext->ClearListener();
+  }
+  mIOThread->Shutdown();
+}
+
+Context*
+Manager::CurrentContext()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  if (!mContext) {
+    nsRefPtr<Action> setupAction = new SetupAction(mOrigin, mBaseDomain);
+    mContext = new Context(this, mOrigin, mBaseDomain, setupAction);
+  }
+  return mContext;
+}
+
+Manager::ListenerId
+Manager::SaveListener(Listener* aListener)
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (mListeners[i] == aListener) {
+      return reinterpret_cast<ListenerId>(aListener);
+    }
+  }
+  mListeners.AppendElement(aListener);
+  return reinterpret_cast<ListenerId>(aListener);
+}
+
+Manager::Listener*
+Manager::GetListener(ListenerId aListenerId) const
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  for (uint32_t i = 0; i < mListeners.Length(); ++i) {
+    if (reinterpret_cast<ListenerId>(mListeners[i]) == aListenerId) {
+      return mListeners[i];
+    }
+  }
+  return nullptr;
+}
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Manager.h
@@ -0,0 +1,97 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Manager_h
+#define mozilla_dom_cache_Manager_h
+
+#include "mozilla/dom/cache/Context.h"
+#include "mozilla/dom/cache/Types.h"
+#include "nsCOMPtr.h"
+#include "nsISupportsImpl.h"
+#include "nsString.h"
+#include "nsTArray.h"
+
+class nsIThread;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class Manager MOZ_FINAL : public Context::Listener
+{
+public:
+  class Listener
+  {
+  public:
+    virtual ~Listener() { }
+    virtual void OnStorageGet(RequestId aRequestId, nsresult aRv,
+                              bool aCacheFound, CacheId aCacheId)=0;
+    virtual void OnStorageHas(RequestId aRequestId, nsresult aRv,
+                              bool aCacheFound)=0;
+    virtual void OnStorageCreate(RequestId aRequestId, nsresult aRv,
+                                 CacheId aCacheId)=0;
+    virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
+                                 bool aCacheDeleted)=0;
+    virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
+                               const nsTArray<nsString>& aKeys)=0;
+  };
+
+  static already_AddRefed<Manager> ForOrigin(const nsACString& aOrigin,
+                                             const nsACString& aBaseDomain);
+
+  void RemoveListener(Listener* aListener);
+
+  void StorageGet(Listener* aListener, RequestId aRequestId,
+                  Namespace aNamespace, const nsAString& aKey);
+  void StorageHas(Listener* aListener, RequestId aRequestId,
+                  Namespace aNamespace, const nsAString& aKey);
+  void StorageCreate(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey);
+  void StorageDelete(Listener* aListener, RequestId aRequestId,
+                     Namespace aNamespace, const nsAString& aKey);
+  void StorageKeys(Listener* aListener, RequestId aRequestId,
+                   Namespace aNamespace);
+
+  const nsCString& Origin() const { return mOrigin; }
+  const nsCString& BaseDomain() const { return mBaseDomain; }
+
+  // Context::Listener methods
+  virtual void RemoveContext(Context* aContext) MOZ_OVERRIDE;
+
+private:
+  class Factory;
+  class BaseAction;
+  class StorageGetAction;
+  class StorageHasAction;
+  class StorageCreateAction;
+  class StorageDeleteAction;
+  class StorageKeysAction;
+  typedef uintptr_t ListenerId;
+
+  Manager(const nsACString& aOrigin, const nsACString& aBaseDomain);
+  ~Manager();
+  Context* CurrentContext();
+
+  ListenerId SaveListener(Listener* aListener);
+  Listener* GetListener(ListenerId aListenerId) const;
+
+  const nsCString mOrigin;
+  const nsCString mBaseDomain;
+  nsCOMPtr<nsIThread> mIOThread;
+  nsTArray<Listener*> mListeners;
+
+  // weak ref as Context destructor clears this pointer
+  Context* mContext;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::Manager)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include PCacheQueryParams;
 include PCacheRequest;
 include PCacheResponse;
 
-using mozilla::dom::cache::RequestId from "mozilla/dom/CacheTypes.h";
+using mozilla::dom::cache::RequestId from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace dom {
 
 protocol PCache
 {
   manager PBackground;
 
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/Types.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_Types_h
+#define mozilla_dom_cache_Types_h
+
+#include <stdint.h>
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+enum Namespace
+{
+  DEFAULT_NAMESPACE,
+  CHROME_ONLY_NAMESPACE,
+  NUMBER_OF_NAMESPACES
+};
+
+typedef uintptr_t RequestId;
+static const RequestId INVALID_REQUEST_ID = 0;
+
+typedef int32_t CacheId;
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -12,35 +12,43 @@ EXPORTS.mozilla.dom += [
     'CacheDBListener.h',
     'CacheDBSchema.h',
     'CacheIPCUtils.h',
     'CacheParent.h',
     'CacheQuotaRunnable.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
-    'CacheStorageDBConnection.h',
-    'CacheStorageDBListener.h',
-    'CacheStorageDBSchema.h',
     'CacheStorageParent.h',
-    'CacheTypes.h',
 ]
 
-UNIFIED_SOURCES += [
+EXPORTS.mozilla.dom.cache += [
+    'Action.h',
+    'Context.h',
+    'DBAction.h',
+    'DBSchema.h',
+    'Manager.h',
+    'Types.h',
+]
+
+SOURCES += [
+    'Action.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheDBConnection.cpp',
     'CacheDBSchema.cpp',
     'CacheParent.cpp',
     'CacheQuotaRunnable.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
-    'CacheStorageDBConnection.cpp',
-    'CacheStorageDBSchema.cpp',
     'CacheStorageParent.cpp',
+    'Context.cpp',
+    'DBAction.cpp',
+    'DBSchema.cpp',
+    'Manager.cpp',
 ]
 
 IPDL_SOURCES += [
     'PCache.ipdl',
     'PCacheQueryParams.ipdlh',
     'PCacheRequest.ipdlh',
     'PCacheResponse.ipdlh',
     'PCacheStorage.ipdl',
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -2,17 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundTest;
 include protocol PCacheStorage;
 include protocol PCache;
 include protocol PMessagePort;
 
-using mozilla::dom::cache::Namespace from "mozilla/dom/CacheTypes.h";
+using mozilla::dom::cache::Namespace from "mozilla/dom/cache/Types.h";
 
 namespace mozilla {
 namespace ipc {
 
 protocol PBackground
 {
   manages PBackgroundTest;
   manages PCacheStorage;
