# HG changeset patch
# Parent 4e88a78e18dd84d22744346668da5b31d1050dfa
# User Ben Kelly <ben@wanderview.com>
try: -b d -p emulator -u mochitests -t none

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -32,16 +32,18 @@
 #include "mozilla/Assertions.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/dom/Exceptions.h"
 #include "Principal.h"
 #include "WorkerFeature.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
+#include "nsSandboxFlags.h"
+
 #define MAX_CONCURRENT_SCRIPTS 1000
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::dom::workers::exceptions::ThrowDOMExceptionForNSResult;
 
 namespace {
 
@@ -101,19 +103,35 @@ ChannelFromScriptURL(nsIPrincipal* princ
   }
   else {
     rv = secMan->CheckLoadURIWithPrincipal(principal, uri, 0);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
 
   uint32_t flags = nsIRequest::LOAD_NORMAL | nsIChannel::LOAD_CLASSIFY_URI;
 
+  nsAutoCString spec;
+  uri->GetAsciiSpec(spec);
+  printf_stderr("### ### Create worker channel with doc:%p for URI:%s\n",
+                parentDoc, spec.get());
+
   nsCOMPtr<nsIChannel> channel;
   // If we have the document, use it
   if (parentDoc) {
+    nsCOMPtr<nsIPrincipal> nodePrincipal = parentDoc->NodePrincipal();
+    if (!NS_LoadGroupMatchesPrincipal(loadGroup, nodePrincipal)) {
+      printf_stderr("### ### parent doc node principal does not match provided load group!\n");
+      nsCOMPtr<nsILoadGroup> docLoadGroup = parentDoc->GetDocumentLoadGroup();
+      if (!NS_LoadGroupMatchesPrincipal(docLoadGroup, nodePrincipal)) {
+        printf_stderr("### ### parent doc node principal does not match parent doc load group either!\n");
+      }
+    }
+    if (parentDoc->GetSandboxFlags() & SANDBOXED_ORIGIN) {
+      printf_stderr("### ### parent doc has SANDBOXED_ORIGIN flag set\n");
+    }
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        parentDoc,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
                        nullptr, // aCallbacks
                        flags,
@@ -510,29 +528,67 @@ private:
       rv = ssm->GetChannelResultPrincipal(channel, getter_AddRefs(channelPrincipal));
       NS_ENSURE_SUCCESS(rv, rv);
 
       nsCOMPtr<nsILoadGroup> channelLoadGroup;
       rv = channel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
       NS_ENSURE_SUCCESS(rv, rv);
       MOZ_ASSERT(channelLoadGroup);
 
+      nsCOMPtr<nsIInterfaceRequestor> callbacks;
+      rv = channel->GetNotificationCallbacks(getter_AddRefs(callbacks));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      nsCOMPtr<nsILoadContext> context = do_QueryInterface(callbacks);
+      if (callbacks || context) {
+        printf_stderr("### ### got channel specific callbacks:%p context:%p\n",
+                      callbacks.get(), context.get());
+      }
+
+      nsCOMPtr<nsILoadInfo> loadInfo;
+      channel->GetLoadInfo(getter_AddRefs(loadInfo));
+      if (loadInfo) {
+        printf_stderr("### ### channel has load info with sandboxed:%s force inherit:%s\n",
+                      (loadInfo->GetLoadingSandboxed() ? "true" : "false"),
+                      (loadInfo->GetForceInheritPrincipal() ? " true" : "false"));
+      }
+
+      nsCOMPtr<nsISupports> owner;
+      channel->GetOwner(getter_AddRefs(owner));
+      nsCOMPtr<nsIPrincipal> ownerPrincipal = do_QueryInterface(owner);
+      if (owner || ownerPrincipal) {
+        printf_stderr("### ### channel has owner:%p owner principal:%p\n",
+                      owner.get(), ownerPrincipal.get());
+        if (ownerPrincipal &&
+            !NS_LoadGroupMatchesPrincipal(channelLoadGroup, ownerPrincipal)) {
+          printf_stderr("### ### owner principal does not match load group\n");
+        }
+      }
+
+      if (!NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal)) {
+        printf_stderr("### ### initial channel load group and principal do not match!\n");
+      }
+
       // See if this is a resource URI. Since JSMs usually come from resource://
       // URIs we're currently considering all URIs with the URI_IS_UI_RESOURCE
       // flag as valid for creating privileged workers.
       if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
         bool isResource;
         rv = NS_URIChainHasFlags(finalURI,
                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
                                  &isResource);
         NS_ENSURE_SUCCESS(rv, rv);
 
         if (isResource) {
           rv = ssm->GetSystemPrincipal(getter_AddRefs(channelPrincipal));
           NS_ENSURE_SUCCESS(rv, rv);
+
+          if (!NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal)) {
+            printf_stderr("### ### resource switched to system principal and no longer matches load group\n");
+          }
         }
       }
 
       // If the load principal is the system principal then the channel
       // principal must also be the system principal (we do not allow chrome
       // code to create workers with non-chrome scripts). Otherwise this channel
       // principal must be same origin with the load principal (we check again
       // here in case redirects changed the location of the script).
diff --git a/netwerk/base/src/nsNetUtil.cpp b/netwerk/base/src/nsNetUtil.cpp
--- a/netwerk/base/src/nsNetUtil.cpp
+++ b/netwerk/base/src/nsNetUtil.cpp
@@ -59,11 +59,27 @@ NS_LoadGroupMatchesPrincipal(nsILoadGrou
 
     uint32_t principalAppId;
     bool principalInBrowserElement;
     rv = aPrincipal->GetAppId(&principalAppId);
     NS_ENSURE_SUCCESS(rv, false);
     rv = aPrincipal->GetIsInBrowserElement(&principalInBrowserElement);
     NS_ENSURE_SUCCESS(rv, false);
 
-    return contextAppId == principalAppId &&
+    bool rtn = contextAppId == principalAppId &&
            contextInBrowserElement == principalInBrowserElement;
+    if (!rtn) {
+      nsCOMPtr<nsIURI> uri;
+      aPrincipal->GetURI(getter_AddRefs(uri));
+
+      nsAutoCString spec;
+      if (uri) {
+        uri->GetAsciiSpec(spec);
+      }
+
+      printf_stderr("### ### context[appId:%u browser:%s] "
+                    "principal[appId:%u browser:%s] uri:%s\n",
+                    contextAppId, (contextInBrowserElement ? "true" : "false"),
+                    principalAppId, (principalInBrowserElement ? "true" : "false"),
+                    spec.get());
+    }
+    return rtn;
 }
