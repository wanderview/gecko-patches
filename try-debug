# HG changeset patch
# Parent 606848e8adfc4993ee9ed70bee27a439ad556561
# User Ben Kelly <ben@wanderview.com>
try: -b d -p emulator -u mochitests -t none

diff --git a/ipc/glue/BackgroundImpl.cpp b/ipc/glue/BackgroundImpl.cpp
--- a/ipc/glue/BackgroundImpl.cpp
+++ b/ipc/glue/BackgroundImpl.cpp
@@ -29,16 +29,18 @@
 #include "nsIThread.h"
 #include "nsITimer.h"
 #include "nsTArray.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 #include "nsXPCOMPrivate.h"
 #include "prthread.h"
+#include <sys/syscall.h>
+#include <unistd.h>
 
 #ifdef RELEASE_BUILD
 #define THREADSAFETY_ASSERT MOZ_ASSERT
 #else
 #define THREADSAFETY_ASSERT MOZ_RELEASE_ASSERT
 #endif
 
 #define CRASH_IN_CHILD_PROCESS(_msg)                                           \
@@ -372,16 +374,18 @@ public:
     THREADSAFETY_ASSERT(
       NS_SUCCEEDED(mBoundThread->IsOnCurrentThread(&current)));
     THREADSAFETY_ASSERT(current);
   }
 
   void
   AssertActorDestroyed()
   {
+    printf_stderr("### ### [%d][%d][%p] AssertActorDestroyed(): %s\n",
+                  getpid(), syscall(__NR_gettid), this, (mActorDestroyed ? "true" : "false"));
     MOZ_ASSERT(mActorDestroyed, "ChildImpl::ActorDestroy not called in time");
   }
 
   ChildImpl()
   : mBoundThread(nullptr)
   , mActorDestroyed(false)
   {
     AssertIsOnMainThread();
@@ -417,16 +421,18 @@ private:
   static void
   ThreadLocalDestructor(void* aThreadLocal)
   {
     auto threadLocalInfo = static_cast<ThreadLocalInfo*>(aThreadLocal);
 
     if (threadLocalInfo) {
       if (threadLocalInfo->mActor) {
         threadLocalInfo->mActor->Close();
+        printf_stderr("### ### [%d][%d] ThreadLocalDestructor() mActor:%p\n",
+                      getpid(), syscall(__NR_gettid), threadLocalInfo->mActor.get());
         threadLocalInfo->mActor->AssertActorDestroyed();
         // Since the actor is created on the main thread it must only
         // be released on the main thread as well.
         if (!NS_IsMainThread()) {
           ChildImpl* actor;
           threadLocalInfo->mActor.forget(&actor);
 
           nsCOMPtr<nsIRunnable> releaser =
@@ -439,17 +445,22 @@ private:
   }
 
   static void
   DispatchFailureCallback(nsIEventTarget* aEventTarget);
 
   // This class is reference counted.
   ~ChildImpl()
   {
-    AssertActorDestroyed();
+    printf_stderr("### ### [%d][%d][%p] ChildImpl::~ChildImpl(): shutdown:%s\n",
+                  getpid(), syscall(__NR_gettid), this,
+                  (sShutdownHasStarted ? "true" : "false"));
+    if (!sShutdownHasStarted) {
+      AssertActorDestroyed();
+    }
   }
 
   void
   SetBoundThread()
   {
     THREADSAFETY_ASSERT(!mBoundThread);
 
 #if defined(DEBUG) || !defined(RELEASE_BUILD)
@@ -1555,16 +1566,18 @@ ChildImpl::Shutdown()
   if (sShutdownHasStarted) {
     MOZ_ASSERT_IF(sThreadLocalIndex != kBadThreadLocalIndex,
                   !PR_GetThreadPrivate(sThreadLocalIndex));
     return;
   }
 
   sShutdownHasStarted = true;
 
+  printf_stderr("### ### [%d][%d] Shutdown()\n",
+                getpid(), syscall(__NR_gettid));
   MOZ_ASSERT(sThreadLocalIndex != kBadThreadLocalIndex);
 
   DebugOnly<PRStatus> status = PR_SetThreadPrivate(sThreadLocalIndex, nullptr);
   MOZ_ASSERT(status == PR_SUCCESS);
 }
 
 // static
 PBackgroundChild*
@@ -1692,16 +1705,19 @@ ChildImpl::CloseForCurrentThread()
   //   1) Startup has not completed and we are racing
   //   2) We were called again after a previous close or shutdown
   // For now, these should not happen, so crash.  We can add extra complexity
   // in the future if it turns out we need to support these cases.
   if (!threadLocalInfo) {
     MOZ_CRASH("Attempting to close a non-existent PBackground actor!");
   }
 
+  printf_stderr("### ### [%d][%d][%p] CloseForCurrentThread()\n",
+                getpid(), syscall(__NR_gettid), threadLocalInfo->mActor.get());
+
   if (threadLocalInfo->mActor) {
     threadLocalInfo->mActor->FlushPendingInterruptQueue();
   }
   DebugOnly<PRStatus> status = PR_SetThreadPrivate(sThreadLocalIndex, nullptr);
   MOZ_ASSERT(status == PR_SUCCESS);
 }
 
 // static
@@ -1955,16 +1971,19 @@ ChildImpl::OpenProtocolOnMainThread(nsIE
   AssertIsOnMainThread();
   MOZ_ASSERT(aEventTarget);
 
   if (sShutdownHasStarted) {
     MOZ_CRASH("Called BackgroundChild::GetOrCreateForCurrentThread after "
               "shutdown has started!");
   }
 
+  printf_stderr("### ### [%d][%d] OpenProtocolOnMainThread()\n",
+                getpid(), syscall(__NR_gettid));
+
   if (IsMainProcess()) {
     nsRefPtr<ParentImpl::CreateCallback> parentCallback =
       new ParentCreateCallback(aEventTarget);
 
     if (!ParentImpl::CreateActorForSameProcess(parentCallback)) {
       NS_WARNING("BackgroundParent::CreateActor() failed!");
       DispatchFailureCallback(aEventTarget);
       return false;
@@ -2003,16 +2022,18 @@ ChildImpl::DispatchFailureCallback(nsIEv
   }
 }
 
 void
 ChildImpl::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBoundThread();
 
+  printf_stderr("### ### [%d][%d][%p] ActorDestroy(): %s => true\n",
+                getpid(), syscall(__NR_gettid), this, (mActorDestroyed ? "true" : "false"));
   mActorDestroyed = true;
   BackgroundChildImpl::ActorDestroy(aWhy);
 }
 
 NS_IMPL_ISUPPORTS(ChildImpl::ShutdownObserver, nsIObserver)
 
 NS_IMETHODIMP
 ChildImpl::ShutdownObserver::Observe(nsISupports* aSubject,
diff --git a/ipc/glue/MessageChannel.cpp b/ipc/glue/MessageChannel.cpp
--- a/ipc/glue/MessageChannel.cpp
+++ b/ipc/glue/MessageChannel.cpp
@@ -1653,24 +1653,27 @@ MessageChannel::Close()
             // IO thread's NotifyChannelError event is still enqueued
             // and subsequently deletes us, then the error event will
             // also be deleted and the listener will never be notified
             // of the channel error.
             if (mListener) {
                 MonitorAutoUnlock unlock(*mMonitor);
                 NotifyMaybeChannelError();
             }
+            printf_stderr("### ### MessageChannel::Close() return early due to %s\n",
+                          (ChannelError == mChannelState ? "error" : "timeout"));
             return;
         }
 
         if (ChannelOpening == mChannelState) {
             // Mimic CloseWithError().
             SynchronouslyClose();
             mChannelState = ChannelError;
             PostErrorNotifyTask();
+            printf_stderr("### ### MessageChannel::Close() return early due to opening\n");
             return;
         }
 
         if (ChannelConnected != mChannelState) {
             // XXX be strict about this until there's a compelling reason
             // to relax
             NS_RUNTIMEABORT("Close() called on closed channel!");
         }
