# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8db77334aa512500e7ae1b01a7174f36219d695f
Bug 1459209 P5 Scaffold a ServiceWorkerProxy class to connect the parent actor to the main thread SWM. r=baku

diff --git a/dom/serviceworkers/ServiceWorkerParent.cpp b/dom/serviceworkers/ServiceWorkerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerParent.cpp
@@ -1,34 +1,60 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerParent.h"
 
+#include "ServiceWorkerProxy.h"
+
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::IPCResult;
 
 void
 ServiceWorkerParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  // TODO
+  if (mProxy) {
+    mProxy->RevokeActor(this);
+    mProxy = nullptr;
+  }
 }
 
 IPCResult
 ServiceWorkerParent::RecvTeardown()
 {
-  // TODO
+  MaybeSendDelete();
   return IPC_OK();
 }
 
+ServiceWorkerParent::ServiceWorkerParent()
+  : mDeleteSent(false)
+{
+}
+
+ServiceWorkerParent::~ServiceWorkerParent()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mProxy);
+}
+
 void
 ServiceWorkerParent::Init(const IPCServiceWorkerDescriptor& aDescriptor)
 {
-  // TODO
+  MOZ_DIAGNOSTIC_ASSERT(!mProxy);
+  mProxy = new ServiceWorkerProxy(this, ServiceWorkerDescriptor(aDescriptor));
+}
+
+void
+ServiceWorkerParent::MaybeSendDelete()
+{
+  if (mDeleteSent) {
+    return;
+  }
+  mDeleteSent = true;
+  Unused << Send__delete__(this);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerParent.h b/dom/serviceworkers/ServiceWorkerParent.h
--- a/dom/serviceworkers/ServiceWorkerParent.h
+++ b/dom/serviceworkers/ServiceWorkerParent.h
@@ -8,30 +8,37 @@
 #define mozilla_dom_serviceworkerparent_h__
 
 #include "mozilla/dom/PServiceWorkerParent.h"
 
 namespace mozilla {
 namespace dom {
 
 class IPCServiceWorkerDescriptor;
+class ServiceWorkerProxy;
 
 class ServiceWorkerParent final : public PServiceWorkerParent
 {
+  RefPtr<ServiceWorkerProxy> mProxy;
+  bool mDeleteSent;
+
   // PServiceWorkerParent
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
 public:
-  ServiceWorkerParent() = default;
-  ~ServiceWorkerParent() = default;
+  ServiceWorkerParent();
+  ~ServiceWorkerParent();
 
   void
   Init(const IPCServiceWorkerDescriptor& aDescriptor);
+
+  void
+  MaybeSendDelete();
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_serviceworkerparent_h__
diff --git a/dom/serviceworkers/ServiceWorkerProxy.cpp b/dom/serviceworkers/ServiceWorkerProxy.cpp
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerProxy.cpp
@@ -0,0 +1,148 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ServiceWorkerProxy.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+ServiceWorkerProxy::~ServiceWorkerProxy()
+{
+  // Any thread
+  MOZ_DIAGNOSTIC_ASSERT(!mActor);
+  MOZ_DIAGNOSTIC_ASSERT(!mInfo);
+}
+
+void
+ServiceWorkerProxy::MaybeShutdownOnBGThread()
+{
+  AssertIsOnBackgroundThread();
+  if (!mActor) {
+    return;
+  }
+  mActor->MaybeSendDelete();
+}
+
+void
+ServiceWorkerProxy::SetStateOnBGThread(ServiceWorkerState aState)
+{
+  AssertIsOnBackgroundThread();
+  if (!mActor) {
+    return;
+  }
+  // TODO send the state
+}
+
+void
+ServiceWorkerProxy::InitOnMainThread()
+{
+  AssertIsOnMainThread();
+
+  auto scopeExit = MakeScopeExit([&] {
+    // If we can't find the service worker, then move the binding object
+    // to the redundant state automatically.
+    SetState(ServiceWorkerState::Redundant);
+    MaybeShutdownOnMainThread();
+  });
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  NS_ENSURE_TRUE_VOID(swm);
+
+  RefPtr<ServiceWorkerRegistrationInfo> reg =
+    swm->GetRegistration(mDescriptor.PrincipalInfo(), mDescriptor.Scope());
+  NS_ENSURE_TRUE_VOID(reg);
+
+  RefPtr<ServiceWorkerInfo> info = reg->GetByDescriptor(mDescriptor);
+  NS_ENSURE_TRUE_VOID(info);
+
+  scopeExit.release();
+
+  mInfo = new nsMainThreadPtrHolder<ServiceWorkerInfo>("ServiceWorkerProxy::mInfo",
+                                                       info);
+
+  // The ServiceWorkerInfo will automatically update our state when we
+  // add ourself as a listener.
+  mInfo->AddListener(this);
+}
+
+void
+ServiceWorkerProxy::MaybeShutdownOnMainThread()
+{
+  AssertIsOnMainThread();
+
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod(__func__, this,
+                      &ServiceWorkerProxy::MaybeShutdownOnBGThread);
+
+  MOZ_ALWAYS_SUCCEEDS(mEventTarget->Dispatch(r.forget(), NS_DISPATCH_NORMAL));
+}
+
+void
+ServiceWorkerProxy::StopListeningOnMainThread()
+{
+  AssertIsOnMainThread();
+
+  if (!mInfo) {
+    return;
+  }
+
+  mInfo->RemoveListener(this);
+  mInfo = nullptr;
+}
+
+void
+ServiceWorkerProxy::SetState(ServiceWorkerState aState)
+{
+  AssertIsOnMainThread();
+
+  if (mDescriptor.State() == aState) {
+    return;
+  }
+  mDescriptor.SetState(aState);
+
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod<ServiceWorkerState>(__func__, this,
+                                          &ServiceWorkerProxy::SetStateOnBGThread,
+                                          aState);
+
+  MOZ_ALWAYS_SUCCEEDS(mEventTarget->Dispatch(r.forget(), NS_DISPATCH_NORMAL));
+}
+
+ServiceWorkerProxy::ServiceWorkerProxy(ServiceWorkerParent* aActor,
+                                       const ServiceWorkerDescriptor& aDescriptor)
+  : mActor(aActor)
+  , mEventTarget(GetCurrentThreadSerialEventTarget())
+  , mDescriptor(aDescriptor)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mEventTarget);
+
+  nsCOMPtr<nsIRunnable> r = NewRunnableMethod("ServiceWorkerProxy::Init", this,
+                                              &ServiceWorkerProxy::InitOnMainThread);
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+}
+
+void
+ServiceWorkerProxy::RevokeActor(ServiceWorkerParent* aActor)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_DIAGNOSTIC_ASSERT(mActor);
+  MOZ_DIAGNOSTIC_ASSERT(mActor == aActor);
+  mActor = nullptr;
+
+  nsCOMPtr<nsIRunnable> r =
+    NewRunnableMethod(__func__, this,
+                      &ServiceWorkerProxy::StopListeningOnMainThread);
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerProxy.h b/dom/serviceworkers/ServiceWorkerProxy.h
new file mode 100644
--- /dev/null
+++ b/dom/serviceworkers/ServiceWorkerProxy.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef moz_dom_ServiceWorkerProxy_h
+#define moz_dom_ServiceWorkerProxy_h
+
+#include "nsProxyRelease.h"
+#include "ServiceWorkerDescriptor.h"
+#include "ServiceWorkerInfo.h"
+
+namespace mozilla {
+namespace dom {
+
+class ServiceWorkerInfo;
+class ServiceWorkerParent;
+
+class ServiceWorkerProxy final : public ServiceWorkerInfo::Listener
+{
+  // Background thread only
+  ServiceWorkerParent* mActor;
+
+  // Written on background thread and read on main thread
+  nsCOMPtr<nsISerialEventTarget> mEventTarget;
+
+  // Main thread only
+  ServiceWorkerDescriptor mDescriptor;
+  nsMainThreadPtrHandle<ServiceWorkerInfo> mInfo;
+
+  ~ServiceWorkerProxy();
+
+  // Background thread methods
+  void
+  MaybeShutdownOnBGThread();
+
+  void
+  SetStateOnBGThread(ServiceWorkerState aState);
+
+  // Main thread methods
+  void
+  InitOnMainThread();
+
+  void
+  MaybeShutdownOnMainThread();
+
+  void
+  StopListeningOnMainThread();
+
+  // ServiceWorkerInfo::Listener interface
+  void
+  SetState(ServiceWorkerState aState) override;
+
+public:
+  ServiceWorkerProxy(ServiceWorkerParent* aActor,
+                     const ServiceWorkerDescriptor& aDescriptor);
+
+  void
+  RevokeActor(ServiceWorkerParent* aActor);
+
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ServiceWorkerProxy, override);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // moz_dom_ServiceWorkerProxy_h
diff --git a/dom/serviceworkers/moz.build b/dom/serviceworkers/moz.build
--- a/dom/serviceworkers/moz.build
+++ b/dom/serviceworkers/moz.build
@@ -47,16 +47,17 @@ UNIFIED_SOURCES += [
     'ServiceWorkerJob.cpp',
     'ServiceWorkerJobQueue.cpp',
     'ServiceWorkerManager.cpp',
     'ServiceWorkerManagerChild.cpp',
     'ServiceWorkerManagerParent.cpp',
     'ServiceWorkerManagerService.cpp',
     'ServiceWorkerParent.cpp',
     'ServiceWorkerPrivate.cpp',
+    'ServiceWorkerProxy.cpp',
     'ServiceWorkerRegisterJob.cpp',
     'ServiceWorkerRegistrar.cpp',
     'ServiceWorkerRegistration.cpp',
     'ServiceWorkerRegistrationChild.cpp',
     'ServiceWorkerRegistrationDescriptor.cpp',
     'ServiceWorkerRegistrationImpl.cpp',
     'ServiceWorkerRegistrationInfo.cpp',
     'ServiceWorkerRegistrationParent.cpp',
