# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8fda04398a32ff69ab886cb817579760636b1e12
Bug 1424338 P1 Implement ClientManager::MatchAll() to support clients.matchAll() WebAPI. r=baku

diff --git a/dom/clients/manager/ClientIPCTypes.ipdlh b/dom/clients/manager/ClientIPCTypes.ipdlh
--- a/dom/clients/manager/ClientIPCTypes.ipdlh
+++ b/dom/clients/manager/ClientIPCTypes.ipdlh
@@ -62,36 +62,56 @@ struct ClientSourceExecutionReadyArgs
   FrameType frameType;
 };
 
 struct ClientControlledArgs
 {
   IPCServiceWorkerDescriptor serviceWorker;
 };
 
+union ClientEndPoint
+{
+  IPCClientInfo;
+  IPCServiceWorkerDescriptor;
+};
+
+struct ClientMatchAllArgs
+{
+  ClientEndPoint endpoint;
+  ClientType type;
+  bool includeUncontrolled;
+};
+
 struct ClientGetInfoAndStateArgs
 {
   nsID id;
   PrincipalInfo principalInfo;
 };
 
 struct ClientOpenWindowArgs
 {
 };
 
 union ClientOpConstructorArgs
 {
   ClientControlledArgs;
+  ClientMatchAllArgs;
   ClientGetInfoAndStateArgs;
 };
 
+struct ClientList
+{
+  ClientInfoAndState[] values;
+};
+
 struct ClientNavigateOpConstructorArgs
 {
 };
 
 union ClientOpResult
 {
   nsresult;
   ClientInfoAndState;
+  ClientList;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -254,16 +254,25 @@ ClientManager::CreateHandle(const Client
                             nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->CreateHandleInternal(aClientInfo, aSerialEventTarget);
 }
 
 // static
 RefPtr<ClientOpPromise>
+ClientManager::MatchAll(const ClientMatchAllArgs& aArgs,
+                        nsISerialEventTarget* aSerialEventTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aSerialEventTarget);
+}
+
+// static
+RefPtr<ClientOpPromise>
 ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
                                nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->StartOp(aArgs, aSerialEventTarget);
 }
 
 } // namespace dom
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -17,16 +17,17 @@ class PBackgroundChild;
 class PrincipalInfo;
 } // namespace ipc
 namespace dom {
 
 class ClientGetInfoAndStateArgs;
 class ClientHandle;
 class ClientInfo;
 class ClientManagerChild;
+class ClientMatchAllArgs;
 class ClientOpConstructorArgs;
 class ClientSource;
 enum class ClientType : uint8_t;
 
 namespace workers {
 class WorkerPrivate;
 } // workers namespace
 
@@ -90,16 +91,19 @@ public:
   CreateSource(ClientType aType, nsISerialEventTarget* aEventTarget,
                const mozilla::ipc::PrincipalInfo& aPrincipal);
 
   static already_AddRefed<ClientHandle>
   CreateHandle(const ClientInfo& aClientInfo,
                nsISerialEventTarget* aSerialEventTarget);
 
   static RefPtr<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs, nsISerialEventTarget* aTarget);
+
+  static RefPtr<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
                   nsISerialEventTarget* aSerialEventTarget);
 
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -43,16 +43,22 @@ ClientManagerOpParent::ClientManagerOpPa
 {
   MOZ_DIAGNOSTIC_ASSERT(mService);
 }
 
 void
 ClientManagerOpParent::Init(const ClientOpConstructorArgs& aArgs)
 {
   switch (aArgs.type()) {
+    case ClientOpConstructorArgs::TClientMatchAllArgs:
+    {
+      DoServiceOp(&ClientManagerService::MatchAll,
+                  aArgs.get_ClientMatchAllArgs());
+      break;
+    }
     case ClientOpConstructorArgs::TClientGetInfoAndStateArgs:
     {
       DoServiceOp(&ClientManagerService::GetInfoAndState,
                   aArgs.get_ClientGetInfoAndStateArgs());
       break;
     }
     default:
     {
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -297,16 +297,161 @@ void
 ClientManagerService::RemoveManager(ClientManagerParent* aManager)
 {
   AssertIsOnBackgroundThread();
   MOZ_DIAGNOSTIC_ASSERT(aManager);
   DebugOnly<bool> removed = mManagerList.RemoveElement(aManager);
   MOZ_ASSERT(removed);
 }
 
+namespace
+{
+
+class PromiseListHolder final
+{
+  RefPtr<ClientOpPromise::Private> mResultPromise;
+  nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
+  nsTArray<ClientInfoAndState> mResultList;
+  uint32_t mOutstandingPromiseCount;
+
+  void
+  ProcessSuccess(const ClientInfoAndState& aResult)
+  {
+    mResultList.AppendElement(aResult);
+    ProcessCompletion();
+  }
+
+  void
+  ProcessCompletion()
+  {
+    MOZ_DIAGNOSTIC_ASSERT(mOutstandingPromiseCount > 0);
+    mOutstandingPromiseCount -= 1;
+    MaybeFinish();
+  }
+
+  ~PromiseListHolder() = default;
+public:
+  PromiseListHolder()
+    : mResultPromise(new ClientOpPromise::Private(__func__))
+    , mOutstandingPromiseCount(0)
+  {
+  }
+
+  already_AddRefed<ClientOpPromise>
+  GetResultPromise()
+  {
+    RefPtr<PromiseListHolder> kungFuDeathGrip = this;
+    mResultPromise->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
+      [kungFuDeathGrip] (const ClientOpResult& aResult) { },
+      [kungFuDeathGrip] (nsresult aResult) { });
+
+    RefPtr<ClientOpPromise> ref = mResultPromise;
+    return ref.forget();
+  }
+
+  void
+  AddPromise(RefPtr<ClientOpPromise>&& aPromise)
+  {
+    mPromiseList.AppendElement(Move(aPromise));
+    MOZ_DIAGNOSTIC_ASSERT(mPromiseList.LastElement());
+    mOutstandingPromiseCount += 1;
+
+    RefPtr<PromiseListHolder> self(this);
+    mPromiseList.LastElement()->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
+      [self] (const ClientOpResult& aResult) {
+        // TODO: This is pretty clunky.  Try to figure out a better
+        //       wait for MatchAll() and Claim() to share this code
+        //       even though they expect different return values.
+        if (aResult.type() == ClientOpResult::TClientInfoAndState) {
+          self->ProcessSuccess(aResult.get_ClientInfoAndState());
+        } else {
+          self->ProcessCompletion();
+        }
+      }, [self] (nsresult aResult) {
+        self->ProcessCompletion();
+      });
+  }
+
+  void
+  MaybeFinish()
+  {
+    if (!mOutstandingPromiseCount) {
+      mResultPromise->Resolve(mResultList, __func__);
+    }
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(PromiseListHolder)
+};
+
+} // anonymous namespace
+
+RefPtr<ClientOpPromise>
+ClientManagerService::MatchAll(const ClientMatchAllArgs& aArgs)
+{
+  AssertIsOnBackgroundThread();
+
+  const ClientEndPoint& endpoint = aArgs.endpoint();
+
+  const PrincipalInfo& principalInfo =
+    endpoint.type() == ClientEndPoint::TIPCClientInfo
+      ? endpoint.get_IPCClientInfo().principalInfo()
+      : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
+
+  RefPtr<PromiseListHolder> promiseList = new PromiseListHolder();
+
+  for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
+    ClientSourceParent* source = iter.UserData();
+    MOZ_DIAGNOSTIC_ASSERT(source);
+
+    if (source->IsFrozen() || !source->ExecutionReady()) {
+      continue;
+    }
+
+    if (aArgs.type() != ClientType::All &&
+        source->Info().Type() != aArgs.type()) {
+      continue;
+    }
+
+    if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), principalInfo)) {
+      continue;
+    }
+
+    if (!aArgs.includeUncontrolled()) {
+      if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
+        continue;
+      }
+
+      const Maybe<ServiceWorkerDescriptor>& controller =
+        source->GetController();
+      if (controller.isNothing()) {
+        continue;
+      }
+
+      const IPCServiceWorkerDescriptor& serviceWorker =
+        endpoint.get_IPCServiceWorkerDescriptor();
+
+      if(controller.ref().Id() != serviceWorker.id() ||
+         controller.ref().Scope() != serviceWorker.scope()) {
+        continue;
+      }
+    }
+
+    promiseList->AddPromise(
+      source->StartOp(Move(ClientGetInfoAndStateArgs(source->Info().Id(),
+                                                     source->Info().PrincipalInfo()))));
+  }
+
+  // Maybe finish the promise now in case we didn't find any matching clients.
+  promiseList->MaybeFinish();
+
+  return promiseList->GetResultPromise();
+}
+
 RefPtr<ClientOpPromise>
 ClientManagerService::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref;
 
   ClientSourceParent* source = FindSource(aArgs.id(), aArgs.principalInfo());
   if (!source || !source->ExecutionReady()) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_FAILURE, __func__);
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -55,16 +55,19 @@ public:
 
   void
   AddManager(ClientManagerParent* aManager);
 
   void
   RemoveManager(ClientManagerParent* aManager);
 
   RefPtr<ClientOpPromise>
+  MatchAll(const ClientMatchAllArgs& aArgs);
+
+  RefPtr<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManagerService)
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
--- a/dom/clients/manager/ClientSourceParent.cpp
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -220,16 +220,22 @@ ClientSourceParent::IsFrozen() const
 }
 
 bool
 ClientSourceParent::ExecutionReady() const
 {
   return mExecutionReady;
 }
 
+const Maybe<ServiceWorkerDescriptor>&
+ClientSourceParent::GetController() const
+{
+  return mController;
+}
+
 void
 ClientSourceParent::AttachHandle(ClientHandleParent* aClientHandle)
 {
   MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
   MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
   MOZ_ASSERT(!mHandleList.Contains(aClientHandle));
   mHandleList.AppendElement(aClientHandle);
 }
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
--- a/dom/clients/manager/ClientSourceParent.h
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -65,16 +65,19 @@ public:
   Info() const;
 
   bool
   IsFrozen() const;
 
   bool
   ExecutionReady() const;
 
+  const Maybe<ServiceWorkerDescriptor>&
+  GetController() const;
+
   void
   AttachHandle(ClientHandleParent* aClientSource);
 
   void
   DetachHandle(ClientHandleParent* aClientSource);
 
   RefPtr<ClientOpPromise>
   StartOp(const ClientOpConstructorArgs& aArgs);
