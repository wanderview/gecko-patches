# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8ad8a536fd687e6f3000073248ab46f1112793ba
Bug 1363829 P7 Remove the Timeout nsITimer code. r=ehsan

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -1,19 +1,16 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim:set ts=2 sw=2 sts=2 et cindent: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Timeout.h"
 
-#include "nsGlobalWindow.h"
-#include "nsITimeoutHandler.h"
-#include "nsITimer.h"
 #include "mozilla/dom/TimeoutManager.h"
 
 namespace mozilla {
 namespace dom {
 
 Timeout::Timeout()
   : mCleared(false),
     mRunning(false),
@@ -23,116 +20,32 @@ Timeout::Timeout()
     mTimeoutId(0),
     mInterval(0),
     mFiringId(TimeoutManager::InvalidFiringId),
     mNestingLevel(0),
     mPopupState(openAllowed)
 {
 }
 
-Timeout::~Timeout()
-{
-  if (mTimer) {
-    mTimer->Cancel();
-    mTimer = nullptr;
-  }
-}
-
 NS_IMPL_CYCLE_COLLECTION_CLASS(Timeout)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mWindow)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mScriptHandler)
   tmp->remove();
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mWindow)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(Timeout, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(Timeout, Release)
 
-namespace {
-
-void
-TimerCallback(nsITimer*, void* aClosure)
-{
-  RefPtr<Timeout> timeout = (Timeout*)aClosure;
-  timeout->mWindow->AsInner()->TimeoutManager().RunTimeout(TimeStamp::Now(), timeout->When());
-  timeout->mClosureSelfRef = nullptr;
-}
-
-void
-TimerNameCallback(nsITimer* aTimer, bool aAnonymize, void* aClosure,
-                  char* aBuf, size_t aLen)
-{
-  RefPtr<Timeout> timeout = (Timeout*)aClosure;
-
-  // Filename and line-number information is privacy sensitive. If we're
-  // supposed to anonymize the data, don't include it.
-  if (aAnonymize) {
-    if (timeout->mIsInterval) {
-      snprintf(aBuf, aLen, "setInterval");
-    } else {
-      snprintf(aBuf, aLen, "setTimeout");
-    }
-    return;
-  }
-
-  const char* filename;
-  uint32_t lineNum, column;
-  timeout->mScriptHandler->GetLocation(&filename, &lineNum, &column);
-  snprintf(aBuf, aLen, "[content] %s:%u:%u", filename, lineNum, column);
-}
-
-} // anonymous namespace
-
-nsresult
-Timeout::InitTimer(nsIEventTarget* aTarget, uint32_t aDelay)
-{
-  // If the given target does not match the timer's current target
-  // then we need to override it before the Init.  Note that GetTarget()
-  // will return the current thread after setting the target to nullptr.
-  // So we need to special case the nullptr target comparison.
-  nsCOMPtr<nsIEventTarget> currentTarget;
-  MOZ_ALWAYS_SUCCEEDS(mTimer->GetTarget(getter_AddRefs(currentTarget)));
-  if ((aTarget && currentTarget != aTarget) ||
-      (!aTarget && currentTarget != NS_GetCurrentThread())) {
-    // Always call Cancel() in case we are re-using a timer.  Otherwise
-    // the subsequent SetTarget() may fail.
-    MOZ_ALWAYS_SUCCEEDS(mTimer->Cancel());
-    MOZ_ALWAYS_SUCCEEDS(mTimer->SetTarget(aTarget));
-  }
-
-  nsresult rv = mTimer->InitWithNameableFuncCallback(
-    TimerCallback, this, aDelay, nsITimer::TYPE_ONE_SHOT, TimerNameCallback);
-
-  // Add a reference for the new timer's closure.
-  if (NS_SUCCEEDED(rv)) {
-    mClosureSelfRef = this;
-  }
-
-  return rv;
-}
-
-void
-Timeout::MaybeCancelTimer()
-{
-  if (!mTimer) {
-    return;
-  }
-
-  mTimer->Cancel();
-  mTimer = nullptr;
-
-  mClosureSelfRef = nullptr;
-}
-
 void
 Timeout::SetWhenOrTimeRemaining(const TimeStamp& aBaseTime,
                                 const TimeDuration& aDelay)
 {
   // This must not be called on dummy timeouts.  Instead use SetDummyWhen().
   MOZ_DIAGNOSTIC_ASSERT(mWindow);
 
   // If we are frozen simply set mTimeRemaining to be the "time remaining" in
diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -6,22 +6,21 @@
 
 #ifndef mozilla_dom_timeout_h
 #define mozilla_dom_timeout_h
 
 #include "mozilla/LinkedList.h"
 #include "mozilla/TimeStamp.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsGlobalWindow.h"
+#include "nsITimeoutHandler.h"
 
-class nsGlobalWindow;
 class nsIEventTarget;
 class nsIPrincipal;
-class nsITimeoutHandler;
-class nsITimer;
 class nsIEventTarget;
 
 namespace mozilla {
 namespace dom {
 
 /*
  * Timeout struct that holds information about each script
  * timeout.  Holds a strong reference to an nsITimeoutHandler, which
@@ -31,23 +30,16 @@ class Timeout final
   : public LinkedListElement<RefPtr<Timeout>>
 {
 public:
   Timeout();
 
   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(Timeout)
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(Timeout)
 
-  // The target may be specified to use a particular event queue for the
-  // resulting timer runnable.  A nullptr target will result in the
-  // default main thread being used.
-  nsresult InitTimer(nsIEventTarget* aTarget, uint32_t aDelay);
-
-  void MaybeCancelTimer();
-
   enum class Reason
   {
     eTimeoutOrInterval,
     eIdleCallbackTimeout,
   };
 
   void SetWhenOrTimeRemaining(const TimeStamp& aBaseTime,
                               const TimeDuration& aDelay);
@@ -61,19 +53,16 @@ public:
   const TimeDuration& TimeRemaining() const;
 
   // Can only be called when not frozen.
   const TimeDuration& ScheduledDelay() const;
 
   // Window for which this timeout fires
   RefPtr<nsGlobalWindow> mWindow;
 
-  // The actual timer object
-  nsCOMPtr<nsITimer> mTimer;
-
   // True if the timeout was cleared
   bool mCleared;
 
   // True if this is one of the timeouts that are currently running
   bool mRunning;
 
   // True if this is a repeating/interval timer
   bool mIsInterval;
@@ -99,31 +88,29 @@ public:
 
   // The popup state at timeout creation time if not created from
   // another timeout
   PopupControlState mPopupState;
 
   // The language-specific information about the callback.
   nsCOMPtr<nsITimeoutHandler> mScriptHandler;
 
-  RefPtr<Timeout> mClosureSelfRef;
-
 private:
   // mWhen and mTimeRemaining can't be in a union, sadly, because they
   // have constructors.
   // Nominal time to run this timeout.  Use only when timeouts are not
   // frozen.
   TimeStamp mWhen;
 
   // Remaining time to wait.  Used only when timeouts are frozen.
   TimeDuration mTimeRemaining;
 
   // The actual interval in milliseconds.  This may be throttled to
   // a longer delay than mInterval for a number of reasons.
   TimeDuration mScheduledDelay;
 
-  ~Timeout();
+  ~Timeout() = default;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_timeout_h
