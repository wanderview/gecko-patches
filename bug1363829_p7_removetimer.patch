# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0e12a55e38fb998f8940353e537e3809f373e326
Bug 1363829 P7 Remove the Timeout nsITimer code. r=ehsan

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -25,20 +25,16 @@ Timeout::Timeout()
     mFiringId(TimeoutManager::InvalidFiringId),
     mNestingLevel(0),
     mPopupState(openAllowed)
 {
 }
 
 Timeout::~Timeout()
 {
-  if (mTimer) {
-    mTimer->Cancel();
-    mTimer = nullptr;
-  }
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(Timeout)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mWindow)
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
@@ -46,92 +42,16 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(Timeout)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mWindow)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(Timeout, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(Timeout, Release)
 
-namespace {
-
-void
-TimerCallback(nsITimer*, void* aClosure)
-{
-  RefPtr<Timeout> timeout = (Timeout*)aClosure;
-  timeout->mWindow->AsInner()->TimeoutManager().RunTimeout(timeout->When());
-  timeout->mClosureSelfRef = nullptr;
-}
-
-void
-TimerNameCallback(nsITimer* aTimer, bool aAnonymize, void* aClosure,
-                  char* aBuf, size_t aLen)
-{
-  RefPtr<Timeout> timeout = (Timeout*)aClosure;
-
-  // Filename and line-number information is privacy sensitive. If we're
-  // supposed to anonymize the data, don't include it.
-  if (aAnonymize) {
-    if (timeout->mIsInterval) {
-      snprintf(aBuf, aLen, "setInterval");
-    } else {
-      snprintf(aBuf, aLen, "setTimeout");
-    }
-    return;
-  }
-
-  const char* filename;
-  uint32_t lineNum, column;
-  timeout->mScriptHandler->GetLocation(&filename, &lineNum, &column);
-  snprintf(aBuf, aLen, "[content] %s:%u:%u", filename, lineNum, column);
-}
-
-} // anonymous namespace
-
-nsresult
-Timeout::InitTimer(nsIEventTarget* aTarget, uint32_t aDelay)
-{
-  // If the given target does not match the timer's current target
-  // then we need to override it before the Init.  Note that GetTarget()
-  // will return the current thread after setting the target to nullptr.
-  // So we need to special case the nullptr target comparison.
-  nsCOMPtr<nsIEventTarget> currentTarget;
-  MOZ_ALWAYS_SUCCEEDS(mTimer->GetTarget(getter_AddRefs(currentTarget)));
-  if ((aTarget && currentTarget != aTarget) ||
-      (!aTarget && currentTarget != NS_GetCurrentThread())) {
-    // Always call Cancel() in case we are re-using a timer.  Otherwise
-    // the subsequent SetTarget() may fail.
-    MOZ_ALWAYS_SUCCEEDS(mTimer->Cancel());
-    MOZ_ALWAYS_SUCCEEDS(mTimer->SetTarget(aTarget));
-  }
-
-  nsresult rv = mTimer->InitWithNameableFuncCallback(
-    TimerCallback, this, aDelay, nsITimer::TYPE_ONE_SHOT, TimerNameCallback);
-
-  // Add a reference for the new timer's closure.
-  if (NS_SUCCEEDED(rv)) {
-    mClosureSelfRef = this;
-  }
-
-  return rv;
-}
-
-void
-Timeout::MaybeCancelTimer()
-{
-  if (!mTimer) {
-    return;
-  }
-
-  mTimer->Cancel();
-  mTimer = nullptr;
-
-  mClosureSelfRef = nullptr;
-}
-
 void
 Timeout::SetWhenOrTimeRemaining(const TimeStamp& aBaseTime,
                                 const TimeDuration& aDelay)
 {
   // This must not be called on dummy timeouts.  Instead use SetDummyWhen().
   MOZ_DIAGNOSTIC_ASSERT(mWindow);
 
   // If we are frozen simply set mTimeRemaining to be the "time remaining" in
diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -11,17 +11,16 @@
 #include "mozilla/TimeStamp.h"
 #include "nsCOMPtr.h"
 #include "nsCycleCollectionParticipant.h"
 
 class nsGlobalWindow;
 class nsIEventTarget;
 class nsIPrincipal;
 class nsITimeoutHandler;
-class nsITimer;
 class nsIEventTarget;
 
 namespace mozilla {
 namespace dom {
 
 /*
  * Timeout struct that holds information about each script
  * timeout.  Holds a strong reference to an nsITimeoutHandler, which
@@ -31,23 +30,16 @@ class Timeout final
   : public LinkedListElement<RefPtr<Timeout>>
 {
 public:
   Timeout();
 
   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(Timeout)
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(Timeout)
 
-  // The target may be specified to use a particular event queue for the
-  // resulting timer runnable.  A nullptr target will result in the
-  // default main thread being used.
-  nsresult InitTimer(nsIEventTarget* aTarget, uint32_t aDelay);
-
-  void MaybeCancelTimer();
-
   enum class Reason
   {
     eTimeoutOrInterval,
     eIdleCallbackTimeout,
   };
 
   void SetWhenOrTimeRemaining(const TimeStamp& aBaseTime,
                               const TimeDuration& aDelay);
@@ -61,19 +53,16 @@ public:
   const TimeDuration& TimeRemaining() const;
 
   // Can only be called when not frozen.
   const TimeDuration& ScheduledDelay() const;
 
   // Window for which this timeout fires
   RefPtr<nsGlobalWindow> mWindow;
 
-  // The actual timer object
-  nsCOMPtr<nsITimer> mTimer;
-
   // True if the timeout was cleared
   bool mCleared;
 
   // True if this is one of the timeouts that are currently running
   bool mRunning;
 
   // True if this is a repeating/interval timer
   bool mIsInterval;
@@ -99,18 +88,16 @@ public:
 
   // The popup state at timeout creation time if not created from
   // another timeout
   PopupControlState mPopupState;
 
   // The language-specific information about the callback.
   nsCOMPtr<nsITimeoutHandler> mScriptHandler;
 
-  RefPtr<Timeout> mClosureSelfRef;
-
 private:
   // mWhen and mTimeRemaining can't be in a union, sadly, because they
   // have constructors.
   // Nominal time to run this timeout.  Use only when timeouts are not
   // frozen.
   TimeStamp mWhen;
 
   // Remaining time to wait.  Used only when timeouts are frozen.
