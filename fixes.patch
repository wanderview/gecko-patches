# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e162487d337a0227f9a7f8332461d2eb371a12bd

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3496,17 +3496,17 @@ nsGlobalWindow::EnsureClientSource()
       mClientSource = loadInfo->TakeReservedClient();
     }
   }
 
   // If we don't have a reserved client we need to create one now
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
-    if (!mClientSource) {
+    if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
   }
 
   // The load may have started controlled the Client as well.  If
   // so mark it as controlled immediately here.  The actor may
   // or may not have been notified by the parent side about being
   // controlled yet.
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Client.h"
 
+#include "ClientDOMUtil.h"
 #include "mozilla/dom/ClientHandle.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientState.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
 #include "nsIGlobalObject.h"
@@ -39,44 +40,16 @@ void
 Client::EnsureHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Client);
   if (!mHandle) {
     mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()));
   }
 }
 
-// TODO: unify this with code in Clients
-nsresult
-Client::GetEndPoint(ClientEndPoint& aEndPointOut)
-{
-  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
-  if (window) {
-    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
-    if (clientInfo.isSome()) {
-      aEndPointOut = clientInfo.ref().ToIPC();
-      return NS_OK;
-    }
-  } else {
-    MOZ_ASSERT(!NS_IsMainThread());
-    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
-    if (workerPrivate) {
-      if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
-        return NS_OK;
-      } else {
-        aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
-        return NS_OK;
-      }
-    }
-  }
-
-  return NS_ERROR_DOM_INVALID_STATE_ERR;
-}
-
 Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
   : mGlobal(aGlobal)
   , mData(MakeUnique<ClientInfoAndState>(aData))
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
 }
 
 TimeStamp
@@ -152,17 +125,17 @@ Client::PostMessage(JSContext* aCx, JS::
 
   StructuredCloneData data;
   data.Write(aCx, aMessage, transferable, aRv);
   if (aRv.Failed()) {
     return;
   }
 
   ClientEndPoint endpoint;
-  aRv = GetEndPoint(endpoint);
+  aRv = ClientGetEndPoint(mGlobal, &endpoint);
   if (aRv.Failed()) {
     return;
   }
 
   EnsureHandle();
   RefPtr<GenericPromise> p = mHandle->PostMessage(data, endpoint);
 }
 
@@ -182,17 +155,17 @@ already_AddRefed<Promise>
 Client::Focus(ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
   ClientEndPoint endpoint;
-  aRv = GetEndPoint(endpoint);
+  aRv = ClientGetEndPoint(mGlobal, &endpoint);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
   bool interactionAllowed = false;
 
   if (endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor) {
     WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
@@ -247,19 +220,17 @@ Client::Navigate(const nsAString& aURL, 
       baseURL = workerPrivate->GetLocationInfo().mHref;
     }
   }
 
   RefPtr<Client> self = this;
 
   ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
 
-  RefPtr<ClientOpPromise> innerPromise = ClientManager::Navigate(args);
-
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  StartClientManagerOp(&ClientManager::Navigate, args,
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> newClient =
         new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
diff --git a/dom/clients/api/Client.h b/dom/clients/api/Client.h
--- a/dom/clients/api/Client.h
+++ b/dom/clients/api/Client.h
@@ -14,17 +14,16 @@
 class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
-class ClientEndPoint;
 class ClientHandle;
 class ClientInfoAndState;
 class Promise;
 
 template <typename t> class Sequence;
 
 class Client final : public nsISupports
                    , public nsWrapperCache
@@ -33,19 +32,16 @@ class Client final : public nsISupports
   UniquePtr<ClientInfoAndState> mData;
   RefPtr<ClientHandle> mHandle;
 
   ~Client();
 
   void
   EnsureHandle();
 
-  nsresult
-  GetEndPoint(ClientEndPoint& aEndPointOut);
-
 public:
   Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData);
 
   TimeStamp
   CreationTime() const;
 
   TimeStamp
   LastFocusTime() const;
diff --git a/dom/clients/api/ClientDOMUtil.cpp b/dom/clients/api/ClientDOMUtil.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.cpp
@@ -0,0 +1,43 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientDOMUtil.h"
+
+namespace mozilla {
+namespace dom {
+
+nsresult
+ClientGetEndPoint(nsIGlobalObject* aGlobal, ClientEndPoint* aEndPointOut)
+{
+  MOZ_DIAGNOSTIC_ASSERT(aGlobal);
+  MOZ_DIAGNOSTIC_ASSERT(aEndPointOut);
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  if (window) {
+    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
+    if (clientInfo.isSome()) {
+      *aEndPointOut = clientInfo.ref().ToIPC();
+      return NS_OK;
+    }
+  } else {
+    MOZ_ASSERT(!NS_IsMainThread());
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    if (workerPrivate) {
+      if (workerPrivate->IsServiceWorker()) {
+        *aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
+        return NS_OK;
+      } else {
+        *aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
+        return NS_OK;
+      }
+    }
+  }
+
+  return NS_ERROR_DOM_INVALID_STATE_ERR;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientDOMUtil_h
+#define _mozilla_dom_ClientDOMUtil_h
+
+#include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/dom/ClientOpPromise.h"
+#include "mozilla/dom/WorkerPrivate.h"
+#include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
+
+class nsIGlobalObject;
+
+namespace mozilla {
+namespace dom {
+
+class ClientEndPoint;
+
+nsresult
+ClientGetEndPoint(nsIGlobalObject* aGlobal, ClientEndPoint* aEndPointOut);
+
+// TODO: Add a ClientHandle version of this wrapper for Client methods.
+template<typename Func, typename Arg, typename Resolve, typename Reject>
+void
+StartClientManagerOp(Func aFunc, const Arg& aArg, Resolve aResolve, Reject aReject)
+{
+  using mozilla::dom::workers::Closing;
+  using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
+  using mozilla::dom::workers::WorkerHolderToken;
+
+  RefPtr<WorkerHolderToken> token;
+  if (!NS_IsMainThread()) {
+    token = WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Closing);
+  }
+
+  RefPtr<ClientOpPromise> promise = aFunc(aArg);
+  promise->Then(AbstractThread::GetCurrent(), __func__,
+    [aResolve, token](const ClientOpResult& aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aResolve(aResult);
+    }, [aReject, token](nsresult aResult) {
+      if (token && token->IsShuttingDown()) {
+        return;
+      }
+      aReject(aResult);
+    });
+}
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientDOMUtil_h
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "Clients.h"
 
+#include "ClientDOMUtil.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientsBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "nsIGlobalObject.h"
 #include "nsString.h"
@@ -30,43 +31,16 @@ NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
 Clients::~Clients()
 {
 }
 
-nsresult
-Clients::GetEndPoint(ClientEndPoint& aEndPointOut)
-{
-  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mGlobal);
-  if (window) {
-    const Maybe<ClientInfo>& clientInfo = window->GetClientInfo();
-    if (clientInfo.isSome()) {
-      aEndPointOut = clientInfo.ref().ToIPC();
-      return NS_OK;
-    }
-  } else {
-    MOZ_ASSERT(!NS_IsMainThread());
-    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
-    if (workerPrivate) {
-      if (workerPrivate->IsServiceWorker()) {
-        aEndPointOut = workerPrivate->GetServiceWorkerDescriptor().ToIPC();
-        return NS_OK;
-      } else {
-        aEndPointOut = workerPrivate->GetClientInfo().ToIPC();
-        return NS_OK;
-      }
-    }
-  }
-
-  return NS_ERROR_DOM_INVALID_STATE_ERR;
-}
-
 Clients::Clients(nsIGlobalObject* aGlobal)
   : mGlobal(aGlobal)
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
 }
 
 JSObject*
 Clients::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
@@ -92,17 +66,17 @@ Clients::Get(const nsAString& aClientID,
   if (!id.Parse(NS_ConvertUTF16toUTF8(aClientID).get())) {
     // Invalid ID means we will definitely not find a match, so just
     // resolve with undefined indicating "not found".
     outerPromise->MaybeResolveWithUndefined();
     return outerPromise.forget();
   }
 
   ClientEndPoint endpoint;
-  nsresult rv = GetEndPoint(endpoint);
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
   if (NS_FAILED(rv)) {
     // If we can't get an endpoint then we don't have a recognizeable
     // principal and we won't effectively match anything.  Resolve
     // undefined indicating "not found".
     outerPromise->MaybeResolveWithUndefined();
     return outerPromise.forget();
   }
 
@@ -167,31 +141,30 @@ already_AddRefed<Promise>
 Clients::MatchAll(const ClientQueryOptions& aOptions, ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
   ClientEndPoint endpoint;
-  nsresult rv = GetEndPoint(endpoint);
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return outerPromise.forget();
   }
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   // We don't expose this reserved clients yet
   const bool includeReserved = false;
   ClientMatchAllArgs args(endpoint, aOptions.mType,
                           aOptions.mIncludeUncontrolled,
                           includeReserved);
-  RefPtr<ClientOpPromise> innerPromise = ClientManager::MatchAll(args);
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  StartClientManagerOp(&ClientManager::MatchAll, args,
     [outerPromise, global] (const ClientOpResult& aResult) {
       nsTArray<RefPtr<Client>> clientList;
       for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
         clientList.AppendElement(new Client(global, value));
       }
       clientList.Sort(MatchAllComparator());
       outerPromise->MaybeResolve(clientList);
     }, [outerPromise] (nsresult aResult) {
@@ -250,18 +223,17 @@ Clients::OpenWindow(const nsAString& aUR
   if (!interactionAllowed) {
     outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
     return outerPromise.forget();
   }
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   ClientOpenWindowArgs args(principalInfo, NS_ConvertUTF16toUTF8(aURL), baseURL);
-  RefPtr<ClientOpPromise> innerPromise = ClientManager::OpenWindow(args);
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  StartClientManagerOp(&ClientManager::OpenWindow, args,
     [outerPromise, global] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> client =
         new Client(global, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(client);
@@ -277,17 +249,17 @@ already_AddRefed<Promise>
 Clients::Claim(ErrorResult& aRv)
 {
   RefPtr<Promise> outerPromise = Promise::Create(mGlobal, aRv);
   if (aRv.Failed()) {
     return outerPromise.forget();
   }
 
   ClientEndPoint endpoint;
-  nsresult rv = GetEndPoint(endpoint);
+  nsresult rv = ClientGetEndPoint(mGlobal, &endpoint);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return outerPromise.forget();
   }
 
   if (endpoint.type() != ClientEndPoint::TIPCServiceWorkerDescriptor) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
@@ -297,19 +269,17 @@ Clients::Claim(ErrorResult& aRv)
     endpoint.get_IPCServiceWorkerDescriptor();
 
   if (serviceWorker.state() != ServiceWorkerState::Activating &&
       serviceWorker.state() != ServiceWorkerState::Activated) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
-  RefPtr<ClientOpPromise> innerPromise =
-    ClientManager::Claim(ClientClaimArgs(serviceWorker));
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
     [outerPromise] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
     }, [outerPromise] (nsresult aResult) {
       outerPromise->MaybeReject(aResult);
     });
 
   return outerPromise.forget();
 }
diff --git a/dom/clients/api/Clients.h b/dom/clients/api/Clients.h
--- a/dom/clients/api/Clients.h
+++ b/dom/clients/api/Clients.h
@@ -13,30 +13,26 @@
 class nsIGlobalObject;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
-class ClientEndPoint;
 struct ClientQueryOptions;
 class Promise;
 
 class Clients final : public nsISupports
                     , public nsWrapperCache
 {
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
   ~Clients();
 
-  nsresult
-  GetEndPoint(ClientEndPoint& aEndPointOut);
-
 public:
   explicit Clients(nsIGlobalObject* aGlobal);
 
   // nsWrapperCache interface methods
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   // DOM bindings methods
diff --git a/dom/clients/api/moz.build b/dom/clients/api/moz.build
--- a/dom/clients/api/moz.build
+++ b/dom/clients/api/moz.build
@@ -6,16 +6,17 @@
 
 EXPORTS.mozilla.dom += [
   'Client.h',
   'Clients.h',
 ]
 
 UNIFIED_SOURCES += [
   'Client.cpp',
+  'ClientDOMUtil.cpp',
   'Clients.cpp',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
   '/dom/workers',
 ]
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -161,17 +161,17 @@ ClientHandle::PostMessage(StructuredClon
   // TODO: Ideally we should be able to wait for the actor to initialize,
   //       but for now just fail the postMessage() if its not ready.  We
   //       need a RefCounted version of the StructuredCloneData in order
   //       to capture it in the lambda here.
   if (!GetActor() ||
       !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
                                                       args.clonedData())) {
     ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    ref.forget();
+    return ref.forget();
   }
 
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise](const ClientOpResult& aResult) {
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -18,18 +18,18 @@
 #include "prthread.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::PBackgroundChild;
 using mozilla::ipc::PrincipalInfo;
+using mozilla::dom::workers::Closing;
 using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
-using mozilla::dom::workers::Terminating;
 using mozilla::dom::workers::WorkerHolderToken;
 using mozilla::dom::workers::WorkerPrivate;
 
 namespace {
 
 uint32_t kBadThreadLocalIndex = -1;
 uint32_t sClientManagerThreadLocalIndex = kBadThreadLocalIndex;
 
@@ -239,17 +239,17 @@ ClientManager::PBackgroundActorCreated(P
 
   if (IsShutdown()) {
     return;
   }
 
   RefPtr<WorkerHolderToken> workerHolderToken;
   if (!NS_IsMainThread()) {
     workerHolderToken =
-      WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Terminating);
+      WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Closing);
     if (NS_WARN_IF(!workerHolderToken)) {
       Shutdown();
       return;
     }
   }
 
   ClientManagerChild* actor = new ClientManagerChild(workerHolderToken);
   PClientManagerChild *sentActor = aActor->SendPClientManagerConstructor(actor);
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -123,27 +123,27 @@ ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
 nsPIDOMWindowInner*
 ClientSource::GetInnerWindow() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() && !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
+  if (mOwner.isNothing() || !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
     return nullptr;
   }
   return mOwner.ref().as<RefPtr<nsPIDOMWindowInner>>();
 }
 
 WorkerPrivate*
 ClientSource::GetWorkerPrivate() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() && !mOwner.ref().is<WorkerPrivate*>()) {
+  if (mOwner.isNothing() || !mOwner.ref().is<WorkerPrivate*>()) {
     return nullptr;
   }
   return mOwner.ref().as<WorkerPrivate*>();
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
@@ -203,16 +203,17 @@ ClientSource::WindowExecutionReady(nsPID
   // We should either be setting a window execution ready for the
   // first time or setting the same window execution ready again.
   // The secondary calls are due to initial about:blank replacement.
   MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing() ||
                         GetInnerWindow() == aInnerWindow);
 
   // This creates a cycle with the window.  It is broken when
   // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
+  mOwner.reset();
   mOwner.emplace(AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow)));
 
   return NS_OK;
 }
 
 void
 ClientSource::Freeze()
 {
@@ -560,16 +561,17 @@ ClientSource::SnapshotState(ClientState*
 
   // TODO: Handle state on reserved client where no window/workerprivate yet.
 
   if (mClientInfo.Type() == ClientType::Window) {
     nsresult rv = SnapshotWindowState(aStateOut);
     if (NS_FAILED(rv)) {
       return rv;
     }
+    return NS_OK;
   }
 
   *aStateOut = ClientState(ClientWorkerState());
   return NS_OK;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientThing.h b/dom/clients/manager/ClientThing.h
--- a/dom/clients/manager/ClientThing.h
+++ b/dom/clients/manager/ClientThing.h
@@ -24,17 +24,17 @@ class ClientThing
   };
 
   template <typename Callable>
   class TaskImpl final : public Task
   {
     Callable mCallable;
 
   public:
-    explicit TaskImpl(Callable aCallable)
+    explicit TaskImpl(const Callable& aCallable)
       : mCallable(aCallable)
     { }
 
     void
     Execute(ActorType* aActor) override
     {
       MOZ_DIAGNOSTIC_ASSERT(aActor);
       mCallable(aActor);
@@ -66,17 +66,17 @@ protected:
   bool
   IsShutdown() const
   {
     return mShutdown;
   }
 
   template<typename Callable>
   void
-  MaybeExecute(Callable aCallable)
+  MaybeExecute(const Callable& aCallable)
   {
     if (mShutdown) {
       return;
     }
     mTaskList.AppendElement(new TaskImpl<Callable>(aCallable));
     MaybeExecuteTaskList();
   }
 
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -580,17 +580,17 @@ private:
   // run we have not yet done our load so don't know things like our final
   // principal and whatnot.
 
   virtual bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
-    aWorkerPrivate->ReserveClient();
+    aWorkerPrivate->EnsureClientSource();
 
     ErrorResult rv;
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL, WorkerScript, rv);
     rv.WouldReportJSException();
     // Explicitly ignore NS_BINDING_ABORTED on rv.  Or more precisely, still
     // return false and don't SetWorkerScriptExecutedSuccessfully() in that
     // case, but don't throw anything on aCx.  The idea is to not dispatch error
     // events if our load is canceled with that error code.
@@ -652,17 +652,17 @@ private:
 
     WorkerDebuggerGlobalScope* globalScope =
       aWorkerPrivate->CreateDebuggerGlobalScope(aCx);
     if (!globalScope) {
       NS_WARNING("Failed to make global!");
       return false;
     }
 
-    aWorkerPrivate->ReserveClient();
+    aWorkerPrivate->EnsureClientSource();
 
     JS::Rooted<JSObject*> global(aCx, globalScope->GetWrapper());
 
     ErrorResult rv;
     JSAutoCompartment ac(aCx, global);
     scriptloader::LoadMainScript(aWorkerPrivate, mScriptURL,
                                  DebuggerScript, rv);
     rv.WouldReportJSException();
@@ -5197,20 +5197,23 @@ WorkerPrivate::DispatchToMainThread(alre
 
 nsIEventTarget*
 WorkerPrivate::ControlEventTarget()
 {
   return mWorkerControlEventTarget;
 }
 
 void
-WorkerPrivate::ReserveClient()
+WorkerPrivate::EnsureClientSource()
 {
   AssertIsOnWorkerThread();
-  MOZ_ASSERT(!mClientSource);
+
+  if (mClientSource) {
+    return;
+  }
 
   ClientType type;
   switch(Type()) {
     case WorkerTypeDedicated:
       type = ClientType::Worker;
       break;
     case WorkerTypeShared:
       type = ClientType::Sharedworker;
@@ -5218,16 +5221,19 @@ WorkerPrivate::ReserveClient()
     case WorkerTypeService:
       type = ClientType::Serviceworker;
       break;
     default:
       MOZ_CRASH("unknown worker type!");
   }
 
   mClientSource = ClientManager::CreateSource(type, GetPrincipalInfo());
+  if (mFrozen) {
+    mClientSource->Freeze();
+  }
 
   // Shortly after the client is reserved we will try loading the main script
   // for the worker.  This may get intercepted by the ServiceWorkerManager
   // which will then try to create a ClientHandle.  Its actually possible for
   // the main thread to create this ClientHandle before our IPC message creating
   // the ClientSource completes.  To avoid this race we synchronously ping our
   // parent Client actor here.  This ensure the worker Client is created in
   // the parent before the main thread might try reaching it with a
@@ -5603,17 +5609,19 @@ WorkerPrivate::ClearDebuggerEventQueue()
 
 bool
 WorkerPrivate::FreezeInternal()
 {
   AssertIsOnWorkerThread();
 
   NS_ASSERTION(!mFrozen, "Already frozen!");
 
-  mClientSource->Freeze();
+  if (mClientSource) {
+    mClientSource->Freeze();
+  }
 
   mFrozen = true;
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Freeze(nullptr);
   }
 
   return true;
@@ -5627,17 +5635,19 @@ WorkerPrivate::ThawInternal()
   NS_ASSERTION(mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Thaw(nullptr);
   }
 
   mFrozen = false;
 
-  mClientSource->Thaw();
+  if (mClientSource) {
+    mClientSource->Thaw();
+  }
 
   return true;
 }
 
 void
 WorkerPrivate::TraverseTimeouts(nsCycleCollectionTraversalCallback& cb)
 {
   for (uint32_t i = 0; i < mTimeouts.Length(); ++i) {
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1471,17 +1471,17 @@ public:
 
   // Get an event target that will dispatch runnables as control runnables on
   // the worker thread.  Implement nsICancelableRunnable if you wish to take
   // action on cancelation.
   nsIEventTarget*
   ControlEventTarget();
 
   void
-  ReserveClient();
+  EnsureClientSource();
 
   const ClientInfo&
   GetClientInfo() const;
 
   void
   Control(const ServiceWorkerDescriptor& aServiceWorker);
 
   void
