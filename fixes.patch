# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6b34343bb3e7a8c011ed8c177dcb4505247d5b36

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3486,17 +3486,17 @@ nsGlobalWindow::EnsureClientSource()
       mClientSource = loadInfo->TakeReservedClient();
     }
   }
 
   // If we don't have a reserved client we need to create one now
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 mDoc->NodePrincipal());
-    if (!mClientSource) {
+    if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
   }
 
   // The load may have started controlled the Client as well.  If
   // so mark it as controlled immediately here.  The actor may
   // or may not have been notified by the parent side about being
   // controlled yet.
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -161,17 +161,17 @@ ClientHandle::PostMessage(StructuredClon
   // TODO: Ideally we should be able to wait for the actor to initialize,
   //       but for now just fail the postMessage() if its not ready.  We
   //       need a RefCounted version of the StructuredCloneData in order
   //       to capture it in the lambda here.
   if (!GetActor() ||
       !aData.BuildClonedMessageDataForBackgroundChild(GetActor()->Manager()->Manager(),
                                                       args.clonedData())) {
     ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
-    ref.forget();
+    return ref.forget();
   }
 
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
   innerPromise->Then(AbstractThread::GetCurrent(), __func__,
     [outerPromise](const ClientOpResult& aResult) {
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -123,27 +123,27 @@ ClientSource::~ClientSource()
 {
   Shutdown();
 }
 
 nsPIDOMWindowInner*
 ClientSource::GetInnerWindow() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() && !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
+  if (mOwner.isNothing() || !mOwner.ref().is<RefPtr<nsPIDOMWindowInner>>()) {
     return nullptr;
   }
   return mOwner.ref().as<RefPtr<nsPIDOMWindowInner>>();
 }
 
 WorkerPrivate*
 ClientSource::GetWorkerPrivate() const
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
-  if (mOwner.isNothing() && !mOwner.ref().is<WorkerPrivate*>()) {
+  if (mOwner.isNothing() || !mOwner.ref().is<WorkerPrivate*>()) {
     return nullptr;
   }
   return mOwner.ref().as<WorkerPrivate*>();
 }
 
 void
 ClientSource::WorkerExecutionReady(WorkerPrivate* aWorkerPrivate)
 {
@@ -203,16 +203,17 @@ ClientSource::WindowExecutionReady(nsPID
   // We should either be setting a window execution ready for the
   // first time or setting the same window execution ready again.
   // The secondary calls are due to initial about:blank replacement.
   MOZ_DIAGNOSTIC_ASSERT(mOwner.isNothing() ||
                         GetInnerWindow() == aInnerWindow);
 
   // This creates a cycle with the window.  It is broken when
   // nsGlobalWindow::FreeInnerObjects() deletes the ClientSource.
+  mOwner.reset();
   mOwner.emplace(AsVariant(RefPtr<nsPIDOMWindowInner>(aInnerWindow)));
 
   return NS_OK;
 }
 
 void
 ClientSource::Freeze()
 {
@@ -560,16 +561,17 @@ ClientSource::SnapshotState(ClientState*
 
   // TODO: Handle state on reserved client where no window/workerprivate yet.
 
   if (mClientInfo.Type() == ClientType::Window) {
     nsresult rv = SnapshotWindowState(aStateOut);
     if (NS_FAILED(rv)) {
       return rv;
     }
+    return NS_OK;
   }
 
   *aStateOut = ClientState(ClientWorkerState());
   return NS_OK;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientThing.h b/dom/clients/manager/ClientThing.h
--- a/dom/clients/manager/ClientThing.h
+++ b/dom/clients/manager/ClientThing.h
@@ -24,17 +24,17 @@ class ClientThing
   };
 
   template <typename Callable>
   class TaskImpl final : public Task
   {
     Callable mCallable;
 
   public:
-    explicit TaskImpl(Callable aCallable)
+    explicit TaskImpl(const Callable& aCallable)
       : mCallable(aCallable)
     { }
 
     void
     Execute(ActorType* aActor) override
     {
       MOZ_DIAGNOSTIC_ASSERT(aActor);
       mCallable(aActor);
@@ -66,17 +66,17 @@ protected:
   bool
   IsShutdown() const
   {
     return mShutdown;
   }
 
   template<typename Callable>
   void
-  MaybeExecute(Callable aCallable)
+  MaybeExecute(const Callable& aCallable)
   {
     if (mShutdown) {
       return;
     }
     mTaskList.AppendElement(new TaskImpl<Callable>(aCallable));
     MaybeExecuteTaskList();
   }
 
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -5236,16 +5236,17 @@ WorkerPrivate::ReserveClient()
       break;
     case WorkerTypeService:
       type = ClientType::Serviceworker;
       break;
     default:
       MOZ_CRASH("unknown worker type!");
   }
 
+  MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
   mClientSource = ClientManager::CreateSource(type, GetPrincipalInfo());
 
   // Shortly after the client is reserved we will try loading the main script
   // for the worker.  This may get intercepted by the ServiceWorkerManager
   // which will then try to create a ClientHandle.  Its actually possible for
   // the main thread to create this ClientHandle before our IPC message creating
   // the ClientSource completes.  To avoid this race we synchronously ping our
   // parent Client actor here.  This ensure the worker Client is created in
@@ -5622,17 +5623,19 @@ WorkerPrivate::ClearDebuggerEventQueue()
 
 bool
 WorkerPrivate::FreezeInternal()
 {
   AssertIsOnWorkerThread();
 
   NS_ASSERTION(!mFrozen, "Already frozen!");
 
-  mClientSource->Freeze();
+  if (mClientSource) {
+    mClientSource->Freeze();
+  }
 
   mFrozen = true;
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Freeze(nullptr);
   }
 
   return true;
@@ -5646,17 +5649,19 @@ WorkerPrivate::ThawInternal()
   NS_ASSERTION(mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Thaw(nullptr);
   }
 
   mFrozen = false;
 
-  mClientSource->Thaw();
+  if (mClientSource) {
+    mClientSource->Thaw();
+  }
 
   return true;
 }
 
 void
 WorkerPrivate::TraverseTimeouts(nsCycleCollectionTraversalCallback& cb)
 {
   for (uint32_t i = 0; i < mTimeouts.Length(); ++i) {
