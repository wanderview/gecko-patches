# HG changeset patch
# Parent 6b6fb22a43811b4b54638b35c6782b6079fb0444
# User Ben Kelly <ben@wanderview.com>
Pass stream control and ID back to parent when given our own streams.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -129,16 +129,18 @@ Cache::Add(const RequestOrScalarValueStr
   if (aRv.Failed()) {
     return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendAdd(requestId, request);
 
+  CleanupChildFds(request.body());
+
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::AddAll(const Sequence<OwningRequestOrScalarValueString>& aRequests,
               ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
@@ -166,16 +168,20 @@ Cache::AddAll(const Sequence<OwningReque
       return nullptr;
     }
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendAddAll(requestId, requests);
 
+  for (uint32_t i = 0; i < requests.Length(); ++i) {
+    CleanupChildFds(requests[i].body());
+  }
+
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::Put(const RequestOrScalarValueString& aRequest, Response& aResponse,
            ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
@@ -206,16 +212,19 @@ Cache::Put(const RequestOrScalarValueStr
   if (aRv.Failed()) {
     return nullptr;
   }
 
   RequestId requestId = AddRequestPromise(promise, aRv);
 
   unused << mActor->SendPut(requestId, request, response);
 
+  CleanupChildFds(request.body());
+  CleanupChildFds(response.body());
+
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 Cache::Delete(const RequestOrScalarValueString& aRequest,
               const QueryParams& aParams, ErrorResult& aRv)
 {
   MOZ_ASSERT(mActor);
@@ -314,56 +323,54 @@ Cache::ActorDestroy(mozilla::ipc::IProto
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 Cache::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                         const PCacheResponseOrVoid& aResponse,
-                         PCacheStreamControlChild* aStreamControl)
+                         const PCacheResponseOrVoid& aResponse)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
-  nsRefPtr<Response> response = ToResponse(aResponse, aStreamControl);
+  nsRefPtr<Response> response = ToResponse(aResponse);
   promise->MaybeResolve(response);
 }
 
 void
 Cache::RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                            const nsTArray<PCacheResponse>& aResponses,
-                            PCacheStreamControlChild* aStreamControl)
+                            const nsTArray<PCacheResponse>& aResponses)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Response>> responses;
   for (uint32_t i = 0; i < aResponses.Length(); ++i) {
-    nsRefPtr<Response> response = ToResponse(aResponses[i], aStreamControl);
+    nsRefPtr<Response> response = ToResponse(aResponses[i]);
     responses.AppendElement(response.forget());
   }
   promise->MaybeResolve(responses);
 }
 
 void
 Cache::RecvAddResponse(RequestId aRequestId, nsresult aRv)
 {
@@ -425,32 +432,31 @@ Cache::RecvDeleteResponse(RequestId aReq
     return;
   }
 
   promise->MaybeResolve(aSuccess);
 }
 
 void
 Cache::RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                        const nsTArray<PCacheRequest>& aRequests,
-                        PCacheStreamControlChild* aStreamControl)
+                        const nsTArray<PCacheRequest>& aRequests)
 {
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
   if (NS_FAILED(aRv)) {
     promise->MaybeReject(aRv);
     return;
   }
 
   nsTArray<nsRefPtr<Request>> requests;
   for (uint32_t i = 0; i < aRequests.Length(); ++i) {
-    nsRefPtr<Request> request = ToRequest(aRequests[i], aStreamControl);
+    nsRefPtr<Request> request = ToRequest(aRequests[i]);
     requests.AppendElement(request.forget());
   }
   promise->MaybeResolve(requests);
 }
 
 nsIGlobalObject*
 Cache::GetGlobalObject() const
 {
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -73,36 +73,33 @@ public:
 
   virtual nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // CacheChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse,
-                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses,
-                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& aResponses) MOZ_OVERRIDE;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv) MOZ_OVERRIDE;
 
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess) MOZ_OVERRIDE;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<PCacheRequest>& aRequests,
-                   PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                   const nsTArray<PCacheRequest>& aRequests) MOZ_OVERRIDE;
 
   // TypeUtils methods
   virtual nsIGlobalObject* GetGlobalObject() const MOZ_OVERRIDE;
 #ifdef DEBUG
   virtual void AssertOwningThread() const MOZ_OVERRIDE;
 #endif
 
 private:
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -43,31 +43,29 @@ void
 CacheChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
 
 bool
 CacheChild::RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                              const PCacheResponseOrVoid& aResponse,
-                              PCacheStreamControlChild* aStreamControl)
+                              const PCacheResponseOrVoid& aResponse)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchResponse(requestId, aRv, aResponse, aStreamControl);
+  mListener->RecvMatchResponse(requestId, aRv, aResponse);
   return true;
 }
 
 bool
 CacheChild::RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                                 const nsTArray<PCacheResponse>& responses,
-                                 PCacheStreamControlChild* aStreamControl)
+                                 const nsTArray<PCacheResponse>& responses)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchAllResponse(requestId, aRv, responses, aStreamControl);
+  mListener->RecvMatchAllResponse(requestId, aRv, responses);
   return true;
 }
 
 bool
 CacheChild::RecvAddResponse(const RequestId& requestId, const nsresult& aRv)
 {
   MOZ_ASSERT(mListener);
   mListener->RecvAddResponse(requestId, aRv);
@@ -96,19 +94,18 @@ CacheChild::RecvDeleteResponse(const Req
 {
   MOZ_ASSERT(mListener);
   mListener->RecvDeleteResponse(requestId, aRv, result);
   return true;
 }
 
 bool
 CacheChild::RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
-                             const nsTArray<PCacheRequest>& requests,
-                             PCacheStreamControlChild* aStreamControl)
+                             const nsTArray<PCacheRequest>& requests)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvKeysResponse(requestId, aRv, requests, aStreamControl);
+  mListener->RecvKeysResponse(requestId, aRv, requests);
   return true;
 }
 
 } // namespace cache
 } // namespace dom
 } // namesapce mozilla
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -26,37 +26,34 @@ public:
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   void SetListener(CacheChildListener& aListener);
   void ClearListener();
 
   // PCacheChild methods
   virtual bool
   RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
-                    const PCacheResponseOrVoid& aResponse,
-                    PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                    const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAllResponse(const RequestId& requestId, const nsresult& aRv,
-                       const nsTArray<PCacheResponse>& responses,
-                       PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                       const nsTArray<PCacheResponse>& responses) MOZ_OVERRIDE;
   virtual bool
   RecvAddResponse(const RequestId& requestId, const nsresult& aRv) MOZ_OVERRIDE;
 
   virtual bool
   RecvAddAllResponse(const RequestId& requestId,
                      const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvPutResponse(const RequestId& aRequestId,
                   const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
-                   const nsTArray<PCacheRequest>& requests,
-                   PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                   const nsTArray<PCacheRequest>& requests) MOZ_OVERRIDE;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheChild_h
diff --git a/dom/cache/CacheChildListener.h b/dom/cache/CacheChildListener.h
--- a/dom/cache/CacheChildListener.h
+++ b/dom/cache/CacheChildListener.h
@@ -27,37 +27,34 @@ class PCacheStreamControlChild;
 class CacheChildListener
 {
 public:
   virtual ~CacheChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
 
   virtual void
   RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                    const PCacheResponseOrVoid& aResponse,
-                    PCacheStreamControlChild* aStreamControl)=0;
+                    const PCacheResponseOrVoid& aResponse)=0;
   virtual void
   RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
-                       const nsTArray<PCacheResponse>& aResponses,
-                       PCacheStreamControlChild* aStreamControl)=0;
+                       const nsTArray<PCacheResponse>& aResponses)=0;
   virtual void
   RecvAddResponse(RequestId aRequestId, nsresult aRv)=0;
 
   virtual void
   RecvAddAllResponse(RequestId aRequestId, nsresult aRv)=0;
 
   virtual void
   RecvPutResponse(RequestId aRequestId, nsresult aRv)=0;
 
   virtual void
   RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                      bool aSuccess)=0;
   virtual void
   RecvKeysResponse(RequestId aRequestId, nsresult aRv,
-                   const nsTArray<PCacheRequest>& aRequests,
-                   PCacheStreamControlChild* aStreamControl)=0;
+                   const nsTArray<PCacheRequest>& aRequests)=0;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_CacheChildListener_h
diff --git a/dom/cache/CacheParent.cpp b/dom/cache/CacheParent.cpp
--- a/dom/cache/CacheParent.cpp
+++ b/dom/cache/CacheParent.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheParent.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsCOMPtr.h"
 
 namespace mozilla {
@@ -92,16 +93,19 @@ CacheParent::RecvPut(const RequestId& aR
   MOZ_ASSERT(mManager);
 
   nsCOMPtr<nsIInputStream> requestStream =
     DeserializeCacheStream(aRequest.body());
 
   nsCOMPtr<nsIInputStream> responseStream =
     DeserializeCacheStream(aResponse.body());
 
+  printf_stderr("### ### CacheParent::RecvPut() request:%p response:%p\n",
+                requestStream.get(), responseStream.get());
+
   mManager->CachePut(this, aRequestId, mCacheId, aRequest, requestStream,
                      aResponse, responseStream);
   return true;
 }
 
 bool
 CacheParent::RecvDelete(const RequestId& aRequestId,
                         const PCacheRequest& aRequest,
@@ -127,37 +131,36 @@ CacheParent::OnCacheMatch(RequestId aReq
                           const SavedResponse* aSavedResponse,
                           Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse || !aStreamList) {
     responseOrVoid = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
     responseOrVoid.get_PCacheResponse().body() = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   PCacheReadStream readStream;
-  Manager::StreamControl* streamControl =
-    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
-                        &readStream);
+  SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                      &readStream);
 
   responseOrVoid = aSavedResponse->mValue;
   responseOrVoid.get_PCacheResponse().body() = readStream;
 
-  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, streamControl);
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheParent::OnCacheMatchAll(RequestId aRequestId, nsresult aRv,
                              const nsTArray<SavedResponse>& aSavedResponses,
                              Manager::StreamList* aStreamList)
 {
   Manager::StreamControl* streamControl = nullptr;
@@ -174,17 +177,17 @@ CacheParent::OnCacheMatchAll(RequestId a
 
     PCacheReadStream readStream;
     streamControl =
       SerializeReadStream(streamControl, aSavedResponses[i].mBodyId,
                           aStreamList, &readStream);
     res->body() = readStream;
   }
 
-  unused << SendMatchAllResponse(aRequestId, aRv, responses, streamControl);
+  unused << SendMatchAllResponse(aRequestId, aRv, responses);
 }
 
 void
 CacheParent::OnCachePut(RequestId aRequestId, nsresult aRv)
 {
   unused << SendPutResponse(aRequestId, aRv);
   return;
 }
@@ -214,70 +217,62 @@ CacheParent::OnCacheKeys(RequestId aRequ
 
     PCacheReadStream readStream;
     streamControl =
       SerializeReadStream(streamControl, aSavedRequests[i].mBodyId,
                           aStreamList, &readStream);
     req->body() = readStream;
   }
 
-  unused << SendKeysResponse(aRequestId, aRv, requests, streamControl);
+  unused << SendKeysResponse(aRequestId, aRv, requests);
 }
 
 Manager::StreamControl*
 CacheParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
                                  const nsID& aId,
                                  Manager::StreamList* aStreamList,
                                  PCacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(aStreamList);
   MOZ_ASSERT(aReadStreamOut);
 
-  aReadStreamOut->id() = aId;
   nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
   MOZ_ASSERT(stream);
 
-  nsTArray<FileDescriptor> fds;
-  SerializeInputStream(stream, aReadStreamOut->params(), fds);
-
-  PFileDescriptorSetParent* fdSet = nullptr;
-  if (!fds.IsEmpty()) {
-    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
-    for (uint32_t i = 1; i < fds.Length(); ++i) {
-      unused << fdSet->SendAddFileDescriptor(fds[i]);
-    }
-  }
-
-  if (fdSet) {
-    aReadStreamOut->fds() = fdSet;
-  } else {
-    aReadStreamOut->fds() = void_t();
-  }
-
   if (!aStreamControl) {
     aStreamControl = new CacheStreamControlParent();
     DebugOnly<PCacheStreamControlParent*> actor =
       Manager()->SendPCacheStreamControlConstructor(aStreamControl);
     MOZ_ASSERT(aStreamControl == actor);
   }
 
   aStreamList->SetStreamControl(aStreamControl);
 
+  nsRefPtr<ReadStream> readStream = ReadStream::Create(aStreamControl,
+                                                       aId, stream);
+  readStream->Serialize(aReadStreamOut);
+
   return aStreamControl;
 }
 
 already_AddRefed<nsIInputStream>
 CacheParent::DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid)
 {
   if (aStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
     return nullptr;
   }
 
   const PCacheReadStream& readStream = aStreamOrVoid.get_PCacheReadStream();
 
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(readStream);
+  if (stream) {
+    printf_stderr("### ### CacheParent::DeserializeCacheStream() return ReadStream %p\n", stream.get());
+    return stream.forget();
+  }
+
   nsTArray<FileDescriptor> fds;
   if (readStream.fds().type() ==
       OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
 
     FileDescriptorSetParent* fdSetActor =
       static_cast<FileDescriptorSetParent*>(readStream.fds().get_PFileDescriptorSetParent());
     MOZ_ASSERT(fdSetActor);
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -354,18 +354,17 @@ CacheStorage::ActorDestroy(IProtocol& aA
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == &aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
 CacheStorage::RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                                const PCacheResponseOrVoid& aResponse,
-                                PCacheStreamControlChild* aStreamControl)
+                                const PCacheResponseOrVoid& aResponse)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   nsRefPtr<Promise> promise = RemoveRequestPromise(aRequestId);
   if (NS_WARN_IF(!promise)) {
     return;
   }
 
@@ -374,17 +373,17 @@ CacheStorage::RecvMatchResponse(RequestI
     return;
   }
 
   if (aResponse.type() == PCacheResponseOrVoid::Tvoid_t) {
     promise->MaybeReject(NS_ERROR_DOM_NOT_FOUND_ERR);
     return;
   }
 
-  nsRefPtr<Response> response = ToResponse(aResponse, aStreamControl);
+  nsRefPtr<Response> response = ToResponse(aResponse);
   promise->MaybeResolve(response);
 }
 
 void
 CacheStorage::RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -67,18 +67,17 @@ public:
 
   // nsIIPCbackgroundChildCreateCallback methods
   virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
   virtual void ActorFailed() MOZ_OVERRIDE;
 
   // CacheStorageChildListener methods
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor) MOZ_OVERRIDE;
   virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                           const PCacheResponseOrVoid& aResponse,
-                           PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                           const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual void RecvHasResponse(RequestId aRequestId, nsresult aRv,
                                bool aSuccess) MOZ_OVERRIDE;
   virtual void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
                                 PCacheChild* aActor) MOZ_OVERRIDE;
   virtual void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
                                   bool aSuccess) MOZ_OVERRIDE;
   virtual void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                                 const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -30,21 +30,20 @@ CacheStorageChild::ActorDestroy(ActorDes
   if (mListener) {
     mListener->ActorDestroy(*this);
   }
 }
 
 bool
 CacheStorageChild::RecvMatchResponse(const RequestId& aRequestId,
                                      const nsresult& aRv,
-                                     const PCacheResponseOrVoid& aResponseOrVoid,
-                                     PCacheStreamControlChild* aStreamControl)
+                                     const PCacheResponseOrVoid& aResponseOrVoid)
 {
   MOZ_ASSERT(mListener);
-  mListener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid, aStreamControl);
+  mListener->RecvMatchResponse(aRequestId, aRv, aResponseOrVoid);
   return true;
 }
 
 bool
 CacheStorageChild::RecvHasResponse(const RequestId& aRequestId,
                                    const nsresult& aRv,
                                    const bool& aSuccess)
 {
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -20,18 +20,17 @@ class PCacheChild;
 class CacheStorageChild MOZ_FINAL : public PCacheStorageChild
 {
 public:
   CacheStorageChild(CacheStorageChildListener& aListener);
   virtual ~CacheStorageChild();
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvMatchResponse(const RequestId& requestId,
                              const nsresult& aRv,
-                             const PCacheResponseOrVoid& response,
-                             PCacheStreamControlChild* aStreamControl) MOZ_OVERRIDE;
+                             const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
   virtual bool RecvHasResponse(const cache::RequestId& aRequestId,
                                const nsresult& aRv,
                                const bool& aSuccess) MOZ_OVERRIDE;
   virtual bool RecvOpenResponse(const cache::RequestId& aRequestId,
                                 const nsresult& aRv,
                                 PCacheChild* aActor) MOZ_OVERRIDE;
   virtual bool RecvDeleteResponse(const cache::RequestId& aRequestId,
                                   const nsresult& aRv,
diff --git a/dom/cache/CacheStorageChildListener.h b/dom/cache/CacheStorageChildListener.h
--- a/dom/cache/CacheStorageChildListener.h
+++ b/dom/cache/CacheStorageChildListener.h
@@ -19,26 +19,24 @@ namespace ipc {
   class IProtocol;
 }
 
 namespace dom {
 namespace cache {
 
 class PCacheChild;
 class PCacheResponseOrVoid;
-class PCacheStreamControlChild;
 
 class CacheStorageChildListener
 {
 public:
   virtual ~CacheStorageChildListener() { }
   virtual void ActorDestroy(mozilla::ipc::IProtocol& aActor)=0;
   virtual void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
-                                 const PCacheResponseOrVoid& aResponse,
-                                 PCacheStreamControlChild* aStreamControl)=0;
+                                 const PCacheResponseOrVoid& aResponse)=0;
   virtual void RecvHasResponse(cache::RequestId aRequestId, nsresult aRv,
                                bool aSuccess)=0;
   virtual void RecvOpenResponse(cache::RequestId aRequestId, nsresult aRv,
                                 PCacheChild* aActor)=0;
   virtual void RecvDeleteResponse(cache::RequestId aRequestId, nsresult aRv,
                                   bool aSuccess)=0;
   virtual void RecvKeysResponse(cache::RequestId aRequestId, nsresult aRv,
                                 const nsTArray<nsString>& aKeys)=0;
diff --git a/dom/cache/CacheStorageParent.cpp b/dom/cache/CacheStorageParent.cpp
--- a/dom/cache/CacheStorageParent.cpp
+++ b/dom/cache/CacheStorageParent.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStorageParent.h"
 
 #include "mozilla/dom/cache/CacheParent.h"
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 #include "mozilla/dom/cache/Manager.h"
+#include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "mozilla/ipc/PBackgroundParent.h"
 #include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "mozilla/DebugOnly.h"
 #include "mozilla/unused.h"
 #include "nsCOMPtr.h"
 
@@ -93,36 +94,35 @@ CacheStorageParent::OnStorageMatch(Reque
                                    const SavedResponse* aSavedResponse,
                                    Manager::StreamList* aStreamList)
 {
   PCacheResponseOrVoid responseOrVoid;
 
   // no match
   if (NS_FAILED(aRv) || !aSavedResponse) {
     responseOrVoid = void_t();
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   // match without body data to stream
   if (!aSavedResponse->mHasBodyId) {
     responseOrVoid = aSavedResponse->mValue;
-    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, nullptr);
+    unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
     return;
   }
 
   PCacheReadStream readStream;
-  Manager::StreamControl* streamControl =
-    SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
-                        &readStream);
+  SerializeReadStream(nullptr, aSavedResponse->mBodyId, aStreamList,
+                      &readStream);
 
   responseOrVoid = aSavedResponse->mValue;
   responseOrVoid.get_PCacheResponse().body() = readStream;
 
-  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid, streamControl);
+  unused << SendMatchResponse(aRequestId, aRv, responseOrVoid);
 }
 
 void
 CacheStorageParent::OnStorageHas(RequestId aRequestId, nsresult aRv,
                                  bool aCacheFound)
 {
   unused << SendHasResponse(aRequestId, aRv, aCacheFound);
 }
@@ -160,44 +160,30 @@ Manager::StreamControl*
 CacheStorageParent::SerializeReadStream(Manager::StreamControl *aStreamControl,
                                         const nsID& aId,
                                         Manager::StreamList* aStreamList,
                                         PCacheReadStream* aReadStreamOut)
 {
   MOZ_ASSERT(aStreamList);
   MOZ_ASSERT(aReadStreamOut);
 
-  aReadStreamOut->id() = aId;
   nsCOMPtr<nsIInputStream> stream = aStreamList->Extract(aId);
   MOZ_ASSERT(stream);
 
-  nsTArray<FileDescriptor> fds;
-  SerializeInputStream(stream, aReadStreamOut->params(), fds);
-
-  PFileDescriptorSetParent* fdSet = nullptr;
-  if (!fds.IsEmpty()) {
-    fdSet = Manager()->SendPFileDescriptorSetConstructor(fds[0]);
-    for (uint32_t i = 1; i < fds.Length(); ++i) {
-      unused << fdSet->SendAddFileDescriptor(fds[i]);
-    }
-  }
-
-  if (fdSet) {
-    aReadStreamOut->fds() = fdSet;
-  } else {
-    aReadStreamOut->fds() = void_t();
-  }
-
   if (!aStreamControl) {
     aStreamControl = new CacheStreamControlParent();
     DebugOnly<PCacheStreamControlParent*> actor =
       Manager()->SendPCacheStreamControlConstructor(aStreamControl);
     MOZ_ASSERT(aStreamControl == actor);
   }
 
   aStreamList->SetStreamControl(aStreamControl);
 
+  nsRefPtr<ReadStream> readStream = ReadStream::Create(aStreamControl,
+                                                       aId, stream);
+  readStream->Serialize(aReadStreamOut);
+
   return aStreamControl;
 }
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlChild.cpp b/dom/cache/CacheStreamControlChild.cpp
--- a/dom/cache/CacheStreamControlChild.cpp
+++ b/dom/cache/CacheStreamControlChild.cpp
@@ -2,32 +2,41 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 
+CacheStreamControlChild::CacheStreamControlChild()
+{
+}
+
+CacheStreamControlChild::~CacheStreamControlChild()
+{
+}
+
 void
-CacheStreamControlChild::AddListener(Listener* aListener)
+CacheStreamControlChild::AddListener(CacheStreamControlListener* aListener)
 {
   MOZ_ASSERT(aListener);
   mListeners.AppendElement(aListener);
 }
 
 void
-CacheStreamControlChild::RemoveListener(Listener* aListener)
+CacheStreamControlChild::RemoveListener(CacheStreamControlListener* aListener)
 {
   MOZ_ASSERT(aListener);
   mListeners.RemoveElement(aListener);
 }
 
 void
 CacheStreamControlChild::NoteClosed(const nsID& aId)
 {
@@ -39,31 +48,31 @@ CacheStreamControlChild::ActorDestroy(Ac
 {
   RecvCloseAll();
 }
 
 bool
 CacheStreamControlChild::RecvClose(const nsID& aId)
 {
   // defensive copy of list since may be modified as we close streams
-  nsTArray<Listener*> listeners(mListeners);
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
   for (uint32_t i = 0; i < listeners.Length(); ++i) {
     // note, multiple streams may exist for same ID
     if (listeners[i]->MatchId(aId)) {
       listeners[i]->CloseStream();
     }
   }
   return true;
 }
 
 bool
 CacheStreamControlChild::RecvCloseAll()
 {
   // defensive copy of list since may be modified as we close streams
-  nsTArray<Listener*> listeners(mListeners);
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
   for (uint32_t i = 0; i < listeners.Length(); ++i) {
     listeners[i]->CloseStream();
   }
   return true;
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -9,37 +9,35 @@
 
 #include "mozilla/dom/cache/PCacheStreamControlChild.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class CacheStreamControlListener;
+
 class CacheStreamControlChild : public PCacheStreamControlChild
 {
 public:
-  class Listener
-  {
-  public:
-    virtual void CloseStream()=0;
-    virtual bool MatchId(const nsID& aId)=0;
-  };
+  CacheStreamControlChild();
+  virtual ~CacheStreamControlChild();
 
-  void AddListener(Listener* aListener);
-  void RemoveListener(Listener* aListener);
+  void AddListener(CacheStreamControlListener* aListener);
+  void RemoveListener(CacheStreamControlListener* aListener);
 
   void NoteClosed(const nsID& aId);
 
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
 private:
-  nsTArray<Listener*> mListeners;
+  nsTArray<CacheStreamControlListener*> mListeners;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStreamControlChild_h
diff --git a/dom/cache/CacheStreamControlParent.cpp b/dom/cache/CacheStreamControlParent.cpp
--- a/dom/cache/CacheStreamControlParent.cpp
+++ b/dom/cache/CacheStreamControlParent.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 
 CacheStreamControlParent::CacheStreamControlParent()
@@ -19,16 +20,30 @@ CacheStreamControlParent::CacheStreamCon
 }
 
 CacheStreamControlParent::~CacheStreamControlParent()
 {
   MOZ_ASSERT(!mStreamList);
 }
 
 void
+CacheStreamControlParent::AddListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.AppendElement(aListener);
+}
+
+void
+CacheStreamControlParent::RemoveListener(CacheStreamControlListener* aListener)
+{
+  MOZ_ASSERT(aListener);
+  mListeners.RemoveElement(aListener);
+}
+
+void
 CacheStreamControlParent::ActorDestroy(ActorDestroyReason aReason)
 {
   MOZ_ASSERT(mStreamList);
   mStreamList->RemoveStreamControl(this);
   mStreamList = nullptr;
 }
 
 bool
@@ -44,26 +59,51 @@ CacheStreamControlParent::SetStreamList(
 {
   MOZ_ASSERT(!mStreamList);
   mStreamList = aStreamList;
 }
 
 void
 CacheStreamControlParent::Close(const nsID& aId)
 {
+  NotifyClose(aId);
   unused << SendClose(aId);
 }
 
 void
 CacheStreamControlParent::CloseAll()
 {
+  NotifyCloseAll();
   unused << SendCloseAll();
 }
 
 void
 CacheStreamControlParent::Shutdown()
 {
   unused << Send__delete__(this);
 }
 
+void
+CacheStreamControlParent::NotifyClose(const nsID& aId)
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    // note, multiple streams may exist for same ID
+    if (listeners[i]->MatchId(aId)) {
+      listeners[i]->CloseStream();
+    }
+  }
+}
+
+void
+CacheStreamControlParent::NotifyCloseAll()
+{
+  // defensive copy of list since may be modified as we close streams
+  nsTArray<CacheStreamControlListener*> listeners(mListeners);
+  for (uint32_t i = 0; i < listeners.Length(); ++i) {
+    listeners[i]->CloseStream();
+  }
+}
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/CacheStreamControlParent.h b/dom/cache/CacheStreamControlParent.h
--- a/dom/cache/CacheStreamControlParent.h
+++ b/dom/cache/CacheStreamControlParent.h
@@ -8,33 +8,42 @@
 #define mozilla_dom_cache_CacheStreamControlParent_h
 
 #include "mozilla/dom/cache/Manager.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+class CacheStreamControlListener;
+
 class CacheStreamControlParent : public Manager::StreamControl
 {
 public:
   CacheStreamControlParent();
   ~CacheStreamControlParent();
 
+  void AddListener(CacheStreamControlListener* aListener);
+  void RemoveListener(CacheStreamControlListener* aListener);
+
   // PCacheStreamControlParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvNoteClosed(const nsID& aId) MOZ_OVERRIDE;
 
   // Manager::StreamControl methods
   virtual void SetStreamList(Manager::StreamList* aStreamList) MOZ_OVERRIDE;
   virtual void Close(const nsID& aId) MOZ_OVERRIDE;
   virtual void CloseAll() MOZ_OVERRIDE;
   virtual void Shutdown() MOZ_OVERRIDE;
 
 private:
+  void NotifyClose(const nsID& aId);
+  void NotifyCloseAll();
+
   nsRefPtr<Manager::StreamList> mStreamList;
+  nsTArray<CacheStreamControlListener*> mListeners;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_CacheStreamControlParent_h
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -180,21 +180,23 @@ FileUtils::BodyStartWriteStream(const ns
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(exists)) { return NS_ERROR_FILE_ALREADY_EXISTS; }
 
   nsCOMPtr<nsIOutputStream> fileStream =
     FileOutputStream::Create(PERSISTENCE_TYPE_PERSISTENT,
                              aBaseDomain, aOrigin, tmpFile);
   if (NS_WARN_IF(!fileStream)) { return NS_ERROR_UNEXPECTED; }
 
+  // Note, we cannot auto-close the source stream here because some of
+  // our source streams must be closed on the PBackground worker thread.
   rv = NS_AsyncCopy(aSource, fileStream, NS_GetCurrentThread(),
                     NS_ASYNCCOPY_VIA_READSEGMENTS,
                     4096, // chunk size
                     aCallback, aClosure,
-                    true, true, // close streams
+                    false, true, // close streams
                     aCopyContextOut);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     fileStream->Close();
     return rv;
   }
 
   return rv;
 }
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -503,16 +503,19 @@ public:
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) MOZ_OVERRIDE
   {
     NS_ASSERT_OWNINGTHREAD(Action);
 
+    mRequestBodyStream = nullptr;
+    mResponseBodyStream = nullptr;
+
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
     Listener* listener = mManager->GetListener(mListenerId);
     mManager = nullptr;
     if (!listener) {
       return;
     }
     if (NS_FAILED(aRv)) {
diff --git a/dom/cache/PCache.ipdl b/dom/cache/PCache.ipdl
--- a/dom/cache/PCache.ipdl
+++ b/dom/cache/PCache.ipdl
@@ -1,18 +1,18 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
-include protocol PCacheStreamControl;
 include PCacheTypes;
 include protocol PFileDescriptorSet;
 
 include protocol PBlob; // FIXME: bug 792908
+include protocol PCacheStreamControl;
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCache
@@ -24,26 +24,23 @@ parent:
   MatchAll(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
   Add(RequestId requestId, PCacheRequest request);
   AddAll(RequestId requestId, PCacheRequest[] requests);
   Put(RequestId requestId, PCacheRequest request, PCacheResponse response);
   Delete(RequestId requestId, PCacheRequest request, PCacheQueryParams params);
   Keys(RequestId requestId, PCacheRequestOrVoid request, PCacheQueryParams params);
 
 child:
-  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse,
-                nullable PCacheStreamControl aStreamControl);
-  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses,
-                   nullable PCacheStreamControl aStreamControl);
+  MatchResponse(RequestId requestId, nsresult aRv, PCacheResponseOrVoid aResponse);
+  MatchAllResponse(RequestId requestId, nsresult aRv, PCacheResponse[] responses);
   AddResponse(RequestId requestId, nsresult aRv);
   AddAllResponse(RequestId requestId, nsresult aRv);
   PutResponse(RequestId requestId, nsresult aRv);
   DeleteResponse(RequestId requestId, nsresult aRv, bool success);
-  KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests,
-               nullable PCacheStreamControl aStreamControl);
+  KeysResponse(RequestId requestId, nsresult aRv, PCacheRequest[] requests);
 
 both:
   __delete__();
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/PCacheStorage.ipdl b/dom/cache/PCacheStorage.ipdl
--- a/dom/cache/PCacheStorage.ipdl
+++ b/dom/cache/PCacheStorage.ipdl
@@ -1,19 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackground;
 include protocol PCache;
-include protocol PCacheStreamControl;
 include PCacheTypes;
 include protocol PFileDescriptorSet;
 
 include protocol PBlob; // FIXME: bug 792908
+include protocol PCacheStreamControl;
 
 using mozilla::dom::cache::RequestId from "mozilla/dom/cache/IPCUtils.h";
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 protocol PCacheStorage
@@ -25,18 +25,17 @@ parent:
         PCacheQueryParams aParams);
   Has(RequestId aRequestId, nsString aKey);
   Open(RequestId aRequestId, nsString aKey);
   Delete(RequestId aRequestId, nsString aKey);
   Keys(RequestId aRequestId);
 
 child:
   MatchResponse(RequestId aRequestId, nsresult aRv,
-                PCacheResponseOrVoid aResponseOrVoid,
-                nullable PCacheStreamControl aStreamControl);
+                PCacheResponseOrVoid aResponseOrVoid);
   HasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   OpenResponse(RequestId aRequestId, nsresult aRv, nullable PCache aActor);
   DeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   KeysResponse(RequestId aRequestId, nsresult aRv, nsString[] aKeys);
 
 both:
   __delete__();
 };
diff --git a/dom/cache/PCacheTypes.ipdlh b/dom/cache/PCacheTypes.ipdlh
--- a/dom/cache/PCacheTypes.ipdlh
+++ b/dom/cache/PCacheTypes.ipdlh
@@ -1,12 +1,13 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+include protocol PCacheStreamControl;
 include PHeaders;
 include InputStreamParams;
 
 using HeadersGuardEnum from "mozilla/dom/FetchIPCUtils.h";
 using RequestCredentials from "mozilla/dom/FetchIPCUtils.h";
 using RequestMode from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::dom::ResponseType from "mozilla/dom/FetchIPCUtils.h";
 using mozilla::void_t from "ipc/IPCMessageUtils.h";
@@ -26,16 +27,17 @@ struct PCacheQueryParams
   nsString cacheName;
 };
 
 struct PCacheReadStream
 {
   nsID id;
   OptionalInputStreamParams params;
   OptionalFileDescriptorSet fds;
+  nullable PCacheStreamControl control;
 };
 
 union PCacheReadStreamOrVoid
 {
   void_t;
   PCacheReadStream;
 };
 
diff --git a/dom/cache/ReadStream.cpp b/dom/cache/ReadStream.cpp
--- a/dom/cache/ReadStream.cpp
+++ b/dom/cache/ReadStream.cpp
@@ -2,130 +2,343 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/ReadStream.h"
 
 #include "mozilla/unused.h"
+#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "mozilla/dom/cache/CacheStreamControlParent.h"
+#include "mozilla/dom/cache/PCacheStreamControlChild.h"
+#include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/ipc/FileDescriptor.h"
 #include "mozilla/ipc/FileDescriptorSetChild.h"
+#include "mozilla/ipc/FileDescriptorSetParent.h"
 #include "mozilla/ipc/InputStreamParams.h"
 #include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundParent.h"
+#include "mozilla/ipc/PFileDescriptorSetChild.h"
+#include "mozilla/ipc/PFileDescriptorSetParent.h"
 #include "nsIAsyncInputStream.h"
 #include "nsTArray.h"
 
+namespace {
+
+using mozilla::unused;
+using mozilla::void_t;
+using mozilla::dom::cache::CacheStreamControlChild;
+using mozilla::dom::cache::CacheStreamControlParent;
+using mozilla::dom::cache::PCacheReadStream;
+using mozilla::dom::cache::PCacheStreamControlChild;
+using mozilla::dom::cache::PCacheStreamControlParent;
+using mozilla::dom::cache::ReadStream;
+using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::PFileDescriptorSetChild;
+using mozilla::ipc::PFileDescriptorSetParent;
+
+class ReadStreamChild MOZ_FINAL : public ReadStream
+{
+public:
+  ReadStreamChild(PCacheStreamControlChild* aControl, const nsID& aId,
+                  nsIInputStream* aStream)
+    : ReadStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlChild*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual ~ReadStreamChild()
+  {
+    NoteClosed();
+  }
+
+  virtual void NoteClosed() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->NoteClosed(mId);
+    mControl->RemoveListener(this);
+  }
+
+  virtual void Forget() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+  }
+
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    aReadStreamOut->controlParent() = nullptr;
+    aReadStreamOut->controlChild() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    printf_stderr("### ### ReadStreamChild::SerializeFds() %lu fds\n", fds.Length());
+
+    PFileDescriptorSetChild* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  CacheStreamControlChild* mControl;
+};
+
+class ReadStreamParent MOZ_FINAL : public ReadStream
+{
+public:
+  ReadStreamParent(PCacheStreamControlParent* aControl, const nsID& aId,
+                  nsIInputStream* aStream)
+    : ReadStream(aId, aStream)
+    , mControl(static_cast<CacheStreamControlParent*>(aControl))
+  {
+    MOZ_ASSERT(mControl);
+    mControl->AddListener(this);
+  }
+
+  virtual ~ReadStreamParent()
+  {
+    NoteClosed();
+  }
+
+  virtual void NoteClosed() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RecvNoteClosed(mId);
+    mControl->RemoveListener(this);
+  }
+
+  virtual void Forget() MOZ_OVERRIDE
+  {
+    if (mClosed) {
+      return;
+    }
+
+    mClosed = true;
+    mControl->RemoveListener(this);
+  }
+
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut) MOZ_OVERRIDE
+  {
+    MOZ_ASSERT(aReadStreamOut);
+    aReadStreamOut->controlChild() = nullptr;
+    aReadStreamOut->controlParent() = mControl;
+  }
+
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<FileDescriptor>& fds) MOZ_OVERRIDE
+  {
+    printf_stderr("### ### ReadStreamParent::SerializeFds() %lu fds\n", fds.Length());
+
+    PFileDescriptorSetParent* fdSet = nullptr;
+    if (!fds.IsEmpty()) {
+      fdSet = mControl->Manager()->SendPFileDescriptorSetConstructor(fds[0]);
+      for (uint32_t i = 1; i < fds.Length(); ++i) {
+        unused << fdSet->SendAddFileDescriptor(fds[i]);
+      }
+    }
+
+    if (fdSet) {
+      aReadStreamOut->fds() = fdSet;
+    } else {
+      aReadStreamOut->fds() = void_t();
+    }
+  }
+
+private:
+  CacheStreamControlParent* mControl;
+};
+
+} // anonymous namespace
+
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::ipc::FileDescriptor;
 using mozilla::ipc::FileDescriptorSetChild;
+using mozilla::ipc::FileDescriptorSetParent;
 using mozilla::ipc::InputStreamParams;
 using mozilla::ipc::OptionalFileDescriptorSet;
+using mozilla::ipc::PFileDescriptorSetChild;
 
 NS_IMPL_ISUPPORTS(mozilla::dom::cache::ReadStream, nsIInputStream,
-                                                   nsIIPCSerializableInputStream);
+                                                   ReadStream);
 
 // static
 already_AddRefed<ReadStream>
-ReadStream::Create(PCacheStreamControlChild* aControl,
-                   const PCacheReadStreamOrVoid& aReadStreamOrVoid)
+ReadStream::Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid)
 {
-  if (!aControl || aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
     return nullptr;
   }
 
-  return Create(aControl, aReadStreamOrVoid.get_PCacheReadStream());
+  return Create(aReadStreamOrVoid.get_PCacheReadStream());
 }
 
 // static
 already_AddRefed<ReadStream>
-ReadStream::Create(PCacheStreamControlChild* aControl,
-                   const PCacheReadStream& aReadStream)
+ReadStream::Create(const PCacheReadStream& aReadStream)
 {
-  MOZ_ASSERT(aControl);
+  if (!aReadStream.controlChild() && !aReadStream.controlParent()) {
+    return nullptr;
+  }
 
   nsTArray<FileDescriptor> fds;
   if (aReadStream.fds().type() ==
       OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
 
+    printf_stderr("### ### ReadStream::Create() child fds\n");
+
     FileDescriptorSetChild* fdSetActor =
       static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
     MOZ_ASSERT(fdSetActor);
 
     fdSetActor->ForgetFileDescriptors(fds);
     MOZ_ASSERT(!fds.IsEmpty());
 
+    printf_stderr("### ### ReadStream::Create() child delete fdset actor\n");
+    unused << fdSetActor->Send__delete__(fdSetActor);
+  } else if (aReadStream.fds().type() ==
+      OptionalFileDescriptorSet::TPFileDescriptorSetParent) {
+
+    printf_stderr("### ### ReadStream::Create() parent fds\n");
+
+    FileDescriptorSetParent* fdSetActor =
+      static_cast<FileDescriptorSetParent*>(aReadStream.fds().get_PFileDescriptorSetParent());
+    MOZ_ASSERT(fdSetActor);
+
+    fdSetActor->ForgetFileDescriptors(fds);
+    MOZ_ASSERT(!fds.IsEmpty());
+
+    printf_stderr("### ### ReadStream::Create() parent delete fdset actor\n");
     unused << fdSetActor->Send__delete__(fdSetActor);
   }
 
+  printf_stderr("### ### ReadStream::Create() got %lu fds\n", fds.Length());
+
   nsCOMPtr<nsIInputStream> stream =
     DeserializeInputStream(aReadStream.params(), fds);
 
   if (!stream) {
     return nullptr;
   }
 
   // Currently we expect all cache read streams to be blocking file streams.
 #ifdef DEBUG
   nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
   MOZ_ASSERT(!asyncStream);
 #endif
 
-  nsRefPtr<ReadStream> ref = new ReadStream(aControl, aReadStream.id(), stream);
+  nsRefPtr<ReadStream> ref;
+
+  if (aReadStream.controlChild()) {
+    ref = new ReadStreamChild(aReadStream.controlChild(), aReadStream.id(),
+                              stream);
+  } else {
+    ref = new ReadStreamParent(aReadStream.controlParent(), aReadStream.id(),
+                               stream);
+  }
+
+  printf_stderr("### ### ReadStream::Create() return %p\n", ref.get());
+
   return ref.forget();
 }
 
+// static
+already_AddRefed<ReadStream>
+ReadStream::Create(PCacheStreamControlParent* aControl, const nsID& aId,
+                   nsIInputStream* aStream)
+{
+  nsRefPtr<ReadStream> ref = new ReadStreamParent(aControl, aId, aStream);
+  return ref.forget();
+}
+
+void
+ReadStream::Serialize(PCacheReadStreamOrVoid* aReadStreamOut)
+{
+  MOZ_ASSERT(aReadStreamOut);
+  PCacheReadStream stream;
+  Serialize(&stream);
+  *aReadStreamOut = stream;
+}
+
+void
+ReadStream::Serialize(PCacheReadStream* aReadStreamOut)
+{
+  MOZ_ASSERT(aReadStreamOut);
+  MOZ_ASSERT(!mClosed);
+
+  aReadStreamOut->id() = mId;
+  SerializeControl(aReadStreamOut);
+
+  nsTArray<FileDescriptor> fds;
+  SerializeInputStream(mStream, aReadStreamOut->params(), fds);
+
+  SerializeFds(aReadStreamOut, fds);
+
+  // We're passing ownership across the IPC barrier with the control, so
+  // do not signal that the stream is closed here.
+  Forget();
+}
+
 void
 ReadStream::CloseStream()
 {
   Close();
 }
 
 bool
 ReadStream::MatchId(const nsID& aId)
 {
   return mId.Equals(aId);
 }
 
-ReadStream::ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
-                       nsIInputStream* aStream)
-  : mControl(static_cast<CacheStreamControlChild*>(aControl))
-  , mId(aId)
+ReadStream::ReadStream(const nsID& aId, nsIInputStream* aStream)
+  : mId(aId)
   , mStream(aStream)
   , mClosed(false)
 {
-  MOZ_ASSERT(mControl);
   MOZ_ASSERT(mStream);
-
-  mSerializable = do_QueryInterface(mStream);
-  MOZ_ASSERT(mSerializable);
-
-  mControl->AddListener(this);
 }
 
 ReadStream::~ReadStream()
 {
-  NoteClosed();
-}
-
-void
-ReadStream::NoteClosed()
-{
-  if (mClosed) {
-    return;
-  }
-
-  mClosed = true;
-  mControl->NoteClosed(mId);
-  mControl->RemoveListener(this);
 }
 
 NS_IMETHODIMP
 ReadStream::Close()
 {
   NoteClosed();
   return mStream->Close();
 }
@@ -174,25 +387,11 @@ ReadStream::ReadSegments(nsWriteSegmentF
 }
 
 NS_IMETHODIMP
 ReadStream::IsNonBlocking(bool* aNonBlockingOut)
 {
   return mStream->IsNonBlocking(aNonBlockingOut);
 }
 
-void
-ReadStream::Serialize(InputStreamParams& aParams, FileDescriptorArray& aFds)
-{
-  // TODO: will lose track of when stream underlying fd closes... must we accept this?
-  mSerializable->Serialize(aParams, aFds);
-}
-
-bool
-ReadStream::Deserialize(const InputStreamParams& aParams,
-                        const FileDescriptorArray& aFds)
-{
-  return mSerializable->Deserialize(aParams, aFds);
-}
-
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/ReadStream.h b/dom/cache/ReadStream.h
--- a/dom/cache/ReadStream.h
+++ b/dom/cache/ReadStream.h
@@ -2,65 +2,81 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_ReadStream_h
 #define mozilla_dom_cache_ReadStream_h
 
-#include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "mozilla/dom/cache/CacheStreamControlListener.h"
+#include "mozilla/ipc/FileDescriptor.h"
 #include "nsCOMPtr.h"
 #include "nsID.h"
 #include "nsIInputStream.h"
-#include "nsIIPCSerializableInputStream.h"
 #include "nsISupportsImpl.h"
 
 template<class T> class nsTArray;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class PCacheReadStream;
 class PCacheReadStreamOrVoid;
+class PCacheStreamControlParent;
+
+// IID for the dom::cache::ReadStream interface
+#define NS_DOM_CACHE_IID \
+{0x8e5da7c9, 0x0940, 0x4f1d, \
+  {0x97, 0x25, 0x5c, 0x59, 0x38, 0xdd, 0xb9, 0x9f}}
 
 class ReadStream : public nsIInputStream
-                 , public nsIIPCSerializableInputStream
-                 , public CacheStreamControlChild::Listener
+                 , public CacheStreamControlListener
 {
 public:
   static already_AddRefed<ReadStream>
-  Create(PCacheStreamControlChild* aControl,
-         const PCacheReadStreamOrVoid& aReadStreamOrVoid);
+  Create(const PCacheReadStreamOrVoid& aReadStreamOrVoid);
 
   static already_AddRefed<ReadStream>
-  Create(PCacheStreamControlChild* aControl,
-         const PCacheReadStream& aReadStream);
+  Create(const PCacheReadStream& aReadStream);
 
-  // CacheStreamControlChild::Listener methods
+  static already_AddRefed<ReadStream>
+  Create(PCacheStreamControlParent* aControl, const nsID& aId,
+         nsIInputStream* aStream);
+
+  void Serialize(PCacheReadStreamOrVoid* aReadStreamOut);
+  void Serialize(PCacheReadStream* aReadStreamOut);
+
+  // CacheStreamControlListener methods
   virtual void CloseStream() MOZ_OVERRIDE;
   virtual bool MatchId(const nsID& aId) MOZ_OVERRIDE;
 
-private:
-  ReadStream(PCacheStreamControlChild* aControl, const nsID& aId,
-             nsIInputStream* aStream);
+protected:
+  ReadStream(const nsID& aId, nsIInputStream* aStream);
   virtual ~ReadStream();
 
-  void NoteClosed();
+  virtual void NoteClosed()=0;
+  virtual void Forget()=0;
+  virtual void SerializeControl(PCacheReadStream* aReadStreamOut)=0;
 
-  CacheStreamControlChild* mControl;
+  virtual void
+  SerializeFds(PCacheReadStream* aReadStreamOut,
+               const nsTArray<mozilla::ipc::FileDescriptor>& fds)=0;
+
   const nsID mId;
   nsCOMPtr<nsIInputStream> mStream;
-  nsCOMPtr<nsIIPCSerializableInputStream> mSerializable;
   bool mClosed;
 
 public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_DOM_CACHE_IID);
+
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIINPUTSTREAM
-  NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
 };
 
+NS_DEFINE_STATIC_IID_ACCESSOR(ReadStream, NS_DOM_CACHE_IID);
+
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_ReadStream_h
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -9,16 +9,17 @@
 #include "mozilla/unused.h"
 #include "mozilla/dom/CacheBinding.h"
 #include "mozilla/dom/InternalRequest.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/cache/PCacheTypes.h"
 #include "mozilla/dom/cache/ReadStream.h"
 #include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/FileDescriptorSetChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
@@ -103,18 +104,20 @@ ProcessURL(nsAString& aUrl, bool* aSchem
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 using mozilla::unused;
 using mozilla::void_t;
 using mozilla::ipc::BackgroundChild;
 using mozilla::ipc::FileDescriptor;
+using mozilla::ipc::FileDescriptorSetChild;
 using mozilla::ipc::PFileDescriptorSetChild;
 using mozilla::ipc::PBackgroundChild;
+using mozilla::ipc::OptionalFileDescriptorSet;
 
 void
 TypeUtils::ToPCacheRequest(PCacheRequest& aOut,
                            const RequestOrScalarValueString& aIn, bool aReadBody,
                            ErrorResult& aRv)
 {
   AutoJSAPI jsapi;
   jsapi.Init(GetGlobalObject());
@@ -324,18 +327,17 @@ TypeUtils::ToPCacheQueryParams(PCacheQue
   if (aOut.cacheNameSet()) {
     aOut.cacheName() = aIn.mCacheName.Value();
   } else {
     aOut.cacheName() = NS_LITERAL_STRING("");
   }
 }
 
 already_AddRefed<Response>
-TypeUtils::ToResponse(const PCacheResponse& aIn,
-                      PCacheStreamControlChild* aStreamControl)
+TypeUtils::ToResponse(const PCacheResponse& aIn)
 {
   nsRefPtr<InternalResponse> ir;
   switch (aIn.type())
   {
     case ResponseType::Error:
       ir = InternalResponse::NetworkError();
       break;
     case ResponseType::Opaque:
@@ -367,64 +369,97 @@ TypeUtils::ToResponse(const PCacheRespon
 
   nsRefPtr<InternalHeaders> internalHeaders =
     new InternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
   ir->Headers()->SetGuard(aIn.headersGuard(), result);
   ir->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
-  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aStreamControl,
-                                                       aIn.body());
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
   ir->SetBody(stream);
 
   nsRefPtr<Response> ref = new Response(GetGlobalObject(), ir);
   return ref.forget();
 }
 
 already_AddRefed<Request>
-TypeUtils::ToRequest(const PCacheRequest& aIn,
-                     PCacheStreamControlChild* aStreamControl)
+TypeUtils::ToRequest(const PCacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
   internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
   internalRequest->SetReferrer(NS_ConvertUTF16toUTF8(aIn.referrer()));
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
 
   nsRefPtr<InternalHeaders> internalHeaders =
     new InternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
   internalRequest->Headers()->SetGuard(aIn.headersGuard(), result);
   internalRequest->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
 
-  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aStreamControl,
-                                                       aIn.body());
+  nsCOMPtr<nsIInputStream> stream = ReadStream::Create(aIn.body());
 
   internalRequest->SetBody(stream);
 
   nsRefPtr<Request> request = new Request(GetGlobalObject(), internalRequest);
   return request.forget();
 }
 
 void
+TypeUtils::CleanupChildFds(PCacheReadStreamOrVoid& aReadStreamOrVoid)
+{
+  if (aReadStreamOrVoid.type() == PCacheReadStreamOrVoid::Tvoid_t) {
+    return;
+  }
+
+  CleanupChildFds(aReadStreamOrVoid.get_PCacheReadStream());
+}
+
+void
+TypeUtils::CleanupChildFds(PCacheReadStream& aReadStream)
+{
+  if (aReadStream.fds().type() !=
+      OptionalFileDescriptorSet::TPFileDescriptorSetChild) {
+    return;
+  }
+
+  nsTArray<FileDescriptor> fds;
+
+  FileDescriptorSetChild* fdSetActor =
+    static_cast<FileDescriptorSetChild*>(aReadStream.fds().get_PFileDescriptorSetChild());
+  MOZ_ASSERT(fdSetActor);
+
+  fdSetActor->ForgetFileDescriptors(fds);
+}
+
+void
 TypeUtils::SerializeCacheStream(nsIInputStream* aStream,
                                 PCacheReadStreamOrVoid* aStreamOut,
                                 ErrorResult& aRv)
 {
   MOZ_ASSERT(aStreamOut);
   if (!aStream) {
     *aStreamOut = void_t();
     return;
   }
 
+  nsRefPtr<ReadStream> controlled = do_QueryObject(aStream);
+  if (controlled) {
+    controlled->Serialize(aStreamOut);
+    return;
+  }
+
   PCacheReadStream readStream;
+  readStream.controlChild() = nullptr;
+  readStream.controlParent() = nullptr;
+
   nsTArray<FileDescriptor> fds;
   SerializeInputStream(aStream, readStream.params(), fds);
 
   PFileDescriptorSetChild* fdSet = nullptr;
   if (!fds.IsEmpty()) {
     // We should not be serializing until we have an actor ready
     PBackgroundChild* manager = BackgroundChild::GetForCurrentThread();
     MOZ_ASSERT(manager);
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -24,16 +24,17 @@ class InternalRequest;
 class Request;
 class RequestOrScalarValueString;
 class Response;
 template<typename T> class Optional;
 
 namespace cache {
 
 class PCacheQueryParams;
+class PCacheReadStream;
 class PCacheReadStreamOrVoid;
 class PCacheRequest;
 class PCacheRequestOrVoid;
 class PCacheResponse;
 class PCacheStreamControlChild;
 
 class TypeUtils
 {
@@ -67,22 +68,23 @@ protected:
 
   void
   ToPCacheResponse(PCacheResponse& aOut, Response& aIn, ErrorResult& aRv);
 
   void
   ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn);
 
   already_AddRefed<Response>
-  ToResponse(const PCacheResponse& aIn,
-             PCacheStreamControlChild* aStreamControl);
+  ToResponse(const PCacheResponse& aIn);
 
   already_AddRefed<Request>
-  ToRequest(const PCacheRequest& aIn,
-            PCacheStreamControlChild* aStreamControl);
+  ToRequest(const PCacheRequest& aIn);
+
+  void CleanupChildFds(PCacheReadStreamOrVoid& aRequest);
+  void CleanupChildFds(PCacheReadStream& aReadStream);
 
 private:
   void
   ToPCacheRequest(const GlobalObject& aGlobal, PCacheRequest& aOut,
                   const RequestOrScalarValueString& aIn, bool aReadBody,
                   ErrorResult& aRv);
 
   void
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -10,16 +10,17 @@ EXPORTS.mozilla.dom.cache += [
     'CacheChild.h',
     'CacheChildListener.h',
     'CacheParent.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageChildListener.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
+    'CacheStreamControlListener.h',
     'CacheStreamControlParent.h',
     'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ReadStream.h',
diff --git a/dom/tests/mochitest/cache/test_cache.js b/dom/tests/mochitest/cache/test_cache.js
--- a/dom/tests/mochitest/cache/test_cache.js
+++ b/dom/tests/mochitest/cache/test_cache.js
@@ -32,18 +32,28 @@ caches.open('snafu').then(function(openC
 }).then(function(snafu) {
   return Promise.all([snafu, snafu.keys()]);
 }).then(function(args) {
   var snafu = args[0];
   var keys = args[1];
   is(1, keys.length, 'cache.keys() should resolve to an array of length 1');
   ok(keys[0] instanceof Request, 'key should be a Request');
   ok(keys[0].url.match(/cachekey$/), 'Request URL should match original');
-  return snafu.match(keys[0]);
-}).then(function(response) {
+  return Promise.all([snafu, snafu.match(keys[0])]);
+}).then(function(args) {
+  var snafu = args[0];
+  var response = args[1];
   ok(response instanceof Response, 'value should be a Response');
   is(response.status, 200, 'Response status should be 200');
+  dump("### ### got first match, start second put\n");
+  return Promise.all([snafu, snafu.put('./cachekey2', response)]);
+}).then(function(args) {
+  var snafu = args[0]
+  dump("### ### second put done, start second match\n");
+  return snafu.match('./cachekey2');
+}).then(function(response) {
+  dump("### ### got second match\n");
   return response.text().then(function(v) {
     is(v, "Hello world", "Response body should match original");
   });
 }).then(function() {
   workerTestDone();
 })
