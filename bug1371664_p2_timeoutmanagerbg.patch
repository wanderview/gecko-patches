# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  9ac956132a64dea3701341b89da50aacb56f8b11
Bug 1371664 P2 Make nsGlobalWindow::SetIsBackground() call new TimeoutManager::UpdateBackgroundState(). r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -1147,16 +1147,24 @@ TimeoutManager::Thaw()
 
   ForEachUnorderedTimeout([&](Timeout* aTimeout) {
     // Set When() back to the time when the timer is supposed to fire.
     aTimeout->SetWhenOrTimeRemaining(now, aTimeout->TimeRemaining());
     MOZ_DIAGNOSTIC_ASSERT(!aTimeout->When().IsNull());
   });
 }
 
+void
+TimeoutManager::UpdateBackgroundState()
+{
+  if (!IsBackground()) {
+    ResetTimersForThrottleReduction();
+  }
+}
+
 bool
 TimeoutManager::IsTimeoutTracking(uint32_t aTimeoutId)
 {
   return mTrackingTimeouts.ForEachAbortable([&](Timeout* aTimeout) {
       return aTimeout->mTimeoutId == aTimeoutId;
     });
 }
 
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -72,16 +72,20 @@ public:
 
   // These four methods are intended to be called from the corresponding methods
   // on nsGlobalWindow.
   void Suspend();
   void Resume();
   void Freeze();
   void Thaw();
 
+  // This should be called by nsGlobalWindow when the window might have moved
+  // to the background or foreground.
+  void UpdateBackgroundState();
+
   // Initialize TimeoutManager before the first time it is accessed.
   static void Initialize();
 
   // Exposed only for testing
   bool IsTimeoutTracking(uint32_t aTimeoutId);
 
   // The document finished loading
   void OnDocumentLoaded();
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -10665,33 +10665,33 @@ nsGlobalWindow::IsTopLevelWindowActive()
    nsCOMPtr<nsPIDOMWindowOuter> domWindow = rootItem->GetWindow();
    return domWindow && domWindow->IsActive();
 }
 
 void nsGlobalWindow::SetIsBackground(bool aIsBackground)
 {
   MOZ_ASSERT(IsOuterWindow());
 
-  bool resetTimers = (!aIsBackground && AsOuter()->IsBackground());
+  bool changed = aIsBackground != AsOuter()->IsBackground();
   nsPIDOMWindow::SetIsBackground(aIsBackground);
 
   nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
 
+  if (inner && changed) {
+    inner->mTimeoutManager->UpdateBackgroundState();
+  }
+
   if (aIsBackground) {
-    MOZ_ASSERT(!resetTimers);
     // Notify gamepadManager we are at the background window,
     // we need to stop vibrate.
     if (inner) {
       inner->StopGamepadHaptics();
     }
     return;
   } else if (inner) {
-    if (resetTimers) {
-      inner->mTimeoutManager->ResetTimersForThrottleReduction();
-    }
     inner->SyncGamepadState();
   }
 }
 
 void nsGlobalWindow::MaybeUpdateTouchState()
 {
   FORWARD_TO_INNER_VOID(MaybeUpdateTouchState, ());
 
