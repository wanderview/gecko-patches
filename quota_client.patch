# HG changeset patch
# Parent ba71ba81175fda5a6f9513b3d66f562d87e1879c
# User Ben Kelly <ben@wanderview.com>
Implement a basic QuotaManager Client for Cache.

diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -82,23 +82,16 @@ DBAction::OpenConnection(const QuotaInfo
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = dbFile->Exists(&exists);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  nsCOMPtr<nsIFile> dbTmpDir;
-  rv = aDBDir->Clone(getter_AddRefs(dbTmpDir));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = dbTmpDir->Append(NS_LITERAL_STRING("db"));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
   // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
   //      but this is what IDB does to access mozIStorageConnection so
   //      it seems at least this corner case mostly works.
   // TODO: move this to main thread where GetInfoFromPrincipal() is executed
   nsCOMPtr<nsIURI> uri;
   rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -119,28 +112,16 @@ DBAction::OpenConnection(const QuotaInfo
     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
   if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
 
   rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
   if (rv == NS_ERROR_FILE_CORRUPTED) {
     dbFile->Remove(false);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = dbTmpDir->Exists(&exists);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    if (exists) {
-      bool isDir;
-      rv = dbTmpDir->IsDirectory(&isDir);
-      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-      if (NS_WARN_IF(!isDir)) { return NS_ERROR_UNEXPECTED; }
-      rv = dbTmpDir->Remove(true);
-      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    }
-
     rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   MOZ_ASSERT(*aConnOut);
   return rv;
 }
 
 SyncDBAction::SyncDBAction(Mode aMode)
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
new file mode 100644
--- /dev/null
+++ b/dom/cache/QuotaClient.cpp
@@ -0,0 +1,211 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/cache/QuotaClient.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/dom/quota/UsageInfo.h"
+#include "nsIFile.h"
+#include "nsISimpleEnumerator.h"
+
+namespace {
+
+using mozilla::dom::quota::UsageInfo;
+
+static nsresult
+GetBodyUsage(nsIFile* aDir, UsageInfo* aUsageInfo)
+{
+  nsCOMPtr<nsISimpleEnumerator> entries;
+  nsresult rv = aDir->GetDirectoryEntries(getter_AddRefs(entries));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMore;
+  while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+         !aUsageInfo->Canceled()) {
+    nsCOMPtr<nsISupports> entry;
+    rv = entries->GetNext(getter_AddRefs(entry));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+    if (!file) { return NS_NOINTERFACE; }
+
+    bool isDir;
+    rv = file->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (isDir) {
+      rv = GetBodyUsage(file, aUsageInfo);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      continue;
+    }
+
+    int64_t fileSize;
+    rv = file->GetFileSize(&fileSize);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    MOZ_ASSERT(fileSize >= 0);
+
+    aUsageInfo->AppendToFileUsage(fileSize);
+  }
+
+  return NS_OK;
+}
+
+} // anonymous namespace;
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+using mozilla::dom::quota::Client;
+using mozilla::dom::quota::PersistenceType;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::UsageInfo;
+
+Client*
+QuotaClient::Create()
+{
+  return new QuotaClient();
+}
+
+Client::Type
+QuotaClient::GetType()
+{
+  return DOMCACHE;
+}
+
+nsresult
+QuotaClient::InitOrigin(PersistenceType aPersistenceType,
+                        const nsACString& aGroup, const nsACString& aOrigin,
+                        UsageInfo* aUsageInfo)
+{
+  return NS_OK;
+}
+
+nsresult
+QuotaClient::GetUsageForOrigin(PersistenceType aPersistenceType,
+                               const nsACString& aGroup,
+                               const nsACString& aOrigin, UsageInfo* aUsageInfo)
+{
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+
+  nsCOMPtr<nsIFile> dir;
+  nsresult rv = qm->GetDirectoryForOrigin(aPersistenceType, aOrigin,
+                                          getter_AddRefs(dir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dir->Append(NS_LITERAL_STRING(DOMCACHE_DIRECTORY_NAME));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  DebugOnly<bool> exists;
+  MOZ_ASSERT(NS_SUCCEEDED(dir->Exists(&exists)) && exists);
+
+  nsCOMPtr<nsISimpleEnumerator> entries;
+  rv = dir->GetDirectoryEntries(getter_AddRefs(entries));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMore;
+  while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+         !aUsageInfo->Canceled()) {
+    nsCOMPtr<nsISupports> entry;
+    rv = entries->GetNext(getter_AddRefs(entry));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+    if (!file) { return NS_NOINTERFACE; }
+
+    nsAutoString leafName;
+    rv = file->GetLeafName(leafName);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool isDir;
+    rv = file->IsDirectory(&isDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    if (isDir) {
+      if (leafName.EqualsLiteral("morgue")) {
+        rv = GetBodyUsage(file, aUsageInfo);
+      } else {
+        NS_WARNING("Unknown Cache directory found!");
+      }
+
+      continue;
+    }
+
+    // Ignore transient sqlite files
+    if (leafName.EqualsLiteral("db.sqlite-journal") ||
+        leafName.EqualsLiteral("db.sqlite-shm") ||
+        leafName.Find(NS_LITERAL_CSTRING("db.sqlite-mj"), false, 0, 0) == 0) {
+      continue;
+    }
+
+    if (leafName.EqualsLiteral("db.sqlite") ||
+        leafName.EqualsLiteral("db.sqlite-wal")) {
+      int64_t fileSize;
+      rv = file->GetFileSize(&fileSize);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+      MOZ_ASSERT(fileSize >= 0);
+
+      aUsageInfo->AppendToDatabaseUsage(fileSize);
+      continue;
+    }
+
+    NS_WARNING("Unknown Cache file found!");
+  }
+
+  return NS_OK;
+}
+
+void
+QuotaClient::OnOriginClearCompleted(PersistenceType aPersistenceType,
+                                    const nsACString& aOrigin)
+{
+}
+
+void
+QuotaClient::ReleaseIOThreadObjects()
+{
+  // nothing to do
+}
+
+bool
+QuotaClient::IsFileServiceUtilized()
+{
+  return false;
+}
+
+bool
+QuotaClient::IsTransactionServiceActivated()
+{
+  return false;
+}
+
+void
+QuotaClient::WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
+                                       nsIRunnable* aCallback)
+{
+  // nothing to do
+}
+
+void
+QuotaClient::ShutdownTransactionService()
+{
+  // nothing to do
+}
+
+QuotaClient::QuotaClient()
+{
+}
+
+QuotaClient::~QuotaClient()
+{
+}
+
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/QuotaClient.h b/dom/cache/QuotaClient.h
new file mode 100644
--- /dev/null
+++ b/dom/cache/QuotaClient.h
@@ -0,0 +1,61 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_cache_QuotaClient_h
+#define mozilla_dom_cache_QuotaClient_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/quota/Client.h"
+
+namespace mozilla {
+namespace dom {
+namespace cache {
+
+class QuotaClient MOZ_FINAL : public quota::Client
+{
+public:
+  static quota::Client*
+  Create();
+
+  // quota::Client methods
+  Type GetType() MOZ_OVERRIDE;
+
+  nsresult InitOrigin(quota::PersistenceType aPersistenceType,
+                      const nsACString& aGroup, const nsACString& aOrigin,
+                      quota::UsageInfo* aUsageInfo) MOZ_OVERRIDE;
+
+  nsresult GetUsageForOrigin(quota::PersistenceType aPersistenceType,
+                             const nsACString& aGroup,
+                             const nsACString& aOrigin,
+                             quota::UsageInfo* aUsageInfo) MOZ_OVERRIDE;
+
+  void OnOriginClearCompleted(quota::PersistenceType aPersistenceType,
+                              const nsACString& aOrigin) MOZ_OVERRIDE;
+
+  void ReleaseIOThreadObjects() MOZ_OVERRIDE;
+
+  bool IsFileServiceUtilized() MOZ_OVERRIDE;
+
+  bool IsTransactionServiceActivated() MOZ_OVERRIDE;
+
+  void WaitForStoragesToComplete(nsTArray<nsIOfflineStorage*>& aStorages,
+                                 nsIRunnable* aCallback) MOZ_OVERRIDE;
+
+  void ShutdownTransactionService() MOZ_OVERRIDE;
+
+private:
+  QuotaClient();
+  ~QuotaClient();
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(mozilla::dom::cache::QuotaClient)
+};
+
+} // namespace cache
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_cache_QuotaClient_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -21,16 +21,17 @@ EXPORTS.mozilla.dom.cache += [
     'DBAction.h',
     'DBSchema.h',
     'FetchPut.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
     'PrincipalVerifier.h',
+    'QuotaClient.h',
     'ReadStream.h',
     'SavedTypes.h',
     'ShutdownObserver.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 SOURCES += [
@@ -46,16 +47,17 @@ SOURCES += [
     'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FetchPut.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'PrincipalVerifier.cpp',
+    'QuotaClient.cpp',
     'ReadStream.cpp',
     'ShutdownObserver.cpp',
     'TypeUtils.cpp',
 ]
 
 IPDL_SOURCES += [
     'CacheInitData.ipdlh',
     'PCache.ipdl',
diff --git a/dom/quota/Client.h b/dom/quota/Client.h
--- a/dom/quota/Client.h
+++ b/dom/quota/Client.h
@@ -11,16 +11,17 @@
 
 #include "PersistenceType.h"
 
 class nsIOfflineStorage;
 class nsIRunnable;
 
 #define IDB_DIRECTORY_NAME "idb"
 #define ASMJSCACHE_DIRECTORY_NAME "asmjs"
+#define DOMCACHE_DIRECTORY_NAME "cache"
 
 BEGIN_QUOTA_NAMESPACE
 
 class OriginOrPatternString;
 class UsageInfo;
 
 // An abstract interface for quota manager clients.
 // Each storage API must provide an implementation of this interface in order
@@ -34,16 +35,17 @@ public:
   NS_IMETHOD_(MozExternalRefCountType)
   Release() = 0;
 
   enum Type {
     IDB = 0,
     //LS,
     //APPCACHE,
     ASMJS,
+    DOMCACHE,
     TYPE_MAX
   };
 
   virtual Type
   GetType() = 0;
 
   static nsresult
   TypeToText(Type aType, nsAString& aText)
@@ -52,16 +54,20 @@ public:
       case IDB:
         aText.AssignLiteral(IDB_DIRECTORY_NAME);
         break;
 
       case ASMJS:
         aText.AssignLiteral(ASMJSCACHE_DIRECTORY_NAME);
         break;
 
+      case DOMCACHE:
+        aText.AssignLiteral(DOMCACHE_DIRECTORY_NAME);
+        break;
+
       case TYPE_MAX:
       default:
         NS_NOTREACHED("Bad id value!");
         return NS_ERROR_UNEXPECTED;
     }
 
     return NS_OK;
   }
@@ -70,16 +76,19 @@ public:
   TypeFromText(const nsAString& aText, Type& aType)
   {
     if (aText.EqualsLiteral(IDB_DIRECTORY_NAME)) {
       aType = IDB;
     }
     else if (aText.EqualsLiteral(ASMJSCACHE_DIRECTORY_NAME)) {
       aType = ASMJS;
     }
+    else if (aText.EqualsLiteral(DOMCACHE_DIRECTORY_NAME)) {
+      aType = DOMCACHE;
+    }
     else {
       return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
   }
 
   // Methods which are called on the IO thred.
diff --git a/dom/quota/QuotaManager.cpp b/dom/quota/QuotaManager.cpp
--- a/dom/quota/QuotaManager.cpp
+++ b/dom/quota/QuotaManager.cpp
@@ -25,16 +25,17 @@
 #include "nsPIDOMWindow.h"
 
 #include <algorithm>
 #include "GeckoProfiler.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/FileService.h"
+#include "mozilla/dom/cache/QuotaClient.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/LazyIdleThread.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsComponentManagerUtils.h"
 #include "nsAboutProtocolUtils.h"
@@ -1404,27 +1405,28 @@ QuotaManager::Init()
     NS_WARNING("Unable to respond to temp storage pref changes!");
   }
 
   if (NS_FAILED(Preferences::AddBoolVarCache(&gTestingEnabled,
                                              PREF_TESTING_FEATURES, false))) {
     NS_WARNING("Unable to respond to testing pref changes!");
   }
 
-  static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::TYPE_MAX == 2,
-                "Fix the registration!");
+  static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::DOMCACHE == 2 &&
+                Client::TYPE_MAX == 3, "Fix the registration!");
 
   NS_ASSERTION(mClients.Capacity() == Client::TYPE_MAX,
                "Should be using an auto array with correct capacity!");
 
   nsRefPtr<Client> idbClient = indexedDB::CreateQuotaClient();
 
   // Register clients.
   mClients.AppendElement(idbClient);
   mClients.AppendElement(asmjscache::CreateClient());
+  mClients.AppendElement(cache::QuotaClient::Create());
 
   return NS_OK;
 }
 
 void
 QuotaManager::InitQuotaForOrigin(PersistenceType aPersistenceType,
                                  const nsACString& aGroup,
                                  const nsACString& aOrigin,
@@ -2033,21 +2035,21 @@ QuotaManager::InitializeOrigin(Persisten
 
     if (!isDirectory) {
       NS_WARNING("Unknown file found!");
       return NS_ERROR_UNEXPECTED;
     }
 
     Client::Type clientType;
     rv = Client::TypeFromText(leafName, clientType);
-    if (NS_SUCCEEDED(rv)) {
-      rv = mClients[clientType]->InitOrigin(aPersistenceType, aGroup, aOrigin,
-                                            usageInfo);
-      NS_ENSURE_SUCCESS(rv, rv);
-    }
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = mClients[clientType]->InitOrigin(aPersistenceType, aGroup, aOrigin,
+                                          usageInfo);
+    NS_ENSURE_SUCCESS(rv, rv);
   }
 
   if (trackQuota) {
     uint64_t quotaMaxBytes;
     uint64_t totalUsageBytes = usageInfo->TotalUsage();
 
     if (IsTreatedAsTemporary(aPersistenceType, aIsApp)) {
       // Temporary storage has no limit for origin usage (there's a group and
