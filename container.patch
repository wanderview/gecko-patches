# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d8e238b811d3dc74515065ae8cab6c74baf0295f

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -5324,17 +5324,20 @@ nsBrowserAccess.prototype = {
         // to the nsIDOMWindow of the opened tab right away. For e10s windows,
         // this means forcing the newly opened browser to be non-remote so that
         // we can hand back the nsIDOMWindow. The XULBrowserWindow.shouldLoadURI
         // will do the job of shuttling off the newly opened browser to run in
         // the right process once it starts loading a URI.
         let forceNotRemote = !!aOpener;
         let userContextId = aOpener && aOpener.document
                               ? aOpener.document.nodePrincipal.originAttributes.userContextId
-                              : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+                              : aTriggeringPrincipal
+                                ? aTriggeringPrincipal.originAttributes.userContextId
+                                : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+        dump('### ### opening tab with user context id: ' + userContextId + '\n');
         let openerWindow = (aFlags & Ci.nsIBrowserDOMWindow.OPEN_NO_OPENER) ? null : aOpener;
         let browser = this._openURIInNewTab(aURI, referrer, referrerPolicy,
                                             isPrivate, isExternal,
                                             forceNotRemote, userContextId,
                                             openerWindow, null, aTriggeringPrincipal);
         if (browser)
           newWindow = browser.contentWindow;
         break;
diff --git a/dom/workers/ServiceWorkerClients.cpp b/dom/workers/ServiceWorkerClients.cpp
--- a/dom/workers/ServiceWorkerClients.cpp
+++ b/dom/workers/ServiceWorkerClients.cpp
@@ -27,16 +27,17 @@
 #include "nsIWebProgress.h"
 #include "nsIWebProgressListener.h"
 #include "nsIWindowMediator.h"
 #include "nsIWindowWatcher.h"
 #include "nsNetUtil.h"
 #include "nsPIWindowWatcher.h"
 #include "nsWindowWatcher.h"
 #include "nsWeakReference.h"
+#include "nsDocShellLoadInfo.h"
 
 #ifdef MOZ_WIDGET_ANDROID
 #include "FennecJNIWrappers.h"
 #endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 using namespace mozilla::dom::workers;
@@ -704,29 +705,32 @@ private:
       NS_ENSURE_STATE(pwwatch);
 
       nsCString spec;
       rv = uri->GetSpec(spec);
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
 
+      nsCOMPtr<nsIDocShellLoadInfo> loadInfo = new nsDocShellLoadInfo();
+      loadInfo->SetTriggeringPrincipal(workerPrivate->GetPrincipal());
+
       nsCOMPtr<mozIDOMWindowProxy> newWindow;
       rv = pwwatch->OpenWindow2(nullptr,
                                 spec.get(),
                                 nullptr,
                                 nullptr,
                                 false, false, true, nullptr,
                                 // Not a spammy popup; we got permission, we swear!
                                 /* aIsPopupSpam = */ false,
                                 // Don't force noopener.  We're not passing in an
                                 // opener anyway, and we _do_ want the returned
                                 // window.
                                 /* aForceNoOpener = */ false,
-                                /* aLoadInfp = */ nullptr,
+                                loadInfo,
                                 getter_AddRefs(newWindow));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
       nsCOMPtr<nsPIDOMWindowOuter> pwindow = nsPIDOMWindowOuter::From(newWindow);
       pwindow.forget(aWindow);
       MOZ_DIAGNOSTIC_ASSERT(*aWindow);
       return NS_OK;
@@ -752,16 +756,20 @@ private:
 
     if (NS_WARN_IF(!bwin)) {
       return NS_ERROR_FAILURE;
     }
 
     nsCOMPtr<nsIPrincipal> triggeringPrincipal = workerPrivate->GetPrincipal();
     MOZ_DIAGNOSTIC_ASSERT(triggeringPrincipal);
 
+    nsAutoCString suffix;
+    triggeringPrincipal->OriginAttributesRef().CreateSuffix(suffix);
+    printf_stderr("### ### Calling OpenURI with triggering principal suffix %s\n", suffix.get());
+
     nsCOMPtr<mozIDOMWindowProxy> win;
     rv = bwin->OpenURI(uri, nullptr,
                        nsIBrowserDOMWindow::OPEN_DEFAULTWINDOW,
                        nsIBrowserDOMWindow::OPEN_NEW,
                        triggeringPrincipal,
                        getter_AddRefs(win));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return rv;
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -94,16 +94,17 @@ IPDL_SOURCES += [
     'PServiceWorkerManager.ipdl',
     'PServiceWorkerUpdater.ipdl',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
+    '/docshell/base',
     '/dom/base',
     '/dom/bindings',
     '/xpcom/build',
     '/xpcom/threads',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
