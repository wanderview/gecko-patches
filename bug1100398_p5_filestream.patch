# HG changeset patch
# Parent 621ed024842de5f2df1cd4f6e6c0eb225976c6b4
# User Ben Kelly <ben@wanderview.com>
Bug 1100398 P5 Make nsFileInputStream and nsPartialFileInputStream cloneable.

diff --git a/ipc/glue/FileDescriptor.cpp b/ipc/glue/FileDescriptor.cpp
--- a/ipc/glue/FileDescriptor.cpp
+++ b/ipc/glue/FileDescriptor.cpp
@@ -108,14 +108,22 @@ FileDescriptor::ShareTo(const FileDescri
     NS_WARNING("Failed to duplicate file handle for other process!");
   }
   return base::FileDescriptor();
 #endif
 
   MOZ_CRASH("Must not get here!");
 }
 
+FileDescriptor::PlatformHandleType
+FileDescriptor::ForgetPlatformHandle()
+{
+  PlatformHandleType handle = mHandle;
+  mHandle = INVALID_HANDLE;
+  return handle;
+}
+
 // static
 bool
 FileDescriptor::IsValid(PlatformHandleType aHandle)
 {
   return aHandle != INVALID_HANDLE;
 }
diff --git a/ipc/glue/FileDescriptor.h b/ipc/glue/FileDescriptor.h
--- a/ipc/glue/FileDescriptor.h
+++ b/ipc/glue/FileDescriptor.h
@@ -103,16 +103,19 @@ public:
   PlatformHandle() const
   {
     if (mHandleCreatedByOtherProcess) {
       mHandleCreatedByOtherProcessWasUsed = true;
     }
     return mHandle;
   }
 
+  PlatformHandleType
+  ForgetPlatformHandle();
+
   bool
   operator==(const FileDescriptor& aOther) const
   {
     return mHandle == aOther.mHandle;
   }
 
 private:
   void
diff --git a/netwerk/base/public/nsReadLine.h b/netwerk/base/public/nsReadLine.h
--- a/netwerk/base/public/nsReadLine.h
+++ b/netwerk/base/public/nsReadLine.h
@@ -37,16 +37,23 @@
  * The buffer is empty when |start| == |end|.
  * Invariant: |start| <= |end|
  */
 template<typename CharT>
 class nsLineBuffer {
   public:
     nsLineBuffer() : start(buf), end(buf) { }
 
+    nsLineBuffer(const nsLineBuffer<CharT>& aOther)
+      : start(buf + (aOther.start - aOther.buf))
+      , end(buf + (aOther.end - aOther.buf))
+    {
+      memcpy(start, aOther.start, aOther.end - aOther.start);
+    }
+
   CharT buf[kLineBufferSize+1];
   CharT* start;
   CharT* end;
 };
 
 /**
  * Read a line from an input stream. Lines are separated by '\r' (0x0D) or '\n'
  * (0x0A), or "\r\n" or "\n\r".
diff --git a/netwerk/base/src/nsFileStreams.cpp b/netwerk/base/src/nsFileStreams.cpp
--- a/netwerk/base/src/nsFileStreams.cpp
+++ b/netwerk/base/src/nsFileStreams.cpp
@@ -36,16 +36,34 @@ using mozilla::DebugOnly;
 
 nsFileStreamBase::nsFileStreamBase()
     : mFD(nullptr)
     , mBehaviorFlags(0)
     , mDeferredOpen(false)
 {
 }
 
+nsFileStreamBase::nsFileStreamBase(const nsFileStreamBase& aOther)
+    : mFD(nullptr)
+    , mBehaviorFlags(aOther.mBehaviorFlags)
+    , mDeferredOpen(aOther.mDeferredOpen)
+    , mOpenParams(aOther.mOpenParams)
+{
+    // Clone the file descriptor if present
+    if (aOther.mFD) {
+        FileDescriptor fd(PR_FileDesc2NativeHandle(aOther.mFD));
+        MOZ_ASSERT(fd.IsValid());
+        PRFileDesc* tmpFd = PR_ImportFile(PROsfd(fd.ForgetPlatformHandle()));
+        MOZ_ALWAYS_TRUE(tmpFd);
+        printf_stderr("### ### cloned fd %d to %d\n",
+                      static_cast<int>(PR_FileDesc2NativeHandle(aOther.mFD)),
+                      static_cast<int>(PR_FileDesc2NativeHandle(mFD)));
+    }
+}
+
 nsFileStreamBase::~nsFileStreamBase()
 {
     Close();
 }
 
 NS_IMPL_ISUPPORTS(nsFileStreamBase,
                   nsISeekableStream,
                   nsIFileMetadata)
@@ -164,16 +182,18 @@ nsFileStreamBase::GetLastModified(int64_
 
 nsresult
 nsFileStreamBase::Close()
 {
     CleanUpOpen();
 
     nsresult rv = NS_OK;
     if (mFD) {
+        printf_stderr("### ### closing fd %d\n",
+                      static_cast<int>(PR_FileDesc2NativeHandle(mFD)));
         if (PR_Close(mFD) == PR_FAILURE)
             rv = NS_BASE_STREAM_OSERROR;
         mFD = nullptr;
     }
     return rv;
 }
 
 nsresult
@@ -204,16 +224,18 @@ nsFileStreamBase::Read(char* aBuf, uint3
     nsresult rv = DoPendingOpen();
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (!mFD) {
         *aResult = 0;
         return NS_OK;
     }
 
+    printf_stderr("### ### PR_Read() fd:%d\n",
+                  static_cast<int>(PR_FileDesc2NativeHandle(mFD)));
     int32_t bytesRead = PR_Read(mFD, aBuf, aCount);
     if (bytesRead == -1) {
         return NS_ErrorAccordingToNSPR();
     }
 
     *aResult = bytesRead;
     return NS_OK;
 }
@@ -349,68 +371,98 @@ nsFileStreamBase::DoOpen()
       rv = mOpenParams.localFile->OpenNSPRFileDesc(mOpenParams.ioFlags,
                                                    mOpenParams.perm,
                                                    &fd);
     }
 
     CleanUpOpen();
     if (NS_FAILED(rv))
         return rv;
+    printf_stderr("### ### opened fd %d\n",
+                  static_cast<int>(PR_FileDesc2NativeHandle(fd)));
     mFD = fd;
 
     return NS_OK;
 }
 
 nsresult
 nsFileStreamBase::DoPendingOpen()
 {
     if (!mDeferredOpen) {
         return NS_OK;
     }
 
     return DoOpen();
 }
 
+nsFileStreamBase::OpenParams::OpenParams(const OpenParams& aOther)
+  : ioFlags(aOther.ioFlags)
+  , perm(aOther.perm)
+{
+  if (aOther.localFile) {
+    DebugOnly<nsresult> rv = aOther.localFile->Clone(getter_AddRefs(localFile));
+    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
+  }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // nsFileInputStream
 
 NS_IMPL_ADDREF_INHERITED(nsFileInputStream, nsFileStreamBase)
 NS_IMPL_RELEASE_INHERITED(nsFileInputStream, nsFileStreamBase)
 
 NS_IMPL_CLASSINFO(nsFileInputStream, nullptr, nsIClassInfo::THREADSAFE,
                   NS_LOCALFILEINPUTSTREAM_CID)
 
 NS_INTERFACE_MAP_BEGIN(nsFileInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIFileInputStream)
     NS_INTERFACE_MAP_ENTRY(nsILineInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIIPCSerializableInputStream)
+    NS_INTERFACE_MAP_ENTRY(nsICloneableInputStream)
     NS_IMPL_QUERY_CLASSINFO(nsFileInputStream)
 NS_INTERFACE_MAP_END_INHERITING(nsFileStreamBase)
 
 NS_IMPL_CI_INTERFACE_GETTER(nsFileInputStream,
                             nsIInputStream,
                             nsIFileInputStream,
                             nsISeekableStream,
-                            nsILineInputStream)
+                            nsILineInputStream,
+                            nsICloneableInputStream)
 
 nsresult
 nsFileInputStream::Create(nsISupports *aOuter, REFNSIID aIID, void **aResult)
 {
     NS_ENSURE_NO_AGGREGATION(aOuter);
 
     nsFileInputStream* stream = new nsFileInputStream();
     if (stream == nullptr)
         return NS_ERROR_OUT_OF_MEMORY;
     NS_ADDREF(stream);
     nsresult rv = stream->QueryInterface(aIID, aResult);
     NS_RELEASE(stream);
     return rv;
 }
 
+nsFileInputStream::nsFileInputStream(const nsFileInputStream& aOther)
+    : nsFileStreamBase(aOther)
+    , mIOFlags(aOther.mIOFlags)
+    , mPerm(aOther.mPerm)
+    , mCachedPosition(aOther.mCachedPosition)
+{
+    if (aOther.mLineBuffer) {
+        mLineBuffer = new nsLineBuffer<char>(*aOther.mLineBuffer);
+    }
+
+    if (aOther.mFile) {
+        DebugOnly<nsresult> rv = aOther.mFile->Clone(getter_AddRefs(mFile));
+        MOZ_ALWAYS_TRUE(NS_SUCCEEDED(rv));
+    }
+}
+
 nsresult
 nsFileInputStream::Open(nsIFile* aFile, int32_t aIOFlags, int32_t aPerm)
 {   
     nsresult rv = NS_OK;
 
     // If the previous file is open, close it
     if (mFD) {
         rv = Close();
@@ -632,40 +684,57 @@ nsFileInputStream::Deserialize(const Inp
         mBehaviorFlags &= ~nsIFileInputStream::REOPEN_ON_REWIND;
     }
 
     mIOFlags = params.ioFlags();
 
     return true;
 }
 
+NS_IMETHODIMP
+nsFileInputStream::GetCloneable(bool* aCloneableOut)
+{
+    *aCloneableOut = true;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsFileInputStream::Clone(nsIInputStream** aCloneOut)
+{
+    nsCOMPtr<nsIInputStream> ref = new nsFileInputStream(*this);
+    ref.forget(aCloneOut);
+    return NS_OK;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // nsPartialFileInputStream
 
 NS_IMPL_ADDREF_INHERITED(nsPartialFileInputStream, nsFileStreamBase)
 NS_IMPL_RELEASE_INHERITED(nsPartialFileInputStream, nsFileStreamBase)
 
 NS_IMPL_CLASSINFO(nsPartialFileInputStream, nullptr, nsIClassInfo::THREADSAFE,
                   NS_PARTIALLOCALFILEINPUTSTREAM_CID)
 
 // Don't forward to nsFileInputStream as we don't want to QI to
 // nsIFileInputStream
 NS_INTERFACE_MAP_BEGIN(nsPartialFileInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIPartialFileInputStream)
     NS_INTERFACE_MAP_ENTRY(nsILineInputStream)
     NS_INTERFACE_MAP_ENTRY(nsIIPCSerializableInputStream)
+    NS_INTERFACE_MAP_ENTRY(nsICloneableInputStream)
     NS_IMPL_QUERY_CLASSINFO(nsPartialFileInputStream)
 NS_INTERFACE_MAP_END_INHERITING(nsFileStreamBase)
 
 NS_IMPL_CI_INTERFACE_GETTER(nsPartialFileInputStream,
                             nsIInputStream,
                             nsIPartialFileInputStream,
                             nsISeekableStream,
-                            nsILineInputStream)
+                            nsILineInputStream,
+                            nsICloneableInputStream)
 
 nsresult
 nsPartialFileInputStream::Create(nsISupports *aOuter, REFNSIID aIID,
                                  void **aResult)
 {
     NS_ENSURE_NO_AGGREGATION(aOuter);
 
     nsPartialFileInputStream* stream = new nsPartialFileInputStream();
@@ -687,16 +756,24 @@ nsPartialFileInputStream::Init(nsIFile* 
 
     nsresult rv = nsFileInputStream::Init(aFile, aIOFlags, aPerm,
                                           aBehaviorFlags);
     NS_ENSURE_SUCCESS(rv, rv);
     
     return nsFileInputStream::Seek(NS_SEEK_SET, mStart);
 }
 
+nsPartialFileInputStream::nsPartialFileInputStream(const nsPartialFileInputStream& aOther)
+    : nsFileInputStream(aOther)
+    , mStart(aOther.mStart)
+    , mLength(aOther.mLength)
+    , mPosition(aOther.mPosition)
+{
+}
+
 NS_IMETHODIMP
 nsPartialFileInputStream::Tell(int64_t *aResult)
 {
     int64_t tell = 0;
     nsresult rv = nsFileInputStream::Tell(&tell);
     if (NS_SUCCEEDED(rv)) {
         *aResult = tell - mStart;
     }
@@ -811,16 +888,31 @@ nsPartialFileInputStream::Deserialize(
     if (!mStart) {
       return true;
     }
 
     // XXX This is so broken. Main thread IO alert.
     return NS_SUCCEEDED(nsFileInputStream::Seek(NS_SEEK_SET, mStart));
 }
 
+NS_IMETHODIMP
+nsPartialFileInputStream::GetCloneable(bool* aCloneableOut)
+{
+    *aCloneableOut = true;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+nsPartialFileInputStream::Clone(nsIInputStream** aCloneOut)
+{
+    nsCOMPtr<nsIInputStream> ref = new nsPartialFileInputStream(*this);
+    ref.forget(aCloneOut);
+    return NS_OK;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // nsFileOutputStream
 
 NS_IMPL_ISUPPORTS_INHERITED(nsFileOutputStream,
                             nsFileStreamBase,
                             nsIOutputStream,
                             nsIFileOutputStream)
  
diff --git a/netwerk/base/src/nsFileStreams.h b/netwerk/base/src/nsFileStreams.h
--- a/netwerk/base/src/nsFileStreams.h
+++ b/netwerk/base/src/nsFileStreams.h
@@ -2,16 +2,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsFileStreams_h__
 #define nsFileStreams_h__
 
 #include "nsAutoPtr.h"
+#include "nsICloneableInputStream.h"
 #include "nsIFileStreams.h"
 #include "nsIFile.h"
 #include "nsIInputStream.h"
 #include "nsIOutputStream.h"
 #include "nsISafeOutputStream.h"
 #include "nsISeekableStream.h"
 #include "nsILineInputStream.h"
 #include "nsCOMPtr.h"
@@ -28,16 +29,17 @@ class nsFileStreamBase : public nsISeeka
 public:
     NS_DECL_THREADSAFE_ISUPPORTS
     NS_DECL_NSISEEKABLESTREAM
     NS_DECL_NSIFILEMETADATA
 
     nsFileStreamBase();
 
 protected:
+    explicit nsFileStreamBase(const nsFileStreamBase& aOther);
     virtual ~nsFileStreamBase();
 
     nsresult Close();
     nsresult Available(uint64_t* _retval);
     nsresult Read(char* aBuf, uint32_t aCount, uint32_t* _retval);
     nsresult ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
                           uint32_t aCount, uint32_t* _retval);
     nsresult IsNonBlocking(bool* _retval);
@@ -56,16 +58,19 @@ protected:
     int32_t mBehaviorFlags;
 
     /**
      * Whether we have a pending open (see DEFER_OPEN in the IDL file).
      */
     bool mDeferredOpen;
 
     struct OpenParams {
+        OpenParams() : ioFlags(0), perm(0) { }
+        OpenParams(const OpenParams& aOther);
+
         nsCOMPtr<nsIFile> localFile;
         int32_t ioFlags;
         int32_t perm;
     };
 
     /**
      * Data we need to do an open.
      */
@@ -99,23 +104,25 @@ protected:
     inline nsresult DoPendingOpen();
 };
 
 ////////////////////////////////////////////////////////////////////////////////
 
 class nsFileInputStream : public nsFileStreamBase,
                           public nsIFileInputStream,
                           public nsILineInputStream,
-                          public nsIIPCSerializableInputStream
+                          public nsIIPCSerializableInputStream,
+                          public nsICloneableInputStream
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIFILEINPUTSTREAM
     NS_DECL_NSILINEINPUTSTREAM
     NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
+    NS_DECL_NSICLONEABLEINPUTSTREAM
 
     NS_IMETHOD Close();
     NS_IMETHOD Tell(int64_t *aResult);
     NS_IMETHOD Available(uint64_t* _retval);
     NS_IMETHOD Read(char* aBuf, uint32_t aCount, uint32_t* _retval);
     NS_IMETHOD ReadSegments(nsWriteSegmentFun aWriter, void *aClosure,
                             uint32_t aCount, uint32_t* _retval)
     {
@@ -133,16 +140,18 @@ public:
     nsFileInputStream()
       : mLineBuffer(nullptr), mIOFlags(0), mPerm(0), mCachedPosition(0)
     {}
 
     static nsresult
     Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
 
 protected:
+    explicit nsFileInputStream(const nsFileInputStream& aOther);
+
     virtual ~nsFileInputStream()
     {
         Close();
     }
 
     nsAutoPtr<nsLineBuffer<char> > mLineBuffer;
 
     /**
@@ -177,30 +186,32 @@ class nsPartialFileInputStream : public 
                                  public nsIPartialFileInputStream
 {
 public:
     using nsFileInputStream::Init;
     using nsFileInputStream::Read;
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIPARTIALFILEINPUTSTREAM
     NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
+    NS_DECL_NSICLONEABLEINPUTSTREAM
 
     nsPartialFileInputStream()
       : mStart(0), mLength(0), mPosition(0)
     { }
 
     NS_IMETHOD Tell(int64_t *aResult);
     NS_IMETHOD Available(uint64_t *aResult);
     NS_IMETHOD Read(char* aBuf, uint32_t aCount, uint32_t* aResult);
     NS_IMETHOD Seek(int32_t aWhence, int64_t aOffset);
 
     static nsresult
     Create(nsISupports *aOuter, REFNSIID aIID, void **aResult);
 
 protected:
+    explicit nsPartialFileInputStream(const nsPartialFileInputStream& aOther);
     ~nsPartialFileInputStream()
     { }
 
 private:
     uint64_t TruncateSize(uint64_t aSize) {
           return std::min<uint64_t>(mLength - mPosition, aSize);
     }
 
@@ -289,16 +300,20 @@ class nsFileStream : public nsFileStream
                      public nsIOutputStream,
                      public nsIFileStream
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIFILESTREAM
     NS_FORWARD_NSIINPUTSTREAM(nsFileStreamBase::)
 
+    // Do not implement cloning on read/write streams for now.  While we could
+    // in theory clone to a read-only stream, the underlying file descriptor
+    // would still be read/write.
+
     // Can't use NS_FORWARD_NSIOUTPUTSTREAM due to overlapping methods
     // Close() and IsNonBlocking() 
     NS_IMETHOD Flush()
     {
         return nsFileStreamBase::Flush();
     }
     NS_IMETHOD Write(const char* aBuf, uint32_t aCount, uint32_t* _retval)
     {
diff --git a/netwerk/test/unit/test_filestreams.js b/netwerk/test/unit/test_filestreams.js
--- a/netwerk/test/unit/test_filestreams.js
+++ b/netwerk/test/unit/test_filestreams.js
@@ -267,31 +267,81 @@ function do_test_zero_size_buffered(disa
 }
 
 function test_zero_size_buffered()
 {
     do_test_zero_size_buffered(false);
     do_test_zero_size_buffered(true);
 }
 
+function test_clone(aDeferOpen)
+{
+  const TEST_DATA = "this is a test string";
+  const LEAF_NAME = "filestreams-test-file.tmp";
+
+  let file = Cc["@mozilla.org/file/directory_service;1"].
+             getService(Ci.nsIProperties).
+             get("ProfD", Ci.nsIFile);
+  file.append(LEAF_NAME);
+  file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0666);
+
+  let ostream = Cc[OUTPUT_STREAM_CONTRACT_ID].
+                createInstance(Ci.nsIFileOutputStream);
+  ostream.init(file, -1, -1, aDeferOpen ? Ci.nsIFileOutputStream.DEFER_OPEN : 0);
+
+  ostream.write(TEST_DATA, TEST_DATA.length);
+  ostream.close();
+
+  let fstream = Cc["@mozilla.org/network/file-input-stream;1"].
+                createInstance(Ci.nsIFileInputStream);
+  fstream.init(file, -1, 0, aDeferOpen ? Ci.nsIFileInputStream.DEFER_OPEN : 0);
+
+  do_check_true(fstream.cloneable);
+  let clone = fstream.clone();
+
+  let cstream = Cc["@mozilla.org/intl/converter-input-stream;1"].
+                createInstance(Ci.nsIConverterInputStream);
+  cstream.init(fstream, "UTF-8", 0, 0);
+
+  let string  = {};
+  cstream.readString(-1, string);
+  cstream.close();
+  fstream.close();
+
+  do_check_eq(string.value, TEST_DATA);
+
+  let cloneCStream = Cc["@mozilla.org/intl/converter-input-stream;1"].
+                createInstance(Ci.nsIConverterInputStream);
+  cloneCStream.init(clone, "UTF-8", 0, 0);
+
+  let cloneString  = {};
+  cloneCStream.readString(-1, cloneString);
+  dump("### ### cloneString: " + cloneString.value + "\n");
+  cloneCStream.close();
+  clone.close();
+
+  do_check_eq(cloneString.value, TEST_DATA);
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //// Test Runner
 
 let tests = [
   test_access,
   test_access_trick,
   test_access_defer,
   test_access_defer_trick,
   test_access_safe,
   test_access_safe_trick,
   test_access_safe_defer,
   test_access_safe_defer_trick,
   test_sync_operations,
   test_sync_operations_deferred,
   test_zero_size_buffered,
+  test_clone,
 ];
 
 function run_test()
 {
   tests.forEach(function(test) {
     test();
   });
 }
