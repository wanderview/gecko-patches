# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  5c4f6ea84b223de81ddda9bfe7d647c58b907c55
Bug 1210941 P2 Use LOAD_BYPASS_SERVICE_WORKER in HttpBaseChannel instead of mForceNoIntercept. r=jduell

diff --git a/netwerk/protocol/http/HttpBaseChannel.cpp b/netwerk/protocol/http/HttpBaseChannel.cpp
--- a/netwerk/protocol/http/HttpBaseChannel.cpp
+++ b/netwerk/protocol/http/HttpBaseChannel.cpp
@@ -72,17 +72,16 @@ HttpBaseChannel::HttpBaseChannel()
   , mChannelIsForDownload(false)
   , mTracingEnabled(true)
   , mTimingEnabled(false)
   , mAllowSpdy(true)
   , mAllowAltSvc(true)
   , mResponseTimeoutEnabled(true)
   , mAllRedirectsSameOrigin(true)
   , mAllRedirectsPassTimingAllowCheck(true)
-  , mForceNoIntercept(false)
   , mResponseCouldBeSynthesized(false)
   , mSuspendCount(0)
   , mInitialRwin(0)
   , mProxyResolveFlags(0)
   , mProxyURI(nullptr)
   , mContentDispositionHint(UINT32_MAX)
   , mHttpHandler(gHttpHandler)
   , mReferrerPolicy(REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE)
@@ -1565,16 +1564,18 @@ HttpBaseChannel::SetRedirectionLimit(uin
 
 nsresult
 HttpBaseChannel::OverrideSecurityInfo(nsISupports* aSecurityInfo)
 {
   MOZ_ASSERT(!mSecurityInfo,
              "This can only be called when we don't have a security info object already");
   MOZ_RELEASE_ASSERT(aSecurityInfo,
                      "This can only be called with a valid security info object");
+  MOZ_ASSERT(!BypassServiceWorker(),
+             "This can only be called on channels that are not bypassing interception");
   MOZ_ASSERT(mResponseCouldBeSynthesized,
              "This can only be called on channels that can be intercepted");
   if (mSecurityInfo) {
     LOG(("HttpBaseChannel::OverrideSecurityInfo mSecurityInfo is null! "
          "[this=%p]\n", this));
     return NS_ERROR_UNEXPECTED;
   }
   if (!mResponseCouldBeSynthesized) {
@@ -2094,18 +2095,17 @@ HttpBaseChannel::GetLastModifiedTime(PRT
   mResponseHead->GetLastModifiedValue(&lastMod);
   *lastModifiedTime = lastMod;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpBaseChannel::ForceNoIntercept()
 {
-  mForceNoIntercept = true;
-  mResponseCouldBeSynthesized = false;
+  mLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 HttpBaseChannel::GetCorsIncludeCredentials(bool* aInclude)
 {
   *aInclude = mCorsIncludeCredentials;
   return NS_OK;
@@ -2240,22 +2240,28 @@ HttpBaseChannel::GetURIPrincipal()
 
 bool
 HttpBaseChannel::IsNavigation()
 {
   return mLoadFlags & LOAD_DOCUMENT_URI;
 }
 
 bool
+HttpBaseChannel::BypassServiceWorker() const
+{
+  return mLoadFlags & LOAD_BYPASS_SERVICE_WORKER;
+}
+
+bool
 HttpBaseChannel::ShouldIntercept()
 {
   nsCOMPtr<nsINetworkInterceptController> controller;
   GetCallback(controller);
   bool shouldIntercept = false;
-  if (controller && !mForceNoIntercept && mLoadInfo) {
+  if (controller && !BypassServiceWorker() && mLoadInfo) {
     nsContentPolicyType type = mLoadInfo->InternalContentPolicyType();
     nsresult rv = controller->ShouldPrepareForIntercept(mURI,
                                                         IsNavigation(),
                                                         type,
                                                         &shouldIntercept);
     if (NS_FAILED(rv)) {
       return false;
     }
@@ -2527,21 +2533,16 @@ HttpBaseChannel::SetupReplacementChannel
     // if there is a chain of keys for redirect-responses we transfer it to
     // the new channel (see bug #561276)
     if (mRedirectedCachekeys) {
         LOG(("HttpBaseChannel::SetupReplacementChannel "
              "[this=%p] transferring chain of redirect cache-keys", this));
         httpInternal->SetCacheKeysRedirectChain(mRedirectedCachekeys.forget());
     }
 
-    // Preserve any skip-serviceworker-flag.
-    if (mForceNoIntercept) {
-      httpInternal->ForceNoIntercept();
-    }
-
     // Preserve CORS mode flag.
     httpInternal->SetCorsMode(mCorsMode);
 
     // Preserve Redirect mode flag.
     httpInternal->SetRedirectMode(mRedirectMode);
   }
 
   // transfer application cache information
diff --git a/netwerk/protocol/http/HttpBaseChannel.h b/netwerk/protocol/http/HttpBaseChannel.h
--- a/netwerk/protocol/http/HttpBaseChannel.h
+++ b/netwerk/protocol/http/HttpBaseChannel.h
@@ -308,16 +308,18 @@ protected:
 
   // Redirect tracking
   // Checks whether or not aURI and mOriginalURI share the same domain.
   bool SameOriginWithOriginalUri(nsIURI *aURI);
 
   // GetPrincipal Returns the channel's URI principal.
   nsIPrincipal *GetURIPrincipal();
 
+  bool BypassServiceWorker() const;
+
   // Returns true if this channel should intercept the network request and prepare
   // for a possible synthesized response instead.
   bool ShouldIntercept();
 
   friend class PrivateBrowsingChannel<HttpBaseChannel>;
 
   nsCOMPtr<nsIURI>                  mURI;
   nsCOMPtr<nsIURI>                  mOriginalURI;
@@ -386,19 +388,16 @@ protected:
   uint32_t                          mResponseTimeoutEnabled     : 1;
   // A flag that should be false only if a cross-domain redirect occurred
   uint32_t                          mAllRedirectsSameOrigin     : 1;
 
   // Is 1 if no redirects have occured or if all redirects
   // pass the Resource Timing timing-allow-check
   uint32_t                          mAllRedirectsPassTimingAllowCheck : 1;
 
-  // True if this channel should skip any interception checks
-  uint32_t                          mForceNoIntercept           : 1;
-
   // True if this channel was intercepted and could receive a synthesized response.
   uint32_t                          mResponseCouldBeSynthesized : 1;
 
   // Current suspension depth for this channel object
   uint32_t                          mSuspendCount;
 
   // Per channel transport window override (0 means no override)
   uint32_t                          mInitialRwin;
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -6996,16 +6996,17 @@ nsHttpChannel::OnPush(const nsACString &
     channel->SetPushedStream(pushedStream);
     rv = pushListener->OnPush(this, pushHttpChannel);
     return rv;
 }
 
 void
 nsHttpChannel::SetCouldBeSynthesized()
 {
+  MOZ_ASSERT(!BypassServiceWorker());
   mResponseCouldBeSynthesized = true;
 }
 
 NS_IMETHODIMP
 nsHttpChannel::OnPreflightSucceeded()
 {
     MOZ_ASSERT(mRequireCORSPreflight, "Why did a preflight happen?");
     mIsCorsPreflightDone = 1;
