# HG changeset patch
# Parent 88bf5cc9b8d7caaac4ab05bad0e47d538ef937cc
# User Ben Kelly <ben@wanderview.com>
try: -b do -p linux64,emulator -u mochitests -t none

diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -55,23 +55,28 @@ ChannelFromScriptURL(nsIPrincipal* princ
                      const nsAString& aScriptURL,
                      bool aIsWorkerScript,
                      nsIChannel** aChannel)
 {
   AssertIsOnMainThread();
 
   nsresult rv;
   nsCOMPtr<nsIURI> uri;
+  printf_stderr("### ### ScriptLoader::ChannelFromScriptURL() 1\n");
+
   rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
                                                  aScriptURL, parentDoc,
                                                  baseURI);
   if (NS_FAILED(rv)) {
     return NS_ERROR_DOM_SYNTAX_ERR;
   }
 
+  printf_stderr("### ### ScriptLoader::ChannelFromScriptURL() 2 parentDoc:%p\n",
+                parentDoc);
+
   // If we're part of a document then check the content load policy.
   if (parentDoc) {
     int16_t shouldLoad = nsIContentPolicy::ACCEPT;
     rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_SCRIPT, uri,
                                    principal, parentDoc,
                                    NS_LITERAL_CSTRING("text/javascript"),
                                    nullptr, &shouldLoad,
                                    nsContentUtils::GetContentPolicy(),
@@ -79,16 +84,19 @@ ChannelFromScriptURL(nsIPrincipal* princ
     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
       if (NS_FAILED(rv) || shouldLoad != nsIContentPolicy::REJECT_TYPE) {
         return rv = NS_ERROR_CONTENT_BLOCKED;
       }
       return rv = NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
     }
   }
 
+  printf_stderr("### ### ScriptLoader::ChannelFromScriptURL() 3 aIsWorkerScript:%s\n",
+                (aIsWorkerScript ? "true" : "false"));
+
   // If this script loader is being used to make a new worker then we need
   // to do a same-origin check. Otherwise we need to clear the load with the
   // security manager.
   if (aIsWorkerScript) {
     nsCString scheme;
     rv = uri->GetScheme(scheme);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -101,16 +109,18 @@ ChannelFromScriptURL(nsIPrincipal* princ
   }
   else {
     rv = secMan->CheckLoadURIWithPrincipal(principal, uri, 0);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
 
   uint32_t flags = nsIRequest::LOAD_NORMAL | nsIChannel::LOAD_CLASSIFY_URI;
 
+  printf_stderr("### ### ScriptLoader::ChannelFromScriptURL() 4\n");
+
   nsCOMPtr<nsIChannel> channel;
   // If we have the document, use it
   if (parentDoc) {
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        parentDoc,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
@@ -132,16 +142,18 @@ ChannelFromScriptURL(nsIPrincipal* princ
                        loadGroup,
                        nullptr, // aCallbacks
                        flags,
                        ios);
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
+  printf_stderr("### ### ScriptLoader::ChannelFromScriptURL() 5\n");
+
   channel.forget(aChannel);
   return rv;
 }
 
 struct ScriptLoadInfo
 {
   ScriptLoadInfo()
   : mScriptTextBuf(nullptr)
@@ -416,82 +428,104 @@ private:
 
   nsresult
   OnStreamCompleteInternal(nsIStreamLoader* aLoader, nsISupports* aContext,
                            nsresult aStatus, uint32_t aStringLen,
                            const uint8_t* aString, ScriptLoadInfo& aLoadInfo)
   {
     AssertIsOnMainThread();
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 1\n");
+
     if (!aLoadInfo.mChannel) {
       return NS_BINDING_ABORTED;
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 2 status:%x\n", aStatus);
+
     aLoadInfo.mChannel = nullptr;
 
     if (NS_FAILED(aStatus)) {
       return aStatus;
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 3\n");
+
     NS_ASSERTION(aString, "This should never be null!");
 
     // Make sure we're not seeing the result of a 404 or something by checking
     // the 'requestSucceeded' attribute on the http channel.
     nsCOMPtr<nsIRequest> request;
     nsresult rv = aLoader->GetRequest(getter_AddRefs(request));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(request);
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 4 httpChannel:%p\n", httpChannel.get());
     if (httpChannel) {
       bool requestSucceeded;
       rv = httpChannel->GetRequestSucceeded(&requestSucceeded);
       NS_ENSURE_SUCCESS(rv, rv);
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 5\n");
+
       if (!requestSucceeded) {
         return NS_ERROR_NOT_AVAILABLE;
       }
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 6\n");
+
     // May be null.
     nsIDocument* parentDoc = mWorkerPrivate->GetDocument();
 
     // Use the regular nsScriptLoader for this grunt work! Should be just fine
     // because we're running on the main thread.
     // Unlike <script> tags, Worker scripts are always decoded as UTF-8,
     // per spec. So we explicitly pass in the charset hint.
     rv = nsScriptLoader::ConvertToUTF16(aLoadInfo.mChannel, aString, aStringLen,
                                         NS_LITERAL_STRING("UTF-8"), parentDoc,
                                         aLoadInfo.mScriptTextBuf,
                                         aLoadInfo.mScriptTextLength);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 7\n");
+
     if (!aLoadInfo.mScriptTextBuf || !aLoadInfo.mScriptTextLength) {
       return NS_ERROR_FAILURE;
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 8\n");
+
     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
     NS_ASSERTION(channel, "This should never fail!");
 
     // Figure out what we actually loaded.
     nsCOMPtr<nsIURI> finalURI;
     rv = NS_GetFinalChannelURI(channel, getter_AddRefs(finalURI));
     NS_ENSURE_SUCCESS(rv, rv);
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 9\n");
+
     nsCString filename;
     rv = finalURI->GetSpec(filename);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 10\n");
+
     if (!filename.IsEmpty()) {
       // This will help callers figure out what their script url resolved to in
       // case of errors.
       aLoadInfo.mURL.Assign(NS_ConvertUTF8toUTF16(filename));
     }
 
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 11 mIsWorkerScript:%s\n",
+                  (mIsWorkerScript ? "true" : "false"));
+
     // Update the principal of the worker and its base URI if we just loaded the
     // worker's primary script.
     if (mIsWorkerScript) {
       // Take care of the base URI first.
       mWorkerPrivate->SetBaseURI(finalURI);
 
       // Now to figure out which principal to give this worker.
       WorkerPrivate* parent = mWorkerPrivate->GetParent();
@@ -505,74 +539,99 @@ private:
 
       nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
       NS_ASSERTION(ssm, "Should never be null!");
 
       nsCOMPtr<nsIPrincipal> channelPrincipal;
       rv = ssm->GetChannelResultPrincipal(channel, getter_AddRefs(channelPrincipal));
       NS_ENSURE_SUCCESS(rv, rv);
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 12\n");
+
       nsCOMPtr<nsILoadGroup> channelLoadGroup;
       rv = channel->GetLoadGroup(getter_AddRefs(channelLoadGroup));
       NS_ENSURE_SUCCESS(rv, rv);
       MOZ_ASSERT(channelLoadGroup);
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 13\n");
+
       // See if this is a resource URI. Since JSMs usually come from resource://
       // URIs we're currently considering all URIs with the URI_IS_UI_RESOURCE
       // flag as valid for creating privileged workers.
       if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 14\n");
         bool isResource;
         rv = NS_URIChainHasFlags(finalURI,
                                  nsIProtocolHandler::URI_IS_UI_RESOURCE,
                                  &isResource);
         NS_ENSURE_SUCCESS(rv, rv);
 
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 15\n");
+
         if (isResource) {
+          printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 16\n");
           rv = ssm->GetSystemPrincipal(getter_AddRefs(channelPrincipal));
           NS_ENSURE_SUCCESS(rv, rv);
+          printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 17\n");
         }
       }
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 18\n");
+
       // If the load principal is the system principal then the channel
       // principal must also be the system principal (we do not allow chrome
       // code to create workers with non-chrome scripts). Otherwise this channel
       // principal must be same origin with the load principal (we check again
       // here in case redirects changed the location of the script).
       if (nsContentUtils::IsSystemPrincipal(loadPrincipal)) {
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 19\n");
         if (!nsContentUtils::IsSystemPrincipal(channelPrincipal)) {
+          printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 20\n");
           return NS_ERROR_DOM_BAD_URI;
         }
       }
       else  {
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 21\n");
         nsCString scheme;
         rv = finalURI->GetScheme(scheme);
         NS_ENSURE_SUCCESS(rv, rv);
 
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 22\n");
+
         // We exempt data urls and other URI's that inherit their
         // principal again.
         if (NS_FAILED(loadPrincipal->CheckMayLoad(finalURI, false, true))) {
           return NS_ERROR_DOM_BAD_URI;
         }
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 23\n");
       }
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 24\n");
+
       // The principal can change, but it should still match the original
       // load group's appId and browser element flag.
       MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(channelLoadGroup, channelPrincipal));
 
       mWorkerPrivate->SetPrincipal(channelPrincipal, channelLoadGroup);
 
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 25\n");
+
       if (parent) {
+        printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 26\n");
         // XHR Params Allowed
         mWorkerPrivate->SetXHRParamsAllowed(parent->XHRParamsAllowed());
 
         // Set Eval and ContentSecurityPolicy
         mWorkerPrivate->SetCSP(parent->GetCSP());
         mWorkerPrivate->SetEvalAllowed(parent->IsEvalAllowed());
       }
+
+      printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 27\n");
     }
+    printf_stderr("### ### ScriptLoader OnStreamCompleteInternal() 28\n");
 
     return NS_OK;
   }
 
   void
   ExecuteFinishedScripts()
   {
     AssertIsOnMainThread();
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -4349,16 +4349,19 @@ WorkerPrivate::GetLoadInfo(JSContext* aC
                                         &loadInfo.mEvalAllowed);
       NS_ENSURE_SUCCESS(rv, rv);
     } else {
       loadInfo.mEvalAllowed = true;
       loadInfo.mReportCSPViolations = false;
     }
 
     if (!loadInfo.mLoadGroup || aLoadGroupBehavior == ForceNewLoadGroup) {
+      if (loadInfo.mLoadGroup) {
+        printf_stderr("### ### Override load group %p\n", loadInfo.mLoadGroup.get());
+      }
       rv = NS_NewLoadGroup(getter_AddRefs(loadInfo.mLoadGroup),
                            loadInfo.mPrincipal, loadInfo.mLoadGroup);
       NS_ENSURE_SUCCESS(rv, rv);
     }
     MOZ_ASSERT(NS_LoadGroupMatchesPrincipal(loadInfo.mLoadGroup,
                                             loadInfo.mPrincipal));
 
     rv = ChannelFromScriptURLMainThread(loadInfo.mPrincipal, loadInfo.mBaseURI,
diff --git a/netwerk/base/nsNetUtil.cpp b/netwerk/base/nsNetUtil.cpp
--- a/netwerk/base/nsNetUtil.cpp
+++ b/netwerk/base/nsNetUtil.cpp
@@ -20,23 +20,28 @@ bool NS_IsValidHTTPToken(const nsACStrin
 
 nsresult
 NS_NewLoadGroup(nsILoadGroup** aResult, nsIPrincipal* aPrincipal,
                 nsILoadGroup* aOptionalBase)
 {
     using mozilla::LoadContext;
     nsresult rv;
 
+    printf_stderr("### ### NS_NewLoadGroup() base:%p\n", aOptionalBase);
+
     nsCOMPtr<nsILoadContext> baseLoadContext;
     if (aOptionalBase) {
       nsCOMPtr<nsIInterfaceRequestor> cb;
       rv = aOptionalBase->GetNotificationCallbacks(getter_AddRefs(cb));
       NS_ENSURE_SUCCESS(rv, rv);
 
       baseLoadContext = do_QueryInterface(cb);
+
+      printf_stderr("### ### NS_NewLoadGroup() callbacks:%p context:%p\n",
+                    cb.get(), baseLoadContext.get());
     }
 
     nsCOMPtr<nsILoadGroup> group =
         do_CreateInstance(NS_LOADGROUP_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsRefPtr<LoadContext> loadContext = new LoadContext(aPrincipal,
                                                         baseLoadContext);
