# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  214884d507ee369c1cf14edb26527c4f9a97bf48
Bug 1286258 Abort http channels that fail ContinueAsyncOpen() during service worker handling. r=valentin

diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -2524,17 +2524,19 @@ HttpChannelChild::ResetInterception()
   mInterceptListener = nullptr;
 
   // The chance to intercept any further requests associated with this channel
   // (such as redirects) has passed.
   mLoadFlags |= LOAD_BYPASS_SERVICE_WORKER;
 
   // Continue with the original cross-process request
   nsresult rv = ContinueAsyncOpen();
-  NS_ENSURE_SUCCESS_VOID(rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    AsyncAbort(rv);
+  }
 }
 
 NS_IMETHODIMP
 HttpChannelChild::GetResponseSynthesized(bool* aSynthesized)
 {
   NS_ENSURE_ARG_POINTER(aSynthesized);
   *aSynthesized = mSynthesizedResponse;
   return NS_OK;
@@ -2555,17 +2557,19 @@ HttpChannelChild::OverrideWithSynthesize
 
   mResponseHead = aResponseHead;
   mSynthesizedResponse = true;
 
   if (WillRedirect(mResponseHead)) {
     mShouldInterceptSubsequentRedirect = true;
     // Continue with the original cross-process request
     nsresult rv = ContinueAsyncOpen();
-    NS_ENSURE_SUCCESS_VOID(rv);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      AsyncAbort(rv);
+    }
     return;
   }
 
   // In our current implementation, the FetchEvent handler will copy the
   // response stream completely into the pipe backing the input stream so we
   // can treat the available as the length of the stream.
   uint64_t available;
   nsresult rv = aSynthesizedInput->Available(&available);
