# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  d5307c450e6c967147ed474affffe5406efaebaa
Bug 1391693 P9 Make nsHttpChannel redirect to InterceptedHttpChannel to fire a ServiceWorker FetchEvent. r=asuth r=valentin

diff --git a/devtools/shared/webconsole/network-monitor.js b/devtools/shared/webconsole/network-monitor.js
--- a/devtools/shared/webconsole/network-monitor.js
+++ b/devtools/shared/webconsole/network-monitor.js
@@ -809,20 +809,18 @@ NetworkMonitor.prototype = {
     let channel = subject.QueryInterface(Ci.nsIHttpChannel);
 
     if (!matchRequest(channel, this.filters)) {
       return;
     }
 
     this.interceptedChannels.add(subject);
 
-    // On e10s, we never receive http-on-examine-cached-response, so fake one.
-    if (Services.appinfo.processType == Ci.nsIXULRuntime.PROCESS_TYPE_CONTENT) {
-      this._httpResponseExaminer(channel, "http-on-examine-cached-response");
-    }
+    // Service workers never fire http-on-examine-cached-response, so fake one.
+    this._httpResponseExaminer(channel, "http-on-examine-cached-response");
   },
 
   /**
    * Observe notifications for the http-on-examine-response topic, coming from
    * the nsIObserverService.
    *
    * @private
    * @param nsIHttpChannel subject
diff --git a/netwerk/protocol/http/nsHttpChannel.cpp b/netwerk/protocol/http/nsHttpChannel.cpp
--- a/netwerk/protocol/http/nsHttpChannel.cpp
+++ b/netwerk/protocol/http/nsHttpChannel.cpp
@@ -102,16 +102,17 @@
 #include "mozilla/extensions/StreamFilterParent.h"
 #include "mozilla/net/Predictor.h"
 #include "mozilla/MathAlgorithms.h"
 #include "CacheControlParser.h"
 #include "nsMixedContentBlocker.h"
 #include "HSTSPrimerListener.h"
 #include "CacheStorageService.h"
 #include "HttpChannelParent.h"
+#include "InterceptedHttpChannel.h"
 #include "nsIBufferedStreams.h"
 #include "nsIFileStreams.h"
 #include "nsIMIMEInputStream.h"
 #include "nsIMultiplexInputStream.h"
 #include "../../cache2/CacheFileUtils.h"
 
 #ifdef MOZ_TASK_TRACER
 #include "GeckoTaskTracer.h"
@@ -540,16 +541,20 @@ nsHttpChannel::Connect()
     LOG(("nsHttpChannel::Connect [this=%p]\n", this));
 
     // Don't allow resuming when cache must be used
     if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
         LOG(("Resuming from cache is not supported yet"));
         return NS_ERROR_DOCUMENT_NOT_CACHED;
     }
 
+    if (ShouldIntercept()) {
+      return RedirectToInterceptedChannel();
+    }
+
     bool isTrackingResource = mIsTrackingResource; // is atomic
     LOG(("nsHttpChannel %p tracking resource=%d, local blocklist=%d, cos=%u",
           this, isTrackingResource, mLocalBlocklist, mClassOfService));
 
     if (isTrackingResource || mLocalBlocklist) {
         AddClassFlags(nsIClassOfService::Tail);
     }
 
@@ -9584,10 +9589,55 @@ nsHttpChannel::SetWarningReporter(HttpCh
 
 HttpChannelSecurityWarningReporter*
 nsHttpChannel::GetWarningReporter()
 {
     LOG(("nsHttpChannel [this=%p] GetWarningReporter [%p]", this, mWarningReporter.get()));
     return mWarningReporter.get();
 }
 
+nsresult
+nsHttpChannel::RedirectToInterceptedChannel()
+{
+  mInterceptCache = INTERCEPTED;
+
+  nsCOMPtr<nsINetworkInterceptController> controller;
+  GetCallback(controller);
+
+  RefPtr<InterceptedHttpChannel> intercepted =
+    InterceptedHttpChannel::CreateForInterception();
+
+  nsresult rv =
+    intercepted->Init(mURI, mCaps, static_cast<nsProxyInfo*>(mProxyInfo.get()),
+                      mProxyResolveFlags, mProxyURI, mChannelId);
+
+  nsCOMPtr<nsILoadInfo> redirectLoadInfo =
+    CloneLoadInfoForRedirect(mURI, nsIChannelEventSink::REDIRECT_INTERNAL);
+  intercepted->SetLoadInfo(redirectLoadInfo);
+
+  rv = SetupReplacementChannel(mURI, intercepted, true,
+                               nsIChannelEventSink::REDIRECT_INTERNAL);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mRedirectChannel = intercepted;
+
+  PushRedirectAsyncFunc(
+      &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+
+  rv = gHttpHandler->AsyncOnChannelRedirect(this, intercepted,
+                                            nsIChannelEventSink::REDIRECT_INTERNAL);
+
+  if (NS_SUCCEEDED(rv)) {
+    rv = WaitForRedirectCallback();
+  }
+
+  if (NS_FAILED(rv)) {
+    AutoRedirectVetoNotifier notifier(this);
+
+    PopRedirectAsyncFunc(
+        &nsHttpChannel::ContinueAsyncRedirectChannelToURI);
+  }
+
+  return rv;
+}
+
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/nsHttpChannel.h b/netwerk/protocol/http/nsHttpChannel.h
--- a/netwerk/protocol/http/nsHttpChannel.h
+++ b/netwerk/protocol/http/nsHttpChannel.h
@@ -494,16 +494,18 @@ private:
     void MaybeWarnAboutAppCache();
 
     void SetLoadGroupUserAgentOverride();
 
     void SetDoNotTrack();
 
     already_AddRefed<nsChannelClassifier> GetOrCreateChannelClassifier();
 
+    MOZ_MUST_USE nsresult RedirectToInterceptedChannel();
+
 private:
     // this section is for main-thread-only object
     // all the references need to be proxy released on main thread.
     nsCOMPtr<nsIApplicationCache> mApplicationCacheForWrite;
     // auth specific data
     nsCOMPtr<nsIHttpChannelAuthProvider> mAuthProvider;
     nsCOMPtr<nsIURI> mRedirectURI;
     nsCOMPtr<nsIChannel> mRedirectChannel;
