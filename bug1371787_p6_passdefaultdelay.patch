# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b041b81358c1a09f55b1bb9690caea761e206b74
Bug 1371787 P6 Move the std::max() calculation into DOMMinTimeoutValue() and rename the method to CalculateDelay(). r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -228,19 +228,19 @@ TimeoutManager::IsInvalidFiringId(uint32
   return !mFiringIdStack.Contains(aFiringId);
 }
 
 // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
 // uses 5.
 #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
 
 int32_t
-TimeoutManager::DOMMinTimeoutValue(Timeout* aTimeout) const {
+TimeoutManager::CalculateDelay(Timeout* aTimeout) const {
   MOZ_DIAGNOSTIC_ASSERT(aTimeout);
-  int32_t result = 0;
+  int32_t result = aTimeout->mInterval;
 
   if (aTimeout->mIsInterval ||
       aTimeout->mNestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
     result = std::max(result, gMinClampTimeoutValue);
   }
 
   if (aTimeout->mIsTracking && mThrottleTrackingTimeouts) {
     result = std::max(result, gMinTrackingTimeoutValue);
@@ -425,18 +425,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   uint32_t nestingLevel = sNestingLevel + 1;
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
 
   // Now clamp the actual interval we will use for the timer based on
-  uint32_t realInterval =
-    std::max(interval, DOMMinTimeoutValue(timeout));
+  uint32_t realInterval = CalculateDelay(timeout);
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
   timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     nsresult rv = mExecutor->MaybeSchedule(timeout->When(),
                                            MinSchedulingDelay());
@@ -475,17 +474,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   *aReturn = timeout->mTimeoutId;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Set%s(TimeoutManager=%p, timeout=%p, delay=%i, "
            "minimum=%i, throttling=%s, background=%d, realInterval=%i) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
            this, timeout.get(), interval,
-           DOMMinTimeoutValue(timeout),
+           (CalculateDelay(timeout) - interval),
            mThrottleTrackingTimeouts ? "yes"
                                      : (mThrottleTrackingTimeoutsTimer ?
                                           "pending" : "no"),
            int(IsBackground()), realInterval,
            timeout->mIsTracking ? "" : "non-",
            timeout->mTimeoutId));
 
   return NS_OK;
@@ -800,21 +799,19 @@ TimeoutManager::RunTimeout(const TimeSta
 bool
 TimeoutManager::RescheduleTimeout(Timeout* aTimeout, const TimeStamp& now)
 {
   if (!aTimeout->mIsInterval) {
     return false;
   }
 
   // Compute time to next timeout for interval timer.
-  // Make sure nextInterval is at least DOMMinTimeoutValue().
+  // Make sure nextInterval is at least CalculateDelay().
   TimeDuration nextInterval =
-    TimeDuration::FromMilliseconds(
-        std::max(aTimeout->mInterval,
-                 uint32_t(DOMMinTimeoutValue(aTimeout))));
+    TimeDuration::FromMilliseconds(CalculateDelay(aTimeout));
 
   TimeStamp firingTime = now + nextInterval;
 
   TimeStamp currentNow = TimeStamp::Now();
   TimeDuration delay = firingTime - currentNow;
 
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -50,17 +50,17 @@ public:
   // The timeout implementation functions.
   void RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline);
   // Return true if |aTimeout| needs to be reinserted into the timeout list.
   bool RescheduleTimeout(mozilla::dom::Timeout* aTimeout, const TimeStamp& now);
 
   void ClearAllTimeouts();
   uint32_t GetTimeoutId(mozilla::dom::Timeout::Reason aReason);
 
-  int32_t DOMMinTimeoutValue(Timeout* aTimeout) const;
+  int32_t CalculateDelay(Timeout* aTimeout) const;
 
   // aTimeout is the timeout that we're about to start running.  This function
   // returns the current timeout.
   mozilla::dom::Timeout* BeginRunningTimeout(mozilla::dom::Timeout* aTimeout);
   // aTimeout is the last running timeout.
   void EndRunningTimeout(mozilla::dom::Timeout* aTimeout);
 
   void UnmarkGrayTimers();
