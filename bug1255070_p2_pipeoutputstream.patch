# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  e1559b2b4ff705aab66ce2eb978d5dd196ce6091
Bug 1255070 P2 Make nsPipeOutputStream implement nsIBufferedOuptutStream. r=froydnj

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -231,28 +231,30 @@ private:
   nsPipeReadState                mReadState;
 };
 
 //-----------------------------------------------------------------------------
 
 // the output end of a pipe (allocated as a member of the pipe).
 class nsPipeOutputStream
   : public nsIAsyncOutputStream
+  , public nsIBufferedOutputStream
   , public nsIClassInfo
 {
 public:
   // since this class will be allocated as a member of the pipe, we do not
   // need our own ref count.  instead, we share the lifetime (the ref count)
   // of the entire pipe.  this macro is just convenience since it does not
   // declare a mRefCount variable; however, don't let the name fool you...
   // we are not inheriting from nsPipe ;-)
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_NSIOUTPUTSTREAM
   NS_DECL_NSIASYNCOUTPUTSTREAM
+  NS_DECL_NSIBUFFEREDOUTPUTSTREAM
   NS_DECL_NSICLASSINFO
 
   explicit nsPipeOutputStream(nsPipe* aPipe)
     : mPipe(aPipe)
     , mWriterRefCnt(0)
     , mLogicalOffset(0)
     , mBlocking(true)
     , mBlocked(false)
@@ -1536,24 +1538,32 @@ nsPipeInputStream::~nsPipeInputStream()
 {
   Close();
 }
 
 //-----------------------------------------------------------------------------
 // nsPipeOutputStream methods:
 //-----------------------------------------------------------------------------
 
-NS_IMPL_QUERY_INTERFACE(nsPipeOutputStream,
-                        nsIOutputStream,
-                        nsIAsyncOutputStream,
-                        nsIClassInfo)
+NS_INTERFACE_TABLE_HEAD(nsPipeOutputStream)
+  NS_INTERFACE_TABLE_BEGIN
+    NS_INTERFACE_TABLE_ENTRY(nsPipeOutputStream, nsIAsyncOutputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeOutputStream, nsIBufferedOutputStream)
+    NS_INTERFACE_TABLE_ENTRY(nsPipeOutputStream, nsIClassInfo)
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsPipeOutputStream, nsIOutputStream,
+                                       nsIAsyncOutputStream)
+    NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsPipeOutputStream, nsISupports,
+                                       nsIAsyncOutputStream)
+  NS_INTERFACE_TABLE_END
+NS_INTERFACE_TABLE_TAIL
 
 NS_IMPL_CI_INTERFACE_GETTER(nsPipeOutputStream,
                             nsIOutputStream,
-                            nsIAsyncOutputStream)
+                            nsIAsyncOutputStream,
+                            nsIBufferedOutputStream)
 
 NS_IMPL_THREADSAFE_CI(nsPipeOutputStream)
 
 nsresult
 nsPipeOutputStream::Wait()
 {
   NS_ASSERTION(mBlocking, "wait on non-blocking pipe output stream");
 
@@ -1688,17 +1698,18 @@ nsPipeOutputStream::WriteSegments(nsRead
     if (segmentLen > aCount) {
       segmentLen = aCount;
     }
 
     uint32_t readCount, originalLen = segmentLen;
     while (segmentLen) {
       readCount = 0;
 
-      rv = aReader(this, aClosure, segment, *aWriteCount, segmentLen, &readCount);
+      rv = aReader(static_cast<nsIAsyncOutputStream*>(this), aClosure, segment,
+                   *aWriteCount, segmentLen, &readCount);
 
       if (NS_FAILED(rv) || readCount == 0) {
         aCount = 0;
         // any errors returned from the aReader end here: do not
         // propagate to the caller of WriteSegments.
         rv = NS_OK;
         break;
       }
@@ -1809,16 +1820,23 @@ nsPipeOutputStream::AsyncWait(nsIOutputS
       // queue up callback object to be notified when data becomes available
       mCallback = aCallback;
       mCallbackFlags = aFlags;
     }
   }
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsPipeOutputStream::Init(nsIOutputStream*, uint32_t)
+{
+  MOZ_CRASH("nsPipeOutputStream should never be initialized with "
+            "nsIBufferedOutputStream::Init!\n");
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 
 nsresult
 NS_NewPipe(nsIInputStream** aPipeIn,
            nsIOutputStream** aPipeOut,
            uint32_t aSegmentSize,
            uint32_t aMaxSize,
            bool aNonBlockingInput,
diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -952,16 +952,17 @@ TEST(Pipes, Close_During_Read_Full_Segme
 TEST(Pipes, Interfaces)
 {
   nsCOMPtr<nsIInputStream> reader;
   nsCOMPtr<nsIOutputStream> writer;
 
   nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer));
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
+  // nsPipeInputStream interfaces
   nsCOMPtr<nsIAsyncInputStream> readerType1 = do_QueryInterface(reader);
   ASSERT_TRUE(readerType1);
 
   nsCOMPtr<nsISeekableStream> readerType2 = do_QueryInterface(reader);
   ASSERT_TRUE(readerType2);
 
   nsCOMPtr<nsISearchableInputStream> readerType3 = do_QueryInterface(reader);
   ASSERT_TRUE(readerType3);
@@ -970,9 +971,18 @@ TEST(Pipes, Interfaces)
   ASSERT_TRUE(readerType4);
 
   nsCOMPtr<nsIClassInfo> readerType5 = do_QueryInterface(reader);
   ASSERT_TRUE(readerType5);
 
   nsCOMPtr<nsIBufferedInputStream> readerType6 = do_QueryInterface(reader);
   ASSERT_TRUE(readerType6);
 
+  // nsPipeOutputStream interfaces
+  nsCOMPtr<nsIAsyncOutputStream> writerType1 = do_QueryInterface(writer);
+  ASSERT_TRUE(writerType1);
+
+  nsCOMPtr<nsIBufferedOutputStream> writerType2 = do_QueryInterface(writer);
+  ASSERT_TRUE(writerType2);
+
+  nsCOMPtr<nsIClassInfo> writerType3 = do_QueryInterface(writer);
+  ASSERT_TRUE(writerType3);
 }
