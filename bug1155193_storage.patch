# HG changeset patch
# Parent a35163f83d22a34de0d34bda0f656b1ce57b9c41
# User Ben Kelly <ben@wanderview.com>
Bug 1155193 Proxy release the connection in mozStorageService::unregisterConnection(). r=asuth

diff --git a/storage/src/mozStorageService.cpp b/storage/src/mozStorageService.cpp
--- a/storage/src/mozStorageService.cpp
+++ b/storage/src/mozStorageService.cpp
@@ -319,19 +319,30 @@ Service::unregisterConnection(Connection
 {
   // If this is the last Connection it might be the only thing keeping Service
   // alive.  So ensure that Service is destroyed only after the Connection is
   // cleanly unregistered and destroyed.
   nsRefPtr<Service> kungFuDeathGrip(this);
   {
     mRegistrationMutex.AssertNotCurrentThreadOwns();
     MutexAutoLock mutex(mRegistrationMutex);
-    DebugOnly<bool> removed = mConnections.RemoveElement(aConnection);
-    // Assert if we try to unregister a non-existent connection.
-    MOZ_ASSERT(removed);
+
+    for (uint32_t i = 0 ; i < mConnections.Length(); ++i) {
+      if (mConnections[i] == aConnection) {
+        // Ensure the connection is released on its opening thread
+        if (NS_GetCurrentThread() != mConnections[i]->threadOpenedOn) {
+          NS_ProxyRelease(mConnections[i]->threadOpenedOn,
+            static_cast<mozIStorageConnection*>(mConnections[i].forget().take()));
+        }
+        mConnections.RemoveElementAt(i);
+        return;
+      }
+    }
+
+    MOZ_ASSERT_UNREACHABLE("Attempt to unregister unknown storage connection!");
   }
 }
 
 void
 Service::getConnections(/* inout */ nsTArray<nsRefPtr<Connection> >& aConnections)
 {
   mRegistrationMutex.AssertNotCurrentThreadOwns();
   MutexAutoLock mutex(mRegistrationMutex);
