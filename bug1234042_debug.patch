# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  946ed22cad04431c75ab5093989dfedf1bae5a3e

diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/unregister-then-register-new-script.https.html b/testing/web-platform/mozilla/tests/service-workers/service-worker/unregister-then-register-new-script.https.html
--- a/testing/web-platform/mozilla/tests/service-workers/service-worker/unregister-then-register-new-script.https.html
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/unregister-then-register-new-script.https.html
@@ -10,30 +10,35 @@ async_test(function(t) {
     var new_worker_url = worker_url + '?new';
     var iframe;
     var registration;
     var new_registration;
 
     service_worker_unregister_and_register(t, worker_url, scope)
       .then(function(r) {
           registration = r;
+          dump('### ### 1\n');
           return wait_for_state(t, r.installing, 'activated');
         })
       .then(function() {
+          dump('### ### 2\n');
           return with_iframe(scope);
         })
       .then(function(frame) {
           iframe = frame;
+          dump('### ### 3\n');
           return registration.unregister();
         })
       .then(function() {
+          dump('### ### 4\n');
           return navigator.serviceWorker.register(new_worker_url,
                                                   { scope: scope });
         })
       .then(function(r) {
+          dump('### ### 5\n');
           new_registration = r;
           assert_equals(registration.installing.scriptURL,
                         normalizeURL(new_worker_url),
                         'before activated registration.installing');
           assert_equals(registration.waiting, null,
                         'before activated registration.waiting');
           assert_equals(registration.active.scriptURL, normalizeURL(worker_url),
                         'before activated registration.active');
@@ -41,73 +46,86 @@ async_test(function(t) {
                         normalizeURL(new_worker_url),
                         'before activated new_registration.installing');
           assert_equals(new_registration.waiting, null,
                         'before activated new_registration.waiting');
           assert_equals(new_registration.active.scriptURL,
                         normalizeURL(worker_url),
                         'before activated new_registration.active');
           iframe.remove();
+          dump('### ### 6\n');
           return wait_for_state(t, registration.installing, 'activated');
         })
       .then(function() {
+          dump('### ### 7\n');
           assert_equals(new_registration.installing, null,
                         'after activated new_registration.installing');
           assert_equals(new_registration.waiting, null,
                         'after activated new_registration.waiting');
           assert_equals(new_registration.active.scriptURL,
                         normalizeURL(new_worker_url),
                         'after activated new_registration.active');
+          dump('### ### 8\n');
           return with_iframe(scope);
         })
       .then(function(frame) {
+          dump('### ### 9\n');
           assert_equals(
               frame.contentWindow.navigator.serviceWorker.controller.scriptURL,
               normalizeURL(new_worker_url),
               'the new worker should control a new document');
           frame.remove();
+          dump('### ### 10\n');
           return registration.unregister();
         })
       .then(function() {
+          dump('### ### 11\n');
           t.done();
         })
       .catch(unreached_rejection(t));
 }, 'Registering a new script URL while an unregistered registration is in use');
 
 async_test(function(t) {
     var scope = 'resources/scope/unregister-then-register-new-script-that-404s';
     var iframe;
     var registration;
 
+    dump('### ### a\n');
     service_worker_unregister_and_register(t, worker_url, scope)
       .then(function(r) {
+          dump('### ### b\n');
           registration = r;
           return wait_for_state(t, r.installing, 'activated');
         })
       .then(function() {
+          dump('### ### c\n');
           return with_iframe(scope);
         })
       .then(function(frame) {
+          dump('### ### d\n');
           iframe = frame;
           return registration.unregister();
         })
       .then(function() {
+          dump('### ### e\n');
           var promise = navigator.serviceWorker.register('this-will-404',
                                                          { scope: scope });
           iframe.remove();
           return promise;
         })
       .then(
         function() {
           assert_unreached('register should reject the promise');
         },
         function() {
+          dump('### ### f\n');
           return with_iframe(scope);
         })
       .then(function(frame) {
+          dump('### ### g\n');
           assert_equals(frame.contentWindow.navigator.serviceWorker.controller.scriptURL,
                         normalizeURL(worker_url),
                         'register() should always abort uninstalling the registration');
           frame.remove();
           t.done();
         })
       .catch(unreached_rejection(t));
 }, 'Registering a new script URL that 404s does resurrect an ' +
