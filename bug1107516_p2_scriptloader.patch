# HG changeset patch
# Parent 0a0bb31383bab22044f8368eb51c7d6c399289c8
# User Ben Kelly <ben@wanderview.com>
Bug 1107516 P2 Create a LoadContext if one is not provided in worker ScriptLoader.


diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -24,30 +24,33 @@
 #include "nsNetUtil.h"
 #include "nsScriptLoader.h"
 #include "nsString.h"
 #include "nsTArray.h"
 #include "nsThreadUtils.h"
 #include "nsXPCOM.h"
 #include "xpcpublic.h"
 
+#include "mozilla/LoadContext.h"
 #include "mozilla/dom/Exceptions.h"
 #include "Principal.h"
 #include "WorkerFeature.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
 #define MAX_CONCURRENT_SCRIPTS 1000
 
 USING_WORKERS_NAMESPACE
 
 using mozilla::dom::workers::exceptions::ThrowDOMExceptionForNSResult;
 
 namespace {
 
+using mozilla::LoadContext;
+
 nsresult
 ChannelFromScriptURL(nsIPrincipal* principal,
                      nsIURI* baseURI,
                      nsIDocument* parentDoc,
                      nsILoadGroup* loadGroup,
                      nsIIOService* ios,
                      nsIScriptSecurityManager* secMan,
                      const nsAString& aScriptURL,
@@ -97,44 +100,56 @@ ChannelFromScriptURL(nsIPrincipal* princ
     rv = principal->CheckMayLoad(uri, false, true);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
   else {
     rv = secMan->CheckLoadURIWithPrincipal(principal, uri, 0);
     NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SECURITY_ERR);
   }
 
+  // Try to determine if the load group already has a load context
+  nsCOMPtr<nsILoadContext> existingLoadContext;
+  if (loadGroup) {
+    nsCOMPtr<nsIInterfaceRequestor> callbacks;
+    rv = loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    existingLoadContext = do_QueryInterface(callbacks);
+  }
+
+  // If there is no load context then we need to set one in order for the
+  // principal to make it through the channel successfully.
+  nsRefPtr<LoadContext> loadContext;
+  if (!existingLoadContext) {
+    rv = LoadContext::ForPrincipal(principal, getter_AddRefs(loadContext));
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
   uint32_t flags = nsIRequest::LOAD_NORMAL | nsIChannel::LOAD_CLASSIFY_URI;
 
   nsCOMPtr<nsIChannel> channel;
   // If we have the document, use it
   if (parentDoc) {
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
                        parentDoc,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
-                       nullptr, // aCallbacks
+                       loadContext,
                        flags,
                        ios);
   } else {
-    // we should use 'principal' here; needs to be fixed before
-    // we move security checks to AsyncOpen. We use nullPrincipal
-    // for now, because the loadGroup is null and hence causes
-    // GetChannelUriPrincipal to return the wrong principal.
-    nsCOMPtr<nsIPrincipal> nullPrincipal =
-      do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
     rv = NS_NewChannel(getter_AddRefs(channel),
                        uri,
-                       nullPrincipal,
+                       principal,
                        nsILoadInfo::SEC_NORMAL,
                        nsIContentPolicy::TYPE_SCRIPT,
                        loadGroup,
-                       nullptr, // aCallbacks
+                       loadContext,
                        flags,
                        ios);
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   channel.forget(aChannel);
   return rv;
