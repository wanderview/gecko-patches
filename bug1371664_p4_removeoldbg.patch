# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  84b465eda443b2ca51b08dd177cb3ac7f2e9aa0f
Bug 1371664 P4 Remove old TimeoutManager code that adjusted Timeout::When() while in background. r=ehsan

diff --git a/dom/base/Timeout.cpp b/dom/base/Timeout.cpp
--- a/dom/base/Timeout.cpp
+++ b/dom/base/Timeout.cpp
@@ -49,26 +49,24 @@ Timeout::SetWhenOrTimeRemaining(const Ti
 
   // If we are frozen simply set mTimeRemaining to be the "time remaining" in
   // the timeout (i.e., the interval itself).  This will be used to create a
   // new mWhen time when the window is thawed.  The end effect is that time does
   // not appear to pass for frozen windows.
   if (mWindow->IsFrozen()) {
     mWhen = TimeStamp();
     mTimeRemaining = aDelay;
-    mScheduledDelay = TimeDuration(0);
     return;
   }
 
   // Since we are not frozen we must set a precise mWhen target wakeup
   // time.  Even if we are suspended we want to use this target time so
   // that it appears time passes while suspended.
   mWhen = aBaseTime + aDelay;
   mTimeRemaining = TimeDuration(0);
-  mScheduledDelay = aDelay;
 }
 
 const TimeStamp&
 Timeout::When() const
 {
   MOZ_DIAGNOSTIC_ASSERT(!mWhen.IsNull());
   // Note, mWindow->IsFrozen() can be true here.  The Freeze() method calls
   // When() to calculate the delay to populate mTimeRemaining.
@@ -79,17 +77,10 @@ const TimeDuration&
 Timeout::TimeRemaining() const
 {
   MOZ_DIAGNOSTIC_ASSERT(mWhen.IsNull());
   // Note, mWindow->IsFrozen() can be false here.  The Thaw() method calls
   // TimeRemaining() to calculate the new When() value.
   return mTimeRemaining;
 }
 
-const TimeDuration&
-Timeout::ScheduledDelay() const
-{
-  MOZ_DIAGNOSTIC_ASSERT(!mWhen.IsNull());
-  return mScheduledDelay;
-}
-
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -45,19 +45,16 @@ public:
                               const TimeDuration& aDelay);
 
   // Can only be called when not frozen.
   const TimeStamp& When() const;
 
   // Can only be called when frozen.
   const TimeDuration& TimeRemaining() const;
 
-  // Can only be called when not frozen.
-  const TimeDuration& ScheduledDelay() const;
-
   // Window for which this timeout fires
   RefPtr<nsGlobalWindow> mWindow;
 
   // True if the timeout was cleared
   bool mCleared;
 
   // True if this is one of the timeouts that are currently running
   bool mRunning;
@@ -96,19 +93,15 @@ private:
   // have constructors.
   // Nominal time to run this timeout.  Use only when timeouts are not
   // frozen.
   TimeStamp mWhen;
 
   // Remaining time to wait.  Used only when timeouts are frozen.
   TimeDuration mTimeRemaining;
 
-  // The actual interval in milliseconds.  This may be throttled to
-  // a longer delay than mInterval for a number of reasons.
-  TimeDuration mScheduledDelay;
-
   ~Timeout() = default;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_timeout_h
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -141,16 +141,19 @@ static int32_t gTrackingTimeoutThrottlin
 static bool    gAnnotateTrackingChannels = false;
 
 // static
 const uint32_t TimeoutManager::InvalidFiringId = 0;
 
 bool
 TimeoutManager::IsBackground() const
 {
+  // Don't use the background timeout value when the tab is playing audio.
+  // Until bug 1336484 we only used to do this for pages that use Web Audio.
+  // The original behavior was implemented in bug 11811073.
   return !mWindow.AsInner()->IsPlayingAudio() && mWindow.IsBackgroundInternal();
 }
 
 uint32_t
 TimeoutManager::CreateFiringId()
 {
   uint32_t id = mNextFiringId;
   mNextFiringId += 1;
@@ -222,25 +225,19 @@ TimeoutManager::IsInvalidFiringId(uint32
   // should be rare.  It can only happen with deeply nested event
   // loop spinning.  For example, a page that does a lot of timers
   // and a lot of sync XHRs within those timers could be slow here.
   return !mFiringIdStack.Contains(aFiringId);
 }
 
 int32_t
 TimeoutManager::DOMMinTimeoutValue(bool aIsTracking) const {
-  // Don't use the background timeout value when the tab is playing audio.
-  // Until bug 1336484 we only used to do this for pages that use Web Audio.
-  // The original behavior was implemented in bug 11811073.
-  bool isBackground = IsBackground();
   bool throttleTracking = aIsTracking && mThrottleTrackingTimeouts;
-  auto minValue = throttleTracking ? (isBackground ? gMinTrackingBackgroundTimeoutValue
-                                                   : gMinTrackingTimeoutValue)
-                                   : (isBackground ? gMinBackgroundTimeoutValue
-                                                   : gMinTimeoutValue);
+  auto minValue = throttleTracking ? gMinTrackingTimeoutValue
+                                   : gMinTimeoutValue;
   return minValue;
 }
 
 #define TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY 0 // Consider all timeouts coming from tracking scripts as tracking
 // These strategies are useful for testing.
 #define ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY        1 // Consider all timeouts as normal
 #define ALTERNATE_TIMEOUT_BUCKETING_STRATEGY         2 // Put every other timeout in the list of tracking timeouts
 #define RANDOM_TIMEOUT_BUCKETING_STRATEGY            3 // Put timeouts into either the normal or tracking timeouts list randomly
@@ -413,17 +410,16 @@ TimeoutManager::SetTimeout(nsITimeoutHan
              timeout.get(), timeout->mIsTracking ? "" : "non-"));
     break;
   }
 
   // Now clamp the actual interval we will use for the timer based on
   uint32_t nestingLevel = sNestingLevel + 1;
   uint32_t realInterval = interval;
   if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL ||
-      mWindow.IsBackgroundInternal() ||
       timeout->mIsTracking) {
     // Don't allow timeouts less than DOMMinTimeoutValue() from
     // now...
     realInterval = std::max(realInterval,
                             uint32_t(DOMMinTimeoutValue(timeout->mIsTracking)));
   }
 
   timeout->mWindow = &mWindow;
@@ -481,17 +477,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
            "minimum=%i, throttling=%s, background=%d, realInterval=%i) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
            this, timeout.get(), interval,
            DOMMinTimeoutValue(timeout->mIsTracking),
            mThrottleTrackingTimeouts ? "yes"
                                      : (mThrottleTrackingTimeoutsTimer ?
                                           "pending" : "no"),
-           int(mWindow.IsBackgroundInternal()), realInterval,
+           int(IsBackground()), realInterval,
            timeout->mIsTracking ? "" : "non-",
            timeout->mTimeoutId));
 
   return NS_OK;
 }
 
 void
 TimeoutManager::ClearTimeout(int32_t aTimerId, Timeout::Reason aReason)
@@ -833,136 +829,16 @@ TimeoutManager::RescheduleTimeout(Timeou
 
   nsresult rv = mExecutor->MaybeSchedule(aTimeout->When(),
                                          MinSchedulingDelay());
   NS_ENSURE_SUCCESS(rv, false);
 
   return true;
 }
 
-nsresult
-TimeoutManager::ResetTimersForThrottleReduction()
-{
-  return ResetTimersForThrottleReduction(gMinBackgroundTimeoutValue);
-}
-
-nsresult
-TimeoutManager::ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS)
-{
-  MOZ_ASSERT(aPreviousThrottleDelayMS > 0);
-
-  MOZ_ASSERT_IF(mWindow.IsFrozen(), mWindow.IsSuspended());
-  if (mWindow.IsSuspended()) {
-    return NS_OK;
-  }
-
-  nsresult rv = mNormalTimeouts.ResetTimersForThrottleReduction(aPreviousThrottleDelayMS,
-                                                                *this,
-                                                                Timeouts::SortBy::TimeWhen);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = mTrackingTimeouts.ResetTimersForThrottleReduction(aPreviousThrottleDelayMS,
-                                                         *this,
-                                                         Timeouts::SortBy::TimeWhen);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  OrderedTimeoutIterator iter(mNormalTimeouts, mTrackingTimeouts);
-  Timeout* firstTimeout = iter.Next();
-  if (firstTimeout) {
-    rv = mExecutor->MaybeSchedule(firstTimeout->When(), MinSchedulingDelay());
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  return NS_OK;
-}
-
-nsresult
-TimeoutManager::Timeouts::ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
-                                                          const TimeoutManager& aTimeoutManager,
-                                                          SortBy aSortBy)
-{
-  TimeStamp now = TimeStamp::Now();
-
-  for (RefPtr<Timeout> timeout = GetFirst(); timeout; ) {
-    // Skip over any Timeout values with a valid FiringId.  These are in the
-    // middle of a RunTimeout and should not be modified.  Also, skip any
-    // timeouts in the past.  It's important that this check be <= so that we
-    // guarantee that taking std::max with |now| won't make a quantity equal to
-    // timeout->When() below.
-    if (mManager.IsValidFiringId(timeout->mFiringId) ||
-        timeout->When() <= now) {
-      timeout = timeout->getNext();
-      continue;
-    }
-
-    if (timeout->When() - now >
-        TimeDuration::FromMilliseconds(aPreviousThrottleDelayMS)) {
-      // No need to loop further.  Timeouts are sorted in When() order
-      // and the ones after this point were all set up for at least
-      // gMinBackgroundTimeoutValue ms and hence were not clamped.
-      break;
-    }
-
-    // We reduced our throttled delay. Re-init the timer appropriately.
-    // Compute the interval the timer should have had if it had not been set in a
-    // background window
-    TimeDuration interval =
-      TimeDuration::FromMilliseconds(
-          std::max(timeout->mInterval,
-                   uint32_t(aTimeoutManager.
-                                DOMMinTimeoutValue(timeout->mIsTracking))));
-    const TimeDuration& oldInterval = timeout->ScheduledDelay();
-    if (oldInterval > interval) {
-      // unclamp
-      TimeStamp firingTime =
-        std::max(timeout->When() - oldInterval + interval, now);
-
-      NS_ASSERTION(firingTime < timeout->When(),
-                   "Our firing time should strictly decrease!");
-
-      TimeDuration delay = firingTime - now;
-      timeout->SetWhenOrTimeRemaining(now, delay);
-      MOZ_DIAGNOSTIC_ASSERT(timeout->When() == firingTime);
-
-      // Since we reset When() we need to move |timeout| to the right
-      // place in the list so that it remains sorted by When().
-
-      // Get the pointer to the next timeout now, before we move the
-      // current timeout in the list.
-      Timeout* nextTimeout = timeout->getNext();
-
-      // Since we are only reducing intervals in this method we can
-      // make an optimization here.  If the reduction does not cause us
-      // to fall before our previous timeout then we do not have to
-      // remove and re-insert the current timeout.  This is important
-      // because re-insertion makes this algorithm O(n^2).  Since we
-      // will typically be shifting a lot of timers at once this
-      // optimization saves us a lot of work.
-      Timeout* prevTimeout = timeout->getPrevious();
-      if (prevTimeout && prevTimeout->When() > timeout->When()) {
-        // It is safe to remove and re-insert because When() is now
-        // strictly smaller than it used to be, so we know we'll insert
-        // |timeout| before nextTimeout.
-        NS_ASSERTION(!nextTimeout ||
-                     timeout->When() < nextTimeout->When(), "How did that happen?");
-        timeout->remove();
-        // Insert() will reset mFiringId. Make sure to undo that.
-        uint32_t firingId = timeout->mFiringId;
-        Insert(timeout, aSortBy);
-        timeout->mFiringId = firingId;
-      }
-
-      timeout = nextTimeout;
-    } else {
-      timeout = timeout->getNext();
-    }
-  }
-
-  return NS_OK;
-}
-
 void
 TimeoutManager::ClearAllTimeouts()
 {
   bool seenRunningTimeout = false;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("ClearAllTimeouts(TimeoutManager=%p)\n", this));
 
@@ -1165,20 +1041,16 @@ TimeoutManager::Thaw()
     aTimeout->SetWhenOrTimeRemaining(now, aTimeout->TimeRemaining());
     MOZ_DIAGNOSTIC_ASSERT(!aTimeout->When().IsNull());
   });
 }
 
 void
 TimeoutManager::MaybeUpdateBackgroundState()
 {
-  if (!IsBackground()) {
-    ResetTimersForThrottleReduction();
-  }
-
   // When the window moves to the background or foreground we should
   // reschedule the TimeoutExecutor in case the MinSchedulingDelay()
   // changed.  Only do this if the window is not suspended and we
   // actually have a timeout.
   if (!mWindow.IsSuspended()) {
     OrderedTimeoutIterator iter(mNormalTimeouts, mTrackingTimeouts);
     Timeout* nextTimeout = iter.Next();
     if (nextTimeout) {
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -50,21 +50,16 @@ public:
   // The timeout implementation functions.
   void RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline);
   // Return true if |aTimeout| needs to be reinserted into the timeout list.
   bool RescheduleTimeout(mozilla::dom::Timeout* aTimeout, const TimeStamp& now);
 
   void ClearAllTimeouts();
   uint32_t GetTimeoutId(mozilla::dom::Timeout::Reason aReason);
 
-  // When timers are being throttled and we reduce the thottle delay we must
-  // reschedule.  The amount of the old throttle delay must be provided in
-  // order to bound how many timers must be examined.
-  nsresult ResetTimersForThrottleReduction();
-
   int32_t DOMMinTimeoutValue(bool aIsTracking) const;
 
   // aTimeout is the timeout that we're about to start running.  This function
   // returns the current timeout.
   mozilla::dom::Timeout* BeginRunningTimeout(mozilla::dom::Timeout* aTimeout);
   // aTimeout is the last running timeout.
   void EndRunningTimeout(mozilla::dom::Timeout* aTimeout);
 
@@ -115,17 +110,16 @@ public:
   void EndSyncOperation();
 
   nsIEventTarget*
   EventTarget();
 
   static const uint32_t InvalidFiringId;
 
 private:
-  nsresult ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS);
   void MaybeStartThrottleTrackingTimout();
 
   bool IsBackground() const;
 
   uint32_t
   CreateFiringId();
 
   void
@@ -151,19 +145,16 @@ private:
     // fire after it, but no earlier than the last Timeout with a
     // valid FiringId.
     enum class SortBy
     {
       TimeRemaining,
       TimeWhen
     };
     void Insert(mozilla::dom::Timeout* aTimeout, SortBy aSortBy);
-    nsresult ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS,
-                                             const TimeoutManager& aTimeoutManager,
-                                             SortBy aSortBy);
 
     const Timeout* GetFirst() const { return mTimeoutList.getFirst(); }
     Timeout* GetFirst() { return mTimeoutList.getFirst(); }
     const Timeout* GetLast() const { return mTimeoutList.getLast(); }
     Timeout* GetLast() { return mTimeoutList.getLast(); }
     bool IsEmpty() const { return mTimeoutList.isEmpty(); }
     void InsertFront(Timeout* aTimeout) { mTimeoutList.insertFront(aTimeout); }
     void Clear() { mTimeoutList.clear(); }
