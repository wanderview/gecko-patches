# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bcbf4c7b1a053f6f760b1b44d7b345fd32c3b413
Bug 1204254 P10 Notify "service-worker-synthesized-response" topic when synthesis starts so devtools can trace the channel. r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -211,26 +211,16 @@ public:
       return NS_OK;
     }
 
     TimeStamp timeStamp = TimeStamp::Now();
     mChannel->SetHandleFetchEventEnd(timeStamp);
     mChannel->SetFinishSynthesizedResponseEnd(timeStamp);
     mChannel->SaveTimeStamps();
 
-    nsCOMPtr<nsIObserverService> obsService = services::GetObserverService();
-    if (obsService) {
-      nsCOMPtr<nsIChannel> underlyingChannel;
-      nsresult rv = mChannel->GetChannel(getter_AddRefs(underlyingChannel));
-      NS_ENSURE_SUCCESS(rv, rv);
-      NS_ENSURE_TRUE(underlyingChannel, NS_ERROR_UNEXPECTED);
-
-      obsService->NotifyObservers(underlyingChannel, "service-worker-synthesized-response", nullptr);
-    }
-
     return rv;
   }
 };
 
 class BodyCopyHandle final : public nsIInterceptedBodyCallback
 {
   UniquePtr<RespondWithClosure> mClosure;
 
@@ -357,16 +347,21 @@ public:
 
     rv = mChannel->StartSynthesizedResponse(body, copyHandle,
                                             mResponseURLSpec);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
+    nsCOMPtr<nsIObserverService> obsService = services::GetObserverService();
+    if (obsService) {
+      obsService->NotifyObservers(underlyingChannel, "service-worker-synthesized-response", nullptr);
+    }
+
     return rv;
   }
 
   bool CSPPermitsResponse(nsILoadInfo* aLoadInfo)
   {
     AssertIsOnMainThread();
     MOZ_ASSERT(aLoadInfo);
     nsresult rv;
diff --git a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
--- a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
+++ b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
@@ -81,18 +81,17 @@ function register(aWindow, aURL, aScope)
       });
     });
 }
 
 function fetchAndCheckTimedChannel(aWindow, aIntercepted, aFetch, aURL) {
   var resolveFunction;
   var promise = new Promise(aResolve => resolveFunction = aResolve);
 
-  var topic = aFetch ? "http-on-examine-response"
-                     : "service-worker-synthesized-response";
+  var topic = "http-on-stop-request";
 
   function observer(aSubject) {
     var channel = aSubject.QueryInterface(Ci.nsIChannel);
 
     // Since we cannot make sure that the network event triggered by the fetch()
     // in this testcase is the very next event processed by ObserverService, we
     // have to wait until we catch the one we want.
     if (!channel.URI.spec.endsWith(aURL)) {
