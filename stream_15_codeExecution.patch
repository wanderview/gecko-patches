# HG changeset patch
# User Andrea Marchesini <amarchesini@mozilla.com>
# Parent  6bc79123d1cdd25b86ff1cbe755ecf4389c247ae
Bug 1128959 - Implement the WHATWG Streams spec - part 15 - setting the correct global when ReadableStream.getReader() is called, r?bz

diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -1153,16 +1153,20 @@ FetchBody<Response>::GetBody(JSContext* 
                              ErrorResult& aRv);
 
 template <class Derived>
 void
 FetchBody<Derived>::LockStream(JSContext* aCx,
                                JS::HandleObject aStream,
                                ErrorResult& aRv)
 {
+  MOZ_ASSERT(JS::ReadableStreamGetMode(aStream) ==
+               JS::ReadableStreamMode::ExternalSource);
+
+  // This is native stream, creating a reader will not execute any JS code.
   JS::Rooted<JSObject*> reader(aCx,
                                JS::ReadableStreamGetReader(aCx, aStream,
                                                            JS::ReadableStreamReaderMode::Default));
   if (!reader) {
     aRv.StealExceptionFromJSContext(aCx);
     return;
   }
 
diff --git a/dom/fetch/FetchStreamReader.cpp b/dom/fetch/FetchStreamReader.cpp
--- a/dom/fetch/FetchStreamReader.cpp
+++ b/dom/fetch/FetchStreamReader.cpp
@@ -165,27 +165,23 @@ FetchStreamReader::OnOutputStreamReady(n
   if (mStreamClosed) {
     return NS_OK;
   }
 
   if (mBuffer) {
     return WriteBuffer();
   }
 
-  AutoJSAPI jsapi;
-  if (NS_WARN_IF(!jsapi.Init(mGlobal))) {
-    CloseAndRelease(NS_ERROR_DOM_INVALID_STATE_ERR);
-    return NS_ERROR_FAILURE;
-  }
+  // TODO: We need to verify this is the correct global per the spec.
+  //       See bug 1385890.
+  AutoEntryScript aes(mGlobal, "ReadableStreamReader.read", !mWorkerHolder);
 
-  JSContext* cx = jsapi.cx();
-
-  JS::Rooted<JSObject*> reader(cx, mReader);
-  JS::Rooted<JSObject*> promise(cx,
-                                JS::ReadableStreamDefaultReaderRead(cx,
+  JS::Rooted<JSObject*> reader(aes.cx(), mReader);
+  JS::Rooted<JSObject*> promise(aes.cx(),
+                                JS::ReadableStreamDefaultReaderRead(aes.cx(),
                                                                     reader));
   if (NS_WARN_IF(!promise)) {
     // Let's close the stream.
     CloseAndRelease(NS_ERROR_DOM_INVALID_STATE_ERR);
     return NS_ERROR_FAILURE;
   }
 
   RefPtr<Promise> domPromise = Promise::CreateFromExisting(mGlobal, promise);
diff --git a/dom/tests/mochitest/fetch/common_readableStreams.js b/dom/tests/mochitest/fetch/common_readableStreams.js
--- a/dom/tests/mochitest/fetch/common_readableStreams.js
+++ b/dom/tests/mochitest/fetch/common_readableStreams.js
@@ -1,11 +1,12 @@
 const SAME_COMPARTMENT = "same-compartment";
 const IFRAME_COMPARTMENT = "iframe-compartment";
 const BIG_BUFFER_SIZE = 1000000;
+const ITER_MAX = 10;
 
 function makeBuffer(size) {
   let buffer = new Uint8Array(size);
   buffer.fill(42);
 
   let value = 0;
   for (let i = 0; i < 1000000; i+= 1000) {
     buffer.set([++value % 255], i);
@@ -264,16 +265,59 @@ async function test_codeExecution_contin
   var cl = new consoleListener();
 
   r.body.getReader().read();
   await promise;
 
   that.next();
 };
 
+async function test_global(compartment) {
+  info("test_global: " + compartment);
+
+  self.foo = 42;
+  self.iter = ITER_MAX;
+
+  let r = new Response(new ReadableStream({
+    start(c) {
+      self.controller = c;
+    },
+    pull() {
+      if (!("iter" in self) || self.iter < 0 || self.iter > ITER_MAX) {
+        throw "Something bad is happening here!"
+      }
+
+      let buffer = new Uint8Array(1);
+      buffer.fill(self.foo);
+      self.controller.enqueue(buffer);
+
+      if (--self.iter == 0) {
+        controller.close();
+      }
+    }
+  }));
+
+  apply_compartment(compartment,
+                    { func: "test_global_continue",
+                    args: r });
+}
+
+async function test_global_continue(r, that) {
+  let a = await r.arrayBuffer();
+
+  that.is(Object.getPrototypeOf(a), that.ArrayBuffer.prototype, "Body is an array buffer");
+  that.is(a.byteLength, ITER_MAX, "Body length is correct");
+
+  for (let i = 0; i < ITER_MAX; ++i) {
+    that.is(new Uint8Array(a)[i], 42, "Byte " + i + " is correct");
+  }
+
+  that.next();
+};
+
 function workify(func) {
   info("Workifing " + func);
 
   let worker = new Worker('worker_readableStreams.js');
   worker.postMessage(func);
   worker.onmessage = function(e) {
     if (e.data.type == 'done') {
       next();
diff --git a/dom/tests/mochitest/fetch/test_readableStreams.html b/dom/tests/mochitest/fetch/test_readableStreams.html
--- a/dom/tests/mochitest/fetch/test_readableStreams.html
+++ b/dom/tests/mochitest/fetch/test_readableStreams.html
@@ -43,16 +43,20 @@ let tests = [
   function() { workify('test_nativeStream_cache'); },
 
   function() { test_nonNativeStream_cache(SAME_COMPARTMENT); },
   function() { test_nonNativeStream_cache(IFRAME_COMPARTMENT); },
   function() { workify('test_nonNativeStream_cache'); },
 
   function() { test_codeExecution(SAME_COMPARTMENT); },
   function() { test_codeExecution(IFRAME_COMPARTMENT); },
+
+  function() { test_global(SAME_COMPARTMENT); },
+  function() { test_global(IFRAME_COMPARTMENT); },
+  function() { workify('test_global'); },
 ];
 
 function next() {
   if (!tests.length) {
     SimpleTest.finish();
     return;
   }
 
