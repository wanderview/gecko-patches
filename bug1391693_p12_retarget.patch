# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  826891a1b2a5a26b0d2d5641eb97658a589b758e
Bug 1391693 P12 Make InterceptedHttpChannel actually support OMT retargeting. r=valentin

diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -13,23 +13,27 @@ namespace net {
 
 NS_IMPL_ISUPPORTS_INHERITED(InterceptedHttpChannel,
                             HttpBaseChannel,
                             nsIInterceptedChannel,
                             nsIAsyncVerifyRedirectCallback,
                             nsIRequestObserver,
                             nsIStreamListener,
                             nsIChannelWithDivertableParentListener,
-                            nsIThreadRetargetableRequest)
+                            nsIThreadRetargetableRequest,
+                            nsIThreadRetargetableStreamListener)
 
 InterceptedHttpChannel::InterceptedHttpChannel()
   : HttpAsyncAborter<InterceptedHttpChannel>(this)
+  , mProgress(0)
+  , mProgressReported(0)
   , mSynthesizedStreamLength(-1)
   , mResumeStartPos(0)
   , mSynthesizedOrReset(Invalid)
+  , mCallingStatusAndProgress(false)
 {
   mChannelCreationTime = PR_Now();
   mChannelCreationTimestamp = TimeStamp::Now();
 }
 
 void
 InterceptedHttpChannel::ReleaseListeners()
 {
@@ -252,16 +256,79 @@ InterceptedHttpChannel::OpenRedirectChan
   }
   NS_ENSURE_SUCCESS(rv, rv);
 
   mStatus = NS_BINDING_REDIRECTED;
 
   return rv;
 }
 
+void
+InterceptedHttpChannel::MaybeCallStatusAndProgress()
+{
+  // OnStatus() and OnProgress() must only be called on the main thread.  If
+  // we are on a separate thread, then we maybe need to schedule a runnable
+  // to call them asynchronousnly.
+  if (!NS_IsMainThread()) {
+    // Check to see if we are already trying to call OnStatus/OnProgress
+    // asynchronously.  If we are, then don't queue up another runnable.
+    // We don't want to flood the main thread.
+    if (mCallingStatusAndProgress) {
+      return;
+    }
+    mCallingStatusAndProgress = true;
+
+    nsCOMPtr<nsIRunnable> r =
+      NewRunnableMethod("InterceptedHttpChannel::MaybeCallStatusAndProgress",
+                        this,
+                        &InterceptedHttpChannel::MaybeCallStatusAndProgress);
+    MOZ_ALWAYS_SUCCEEDS(
+      SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+    return;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // Capture the current status from our atomic count.
+  int64_t progress = mProgress;
+
+  // Note that any asynchronous progress update is now taking place.
+  mCallingStatusAndProgress = false;
+
+  MOZ_DIAGNOSTIC_ASSERT(progress >= mProgressReported);
+
+  // Do nothing if we've already made the calls for this amount of progress
+  // or if the channel is not configured for these calls.  Note, the check
+  // for mProgressSink here means we will not fire any spurious late calls
+  // after ReleaseListeners() is executed.
+  if (progress <= mProgressReported ||
+      mCanceled ||
+      !mProgressSink ||
+      (mLoadFlags & HttpBaseChannel::LOAD_BACKGROUND)) {
+    return;
+  }
+
+  // Capture the host name on the first set of calls to avoid doing this
+  // string processing repeatedly.
+  if (mProgressReported == 0) {
+    nsAutoCString host;
+    MOZ_ALWAYS_SUCCEEDS(mURI->GetHost(host));
+    CopyUTF8toUTF16(host, mStatusHost);
+  }
+
+  mProgressSink->OnStatus(this, mListenerContext, NS_NET_STATUS_READING,
+                          mStatusHost.get());
+
+  mProgressSink->OnProgress(this, mListenerContext, progress,
+                            mSynthesizedStreamLength);
+
+  mProgressReported = progress;
+}
+
 // static
 already_AddRefed<InterceptedHttpChannel>
 InterceptedHttpChannel::CreateForInterception()
 {
   // Create an InterceptedHttpChannel that will trigger a FetchEvent
   // in a ServiceWorker when opened.
   RefPtr<InterceptedHttpChannel> ref = new InterceptedHttpChannel();
   return ref.forget();
@@ -778,16 +845,18 @@ InterceptedHttpChannel::SetReleaseHandle
 {
   mReleaseHandle = aHandle;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnRedirectVerifyCallback(nsresult rv)
 {
+  MOZ_ASSERT(NS_IsMainThread());
+
   if (NS_SUCCEEDED(rv)) {
     rv = OpenRedirectChannel();
   }
 
   nsCOMPtr<nsIRedirectResultListener> hook;
   GetCallback(hook);
   if (hook) {
     hook->OnRedirectResult(NS_SUCCEEDED(rv));
@@ -802,66 +871,75 @@ InterceptedHttpChannel::OnRedirectVerify
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnStartRequest(nsIRequest* aRequest,
                                        nsISupports* aContext)
 {
+  MOZ_ASSERT(NS_IsMainThread());
+
   if (!mProgressSink) {
     GetCallback(mProgressSink);
   }
   if (mListener) {
     mListener->OnStartRequest(this, mListenerContext);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnStopRequest(nsIRequest* aRequest,
                                       nsISupports* aContext,
                                       nsresult aStatus)
 {
+  MOZ_ASSERT(NS_IsMainThread());
+
   if (NS_SUCCEEDED(mStatus)) {
     mStatus = aStatus;
   }
+
+  // Its possible that we have any async runnable queued to report some
+  // progress when OnStopRequest() is triggered.  Report any left over
+  // progress immediately.  The extra runnable will then do nothing thanks
+  // to the ReleaseListeners() call below.
+  MaybeCallStatusAndProgress();
+
   mIsPending = false;
+
   if (mListener) {
     mListener->OnStopRequest(this, mListenerContext, mStatus);
   }
+
   ReleaseListeners();
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::OnDataAvailable(nsIRequest* aRequest,
                                         nsISupports* aContext,
                                         nsIInputStream* aInputStream,
                                         uint64_t aOffset,
                                         uint32_t aCount)
 {
+  // Any thread if the channel has been retargeted.
+
   if (mCanceled || !mListener) {
     // If there is no listener, we still need to drain the stream in order
     // maintain necko invariants.
     uint32_t unused = 0;
     aInputStream->ReadSegments(NS_DiscardSegment, nullptr, aCount, &unused);
     return mStatus;
   }
   if (mProgressSink) {
     if (!(mLoadFlags & HttpBaseChannel::LOAD_BACKGROUND)) {
-      nsAutoCString host;
-      mURI->GetHost(host);
-
-      mProgressSink->OnStatus(this, mListenerContext, NS_NET_STATUS_READING,
-                              NS_ConvertUTF8toUTF16(host).get());
-
-      int64_t progress = aOffset + aCount;
-      mProgressSink->OnProgress(this, mListenerContext, progress,
-                                mSynthesizedStreamLength);
+      mProgress = aOffset + aCount;
+      MaybeCallStatusAndProgress();
     }
   }
 
   return mListener->OnDataAvailable(this, mListenerContext, aInputStream,
                                     aOffset, aCount);
 }
 
 NS_IMETHODIMP
@@ -919,10 +997,23 @@ InterceptedHttpChannel::RetargetDelivery
   // we should only be called if we have a pump.
   if (!mPump) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return mPump->RetargetDeliveryTo(aNewTarget);
 }
 
+NS_IMETHODIMP
+InterceptedHttpChannel::CheckListenerChain()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsresult rv = NS_OK;
+  nsCOMPtr<nsIThreadRetargetableStreamListener> retargetableListener =
+  do_QueryInterface(mListener, &rv);
+  if (retargetableListener) {
+    rv = retargetableListener->CheckListenerChain();
+  }
+  return rv;
+}
+
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.h b/netwerk/protocol/http/InterceptedHttpChannel.h
--- a/netwerk/protocol/http/InterceptedHttpChannel.h
+++ b/netwerk/protocol/http/InterceptedHttpChannel.h
@@ -49,37 +49,42 @@ namespace net {
 //    channel and end up calling OnStopRequest() with an error code.
 class InterceptedHttpChannel final : public HttpBaseChannel
                                    , public HttpAsyncAborter<InterceptedHttpChannel>
                                    , public nsIInterceptedChannel
                                    , public nsIAsyncVerifyRedirectCallback
                                    , public nsIStreamListener
                                    , public nsIChannelWithDivertableParentListener
                                    , public nsIThreadRetargetableRequest
+                                   , public nsIThreadRetargetableStreamListener
 {
   friend class HttpAsyncAborter<InterceptedHttpChannel>;
 
   UniquePtr<nsHttpResponseHead> mSynthesizedResponseHead;
   nsCOMPtr<nsIChannel> mRedirectChannel;
   nsCOMPtr<nsIInputStream> mBodyReader;
   nsCOMPtr<nsIOutputStream> mBodyWriter;
   nsCOMPtr<nsISupports> mReleaseHandle;
   nsCOMPtr<nsIProgressEventSink> mProgressSink;
   RefPtr<nsInputStreamPump> mPump;
   RefPtr<ADivertableParentChannel> mParentChannel;
   TimeStamp mFinishResponseStart;
   TimeStamp mFinishResponseEnd;
+  Atomic<int64_t> mProgress;
+  int64_t mProgressReported;
   int64_t mSynthesizedStreamLength;
   uint64_t mResumeStartPos;
   nsCString mResumeEntityId;
+  nsString mStatusHost;
   enum {
     Invalid = 0,
     Synthesized,
     Reset
   } mSynthesizedOrReset;
+  Atomic<bool> mCallingStatusAndProgress;
 
   InterceptedHttpChannel();
   ~InterceptedHttpChannel() = default;
 
   virtual void
   ReleaseListeners() override;
 
   virtual MOZ_MUST_USE nsresult
@@ -97,16 +102,19 @@ class InterceptedHttpChannel final : pub
   RedirectForOpaqueResponse(nsIURI* aResponseURI);
 
   nsresult
   StartPump();
 
   nsresult
   OpenRedirectChannel();
 
+  void
+  MaybeCallStatusAndProgress();
+
 public:
   static already_AddRefed<InterceptedHttpChannel>
   CreateForInterception();
 
   static already_AddRefed<InterceptedHttpChannel>
   CreateForSynthesis(const nsHttpResponseHead* aHead, nsIInputStream* aBody);
 
   NS_IMETHOD
@@ -156,14 +164,15 @@ public:
 
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIINTERCEPTEDCHANNEL
   NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
   NS_DECL_NSIREQUESTOBSERVER
   NS_DECL_NSISTREAMLISTENER
   NS_DECL_NSICHANNELWITHDIVERTABLEPARENTLISTENER
   NS_DECL_NSITHREADRETARGETABLEREQUEST
+  NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
 };
 
 } // namespace net
 } // namespace mozilla
 
 #endif // mozilla_net_InterceptedHttpChannel_h
