# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7855297f24865f818be31b562666b1bdf7718052
Bug 1419536 P4 Allow ClientSource objects to be frozen while in bfcache. r=baku

diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -1527,56 +1527,69 @@ nsGlobalWindowInner::InnerSetNewDocument
   mMutationBits = 0;
 }
 
 nsresult
 nsGlobalWindowInner::EnsureClientSource()
 {
   MOZ_DIAGNOSTIC_ASSERT(mDoc);
 
+  bool newClientSource = false;
+
   nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
   nsCOMPtr<nsILoadInfo> loadInfo = channel ? channel->GetLoadInfo() : nullptr;
 
   // Try to get the reserved client from the LoadInfo.  A Client is
   // reserved at the start of the channel load if there is not an
   // initial about:blank document that will be reused.  It is also
   // created if the channel load encounters a cross-origin redirect.
   if (loadInfo) {
     UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClientSource();
     if (reservedClient) {
       mClientSource.reset();
       mClientSource = Move(reservedClient);
+      newClientSource = true;
     }
   }
 
   // We don't have a LoadInfo reserved client, but maybe we should
   // be inheriting an initial one from the docshell.  This means
   // that the docshell started the channel load before creating the
   // initial about:blank document.  This is an optimization, though,
   // and it created an initial Client as a placeholder for the document.
   // In this case we want to inherit this placeholder Client here.
   if (!mClientSource) {
     nsIDocShell* docshell = GetDocShell();
     if (docshell) {
       mClientSource = docshell->TakeInitialClientSource();
+      if (mClientSource) {
+        newClientSource = true;
+      }
     }
   }
 
   // If we don't have a reserved client or an initial client, then create
   // one now.  This can happen in certain cases where we avoid preallocating
   // the client in the docshell.  This mainly occurs in situations where
   // the principal is not clearly inherited from the parent; e.g. sandboxed
   // iframes, window.open(), etc.
   if (!mClientSource) {
     mClientSource = ClientManager::CreateSource(ClientType::Window,
                                                 EventTargetFor(TaskCategory::Other),
                                                 mDoc->NodePrincipal());
     if (NS_WARN_IF(!mClientSource)) {
       return NS_ERROR_FAILURE;
     }
+    newClientSource = true;
+  }
+
+  // Its possible that we got a client just after being frozen in
+  // the bfcache.  In that case freeze the client immediately.
+  if (newClientSource && IsFrozen()) {
+    mClientSource->Freeze();
   }
 
   return NS_OK;
 }
 
 nsresult
 nsGlobalWindowInner::ExecutionReady()
 {
@@ -6058,16 +6071,19 @@ nsGlobalWindowInner::FreezeInternal()
   MOZ_ASSERT(mSuspendDepth >= mFreezeDepth);
   if (mFreezeDepth != 1) {
     return;
   }
 
   mozilla::dom::workers::FreezeWorkersForWindow(this);
 
   mTimeoutManager->Freeze();
+  if (mClientSource) {
+    mClientSource->Freeze();
+  }
 
   if (IsInnerWindow()) {
     NotifyDOMWindowFrozen(this);
   }
 }
 
 void
 nsGlobalWindowInner::Thaw()
@@ -6089,16 +6105,19 @@ nsGlobalWindowInner::ThawInternal()
 
   MOZ_ASSERT(mFreezeDepth != 0);
   mFreezeDepth -= 1;
   MOZ_ASSERT(mSuspendDepth >= mFreezeDepth);
   if (mFreezeDepth != 0) {
     return;
   }
 
+  if (mClientSource) {
+    mClientSource->Thaw();
+  }
   mTimeoutManager->Thaw();
 
   mozilla::dom::workers::ThawWorkersForWindow(this);
 
   if (IsInnerWindow()) {
     NotifyDOMWindowThawed(this);
   }
 }
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -121,17 +121,18 @@ ClientManagerService::FindSource(const n
   AssertIsOnBackgroundThread();
 
   auto entry = mSourceTable.Lookup(aID);
   if (!entry) {
     return nullptr;
   }
 
   ClientSourceParent* source = entry.Data();
-  if (!MatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
+  if (source->IsFrozen() ||
+      !MatchPrincipalInfo(source->Info().PrincipalInfo(), aPrincipalInfo)) {
     return nullptr;
   }
 
   return source;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -230,16 +230,32 @@ ClientSource::DocShellExecutionReady(nsI
 
   ClientSourceExecutionReadyArgs args(NS_LITERAL_CSTRING("about:blank"),
                                       frameType);
   ExecutionReady(args);
 
   return NS_OK;
 }
 
+void
+ClientSource::Freeze()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendFreeze();
+  });
+}
+
+void
+ClientSource::Thaw()
+{
+  MaybeExecute([](PClientSourceChild* aActor) {
+    aActor->SendThaw();
+  });
+}
+
 const ClientInfo&
 ClientSource::Info() const
 {
   return mClientInfo;
 }
 
 nsISerialEventTarget*
 ClientSource::EventTarget() const
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -77,16 +77,22 @@ public:
   WorkerExecutionReady(mozilla::dom::workers::WorkerPrivate* aWorkerPrivate);
 
   nsresult
   WindowExecutionReady(nsPIDOMWindowInner* aInnerWindow);
 
   nsresult
   DocShellExecutionReady(nsIDocShell* aDocShell);
 
+  void
+  Freeze();
+
+  void
+  Thaw();
+
   const ClientInfo&
   Info() const;
 
   nsISerialEventTarget*
   EventTarget() const;
 };
 
 } // namespace dom
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
--- a/dom/clients/manager/ClientSourceParent.cpp
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -106,16 +106,40 @@ ClientSourceParent::RecvExecutionReady(c
 
   for (ClientHandleParent* handle : mHandleList) {
     Unused << handle->SendExecutionReady(mClientInfo.ToIPC());
   }
 
   return IPC_OK();
 };
 
+IPCResult
+ClientSourceParent::RecvFreeze()
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
+  mFrozen = true;
+
+  // Frozen clients should not be observable.  Act as if the client has
+  // been destroyed.
+  nsTArray<ClientHandleParent*> handleList(mHandleList);
+  for (ClientHandleParent* handle : handleList) {
+    Unused << ClientHandleParent::Send__delete__(handle);
+  }
+
+  return IPC_OK();
+}
+
+IPCResult
+ClientSourceParent::RecvThaw()
+{
+  MOZ_DIAGNOSTIC_ASSERT(mFrozen);
+  mFrozen = false;
+  return IPC_OK();
+}
+
 void
 ClientSourceParent::ActorDestroy(ActorDestroyReason aReason)
 {
   DebugOnly<bool> removed = mService->RemoveSource(this);
   MOZ_ASSERT(removed);
 
   nsTArray<ClientHandleParent*> handleList(mHandleList);
   for (ClientHandleParent* handle : handleList) {
@@ -139,16 +163,17 @@ ClientSourceParent::DeallocPClientSource
   delete aActor;
   return true;
 }
 
 ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
   : mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
   , mService(ClientManagerService::GetOrCreateInstance())
   , mExecutionReady(false)
+  , mFrozen(false)
 {
 }
 
 ClientSourceParent::~ClientSourceParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(mHandleList.IsEmpty());
 }
 
@@ -173,20 +198,27 @@ ClientSourceParent::Init()
 }
 
 const ClientInfo&
 ClientSourceParent::Info() const
 {
   return mClientInfo;
 }
 
+bool
+ClientSourceParent::IsFrozen() const
+{
+  return mFrozen;
+}
+
 void
 ClientSourceParent::AttachHandle(ClientHandleParent* aClientHandle)
 {
   MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
+  MOZ_DIAGNOSTIC_ASSERT(!mFrozen);
   MOZ_ASSERT(!mHandleList.Contains(aClientHandle));
   mHandleList.AppendElement(aClientHandle);
 }
 
 void
 ClientSourceParent::DetachHandle(ClientHandleParent* aClientHandle)
 {
   MOZ_DIAGNOSTIC_ASSERT(aClientHandle);
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
--- a/dom/clients/manager/ClientSourceParent.h
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -16,27 +16,34 @@ class ClientHandleParent;
 class ClientManagerService;
 
 class ClientSourceParent final : public PClientSourceParent
 {
   ClientInfo mClientInfo;
   RefPtr<ClientManagerService> mService;
   nsTArray<ClientHandleParent*> mHandleList;
   bool mExecutionReady;
+  bool mFrozen;
 
   void
   KillInvalidChild();
 
   // PClientSourceParent
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
   mozilla::ipc::IPCResult
   RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs) override;
 
+  mozilla::ipc::IPCResult
+  RecvFreeze() override;
+
+  mozilla::ipc::IPCResult
+  RecvThaw() override;
+
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
   PClientSourceOpParent*
   AllocPClientSourceOpParent(const ClientOpConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientSourceOpParent(PClientSourceOpParent* aActor) override;
@@ -46,16 +53,19 @@ public:
   ~ClientSourceParent();
 
   void
   Init();
 
   const ClientInfo&
   Info() const;
 
+  bool
+  IsFrozen() const;
+
   void
   AttachHandle(ClientHandleParent* aClientSource);
 
   void
   DetachHandle(ClientHandleParent* aClientSource);
 };
 
 } // namespace dom
diff --git a/dom/clients/manager/PClientSource.ipdl b/dom/clients/manager/PClientSource.ipdl
--- a/dom/clients/manager/PClientSource.ipdl
+++ b/dom/clients/manager/PClientSource.ipdl
@@ -17,16 +17,18 @@ sync protocol PClientSource
 {
   manager PClientManager;
 
   manages PClientSourceOp;
 
 parent:
   async Teardown();
   async ExecutionReady(ClientSourceExecutionReadyArgs aArgs);
+  async Freeze();
+  async Thaw();
 
 child:
   async PClientSourceOp(ClientOpConstructorArgs aArgs);
 
   async __delete__();
 };
 
 } // namespace dom
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -5318,16 +5318,19 @@ WorkerPrivate::EnsureClientSource()
       type = ClientType::Serviceworker;
       break;
     default:
       MOZ_CRASH("unknown worker type!");
   }
 
   mClientSource = ClientManager::CreateSource(type, mWorkerHybridEventTarget,
                                               GetPrincipalInfo());
+  if (mFrozen) {
+    mClientSource->Freeze();
+  }
 }
 
 const ClientInfo&
 WorkerPrivate::GetClientInfo() const
 {
   AssertIsOnWorkerThread();
   MOZ_DIAGNOSTIC_ASSERT(mClientSource);
   return mClientSource->Info();
@@ -5675,16 +5678,20 @@ WorkerPrivate::ClearDebuggerEventQueue()
 
 bool
 WorkerPrivate::FreezeInternal()
 {
   AssertIsOnWorkerThread();
 
   NS_ASSERTION(!mFrozen, "Already frozen!");
 
+  if (mClientSource) {
+    mClientSource->Freeze();
+  }
+
   mFrozen = true;
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Freeze(nullptr);
   }
 
   return true;
 }
@@ -5696,16 +5703,21 @@ WorkerPrivate::ThawInternal()
 
   NS_ASSERTION(mFrozen, "Not yet frozen!");
 
   for (uint32_t index = 0; index < mChildWorkers.Length(); index++) {
     mChildWorkers[index]->Thaw(nullptr);
   }
 
   mFrozen = false;
+
+  if (mClientSource) {
+    mClientSource->Thaw();
+  }
+
   return true;
 }
 
 void
 WorkerPrivate::TraverseTimeouts(nsCycleCollectionTraversalCallback& cb)
 {
   for (uint32_t i = 0; i < mTimeouts.Length(); ++i) {
     TimeoutInfo* tmp = mTimeouts[i];
