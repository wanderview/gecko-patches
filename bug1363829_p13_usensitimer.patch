# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4ac29020bf16c1a44afab5c046ed06821b14ae45
Bug 1363829 P13 Use the nsITimer::PreciseInitWithCallback() instead of rounding. r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
--- a/dom/base/TimeoutExecutor.cpp
+++ b/dom/base/TimeoutExecutor.cpp
@@ -56,28 +56,18 @@ TimeoutExecutor::ScheduleDelayed(const T
   // Always call Cancel() in case we are re-using a timer.  Otherwise
   // the subsequent SetTarget() may fail.
   rv = mTimer->Cancel();
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = mTimer->SetTarget(mOwner->EventTarget());
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Convert the precise delay to integral milliseconds for nsITimer.  We
-  // favor rounding down here.  If we fire early we will simply be rescheduled
-  // for an immediate runnable or a 0-ms timer.  This ends up giving us the
-  // most accurate firing time at the cost of a few more runnables.  This cost
-  // is only incurred when the browser is idle, though.  When the busy main
-  // thread is busy there will be a delay and we won't actually be early.
-  // TODO: In the future we could pass a precision argument in and round
-  //       up here for low-precision background timers.  We don't really care
-  //       if those timers fire late.
-  TimeDuration delay(aDeadline - aNow - TimeDuration::FromMilliseconds(0.1));
-  rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
-                                nsITimer::TYPE_ONE_SHOT);
+  rv = mTimer->PreciseInitWithCallback(this, aDeadline - aNow,
+                                       nsITimer::TYPE_ONE_SHOT);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mMode = Mode::Delayed;
   mDeadline = aDeadline;
 
   return NS_OK;
 }
 
