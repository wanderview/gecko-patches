# HG changeset patch
# User Yury Delendik <ydelendik@mozilla.com>
# Date 1452614964 21600
#      Tue Jan 12 10:09:24 2016 -0600
# Node ID 5322cc9bc7edab51d19d62bc6ccf2facfd4f58dd
# Parent  b7052405c63687ae58e4125c7af23759d32a660a
ReadableStream

diff --git a/js/src/builtin/ReadableStream.cpp b/js/src/builtin/ReadableStream.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.cpp
@@ -0,0 +1,285 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "builtin/ReadableStream.h"
+#include "builtin/SelfHostingDefines.h"
+#include "gc/Heap.h"
+#include "vm/NativeObject-inl.h"
+
+#include "jscntxt.h"
+#include "jsobjinlines.h"
+
+using namespace js;
+
+static const JSPropertySpec readablestream_properties[] = {
+    JS_SELF_HOSTED_GET("locked", "ReadableStream_locked", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestream_methods[] = {
+    JS_SELF_HOSTED_FN("cancel", "ReadableStream_cancel", 1, 0),
+    JS_SELF_HOSTED_FN("getReader", "ReadableStream_getReader", 0, 0),
+    JS_SELF_HOSTED_FN("pipeThrough", "ReadableStream_pipeThrough", 2, 0),
+    JS_SELF_HOSTED_FN("pipeTo", "ReadableStream_pipeTo", 2, 0),
+    JS_SELF_HOSTED_FN("tee", "ReadableStream_tee", 0, 0),
+    JS_FS_END
+};
+
+static const JSPropertySpec readablestreamcontroller_properties[] = {
+    JS_SELF_HOSTED_GET("desiredSize", "ReadableStreamController_desiredSize", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestreamcontroller_methods[] = {
+    JS_SELF_HOSTED_FN("close", "ReadableStreamController_close", 0, 0),
+    JS_SELF_HOSTED_FN("enqueue", "ReadableStreamController_enqueue", 1, 0),
+    JS_SELF_HOSTED_FN("error", "ReadableStreamController_error", 1, 0),
+    JS_FS_END
+};
+
+static const JSPropertySpec readablestreamreader_properties[] = {
+    JS_SELF_HOSTED_GET("closed", "ReadableStreamReader_closed", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestreamreader_methods[] = {
+    JS_SELF_HOSTED_FN("cancel", "ReadableStreamReader_cancel", 1, 0),
+    JS_SELF_HOSTED_FN("read", "ReadableStreamReader_read", 0, 0),
+    JS_SELF_HOSTED_FN("releaseLock", "ReadableStreamReader_releaseLock", 0, 0),
+    JS_FS_END
+};
+
+namespace js {
+
+// TODO remove. See also https://bugzil.la/1226261
+bool
+ReadableStreamConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    if (!ThrowIfNotConstructing(cx, args, "ReadableStream"))
+        return false;
+
+    Rooted<ReadableStream*> readableStream(cx, NewBuiltinClassInstance<ReadableStream>(cx));
+    if (!readableStream)
+        return false;
+
+    RootedValue ctorFun(cx);
+    if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStream,
+                                         &ctorFun))
+    {
+        return false;
+    }
+    MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+    InvokeArgs invokeArgs(cx);
+    if (!invokeArgs.init(args.length() >= 2 ? 2 : args.length()))
+        return false;
+    invokeArgs.setCallee(ctorFun);
+    invokeArgs.setThis(ObjectValue(*readableStream));
+    if (args.length() >= 1)
+      invokeArgs[0].set(args.get(0));
+    if (args.length() >= 2)
+      invokeArgs[1].set(args.get(1));
+
+    if (!Call(cx, ctorFun, readableStream, invokeArgs, args.rval()))
+        return false;
+
+    args.rval().setObject(*readableStream);
+    return true;
+}
+
+bool
+ReadableStreamControllerConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+  CallArgs args = CallArgsFromVp(argc, vp);
+
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamController"))
+      return false;
+
+  Rooted<ReadableStreamController*> readableStreamController(cx, NewBuiltinClassInstance<ReadableStreamController>(cx));
+  if (!readableStreamController)
+      return false;
+
+  RootedValue ctorFun(cx);
+  if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStreamController,
+                                       &ctorFun))
+  {
+      return false;
+  }
+  MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+  InvokeArgs invokeArgs(cx);
+  if (!invokeArgs.init(args.length() >= 1 ? 1: 0))
+      return false;
+  invokeArgs.setCallee(ctorFun);
+  invokeArgs.setThis(ObjectValue(*readableStreamController));
+  if (args.length() >= 1)
+    invokeArgs[0].set(args.get(0));
+
+  if (!Call(cx, ctorFun, readableStreamController, invokeArgs, args.rval()))
+      return false;
+
+  args.rval().setObject(*readableStreamController);
+  return true;
+}
+
+bool
+ReadableStreamReaderConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+  CallArgs args = CallArgsFromVp(argc, vp);
+
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamReader"))
+      return false;
+
+  Rooted<ReadableStreamReader*> readableStreamReader(cx, NewBuiltinClassInstance<ReadableStreamReader>(cx));
+  if (!readableStreamReader)
+      return false;
+
+  RootedValue ctorFun(cx);
+  if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStreamReader,
+                                       &ctorFun))
+  {
+      return false;
+  }
+  MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+  InvokeArgs invokeArgs(cx);
+  if (!invokeArgs.init(args.length() >= 1 ? 1 : 0))
+      return false;
+  invokeArgs.setCallee(ctorFun);
+  invokeArgs.setThis(ObjectValue(*readableStreamReader));
+  if (args.length() >= 1)
+    invokeArgs[0].set(args.get(0));
+
+  if (!Call(cx, ctorFun, readableStreamReader, invokeArgs, args.rval()))
+      return false;
+
+  args.rval().setObject(*readableStreamReader);
+  return true;
+}
+
+} // namespace js
+
+static JSObject*
+CreateReadableStreamPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStream::protoClass_);
+}
+
+static JSObject*
+CreateReadableStreamControllerPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStreamController::protoClass_);
+}
+
+static JSObject*
+CreateReadableStreamReaderPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStreamReader::protoClass_);
+}
+
+const ClassSpec ReadableStream::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamConstructor, 0, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamPrototype,
+    nullptr,
+    nullptr,
+    readablestream_methods,
+    readablestream_properties
+};
+
+const Class ReadableStream::class_ = {
+    "ReadableStream",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStream),
+    JS_NULL_CLASS_OPS,
+    &ReadableStream::classSpec_
+};
+
+const ClassSpec ReadableStream::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStream::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStream::protoClass_ = {
+    "ReadableStream",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStream),
+    JS_NULL_CLASS_OPS,
+    &ReadableStream::protoClassSpec_
+};
+
+const ClassSpec ReadableStreamController::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamControllerConstructor, 1, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamControllerPrototype,
+    nullptr,
+    nullptr,
+    readablestreamcontroller_methods,
+    readablestreamcontroller_properties
+};
+
+const Class ReadableStreamController::class_ = {
+    "ReadableStreamController",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamController),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamController::classSpec_
+};
+
+const ClassSpec ReadableStreamController::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStreamController::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStreamController::protoClass_ = {
+    "ReadableStreamController",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamController),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamController::protoClassSpec_
+};
+
+const ClassSpec ReadableStreamReader::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamReaderConstructor, 1, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamReaderPrototype,
+    nullptr,
+    nullptr,
+    readablestreamreader_methods,
+    readablestreamreader_properties
+};
+
+const Class ReadableStreamReader::class_ = {
+    "ReadableStreamReader",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamReader),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamReader::classSpec_
+};
+
+const ClassSpec ReadableStreamReader::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStreamReader::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStreamReader::protoClass_ = {
+    "ReadableStreamReader",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamReader),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamReader::protoClassSpec_
+};
diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef builtin_ReadableStream_h
+#define builtin_ReadableStream_h
+
+#include "vm/NativeObject.h"
+
+namespace js {
+
+class AutoSetNewObjectMetadata;
+
+class ReadableStream : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 13;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+class ReadableStreamController : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 1;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+class ReadableStreamReader : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 4;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+} // namespace js
+
+#endif /* builtin_ReadableStream_h */
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.js
@@ -0,0 +1,613 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Streams spec, 3.2.3.
+function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
+  }
+  if (underlyingSource === undefined) {
+    underlyingSource = {};
+  }
+  if (highWaterMark === undefined) {
+    highWaterMark = 1;
+  }
+
+  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
+  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
+  // Step 2. Set this@[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
+  // Step 3. Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
+  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
+  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
+  // Step 6. Set this@[[disturbed]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
+  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
+  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
+
+  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
+  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
+  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
+  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
+  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
+  // Step 11. ReturnIfAbrupt(startResult).
+  let startResult = InvokeOrNoop(underlyingSource, "start",
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
+  // Step 12. Resolve startResult as a promise:
+  Promise.resolve(startResult).then(() => {
+this._log += 'resolved ' + startResult;
+    // Set this@[[started]] to true.
+    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
+    // Perform RequestReadableStreamPull(this).
+    RequestReadableStreamPull(this);
+  }, (r) => {
+    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
+    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+      ErrorReadableStream(this, r);
+    }
+  });
+}
+
+// Streams spec, 3.2.4.1. get locked
+function ReadableStream_locked() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
+  }
+
+  return IsReadableStreamLocked(this);
+}
+
+// Streams spec, 3.2.4.2. cancel(reason)
+function ReadableStream_cancel(reason) {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+
+  if (IsReadableStreamLocked(this)) {
+    try {
+      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+
+  return CancelReadableStream(this, reason);
+}
+
+// Streams spec, 3.2.4.3. getReader()
+function ReadableStream_getReader() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
+  }
+
+  return AcquireReadableStreamReader(this);
+}
+
+// Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
+function ReadableStream_pipeThrough({ writable, readable }, options) {
+  ReadableStream_pipeTo.call(this, writable, options);
+  return readable;
+}
+
+// Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
+function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
+  return null;
+}
+
+// Streams spec, 3.2.4.6. tee()
+function ReadableStream_tee() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee", typeof this);
+  }
+
+  let branches = TeeReadableStream(this, false);
+  return branches;
+}
+
+
+// Streams spec, 3.3.1. Class Definition
+function ReadableStreamController(stream) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
+  }
+  if (UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT) !== undefined) {
+    ThrowSomething("TypeError", "stream@[[controller]] is not undefined");
+  }
+  UnsafeSetReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT, stream);
+}
+
+// Streams spec, 3.3.4.1. get desiredSize
+function ReadableStreamController_desiredSize() {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "desiredSize", typeof this);
+  }
+  return GetReadableStreamDesiredSize(UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT));
+}
+
+// Streams spec, 3.3.4.2. close()
+function ReadableStreamController_close() {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "close", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    ThrowSomething("TypeError", "stream@[[closeRequested]] is true");
+  }
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_ERRORED_STATE) {
+    ThrowSomething("TypeError", "stream@[[state]] is \"errored\"");
+  }
+  CloseReadableStream(stream);
+}
+
+// Streams spec, 3.3.4.3. enqueue(chunk)
+function ReadableStreamController_enqueue(chunk) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "enqueue", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_ERRORED_STATE) {
+    throw UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    ThrowSomething("TypeError", "stream@[[closeRequested]] is true");
+  }
+  return EnqueueInReadableStream(stream, chunk);
+}
+
+// Streams spec, 3.3.4.4. error(e)
+function ReadableStreamController_error(e) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "error", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_READABLE_STATE) {
+    ThrowSomething("TypeError", "this@[[controlledReadableStream]]@[[state]] is not readable");
+  }
+  return ErrorReadableStream(stream, e);
+}
+
+
+// Streams spec, 3.4.1. Class Definition
+function ReadableStreamReader(stream) {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "ctor", typeof this);
+  }
+  if (!IsObject(stream) || !IsReadableStream(stream)) {
+    ThrowSomething("TypeError", "!IsReadableStream(stream)");
+  }
+  if (IsReadableStreamLocked(stream)) {
+    ThrowSomething("TypeError", "IsReadableStreamLocked(stream)");
+  }
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, stream);
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, this);
+  let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  switch (streamState) {
+    case READABLESTREAM_READABLE_STATE:
+      let deferred = CreateDeferred();
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
+      break;
+    case READABLESTREAM_CLOSED_STATE:
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        Promise.resolve(undefined));
+      break;
+    case READABLESTREAM_ERRORED_STATE:
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        Promise.reject(UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
+      break;
+    default:
+      ThrowSomething("Error", "Unexpected stream state");
+      break;
+  }
+}
+
+// Streams spec, 3.4.4.1. get closed
+function ReadableStreamReader_closed() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "closed", typeof this);
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+  return UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.4.4.2. cancel(reason)
+function ReadableStreamReader_cancel(reason) {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "cancel", typeof this);
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+  return CancelReadableStream(ownerReadableStream, reason);
+}
+
+// Streams spec, 3.4.4.3. read()
+function ReadableStreamReader_read() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "read", typeof this);
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
+    } catch (e) {
+      return Promise.reject(e);
+    }
+  }
+  return ReadFromReadableStreamReader(this);
+}
+
+// Streams spec, 3.4.4.4. releaseLock()
+function ReadableStreamReader_releaseLock() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "releaseLock", typeof this);
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return;
+  }
+  let readRequests = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMREADER_READ_REQUESTS_SLOT)
+  if (readRequests.length !== 0) {
+    ThrowSomething("TypeError", "this@[[readRequests]] is not empty");
+  }
+  let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
+  let releaseLockException;
+  try {
+    ThrowSomething("TypeError", "ReadableStreamReader_releaseLock");
+  } catch (e) {
+    releaseLockException = e;
+  }
+  if (ownerReadableStreamState === READABLESTREAM_READABLE_STATE) {
+    let deferred = UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+    deferred.reject(releaseLockException);
+  } else {
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      Promise.reject(releaseLockException));
+  }
+  UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, undefined);
+}
+
+
+// Streams spec, 3.5.1. AcquireReadableStreamReader ( stream )
+function AcquireReadableStreamReader(stream) {
+  var ReadableStreamReaderCtor = GetReadableStreamReaderCtor();
+  return new ReadableStreamReaderCtor(stream);
+}
+
+// Streams spec, 3.5.2. CancelReadableStream ( stream, reason )
+function CancelReadableStream(stream, reason) {
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+  let streamState = UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (streamState === READABLESTREAM_CLOSED_STATE) {
+    return Promise.resolve(undefined);
+  }
+  if (streamState === READABLESTREAM_ERRORED_STATE) {
+    return Promise.reject(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
+  FinishClosingReadableStream(stream);
+  let sourceCancelPromise = PromiseInvokeOrNoop(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT), "cancel", reason);
+  return sourceCancelPromise.then(() => undefined);
+}
+
+// Streams spec, 3.5.3. CloseReadableStream ( stream )
+function CloseReadableStream(stream) {
+  assert(UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
+    return;
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT, true);
+  if (UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT).length === 0) {
+    FinishClosingReadableStream(stream);
+  }
+}
+
+// Streams spec, 3.5.4. EnqueueInReadableStream ( stream, chunk )
+function EnqueueInReadableStream(stream, chunk) {
+  assert(UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
+    return;
+  }
+  let readRequests;
+  if (IsReadableStreamLocked(stream) &&
+      (readRequests = UnsafeGetObjectFromReservedSlot(
+        UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT),
+          READABLESTREAMREADER_READ_REQUESTS_SLOT)).length !== 0) {
+    let readRequestDeferred = callFunction(std_Array_shift, readRequests);
+    readRequestDeferred.resolve(CreateIterResultObject(chunk, false));
+  } else {
+    let chunkSize = 1;
+    let strategySize = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_SIZE_SLOT);
+    if (strategySize !== undefined) {
+      try {
+        chunkSize = callContentFunction(strategySize, undefined, chunk);
+      } catch (e) {
+        if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+          ErrorReadableStream(stream, e);
+        }
+        throw e;
+      }
+    }
+    let queue = UnsafeGetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT);
+    try {
+      let enqueueResult = EnqueueValueWithSize(queue, chunk, chunkSize);
+    } catch (e) {
+      if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+        ErrorReadableStream(stream, e);
+      }
+      throw e;
+    }
+  }
+  RequestReadableStreamPull(stream);
+}
+
+// Streams spec, 3.5.5. ErrorReadableStream ( stream, e )
+function ErrorReadableStream(stream, e) {
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREM_READABLE_STATE, "stream@[[state]] is \"readable\"");
+  UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT, e);
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT, READABLESTREAM_ERRORED_STATE);
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  if (reader === undefined) {
+    return;
+  }
+  readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+  for (let i = 0; i < readRequests.length; i++) {
+    readRequestDeferred = readRequests[i];
+    readRequestDeferred.reject(e);
+  }
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  let deferred = UnsafeGetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  deferred.reject(e);
+}
+
+// Streams spec, 3.5.6. FinishClosingReadableStream ( stream )
+function FinishClosingReadableStream(stream) {
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREM_READABLE_STATE, "stream@[[state]] is \"readable\"");
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT, READABLESTREAM_CLOSED_STATE);
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  if (reader === undefined) {
+    return;
+  }
+  let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+  for (let i = 0; i < readRequests.length; i++) {
+    let readRequestDeferred = readRequests[i];
+    readRequestDeferred.resolve(CreateIterResultObject(undefined, true));
+  }
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  let deferred = UnsafeGetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  deferred.resolve(undefined);
+}
+
+// Streams spec, 3.5.7. GetReadableStreamDesiredSize ( stream )
+function GetReadableStreamDesiredSize(stream) {
+  let queueSize = GetTotalQueueSize(
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT));
+  let streamHWM = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_HWM_SLOT);
+  return streamHWM - queueSize;
+}
+
+// Streams spec, 3.5.11. IsReadableStreamLocked ( stream )
+function IsReadableStreamLocked(stream) {
+  assert(IsReadbleStream(stream), "IsReadbleStream(stream)");
+  return UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
+}
+
+// Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
+function ReadFromReadableStreamReader(reader) {
+  let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
+  UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
+  let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
+  if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
+    return Promise.resolve(CreateIterResultObject(undefined, true));
+  }
+  if (ownerReadableStreamState === READABLESTREAM_ERRORED_STATE) {
+    return Promise.reject(UnsafeGetReservedSlot(ownerReadableStream, READABLESTREAM_STORED_ERROR_SLOT));
+  }
+  assert(UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT) === READABLESTREM_READABLE_STATE, "reader@[[ownerReadableStream]]@[[state]] is \"readable\"");
+  let queue = UnsafeGetObjectFromReservedSlot(ownerReadableStream, READABLESTREAM_QUEUE_SLOT)
+  if (queue.length !== 0) {
+    let chunk = DequeueValue(queue);
+    if (UnsafeGetBooleanFromReservedSlot(ownerReadableStream, READABLESTREAM_CLOSE_REQUESTED_SLOT) &&
+        queue.length === 0) {
+      FinishClosingReadableStream(ownerReadableStream);
+    } else {
+      RequestReadableStreamPull(ownerReadableStream);
+    }
+    return Promise.resolve(CreateIterResultObject(chunk, false));
+  } else {
+    let readRequestDeferred = CreateDeferred();
+    let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+    callFunction(std_Array_push, readRequests, readRequestDeferred);
+    RequestReadableStreamPull(ownerReadableStream);
+    return readRequestDeferred.promise;
+  }
+}
+
+// Streams spec, 3.5.14. RequestReadableStreamPull ( stream )
+function RequestReadableStreamPull(stream) {
+  let shouldPull = ShouldReadableStreamPull(stream);
+  if (!shouldPull) {
+    return;
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_PULLING_SLOT)) {
+    UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, true);
+    return;
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, true);
+  let pullPromise = PromiseInvokeOrNoop(
+    UnsafeGetReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT),
+    "pull",
+    UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT));
+  pullPromise.then(() => {
+    UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, false);
+    if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT)) {
+      UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, false);
+      RequestReadableStreamPull(stream);
+    }
+  }, (e) => {
+    if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+      ErrorReadableStream(stream, e);
+    }
+  });
+}
+
+// Streams spec, 3.5.15. ShouldReadableStreamPull ( stream )
+function ShouldReadableStreamPull(stream) {
+  let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (streamState === READABLESTREAM_CLOSED_STATE ||
+      streamState === READABLESTREAM_ERRORED_STATE) {
+    return false;
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    return false;
+  }
+  if (!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STARTED_SLOT)) {
+    return false;
+  }
+  if (IsReadableStreamLocked(stream)) {
+    let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+    let readerReadRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+    if (readerReadRequests.length !== 0) {
+      return true;
+    }
+  }
+  let desiredSize = GetReadableStreamDesiredSize(stream);
+  return desiredSize > 0;
+}
+
+// Streams spec, 3.5.16. TeeReadableStream ( stream, shouldClone )
+function TeeReadableStream(stream, shouldClone) {
+  ThrowSomething("Error", "Not implemented TeeReadableStream");
+}
+
+// Streams spec, 6.3.1. DequeueValue ( queue )
+function DequeueValue(queue) {
+  var pair = callFunction(std_Array_shift, queue);
+  return pair.value;
+}
+
+// Streams spec, 6.3.2. EnqueueValueWithSize ( queue, value, size )
+function EnqueueValueWithSize(queue, value, size) {
+  size = ToNumber(size);
+  if (Number_isNaN(size) || !Number_isFinite(size) || size < 0) {
+    ThrowSomething("RangeError", "size NaN, Infinity or < 0");
+  }
+  callFunction(std_Array_push, queue, {value: value, size: size});
+}
+
+// Streams spec, 6.3.3. GetTotalQueueSize ( queue )
+function GetTotalQueueSize(queue) {
+  let totalSize = 0;
+  for (let i = 0; i < queue.length; i++) {
+    let pair = queue[i];
+    assert(Number_isFinite(pair.size) && !Number_isNaN(pair.size), "pair.[[size]] is a finite, non-NaN number");
+    totalSize += pair.size;
+  }
+  return totalSize;
+}
+
+// Streams spec, 6.4.4. InvokeOrNoop ( O, P, args )
+// FIXME per spec
+function InvokeOrNoop(obj, methodName, arg) {
+  var method = obj[methodName];
+  if (method === undefined) {
+    return undefined;
+  }
+  return callContentFunction(method, obj, arg);
+}
+
+// Streams spec, 6.4.6. PromiseInvokeOrNoop ( O, P, args )
+// FIXME per spec
+function PromiseInvokeOrNoop(obj, methodName, arg) {
+  try {
+    let result = InvokeOrNoop(obj, methodName, arg);
+    return Promise.resolve(result);
+  } catch (e) {
+    return Promise.reject(e);
+  }
+}
+
+// Streams spec, 6.4.7. ValidateAndNormalizeQueuingStrategy ( size, highWaterMark )
+function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
+  if (size !== undefined && !IsCallable(size)) {
+    ThrowTypeError(JSMSG_NOT_FUNCTION, DecompileArg(0, size));
+  }
+  highWaterMark = +highWaterMark;
+  if (Number_isNaN(highWaterMark)) {
+    ThrowTypeError(JSMSG_MISSING_FUN_ARG, 1, 'highWaterMark');
+  }
+  if (highWaterMark < 0) {
+    ThrowSomething("RangeError", "highWaterMark < 0");
+  }
+  return {size: size, highWaterMark: highWaterMark};
+}
+
+
+function ThrowSomething(name, msg) {
+  throw {name: name, msg: msg, toString() { return name; }}; 
+}
+
+function CreateIterResultObject(value, done) {
+  return {value: value, done: done};
+}
+
+// intrinsic wrappers
+function CreateDeferred() {
+  var obj = {};
+  obj.promise = new Promise(function (resolve, reject) {
+    obj.resolve = resolve;
+    obj.reject = reject;
+  });
+  return obj;
+}
+
+var _originalReadableStreamControllerCtorHolder = {__proto__: null};
+function GetReadableStreamControllerCtor() {
+    return _originalReadableStreamControllerCtorHolder.ctor ||
+           (_originalReadableStreamControllerCtorHolder.ctor = _GetOriginalReadableStreamControllerConstructor());
+}
+
+var _originalReadableStreamReaderCtorHolder = {__proto__: null};
+function GetReadableStreamReaderCtor() {
+    return _originalReadableStreamReaderCtorHolder.ctor ||
+           (_originalReadableStreamReaderCtorHolder.ctor = _GetOriginalReadableStreamReaderConstructor());
+}
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -71,16 +71,42 @@
 
 #define PROMISE_STATE_PENDING   0
 #define PROMISE_STATE_FULFILLED 1
 #define PROMISE_STATE_REJECTED  2
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
+// Used for ReadableStream.
+#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
+#define READABLESTREAM_CONTROLLER_SLOT 1
+#define READABLESTREAM_DISTURBED_SLOT 2
+#define READABLESTREAM_PULL_AGAIN_SLOT 3
+#define READABLESTREAM_PULLING_SLOT 4
+#define READABLESTREAM_QUEUE_SLOT 5
+#define READABLESTREAM_READER_SLOT 6
+#define READABLESTREAM_STARTED_SLOT 7
+#define READABLESTREAM_STATE_SLOT 8
+#define READABLESTREAM_STORED_ERROR_SLOT 9
+#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
+#define READABLESTREAM_STRATEGY_HWM_SLOT 11
+#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+
+#define READABLESTREAM_READABLE_STATE 0
+#define READABLESTREAM_CLOSED_STATE 1
+#define READABLESTREAM_ERRORED_STATE 2
+
+#define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
+
+#define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
+#define READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT 1
+#define READABLESTREAMREADER_READ_REQUESTS_SLOT 2
+#define READABLESTREAMREADER_CLOSED_DEFERRED_SLOT 3
+
 // NB: keep these in sync with the copy in jsfriendapi.h.
 #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
 #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
 #define JSITER_SYMBOLS    0x20  /* also include symbol property keys */
 #define JSITER_SYMBOLSONLY 0x40 /* exclude string property keys */
 
 #define TELEMETRY_DEFINE_GETTER_SETTER_THIS_NULL_UNDEFINED 25
 
diff --git a/js/src/jsprototypes.h b/js/src/jsprototypes.h
--- a/js/src/jsprototypes.h
+++ b/js/src/jsprototypes.h
@@ -112,12 +112,15 @@ IF_BDATA(real,imaginary)(TypedObject,   
     real(Reflect,               41,     InitReflect,            nullptr) \
 IF_SIMD(real,imaginary)(SIMD,                   42,     InitSimdClass, OCLASP(Simd)) \
     real(WeakSet,               43,     InitWeakSetClass,       OCLASP(WeakSet)) \
     real(TypedArray,            44,     InitViaClassSpec,       &js::TypedArrayObject::sharedTypedArrayPrototypeClass) \
 IF_SAB(real,imaginary)(Atomics, 45,     InitAtomicsClass, OCLASP(Atomics)) \
     real(SavedFrame,            46,     InitViaClassSpec,       &js::SavedFrame::class_) \
     real(Wasm,                  47,     InitWasmClass,          CLASP(Wasm)) \
 IF_PROMISE(real,imaginary)(Promise,             48,     InitViaClassSpec, OCLASP(Promise)) \
+    real(ReadableStream,        49,      InitViaClassSpec,      &js::ReadableStream::class_) \
+    real(ReadableStreamController,              50,     InitViaClassSpec, &js::ReadableStreamController::class_) \
+    real(ReadableStreamReader,  51,      InitViaClassSpec,      &js::ReadableStreamReader::class_) \
 
 #define JS_FOR_EACH_PROTOTYPE(macro) JS_FOR_PROTOTYPES(macro,macro)
 
 #endif /* jsprototypes_h */
diff --git a/js/src/moz.build b/js/src/moz.build
--- a/js/src/moz.build
+++ b/js/src/moz.build
@@ -169,16 +169,17 @@ UNIFIED_SOURCES += [
     'builtin/AtomicsObject.cpp',
     'builtin/Eval.cpp',
     'builtin/Intl.cpp',
     'builtin/MapObject.cpp',
     'builtin/ModuleObject.cpp',
     'builtin/Object.cpp',
     'builtin/Profilers.cpp',
     'builtin/Promise.cpp',
+    'builtin/ReadableStream.cpp',
     'builtin/Reflect.cpp',
     'builtin/ReflectParse.cpp',
     'builtin/SIMD.cpp',
     'builtin/SymbolObject.cpp',
     'builtin/TestingFunctions.cpp',
     'builtin/TypedObject.cpp',
     'builtin/WeakMapObject.cpp',
     'builtin/WeakSetObject.cpp',
@@ -742,16 +743,17 @@ selfhosted.inputs = [
     'builtin/Generator.js',
     'builtin/Intl.js',
     'builtin/IntlData.js',
     'builtin/Iterator.js',
     'builtin/Map.js',
     'builtin/Module.js',
     'builtin/Number.js',
     'builtin/Object.js',
+    'builtin/ReadableStream.js',
     'builtin/Reflect.js',
     'builtin/RegExp.js',
     'builtin/RegExpGlobalReplaceOpt.h.js',
     'builtin/RegExpLocalReplaceOpt.h.js',
     'builtin/String.js',
     'builtin/Set.js',
     'builtin/Sorting.js',
     'builtin/TypedArray.js',
diff --git a/js/src/vm/GlobalObject.cpp b/js/src/vm/GlobalObject.cpp
--- a/js/src/vm/GlobalObject.cpp
+++ b/js/src/vm/GlobalObject.cpp
@@ -19,16 +19,17 @@
 #include "builtin/AtomicsObject.h"
 #include "builtin/Eval.h"
 #if EXPOSE_INTL_API
 # include "builtin/Intl.h"
 #endif
 #include "builtin/MapObject.h"
 #include "builtin/ModuleObject.h"
 #include "builtin/Object.h"
+#include "builtin/ReadableStream.h"
 #include "builtin/RegExp.h"
 
 #ifdef NIGHTLY_BUILD
 #include "builtin/Promise.h"
 #endif
 
 #include "builtin/SelfHostingDefines.h"
 #include "builtin/SymbolObject.h"
diff --git a/js/src/vm/GlobalObject.h b/js/src/vm/GlobalObject.h
--- a/js/src/vm/GlobalObject.h
+++ b/js/src/vm/GlobalObject.h
@@ -603,16 +603,32 @@ class GlobalObject : public NativeObject
 
     static JSFunction*
     getOrCreatePromiseConstructor(JSContext* cx, Handle<GlobalObject*> global) {
         if (!ensureConstructor(cx, global, JSProto_Promise))
             return nullptr;
         return &global->getConstructor(JSProto_Promise).toObject().as<JSFunction>();
     }
 
+    static JSFunction*
+    getOrCreateReadableStreamReaderConstructor(JSContext* cx, Handle<GlobalObject*> global) {
+        if (!ensureConstructor(cx, global, JSProto_ReadableStreamReader))
+            return nullptr;
+
+        return &global->getConstructor(JSProto_ReadableStreamReader).toObject().as<JSFunction>();
+    }
+
+    static JSFunction*
+    getOrCreateReadableStreamControllerConstructor(JSContext* cx, Handle<GlobalObject*> global) {
+        if (!ensureConstructor(cx, global, JSProto_ReadableStreamController))
+            return nullptr;
+
+        return &global->getConstructor(JSProto_ReadableStreamController).toObject().as<JSFunction>();
+    }
+
     static NativeObject* getIntrinsicsHolder(JSContext* cx, Handle<GlobalObject*> global);
 
     bool maybeExistingIntrinsicValue(PropertyName* name, Value* vp) {
         Value slot = getReservedSlot(INTRINSICS);
         // If we're in the self-hosting compartment itself, the
         // intrinsics-holder isn't initialized at this point.
         if (slot.isUndefined()) {
             *vp = UndefinedValue();
diff --git a/testing/web-platform/meta/streams/readable-streams/general.https.html.ini b/testing/web-platform/meta/streams/readable-streams/general.https.html.ini
--- a/testing/web-platform/meta/streams/readable-streams/general.https.html.ini
+++ b/testing/web-platform/meta/streams/readable-streams/general.https.html.ini
@@ -1,11 +1,10 @@
 [general.https.html]
   type: testharness
-  disabled: @True
   [ReadableStream can be constructed with no errors]
     expected: FAIL
 
   [ReadableStream can't be constructed with garbage]
     expected: FAIL
 
   [ReadableStream instances should have the correct list of properties]
     expected: FAIL
diff --git a/testing/web-platform/tests/streams/readable-streams/general.https.html b/testing/web-platform/tests/streams/readable-streams/general.https.html
--- a/testing/web-platform/tests/streams/readable-streams/general.https.html
+++ b/testing/web-platform/tests/streams/readable-streams/general.https.html
@@ -1,13 +1,13 @@
 <!DOCTYPE html>
 <meta charset="utf-8">
 <script src="/resources/testharness.js"></script>
 <script src="/resources/testharnessreport.js"></script>
-<script src="/service-workers/service-workers/resources/test-helpers.js"></script>
+<script src="/service-workers/service-worker/resources/test-helpers.sub.js"></script>
 <script src="../resources/test-initializer.js"></script>
 
 <script src="../resources/test-utils.js"></script>
 <script src="../resources/rs-utils.js"></script>
 <script src="general.js"></script>
 <script>
 'use strict';
 worker_test('general.js');
