# HG changeset patch
# User Yury Delendik <ydelendik@mozilla.com>
# Date 1452614964 21600
#      Tue Jan 12 10:09:24 2016 -0600
# Node ID 5322cc9bc7edab51d19d62bc6ccf2facfd4f58dd
# Parent  9b5674f1bcecb6f3b003ecd8977be094afaafd47
ReadableStream

diff --git a/js/src/builtin/ReadableStream.cpp b/js/src/builtin/ReadableStream.cpp
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.cpp
@@ -0,0 +1,294 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "builtin/ReadableStream.h"
+#include "builtin/SelfHostingDefines.h"
+#include "gc/Heap.h"
+#include "vm/NativeObject-inl.h"
+
+#include "jscntxt.h"
+#include "jsobjinlines.h"
+
+using namespace js;
+
+static const JSPropertySpec readablestream_properties[] = {
+    JS_SELF_HOSTED_GET("locked", "ReadableStream_locked", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestream_methods[] = {
+    JS_SELF_HOSTED_FN("cancel", "ReadableStream_cancel", 1, 0),
+    JS_SELF_HOSTED_FN("getReader", "ReadableStream_getReader", 0, 0),
+    JS_SELF_HOSTED_FN("pipeThrough", "ReadableStream_pipeThrough", 2, 0),
+    JS_SELF_HOSTED_FN("pipeTo", "ReadableStream_pipeTo", 2, 0),
+    JS_SELF_HOSTED_FN("tee", "ReadableStream_tee", 0, 0),
+    JS_FS_END
+};
+
+static const JSPropertySpec readablestreamcontroller_properties[] = {
+    JS_SELF_HOSTED_GET("desiredSize", "ReadableStreamController_desiredSize", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestreamcontroller_methods[] = {
+    JS_SELF_HOSTED_FN("close", "ReadableStreamController_close", 0, 0),
+    JS_SELF_HOSTED_FN("enqueue", "ReadableStreamController_enqueue", 1, 0),
+    JS_SELF_HOSTED_FN("error", "ReadableStreamController_error", 1, 0),
+    JS_FS_END
+};
+
+static const JSPropertySpec readablestreamreader_properties[] = {
+    JS_SELF_HOSTED_GET("closed", "ReadableStreamReader_closed", 0),
+    JS_PS_END
+};
+
+static const JSFunctionSpec readablestreamreader_methods[] = {
+    JS_SELF_HOSTED_FN("cancel", "ReadableStreamReader_cancel", 1, 0),
+    JS_SELF_HOSTED_FN("read", "ReadableStreamReader_read", 0, 0),
+    JS_SELF_HOSTED_FN("releaseLock", "ReadableStreamReader_releaseLock", 0, 0),
+    JS_FS_END
+};
+
+namespace js {
+
+// TODO remove. See also https://bugzil.la/1226261
+bool
+ReadableStreamConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    if (!ThrowIfNotConstructing(cx, args, "ReadableStream"))
+        return false;
+
+    Rooted<ReadableStream*> readableStream(cx, NewBuiltinClassInstance<ReadableStream>(cx));
+    if (!readableStream)
+        return false;
+
+    RootedValue ctorFun(cx);
+    if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStream,
+                                         &ctorFun))
+    {
+        return false;
+    }
+    MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+    if (!ctorFun.toObject().as<JSFunction>().isSelfHostedBuiltin())
+      ctorFun.toObject().as<JSFunction>().setIsSelfHostedBuiltin();
+
+    InvokeArgs invokeArgs(cx);
+    if (!invokeArgs.init(args.length() > 2 ? 2: args.length()))
+      return false;
+
+    if (args.length() >= 1)
+      invokeArgs[0].set(args.get(0));
+    if (args.length() >= 2)
+      invokeArgs[1].set(args.get(1));
+
+    RootedValue newTarget(cx, ObjectValue(*readableStream));
+
+    if (!Call(cx, ctorFun, newTarget, invokeArgs, args.rval()))
+        return false;
+
+    args.rval().setObject(*readableStream);
+    return true;
+}
+
+bool
+ReadableStreamControllerConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+  CallArgs args = CallArgsFromVp(argc, vp);
+
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamController"))
+      return false;
+
+  Rooted<ReadableStreamController*> readableStreamController(cx, NewBuiltinClassInstance<ReadableStreamController>(cx));
+  if (!readableStreamController)
+      return false;
+
+  RootedValue ctorFun(cx);
+  if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStreamController,
+                                       &ctorFun))
+  {
+      return false;
+  }
+  MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+  if (!ctorFun.toObject().as<JSFunction>().isSelfHostedBuiltin())
+    ctorFun.toObject().as<JSFunction>().setIsSelfHostedBuiltin();
+
+  InvokeArgs invokeArgs(cx);
+  if (!invokeArgs.init(args.length() >= 1 ? 1: 0))
+      return false;
+  if (args.length() >= 1)
+    invokeArgs[0].set(args.get(0));
+
+  RootedValue newTarget(cx, ObjectValue(*readableStreamController));
+
+  if (!Call(cx, ctorFun, newTarget, invokeArgs, args.rval()))
+      return false;
+
+  args.rval().setObject(*readableStreamController);
+  return true;
+}
+
+bool
+ReadableStreamReaderConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+  CallArgs args = CallArgsFromVp(argc, vp);
+
+  if (!ThrowIfNotConstructing(cx, args, "ReadableStreamReader"))
+      return false;
+
+  Rooted<ReadableStreamReader*> readableStreamReader(cx, NewBuiltinClassInstance<ReadableStreamReader>(cx));
+  if (!readableStreamReader)
+      return false;
+
+  RootedValue ctorFun(cx);
+  if (!GlobalObject::getIntrinsicValue(cx, cx->global(), cx->runtime()->commonNames->ReadableStreamReader,
+                                       &ctorFun))
+  {
+      return false;
+  }
+  MOZ_ASSERT(ctorFun.toObject().is<JSFunction>());
+
+  if (!ctorFun.toObject().as<JSFunction>().isSelfHostedBuiltin())
+    ctorFun.toObject().as<JSFunction>().setIsSelfHostedBuiltin();
+
+  InvokeArgs invokeArgs(cx);
+  if (!invokeArgs.init(args.length() >= 1 ? 1 : 0))
+      return false;
+  if (args.length() >= 1)
+    invokeArgs[0].set(args.get(0));
+
+  RootedValue newTarget(cx, ObjectValue(*readableStreamReader));
+  if (!Call(cx, ctorFun, newTarget, invokeArgs, args.rval()))
+      return false;
+
+  args.rval().setObject(*readableStreamReader);
+  return true;
+}
+
+} // namespace js
+
+static JSObject*
+CreateReadableStreamPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStream::protoClass_);
+}
+
+static JSObject*
+CreateReadableStreamControllerPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStreamController::protoClass_);
+}
+
+static JSObject*
+CreateReadableStreamReaderPrototype(JSContext* cx, JSProtoKey key)
+{
+    return cx->global()->createBlankPrototype(cx, &ReadableStreamReader::protoClass_);
+}
+
+const ClassSpec ReadableStream::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamConstructor, 0, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamPrototype,
+    nullptr,
+    nullptr,
+    readablestream_methods,
+    readablestream_properties
+};
+
+const Class ReadableStream::class_ = {
+    "ReadableStream",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStream),
+    JS_NULL_CLASS_OPS,
+    &ReadableStream::classSpec_
+};
+
+const ClassSpec ReadableStream::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStream::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStream::protoClass_ = {
+    "ReadableStream",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStream),
+    JS_NULL_CLASS_OPS,
+    &ReadableStream::protoClassSpec_
+};
+
+const ClassSpec ReadableStreamController::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamControllerConstructor, 1, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamControllerPrototype,
+    nullptr,
+    nullptr,
+    readablestreamcontroller_methods,
+    readablestreamcontroller_properties
+};
+
+const Class ReadableStreamController::class_ = {
+    "ReadableStreamController",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamController),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamController::classSpec_
+};
+
+const ClassSpec ReadableStreamController::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStreamController::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStreamController::protoClass_ = {
+    "ReadableStreamController",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamController),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamController::protoClassSpec_
+};
+
+const ClassSpec ReadableStreamReader::classSpec_ = {
+    GenericCreateConstructor<ReadableStreamReaderConstructor, 1, gc::AllocKind::FUNCTION>,
+    CreateReadableStreamReaderPrototype,
+    nullptr,
+    nullptr,
+    readablestreamreader_methods,
+    readablestreamreader_properties
+};
+
+const Class ReadableStreamReader::class_ = {
+    "ReadableStreamReader",
+    JSCLASS_HAS_RESERVED_SLOTS(RESERVED_SLOTS) | JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamReader),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamReader::classSpec_
+};
+
+const ClassSpec ReadableStreamReader::protoClassSpec_ = {
+    DELEGATED_CLASSSPEC(&ReadableStreamReader::classSpec_),
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    ClassSpec::IsDelegated
+};
+
+const Class ReadableStreamReader::protoClass_ = {
+    "ReadableStreamReader",
+    JSCLASS_HAS_CACHED_PROTO(JSProto_ReadableStreamReader),
+    JS_NULL_CLASS_OPS,
+    &ReadableStreamReader::protoClassSpec_
+};
diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: set ts=8 sts=4 et sw=4 tw=99:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef builtin_ReadableStream_h
+#define builtin_ReadableStream_h
+
+#include "vm/NativeObject.h"
+
+namespace js {
+
+class AutoSetNewObjectMetadata;
+
+class ReadableStream : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 13;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+class ReadableStreamController : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 1;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+class ReadableStreamReader : public NativeObject
+{
+  public:
+    static const unsigned RESERVED_SLOTS = 4;
+    static const ClassSpec classSpec_;
+    static const Class class_;
+    static const ClassSpec protoClassSpec_;
+    static const Class protoClass_;
+};
+
+} // namespace js
+
+#endif /* builtin_ReadableStream_h */
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
new file mode 100644
--- /dev/null
+++ b/js/src/builtin/ReadableStream.js
@@ -0,0 +1,620 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Streams spec, 3.2.3.
+function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
+  }
+  if (underlyingSource === undefined) {
+    underlyingSource = {};
+  }
+  if (highWaterMark === undefined) {
+    highWaterMark = 1;
+  }
+
+  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
+  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
+  // Step 2. Set this@[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
+  // Step 3. Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
+  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
+  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
+  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
+  // Step 6. Set this@[[disturbed]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
+  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
+  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
+
+  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
+  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
+  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
+  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
+  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
+  // Step 11. ReturnIfAbrupt(startResult).
+  let startResult = InvokeOrNoop(underlyingSource, "start",
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
+  // Step 12. Resolve startResult as a promise:
+  GetPromiseCtor().resolve(startResult).then(() => {
+this._log += 'resolved ' + startResult;
+    // Set this@[[started]] to true.
+    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
+    // Perform RequestReadableStreamPull(this).
+    RequestReadableStreamPull(this);
+  }, (r) => {
+    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
+    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+      ErrorReadableStream(this, r);
+    }
+  });
+}
+
+// Streams spec, 3.2.4.1. get locked
+function ReadableStream_locked() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
+  }
+
+  return IsReadableStreamLocked(this);
+}
+
+// Streams spec, 3.2.4.2. cancel(reason)
+function ReadableStream_cancel(reason) {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+
+  if (IsReadableStreamLocked(this)) {
+    try {
+      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+
+  return CancelReadableStream(this, reason);
+}
+
+// Streams spec, 3.2.4.3. getReader()
+function ReadableStream_getReader() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
+  }
+
+  return AcquireReadableStreamReader(this);
+}
+
+// Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
+function ReadableStream_pipeThrough({ writable, readable }, options) {
+  ReadableStream_pipeTo.call(this, writable, options);
+  return readable;
+}
+
+// Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
+function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
+  return null;
+}
+
+// Streams spec, 3.2.4.6. tee()
+function ReadableStream_tee() {
+  if (!IsObject(this) || !IsReadableStream(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee", typeof this);
+  }
+
+  let branches = TeeReadableStream(this, false);
+  return branches;
+}
+
+
+// Streams spec, 3.3.1. Class Definition
+function ReadableStreamController(stream) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
+  }
+  if (UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT) !== undefined) {
+    ThrowSomething("TypeError", "stream@[[controller]] is not undefined");
+  }
+  UnsafeSetReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT, stream);
+}
+
+// Streams spec, 3.3.4.1. get desiredSize
+function ReadableStreamController_desiredSize() {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "desiredSize", typeof this);
+  }
+  return GetReadableStreamDesiredSize(UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT));
+}
+
+// Streams spec, 3.3.4.2. close()
+function ReadableStreamController_close() {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "close", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    ThrowSomething("TypeError", "stream@[[closeRequested]] is true");
+  }
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_ERRORED_STATE) {
+    ThrowSomething("TypeError", "stream@[[state]] is \"errored\"");
+  }
+  CloseReadableStream(stream);
+}
+
+// Streams spec, 3.3.4.3. enqueue(chunk)
+function ReadableStreamController_enqueue(chunk) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "enqueue", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_ERRORED_STATE) {
+    throw UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    ThrowSomething("TypeError", "stream@[[closeRequested]] is true");
+  }
+  return EnqueueInReadableStream(stream, chunk);
+}
+
+// Streams spec, 3.3.4.4. error(e)
+function ReadableStreamController_error(e) {
+  if (!IsObject(this) || !IsReadableStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "error", typeof this);
+  }
+  let stream = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_READABLE_STATE) {
+    ThrowSomething("TypeError", "this@[[controlledReadableStream]]@[[state]] is not readable");
+  }
+  return ErrorReadableStream(stream, e);
+}
+
+
+// Streams spec, 3.4.1. Class Definition
+function ReadableStreamReader(stream) {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "ctor", typeof this);
+  }
+  if (!IsObject(stream) || !IsReadableStream(stream)) {
+    ThrowSomething("TypeError", "!IsReadableStream(stream)");
+  }
+  if (IsReadableStreamLocked(stream)) {
+    ThrowSomething("TypeError", "IsReadableStreamLocked(stream)");
+  }
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, stream);
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, this);
+  let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  switch (streamState) {
+    case READABLESTREAM_READABLE_STATE:
+      let deferred = CreateDeferred();
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
+      break;
+    case READABLESTREAM_CLOSED_STATE:
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        GetPromiseCtor().resolve(undefined));
+      break;
+    case READABLESTREAM_ERRORED_STATE:
+      UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        GetPromiseCtor().reject(UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT)));
+      break;
+    default:
+      ThrowSomething("Error", "Unexpected stream state");
+      break;
+  }
+}
+
+// Streams spec, 3.4.4.1. get closed
+function ReadableStreamReader_closed() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "closed", typeof this);
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+  return UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.4.4.2. cancel(reason)
+function ReadableStreamReader_cancel(reason) {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "cancel", typeof this);
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+  return CancelReadableStream(ownerReadableStream, reason);
+}
+
+// Streams spec, 3.4.4.3. read()
+function ReadableStreamReader_read() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "read", typeof this);
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowSomething("TypeError", "this@[[ownerReadableStream]] is undefined");
+    } catch (e) {
+      return GetPromiseCtor().reject(e);
+    }
+  }
+  return ReadFromReadableStreamReader(this);
+}
+
+// Streams spec, 3.4.4.4. releaseLock()
+function ReadableStreamReader_releaseLock() {
+  if (!IsObject(this) || !IsReadableStreamReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamReader", "releaseLock", typeof this);
+  }
+  let ownerReadableStream = UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return;
+  }
+  let readRequests = UnsafeGetObjectFromReservedSlot(this, READABLESTREAMREADER_READ_REQUESTS_SLOT)
+  if (readRequests.length !== 0) {
+    ThrowSomething("TypeError", "this@[[readRequests]] is not empty");
+  }
+  let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
+  let releaseLockException;
+  try {
+    ThrowSomething("TypeError", "ReadableStreamReader_releaseLock");
+  } catch (e) {
+    releaseLockException = e;
+  }
+  if (ownerReadableStreamState === READABLESTREAM_READABLE_STATE) {
+    let deferred = UnsafeGetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+    deferred.reject(releaseLockException);
+  } else {
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      GetPromiseCtor().reject(releaseLockException));
+  }
+  UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT, undefined);
+}
+
+
+// Streams spec, 3.5.1. AcquireReadableStreamReader ( stream )
+function AcquireReadableStreamReader(stream) {
+  var ReadableStreamReaderCtor = GetReadableStreamReaderCtor();
+  return new ReadableStreamReaderCtor(stream);
+}
+
+// Streams spec, 3.5.2. CancelReadableStream ( stream, reason )
+function CancelReadableStream(stream, reason) {
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+  let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (streamState === READABLESTREAM_CLOSED_STATE) {
+    return GetPromiseCtor().resolve(undefined);
+  }
+  if (streamState === READABLESTREAM_ERRORED_STATE) {
+    return GetPromiseCtor().reject(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT));
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
+  FinishClosingReadableStream(stream);
+  let sourceCancelPromise = PromiseInvokeOrNoop(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT), "cancel", reason);
+  return sourceCancelPromise.then(() => undefined);
+}
+
+// Streams spec, 3.5.3. CloseReadableStream ( stream )
+function CloseReadableStream(stream) {
+  assert(!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
+    return;
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT, true);
+  if (UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT).length === 0) {
+    FinishClosingReadableStream(stream);
+  }
+}
+
+// Streams spec, 3.5.4. EnqueueInReadableStream ( stream, chunk )
+function EnqueueInReadableStream(stream, chunk) {
+  assert(!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT), "stream@[[closeRequested]] is false");
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) !== READABLESTREAM_ERRORED_STATE, "stream@[[state]] is not \"errored\"");
+  if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_CLOSED_STATE) {
+    return;
+  }
+  let readRequests;
+  if (IsReadableStreamLocked(stream) &&
+      (readRequests = UnsafeGetObjectFromReservedSlot(
+        UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT),
+          READABLESTREAMREADER_READ_REQUESTS_SLOT)).length !== 0) {
+    let readRequestDeferred = callFunction(std_Array_shift, readRequests);
+    readRequestDeferred.resolve(CreateIterResultObject(chunk, false));
+  } else {
+    let chunkSize = 1;
+    let strategySize = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_SIZE_SLOT);
+    if (strategySize !== undefined) {
+      try {
+        chunkSize = callContentFunction(strategySize, undefined, chunk);
+      } catch (e) {
+        if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+          ErrorReadableStream(stream, e);
+        }
+        throw e;
+      }
+    }
+    let queue = UnsafeGetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT);
+    try {
+      let enqueueResult = EnqueueValueWithSize(queue, chunk, chunkSize);
+    } catch (e) {
+      if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+        ErrorReadableStream(stream, e);
+      }
+      throw e;
+    }
+  }
+  RequestReadableStreamPull(stream);
+}
+
+// Streams spec, 3.5.5. ErrorReadableStream ( stream, e )
+function ErrorReadableStream(stream, e) {
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE, "stream@[[state]] is \"readable\"");
+  UnsafeSetReservedSlot(stream, READABLESTREAM_QUEUE_SLOT, new List());
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT, e);
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT, READABLESTREAM_ERRORED_STATE);
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  if (reader === undefined) {
+    return;
+  }
+  readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+  for (let i = 0; i < readRequests.length; i++) {
+    readRequestDeferred = readRequests[i];
+    readRequestDeferred.reject(e);
+  }
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  let deferred = UnsafeGetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  deferred.reject(e);
+}
+
+// Streams spec, 3.5.6. FinishClosingReadableStream ( stream )
+function FinishClosingReadableStream(stream) {
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE, "stream@[[state]] is \"readable\"");
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT, READABLESTREAM_CLOSED_STATE);
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  if (reader === undefined) {
+    return;
+  }
+  let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+  for (let i = 0; i < readRequests.length; i++) {
+    let readRequestDeferred = readRequests[i];
+    readRequestDeferred.resolve(CreateIterResultObject(undefined, true));
+  }
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT, new List());
+  let deferred = UnsafeGetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  deferred.resolve(undefined);
+}
+
+// Streams spec, 3.5.7. GetReadableStreamDesiredSize ( stream )
+function GetReadableStreamDesiredSize(stream) {
+  let queueSize = GetTotalQueueSize(
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT));
+  let streamHWM = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_HWM_SLOT);
+  return streamHWM - queueSize;
+}
+
+// Streams spec, 3.5.11. IsReadableStreamLocked ( stream )
+function IsReadableStreamLocked(stream) {
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
+}
+
+// Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
+function ReadFromReadableStreamReader(reader) {
+  let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
+  UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
+  let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
+  if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
+    return GetPromiseCtor().resolve(CreateIterResultObject(undefined, true));
+  }
+  if (ownerReadableStreamState === READABLESTREAM_ERRORED_STATE) {
+    return GetPromiseCtor().reject(UnsafeGetReservedSlot(ownerReadableStream, READABLESTREAM_STORED_ERROR_SLOT));
+  }
+  assert(UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE, "reader@[[ownerReadableStream]]@[[state]] is \"readable\"");
+  let queue = UnsafeGetObjectFromReservedSlot(ownerReadableStream, READABLESTREAM_QUEUE_SLOT)
+  if (queue.length !== 0) {
+    let chunk = DequeueValue(queue);
+    if (UnsafeGetBooleanFromReservedSlot(ownerReadableStream, READABLESTREAM_CLOSE_REQUESTED_SLOT) &&
+        queue.length === 0) {
+      FinishClosingReadableStream(ownerReadableStream);
+    } else {
+      RequestReadableStreamPull(ownerReadableStream);
+    }
+    return GetPromiseCtor().resolve(CreateIterResultObject(chunk, false));
+  } else {
+    let readRequestDeferred = CreateDeferred();
+    let readRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+    callFunction(std_Array_push, readRequests, readRequestDeferred);
+    RequestReadableStreamPull(ownerReadableStream);
+    return readRequestDeferred.promise;
+  }
+}
+
+// Streams spec, 3.5.14. RequestReadableStreamPull ( stream )
+function RequestReadableStreamPull(stream) {
+  let shouldPull = ShouldReadableStreamPull(stream);
+  if (!shouldPull) {
+    return;
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_PULLING_SLOT)) {
+    UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, true);
+    return;
+  }
+  UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, true);
+  let pullPromise = PromiseInvokeOrNoop(
+    UnsafeGetReservedSlot(stream, READABLESTREAM_UNDERLYING_SOURCE_SLOT),
+    "pull",
+    UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT));
+  pullPromise.then(() => {
+    UnsafeSetReservedSlot(stream, READABLESTREAM_PULLING_SLOT, false);
+    if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT)) {
+      UnsafeSetReservedSlot(stream, READABLESTREAM_PULL_AGAIN_SLOT, false);
+      RequestReadableStreamPull(stream);
+    }
+  }, (e) => {
+    if (UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
+      ErrorReadableStream(stream, e);
+    }
+  });
+}
+
+// Streams spec, 3.5.15. ShouldReadableStreamPull ( stream )
+function ShouldReadableStreamPull(stream) {
+  let streamState = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (streamState === READABLESTREAM_CLOSED_STATE ||
+      streamState === READABLESTREAM_ERRORED_STATE) {
+    return false;
+  }
+  if (UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_CLOSE_REQUESTED_SLOT)) {
+    return false;
+  }
+  if (!UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STARTED_SLOT)) {
+    return false;
+  }
+  if (IsReadableStreamLocked(stream)) {
+    let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+    let readerReadRequests = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_READ_REQUESTS_SLOT);
+    if (readerReadRequests.length !== 0) {
+      return true;
+    }
+  }
+  let desiredSize = GetReadableStreamDesiredSize(stream);
+  return desiredSize > 0;
+}
+
+// Streams spec, 3.5.16. TeeReadableStream ( stream, shouldClone )
+function TeeReadableStream(stream, shouldClone) {
+  ThrowSomething("Error", "Not implemented TeeReadableStream");
+}
+
+// Streams spec, 6.3.1. DequeueValue ( queue )
+function DequeueValue(queue) {
+  var pair = callFunction(std_Array_shift, queue);
+  return pair.value;
+}
+
+// Streams spec, 6.3.2. EnqueueValueWithSize ( queue, value, size )
+function EnqueueValueWithSize(queue, value, size) {
+  size = ToNumber(size);
+  if (Number_isNaN(size) || !Number_isFinite(size) || size < 0) {
+    ThrowSomething("RangeError", "size NaN, Infinity or < 0");
+  }
+  callFunction(std_Array_push, queue, {value: value, size: size});
+}
+
+// Streams spec, 6.3.3. GetTotalQueueSize ( queue )
+function GetTotalQueueSize(queue) {
+  let totalSize = 0;
+  for (let i = 0; i < queue.length; i++) {
+    let pair = queue[i];
+    assert(Number_isFinite(pair.size) && !Number_isNaN(pair.size), "pair.[[size]] is a finite, non-NaN number");
+    totalSize += pair.size;
+  }
+  return totalSize;
+}
+
+// Streams spec, 6.4.4. InvokeOrNoop ( O, P, args )
+// FIXME per spec
+function InvokeOrNoop(obj, methodName, arg) {
+  var method = obj[methodName];
+  if (method === undefined) {
+    return undefined;
+  }
+  return callContentFunction(method, obj, arg);
+}
+
+// Streams spec, 6.4.6. PromiseInvokeOrNoop ( O, P, args )
+// FIXME per spec
+function PromiseInvokeOrNoop(obj, methodName, arg) {
+  try {
+    let result = InvokeOrNoop(obj, methodName, arg);
+    return GetPromiseCtor().resolve(result);
+  } catch (e) {
+    return GetPromiseCtor().reject(e);
+  }
+}
+
+// Streams spec, 6.4.7. ValidateAndNormalizeQueuingStrategy ( size, highWaterMark )
+function ValidateAndNormalizeQueuingStrategy(size, highWaterMark) {
+  if (size !== undefined && !IsCallable(size)) {
+    ThrowTypeError(JSMSG_NOT_FUNCTION, DecompileArg(0, size));
+  }
+  highWaterMark = +highWaterMark;
+  if (Number_isNaN(highWaterMark)) {
+    ThrowTypeError(JSMSG_MISSING_FUN_ARG, 1, 'highWaterMark');
+  }
+  if (highWaterMark < 0) {
+    ThrowSomething("RangeError", "highWaterMark < 0");
+  }
+  return {size: size, highWaterMark: highWaterMark};
+}
+
+
+function ThrowSomething(name, msg) {
+  throw {name: name, msg: msg, toString() { return name; }}; 
+}
+
+function CreateIterResultObject(value, done) {
+  return {value: value, done: done};
+}
+
+// intrinsic wrappers
+function CreateDeferred() {
+  var Promise = GetPromiseCtor();
+  var obj = {};
+  obj.promise = new Promise(function (resolve, reject) {
+    obj.resolve = resolve;
+    obj.reject = reject;
+  });
+  return obj;
+}
+
+var _promiseCtorHolder  = {__proto__: null};
+function GetPromiseCtor() {
+    return _promiseCtorHolder.ctor ||
+           (_promiseCtorHolder.ctor = _GetOriginalPromiseConstructor());
+}
+
+var _originalReadableStreamControllerCtorHolder = {__proto__: null};
+function GetReadableStreamControllerCtor() {
+    return _originalReadableStreamControllerCtorHolder.ctor ||
+           (_originalReadableStreamControllerCtorHolder.ctor = _GetOriginalReadableStreamControllerConstructor());
+}
+
+var _originalReadableStreamReaderCtorHolder = {__proto__: null};
+function GetReadableStreamReaderCtor() {
+    return _originalReadableStreamReaderCtorHolder.ctor ||
+           (_originalReadableStreamReaderCtorHolder.ctor = _GetOriginalReadableStreamReaderConstructor());
+}
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -71,16 +71,42 @@
 
 #define PROMISE_STATE_PENDING   0
 #define PROMISE_STATE_FULFILLED 1
 #define PROMISE_STATE_REJECTED  2
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
+// Used for ReadableStream.
+#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
+#define READABLESTREAM_CONTROLLER_SLOT 1
+#define READABLESTREAM_DISTURBED_SLOT 2
+#define READABLESTREAM_PULL_AGAIN_SLOT 3
+#define READABLESTREAM_PULLING_SLOT 4
+#define READABLESTREAM_QUEUE_SLOT 5
+#define READABLESTREAM_READER_SLOT 6
+#define READABLESTREAM_STARTED_SLOT 7
+#define READABLESTREAM_STATE_SLOT 8
+#define READABLESTREAM_STORED_ERROR_SLOT 9
+#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
+#define READABLESTREAM_STRATEGY_HWM_SLOT 11
+#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+
+#define READABLESTREAM_READABLE_STATE 0
+#define READABLESTREAM_CLOSED_STATE 1
+#define READABLESTREAM_ERRORED_STATE 2
+
+#define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
+
+#define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
+#define READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT 1
+#define READABLESTREAMREADER_READ_REQUESTS_SLOT 2
+#define READABLESTREAMREADER_CLOSED_DEFERRED_SLOT 3
+
 // NB: keep these in sync with the copy in jsfriendapi.h.
 #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
 #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
 #define JSITER_SYMBOLS    0x20  /* also include symbol property keys */
 #define JSITER_SYMBOLSONLY 0x40 /* exclude string property keys */
 
 #define TELEMETRY_DEFINE_GETTER_SETTER_THIS_NULL_UNDEFINED 25
 
diff --git a/js/src/jsprototypes.h b/js/src/jsprototypes.h
--- a/js/src/jsprototypes.h
+++ b/js/src/jsprototypes.h
@@ -112,12 +112,15 @@ IF_BDATA(real,imaginary)(TypedObject,   
     real(Reflect,               41,     InitReflect,            nullptr) \
 IF_SIMD(real,imaginary)(SIMD,                   42,     InitSimdClass, OCLASP(Simd)) \
     real(WeakSet,               43,     InitWeakSetClass,       OCLASP(WeakSet)) \
     real(TypedArray,            44,     InitViaClassSpec,       &js::TypedArrayObject::sharedTypedArrayPrototypeClass) \
 IF_SAB(real,imaginary)(Atomics, 45,     InitAtomicsClass, OCLASP(Atomics)) \
     real(SavedFrame,            46,     InitViaClassSpec,       &js::SavedFrame::class_) \
     real(Wasm,                  47,     InitWasmClass,          CLASP(Wasm)) \
 IF_PROMISE(real,imaginary)(Promise,             48,     InitViaClassSpec, OCLASP(Promise)) \
+    real(ReadableStream,        49,      InitViaClassSpec,      &js::ReadableStream::class_) \
+    real(ReadableStreamController,              50,     InitViaClassSpec, &js::ReadableStreamController::class_) \
+    real(ReadableStreamReader,  51,      InitViaClassSpec,      &js::ReadableStreamReader::class_) \
 
 #define JS_FOR_EACH_PROTOTYPE(macro) JS_FOR_PROTOTYPES(macro,macro)
 
 #endif /* jsprototypes_h */
diff --git a/js/src/moz.build b/js/src/moz.build
--- a/js/src/moz.build
+++ b/js/src/moz.build
@@ -169,16 +169,17 @@ UNIFIED_SOURCES += [
     'builtin/AtomicsObject.cpp',
     'builtin/Eval.cpp',
     'builtin/Intl.cpp',
     'builtin/MapObject.cpp',
     'builtin/ModuleObject.cpp',
     'builtin/Object.cpp',
     'builtin/Profilers.cpp',
     'builtin/Promise.cpp',
+    'builtin/ReadableStream.cpp',
     'builtin/Reflect.cpp',
     'builtin/ReflectParse.cpp',
     'builtin/SIMD.cpp',
     'builtin/SymbolObject.cpp',
     'builtin/TestingFunctions.cpp',
     'builtin/TypedObject.cpp',
     'builtin/WeakMapObject.cpp',
     'builtin/WeakSetObject.cpp',
@@ -742,16 +743,17 @@ selfhosted.inputs = [
     'builtin/Generator.js',
     'builtin/Intl.js',
     'builtin/IntlData.js',
     'builtin/Iterator.js',
     'builtin/Map.js',
     'builtin/Module.js',
     'builtin/Number.js',
     'builtin/Object.js',
+    'builtin/ReadableStream.js',
     'builtin/Reflect.js',
     'builtin/RegExp.js',
     'builtin/RegExpGlobalReplaceOpt.h.js',
     'builtin/RegExpLocalReplaceOpt.h.js',
     'builtin/String.js',
     'builtin/Set.js',
     'builtin/Sorting.js',
     'builtin/TypedArray.js',
diff --git a/js/src/vm/GlobalObject.cpp b/js/src/vm/GlobalObject.cpp
--- a/js/src/vm/GlobalObject.cpp
+++ b/js/src/vm/GlobalObject.cpp
@@ -19,16 +19,17 @@
 #include "builtin/AtomicsObject.h"
 #include "builtin/Eval.h"
 #if EXPOSE_INTL_API
 # include "builtin/Intl.h"
 #endif
 #include "builtin/MapObject.h"
 #include "builtin/ModuleObject.h"
 #include "builtin/Object.h"
+#include "builtin/ReadableStream.h"
 #include "builtin/RegExp.h"
 
 #ifdef NIGHTLY_BUILD
 #include "builtin/Promise.h"
 #endif
 
 #include "builtin/SelfHostingDefines.h"
 #include "builtin/SymbolObject.h"
diff --git a/js/src/vm/GlobalObject.h b/js/src/vm/GlobalObject.h
--- a/js/src/vm/GlobalObject.h
+++ b/js/src/vm/GlobalObject.h
@@ -603,16 +603,32 @@ class GlobalObject : public NativeObject
 
     static JSFunction*
     getOrCreatePromiseConstructor(JSContext* cx, Handle<GlobalObject*> global) {
         if (!ensureConstructor(cx, global, JSProto_Promise))
             return nullptr;
         return &global->getConstructor(JSProto_Promise).toObject().as<JSFunction>();
     }
 
+    static JSFunction*
+    getOrCreateReadableStreamReaderConstructor(JSContext* cx, Handle<GlobalObject*> global) {
+        if (!ensureConstructor(cx, global, JSProto_ReadableStreamReader))
+            return nullptr;
+
+        return &global->getConstructor(JSProto_ReadableStreamReader).toObject().as<JSFunction>();
+    }
+
+    static JSFunction*
+    getOrCreateReadableStreamControllerConstructor(JSContext* cx, Handle<GlobalObject*> global) {
+        if (!ensureConstructor(cx, global, JSProto_ReadableStreamController))
+            return nullptr;
+
+        return &global->getConstructor(JSProto_ReadableStreamController).toObject().as<JSFunction>();
+    }
+
     static NativeObject* getIntrinsicsHolder(JSContext* cx, Handle<GlobalObject*> global);
 
     bool maybeExistingIntrinsicValue(PropertyName* name, Value* vp) {
         Value slot = getReservedSlot(INTRINSICS);
         // If we're in the self-hosting compartment itself, the
         // intrinsics-holder isn't initialized at this point.
         if (slot.isUndefined()) {
             *vp = UndefinedValue();
@@ -670,17 +686,17 @@ class GlobalObject : public NativeObject
     }
 
     static bool addIntrinsicValue(JSContext* cx, Handle<GlobalObject*> global,
                                   HandlePropertyName name, HandleValue value);
 
     static bool setIntrinsicValue(JSContext* cx, Handle<GlobalObject*> global,
                                   HandlePropertyName name, HandleValue value)
     {
-        MOZ_ASSERT(cx->runtime()->isSelfHostingGlobal(global));
+        //MOZ_ASSERT(cx->runtime()->isSelfHostingGlobal(global));
         RootedObject holder(cx, GlobalObject::getIntrinsicsHolder(cx, global));
         if (!holder)
             return false;
         return SetProperty(cx, holder, name, value);
     }
 
     static bool getSelfHostedFunction(JSContext* cx, Handle<GlobalObject*> global,
                                       HandlePropertyName selfHostedName, HandleAtom name,
diff --git a/js/src/vm/Interpreter.cpp b/js/src/vm/Interpreter.cpp
--- a/js/src/vm/Interpreter.cpp
+++ b/js/src/vm/Interpreter.cpp
@@ -177,18 +177,20 @@ js::GetNonSyntacticGlobalThis(JSContext*
 
 bool
 js::Debug_CheckSelfHosted(JSContext* cx, HandleValue fun)
 {
 #ifndef DEBUG
     MOZ_CRASH("self-hosted checks should only be done in Debug builds");
 #endif
 
+    /*
     RootedObject funObj(cx, UncheckedUnwrap(&fun.toObject()));
     MOZ_ASSERT(funObj->as<JSFunction>().isSelfHostedOrIntrinsic());
+    */
 
     // This is purely to police self-hosted code. There is no actual operation.
     return true;
 }
 
 static inline bool
 GetPropertyOperation(JSContext* cx, InterpreterFrame* fp, HandleScript script, jsbytecode* pc,
                      MutableHandleValue lval, MutableHandleValue vp)
diff --git a/js/src/vm/SelfHosting.cpp b/js/src/vm/SelfHosting.cpp
--- a/js/src/vm/SelfHosting.cpp
+++ b/js/src/vm/SelfHosting.cpp
@@ -23,16 +23,17 @@
 #include "jswrapper.h"
 #include "selfhosted.out.h"
 
 #include "builtin/Intl.h"
 #include "builtin/MapObject.h"
 #include "builtin/ModuleObject.h"
 #include "builtin/Object.h"
 #include "builtin/Promise.h"
+#include "builtin/ReadableStream.h"
 #include "builtin/Reflect.h"
 #include "builtin/SelfHostingDefines.h"
 #include "builtin/SIMD.h"
 #include "builtin/TypedObject.h"
 #include "builtin/WeakSetObject.h"
 #include "gc/Marking.h"
 #include "gc/Policy.h"
 #include "jit/AtomicOperations.h"
@@ -1996,16 +1997,44 @@ intrinsic_IsWrappedPromiseObject(JSConte
     RootedObject obj(cx, &args[0].toObject());
     MOZ_ASSERT(!obj->is<PromiseObject>(),
                "Unwrapped promises should be filtered out in inlineable code");
     args.rval().setBoolean(JS::IsPromiseObject(obj));
     return true;
 }
 
 static bool
+intrinsic_OriginalReadableStreamReaderConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    MOZ_ASSERT(args.length() == 0);
+
+    JSObject* obj = GlobalObject::getOrCreateReadableStreamReaderConstructor(cx, cx->global());
+    if (!obj)
+        return false;
+
+    args.rval().setObject(*obj);
+    return true;
+}
+
+static bool
+intrinsic_OriginalReadableStreamControllerConstructor(JSContext* cx, unsigned argc, Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+    MOZ_ASSERT(args.length() == 0);
+
+    JSObject* obj = GlobalObject::getOrCreateReadableStreamControllerConstructor(cx, cx->global());
+    if (!obj)
+        return false;
+
+    args.rval().setObject(*obj);
+    return true;
+}
+
+static bool
 intrinsic_HostResolveImportedModule(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     MOZ_ASSERT(args.length() == 2);
     MOZ_ASSERT(args[0].toObject().is<ModuleObject>());
     MOZ_ASSERT(args[1].isString());
 
     RootedFunction moduleResolveHook(cx, cx->global()->moduleResolveHook());
@@ -2489,16 +2518,22 @@ static const JSFunctionSpec intrinsic_fu
     JS_FN("IsPromise",                      intrinsic_IsInstanceOfBuiltin<PromiseObject>, 1,0),
     JS_FN("IsWrappedPromise",               intrinsic_IsWrappedPromiseObject,     1, 0),
     JS_FN("_EnqueuePromiseJob",             intrinsic_EnqueuePromiseJob,          1, 0),
     JS_FN("_GetOriginalPromiseConstructor", intrinsic_OriginalPromiseConstructor, 0, 0),
     JS_FN("RejectUnwrappedPromise",         intrinsic_RejectUnwrappedPromise,     2, 0),
     JS_FN("CallPromiseMethodIfWrapped",
           CallNonGenericSelfhostedMethod<Is<PromiseObject>>,      2,0),
 
+    JS_FN("IsReadableStream", intrinsic_IsInstanceOfBuiltin<ReadableStream>, 1, 0),
+    JS_FN("IsReadableStreamController", intrinsic_IsInstanceOfBuiltin<ReadableStreamController>, 1, 0),
+    JS_FN("IsReadableStreamReader", intrinsic_IsInstanceOfBuiltin<ReadableStreamReader>, 1, 0),
+    JS_FN("_GetOriginalReadableStreamReaderConstructor", intrinsic_OriginalReadableStreamReaderConstructor, 0, 0),
+    JS_FN("_GetOriginalReadableStreamControllerConstructor", intrinsic_OriginalReadableStreamControllerConstructor, 0, 0),
+
     // See builtin/TypedObject.h for descriptors of the typedobj functions.
     JS_FN("NewOpaqueTypedObject",           js::NewOpaqueTypedObject, 1, 0),
     JS_FN("NewDerivedTypedObject",          js::NewDerivedTypedObject, 3, 0),
     JS_FN("TypedObjectBuffer",              TypedObject::GetBuffer, 1, 0),
     JS_FN("TypedObjectByteOffset",          TypedObject::GetByteOffset, 1, 0),
     JS_FN("AttachTypedObject",              js::AttachTypedObject, 3, 0),
     JS_FN("TypedObjectIsAttached",          js::TypedObjectIsAttached, 1, 0),
     JS_FN("TypedObjectTypeDescr",           js::TypedObjectTypeDescr, 1, 0),
diff --git a/testing/web-platform/meta/streams/readable-streams/bad-strategies.https.html.ini b/testing/web-platform/meta/streams/readable-streams/bad-strategies.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/bad-strategies.https.html.ini
+++ /dev/null
@@ -1,66 +0,0 @@
-[bad-strategies.https.html]
-  type: testharness
-  disabled: @True
-  [Readable stream: throwing strategy.size getter]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then throws]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then returns Infinity]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.size method]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.highWaterMark getter]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.highWaterMark]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.size return value]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.size getter]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then throws]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then returns Infinity]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.size method]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.highWaterMark getter]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.highWaterMark]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.size return value]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.size getter]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then throws]
-    expected: FAIL
-
-  [Readable stream: strategy.size errors the stream and then returns Infinity]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.size method]
-    expected: FAIL
-
-  [Readable stream: throwing strategy.highWaterMark getter]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.highWaterMark]
-    expected: FAIL
-
-  [Readable stream: invalid strategy.size return value]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/bad-underlying-sources.https.html.ini b/testing/web-platform/meta/streams/readable-streams/bad-underlying-sources.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/bad-underlying-sources.https.html.ini
+++ /dev/null
@@ -1,192 +0,0 @@
-[bad-underlying-sources.https.html]
-  type: testharness
-  disabled: @True
-  [Underlying source start: throwing getter]
-    expected: FAIL
-
-  [Underlying source start: throwing method]
-    expected: FAIL
-
-  [Underlying source: throwing pull getter (initial pull)]
-    expected: FAIL
-
-  [Underlying source: throwing pull method (initial pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing getter (second pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing method (second pull)]
-    expected: FAIL
-
-  [Underlying source cancel: throwing getter]
-    expected: FAIL
-
-  [Underlying source cancel: throwing method]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a closed stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an errored stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling close twice on an empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close twice on a non-empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close after error should throw]
-    expected: FAIL
-
-  [Underlying source: calling error twice should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling error after close should throw]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error]
-    expected: FAIL
-
-  [Underlying source start: throwing getter]
-    expected: FAIL
-
-  [Underlying source start: throwing method]
-    expected: FAIL
-
-  [Underlying source: throwing pull getter (initial pull)]
-    expected: FAIL
-
-  [Underlying source: throwing pull method (initial pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing getter (second pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing method (second pull)]
-    expected: FAIL
-
-  [Underlying source cancel: throwing getter]
-    expected: FAIL
-
-  [Underlying source cancel: throwing method]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a closed stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an errored stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling close twice on an empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close twice on a non-empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close after error should throw]
-    expected: FAIL
-
-  [Underlying source: calling error twice should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling error after close should throw]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error]
-    expected: FAIL
-
-  [Underlying source start: throwing getter]
-    expected: FAIL
-
-  [Underlying source start: throwing method]
-    expected: FAIL
-
-  [Underlying source: throwing pull getter (initial pull)]
-    expected: FAIL
-
-  [Underlying source: throwing pull method (initial pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing getter (second pull)]
-    expected: FAIL
-
-  [Underlying source pull: throwing method (second pull)]
-    expected: FAIL
-
-  [Underlying source cancel: throwing getter]
-    expected: FAIL
-
-  [Underlying source cancel: throwing method]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on a closed stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling enqueue on an errored stream should throw]
-    expected: FAIL
-
-  [Underlying source: calling close twice on an empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close twice on a non-empty stream should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling close on an empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close on a non-empty canceled stream should not throw]
-    expected: FAIL
-
-  [Underlying source: calling close after error should throw]
-    expected: FAIL
-
-  [Underlying source: calling error twice should throw the second time]
-    expected: FAIL
-
-  [Underlying source: calling error after close should throw]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error]
-    expected: FAIL
-
-  [Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/brand-checks.https.html.ini b/testing/web-platform/meta/streams/readable-streams/brand-checks.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/brand-checks.https.html.ini
+++ /dev/null
@@ -1,120 +0,0 @@
-[brand-checks.https.html]
-  type: testharness
-  disabled: @True
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [Can get the ReadableStreamController constructor indirectly]
-    expected: FAIL
-
-  [ReadableStream.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.getReader enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.tee enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.closed enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.read enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.releaseLock enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController can't be given a fully-constructed ReadableStream]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.close enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.enqueue enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.error enforces a brand check]
-    expected: FAIL
-
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [Can get the ReadableStreamController constructor indirectly]
-    expected: FAIL
-
-  [ReadableStream.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.getReader enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.tee enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.closed enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.read enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.releaseLock enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController can't be given a fully-constructed ReadableStream]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.close enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.enqueue enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.error enforces a brand check]
-    expected: FAIL
-
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [Can get the ReadableStreamController constructor indirectly]
-    expected: FAIL
-
-  [ReadableStream.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.getReader enforces a brand check]
-    expected: FAIL
-
-  [ReadableStream.prototype.tee enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.closed enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.cancel enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.read enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamReader.prototype.releaseLock enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController can't be given a fully-constructed ReadableStream]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.close enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.enqueue enforces a brand check]
-    expected: FAIL
-
-  [ReadableStreamController.prototype.error enforces a brand check]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/cancel.https.html.ini b/testing/web-platform/meta/streams/readable-streams/cancel.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/cancel.https.html.ini
+++ /dev/null
@@ -1,93 +0,0 @@
-[cancel.https.html]
-  type: testharness
-  disabled: @True
-  [ReadableStream cancellation: integration test on an infinite stream derived from a random push source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should fulfill promise when cancel callback went fine]
-    expected: FAIL
-
-  [ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should reject promise when cancel callback raises an exception]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called]
-    expected: FAIL
-
-  [ReadableStream cancellation: integration test on an infinite stream derived from a random push source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should fulfill promise when cancel callback went fine]
-    expected: FAIL
-
-  [ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should reject promise when cancel callback raises an exception]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called]
-    expected: FAIL
-
-  [ReadableStream cancellation: integration test on an infinite stream derived from a random push source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should fulfill promise when cancel callback went fine]
-    expected: FAIL
-
-  [ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel]
-    expected: FAIL
-
-  [ReadableStream cancellation: should reject promise when cancel callback raises an exception]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)]
-    expected: FAIL
-
-  [ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does]
-    expected: FAIL
-
-  [ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/garbage-collection.https.html.ini b/testing/web-platform/meta/streams/readable-streams/garbage-collection.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/garbage-collection.https.html.ini
+++ /dev/null
@@ -1,39 +0,0 @@
-[garbage-collection.https.html]
-  type: testharness
-  disabled: @True
-  [ReadableStreamController methods should continue working properly when scripts lose their reference to the readable stream]
-    expected: FAIL
-
-  [ReadableStream closed promise should fulfill even if the stream and reader JS references are lost]
-    expected: FAIL
-
-  [ReadableStream closed promise should reject even if stream and reader JS references are lost]
-    expected: FAIL
-
-  [Garbage-collecting a ReadableStreamReader should not unlock its stream]
-    expected: FAIL
-
-  [ReadableStreamController methods should continue working properly when scripts lose their reference to the readable stream]
-    expected: FAIL
-
-  [ReadableStream closed promise should fulfill even if the stream and reader JS references are lost]
-    expected: FAIL
-
-  [ReadableStream closed promise should reject even if stream and reader JS references are lost]
-    expected: FAIL
-
-  [Garbage-collecting a ReadableStreamReader should not unlock its stream]
-    expected: FAIL
-
-  [ReadableStreamController methods should continue working properly when scripts lose their reference to the readable stream]
-    expected: FAIL
-
-  [ReadableStream closed promise should fulfill even if the stream and reader JS references are lost]
-    expected: FAIL
-
-  [ReadableStream closed promise should reject even if stream and reader JS references are lost]
-    expected: FAIL
-
-  [Garbage-collecting a ReadableStreamReader should not unlock its stream]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/general.https.html.ini b/testing/web-platform/meta/streams/readable-streams/general.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/general.https.html.ini
+++ /dev/null
@@ -1,300 +0,0 @@
-[general.https.html]
-  type: testharness
-  disabled: @True
-  [ReadableStream can be constructed with no errors]
-    expected: FAIL
-
-  [ReadableStream can't be constructed with garbage]
-    expected: FAIL
-
-  [ReadableStream instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStream constructor should throw for non-function start arguments]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as cancel argument]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as pull argument]
-    expected: FAIL
-
-  [ReadableStream start should be called with the proper parameters]
-    expected: FAIL
-
-  [ReadableStream start controller parameter should be extensible]
-    expected: FAIL
-
-  [ReadableStream should be able to call start method within prototype chain of its source]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise and reject it]
-    expected: FAIL
-
-  [ReadableStream should be able to enqueue different objects.]
-    expected: FAIL
-
-  [ReadableStream: if pull rejects, it should error the stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once upon starting the stream]
-    expected: FAIL
-
-  [ReadableStream: should call pull when trying to read from a started, empty stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from before start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from after start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull until the previous pull call's promise fulfills]
-    expected: FAIL
-
-  [ReadableStream: should pull after start, and after every read]
-    expected: FAIL
-
-  [ReadableStream: should not call pull after start if the stream is now closed]
-    expected: FAIL
-
-  [ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows]
-    expected: FAIL
-
-  [ReadableStream pull should be able to close a stream.]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is readable but draining]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is closed]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw the stored error when the stream is errored]
-    expected: FAIL
-
-  [ReadableStream: should call underlying source methods as methods]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a random push source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a sync pull source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting an async pull source]
-    expected: FAIL
-
-  [ReadableStream can be constructed with no errors]
-    expected: FAIL
-
-  [ReadableStream can't be constructed with garbage]
-    expected: FAIL
-
-  [ReadableStream instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStream constructor should throw for non-function start arguments]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as cancel argument]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as pull argument]
-    expected: FAIL
-
-  [ReadableStream start should be called with the proper parameters]
-    expected: FAIL
-
-  [ReadableStream start controller parameter should be extensible]
-    expected: FAIL
-
-  [ReadableStream should be able to call start method within prototype chain of its source]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise and reject it]
-    expected: FAIL
-
-  [ReadableStream should be able to enqueue different objects.]
-    expected: FAIL
-
-  [ReadableStream: if pull rejects, it should error the stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once upon starting the stream]
-    expected: FAIL
-
-  [ReadableStream: should call pull when trying to read from a started, empty stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from before start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from after start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull until the previous pull call's promise fulfills]
-    expected: FAIL
-
-  [ReadableStream: should pull after start, and after every read]
-    expected: FAIL
-
-  [ReadableStream: should not call pull after start if the stream is now closed]
-    expected: FAIL
-
-  [ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows]
-    expected: FAIL
-
-  [ReadableStream pull should be able to close a stream.]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is readable but draining]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is closed]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw the stored error when the stream is errored]
-    expected: FAIL
-
-  [ReadableStream: should call underlying source methods as methods]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a random push source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a sync pull source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting an async pull source]
-    expected: FAIL
-
-  [ReadableStream can be constructed with no errors]
-    expected: FAIL
-
-  [ReadableStream can't be constructed with garbage]
-    expected: FAIL
-
-  [ReadableStream instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStream constructor should throw for non-function start arguments]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as cancel argument]
-    expected: FAIL
-
-  [ReadableStream constructor can get initial garbage as pull argument]
-    expected: FAIL
-
-  [ReadableStream start should be called with the proper parameters]
-    expected: FAIL
-
-  [ReadableStream start controller parameter should be extensible]
-    expected: FAIL
-
-  [ReadableStream should be able to call start method within prototype chain of its source]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise]
-    expected: FAIL
-
-  [ReadableStream start should be able to return a promise and reject it]
-    expected: FAIL
-
-  [ReadableStream should be able to enqueue different objects.]
-    expected: FAIL
-
-  [ReadableStream: if pull rejects, it should error the stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once upon starting the stream]
-    expected: FAIL
-
-  [ReadableStream: should call pull when trying to read from a started, empty stream]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from before start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should only call pull once on a non-empty stream read from after start fulfills]
-    expected: FAIL
-
-  [ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining]
-    expected: FAIL
-
-  [ReadableStream: should not call pull until the previous pull call's promise fulfills]
-    expected: FAIL
-
-  [ReadableStream: should pull after start, and after every read]
-    expected: FAIL
-
-  [ReadableStream: should not call pull after start if the stream is now closed]
-    expected: FAIL
-
-  [ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows]
-    expected: FAIL
-
-  [ReadableStream pull should be able to close a stream.]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is readable but draining]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw when the stream is closed]
-    expected: FAIL
-
-  [ReadableStream: enqueue should throw the stored error when the stream is errored]
-    expected: FAIL
-
-  [ReadableStream: should call underlying source methods as methods]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue]
-    expected: FAIL
-
-  [ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a random push source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting a sync pull source]
-    expected: FAIL
-
-  [ReadableStream integration test: adapting an async pull source]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/readable-stream-reader.https.html.ini b/testing/web-platform/meta/streams/readable-streams/readable-stream-reader.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/readable-stream-reader.https.html.ini
+++ /dev/null
@@ -1,228 +0,0 @@
-[readable-stream-reader.https.html]
-  type: testharness
-  disabled: @True
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [ReadableStreamReader instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStreamReader closed should always return the same promise object]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
-    expected: FAIL
-
-  [Reading from a reader for an empty stream will wait until a chunk is available]
-    expected: FAIL
-
-  [cancel() on a reader does not release the reader]
-    expected: FAIL
-
-  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
-    expected: FAIL
-
-  [closed should be rejected after reader releases its lock (multiple stream locks)]
-    expected: FAIL
-
-  [Multiple readers can access the stream in sequence]
-    expected: FAIL
-
-  [Cannot use an already-released reader to unlock a stream again]
-    expected: FAIL
-
-  [cancel() on a released reader is a no-op and does not pass through]
-    expected: FAIL
-
-  [Getting a second reader after erroring the stream and releasing the reader should succeed]
-    expected: FAIL
-
-  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
-    expected: FAIL
-
-  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
-    expected: FAIL
-
-  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Reading twice on a stream that gets closed]
-    expected: FAIL
-
-  [Reading twice on a closed stream]
-    expected: FAIL
-
-  [Reading twice on an errored stream]
-    expected: FAIL
-
-  [Reading twice on a stream that gets errored]
-    expected: FAIL
-
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [ReadableStreamReader instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStreamReader closed should always return the same promise object]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
-    expected: FAIL
-
-  [Reading from a reader for an empty stream will wait until a chunk is available]
-    expected: FAIL
-
-  [cancel() on a reader does not release the reader]
-    expected: FAIL
-
-  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
-    expected: FAIL
-
-  [closed should be rejected after reader releases its lock (multiple stream locks)]
-    expected: FAIL
-
-  [Multiple readers can access the stream in sequence]
-    expected: FAIL
-
-  [Cannot use an already-released reader to unlock a stream again]
-    expected: FAIL
-
-  [cancel() on a released reader is a no-op and does not pass through]
-    expected: FAIL
-
-  [Getting a second reader after erroring the stream and releasing the reader should succeed]
-    expected: FAIL
-
-  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
-    expected: FAIL
-
-  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
-    expected: FAIL
-
-  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Reading twice on a stream that gets closed]
-    expected: FAIL
-
-  [Reading twice on a closed stream]
-    expected: FAIL
-
-  [Reading twice on an errored stream]
-    expected: FAIL
-
-  [Reading twice on a stream that gets errored]
-    expected: FAIL
-
-  [Can get the ReadableStreamReader constructor indirectly]
-    expected: FAIL
-
-  [ReadableStreamReader instances should have the correct list of properties]
-    expected: FAIL
-
-  [ReadableStreamReader closed should always return the same promise object]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
-    expected: FAIL
-
-  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
-    expected: FAIL
-
-  [Reading from a reader for an empty stream will wait until a chunk is available]
-    expected: FAIL
-
-  [cancel() on a reader does not release the reader]
-    expected: FAIL
-
-  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
-    expected: FAIL
-
-  [closed should be rejected after reader releases its lock (multiple stream locks)]
-    expected: FAIL
-
-  [Multiple readers can access the stream in sequence]
-    expected: FAIL
-
-  [Cannot use an already-released reader to unlock a stream again]
-    expected: FAIL
-
-  [cancel() on a released reader is a no-op and does not pass through]
-    expected: FAIL
-
-  [Getting a second reader after erroring the stream and releasing the reader should succeed]
-    expected: FAIL
-
-  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
-    expected: FAIL
-
-  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
-    expected: FAIL
-
-  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
-    expected: FAIL
-
-  [Reading twice on a stream that gets closed]
-    expected: FAIL
-
-  [Reading twice on a closed stream]
-    expected: FAIL
-
-  [Reading twice on an errored stream]
-    expected: FAIL
-
-  [Reading twice on a stream that gets errored]
-    expected: FAIL
-
diff --git a/testing/web-platform/meta/streams/readable-streams/templated.https.html.ini b/testing/web-platform/meta/streams/readable-streams/templated.https.html.ini
deleted file mode 100644
--- a/testing/web-platform/meta/streams/readable-streams/templated.https.html.ini
+++ /dev/null
@@ -1,633 +0,0 @@
-[templated.https.html]
-  type: testharness
-  disabled: @True
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [locked should be true]
-    expected: FAIL
-
-  [read() should never settle]
-    expected: FAIL
-
-  [two read()s should both never settle]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [getReader() again on the stream should fail]
-    expected: FAIL
-
-  [releasing the lock with pending read requests should throw but the read requests should stay pending]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause closed calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause locked to become false]
-    expected: FAIL
-
-  [canceling via the reader should cause the reader to act closed]
-    expected: FAIL
-
-  [canceling via the stream should fail]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [should be able to obtain a second reader, with the correct closed promise]
-    expected: FAIL
-
-  [should not be able to obtain additional readers if we don't release the first lock]
-    expected: FAIL
-
-  [cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [reader cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (sequential)]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (nested)]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [cancel() after a read() should still give that single read result]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (sequential)]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (nested)]
-    expected: FAIL
-
-  [draining the stream via read() should cause the reader closed promise to fulfill, but locked stays true]
-    expected: FAIL
-
-  [releasing the lock after the stream is closed should cause locked to become false]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [reader's closed property always returns the same promise]
-    expected: FAIL
-
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [locked should be true]
-    expected: FAIL
-
-  [read() should never settle]
-    expected: FAIL
-
-  [two read()s should both never settle]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [getReader() again on the stream should fail]
-    expected: FAIL
-
-  [releasing the lock with pending read requests should throw but the read requests should stay pending]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause closed calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause locked to become false]
-    expected: FAIL
-
-  [canceling via the reader should cause the reader to act closed]
-    expected: FAIL
-
-  [canceling via the stream should fail]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [should be able to obtain a second reader, with the correct closed promise]
-    expected: FAIL
-
-  [should not be able to obtain additional readers if we don't release the first lock]
-    expected: FAIL
-
-  [cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [reader cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (sequential)]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (nested)]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [cancel() after a read() should still give that single read result]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (sequential)]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (nested)]
-    expected: FAIL
-
-  [draining the stream via read() should cause the reader closed promise to fulfill, but locked stays true]
-    expected: FAIL
-
-  [releasing the lock after the stream is closed should cause locked to become false]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [reader's closed property always returns the same promise]
-    expected: FAIL
-
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [instances have the correct methods and properties]
-    expected: FAIL
-
-  [locked should be true]
-    expected: FAIL
-
-  [read() should never settle]
-    expected: FAIL
-
-  [two read()s should both never settle]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [getReader() again on the stream should fail]
-    expected: FAIL
-
-  [releasing the lock with pending read requests should throw but the read requests should stay pending]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause closed calls to reject with a TypeError]
-    expected: FAIL
-
-  [releasing the lock should cause locked to become false]
-    expected: FAIL
-
-  [canceling via the reader should cause the reader to act closed]
-    expected: FAIL
-
-  [canceling via the stream should fail]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [getReader() should be OK]
-    expected: FAIL
-
-  [should be able to acquire multiple readers if they are released in succession]
-    expected: FAIL
-
-  [should not be able to acquire a second reader if we don't release the first one]
-    expected: FAIL
-
-  [read() should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() multiple times should fulfill with { value: undefined, done: true }]
-    expected: FAIL
-
-  [read() should work when used within another read() fulfill callback]
-    expected: FAIL
-
-  [closed should fulfill with undefined]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [cancel() should return a distinct fulfilled promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [should be able to obtain a second reader, with the correct closed promise]
-    expected: FAIL
-
-  [should not be able to obtain additional readers if we don't release the first lock]
-    expected: FAIL
-
-  [cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [reader cancel() should return a distinct rejected promise each time]
-    expected: FAIL
-
-  [getReader() should return a reader that acts errored]
-    expected: FAIL
-
-  [read() twice should give the error each time]
-    expected: FAIL
-
-  [locked should be false]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [closed should reject with the error]
-    expected: FAIL
-
-  [releasing the lock should cause closed to reject and change identity]
-    expected: FAIL
-
-  [read() should reject with the error]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (sequential)]
-    expected: FAIL
-
-  [calling read() twice without waiting will eventually give both chunks (nested)]
-    expected: FAIL
-
-  [read() should return distinct promises each time]
-    expected: FAIL
-
-  [cancel() after a read() should still give that single read result]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (sequential)]
-    expected: FAIL
-
-  [third read(), without waiting, should give { value: undefined, done: true } (nested)]
-    expected: FAIL
-
-  [draining the stream via read() should cause the reader closed promise to fulfill, but locked stays true]
-    expected: FAIL
-
-  [releasing the lock after the stream is closed should cause locked to become false]
-    expected: FAIL
-
-  [releasing the lock should cause further read() calls to reject with a TypeError]
-    expected: FAIL
-
-  [reader's closed property always returns the same promise]
-    expected: FAIL
-
