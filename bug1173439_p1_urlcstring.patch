# HG changeset patch
# Parent 793d120a996122b1c7aca0e3e1cd2eca589ca621
# User Ben Kelly <ben@wanderview.com>
Bug 1173439 P1 Store URLs as UTF8 strings in Cache instead of UTF16. r=ehsan

diff --git a/dom/cache/AutoUtils.cpp b/dom/cache/AutoUtils.cpp
--- a/dom/cache/AutoUtils.cpp
+++ b/dom/cache/AutoUtils.cpp
@@ -288,17 +288,17 @@ MatchInPutList(InternalRequest* aRequest
   for (uint32_t i = 0; i < aPutList.Length(); ++i) {
     const CacheRequest& cachedRequest = aPutList[i].request();
     const CacheResponse& cachedResponse = aPutList[i].response();
 
     nsAutoCString url;
     aRequest->GetURL(url);
 
     // If the URLs don't match, then just skip to the next entry.
-    if (NS_ConvertUTF8toUTF16(url) != cachedRequest.url()) {
+    if (url != cachedRequest.url()) {
       continue;
     }
 
     nsRefPtr<InternalHeaders> cachedRequestHeaders =
       TypeUtils::ToInternalHeaders(cachedRequest.headers());
 
     nsRefPtr<InternalHeaders> cachedResponseHeaders =
       TypeUtils::ToInternalHeaders(cachedResponse.headers());
diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -34,26 +34,26 @@ using mozilla::dom::workers::WorkerPriva
 namespace {
 
 bool
 IsValidPutRequestURL(const nsAString& aUrl, ErrorResult& aRv)
 {
   bool validScheme = false;
 
   // make a copy because ProcessURL strips the fragmet
-  nsAutoString url(aUrl);
+  NS_ConvertUTF16toUTF8 url(aUrl);
 
   TypeUtils::ProcessURL(url, &validScheme, nullptr, aRv);
   if (aRv.Failed()) {
     return false;
   }
 
   if (!validScheme) {
     NS_NAMED_LITERAL_STRING(label, "Request");
-    aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &url);
+    aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aUrl);
     return false;
   }
 
   return true;
 }
 
 static bool
 IsValidPutRequestMethod(const Request& aRequest, ErrorResult& aRv)
diff --git a/dom/cache/CacheTypes.ipdlh b/dom/cache/CacheTypes.ipdlh
--- a/dom/cache/CacheTypes.ipdlh
+++ b/dom/cache/CacheTypes.ipdlh
@@ -48,18 +48,18 @@ struct HeadersEntry
 {
   nsCString name;
   nsCString value;
 };
 
 struct CacheRequest
 {
   nsCString method;
-  nsString url;
-  nsString urlWithoutQuery;
+  nsCString url;
+  nsCString urlWithoutQuery;
   HeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   nsString referrer;
   RequestMode mode;
   RequestCredentials credentials;
   CacheReadStreamOrVoid body;
   uint32_t contentPolicyType;
   RequestCache requestCache;
@@ -69,17 +69,17 @@ union CacheRequestOrVoid
 {
   void_t;
   CacheRequest;
 };
 
 struct CacheResponse
 {
   ResponseType type;
-  nsString url;
+  nsCString url;
   uint32_t status;
   nsCString statusText;
   HeadersEntry[] headers;
   HeadersGuardEnum headersGuard;
   CacheReadStreamOrVoid body;
   IPCChannelInfo channelInfo;
 };
 
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -24,21 +24,21 @@
 #include "mozilla/dom/ResponseBinding.h"
 #include "nsIContentPolicy.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 namespace db {
 
-const int32_t kMaxWipeSchemaVersion = 13;
+const int32_t kMaxWipeSchemaVersion = 14;
 
 namespace {
 
-const int32_t kLatestSchemaVersion = 13;
+const int32_t kLatestSchemaVersion = 14;
 const int32_t kMaxEntriesPerStatement = 255;
 
 const uint32_t kPageSize = 4 * 1024;
 
 // Grow the database in chunks to reduce fragmentation
 const uint32_t kGrowthSize = 32 * 1024;
 const uint32_t kGrowthPages = kGrowthSize / kPageSize;
 static_assert(kGrowthSize % kPageSize == 0,
@@ -934,17 +934,17 @@ QueryCache(mozIStorageConnection* aConn,
     "SELECT id, COUNT(response_headers.name) AS vary_count "
     "FROM entries "
     "LEFT OUTER JOIN response_headers ON entries.id=response_headers.entry_id "
                                     "AND response_headers.name='vary' "
     "WHERE entries.cache_id=:cache_id "
       "AND entries."
   );
 
-  nsAutoString urlToMatch;
+  nsAutoCString urlToMatch;
   if (aParams.ignoreSearch()) {
     urlToMatch = aRequest.urlWithoutQuery();
     query.AppendLiteral("request_url_no_query");
   } else {
     urlToMatch = aRequest.url();
     query.AppendLiteral("request_url");
   }
 
@@ -952,17 +952,17 @@ QueryCache(mozIStorageConnection* aConn,
 
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(query, getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64ByName(NS_LITERAL_CSTRING("cache_id"), aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringByName(NS_LITERAL_CSTRING("url"), urlToMatch);
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("url"), urlToMatch);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData = false;
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
     // no invalid EntryId, init to least likely real value
     EntryId entryId = INT32_MAX;
     rv = state->GetInt32(0, &entryId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -1474,22 +1474,22 @@ InsertEntry(mozIStorageConnection* aConn
     ");"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_method"),
                                    aRequest.method());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringByName(NS_LITERAL_CSTRING("request_url"),
-                               aRequest.url());
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_url"),
+                                   aRequest.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringByName(NS_LITERAL_CSTRING("request_url_no_query"),
-                               aRequest.urlWithoutQuery());
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("request_url_no_query"),
+                                   aRequest.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindStringByName(NS_LITERAL_CSTRING("request_referrer"),
                                aRequest.referrer());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32ByName(NS_LITERAL_CSTRING("request_headers_guard"),
     static_cast<int32_t>(aRequest.headersGuard()));
@@ -1513,18 +1513,18 @@ InsertEntry(mozIStorageConnection* aConn
 
   rv = BindId(state, NS_LITERAL_CSTRING("request_body_id"), aRequestBodyId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32ByName(NS_LITERAL_CSTRING("response_type"),
                               static_cast<int32_t>(aResponse.type()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringByName(NS_LITERAL_CSTRING("response_url"),
-                               aResponse.url());
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("response_url"),
+                                   aResponse.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32ByName(NS_LITERAL_CSTRING("response_status"),
                               aResponse.status());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("response_status_text"),
                                    aResponse.statusText());
@@ -1661,17 +1661,17 @@ ReadResponse(mozIStorageConnection* aCon
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t type;
   rv = state->GetInt32(0, &type);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedResponseOut->mValue.type() = static_cast<ResponseType>(type);
 
-  rv = state->GetString(1, aSavedResponseOut->mValue.url());
+  rv = state->GetUTF8String(1, aSavedResponseOut->mValue.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t status;
   rv = state->GetInt32(2, &status);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedResponseOut->mValue.status() = status;
 
   rv = state->GetUTF8String(3, aSavedResponseOut->mValue.statusText());
@@ -1762,20 +1762,20 @@ ReadRequest(mozIStorageConnection* aConn
 
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->GetUTF8String(0, aSavedRequestOut->mValue.method());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->GetString(1, aSavedRequestOut->mValue.url());
+  rv = state->GetUTF8String(1, aSavedRequestOut->mValue.url());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->GetString(2, aSavedRequestOut->mValue.urlWithoutQuery());
+  rv = state->GetUTF8String(2, aSavedRequestOut->mValue.urlWithoutQuery());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->GetString(3, aSavedRequestOut->mValue.referrer());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t guard;
   rv = state->GetInt32(4, &guard);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
diff --git a/dom/cache/TypeUtils.cpp b/dom/cache/TypeUtils.cpp
--- a/dom/cache/TypeUtils.cpp
+++ b/dom/cache/TypeUtils.cpp
@@ -18,16 +18,17 @@
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/ipc/PFileDescriptorSetChild.h"
 #include "mozilla/ipc/InputStreamUtils.h"
 #include "nsCOMPtr.h"
 #include "nsIAsyncInputStream.h"
 #include "nsIAsyncOutputStream.h"
 #include "nsIIPCSerializableInputStream.h"
 #include "nsQueryObject.h"
+#include "nsPromiseFlatString.h"
 #include "nsStreamUtils.h"
 #include "nsString.h"
 #include "nsURLParsers.h"
 #include "nsCRT.h"
 #include "nsHttp.h"
 
 namespace mozilla {
 namespace dom {
@@ -145,30 +146,29 @@ void
 TypeUtils::ToCacheRequest(CacheRequest& aOut, InternalRequest* aIn,
                           BodyAction aBodyAction, SchemeAction aSchemeAction,
                           ErrorResult& aRv)
 {
   MOZ_ASSERT(aIn);
 
   aIn->GetMethod(aOut.method());
 
-  nsAutoCString url;
-  aIn->GetURL(url);
-  CopyUTF8toUTF16(url, aOut.url());
+  aIn->GetURL(aOut.url());
 
   bool schemeValid;
   ProcessURL(aOut.url(), &schemeValid, &aOut.urlWithoutQuery(), aRv);
   if (aRv.Failed()) {
     return;
   }
 
   if (!schemeValid) {
     if (aSchemeAction == TypeErrorOnInvalidScheme) {
       NS_NAMED_LITERAL_STRING(label, "Request");
-      aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &aOut.url());
+      NS_ConvertUTF8toUTF16 url(aOut.url());
+      aRv.ThrowTypeError(MSG_INVALID_URL_SCHEME, &label, &url);
       return;
     }
   }
 
   aIn->GetReferrer(aOut.referrer());
 
   nsRefPtr<InternalHeaders> headers = aIn->Headers();
   MOZ_ASSERT(headers);
@@ -195,21 +195,19 @@ TypeUtils::ToCacheRequest(CacheRequest& 
 }
 
 void
 TypeUtils::ToCacheResponseWithoutBody(CacheResponse& aOut,
                                       InternalResponse& aIn, ErrorResult& aRv)
 {
   aOut.type() = aIn.Type();
 
-  nsAutoCString url;
-  aIn.GetUrl(url);
-  CopyUTF8toUTF16(url, aOut.url());
+  aIn.GetUrl(aOut.url());
 
-  if (aOut.url() != EmptyString()) {
+  if (aOut.url() != EmptyCString()) {
     // Pass all Response URL schemes through... The spec only requires we take
     // action on invalid schemes for Request objects.
     ProcessURL(aOut.url(), nullptr, nullptr, aRv);
     if (aRv.Failed()) {
       return;
     }
   }
 
@@ -274,17 +272,17 @@ TypeUtils::ToResponse(const CacheRespons
   if (aIn.type() == ResponseType::Error) {
     nsRefPtr<InternalResponse> error = InternalResponse::NetworkError();
     nsRefPtr<Response> r = new Response(GetGlobalObject(), error);
     return r.forget();
   }
 
   nsRefPtr<InternalResponse> ir = new InternalResponse(aIn.status(),
                                                        aIn.statusText());
-  ir->SetUrl(NS_ConvertUTF16toUTF8(aIn.url()));
+  ir->SetUrl(aIn.url());
 
   nsRefPtr<InternalHeaders> internalHeaders =
     ToInternalHeaders(aIn.headers(), aIn.headersGuard());
   ErrorResult result;
   ir->Headers()->SetGuard(aIn.headersGuard(), result);
   MOZ_ASSERT(!result.Failed());
   ir->Headers()->Fill(*internalHeaders, result);
   MOZ_ASSERT(!result.Failed());
@@ -317,17 +315,17 @@ TypeUtils::ToResponse(const CacheRespons
 }
 
 already_AddRefed<InternalRequest>
 TypeUtils::ToInternalRequest(const CacheRequest& aIn)
 {
   nsRefPtr<InternalRequest> internalRequest = new InternalRequest();
 
   internalRequest->SetMethod(aIn.method());
-  internalRequest->SetURL(NS_ConvertUTF16toUTF8(aIn.url()));
+  internalRequest->SetURL(aIn.url());
   internalRequest->SetReferrer(aIn.referrer());
   internalRequest->SetMode(aIn.mode());
   internalRequest->SetCredentialsMode(aIn.credentials());
   internalRequest->SetContentPolicyType(aIn.contentPolicyType());
   internalRequest->SetCacheMode(aIn.requestCache());
 
   nsRefPtr<InternalHeaders> internalHeaders =
     ToInternalHeaders(aIn.headers(), aIn.headersGuard());
@@ -369,20 +367,20 @@ TypeUtils::ToInternalHeaders(const nsTAr
   return ref.forget();
 }
 
 // Utility function to remove the fragment from a URL, check its scheme, and optionally
 // provide a URL without the query.  We're not using nsIURL or URL to do this because
 // they require going to the main thread.
 // static
 void
-TypeUtils::ProcessURL(nsAString& aUrl, bool* aSchemeValidOut,
-                      nsAString* aUrlWithoutQueryOut, ErrorResult& aRv)
+TypeUtils::ProcessURL(nsACString& aUrl, bool* aSchemeValidOut,
+                      nsACString* aUrlWithoutQueryOut, ErrorResult& aRv)
 {
-  NS_ConvertUTF16toUTF8 flatURL(aUrl);
+  const nsAFlatCString& flatURL = PromiseFlatCString(aUrl);
   const char* url = flatURL.get();
 
   // off the main thread URL parsing using nsStdURLParser.
   nsCOMPtr<nsIURLParser> urlParser = new nsStdURLParser();
 
   uint32_t pathPos;
   int32_t pathLen;
   uint32_t schemePos;
diff --git a/dom/cache/TypeUtils.h b/dom/cache/TypeUtils.h
--- a/dom/cache/TypeUtils.h
+++ b/dom/cache/TypeUtils.h
@@ -95,19 +95,29 @@ public:
   already_AddRefed<Request>
   ToRequest(const CacheRequest& aIn);
 
   // static methods
   static already_AddRefed<InternalHeaders>
   ToInternalHeaders(const nsTArray<HeadersEntry>& aHeadersEntryList,
                     HeadersGuardEnum aGuard = HeadersGuardEnum::None);
 
+  // Utility method for parsing a URL and doing associated operations.  A mix
+  // of things are done in this one method to avoid duplicated parsing:
+  //
+  //  1) The aUrl argument is modified to strip the fragment
+  //  2) If aSchemaValidOut is set, then a boolean value is set indicating
+  //     if the aUrl's scheme is valid or not for storing in the cache.
+  //  3) If aUrlWithoutQueryOut is set, then a url string is provided without
+  //     the search section.
+  //
+  // Any errors are thrown on ErrorResult.
   static void
-  ProcessURL(nsAString& aUrl, bool* aSchemeValidOut,
-             nsAString* aUrlWithoutQueryOut, ErrorResult& aRv);
+  ProcessURL(nsACString& aUrl, bool* aSchemeValidOut,
+             nsACString* aUrlWithoutQueryOut, ErrorResult& aRv);
 
 private:
   void
   CheckAndSetBodyUsed(Request* aRequest, BodyAction aBodyAction,
                       ErrorResult& aRv);
 
   already_AddRefed<InternalRequest>
   ToInternalRequest(const nsAString& aIn, ErrorResult& aRv);
