# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0890baf7b4bae094023139587b9655f4c2b1c8df
Bug 1272697 P3 Update to latest ReadableStream spec. r=till

diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -1,69 +1,65 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Streams spec, 3.2.3.
-function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+function ReadableStream(underlyingSource = {}, {size, highWaterMark} = {}) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
   }
-  if (underlyingSource === undefined) {
-    underlyingSource = {};
-  }
-  if (highWaterMark === undefined) {
-    highWaterMark = 1;
+
+  // Step 1. Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
+  // Step 2. Set this@[[reader]] and this@[[storedError]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
+  // Step 3. Set this@[[disturbed]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
+  // Step 4. Set this@[[readableStreamController]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, undefined);
+
+  // Step 5. Let type be ? GetV(underlyingSource, "type").
+  // Step 6. Let typeString be ? ToString(type).
+  // Step 7. If typeString is "bytes",
+  if (underlyingSource.type === "bytes") {
+    // Step a. If highWaterMark is undefined, let highWaterMark be 0.
+    if (highWaterMark === undefined) {
+      highWaterMark = 0;
+    }
+    // Step b. Set this@[[readableStreamController]] to ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
+    let ReadableByteStreamControllerCtor = GetReadableByteStreamControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableByteStreamControllerCtor(this, underlyingSource,
+                                                               highWaterMark));
   }
 
-  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
-  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
-  // Step 2. Set this@[[queue]] to a new empty List.
-  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
-  // Step 3. Set this@[[state]] to "readable".
-  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
-  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
-  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
-  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
-  // Step 6. Set this@[[disturbed]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
-  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
-  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
-  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
+  // Step 8. Otherwise, if type is undefined,
+  else if (underlyingSource.type === undefined) {
+    // Step a. If highWaterMark is undefined, let highWaterMark be 1.
+    if (highWaterMark === undefined) {
+      highWaterMark = 1;
+    }
 
-  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
-  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
-  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
-  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
-  // Step 11. ReturnIfAbrupt(startResult).
-  let startResult = InvokeOrNoop(underlyingSource, "start",
-    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
-  // Step 12. Resolve startResult as a promise:
-  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
-  callFunction(Promise_then, p, () => {
-this._log += 'resolved ' + startResult;
-    // Set this@[[started]] to true.
-    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
-    // Perform RequestReadableStreamPull(this).
-    RequestReadableStreamPull(this);
-  }, (r) => {
-    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
-    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
-      ErrorReadableStream(this, r);
-    }
-  });
+    // Step b. Set this@[[readableStreamController]] to ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
+    let ReadableStreamDefaultControllerCtor = GetReadableStreamDefaultControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableStreamDefaultControllerCtor(this, underlyingSource,
+                                                                  highWaterMark));
+  }
+
+  // Step 9. Otherwise, throw a RangeError exception.
+  else {
+    ThrowSomething("RangeError", "underlyingSource.type must be 'bytes' or undefined");
+  }
 }
 
+// TODO: implement new controller classes
+
 // Streams spec, 3.2.4.1. get locked
 function ReadableStream_locked() {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
   }
 
   return IsReadableStreamLocked(this);
 }
