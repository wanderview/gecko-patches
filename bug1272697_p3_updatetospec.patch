# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  823c1a5afa005d661423bf4c9dcab71c0fed2945
Bug 1272697 P3 Update to latest ReadableStream spec. r=till

diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
--- a/js/src/builtin/ReadableStream.h
+++ b/js/src/builtin/ReadableStream.h
@@ -11,17 +11,17 @@
 
 namespace js {
 
 class AutoSetNewObjectMetadata;
 
 class ReadableStream : public NativeObject
 {
   public:
-    static const unsigned RESERVED_SLOTS = 13;
+    static const unsigned RESERVED_SLOTS = 5;
     static const ClassSpec classSpec_;
     static const Class class_;
     static const ClassSpec protoClassSpec_;
     static const Class protoClass_;
 };
 
 class ReadableStreamController : public NativeObject
 {
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -1,129 +1,2247 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Streams spec, 3.2.3.
-function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+function ReadableStream(underlyingSource = {}, {size, highWaterMark} = {}) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
   }
-  if (underlyingSource === undefined) {
-    underlyingSource = {};
-  }
-  if (highWaterMark === undefined) {
-    highWaterMark = 1;
-  }
-
-  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
-  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
-  // Step 2. Set this@[[queue]] to a new empty List.
-  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
-  // Step 3. Set this@[[state]] to "readable".
-  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
-  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
-  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
+
+  // Step 1: Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_READABLE_STATE);
+  // Step 2: Set this@[[reader]] and this@[[storedError]] to undefined.
   UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
   UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
-  // Step 6. Set this@[[disturbed]] to false.
+  // Step 3: Set this@[[disturbed]] to false.
   UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
-  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
-  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
-  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
-
-  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
-  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
-  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
-  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
-  // Step 11. ReturnIfAbrupt(startResult).
-  let startResult = InvokeOrNoop(underlyingSource, "start",
-    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
-  // Step 12. Resolve startResult as a promise:
-  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
-  callFunction(Promise_then, p, () => {
-this._log += 'resolved ' + startResult;
-    // Set this@[[started]] to true.
-    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
-    // Perform RequestReadableStreamPull(this).
-    RequestReadableStreamPull(this);
-  }, (r) => {
-    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
-    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
-      ErrorReadableStream(this, r);
+  // Step 4: Set this@[[readableStreamController]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, undefined);
+
+  // Step 5: Let type be ? GetV(underlyingSource, "type").
+  // Step 6: Let typeString be ? ToString(type).
+  // Step 7: If typeString is "bytes",
+  if (underlyingSource.type === "bytes") {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 0.
+    if (highWaterMark === undefined) {
+      highWaterMark = 0;
     }
-  });
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
+    let ReadableByteStreamControllerCtor = GetReadableByteStreamControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableByteStreamControllerCtor(this,
+                                                               underlyingSource,
+                                                               highWaterMark));
+  }
+
+  // Step 8: Otherwise, if type is undefined,
+  else if (underlyingSource.type === undefined) {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 1.
+    if (highWaterMark === undefined) {
+      highWaterMark = 1;
+    }
+
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
+    let ReadableStreamDefaultControllerCtor = GetReadableStreamDefaultControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableStreamDefaultControllerCtor(this,
+                                                                  underlyingSource,
+                                                                  size,
+                                                                  highWaterMark));
+  }
+
+  // Step 9: Otherwise, throw a RangeError exception.
+  else {
+    ThrowSomething("RangeError",
+                   "underlyingSource.type must be 'bytes' or undefined");
+  }
 }
 
+// TODO: implement new controller classes
+
 // Streams spec, 3.2.4.1. get locked
 function ReadableStream_locked() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked",
+                   typeof this);
   }
 
+  // Step 2: Return ! IsReadableStreamLocked(this).
   return IsReadableStreamLocked(this);
 }
 
-// Streams spec, 3.2.4.2. cancel(reason)
+// Streams spec, 3.2.4.2. cancel ( reason )
 function ReadableStream_cancel(reason) {
+  // Step 1: If ! IsReadableStream(this) is false, return a promise rejected
+  //         with a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
     try {
-      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel",
+                     typeof this);
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 2: If ! IsReadableStreamLocked(this) is true, return a promise
+  //         rejected with a TypeError exception.
   if (IsReadableStreamLocked(this)) {
     try {
-      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_LOCKED, "cancel");
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 3: Return ! ReadableStreamCancel(this, reason).
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
-function ReadableStream_getReader() {
+function ReadableStream_getReader({ mode } = {}) {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader",
+                   typeof this);
   }
 
-  return AcquireReadableStreamReader(this);
+  // Step 2: If mode is "byob",
+  if (mode === "byob") {
+    // Step a: If ! IsReadableByteStreamController(this@[[readableStreamController]])
+    //         is false, throw a TypeError exception.
+    let controller = UnsafeGetObjectReservedSlot(this,
+                                                 READABLESTREAM_CONTROLLER_SLOT);
+    if (!IsReadableByteStreamController(controller)) {
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER);
+    }
+    // Step b: Return ? AcquireReadableStreamBYOBReader(this).
+    return AcquireReadableStreamBYOBReader(this);
+  }
+
+  // Step 3: If mode is undefined, return
+  //         ? AcquireReadableStreamDefaultReader(this).
+  if (mode === undefined) {
+    return AcquireReadableStreamDefaultReader(this);
+  }
+
+  ThrowSomething("RangeError", "mode must be 'byob' or undefined");
 }
 
 // Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
-function ReadableStream_pipeThrough({ writable, readable }, options) {
-  ReadableStream_pipeTo.call(this, writable, options);
-  return readable;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
-function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
-  return null;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.6. tee()
 function ReadableStream_tee() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee",
+                   typeof this);
   }
 
-  let branches = TeeReadableStream(this, false);
-  return branches;
+  // Step 2: Let branches be ? ReadableStreamTee(this, false).
+  let branches = ReadableStreamTee(this, false);
+
+  // Step 3: Return ! CreateArrayFromList(branches).
+  assert(branches.length == 2, "ReadableStreamTee() must return two branches.");
+  return [ branches[0], branches[1] ];
 }
 
+// Streams spec, 3.3.1. AcquireReadableStreamBYOBReader ( stream )
+function AcquireReadableStreamBYOBReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamBYOBReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamBYOBReaderCtor();
+  return new ReadableStreamBYOBReaderCtor(stream);
+}
+
+// Streams spec, 3.3.2. AcquireReadableStreamDefaultReader ( stream )
+function AcquireReadableStreamDefaultReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamDefaultReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamDefaultReaderCtor();
+  return new ReadableStreamDefaultReaderCtor(stream);
+}
+
+// Streams spec, 3.3.3. IsReadableStream ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStream>()
+
+// Streams spec, 3.3.4. IsReadableStreamDisturbed ( stream )
+function IsReadableStreamDisturbed(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStreamController(this), "IsReadableStream(stream)");
+
+  // Step 2: Return stream@[[disturbed]].
+  return UnsafeGetBooleanReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT);
+}
+
+// Streams spec, 3.3.5. IsReadableStreamLocked ( stream )
+function IsReadableStreamLocked(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: If stream@[[reader]] is undefined, return false.
+  // Step 3: Return true.
+  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
+}
+
+// Streams spec, 3.3.6. ReadableStreamTee ( stream, shouldClone )
+// TODO: This could be re-designed to use a class instead of closures
+function ReadableStreamTee(stream, shouldClone) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: Assert: Type(shouldClone) is Boolean.
+  assert(typeof shouldClone === 'boolean', "Type(shouldClone) is Boolean");
+
+  // Step 3: Let reader be ? AcquireReadableStreamDefaultReader(stream).
+  let reader = AcquireReadableStreamDefaultReader(stream);
+
+  // Step 4: Let teeState be Record {[[closedOrErrored]]: false, [[canceled1]]: false, [[canceled2]]: false, [[reason1]]: undefined, [[reason2]]: undefined, [[promise]]: a new promise}.
+  let teeState = new Record();
+  teeState.closedOrErrored = false;
+  teeState.canceled1 = false;
+  teeState.canceled2 = false;
+  teeState.reason1 = undefined;
+  teeState.reason2 = undefined;
+  teeState.deferred = CreateDeferred();
+
+  // Step 5: Let pull be a new ReadableStreamTee pull function.
+  // Step 6: Set pull@[[reader]] to reader, pull@[[teeState]] to teeState, and
+  //         pull@[[shouldClone]] to shouldClone.
+  let pull = () => {
+    // ReadableStreamTee pull function
+    // Step 1: Let reader be F@[[reader]], branch1 be F@[[branch1]],
+    //         branch2 be F@[[branch2]], teeState be F@[[teeState]], and
+    //         shouldClone be F@[[shouldClone]].
+    // Implemented via closure.
+    let branch1 = UnsafeGetObjectFromReservedSlot(branch1Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+    let branch2 = UnsafeGetObjectFromReservedSlot(branch2Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+
+    // Step 2: Return the result of transforming
+    //         ! ReadableStreamDefaultReaderRead(reader) by a fulfillment
+    //         handler which takes the argument result and performs the
+    //         following steps:
+    let readPromise = ReadableStreamDefaultReaderRead(stream);
+    callFunction(Promise_then, readPromise, result => {
+      // Step a: Assert: Type(result) is Object.
+      assert(IsObject(result), "Read result should be an object");
+
+      // Step b: Let value be ? Get(result, "value").
+      let value = result.value;
+
+      // Step c: Let done be ? Get(result, "done").
+      let done = result.done;
+
+      // Step d: Assert: Type(done) is Boolean.
+      assert(typeof done === 'boolean', "Read result.done should be a boolean");
+
+      // Step e: If done is true and teeState.[[closedOrErrored]] is false,
+      if (done && !teeState.closedOrErrored) {
+        // Step i: If teeState.[[canceled1]] is false,
+        if (!teeState.canceled1) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch1).
+          ReadableStreamDefaultControllerClose(branch1);
+        }
+
+        // Step ii: If teeState.[[canceled2]] is false,
+        if (!teeState.canceled2) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch2).
+          ReadableStreamDefaultControllerClose(branch2);
+        }
+
+        // Step iii: Set teeState.[[closedOrErrored]] to true.
+        teeState.closedOrErrored = true;
+      }
+
+      // Step f: If teeState.[[closedOrErrored]] is true, return undefined.
+      if (teeState.closedOrErrored) {
+        return;
+      }
+
+      // Step g: If teeState.[[canceled1]] is false,
+      if (!teeState.canceled1) {
+        // Step i: Let value1 be value.
+        let value1 = value;
+
+        // Step ii: If shouldClone is true, set value1 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value1).
+        ReadableStreamDefaultControllerEnqueue(branch1, value1);
+      }
+
+      // Step h: If teeState.[[canceled2]] is false,
+      if (!teeState.canceled2) {
+        // Step i: Let value2 be value.
+        let value2 = value;
+
+        // Step ii: If shouldClone is true, set value2 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value2).
+        ReadableStreamDefaultControllerEnqueue(branch2, value2);
+      }
+    });
+  };
+
+  // Step 7: Let cancel1 be a new ReadableStreamTee branch 1 cancel function.
+  // Step 8: Set cancel1@[[stream]] to stream and cancel1@[[teeState]] to
+  //         teeState.
+  let cancel1 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled1]] to true.
+    teeState.canceled1 = true;
+
+    // Step 3: Set teeState.[[reason1]] to reason.
+    teeState.reason1 = reason;
+
+    // Step 4: If teeState.[[canceled2]] is true,
+    if (teeState.canceled2) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(teeState.deferred.resolve, teeState.deferred.promise,
+                   cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.deferred.promise;
+  };
+
+  // Step 9: Let cancel2 be a new ReadableStreamTee branch 2 cancel function.
+  // Step 10: Set cancel2@[[stream]] to stream and cancel2@[[teeState]] to
+  //          teeState.
+  let cancel2 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled2]] to true.
+    teeState.canceled2 = true;
+
+    // Step 3: Set teeState.[[reason2]] to reason.
+    teeState.reason2 = reason;
+
+    // Step 4: If teeState.[[canceled1]] is true,
+    if (teeState.canceled1) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(teeState.deferred.resolve, teeState.deferred.promise,
+                   cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.deferred.promise;
+  };
+
+  // Step 11: Let underlyingSource1 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 12: Perform ! CreateDataProperty(underlyingSource1, "pull", pull).
+  // Step 13: Perform ! CreateDataProperty(underlyingSource1, "cancel", cancel1).
+  let underlyingSource1 = {
+    pull: pull,
+    cancel: cancel1
+  };
+
+  // Step 14: Let branch1Stream be ! Construct(ReadableStream, underlyingSource1).
+  let ReadableStreamCtor = GetReadableStreamCtor();
+  let branch1Stream = new ReadableStreamCtor(underlyingSource1);
+
+  // Step 15: Let underlyingSource2 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 16: Perform ! CreateDataProperty(underlyingSource2, "pull", pull).
+  // Step 17: Perform ! CreateDataProperty(underlyingSource2, "cancel", cancel2).
+  let underlyingSource2 = {
+    pull: pull,
+    cancel: cancel2
+  };
+
+  // Step 18: Let branch2Stream be ! Construct(ReadableStream, underlyingSource2).
+  let branch2Stream = new ReadableStreamCtor(underlyingSource2);
+
+  // Step 19: Set pull@[[branch1]] to branch1Stream@[[readableStreamController]].
+  // Step 20: Set pull@[[branch2]] to branch2Stream@[[readableStreamController]].
+  // Implemented via the pull closure above.
+
+  // Step 21: Upon rejection of reader@[[closedPromise]] with reason r,
+  // TODO: fix slot name here
+  let readerClosedPromise =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
+  callFunction(Promise_catch, readerClosedPromise, reason => {
+    // Step a: If teeState.[[closedOrErrored]] is true, return undefined.
+    if (teeState.closedOrErrored) {
+      return;
+    }
+    // Step b: Perform ! ReadableStreamDefaultControllerError(pull@[[branch1]], r).
+    ReadableStreamDefaultControllerError(branch1Stream, reason);
+    // Step c: Perform ! ReadableStreamDefaultControllerError(pull@[[branch2]], r).
+    ReadableStreamDefaultControllerError(branch2Stream, reason);
+    // Step d: Set teeState.[[closedOrErrored]] to true.
+    teeState.closedOrErrored = true;
+  });
+
+  // Step 22: Return « branch1, branch2 ».
+  let result = new List();
+  result[0] = branch1Stream;
+  result[1] = branch2Stream;
+  return result;
+}
+
+// Streams spec, 3.4.1. ReadableStreamAddReadIntoRequest ( stream )
+function ReadableStreamAddReadIntoRequest(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamAddReadIntoRequest() must operate on a stream");
+
+  // Step 1: Assert: ! IsReadableStreamBYOBReader(stream@[[reader]]) is true.
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  assert(IsReadableStreamBYOBReader(reader),
+         "ReadableStreamAddReadIntoRequest() must operate on a ReadableStreamBYOBReader");
+
+  // Step 2: Let promise be a new promise.
+  let deferred = CreateDeferred();
+
+  // Step 3: Let readIntoRequest be Record {[[promise]]: promise}.
+  let readIntoRequest = new Record();
+  readIntoRequest.deferred = deferred;
+
+  // Step 4: Append readRequest as the last element of stream@[[reader]]@[[readIntoRequests]].
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  ArrayStaticPush(readIntoRequests, readIntoRequest);
+
+  // Step 5: Return promise.
+  return deferred.promise;
+}
+
+// Streams spec, 3.4.2. ReadableStreamAddReadRequest ( stream )
+function ReadableStreamAddReadIntoRequest(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamAddReadRequest() must operate on a stream");
+
+  // Step 1: Assert: ! IsReadableStreamDefaultReader(stream@[[reader]]) is true.
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  assert(IsReadableStreamDefaultReader(reader),
+         "ReadableStreamAddReadRequest() must operate on a ReadableStreamDefaultReader");
+
+  // Step 2: Let promise be a new promise.
+  let deferred = CreateDeferred();
+
+  // Step 3: Let readIntoRequest be Record {[[promise]]: promise}.
+  let readIntoRequest = new Record();
+  readIntoRequest.deferred = deferred;
+
+  // Step 4: Append readRequest as the last element of stream@[[reader]]@[[readIntoRequests]].
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  ArrayStaticPush(readIntoRequests, readIntoRequest);
+
+  // Step 5: Return promise.
+  return deferred.promise;
+}
+
+// Streams spec, 3.4.3. ReadableStreamCancel ( stream, reason )
+function ReadableStreamCancel(stream, reason) {
+  // Step 1: Assert: stream is not undefined.
+  assert(IsReadableStream(stream),
+         "ReadableStreamCancel must operate on a ReadableStream");
+
+  // Step 2: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 3: If stream@[[state]] is "closed", return a new promise resolved
+  //         with undefined.
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    return callFunction(Promise_static_resolve, GetPromiseCtor(), undefined);
+  }
+
+  // Step 4: If stream@[[state]] is "errored", return a new promise rejected
+  //         with stream@[[storedError]].
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 5: Perform ! ReadableStreamClose(stream).
+  ReadableStreamClose(stream);
+
+  // Step 6: Let sourceCancelPromise be
+  //         ! stream@[[readableStreamController]]@[[Cancel]](reason).
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  let sourceCancelPromise =
+    callFunction(ReadableStreamController_Cancel, controller, reason);
+
+  // Step 7: Return the result of transforming sourceCancelPromise by a
+  //         fulfillment handler that returns undefined.
+  return callFunction(Promise_then, sourceCancelPromise, () => undefined);
+}
+
+// Step 3.4.4. ReadableStreamClose ( stream )
+function ReadableStreamClose(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamClose() must operate on a ReadableStream");
+
+  // Step 1: Assert: stream@[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "ReadableStreamClose() must operate on readable ReadableStreams");
+
+  // Step 2: Set stream@[[state]] to "closed".
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_CLOSED_STATE);
+
+  // Step 3: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 4: If reader is undefined, return undefined.
+  if (reader === undefined) {
+    return;
+  }
+
+  // Step 5: If ! IsReadableStreamDefaultReader(reader) is true,
+  if (IsReadableStreamDefaultReader(reader)) {
+    // Step a: Repeat for each readRequest that is an element of
+    //         reader@[[readRequests]],
+    let readRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+    for (let i in readRequests) {
+      // Step i: Resolve readRequest.[[promise]] with
+      //         ! CreateIterResultObject(undefined, true).
+      let readRequest = readRequests[i];
+      callFunction(readRequest.deferred.resolve, readRequest.deferred.promise,
+                   { value: undefined, done: true });
+    }
+
+    // Step b: Set reader@[[readRequests]] to an empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 6: Resolve reader@[[closedPromise]] with undefined.
+  let closedDeferred =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED);
+  callFunction(closedDeferred.resolve, closedDeferred.promise, undefined);
+
+  // Step 7: Return undefined.
+  return;
+}
+
+// Streams spec, 3.4.5. ReadableStreamError ( stream, e )
+function ReadableStreamError(stream, e) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream),
+         "ReadableStreamError() must operate on a ReadableStream");
+
+  // Step 2: Assert: stream@[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "ReadableStreamError() must operate on readable ReadableStreams");
+
+  // Step 3: Set stream@[[state]] to "errored".
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_ERRORED_STATE);
+
+  // Step 4: Set stream@[[storedError]] to e.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT, e);
+
+  // Step 5: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 6: If reader is undefined, return undefined.
+  if (reader === undefined) {
+    return;
+  }
+
+  // Step 7: If ! IsReadableStreamDefaultReader(reader) is true,
+  if (IsReadableStreamDefaultReader(reader)) {
+    // Step a: Repeat for each readRequest that is an element of
+    //         reader@[[readRequests]],
+    let readRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+    for (let i in readRequests) {
+      // Step i: Reject readRequest.[[promise]] with e.
+      let readRequest = readRequests[i];
+      callFunction(readRequest.deferred.reject, readRequest.deferred.promise, e);
+    }
+
+    // Step b: Set reader@[[readRequests]] to a new empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 8: Otherwise,
+  else {
+    // Step a: Assert: ! IsReadableStreamBYOBReader(reader).
+    assert(IsReadableStreamBYOBReader(reader),
+           "Non-default reader must be a BYOB reader");
+
+    // Step b: Repeat for each readIntoRequest that is an element of
+    //         reader@[[readIntoRequests]],
+    let readIntoRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+    for (let i in readIntoRequests) {
+      // Step i: Reject readIntoRequest.[[promise]] with e.
+      let readIntoRequest = readIntoRequests[i];
+      callFunction(readIntoRequest.deferred.reject,
+                   readIntoRequest.deferred.promise, e);
+    }
+
+    // Step b: Set reader@[[readIntoRequests]] to a new empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 9: Reject reader@[[closedPromise]] with e.
+  let closedDeferred =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED);
+  callFunction(closedDeferred.reject, closedDeferred.promise, e);
+}
+
+// Streams spec, 3.4.6. ReadableStreamFulfillReadIntoRequest( stream, chunk, done )
+function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamFulfillReadIntoRequest() must operate on a " +
+         "ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetObjectFromReservedSlot(reader, READBLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamBYOBReader(reader),
+         "ReadableStreamFulfillReadIntoRequest() must operate on a " +
+         "ReadableStreamBYOBReader");
+
+  // Step 2: Let readIntoRequest be the first element of
+  //         reader@[[readIntoRequests]].
+  // Step 3: Remove readIntoRequest from reader@[[readIntoRequests]], shifting
+  //         all other elements downward (so that the second becomes the first,
+  //         and so on).
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  let readIntoRequest = ArrayStaticShift(readIntoRequests);
+
+  // Step 4: Resolve readIntoRequest.[[promise]] with
+  //         ! CreateIterResultObject(chunk, done).
+  callFunction(readIntoRequest.deferred.resolve,
+               readIntoRequest.deferred.promise, { value: chunk, done: done });
+}
+
+// Streams spec, 3.4.7. ReadableStreamFulfillReadRequest ( stream, chunk, done)
+function ReadableStreamFulfillReadRequest(stream, chunk, done) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamFulfillReadRequest() must operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetObjectFromReservedSlot(reader, READBLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamDefaultReader(reader),
+         "ReadableStreamFulfillReadRequest() must operate on a " +
+         "ReadableStreamDefaultReader");
+
+  // Step 2: Let readRequest be the first element of reader@[[readRequests]].
+  // Step 3: Remove readRequest from reader@[[readRequests]], shifting all other
+  //         elements downward (so that the second becomes the first, and so on).
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  let readRequest = ArrayStaticShift(readRequests);
+
+  // Step 4: Resolve readRequest.[[promise]] with
+  //         ! CreateIterResultObject(chunk, done).
+  callFunction(readRequest.deferred.resolve, readRequest.deferred.promise,
+               { value: chunk, done: done });
+}
+
+// Streams spec 3.4.8. ReadableStreamGetNumReadIntoRequests ( stream )
+function ReadableStreamGetNumReadIntoRequests(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamGetNumReadIntoRequests must " +
+                                   "operate on a ReadableStream");
+
+  let reader =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamBYOBReader(reader), "ReadableStreamGetNumReadIntoRequests " +
+                                             "must operate on a ReadableStreamBYOBReader");
+
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+
+  // Step 1: Return the number of elements in
+  //         stream@[[reader]]@[[readIntoRequests]].
+  return readIntoRequests.length;
+}
+
+// Streams spec 3.4.9. ReadableStreamGetNumReadRequests ( stream )
+function ReadableStreamGetNumReadRequests(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamGetNumReadRequests must " +
+                                   "operate on a ReadableStream");
+
+  let reader =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamDefaultReader(reader), "ReadableStreamGetNumReadRequests " +
+                                                "must operate on a ReadableStreamDefaultReader");
+
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+
+  // Step 1: Return the number of elements in
+  //         stream@[[reader]]@[[readRequests]].
+  return readRequests.length;
+}
+
+// Stream spec 3.4.10. ReadableStreamHasBYOBReader ( stream )
+function ReadableStreamHasBYOBReader(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamHasBYOBReader must " +
+                                   "operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 2: If reader is undefined, return false.
+  if (reader === undefined) {
+    return false;
+  }
+
+  // Step 3: If ! IsReadableStreamBYOBReader(reader) is false, return false.
+  // Step 4: Return true.
+  return IsReadableStreamBYOBReader(reader);
+}
+
+// Streap spec 3.4.11. ReadableStreamHasDefaultReader ( stream )
+function ReadableStreamHasDefaultReader(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamHasDefaultReader must " +
+                                   "operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 2: If reader is undefined, return false.
+  if (reader === undefined) {
+    return false;
+  }
+
+  // Step 3: If ! IsReadableStreamBYOBReader(reader) is false, return false.
+  // Step 4: Return true.
+  return IsReadableStreamDefaultReader(reader);
+}
+
+// Stream spec, 3.5.3. new ReadableStreamDefaultReader ( stream )
+function ReadableStreamDefaultReader(stream) {
+  if (!IsReadableStreamDefaultReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamDefaultReader", typeof stream);
+  }
+
+  // Step 2: If ! IsReadableStreamLocked(stream) is true, throw a TypeError
+  //         exception.
+  if (IsReadableStreamLocked(stream)) {
+    ThrowTypeError(JSMSG_READABLESTREAM_LOCKED, "getReader");
+  }
+
+  // Step 3: Perform ! ReadableStreamReaderGenericInitialize(this, stream).
+  ReadableStreamReaderGenericInitialize(this, stream);
+
+  // Step 4: Set this@[[readRequests]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                        new List());
+}
+
+// Streams spec, 3.5.4.1 get closed
+function ReadableStreamDefaultReader_closed() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "closed", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: Return this@[[closedPromise]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.5.4.2. cancel ( reason )
+function ReadableStreamDefaultReader_cancel(reason) {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "cancel", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED, "cancel");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamReaderGenericCancel(this, reason).
+  return ReadableStreamReaderGenericCancel(this, reason);
+}
+
+// Streams spec, 3.5.4.3 read ( )
+function ReadableStreamDefaultReader_read() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "read", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED, "read");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamDefaultReaderRead(this).
+  return ReadableStreamDefaultReaderRead(this);
+}
+
+// Streams spec, 3.5.4.4. releaseLock ( )
+function ReadableStreamDefaultReader_releaseLock() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                   "releaseLock", typeof this);
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return undefined.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return undefined;
+  }
+
+  // Step 3: If this@[[readRequests]] is not empty, throw a TypeError exception.
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  if (readRequests.length > 0) {
+    ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_EMPTY, "releaseLock");
+  }
+
+  // Step 4: Perform ! ReadableStreamReaderGenericRelease(this).
+  ReadableStreamReaderGenericRelease(this);
+}
+
+// Streams spec, 3.6.3 new ReadableStreamBYOBReader ( stream )
+function ReadableStreamBYOBReader(stream) {
+  if (!IsReadableStreamBYOBReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamBYOBReader", typeof stream);
+  }
+
+  // Step 2: If ! IsReadableStreamLocked(stream) is true, throw a TypeError
+  //         exception.
+  if (IsReadableStreamLocked(stream)) {
+    ThrowTypeError(JSMSG_READABLESTREAM_LOCKED, "getReader");
+  }
+
+  // Step 3: Perform ! ReadableStreamReaderGenericInitialize(this, stream).
+  ReadableStreamReaderGenericInitialize(this, stream);
+
+  // Step 4: Set this@[[readIntoRequests]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT,
+                        new List());
+}
+
+// Streams spec, 3.6.4.1 get closed
+function ReadableStreamBYOBReader_closed() {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "closed", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: Return this@[[closedPromise]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.6.4.2. cancel ( reason )
+function ReadableStreamBYOBReader_cancel(reason) {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "cancel", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      // TODO fix error name
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_OWNED, "cancel");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamReaderGenericCancel(this, reason).
+  return ReadableStreamReaderGenericCancel(this, reason);
+}
+
+// Streams spec, 3.6.4.3. read ( view )
+function ReadableStreamBYOBReader_read(view) {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "read", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      // TODO fix error name
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_OWNED, "read");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: If Type(view) is not Object, return a promise rejected with a
+  //         TypeError exception.
+  if (!IsObject(view)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "Object",
+                     "ReadableStreamBYOBReader.read", typeof view);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 4: If view does not have a [[ViewedArrayBuffer]] internal slot,
+  //         return a promise rejected with a TypeError exception.
+  if (!IsTypedArray(view)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "TypedArray",
+                     "ReadableStreamBYOBReader.read", typeof view);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 5: If view@[[ByteLength]] is 0, return a promise rejected with a
+  //         TypeError exception.
+  let buffer = ViewedArrayBufferIfReified(view);
+  if (ArrayBufferByteLength(buffer) === 0) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 6: Return ! ReadableStreamBYOBReaderRead(this, view).
+  return ReadableStreamBYOBReaderReader(this, view);
+}
+
+// Streams spec, 3.6.4.4. releaseLock ( )
+function ReadableStreamBYOBReader_releaseLock() {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                   "releaseLock", typeof this);
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return undefined.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return undefined;
+  }
+
+  // Step 3: If this@[[readIntoRequests]] is not empty, throw a TypeError
+  //         exception.
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  if (readRequests.length > 0) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_EMPTY, "releaseLock");
+  }
+
+  // Step 4: Perform ! ReadableStreamReaderGenericRelease(this).
+  ReadableStreamReaderGenericRelease(this);
+}
+
+// Streams spec, 3.7.1. IsReadableStreamDefaultReader ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamDefaultReader>()
+
+// Streams spec, 3.7.2. IsReadableStreamBYOBReader ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamBYOBReader>()
+
+// Streams spec, 3.7.3. ReadableStreamReaderGenericCancel ( reader, reason )
+function ReadableStreamReaderGenericCancel(reader, reason) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(stream !== undefined, "owning stream must be defined");
+
+  // Step 3: Return ! ReadableStreamCancel(stream, reason).
+  ReadableStreamCancel(stream, reason);
+}
+
+// Streams spec, 3.7.4. ReadableStreamReaderGenericInitialize ( reader, stream )
+function ReadableStreamReaderGenericInitialize(reader, stream) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+  assert(IsReadableStream(stream), "must be initializing with a ReadableStream");
+
+  // Step 1: Set reader@[[ownerReadableStream]] to stream.
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 2: Set stream@[[reader]] to reader.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, reader);
+
+  // Step 3: If stream@[[state]] is "readable",
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_READABLE_STATE) {
+    // Step a: Set reader@[[closedPromise]] to a new promise.
+    let deferred = CreateDeferred();
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
+  }
+
+  // Step 4: Otherwise
+  // Step a: If stream@[[state]] is "closed",
+  else if (state === READABLESTREAM_CLOSED_STATE) {
+    // Step i: Set reader@[[closedPromise]] to a new promise resolved with
+    //         undefined.
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      callFunction(Promise_static_resolve, GetPromiseCtor(), undefined));
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  }
+
+  // Step b: Otherwise,
+  else {
+    // Step i: Assert: stream@[[state]] is "errored".
+    assert(state === READABLESTREAM_ERRORED_STATE,
+           "must be errored if not readable or closed");
+
+    // Step ii: Set reader@[[closedPromise]] to a new promise rejected with
+    //          stream@[[storedError]].
+    let storedError = UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      callFunction(Promise_static_reject, GetPromiseCtor(), storedError));
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  }
+}
+
+// Streams spec, 3.7.5. ReadableStreamReaderGenericRelease ( reader )
+function ReadableStreamReaderGenericRelease(reader) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+
+  // Step 1: Assert: reader@[[ownerReadableStream]] is not undefined.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "reader should be owned by a ReadableStream");
+
+  // Step 2: Assert: reader@[[ownerReadableStream]]@[[reader]] is not undefined.
+  assert(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT) === reader,
+         "owning ReadableStream should reference the given reader");
+
+  try {
+    throwTypeError(JSMSG_READABLESTREAMREADER_RELEASED);
+  } catch(e) {
+    // Step 3: If reader@[[ownerReadableStream]]@[[state]] is "readable", reject
+    //         reader@[[closedPromise]] with a TypeError exception.
+    let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+    if (state === READABLESTREAM_READABLE_STATE) {
+        let closedDeferred =
+          UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+        callFunction(closedDeferred.reject, closedDeferred.promise, e);
+      }
+    }
+
+    // Step 4: Otherwise, set reader@[[closedPromise]] to a new promise rejected
+    //         with a TypeError exception.
+    else {
+      UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        callFunction(Promise_static_reject, GetPromiseCtor(), e));
+      UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+    }
+  }
+
+  // Step 5: Set reader@[[ownerReadableStream]]@[[reader]] to undefined.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, undefined);
+
+  // Step 6: Set reader@[[ownerReadableStream]] to undefined.
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT,
+                        undefined);
+}
+
+// Streams spec, 3.7.6. ReadableStreamBYOBReaderRead ( reader, view )
+function ReadableStreamBYOBReaderRead(reader, view) {
+  assert(IsReadableStreamBYOBReader(reader), "must be a byob reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(IsReadableStream(stream), "must be owned by a ReadableStream");
+
+  // Step 3: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 4: If stream@[[state]] is "errored", return a promise rejected with
+  //         stream@[[storedError]].
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 5: Return ! ReadableByteStreamControllerPullInto(stream@[[readableStreamController]], view).
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  return ReadableByteStreamControllerPullInto(controller, view);
+}
+
+// Streams spec, 3.7.7. ReadableStreamDefaultReaderRead ( reader )
+function ReadableStreamDefaultReaderRead(reader) {
+  assert(IsReadableStreamDefaultReader(reader), "must be a default reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(IsReadableStream(stream), "must be owned by a ReadableStream");
+
+  // Step 3: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 4: If stream@[[state]] is "closed", return a new promise resolved with
+  //         ! CreateIterResultObject(undefined, true).
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        { value: undefined, done: true });
+  }
+
+  // Step 5: If stream@[[state]] is "errored", return a new promise rejected with
+  //         stream@[[storedError]].
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 6: Assert: stream@[[state]] is "readable".
+  assert(state === READABLESTREAM_READABLE_STATE,
+         "mut be readable if not closed or errored");
+
+  // Step 7: Return ! stream@[[readableStreamController]]@[[Pull]]().
+  // TODO: is this the right way to call this?
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  callFunction(controller.pull, controller);
+}
+
+// Streams spec, 3.8.3 new ReadableStreamDefaultController ( stream, underlyingSource,
+//                                                           size, highWaterMark )
+function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamDefaultController", typeof stream);
+  }
+
+  // Step 2: If stream@[[readableStreamController]] is not undefined, throw a
+  //         TypeError exception.
+  let controller = UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  if (controller !== undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAM_CONTROLLER_SET);
+  }
+
+  // Step 3: Set this@[[controlledReadableStream]] to stream.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 4: Set this@[[underlyingSource]] to underlyingSource.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT,
+                        underlyingSource);
+
+  // Step 5: Set this@[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT, new List());
+
+  // Step 6: Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]],
+  //         and this@[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CLOSE_REQUESTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                        false);
+
+  // Step 7: Let normalizedStrategy be
+  //         ? ValidateAndNormalizeQueuingStrategy(size, highWaterMark).
+  let normalizedStrategy =
+    ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
+
+  // Step 8: Set this@[[strategySize]] to normalizedStrategy.[[size]] and
+  //         this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_SIZE_SLOT,
+                        normalizedStrategy.size);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_HWM_SLOT,
+                        normalizedStrategy.highWaterMark);
+
+  // Step 9: Let controller be this.
+  let controller = this;
+
+  // Step 10: Let startResult be
+  //          ? InvokeOrNoop(underlyingSource, "start", « this »).
+  let startResult = InvokeOrNoop(underlyingSource, "start", this);
+
+  // Step 11: Resolve startResult as a promise:
+  callFunction(Promise_then, startResult,
+    // Step a: Upon fulfillment,
+    () => {
+      // Step i: Set controller@[[started]] to true.
+      UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT,
+                            true);
+
+      // Step ii: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+    },
+
+    // Step b: Upon rejection with reason r,
+    r => {
+      // Step i: If stream@[[state]] is "readable", perform
+      //         ! ReadableStreamDefaultControllerError(controller, r).
+      let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableStreamDefaultControllerError(controller, r);
+      }
+    }
+  );
+}
+
+// Streams spec, 3.8.4.1. get desiredSize
+function ReadableStreamDefaultController_desiredSize() {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "desiredSize", typeof this);
+  }
+
+  // Step 2: Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
+  return ReadableStreamDefaultControllerGetDesiredSize(this);
+}
+
+// Streams spec, 3.8.4.2 close()
+function ReadableStreamDefaultController_close() {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this@[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "close");
+  }
+
+  // Step 3: If this@[[controlledReadableStream]]@[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "close");
+  }
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerClose(this).
+  ReadableStreamDefaultControlleClose(this);
+}
+
+// Streams spec, 3.8.4.3. enqueue ( chunk )
+function ReadableStreamDefaultController_enqueue(chunk) {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "enqueue", typeof this);
+  }
+
+  // Step 2: If this@[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "enqueue");
+  }
+
+  // Step 3: If this@[[controlledReadableStream]]@[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "enqueue");
+  }
+
+  // Step 4: Return ! ReadableStreamDefaultControllerEnqueue(this, chunk).
+  return ReadableStreamDefaultControllerEnqueue(this, chunk);
+}
+
+// Streams spec, 3.8.4.4. error ( e )
+function ReadableStreamDefaultController_error(e) {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "enqueue", typeof this);
+  }
+
+  // Step 2: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 3: If stream.[[state]] is not "readable", throw a TypeError exception.
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "error");
+  }
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerError(this, e).
+  ReadableStreamDefaultControllerError(this, e);
+}
+
+// Streams spec, 3.8.5.1. [[Cancel]] ( reason )
+function ReadableStreamDefaultController_cancel(reason) {
+  assert(IsReadableStreamDefaultController(this),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 2: Return ! PromiseInvokeOrNoop(this.[[underlyingSource]], "cancel", « reason »)
+  let underlyingSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT);
+  return PromiseInvokeOrNoop(underlyingSource, "cancel", reason);
+}
+
+// Streams spec, 3.8.5.2. [[Pull]] ( )
+function ReadableStreamDefaultController_pull() {
+  assert(IsReadableStreamDefaultController(this),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If this[[queue]] is not empty,
+  let queue =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  if (queue.length > 0) {
+    // Step a: Let chunk be ! DequeueValue(this.[[queue]]).
+    let chunk = DequeueValue(queue);
+
+    // Step b: If this.[[closeRequested]] is true and this.[[queue]] is empty,
+    //         perform ! ReadableStreamClose(stream).
+    let closeRequested =
+      UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+    if (closeRequested && queue.length === 0) {
+      ReadableStreamClose(stream);
+    }
+
+    // Step c: Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
+    else {
+      ReadableStreamDefaultControllerCallPullIfNeeded(this);
+    }
+
+    // Step d: Return a promise resolved with ! CreateIterResultObject(chunk, false).
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        { value: chunk, done: false });
+  }
+
+  // Step 3: Let pendingPromise be ! ReadableStreamAddReadRequest(stream).
+  let pendingPromise = ReadableStreamAddReadRequest(stream);
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
+  ReadableStreamDefaultControllerCallPullIfNeeded(this);
+
+  // Step 5: Return pendingPromise.
+  return pendingPromise;
+}
+
+// Streams spec, 3.9.1 IsReadableStreamDefaultController ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamDefaultController>()
+
+// Streams spec, 3.9.2 ReadableStreamDefaultControllerCallPullIfNeeded ( controller )
+function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
+  let shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
+
+  // Step 2: If shouldPull is false, return undefined.
+  if (!shouldPull) {
+    return undefined;
+  }
+
+  // Step 3: If controller.[[pulling]] is true,
+  let pulling =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT);
+  if (pulling) {
+    // Step a: Set controller.[[pullAgain]] to true.
+    UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                          true);
+
+    // Step b: Return undefined.
+    return undefined;
+  }
+
+  // Step 4: Set controller.[[pulling]] to true.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                        true);
+
+  // Step 5: Let pullPromise be
+  //         ! PromiseInvokeOrNoop(controller.[[underlyingSource]], "pull", « controller »).
+  let underlyingSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT);
+  let pullPromise = PromiseInvokeOrNoop(underlyingSource, "pull", controller);
+
+  // Step 6: Upon fulfillment of pullPromise,
+  callFunction(Promise_then, pullPromise, () => {
+    // Step a: Set controller.[[pulling]] to false.
+    UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                          false);
+
+    // Step b: If controller.[[pullAgain]] is true,
+    let pullAgain =
+      UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT);
+    if (pullAgain) {
+      // Step i: Set controller.[[pullAgain]] to false.
+      UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                            false);
+
+      // Step ii: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+    }
+  },
+
+  // Step 7: Upon rejection of pullPromise with reason e,
+  e => {
+    // Step a: If controller.[[controlledReadableStream]].[[state]] is "readable",
+    //         perform ! ReadableStreamDefaultControllerError(controller, e).
+    let stream =
+      UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+    assert(IsReadableStream(stream), "controller should have a ReadableStream");
+    let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+    if (state === READABLESTREAM_READABLE_STATE) {
+      ReadableStreamDefaultControllerError(controller, e);
+    }
+  });
+
+  // Step 8: Return undefined.
+  return undefined;
+}
+
+// Streams spec, 3.9.3. ReadableStreamDefaultControllerShouldCallPull ( controller )
+function ReadableStreamDefaultControllerShouldCallPull(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If stream.[[state]] is "closed" or stream.[[state]] is "errored",
+  //         return false.
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE ||
+      state === READABLESTREAM_ERRORED_STATE) {
+    return false;
+  }
+
+  // Step 3: If controller.[[closeRequested]] is true, return false.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    return false;
+  }
+
+  // Step 4: If controller.[[started]] is false, return false.
+  let started =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT);
+  if (!started) {
+    return false;
+  }
+
+  // Step 5: If ! IsReadableStreamLocked(stream) is true and
+  //         ! ReadableStreamGetNumReadRequests(stream) > 0, return true.
+  if (IsReadableStreamLocked(stream) &&
+      ReadableStreamGetNumReadRequests(stream) > 0) {
+    return true;
+  }
+
+  // Step 6: Let desiredSize be ReadableStreamDefaultControllerGetDesiredSize(controller).
+  let desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
+
+  // Step 7: If desiredSize > 0, return true.
+  // Step 8: Return false.
+  return desiredSize > 0;
+}
+
+// Streams spec, 3.9.4. ReadableStreamDefaultControllerClose ( controller )
+function ReadableStreamDefaultControllerClose(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT),
+         "controller should not have a pending close operation");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 4: Set controller.[[closeRequested]] to true.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT,
+                        true);
+
+  // Step 5: If controller.[[queue]] is empty, perform ! ReadableStreamClose(stream).
+  let queue =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  if (queue.length === 0) {
+    ReadableStreamClose(stream);
+  }
+}
+
+// Streams spec, 3.9.5. ReadableStreamDefaultControllerEnqueue ( controller, chunk )
+function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT),
+         "controller should not have a pending close operation");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 4: If ! IsReadableStreamLocked(stream) is true and
+  //         ! ReadableStreamGetNumReadRequests(stream) > 0, perform
+  //         ! ReadableStreamFulfillReadRequest(stream, chunk, false).
+  if (IsReadableStreamLocked(stream) &&
+      ReadableStreamGetNumReadRequests(stream) > 0) {
+    ReadableStreamFulfillReadRequest(stream, chunk, false);
+  }
+
+  // Step 5: Otherwise,
+  else {
+    // Step a: Let chunkSize be 1.
+    let chunkSize = 1;
+
+    // Step b: If controller.[[strategySize]] is not undefined,
+    let strategySize =
+      UnsafeGetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_SIZE_SLOT);
+    if (strategySize !== undefined) {
+      // Step i: Set chunkSize to Call(stream.[[strategySize]], undefined, « chunk »).
+      try {
+        let chunkSize = callContentFunction(strategySize, undefined, chunk);
+      }
+
+      // Step ii: If chunkSize is an abrupt completion,
+      // The only abrupt completion possible in Call() is a thrown exception.
+      catch(e) {
+        // Step 1: If stream.[[state]] is "readable", perform
+        //         ! ReadableStreamDefaultControllerError(controller, chunkSize.[[Value]]).
+        let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+        if (state === READABLESTREAM_READABLE_STATE) {
+          ReadableStreamDefaultControllerError(controller, e);
+        }
+
+        // Step 2: Return chunkSize.
+        // Here chunkSize has an abrupt completion from a thrown exception.
+        throw(e);
+      }
+    }
+
+    // Step c: Let enqueueResult be
+    //         ! EnqueueValueWithSize(controller.[[queue]], chunk, chunkSize).
+    let queue =
+      UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+
+    try {
+      EnqueueValueWithSize(queue, chunk, chunkSize);
+    }
+
+    // Step d: If enqueueResult is an abrupt completion,
+    // The only abrupt completion possible in EnqueueValueWithSize() is a thrown
+    // exception.
+    catch(e) {
+      // Step i: If stream.[[state]] is "readable", perform
+      //         ! ReadableStreamDefaultControllerError(controller, enqueueResult.[[Value]]).
+      let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableStreamDefaultControllerError(controller, e);
+      }
+
+      // Step ii: Return enqueueResult.
+      // Here enqueueResult has an abrupt completion from a thrown exception.
+      throw (e);
+    }
+  }
+
+  // Step 6: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+
+  // Step 7: Return undefined.
+  return undefined;
+}
+
+// Streams spec, 3.9.6. ReadableStreamDefaultControllerError ( controller, e )
+function ReadableStreamDefaultControllerError(controller, e) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 3: Set controller.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 4: Perform ! ReadableStreamError(stream, e).
+  ReadableStreamError(stream, e);
+}
+
+// Streams spec, 3.9.7. ReadableStreamDefaultControllerGetDesiredSize ( controller )
+function ReadableStreamDefaultControllerGetDesiredSize(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let queueSize be ! GetTotalQueueSize(controller.[[queue]]).
+  let queue =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  let queueSize = GetTotalQueueSize(queue);
+
+  // Step 2: Return controller.[[strategyHWM]] − queueSize.
+  let strategyHWM =
+    UnsafeGetInt32ReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_HWM_SLOT);
+  return strategyHWM - queueSize;
+}
+
+// Streams spec, 3.10.3. new ReadableByteStreamController ( stream, underlyingByteSource, highWaterMark )
+function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableByteStreamController", typeof this);
+  }
+
+  // Step 2: If stream.[[readableStreamController]] is not undefined, throw a
+  //         TypeError exception.
+  let controller = UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  if (controller !== undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAM_CONTROLLER_SET);
+  }
+
+  // Step 3: Set this.[[controlledReadableStream]] to stream.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 4: Set this.[[underlyingByteSource]] to underlyingByteSource.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_UNDERLYING_BYTE_SOURCE_SLOT,
+                        underlyingByteSource);
+
+  // Step 5: Set this.[[pullAgain]], and this.[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT,
+                        false);
+
+  // Step 6: Perform ! ReadableByteStreamControllerClearPendingPullIntos(this).
+  ReadableByteStreamControllerClearPendingPullIntos(this);
+
+  // Step 7: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 8: Set this.[[totalQueuedBytes]] to 0.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                        0);
+
+  // Step 9: Set this.[[started]], and this.[[closeRequested]] to false.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_STARTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT,
+                        false);
+
+  // Step 10: Set this.[[strategyHWM]] to
+  //          ? ValidateAndNormalizeHighWaterMark(highWaterMark).
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_STRATEGY_HWM_SLOT,
+                        ValidateAndNormalizeHighWaterMark(highWaterMark));
+
+  // Step 11: Let autoAllocateChunkSize be
+  //          ? GetV(underlyingByteSource, "autoAllocateChunkSize").
+  let autoAllocateChunksize = underlyingByteSource.autoAllocateChunkSize;
+
+  // Step 12: If autoAllocateChunkSize is not undefined,
+  if (autoAllocateChunkSize !== undefined) {
+    // Step a: Set autoAllocateChunkSize to ? ToInteger(autoAllocateChunkSize).
+    autoAllocateChunkSize = ToInteger(autoAllocateChunkSize);
+
+    // Step b: If autoAllocateChunkSize ≤ 0, or if autoAllocateChunkSize is
+    //         +infinity or −infinity, throw a RangeError exception.
+    if (autoAllocateChunkSize <= 0 || !Number_isFinite(autoAllocateChunkSize)) {
+      ThrowRangeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE);
+    }
+  }
+
+  // Step 13: Set this.[[autoAllocateChunkSize]] to autoAllocateChunkSize.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT,
+                        autoAllocateChunkSize);
+
+  // Step 14: Set this.[[pendingPullIntos]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT,
+                        new List());
+
+  // Step 15: Let controller be this.
+  let controller = this;
+
+  // Step 16: Let startResult be ? InvokeOrNoop(underlyingByteSource, "start", « this »).
+  let startResult = InvokeOrNoop(underlyingByteSource, "start", this);
+
+  // Step 17: Resolve startResult as a promise:
+  callFunction(Promise_then, startResult,
+    // Step a: Upon fulfillment,
+    () => {
+      // Step i: Set controller.[[started]] to true.
+      UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_STARTED_SLOT,
+                            true);
+
+      // Step ii: Assert: controller.[[pulling]] is false.
+      assert(!UnsafeGetBooleanReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT),
+             "should not be pulling after start promise resolves");
+
+      // Step iii: Assert: controller.[[pullAgain]] is false.
+      assert(!UnsafeGetBooleanReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT),
+             "should not need to pull again after start promise resolves");
+
+      // Step iv: Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
+      ReadableByteStreamControllerCallPullIfNeeded(controller);
+    },
+
+    // Step b: Upon rejection with reason r,
+    r => {
+      // Step i: If stream.[[state]] is "readable", perform
+      //         ! ReadableByteStreamControllerError(controller, r).
+      let state = UnsafeGetInt32ReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableByteStreamControllerError(controller, r);
+      }
+    }
+  );
+}
+
+// Streams spec, 3.10.4.1. get byobRequest
+function ReadableByteStreamController_byobRequest() {
+  // Step 1: If IsReadableByteStreamController(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "byobRequest", typeof this);
+  }
+
+  // Step 2: If this.[[byobRequest]] is undefined and this.[[pendingPullIntos]]
+  //         is not empty,
+  let byobRequest =
+    UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT);
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (byobRequest === undefined && pendingPullIntos.length > 0) {
+    // Step a: Let firstDescriptor be the first element of this.[[pendingPullIntos]].
+    let firstDescriptor = pendingPullIntos[0];
+
+    // Step b: Let view be ! Construct(%Uint8Array%,
+    //  « firstDescriptor.[[buffer]],
+    //  firstDescriptor.[[byteOffset]] + firstDescriptor.[[bytesFilled]],
+    //  firstDescriptor.[[byteLength]] − firstDescriptor.[[bytesFilled]] »).
+    let view = new Uint8Array(firstDescriptor.buffer,
+                              firstDestriptor.byteOffset + firstDescriptor.bytesFilled,
+                              firstDestriptor.byteLength + firstDescriptor.bytesFilled);
+
+    // Step c: Set this.[[byobRequest]] to
+    //         ! Construct(ReadableStreamBYOBRequest, « this, view »).
+    let ReadableStreamBYOBRequestCtor = GetReadableStreamBYOBRequestCtor();
+    byobRequest = new ReadableStreamBYOBRequestCtor(this, view));
+    UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT,
+                          byobRequest);
+  }
+
+  // Step 3: Return this.[[byobRequest]].
+  return byobRequest;
+}
+
+// Streams spec, 3.10.4.2. get desiredSize
+function ReadableByteStreamController_desiredSize() {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "desiredSize", typeof this);
+  }
+
+  // Step 2: Return ! ReadableByteStreamControllerGetDesiredSize(this).
+  return ReadableByteStreamControllerGetDesiredSize(this);
+}
+
+// Streams spec, 3.10.4.3. close()
+function ReadableByteStreamController_close() {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this.[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "close");
+  }
+
+  // Step 3: If this.[[controlledReadableStream]].[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "close");
+  }
+
+  // Step 4: Perform ? ReadableByteStreamControllerClose(this).
+  ReadableByteStreamControllerClose(this);
+}
+
+// Streams spec, 3.10.4.4. enqueue ( chunk )
+function ReadableByteStreamController_enqueue(chunk) {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this.[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "enqueue");
+  }
+
+  // Step 3: If this.[[controlledReadableStream]].[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "enqueue");
+  }
+
+  // Step 4: If Type(chunk) is not Object, throw a TypeError exception.
+  if (!IsObject(chunk)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 5: If chunk does not have a [[ViewedArrayBuffer]] internal slot,
+  //         throw a TypeError exception.
+  if (!IsTypedArray(chunk)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 6: Return ! ReadableByteStreamControllerEnqueue(this, chunk).
+  return ReadableByteStreamControllerEnqueue(this, chunk);
+}
+
+// Streams spec, 3.10.4.5. error ( e )
+function ReadableByteStreamController_error(e) {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 3: If stream.[[state]] is not "readable", throw a TypeError exception.
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "error");
+  }
+
+  // Step 4: Perform ! ReadableByteStreamControllerError(this, e).
+  ReadableByteStreamControllerError(this, e);
+}
+
+// Streams spec, 3.10.5.1. [[Cancel]] ( reason )
+function ReadableByteStreamController_cancel(reason) {
+  assert(IsReadableByteStreamController(this),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: If this.[[pendingPullIntos]] is not empty,
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (pendingPullIntos.length > 0) {
+    // Step a: Let firstDescriptor be the first element of
+    //         this.[[pendingPullIntos]].
+    // Step b: Set firstDescriptor.[[bytesFilled]] to 0.
+    pendingPullIntos[0].bytesFilled = 0;
+  }
+
+  // Step 2: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 3: Set this.[[totalQueuedBytes]] to 0.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                        0);
+
+  // Step 4: Return ! PromiseInvokeOrNoop(this.[[underlyingByteSource]], "cancel", « reason »)
+  let underlyingByteSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_UNDERLYING_BYTE_SOURCE_SLOT);
+  return PromiseInvokeOrNoop(underlyingByteSource, "cancel", reason);
+}
+
+// Streams spec, 3.10.5.2. [[Pull]] ( )
+function ReadableByteStreamController_pull() {
+  assert(IsReadableByteStreamController(this),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If ! ReadableStreamGetNumReadRequests(stream) is 0,
+  if (ReadableStreamGetNumReadRequests(stream) === 0) {
+    // Step a: If this[[totalQueuedBytes]] > 0,
+    let totalQueuedBytes =
+        UnsafeGetInt32FromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+    if (totalQueuedBytes > 0) {
+      // Step i: Let entry be the first element of this.[[queue]].
+      // Step ii: Remove entry from this.[[queue]], shifting all other elements
+      //          downward (so that the second becomes the first, and so on).
+      let queue = UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT);
+      let entry = ArrayStaticShift(queue);
+
+      // Step iii: Set this.[[totalQueuedBytes]] to this.[[totalQueuedBytes]] −
+      //           entry.[[byteLength]].
+      totalQueuedBytes = totalQueuedBytes - entry.byteLength;
+      UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                            totalQueuedBytes);
+
+      // Step iv: Perform ! ReadableByteStreamControllerHandleQueueDrain(this).
+      ReadableByteStreamControllerHandleQueueDrain(this);
+
+      // Step v: Let view be
+      //         ! Construct(%Uint8Array%, « entry.[[buffer]],
+      //                     entry.[[byteOffset]], entry.[[byteLength]] »).
+      let view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
+
+      // Step vi: Return a promise resolved with ! CreateIterResultObject(view, false).
+      return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                          { value: view, done: false });
+    }
+
+    // Step b: Let autoAllocateChunkSize be this.[[autoAllocateChunkSize]].
+    let autoAllocateChunkSize =
+      UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT);
+
+    // Step c: If autoAllocateChunkSize is not undefined,
+    if (autoAllocateChunkSize !== undefined) {
+      // Step i: Let buffer be Construct(%ArrayBuffer%, « autoAllocateChunkSize »).
+      let buffer;
+      try {
+        buffer = new ArrayBuffer(autoAllocateChunkSize);
+      }
+
+      // Step ii: If buffer is an abrupt completion, return a promise rejected
+      //          with buffer.[[Value]].
+      catch (e) {
+        return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+      }
+
+      // Step iii: Let pullIntoDescriptor be Record {[[buffer]]: buffer.[[Value]],
+      //                                             [[byteOffset]]: 0,
+      //                                             [[byteLength]]: autoAllocateChunkSize,
+      //                                             [[bytesFilled]]: 0,
+      //                                             [[elementSize]]: 1,
+      //                                             [[ctor]]: %Uint8Array%,
+      //                                             [[readerType]]: "default"}.
+      let pullIntoDescriptor = new Record();
+      pullIntoDescriptor.buffer = buffer;
+      pullIntoDescriptor.byteOffset = 0;
+      pullIntoDescriptor.byteLength = autoAllocateChunkSize;
+      pullIntoDescriptor.bytesFilled = 0;
+      pullIntoDescriptor.elementsSize = 1;
+      pullIntoDescriptor.ctor = Uin8Array;
+      pullIntoDescriptor.readerType = "default";
+
+      // Step iv: Append pullIntoDescriptor as the last element of
+      //          this.[[pendingPullIntos]].
+      let pendingPullIntos =
+        UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+      ArrayStaticPush(pendingPullIntos, pullIntoDescriptor);
+    }
+  }
+
+  // Step 3: Otherwise,
+  else {
+    // Step a: Assert: this.[[autoAllocateChunkSize]] is undefined.
+    assert(UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT) === undefined,
+           "autoAllocateChunkSize should not be defined");
+  }
+
+  // Step 4: Let promise be ! ReadableStreamAddReadRequest(stream).
+  let promise = ReadableStreamAddReadRequest(stream);
+
+  // Step 5: Perform ! ReadableByteStreamControllerCallPullIfNeeded(this).
+  ReadableByteStreamControllerCallPullIfNeeded(this);
+
+  // Step 6: Return promise.
+  return promise;
+}
+
+// Streams spec, 3.11.3. new ReadableStreamBYOBRequest ( controller, view )
+function ReadableStreamBYOBRequest(controller, view) {
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "ctor", typeof this);
+  }
+
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  assert(IsObject(view), "view should be an object");
+
+  // Step 1: Set this.[[associatedReadableByteStreamController]] to controller.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT,
+                        controller);
+
+  // Step 2: Set this.[[view]] to view.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREQUEST_VIEW_SLOT, view);
+}
+
+// Streams spec, 3.11.4.1 get view
+function ReadableStreamBYOBRequest_view() {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "view", typeof this);
+  }
+
+  // Step 2: Return this.[[view]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREQUEST_VIEW_SLOT);
+}
+
+// Streams spec, 3.11.4.2. respond ( bytesWritten )
+function ReadableStreamBYOBRequest_respond(bytesWritten) {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "view", typeof this);
+  }
+
+  // Step 2: If this.[[associatedReadableByteStreamController]] is undefined,
+  //         throw a TypeError exception.
+  let controller =
+    UnsafeGetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT);
+  if (controller === undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER, "respond");
+  }
+
+  // Step 3: Return ? ReadableByteStreamControllerRespond(this.[[associatedReadableByteStreamController]],
+  //                                                      bytesWritten).
+  return ReadableByteStreamControllerRespond(controller, bytesWritten);
+}
+
+// Streams spec, 3.11.4.3. respondWithNewView ( view )
+function ReadableStreamBYOBRequest_respondWithNewView(view) {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "respondWithView", typeof this);
+  }
+
+  // Step 2: If this.[[associatedReadableByteStreamController]] is undefined,
+  //         throw a TypeError exception.
+  let controller =
+    UnsafeGetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT);
+  if (controller === undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER, "respond");
+  }
+
+  // Step 3: If Type(chunk) is not Object, throw a TypeError exception.
+  // Step 4: If view does not have a [[ViewedArrayBuffer]] internal slot, throw
+  //         a TypeError exception.
+  if (!IsTypedArray(view)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 5: Return ? ReadableByteStreamControllerRespondWithNewView(this.[[associatedReadableByteStreamController]],
+  //                                                                 view).
+  return ReadableByteStreamControllerRespondWithNewView(controller, view);
+}
+
+// Streams spec, 3.12.1 IsReadableStreamBYOBRequest ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamBYOBRequest>()
+
+// Streams spec, 3.12.2. IsReadableByteStreamController ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableByteStreamController>()
+
+// TODO: continue here
 
 // Streams spec, 3.3.1. Class Definition
 function ReadableStreamController(stream) {
   if (!IsObject(this) || !IsReadableStreamController(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
   }
   if (!IsObject(this) || !IsReadableStream(stream)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ReadableStreamController", typeof stream);
@@ -425,22 +2543,16 @@ function FinishClosingReadableStream(str
 // Streams spec, 3.5.7. GetReadableStreamDesiredSize ( stream )
 function GetReadableStreamDesiredSize(stream) {
   let queueSize = GetTotalQueueSize(
     UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT));
   let streamHWM = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_HWM_SLOT);
   return streamHWM - queueSize;
 }
 
-// Streams spec, 3.5.11. IsReadableStreamLocked ( stream )
-function IsReadableStreamLocked(stream) {
-  assert(IsReadableStream(stream), "IsReadableStream(stream)");
-  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
-}
-
 // Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
 function ReadFromReadableStreamReader(reader) {
   let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
   let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
   if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
     return callFunction(Promise_static_resolve, GetPromiseCtor(), CreateIterResultObject(undefined, true));
@@ -516,21 +2628,16 @@ function ShouldReadableStreamPull(stream
     if (readerReadRequests.length !== 0) {
       return true;
     }
   }
   let desiredSize = GetReadableStreamDesiredSize(stream);
   return desiredSize > 0;
 }
 
-// Streams spec, 3.5.16. TeeReadableStream ( stream, shouldClone )
-function TeeReadableStream(stream, shouldClone) {
-  ThrowSomething("Error", "Not implemented TeeReadableStream");
-}
-
 // Streams spec, 6.3.1. DequeueValue ( queue )
 function DequeueValue(queue) {
   var pair = callFunction(std_Array_shift, queue);
   return pair.value;
 }
 
 // Streams spec, 6.3.2. EnqueueValueWithSize ( queue, value, size )
 function EnqueueValueWithSize(queue, value, size) {
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -80,29 +80,21 @@
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
 #define PROMISE_REJECTION_TRACKER_OPERATION_REJECT false
 #define PROMISE_REJECTION_TRACKER_OPERATION_HANDLE true
 
 // Used for ReadableStream.
-#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
-#define READABLESTREAM_CONTROLLER_SLOT 1
-#define READABLESTREAM_DISTURBED_SLOT 2
-#define READABLESTREAM_PULL_AGAIN_SLOT 3
-#define READABLESTREAM_PULLING_SLOT 4
-#define READABLESTREAM_QUEUE_SLOT 5
-#define READABLESTREAM_READER_SLOT 6
-#define READABLESTREAM_STARTED_SLOT 7
-#define READABLESTREAM_STATE_SLOT 8
-#define READABLESTREAM_STORED_ERROR_SLOT 9
-#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
-#define READABLESTREAM_STRATEGY_HWM_SLOT 11
-#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+#define READABLESTREAM_CONTROLLER_SLOT 0
+#define READABLESTREAM_DISTURBED_SLOT 1
+#define READABLESTREAM_READER_SLOT 2
+#define READABLESTREAM_STATE_SLOT 3
+#define READABLESTREAM_STORED_ERROR_SLOT 4
 
 #define READABLESTREAM_READABLE_STATE 0
 #define READABLESTREAM_CLOSED_STATE 1
 #define READABLESTREAM_ERRORED_STATE 2
 
 #define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
 
 #define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
diff --git a/js/src/js.msg b/js/src/js.msg
--- a/js/src/js.msg
+++ b/js/src/js.msg
@@ -533,8 +533,23 @@ MSG_DEF(JSMSG_MISSING_NAMESPACE_EXPORT, 
 MSG_DEF(JSMSG_MISSING_EXPORT,            1, JSEXN_SYNTAXERR, "local binding for export '{0}' not found")
 
 // Promise
 MSG_DEF(JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF,       0, JSEXN_TYPEERR, "A promise cannot be resolved with itself.")
 MSG_DEF(JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY, 0, JSEXN_TYPEERR, "GetCapabilitiesExecutor function already invoked with non-undefined values.")
 MSG_DEF(JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE,    0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the resolve function.")
 MSG_DEF(JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE,     0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the reject function.")
 MSG_DEF(JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON,0, JSEXN_INTERNALERR, "Promise rejection value is a non-unwrappable cross-compartment wrapper.")
+
+// ReadableStream
+MSG_DEF(JSMSG_READABLESTREAM_NOT_LOCKED,                 1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on a locked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_LOCKED,                     1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on an unlocked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER, 0, JSEXN_TYPEERR, "ReadableStream.getReader('byob') requires a ReadableByteStreamController.")
+MSG_DEF(JSMSG_READABLESTREAM_CONTROLLER_SET,             0, JSEXN_TYPEERR, "The ReadableStream already has a controller defined.")
+MSG_DEF(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED,     1, JSEXN_TYPEERR, "ReadableStreamDefaultReader method '{0}' may only be called on a reader owned by a stream.")
+MSG_DEF(JSMSG_READABLESTREAMDEFAULTREADER_NOT_EMPTY,     1, JSEXN_TYPEERR, "ReadableStreamDefaultReader method '{0}' may not be called on a reader with read requests.")
+MSG_DEF(JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW,  0, JSEXN_TYPEERR, "ReadableStreamBYOBReader.read() was passed an empty TypedArrayBuffer view.")
+MSG_DEF(JSMSG_READABLESTREAMREADER_RELEASED,             0, JSEXN_TYPEERR, "The ReadableStream reader was released.")
+MSG_DEF(JSMSG_READABLESTREAMCONTROLLER_CLOSED,           1, JSEXN_TYPEERR, "The ReadableStream controller method '{0}' called on a stream already closing.")
+MSG_DEF(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE,     1, JSEXN_TYPEERR, "The ReadableStream controller method '{0}' may only be called on a stream in the 'readable' state.")
+MSG_DEF(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE,0, JSEXN_RANGEERR, "ReadableByteStreamController requires a positive integer or undefined for 'autoAllocateChunkSize'.")
+MSG_DEF(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK,    0, JSEXN_TYPEERR, "ReadableByteStreamController passed a bad chunk.")
+MSG_DEF(JSMSG_READABLESTREAMBYOBREADER_NO_CONTROLLER,    1, JSEXN_TYPEERR, "ReadableStreamBYOBRequest method '{0}' called on a request with no controller.")
