# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  27374ac7b0026fe4f0d7b7dbc92244072dcb7b39
Bug 1272697 P3 Update to latest ReadableStream spec. r=till

diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
--- a/js/src/builtin/ReadableStream.h
+++ b/js/src/builtin/ReadableStream.h
@@ -11,17 +11,17 @@
 
 namespace js {
 
 class AutoSetNewObjectMetadata;
 
 class ReadableStream : public NativeObject
 {
   public:
-    static const unsigned RESERVED_SLOTS = 13;
+    static const unsigned RESERVED_SLOTS = 5;
     static const ClassSpec classSpec_;
     static const Class class_;
     static const ClassSpec protoClassSpec_;
     static const Class protoClass_;
 };
 
 class ReadableStreamController : public NativeObject
 {
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -1,129 +1,3284 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Streams spec, 3.2.3.
-function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+function ReadableStream(underlyingSource = {}, {size, highWaterMark} = {}) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
   }
-  if (underlyingSource === undefined) {
-    underlyingSource = {};
-  }
-  if (highWaterMark === undefined) {
-    highWaterMark = 1;
-  }
-
-  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
-  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
-  // Step 2. Set this@[[queue]] to a new empty List.
-  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
-  // Step 3. Set this@[[state]] to "readable".
-  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
-  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
-  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
+
+  // Step 1: Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_READABLE_STATE);
+  // Step 2: Set this@[[reader]] and this@[[storedError]] to undefined.
   UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
   UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
-  // Step 6. Set this@[[disturbed]] to false.
+  // Step 3: Set this@[[disturbed]] to false.
   UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
-  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
-  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
-  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
-
-  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
-  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
-  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
-  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
-  // Step 11. ReturnIfAbrupt(startResult).
-  let startResult = InvokeOrNoop(underlyingSource, "start",
-    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
-  // Step 12. Resolve startResult as a promise:
-  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
-  callFunction(Promise_then, p, () => {
-this._log += 'resolved ' + startResult;
-    // Set this@[[started]] to true.
-    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
-    // Perform RequestReadableStreamPull(this).
-    RequestReadableStreamPull(this);
-  }, (r) => {
-    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
-    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
-      ErrorReadableStream(this, r);
+  // Step 4: Set this@[[readableStreamController]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, undefined);
+
+  // Step 5: Let type be ? GetV(underlyingSource, "type").
+  // Step 6: Let typeString be ? ToString(type).
+  // Step 7: If typeString is "bytes",
+  if (underlyingSource.type === "bytes") {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 0.
+    if (highWaterMark === undefined) {
+      highWaterMark = 0;
     }
-  });
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
+    let ReadableByteStreamControllerCtor = GetReadableByteStreamControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableByteStreamControllerCtor(this,
+                                                               underlyingSource,
+                                                               highWaterMark));
+  }
+
+  // Step 8: Otherwise, if type is undefined,
+  else if (underlyingSource.type === undefined) {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 1.
+    if (highWaterMark === undefined) {
+      highWaterMark = 1;
+    }
+
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
+    let ReadableStreamDefaultControllerCtor = GetReadableStreamDefaultControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableStreamDefaultControllerCtor(this,
+                                                                  underlyingSource,
+                                                                  size,
+                                                                  highWaterMark));
+  }
+
+  // Step 9: Otherwise, throw a RangeError exception.
+  else {
+    ThrowSomething("RangeError",
+                   "underlyingSource.type must be 'bytes' or undefined");
+  }
 }
 
+// TODO: implement new controller classes
+
 // Streams spec, 3.2.4.1. get locked
 function ReadableStream_locked() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked",
+                   typeof this);
   }
 
+  // Step 2: Return ! IsReadableStreamLocked(this).
   return IsReadableStreamLocked(this);
 }
 
-// Streams spec, 3.2.4.2. cancel(reason)
+// Streams spec, 3.2.4.2. cancel ( reason )
 function ReadableStream_cancel(reason) {
+  // Step 1: If ! IsReadableStream(this) is false, return a promise rejected
+  //         with a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
     try {
-      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel",
+                     typeof this);
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 2: If ! IsReadableStreamLocked(this) is true, return a promise
+  //         rejected with a TypeError exception.
   if (IsReadableStreamLocked(this)) {
     try {
-      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_LOCKED, "cancel");
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 3: Return ! ReadableStreamCancel(this, reason).
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
-function ReadableStream_getReader() {
+function ReadableStream_getReader({ mode } = {}) {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader",
+                   typeof this);
   }
 
-  return AcquireReadableStreamReader(this);
+  // Step 2: If mode is "byob",
+  if (mode === "byob") {
+    // Step a: If ! IsReadableByteStreamController(this@[[readableStreamController]])
+    //         is false, throw a TypeError exception.
+    let controller = UnsafeGetObjectReservedSlot(this,
+                                                 READABLESTREAM_CONTROLLER_SLOT);
+    if (!IsReadableByteStreamController(controller)) {
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER);
+    }
+    // Step b: Return ? AcquireReadableStreamBYOBReader(this).
+    return AcquireReadableStreamBYOBReader(this);
+  }
+
+  // Step 3: If mode is undefined, return
+  //         ? AcquireReadableStreamDefaultReader(this).
+  if (mode === undefined) {
+    return AcquireReadableStreamDefaultReader(this);
+  }
+
+  ThrowSomething("RangeError", "mode must be 'byob' or undefined");
 }
 
 // Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
-function ReadableStream_pipeThrough({ writable, readable }, options) {
-  ReadableStream_pipeTo.call(this, writable, options);
-  return readable;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
-function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
-  return null;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.6. tee()
 function ReadableStream_tee() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee",
+                   typeof this);
   }
 
-  let branches = TeeReadableStream(this, false);
-  return branches;
+  // Step 2: Let branches be ? ReadableStreamTee(this, false).
+  let branches = ReadableStreamTee(this, false);
+
+  // Step 3: Return ! CreateArrayFromList(branches).
+  assert(branches.length == 2, "ReadableStreamTee() must return two branches.");
+  return [ branches[0], branches[1] ];
 }
 
+// Streams spec, 3.3.1. AcquireReadableStreamBYOBReader ( stream )
+function AcquireReadableStreamBYOBReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamBYOBReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamBYOBReaderCtor();
+  return new ReadableStreamBYOBReaderCtor(stream);
+}
+
+// Streams spec, 3.3.2. AcquireReadableStreamDefaultReader ( stream )
+function AcquireReadableStreamDefaultReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamDefaultReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamDefaultReaderCtor();
+  return new ReadableStreamDefaultReaderCtor(stream);
+}
+
+// Streams spec, 3.3.3. IsReadableStream ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStream>()
+
+// Streams spec, 3.3.4. IsReadableStreamDisturbed ( stream )
+function IsReadableStreamDisturbed(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStreamController(this), "IsReadableStream(stream)");
+
+  // Step 2: Return stream@[[disturbed]].
+  return UnsafeGetBooleanReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT);
+}
+
+// Streams spec, 3.3.5. IsReadableStreamLocked ( stream )
+function IsReadableStreamLocked(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: If stream@[[reader]] is undefined, return false.
+  // Step 3: Return true.
+  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
+}
+
+// Streams spec, 3.3.6. ReadableStreamTee ( stream, shouldClone )
+// TODO: This could be re-designed to use a class instead of closures
+function ReadableStreamTee(stream, shouldClone) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: Assert: Type(shouldClone) is Boolean.
+  assert(typeof shouldClone === 'boolean', "Type(shouldClone) is Boolean");
+
+  // Step 3: Let reader be ? AcquireReadableStreamDefaultReader(stream).
+  let reader = AcquireReadableStreamDefaultReader(stream);
+
+  // Step 4: Let teeState be Record {[[closedOrErrored]]: false, [[canceled1]]: false, [[canceled2]]: false, [[reason1]]: undefined, [[reason2]]: undefined, [[promise]]: a new promise}.
+  let teeState = new Record();
+  teeState.closedOrErrored = false;
+  teeState.canceled1 = false;
+  teeState.canceled2 = false;
+  teeState.reason1 = undefined;
+  teeState.reason2 = undefined;
+  teeState.deferred = CreateDeferred();
+
+  // Step 5: Let pull be a new ReadableStreamTee pull function.
+  // Step 6: Set pull@[[reader]] to reader, pull@[[teeState]] to teeState, and
+  //         pull@[[shouldClone]] to shouldClone.
+  let pull = () => {
+    // ReadableStreamTee pull function
+    // Step 1: Let reader be F@[[reader]], branch1 be F@[[branch1]],
+    //         branch2 be F@[[branch2]], teeState be F@[[teeState]], and
+    //         shouldClone be F@[[shouldClone]].
+    // Implemented via closure.
+    let branch1 = UnsafeGetObjectFromReservedSlot(branch1Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+    let branch2 = UnsafeGetObjectFromReservedSlot(branch2Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+
+    // Step 2: Return the result of transforming
+    //         ! ReadableStreamDefaultReaderRead(reader) by a fulfillment
+    //         handler which takes the argument result and performs the
+    //         following steps:
+    let readPromise = ReadableStreamDefaultReaderRead(stream);
+    callFunction(Promise_then, readPromise, result => {
+      // Step a: Assert: Type(result) is Object.
+      assert(IsObject(result), "Read result should be an object");
+
+      // Step b: Let value be ? Get(result, "value").
+      let value = result.value;
+
+      // Step c: Let done be ? Get(result, "done").
+      let done = result.done;
+
+      // Step d: Assert: Type(done) is Boolean.
+      assert(typeof done === 'boolean', "Read result.done should be a boolean");
+
+      // Step e: If done is true and teeState.[[closedOrErrored]] is false,
+      if (done && !teeState.closedOrErrored) {
+        // Step i: If teeState.[[canceled1]] is false,
+        if (!teeState.canceled1) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch1).
+          ReadableStreamDefaultControllerClose(branch1);
+        }
+
+        // Step ii: If teeState.[[canceled2]] is false,
+        if (!teeState.canceled2) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch2).
+          ReadableStreamDefaultControllerClose(branch2);
+        }
+
+        // Step iii: Set teeState.[[closedOrErrored]] to true.
+        teeState.closedOrErrored = true;
+      }
+
+      // Step f: If teeState.[[closedOrErrored]] is true, return undefined.
+      if (teeState.closedOrErrored) {
+        return;
+      }
+
+      // Step g: If teeState.[[canceled1]] is false,
+      if (!teeState.canceled1) {
+        // Step i: Let value1 be value.
+        let value1 = value;
+
+        // Step ii: If shouldClone is true, set value1 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value1).
+        ReadableStreamDefaultControllerEnqueue(branch1, value1);
+      }
+
+      // Step h: If teeState.[[canceled2]] is false,
+      if (!teeState.canceled2) {
+        // Step i: Let value2 be value.
+        let value2 = value;
+
+        // Step ii: If shouldClone is true, set value2 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value2).
+        ReadableStreamDefaultControllerEnqueue(branch2, value2);
+      }
+    });
+  };
+
+  // Step 7: Let cancel1 be a new ReadableStreamTee branch 1 cancel function.
+  // Step 8: Set cancel1@[[stream]] to stream and cancel1@[[teeState]] to
+  //         teeState.
+  let cancel1 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled1]] to true.
+    teeState.canceled1 = true;
+
+    // Step 3: Set teeState.[[reason1]] to reason.
+    teeState.reason1 = reason;
+
+    // Step 4: If teeState.[[canceled2]] is true,
+    if (teeState.canceled2) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(teeState.deferred.resolve, teeState.deferred.promise,
+                   cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.deferred.promise;
+  };
+
+  // Step 9: Let cancel2 be a new ReadableStreamTee branch 2 cancel function.
+  // Step 10: Set cancel2@[[stream]] to stream and cancel2@[[teeState]] to
+  //          teeState.
+  let cancel2 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled2]] to true.
+    teeState.canceled2 = true;
+
+    // Step 3: Set teeState.[[reason2]] to reason.
+    teeState.reason2 = reason;
+
+    // Step 4: If teeState.[[canceled1]] is true,
+    if (teeState.canceled1) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(teeState.deferred.resolve, teeState.deferred.promise,
+                   cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.deferred.promise;
+  };
+
+  // Step 11: Let underlyingSource1 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 12: Perform ! CreateDataProperty(underlyingSource1, "pull", pull).
+  // Step 13: Perform ! CreateDataProperty(underlyingSource1, "cancel", cancel1).
+  let underlyingSource1 = {
+    pull: pull,
+    cancel: cancel1
+  };
+
+  // Step 14: Let branch1Stream be ! Construct(ReadableStream, underlyingSource1).
+  let ReadableStreamCtor = GetReadableStreamCtor();
+  let branch1Stream = new ReadableStreamCtor(underlyingSource1);
+
+  // Step 15: Let underlyingSource2 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 16: Perform ! CreateDataProperty(underlyingSource2, "pull", pull).
+  // Step 17: Perform ! CreateDataProperty(underlyingSource2, "cancel", cancel2).
+  let underlyingSource2 = {
+    pull: pull,
+    cancel: cancel2
+  };
+
+  // Step 18: Let branch2Stream be ! Construct(ReadableStream, underlyingSource2).
+  let branch2Stream = new ReadableStreamCtor(underlyingSource2);
+
+  // Step 19: Set pull@[[branch1]] to branch1Stream@[[readableStreamController]].
+  // Step 20: Set pull@[[branch2]] to branch2Stream@[[readableStreamController]].
+  // Implemented via the pull closure above.
+
+  // Step 21: Upon rejection of reader@[[closedPromise]] with reason r,
+  // TODO: fix slot name here
+  let readerClosedPromise =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
+  callFunction(Promise_catch, readerClosedPromise, reason => {
+    // Step a: If teeState.[[closedOrErrored]] is true, return undefined.
+    if (teeState.closedOrErrored) {
+      return;
+    }
+    // Step b: Perform ! ReadableStreamDefaultControllerError(pull@[[branch1]], r).
+    ReadableStreamDefaultControllerError(branch1Stream, reason);
+    // Step c: Perform ! ReadableStreamDefaultControllerError(pull@[[branch2]], r).
+    ReadableStreamDefaultControllerError(branch2Stream, reason);
+    // Step d: Set teeState.[[closedOrErrored]] to true.
+    teeState.closedOrErrored = true;
+  });
+
+  // Step 22: Return « branch1, branch2 ».
+  let result = new List();
+  result[0] = branch1Stream;
+  result[1] = branch2Stream;
+  return result;
+}
+
+// Streams spec, 3.4.1. ReadableStreamAddReadIntoRequest ( stream )
+function ReadableStreamAddReadIntoRequest(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamAddReadIntoRequest() must operate on a stream");
+
+  // Step 1: Assert: ! IsReadableStreamBYOBReader(stream@[[reader]]) is true.
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  assert(IsReadableStreamBYOBReader(reader),
+         "ReadableStreamAddReadIntoRequest() must operate on a ReadableStreamBYOBReader");
+
+  // Step 2: Let promise be a new promise.
+  let deferred = CreateDeferred();
+
+  // Step 3: Let readIntoRequest be Record {[[promise]]: promise}.
+  let readIntoRequest = new Record();
+  readIntoRequest.deferred = deferred;
+
+  // Step 4: Append readRequest as the last element of stream@[[reader]]@[[readIntoRequests]].
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  ArrayStaticPush(readIntoRequests, readIntoRequest);
+
+  // Step 5: Return promise.
+  return deferred.promise;
+}
+
+// Streams spec, 3.4.2. ReadableStreamAddReadRequest ( stream )
+function ReadableStreamAddReadIntoRequest(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamAddReadRequest() must operate on a stream");
+
+  // Step 1: Assert: ! IsReadableStreamDefaultReader(stream@[[reader]]) is true.
+  let reader = UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+  assert(IsReadableStreamDefaultReader(reader),
+         "ReadableStreamAddReadRequest() must operate on a ReadableStreamDefaultReader");
+
+  // Step 2: Let promise be a new promise.
+  let deferred = CreateDeferred();
+
+  // Step 3: Let readIntoRequest be Record {[[promise]]: promise}.
+  let readIntoRequest = new Record();
+  readIntoRequest.deferred = deferred;
+
+  // Step 4: Append readRequest as the last element of stream@[[reader]]@[[readIntoRequests]].
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  ArrayStaticPush(readIntoRequests, readIntoRequest);
+
+  // Step 5: Return promise.
+  return deferred.promise;
+}
+
+// Streams spec, 3.4.3. ReadableStreamCancel ( stream, reason )
+function ReadableStreamCancel(stream, reason) {
+  // Step 1: Assert: stream is not undefined.
+  assert(IsReadableStream(stream),
+         "ReadableStreamCancel must operate on a ReadableStream");
+
+  // Step 2: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 3: If stream@[[state]] is "closed", return a new promise resolved
+  //         with undefined.
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    return callFunction(Promise_static_resolve, GetPromiseCtor(), undefined);
+  }
+
+  // Step 4: If stream@[[state]] is "errored", return a new promise rejected
+  //         with stream@[[storedError]].
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 5: Perform ! ReadableStreamClose(stream).
+  ReadableStreamClose(stream);
+
+  // Step 6: Let sourceCancelPromise be
+  //         ! stream@[[readableStreamController]]@[[Cancel]](reason).
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  let sourceCancelPromise =
+    callFunction(ReadableStreamController_Cancel, controller, reason);
+
+  // Step 7: Return the result of transforming sourceCancelPromise by a
+  //         fulfillment handler that returns undefined.
+  return callFunction(Promise_then, sourceCancelPromise, () => undefined);
+}
+
+// Step 3.4.4. ReadableStreamClose ( stream )
+function ReadableStreamClose(stream) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamClose() must operate on a ReadableStream");
+
+  // Step 1: Assert: stream@[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "ReadableStreamClose() must operate on readable ReadableStreams");
+
+  // Step 2: Set stream@[[state]] to "closed".
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_CLOSED_STATE);
+
+  // Step 3: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 4: If reader is undefined, return undefined.
+  if (reader === undefined) {
+    return;
+  }
+
+  // Step 5: If ! IsReadableStreamDefaultReader(reader) is true,
+  if (IsReadableStreamDefaultReader(reader)) {
+    // Step a: Repeat for each readRequest that is an element of
+    //         reader@[[readRequests]],
+    let readRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+    for (let i in readRequests) {
+      // Step i: Resolve readRequest.[[promise]] with
+      //         ! CreateIterResultObject(undefined, true).
+      let readRequest = readRequests[i];
+      callFunction(readRequest.deferred.resolve, readRequest.deferred.promise,
+                   { value: undefined, done: true });
+    }
+
+    // Step b: Set reader@[[readRequests]] to an empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 6: Resolve reader@[[closedPromise]] with undefined.
+  let closedDeferred =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED);
+  callFunction(closedDeferred.resolve, closedDeferred.promise, undefined);
+
+  // Step 7: Return undefined.
+  return;
+}
+
+// Streams spec, 3.4.5. ReadableStreamError ( stream, e )
+function ReadableStreamError(stream, e) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream),
+         "ReadableStreamError() must operate on a ReadableStream");
+
+  // Step 2: Assert: stream@[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "ReadableStreamError() must operate on readable ReadableStreams");
+
+  // Step 3: Set stream@[[state]] to "errored".
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_ERRORED_STATE);
+
+  // Step 4: Set stream@[[storedError]] to e.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT, e);
+
+  // Step 5: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 6: If reader is undefined, return undefined.
+  if (reader === undefined) {
+    return;
+  }
+
+  // Step 7: If ! IsReadableStreamDefaultReader(reader) is true,
+  if (IsReadableStreamDefaultReader(reader)) {
+    // Step a: Repeat for each readRequest that is an element of
+    //         reader@[[readRequests]],
+    let readRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+    for (let i in readRequests) {
+      // Step i: Reject readRequest.[[promise]] with e.
+      let readRequest = readRequests[i];
+      callFunction(readRequest.deferred.reject, readRequest.deferred.promise, e);
+    }
+
+    // Step b: Set reader@[[readRequests]] to a new empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 8: Otherwise,
+  else {
+    // Step a: Assert: ! IsReadableStreamBYOBReader(reader).
+    assert(IsReadableStreamBYOBReader(reader),
+           "Non-default reader must be a BYOB reader");
+
+    // Step b: Repeat for each readIntoRequest that is an element of
+    //         reader@[[readIntoRequests]],
+    let readIntoRequests =
+      UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+    for (let i in readIntoRequests) {
+      // Step i: Reject readIntoRequest.[[promise]] with e.
+      let readIntoRequest = readIntoRequests[i];
+      callFunction(readIntoRequest.deferred.reject,
+                   readIntoRequest.deferred.promise, e);
+    }
+
+    // Step b: Set reader@[[readIntoRequests]] to a new empty List.
+    UnsafeSetReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT,
+                          new List());
+  }
+
+  // Step 9: Reject reader@[[closedPromise]] with e.
+  let closedDeferred =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED);
+  callFunction(closedDeferred.reject, closedDeferred.promise, e);
+}
+
+// Streams spec, 3.4.6. ReadableStreamFulfillReadIntoRequest( stream, chunk, done )
+function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamFulfillReadIntoRequest() must operate on a " +
+         "ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetObjectFromReservedSlot(reader, READBLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamBYOBReader(reader),
+         "ReadableStreamFulfillReadIntoRequest() must operate on a " +
+         "ReadableStreamBYOBReader");
+
+  // Step 2: Let readIntoRequest be the first element of
+  //         reader@[[readIntoRequests]].
+  // Step 3: Remove readIntoRequest from reader@[[readIntoRequests]], shifting
+  //         all other elements downward (so that the second becomes the first,
+  //         and so on).
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  let readIntoRequest = ArrayStaticShift(readIntoRequests);
+
+  // Step 4: Resolve readIntoRequest.[[promise]] with
+  //         ! CreateIterResultObject(chunk, done).
+  callFunction(readIntoRequest.deferred.resolve,
+               readIntoRequest.deferred.promise, { value: chunk, done: done });
+}
+
+// Streams spec, 3.4.7. ReadableStreamFulfillReadRequest ( stream, chunk, done)
+function ReadableStreamFulfillReadRequest(stream, chunk, done) {
+  assert(IsReadableStream(stream),
+         "ReadableStreamFulfillReadRequest() must operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetObjectFromReservedSlot(reader, READBLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamDefaultReader(reader),
+         "ReadableStreamFulfillReadRequest() must operate on a " +
+         "ReadableStreamDefaultReader");
+
+  // Step 2: Let readRequest be the first element of reader@[[readRequests]].
+  // Step 3: Remove readRequest from reader@[[readRequests]], shifting all other
+  //         elements downward (so that the second becomes the first, and so on).
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  let readRequest = ArrayStaticShift(readRequests);
+
+  // Step 4: Resolve readRequest.[[promise]] with
+  //         ! CreateIterResultObject(chunk, done).
+  callFunction(readRequest.deferred.resolve, readRequest.deferred.promise,
+               { value: chunk, done: done });
+}
+
+// Streams spec 3.4.8. ReadableStreamGetNumReadIntoRequests ( stream )
+function ReadableStreamGetNumReadIntoRequests(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamGetNumReadIntoRequests must " +
+                                   "operate on a ReadableStream");
+
+  let reader =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamBYOBReader(reader), "ReadableStreamGetNumReadIntoRequests " +
+                                             "must operate on a ReadableStreamBYOBReader");
+
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+
+  // Step 1: Return the number of elements in
+  //         stream@[[reader]]@[[readIntoRequests]].
+  return readIntoRequests.length;
+}
+
+// Streams spec 3.4.9. ReadableStreamGetNumReadRequests ( stream )
+function ReadableStreamGetNumReadRequests(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamGetNumReadRequests must " +
+                                   "operate on a ReadableStream");
+
+  let reader =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  assert(IsReadableStreamDefaultReader(reader), "ReadableStreamGetNumReadRequests " +
+                                                "must operate on a ReadableStreamDefaultReader");
+
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+
+  // Step 1: Return the number of elements in
+  //         stream@[[reader]]@[[readRequests]].
+  return readRequests.length;
+}
+
+// Stream spec 3.4.10. ReadableStreamHasBYOBReader ( stream )
+function ReadableStreamHasBYOBReader(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamHasBYOBReader must " +
+                                   "operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 2: If reader is undefined, return false.
+  if (reader === undefined) {
+    return false;
+  }
+
+  // Step 3: If ! IsReadableStreamBYOBReader(reader) is false, return false.
+  // Step 4: Return true.
+  return IsReadableStreamBYOBReader(reader);
+}
+
+// Streap spec 3.4.11. ReadableStreamHasDefaultReader ( stream )
+function ReadableStreamHasDefaultReader(stream) {
+  assert(IsReadableStream(stream), "ReadableStreamHasDefaultReader must " +
+                                   "operate on a ReadableStream");
+
+  // Step 1: Let reader be stream@[[reader]].
+  let reader = UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT);
+
+  // Step 2: If reader is undefined, return false.
+  if (reader === undefined) {
+    return false;
+  }
+
+  // Step 3: If ! IsReadableStreamBYOBReader(reader) is false, return false.
+  // Step 4: Return true.
+  return IsReadableStreamDefaultReader(reader);
+}
+
+// Stream spec, 3.5.3. new ReadableStreamDefaultReader ( stream )
+function ReadableStreamDefaultReader(stream) {
+  if (!IsReadableStreamDefaultReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamDefaultReader", typeof stream);
+  }
+
+  // Step 2: If ! IsReadableStreamLocked(stream) is true, throw a TypeError
+  //         exception.
+  if (IsReadableStreamLocked(stream)) {
+    ThrowTypeError(JSMSG_READABLESTREAM_LOCKED, "getReader");
+  }
+
+  // Step 3: Perform ! ReadableStreamReaderGenericInitialize(this, stream).
+  ReadableStreamReaderGenericInitialize(this, stream);
+
+  // Step 4: Set this@[[readRequests]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT,
+                        new List());
+}
+
+// Streams spec, 3.5.4.1 get closed
+function ReadableStreamDefaultReader_closed() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "closed", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: Return this@[[closedPromise]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.5.4.2. cancel ( reason )
+function ReadableStreamDefaultReader_cancel(reason) {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "cancel", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED, "cancel");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamReaderGenericCancel(this, reason).
+  return ReadableStreamReaderGenericCancel(this, reason);
+}
+
+// Streams spec, 3.5.4.3 read ( )
+function ReadableStreamDefaultReader_read() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                     "read", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED, "read");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamDefaultReaderRead(this).
+  return ReadableStreamDefaultReaderRead(this);
+}
+
+// Streams spec, 3.5.4.4. releaseLock ( )
+function ReadableStreamDefaultReader_releaseLock() {
+  // Step 1: If ! IsReadableStreamDefaultReader(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultReader",
+                   "releaseLock", typeof this);
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return undefined.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return undefined;
+  }
+
+  // Step 3: If this@[[readRequests]] is not empty, throw a TypeError exception.
+  let readRequests =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTREADER_READ_REQUESTS_SLOT);
+  if (readRequests.length > 0) {
+    ThrowTypeError(JSMSG_READABLESTREAMDEFAULTREADER_NOT_EMPTY, "releaseLock");
+  }
+
+  // Step 4: Perform ! ReadableStreamReaderGenericRelease(this).
+  ReadableStreamReaderGenericRelease(this);
+}
+
+// Streams spec, 3.6.3 new ReadableStreamBYOBReader ( stream )
+function ReadableStreamBYOBReader(stream) {
+  if (!IsReadableStreamBYOBReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamBYOBReader", typeof stream);
+  }
+
+  // Step 2: If ! IsReadableStreamLocked(stream) is true, throw a TypeError
+  //         exception.
+  if (IsReadableStreamLocked(stream)) {
+    ThrowTypeError(JSMSG_READABLESTREAM_LOCKED, "getReader");
+  }
+
+  // Step 3: Perform ! ReadableStreamReaderGenericInitialize(this, stream).
+  ReadableStreamReaderGenericInitialize(this, stream);
+
+  // Step 4: Set this@[[readIntoRequests]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT,
+                        new List());
+}
+
+// Streams spec, 3.6.4.1 get closed
+function ReadableStreamBYOBReader_closed() {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "closed", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: Return this@[[closedPromise]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREADER_CLOSED_PROMISE_SLOT);
+}
+
+// Streams spec, 3.6.4.2. cancel ( reason )
+function ReadableStreamBYOBReader_cancel(reason) {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "cancel", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      // TODO fix error name
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_OWNED, "cancel");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: Return ! ReadableStreamReaderGenericCancel(this, reason).
+  return ReadableStreamReaderGenericCancel(this, reason);
+}
+
+// Streams spec, 3.6.4.3. read ( view )
+function ReadableStreamBYOBReader_read(view) {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, return a promise
+  //         rejected with a TypeError exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                     "read", typeof this);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return a promise
+  //         rejected with a TypeError exception.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    try {
+      // TODO fix error name
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_OWNED, "read");
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 3: If Type(view) is not Object, return a promise rejected with a
+  //         TypeError exception.
+  if (!IsObject(view)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "Object",
+                     "ReadableStreamBYOBReader.read", typeof view);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 4: If view does not have a [[ViewedArrayBuffer]] internal slot,
+  //         return a promise rejected with a TypeError exception.
+  if (!IsTypedArray(view)) {
+    try {
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "TypedArray",
+                     "ReadableStreamBYOBReader.read", typeof view);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 5: If view@[[ByteLength]] is 0, return a promise rejected with a
+  //         TypeError exception.
+  let buffer = ViewedArrayBufferIfReified(view);
+  if (ArrayBufferByteLength(buffer) === 0) {
+    try {
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW);
+    } catch (e) {
+      return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+    }
+  }
+
+  // Step 6: Return ! ReadableStreamBYOBReaderRead(this, view).
+  return ReadableStreamBYOBReaderReader(this, view);
+}
+
+// Streams spec, 3.6.4.4. releaseLock ( )
+function ReadableStreamBYOBReader_releaseLock() {
+  // Step 1: If ! IsReadableStreamBYOBReader(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBReader(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBReader",
+                   "releaseLock", typeof this);
+  }
+
+  // Step 2: If this@[[ownerReadableStream]] is undefined, return undefined.
+  let ownerReadableStream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  if (ownerReadableStream === undefined) {
+    return undefined;
+  }
+
+  // Step 3: If this@[[readIntoRequests]] is not empty, throw a TypeError
+  //         exception.
+  let readIntoRequests =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREADER_READ_INTO_REQUESTS_SLOT);
+  if (readRequests.length > 0) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREADER_NOT_EMPTY, "releaseLock");
+  }
+
+  // Step 4: Perform ! ReadableStreamReaderGenericRelease(this).
+  ReadableStreamReaderGenericRelease(this);
+}
+
+// Streams spec, 3.7.1. IsReadableStreamDefaultReader ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamDefaultReader>()
+
+// Streams spec, 3.7.2. IsReadableStreamBYOBReader ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamBYOBReader>()
+
+// Streams spec, 3.7.3. ReadableStreamReaderGenericCancel ( reader, reason )
+function ReadableStreamReaderGenericCancel(reader, reason) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetReservedSlot(this, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(stream !== undefined, "owning stream must be defined");
+
+  // Step 3: Return ! ReadableStreamCancel(stream, reason).
+  ReadableStreamCancel(stream, reason);
+}
+
+// Streams spec, 3.7.4. ReadableStreamReaderGenericInitialize ( reader, stream )
+function ReadableStreamReaderGenericInitialize(reader, stream) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+  assert(IsReadableStream(stream), "must be initializing with a ReadableStream");
+
+  // Step 1: Set reader@[[ownerReadableStream]] to stream.
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 2: Set stream@[[reader]] to reader.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, reader);
+
+  // Step 3: If stream@[[state]] is "readable",
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_READABLE_STATE) {
+    // Step a: Set reader@[[closedPromise]] to a new promise.
+    let deferred = CreateDeferred();
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT, deferred.promise);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, deferred);
+  }
+
+  // Step 4: Otherwise
+  // Step a: If stream@[[state]] is "closed",
+  else if (state === READABLESTREAM_CLOSED_STATE) {
+    // Step i: Set reader@[[closedPromise]] to a new promise resolved with
+    //         undefined.
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      callFunction(Promise_static_resolve, GetPromiseCtor(), undefined));
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  }
+
+  // Step b: Otherwise,
+  else {
+    // Step i: Assert: stream@[[state]] is "errored".
+    assert(state === READABLESTREAM_ERRORED_STATE,
+           "must be errored if not readable or closed");
+
+    // Step ii: Set reader@[[closedPromise]] to a new promise rejected with
+    //          stream@[[storedError]].
+    let storedError = UnsafeGetReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+      callFunction(Promise_static_reject, GetPromiseCtor(), storedError));
+    UnsafeSetReservedSlot(this, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+  }
+}
+
+// Streams spec, 3.7.5. ReadableStreamReaderGenericRelease ( reader )
+function ReadableStreamReaderGenericRelease(reader) {
+  assert(IsReadableStreamDefaultReader(reader) ||
+         IsReadableStreamBYOBReader(reader), "must be either a default or byob reader");
+
+  // Step 1: Assert: reader@[[ownerReadableStream]] is not undefined.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "reader should be owned by a ReadableStream");
+
+  // Step 2: Assert: reader@[[ownerReadableStream]]@[[reader]] is not undefined.
+  assert(UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_READER_SLOT) === reader,
+         "owning ReadableStream should reference the given reader");
+
+  try {
+    throwTypeError(JSMSG_READABLESTREAMREADER_RELEASED);
+  } catch(e) {
+    // Step 3: If reader@[[ownerReadableStream]]@[[state]] is "readable", reject
+    //         reader@[[closedPromise]] with a TypeError exception.
+    let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+    if (state === READABLESTREAM_READABLE_STATE) {
+        let closedDeferred =
+          UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT);
+        callFunction(closedDeferred.reject, closedDeferred.promise, e);
+      }
+    }
+
+    // Step 4: Otherwise, set reader@[[closedPromise]] to a new promise rejected
+    //         with a TypeError exception.
+    else {
+      UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_PROMISE_SLOT,
+        callFunction(Promise_static_reject, GetPromiseCtor(), e));
+      UnsafeSetReservedSlot(reader, READABLESTREAMREADER_CLOSED_DEFERRED_SLOT, undefined);
+    }
+  }
+
+  // Step 5: Set reader@[[ownerReadableStream]]@[[reader]] to undefined.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_READER_SLOT, undefined);
+
+  // Step 6: Set reader@[[ownerReadableStream]] to undefined.
+  UnsafeSetReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT,
+                        undefined);
+}
+
+// Streams spec, 3.7.6. ReadableStreamBYOBReaderRead ( reader, view )
+function ReadableStreamBYOBReaderRead(reader, view) {
+  assert(IsReadableStreamBYOBReader(reader), "must be a byob reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(IsReadableStream(stream), "must be owned by a ReadableStream");
+
+  // Step 3: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 4: If stream@[[state]] is "errored", return a promise rejected with
+  //         stream@[[storedError]].
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 5: Return ! ReadableByteStreamControllerPullInto(stream@[[readableStreamController]], view).
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  return ReadableByteStreamControllerPullInto(controller, view);
+}
+
+// Streams spec, 3.7.7. ReadableStreamDefaultReaderRead ( reader )
+function ReadableStreamDefaultReaderRead(reader) {
+  assert(IsReadableStreamDefaultReader(reader), "must be a default reader");
+
+  // Step 1: Let stream be reader@[[ownerReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
+
+  // Step 2: Assert: stream is not undefined.
+  assert(IsReadableStream(stream), "must be owned by a ReadableStream");
+
+  // Step 3: Set stream@[[disturbed]] to true.
+  UnsafeSetReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT, true);
+
+  // Step 4: If stream@[[state]] is "closed", return a new promise resolved with
+  //         ! CreateIterResultObject(undefined, true).
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        { value: undefined, done: true });
+  }
+
+  // Step 5: If stream@[[state]] is "errored", return a new promise rejected with
+  //         stream@[[storedError]].
+  if (state === READABLESTREAM_ERRORED_STATE) {
+    let storedError =
+      UnsafeGetFromReservedSlot(stream, READABLESTREAM_STORED_ERROR_SLOT);
+    return callFunction(Promise_static_reject, GetPromiseCtor(), storedError);
+  }
+
+  // Step 6: Assert: stream@[[state]] is "readable".
+  assert(state === READABLESTREAM_READABLE_STATE,
+         "mut be readable if not closed or errored");
+
+  // Step 7: Return ! stream@[[readableStreamController]]@[[Pull]]().
+  // TODO: is this the right way to call this?
+  let controller =
+    UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  callFunction(controller.pull, controller);
+}
+
+// Streams spec, 3.8.3 new ReadableStreamDefaultController ( stream, underlyingSource,
+//                                                           size, highWaterMark )
+function ReadableStreamDefaultController(stream, underlyingSource, size, highWaterMark) {
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableStreamDefaultController", typeof stream);
+  }
+
+  // Step 2: If stream@[[readableStreamController]] is not undefined, throw a
+  //         TypeError exception.
+  let controller = UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  if (controller !== undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAM_CONTROLLER_SET);
+  }
+
+  // Step 3: Set this@[[controlledReadableStream]] to stream.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 4: Set this@[[underlyingSource]] to underlyingSource.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT,
+                        underlyingSource);
+
+  // Step 5: Set this@[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT, new List());
+
+  // Step 6: Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]],
+  //         and this@[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CLOSE_REQUESTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                        false);
+
+  // Step 7: Let normalizedStrategy be
+  //         ? ValidateAndNormalizeQueuingStrategy(size, highWaterMark).
+  let normalizedStrategy =
+    ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
+
+  // Step 8: Set this@[[strategySize]] to normalizedStrategy.[[size]] and
+  //         this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_SIZE_SLOT,
+                        normalizedStrategy.size);
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_HWM_SLOT,
+                        normalizedStrategy.highWaterMark);
+
+  // Step 9: Let controller be this.
+  let controller = this;
+
+  // Step 10: Let startResult be
+  //          ? InvokeOrNoop(underlyingSource, "start", « this »).
+  let startResult = InvokeOrNoop(underlyingSource, "start", this);
+
+  // Step 11: Resolve startResult as a promise:
+  callFunction(Promise_then, startResult,
+    // Step a: Upon fulfillment,
+    () => {
+      // Step i: Set controller@[[started]] to true.
+      UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT,
+                            true);
+
+      // Step ii: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+    },
+
+    // Step b: Upon rejection with reason r,
+    r => {
+      // Step i: If stream@[[state]] is "readable", perform
+      //         ! ReadableStreamDefaultControllerError(controller, r).
+      let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableStreamDefaultControllerError(controller, r);
+      }
+    }
+  );
+}
+
+// Streams spec, 3.8.4.1. get desiredSize
+function ReadableStreamDefaultController_desiredSize() {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "desiredSize", typeof this);
+  }
+
+  // Step 2: Return ! ReadableStreamDefaultControllerGetDesiredSize(this).
+  return ReadableStreamDefaultControllerGetDesiredSize(this);
+}
+
+// Streams spec, 3.8.4.2 close()
+function ReadableStreamDefaultController_close() {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this@[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "close");
+  }
+
+  // Step 3: If this@[[controlledReadableStream]]@[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "close");
+  }
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerClose(this).
+  ReadableStreamDefaultControlleClose(this);
+}
+
+// Streams spec, 3.8.4.3. enqueue ( chunk )
+function ReadableStreamDefaultController_enqueue(chunk) {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "enqueue", typeof this);
+  }
+
+  // Step 2: If this@[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "enqueue");
+  }
+
+  // Step 3: If this@[[controlledReadableStream]]@[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "enqueue");
+  }
+
+  // Step 4: Return ! ReadableStreamDefaultControllerEnqueue(this, chunk).
+  return ReadableStreamDefaultControllerEnqueue(this, chunk);
+}
+
+// Streams spec, 3.8.4.4. error ( e )
+function ReadableStreamDefaultController_error(e) {
+  // Step 1: If ! IsReadableStreamDefaultController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableStreamDefaultController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamDefaultController",
+                   "enqueue", typeof this);
+  }
+
+  // Step 2: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 3: If stream.[[state]] is not "readable", throw a TypeError exception.
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "error");
+  }
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerError(this, e).
+  ReadableStreamDefaultControllerError(this, e);
+}
+
+// Streams spec, 3.8.5.1. [[Cancel]] ( reason )
+function ReadableStreamDefaultController_cancel(reason) {
+  assert(IsReadableStreamDefaultController(this),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 2: Return ! PromiseInvokeOrNoop(this.[[underlyingSource]], "cancel", « reason »)
+  let underlyingSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT);
+  return PromiseInvokeOrNoop(underlyingSource, "cancel", reason);
+}
+
+// Streams spec, 3.8.5.2. [[Pull]] ( )
+function ReadableStreamDefaultController_pull() {
+  assert(IsReadableStreamDefaultController(this),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If this[[queue]] is not empty,
+  let queue =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  if (queue.length > 0) {
+    // Step a: Let chunk be ! DequeueValue(this.[[queue]]).
+    let chunk = DequeueValue(queue);
+
+    // Step b: If this.[[closeRequested]] is true and this.[[queue]] is empty,
+    //         perform ! ReadableStreamClose(stream).
+    let closeRequested =
+      UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+    if (closeRequested && queue.length === 0) {
+      ReadableStreamClose(stream);
+    }
+
+    // Step c: Otherwise, perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
+    else {
+      ReadableStreamDefaultControllerCallPullIfNeeded(this);
+    }
+
+    // Step d: Return a promise resolved with ! CreateIterResultObject(chunk, false).
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        { value: chunk, done: false });
+  }
+
+  // Step 3: Let pendingPromise be ! ReadableStreamAddReadRequest(stream).
+  let pendingPromise = ReadableStreamAddReadRequest(stream);
+
+  // Step 4: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(this).
+  ReadableStreamDefaultControllerCallPullIfNeeded(this);
+
+  // Step 5: Return pendingPromise.
+  return pendingPromise;
+}
+
+// Streams spec, 3.9.1 IsReadableStreamDefaultController ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamDefaultController>()
+
+// Streams spec, 3.9.2 ReadableStreamDefaultControllerCallPullIfNeeded ( controller )
+function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let shouldPull be ! ReadableStreamDefaultControllerShouldCallPull(controller).
+  let shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
+
+  // Step 2: If shouldPull is false, return undefined.
+  if (!shouldPull) {
+    return undefined;
+  }
+
+  // Step 3: If controller.[[pulling]] is true,
+  let pulling =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT);
+  if (pulling) {
+    // Step a: Set controller.[[pullAgain]] to true.
+    UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                          true);
+
+    // Step b: Return undefined.
+    return undefined;
+  }
+
+  // Step 4: Set controller.[[pulling]] to true.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                        true);
+
+  // Step 5: Let pullPromise be
+  //         ! PromiseInvokeOrNoop(controller.[[underlyingSource]], "pull", « controller »).
+  let underlyingSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_UNDERLYING_SOURCE_SLOT);
+  let pullPromise = PromiseInvokeOrNoop(underlyingSource, "pull", controller);
+
+  // Step 6: Upon fulfillment of pullPromise,
+  callFunction(Promise_then, pullPromise, () => {
+    // Step a: Set controller.[[pulling]] to false.
+    UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULLING_SLOT,
+                          false);
+
+    // Step b: If controller.[[pullAgain]] is true,
+    let pullAgain =
+      UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT);
+    if (pullAgain) {
+      // Step i: Set controller.[[pullAgain]] to false.
+      UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_PULL_AGAIN_SLOT,
+                            false);
+
+      // Step ii: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+    }
+  },
+
+  // Step 7: Upon rejection of pullPromise with reason e,
+  e => {
+    // Step a: If controller.[[controlledReadableStream]].[[state]] is "readable",
+    //         perform ! ReadableStreamDefaultControllerError(controller, e).
+    let stream =
+      UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+    assert(IsReadableStream(stream), "controller should have a ReadableStream");
+    let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+    if (state === READABLESTREAM_READABLE_STATE) {
+      ReadableStreamDefaultControllerError(controller, e);
+    }
+  });
+
+  // Step 8: Return undefined.
+  return undefined;
+}
+
+// Streams spec, 3.9.3. ReadableStreamDefaultControllerShouldCallPull ( controller )
+function ReadableStreamDefaultControllerShouldCallPull(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If stream.[[state]] is "closed" or stream.[[state]] is "errored",
+  //         return false.
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE ||
+      state === READABLESTREAM_ERRORED_STATE) {
+    return false;
+  }
+
+  // Step 3: If controller.[[closeRequested]] is true, return false.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    return false;
+  }
+
+  // Step 4: If controller.[[started]] is false, return false.
+  let started =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STARTED_SLOT);
+  if (!started) {
+    return false;
+  }
+
+  // Step 5: If ! IsReadableStreamLocked(stream) is true and
+  //         ! ReadableStreamGetNumReadRequests(stream) > 0, return true.
+  if (IsReadableStreamLocked(stream) &&
+      ReadableStreamGetNumReadRequests(stream) > 0) {
+    return true;
+  }
+
+  // Step 6: Let desiredSize be ReadableStreamDefaultControllerGetDesiredSize(controller).
+  let desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
+
+  // Step 7: If desiredSize > 0, return true.
+  // Step 8: Return false.
+  return desiredSize > 0;
+}
+
+// Streams spec, 3.9.4. ReadableStreamDefaultControllerClose ( controller )
+function ReadableStreamDefaultControllerClose(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT),
+         "controller should not have a pending close operation");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 4: Set controller.[[closeRequested]] to true.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT,
+                        true);
+
+  // Step 5: If controller.[[queue]] is empty, perform ! ReadableStreamClose(stream).
+  let queue =
+    UnsafeGetObjectFromReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  if (queue.length === 0) {
+    ReadableStreamClose(stream);
+  }
+}
+
+// Streams spec, 3.9.5. ReadableStreamDefaultControllerEnqueue ( controller, chunk )
+function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLL_CLOSE_REQUESTED_SLOT),
+         "controller should not have a pending close operation");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 4: If ! IsReadableStreamLocked(stream) is true and
+  //         ! ReadableStreamGetNumReadRequests(stream) > 0, perform
+  //         ! ReadableStreamFulfillReadRequest(stream, chunk, false).
+  if (IsReadableStreamLocked(stream) &&
+      ReadableStreamGetNumReadRequests(stream) > 0) {
+    ReadableStreamFulfillReadRequest(stream, chunk, false);
+  }
+
+  // Step 5: Otherwise,
+  else {
+    // Step a: Let chunkSize be 1.
+    let chunkSize = 1;
+
+    // Step b: If controller.[[strategySize]] is not undefined,
+    let strategySize =
+      UnsafeGetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_SIZE_SLOT);
+    if (strategySize !== undefined) {
+      // Step i: Set chunkSize to Call(stream.[[strategySize]], undefined, « chunk »).
+      try {
+        let chunkSize = callContentFunction(strategySize, undefined, chunk);
+      }
+
+      // Step ii: If chunkSize is an abrupt completion,
+      // The only abrupt completion possible in Call() is a thrown exception.
+      catch(e) {
+        // Step 1: If stream.[[state]] is "readable", perform
+        //         ! ReadableStreamDefaultControllerError(controller, chunkSize.[[Value]]).
+        let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+        if (state === READABLESTREAM_READABLE_STATE) {
+          ReadableStreamDefaultControllerError(controller, e);
+        }
+
+        // Step 2: Return chunkSize.
+        // Here chunkSize has an abrupt completion from a thrown exception.
+        throw(e);
+      }
+    }
+
+    // Step c: Let enqueueResult be
+    //         ! EnqueueValueWithSize(controller.[[queue]], chunk, chunkSize).
+    let queue =
+      UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+
+    try {
+      EnqueueValueWithSize(queue, chunk, chunkSize);
+    }
+
+    // Step d: If enqueueResult is an abrupt completion,
+    // The only abrupt completion possible in EnqueueValueWithSize() is a thrown
+    // exception.
+    catch(e) {
+      // Step i: If stream.[[state]] is "readable", perform
+      //         ! ReadableStreamDefaultControllerError(controller, enqueueResult.[[Value]]).
+      let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableStreamDefaultControllerError(controller, e);
+      }
+
+      // Step ii: Return enqueueResult.
+      // Here enqueueResult has an abrupt completion from a thrown exception.
+      throw (e);
+    }
+  }
+
+  // Step 6: Perform ! ReadableStreamDefaultControllerCallPullIfNeeded(controller).
+  ReadableStreamDefaultControllerCallPullIfNeeded(controller);
+
+  // Step 7: Return undefined.
+  return undefined;
+}
+
+// Streams spec, 3.9.6. ReadableStreamDefaultControllerError ( controller, e )
+function ReadableStreamDefaultControllerError(controller, e) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) ===
+         READABLESTREAM_READABLE_STATE,
+         "stream should be in the readable state");
+
+  // Step 3: Set controller.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 4: Perform ! ReadableStreamError(stream, e).
+  ReadableStreamError(stream, e);
+}
+
+// Streams spec, 3.9.7. ReadableStreamDefaultControllerGetDesiredSize ( controller )
+function ReadableStreamDefaultControllerGetDesiredSize(controller) {
+  assert(IsReadableStreamDefaultController(controller),
+         "must operate on a ReadableStreamDefaultController");
+
+  // Step 1: Let queueSize be ! GetTotalQueueSize(controller.[[queue]]).
+  let queue =
+    UnsafeGetObjectFromReservedSlot(controller, READABLESTREAMDEFAULTCONTROLLER_QUEUE_SLOT);
+  let queueSize = GetTotalQueueSize(queue);
+
+  // Step 2: Return controller.[[strategyHWM]] − queueSize.
+  let strategyHWM =
+    UnsafeGetInt32ReservedSlot(this, READABLESTREAMDEFAULTCONTROLLER_STRATEGY_HWM_SLOT);
+  return strategyHWM - queueSize;
+}
+
+// Streams spec, 3.10.3. new ReadableByteStreamController ( stream, underlyingByteSource, highWaterMark )
+function ReadableByteStreamController(stream, underlyingByteSource, highWaterMark) {
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "ctor", typeof this);
+  }
+
+  // Step 1: If ! IsReadableStream(stream) is false, throw a TypeError exception.
+  if (!IsReadableStream(stream)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream",
+                   "ReadableByteStreamController", typeof this);
+  }
+
+  // Step 2: If stream.[[readableStreamController]] is not undefined, throw a
+  //         TypeError exception.
+  let controller = UnsafeGetReservedSlot(stream, READABLESTREAM_CONTROLLER_SLOT);
+  if (controller !== undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAM_CONTROLLER_SET);
+  }
+
+  // Step 3: Set this.[[controlledReadableStream]] to stream.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT,
+                        stream);
+
+  // Step 4: Set this.[[underlyingByteSource]] to underlyingByteSource.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_UNDERLYING_BYTE_SOURCE_SLOT,
+                        underlyingByteSource);
+
+  // Step 5: Set this.[[pullAgain]], and this.[[pulling]] to false.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT,
+                        false);
+
+  // Step 6: Perform ! ReadableByteStreamControllerClearPendingPullIntos(this).
+  ReadableByteStreamControllerClearPendingPullIntos(this);
+
+  // Step 7: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 8: Set this.[[totalQueuedBytes]] to 0.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                        0);
+
+  // Step 9: Set this.[[started]], and this.[[closeRequested]] to false.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_STARTED_SLOT,
+                        false);
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT,
+                        false);
+
+  // Step 10: Set this.[[strategyHWM]] to
+  //          ? ValidateAndNormalizeHighWaterMark(highWaterMark).
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_STRATEGY_HWM_SLOT,
+                        ValidateAndNormalizeHighWaterMark(highWaterMark));
+
+  // Step 11: Let autoAllocateChunkSize be
+  //          ? GetV(underlyingByteSource, "autoAllocateChunkSize").
+  let autoAllocateChunksize = underlyingByteSource.autoAllocateChunkSize;
+
+  // Step 12: If autoAllocateChunkSize is not undefined,
+  if (autoAllocateChunkSize !== undefined) {
+    // Step a: Set autoAllocateChunkSize to ? ToInteger(autoAllocateChunkSize).
+    autoAllocateChunkSize = ToInteger(autoAllocateChunkSize);
+
+    // Step b: If autoAllocateChunkSize ≤ 0, or if autoAllocateChunkSize is
+    //         +infinity or −infinity, throw a RangeError exception.
+    if (autoAllocateChunkSize <= 0 || !Number_isFinite(autoAllocateChunkSize)) {
+      ThrowRangeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE);
+    }
+  }
+
+  // Step 13: Set this.[[autoAllocateChunkSize]] to autoAllocateChunkSize.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT,
+                        autoAllocateChunkSize);
+
+  // Step 14: Set this.[[pendingPullIntos]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT,
+                        new List());
+
+  // Step 15: Let controller be this.
+  let controller = this;
+
+  // Step 16: Let startResult be ? InvokeOrNoop(underlyingByteSource, "start", « this »).
+  let startResult = InvokeOrNoop(underlyingByteSource, "start", this);
+
+  // Step 17: Resolve startResult as a promise:
+  callFunction(Promise_then, startResult,
+    // Step a: Upon fulfillment,
+    () => {
+      // Step i: Set controller.[[started]] to true.
+      UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_STARTED_SLOT,
+                            true);
+
+      // Step ii: Assert: controller.[[pulling]] is false.
+      assert(!UnsafeGetBooleanReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT),
+             "should not be pulling after start promise resolves");
+
+      // Step iii: Assert: controller.[[pullAgain]] is false.
+      assert(!UnsafeGetBooleanReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT),
+             "should not need to pull again after start promise resolves");
+
+      // Step iv: Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
+      ReadableByteStreamControllerCallPullIfNeeded(controller);
+    },
+
+    // Step b: Upon rejection with reason r,
+    r => {
+      // Step i: If stream.[[state]] is "readable", perform
+      //         ! ReadableByteStreamControllerError(controller, r).
+      let state = UnsafeGetInt32ReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+      if (state === READABLESTREAM_READABLE_STATE) {
+        ReadableByteStreamControllerError(controller, r);
+      }
+    }
+  );
+}
+
+// Streams spec, 3.10.4.1. get byobRequest
+function ReadableByteStreamController_byobRequest() {
+  // Step 1: If IsReadableByteStreamController(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "byobRequest", typeof this);
+  }
+
+  // Step 2: If this.[[byobRequest]] is undefined and this.[[pendingPullIntos]]
+  //         is not empty,
+  let byobRequest =
+    UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT);
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (byobRequest === undefined && pendingPullIntos.length > 0) {
+    // Step a: Let firstDescriptor be the first element of this.[[pendingPullIntos]].
+    let firstDescriptor = pendingPullIntos[0];
+
+    // Step b: Let view be ! Construct(%Uint8Array%,
+    //  « firstDescriptor.[[buffer]],
+    //  firstDescriptor.[[byteOffset]] + firstDescriptor.[[bytesFilled]],
+    //  firstDescriptor.[[byteLength]] − firstDescriptor.[[bytesFilled]] »).
+    let view = new Uint8Array(firstDescriptor.buffer,
+                              firstDestriptor.byteOffset + firstDescriptor.bytesFilled,
+                              firstDestriptor.byteLength + firstDescriptor.bytesFilled);
+
+    // Step c: Set this.[[byobRequest]] to
+    //         ! Construct(ReadableStreamBYOBRequest, « this, view »).
+    let ReadableStreamBYOBRequestCtor = GetReadableStreamBYOBRequestCtor();
+    byobRequest = new ReadableStreamBYOBRequestCtor(this, view));
+    UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT,
+                          byobRequest);
+  }
+
+  // Step 3: Return this.[[byobRequest]].
+  return byobRequest;
+}
+
+// Streams spec, 3.10.4.2. get desiredSize
+function ReadableByteStreamController_desiredSize() {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "desiredSize", typeof this);
+  }
+
+  // Step 2: Return ! ReadableByteStreamControllerGetDesiredSize(this).
+  return ReadableByteStreamControllerGetDesiredSize(this);
+}
+
+// Streams spec, 3.10.4.3. close()
+function ReadableByteStreamController_close() {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this.[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "close");
+  }
+
+  // Step 3: If this.[[controlledReadableStream]].[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "close");
+  }
+
+  // Step 4: Perform ? ReadableByteStreamControllerClose(this).
+  ReadableByteStreamControllerClose(this);
+}
+
+// Streams spec, 3.10.4.4. enqueue ( chunk )
+function ReadableByteStreamController_enqueue(chunk) {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: If this.[[closeRequested]] is true, throw a TypeError exception.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "enqueue");
+  }
+
+  // Step 3: If this.[[controlledReadableStream]].[[state]] is not "readable",
+  //         throw a TypeError exception.
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "enqueue");
+  }
+
+  // Step 4: If Type(chunk) is not Object, throw a TypeError exception.
+  if (!IsObject(chunk)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 5: If chunk does not have a [[ViewedArrayBuffer]] internal slot,
+  //         throw a TypeError exception.
+  if (!IsTypedArray(chunk)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 6: Return ! ReadableByteStreamControllerEnqueue(this, chunk).
+  return ReadableByteStreamControllerEnqueue(this, chunk);
+}
+
+// Streams spec, 3.10.4.5. error ( e )
+function ReadableByteStreamController_error(e) {
+  // Step 1: If ! IsReadableByteStreamController(this) is false, throw a
+  //         TypeError exception.
+  if (!IsReadableByteStreamController(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableByteStreamController",
+                   "close", typeof this);
+  }
+
+  // Step 2: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 3: If stream.[[state]] is not "readable", throw a TypeError exception.
+  let state = UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE, "error");
+  }
+
+  // Step 4: Perform ! ReadableByteStreamControllerError(this, e).
+  ReadableByteStreamControllerError(this, e);
+}
+
+// Streams spec, 3.10.5.1. [[Cancel]] ( reason )
+function ReadableByteStreamController_cancel(reason) {
+  assert(IsReadableByteStreamController(this),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: If this.[[pendingPullIntos]] is not empty,
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (pendingPullIntos.length > 0) {
+    // Step a: Let firstDescriptor be the first element of
+    //         this.[[pendingPullIntos]].
+    // Step b: Set firstDescriptor.[[bytesFilled]] to 0.
+    pendingPullIntos[0].bytesFilled = 0;
+  }
+
+  // Step 2: Set this.[[queue]] to a new empty List.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 3: Set this.[[totalQueuedBytes]] to 0.
+  UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                        0);
+
+  // Step 4: Return ! PromiseInvokeOrNoop(this.[[underlyingByteSource]], "cancel", « reason »)
+  let underlyingByteSource =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_UNDERLYING_BYTE_SOURCE_SLOT);
+  return PromiseInvokeOrNoop(underlyingByteSource, "cancel", reason);
+}
+
+// Streams spec, 3.10.5.2. [[Pull]] ( )
+function ReadableByteStreamController_pull() {
+  assert(IsReadableByteStreamController(this),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be this.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If ! ReadableStreamGetNumReadRequests(stream) is 0,
+  if (ReadableStreamGetNumReadRequests(stream) === 0) {
+    // Step a: If this[[totalQueuedBytes]] > 0,
+    let totalQueuedBytes =
+        UnsafeGetInt32FromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+    if (totalQueuedBytes > 0) {
+      // Step i: Let entry be the first element of this.[[queue]].
+      // Step ii: Remove entry from this.[[queue]], shifting all other elements
+      //          downward (so that the second becomes the first, and so on).
+      let queue = UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT);
+      let entry = ArrayStaticShift(queue);
+
+      // Step iii: Set this.[[totalQueuedBytes]] to this.[[totalQueuedBytes]] −
+      //           entry.[[byteLength]].
+      totalQueuedBytes = totalQueuedBytes - entry.byteLength;
+      UnsafeSetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                            totalQueuedBytes);
+
+      // Step iv: Perform ! ReadableByteStreamControllerHandleQueueDrain(this).
+      ReadableByteStreamControllerHandleQueueDrain(this);
+
+      // Step v: Let view be
+      //         ! Construct(%Uint8Array%, « entry.[[buffer]],
+      //                     entry.[[byteOffset]], entry.[[byteLength]] »).
+      let view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
+
+      // Step vi: Return a promise resolved with ! CreateIterResultObject(view, false).
+      return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                          { value: view, done: false });
+    }
+
+    // Step b: Let autoAllocateChunkSize be this.[[autoAllocateChunkSize]].
+    let autoAllocateChunkSize =
+      UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT);
+
+    // Step c: If autoAllocateChunkSize is not undefined,
+    if (autoAllocateChunkSize !== undefined) {
+      // Step i: Let buffer be Construct(%ArrayBuffer%, « autoAllocateChunkSize »).
+      let buffer;
+      try {
+        buffer = new ArrayBuffer(autoAllocateChunkSize);
+      }
+
+      // Step ii: If buffer is an abrupt completion, return a promise rejected
+      //          with buffer.[[Value]].
+      catch (e) {
+        return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+      }
+
+      // Step iii: Let pullIntoDescriptor be Record {[[buffer]]: buffer.[[Value]],
+      //                                             [[byteOffset]]: 0,
+      //                                             [[byteLength]]: autoAllocateChunkSize,
+      //                                             [[bytesFilled]]: 0,
+      //                                             [[elementSize]]: 1,
+      //                                             [[ctor]]: %Uint8Array%,
+      //                                             [[readerType]]: "default"}.
+      let pullIntoDescriptor = new Record();
+      pullIntoDescriptor.buffer = buffer;
+      pullIntoDescriptor.byteOffset = 0;
+      pullIntoDescriptor.byteLength = autoAllocateChunkSize;
+      pullIntoDescriptor.bytesFilled = 0;
+      pullIntoDescriptor.elementsSize = 1;
+      pullIntoDescriptor.ctor = Uin8Array;
+      pullIntoDescriptor.readerType = "default";
+
+      // Step iv: Append pullIntoDescriptor as the last element of
+      //          this.[[pendingPullIntos]].
+      let pendingPullIntos =
+        UnsafeGetObjectFromReservedSlot(this, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+      ArrayStaticPush(pendingPullIntos, pullIntoDescriptor);
+    }
+  }
+
+  // Step 3: Otherwise,
+  else {
+    // Step a: Assert: this.[[autoAllocateChunkSize]] is undefined.
+    assert(UnsafeGetReservedSlot(this, READABLEBYTESTREAMCONTROLLER_AUTO_ALLOCATE_CHUNK_SIZE_SLOT) === undefined,
+           "autoAllocateChunkSize should not be defined");
+  }
+
+  // Step 4: Let promise be ! ReadableStreamAddReadRequest(stream).
+  let promise = ReadableStreamAddReadRequest(stream);
+
+  // Step 5: Perform ! ReadableByteStreamControllerCallPullIfNeeded(this).
+  ReadableByteStreamControllerCallPullIfNeeded(this);
+
+  // Step 6: Return promise.
+  return promise;
+}
+
+// Streams spec, 3.11.3. new ReadableStreamBYOBRequest ( controller, view )
+function ReadableStreamBYOBRequest(controller, view) {
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "ctor", typeof this);
+  }
+
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  assert(IsObject(view), "view should be an object");
+
+  // Step 1: Set this.[[associatedReadableByteStreamController]] to controller.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT,
+                        controller);
+
+  // Step 2: Set this.[[view]] to view.
+  UnsafeSetReservedSlot(this, READABLESTREAMBYOBREQUEST_VIEW_SLOT, view);
+}
+
+// Streams spec, 3.11.4.1 get view
+function ReadableStreamBYOBRequest_view() {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "view", typeof this);
+  }
+
+  // Step 2: Return this.[[view]].
+  return UnsafeGetObjectFromReservedSlot(this, READABLESTREAMBYOBREQUEST_VIEW_SLOT);
+}
+
+// Streams spec, 3.11.4.2. respond ( bytesWritten )
+function ReadableStreamBYOBRequest_respond(bytesWritten) {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "view", typeof this);
+  }
+
+  // Step 2: If this.[[associatedReadableByteStreamController]] is undefined,
+  //         throw a TypeError exception.
+  let controller =
+    UnsafeGetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT);
+  if (controller === undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER, "respond");
+  }
+
+  // Step 3: Return ? ReadableByteStreamControllerRespond(this.[[associatedReadableByteStreamController]],
+  //                                                      bytesWritten).
+  return ReadableByteStreamControllerRespond(controller, bytesWritten);
+}
+
+// Streams spec, 3.11.4.3. respondWithNewView ( view )
+function ReadableStreamBYOBRequest_respondWithNewView(view) {
+  // Step 1: If ! IsReadableStreamBYOBRequest(this) is false, throw a TypeError
+  //         exception.
+  if (!IsReadableStreamBYOBRequest(this)) {
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamBYOBRequest",
+                   "respondWithView", typeof this);
+  }
+
+  // Step 2: If this.[[associatedReadableByteStreamController]] is undefined,
+  //         throw a TypeError exception.
+  let controller =
+    UnsafeGetReservedSlot(this, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT);
+  if (controller === undefined) {
+    ThrowTypeError(JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER, "respond");
+  }
+
+  // Step 3: If Type(chunk) is not Object, throw a TypeError exception.
+  // Step 4: If view does not have a [[ViewedArrayBuffer]] internal slot, throw
+  //         a TypeError exception.
+  if (!IsTypedArray(view)) {
+    ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK);
+  }
+
+  // Step 5: Return ? ReadableByteStreamControllerRespondWithNewView(this.[[associatedReadableByteStreamController]],
+  //                                                                 view).
+  return ReadableByteStreamControllerRespondWithNewView(controller, view);
+}
+
+// Streams spec, 3.12.1 IsReadableStreamBYOBRequest ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStreamBYOBRequest>()
+
+// Streams spec, 3.12.2. IsReadableByteStreamController ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableByteStreamController>()
+
+// Streams spec, 3.12.3. ReadableByteStreamControllerCallPullIfNeeded ( controller )
+function ReadableByteStreamControllerCallPullIfNeeded(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let shouldPull be
+  //         ! ReadableByteStreamControllerShouldCallPull(controller).
+  let shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
+
+  // Step 2: If shouldPull is false, return undefined.
+  if (!shouldPull) {
+    return undefined;
+  }
+
+  // Step 3: If controller.[[pulling]] is true,
+  let pulling =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT);
+  if (pulling) {
+    // Step a: Set controller.[[pullAgain]] to true.
+    UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT,
+                          true);
+
+    // Step b: Return undefined.
+    return undefined;
+  }
+
+  // Step 4: Set controller.[[pullAgain]] to false.
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT,
+                        false);
+
+  // Step 5: Set controller.[[pulling]] to true.
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT,
+                        true);
+
+  // Step 6: Let pullPromise be
+  //         ! PromiseInvokeOrNoop(controller.[[underlyingByteSource]], "pull", controller).
+  let underlyingSource =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_UNDERLYING_BYTE_SOURCE_SLOT);
+  let pullPromise = PromiseInvokeOrNoop(underlyingSource, "pull", controller);
+
+  // Step 7: Upon fulfillment of pullPromise,
+  callFunction(Promise_then, pullPromise, () => {
+    // Step a: Set controller.[[pulling]] to false.
+    UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULLING_SLOT,
+                          false);
+
+    // Step b: If controller.[[pullAgain]] is true,
+    let pullAgain =
+      UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT);
+    if (pullAgain) {
+      // Step i: Set controller.[[pullAgain]] to false.
+      UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PULL_AGAIN_SLOT,
+                            false);
+
+      // Step ii: Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
+      ReadableByteStreamControllerCallPullIfNeeded(controller);
+    }
+  },
+
+  // Step 8: Upon rejection of pullPromise with reason e,
+  e => {
+    // Step a: If controller.[[controlledReadableStream]].[[state]] is "readable",
+    //         perform ! ReadableByteStreamControllerError(controller, e).
+    let stream =
+      UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+    assert(IsReadableStream(stream), "controller should have a ReadableStream");
+    let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+    if (state === READABLESTREAM_READABLE_STATE) {
+      ReadableByteStreamControllerError(controller, e);
+    }
+  });
+
+  // Step 9: Return undefined.
+  return undefined;
+}
+
+// Streams spec, 3.12.4. ReadableByteStreamControllerClearPendingPullIntos ( controller )
+function ReadableByteStreamControllerClearPendingPullIntos(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
+  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
+
+  // Step 2: Set controller.[[pendingPullIntos]] to a new empty List.
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT,
+                        new List());
+}
+
+// Streams spec, 3.12.5. ReadableByteStreamControllerClose ( controller )
+function ReadableByteStreamControllerClose(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT),
+         "controller should not have a close requested");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE,
+         "controller's stream should be in the readable state");
+
+  // Step 4: If controller.[[totalQueuedBytes]] > 0,
+  let totalQueuedBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  if (totalQueuedBytes > 0) {
+    // Step a: Set controller.[[closeRequested]] to true.
+    UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT,
+                          true);
+
+    // Step b: Return
+    return;
+  }
+
+  // Step 5: If controller.[[pendingPullIntos]] is not empty,
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (pendingPullIntos.length > 0) {
+    // Step a: Let firstPendingPullInto be the first element of
+    //         controller.[[pendingPullIntos]].
+    let firstPendingPullInto = pendingPullIntos[0];
+
+    // Step b: If firstPendingPullInto.[[bytesFilled]] > 0,
+    if (firstPendingPullInto.bytesFilled > 0) {
+      try {
+        // Step i: Let e be a new TypeError exception.
+        ThrowTypeError(JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL);
+      } catch (e) {
+        // Step ii: Perform ! ReadableByteStreamControllerError(controller, e).
+        ReadableByteStreamControllerError(controller, e);
+
+        // Step iii: Throw e.
+        throw e;
+      }
+    }
+  }
+
+  // Step 6: Perform ! ReadableStreamClose(stream).
+  ReadableStreamClose(stream);
+}
+
+// Streams spec, 3.12.6. ReadableByteStreamControllerCommitPullIntoDescriptor ( stream, pullIntoDescriptor )
+function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
+  assert(IsReadableStream(stream), "must operate on a ReadableStream");
+
+  // Step 1: Assert: stream.[[state]] is not "errored".
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  assert(state !== READABLESTREAM_ERRORED_STATE,
+         "stream must not be in the errored state");
+
+  // Step 2: Let done be false.
+  let done = false;
+
+  // Step 3: If stream.[[state]] is "closed",
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    // Step a: Assert: pullIntoDescriptor.[[bytesFilled]] is not 0.
+    assert(pullIntoDescriptor.bytesFilled !== 0,
+           "pullIntoDescriptor should not be empty");
+
+    // Step b: Set done to true.
+    done = true;
+  }
+
+  // Step 4: Let filledView be
+  //         ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
+  let filledView =
+    ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
+
+  // Step 5: If pullIntoDescriptor.[[readerType]] is "default",
+  if (pullIntoDescriptor.readerType === "default") {
+    // Step a: Perform ! ReadableStreamFulfillReadRequest(stream, filledView, done).
+    ReadableStreamFulfillReadRequest(stream, filledView, done);
+  }
+
+  // Step 6: Otherwise,
+  else {
+    // Step a: Assert: pullIntoDescriptor.[[readerType]] is "byob".
+    assert(pullIntoDescriptor.readerType === "byob",
+           "must be byob if not default");
+
+    // Step b: Perform ! ReadableStreamFulfillReadIntoRequest(stream, filledView, done).
+    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
+  }
+}
+
+// Streams spec, 3.12.7. ReadableByteStreamControllerConvertPullIntoDescriptor ( pullIntoDescriptor )
+function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
+  // Step 1: Let bytesFilled be pullIntoDescriptor.[[bytesFilled]].
+  let bytesFilled = pullIntoDescriptor.bytesFilled;
+
+  // Step 2: Let elementSize be pullIntoDescriptor.[[elementSize]].
+  let elementSize = pullIntoDescriptor.elementSize;
+
+  // Step 3: Assert: bytesFilled <= pullIntoDescriptor.[[byteLength]].
+  assert(bytesFilled <= pullIntoDescriptor.bytesLength,
+         "pullIntoDescriptor should not be filled beyond its capacity");
+
+  // Step 4: Assert: bytesFilled mod elementSize is 0.
+  assert(bytesFilled % elementSize === 0,
+         "pullIntoDescriptor should be filled in multiples of its elementSize");
+
+  // Step 5: Return ! Construct(pullIntoDescriptor.[[ctor]],
+  //                            pullIntoDescriptor.[[buffer]],
+  //                            pullIntoDescriptor.[[byteOffset]],
+  //                            bytesFilled / elementSize).
+  return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer,
+                                     pullIntoDescriptor.byteOffset,
+                                     bytesFilled / elementSize);
+}
+
+// Streams spec, 3.12.8. ReadableByteStreamControllerEnqueue ( controller, chunk )
+function ReadableByteStreamControllerEnqueue(controller, chunk) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT),
+         "controller should not have a close requested");
+
+  // Step 3: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE,
+         "controller's stream should be in the readable state");
+
+  // Step 4: Let buffer be chunk.[[ViewedArrayBuffer]].
+  // TODO: assert and use slot?
+  let buffer = chunk.buffer;
+
+  // Step 5: Let byteOffset be chunk.[[ByteOffset]].
+  let byteOffset = chunk.byteOffset;
+
+  // Step 6: Let byteLength be chunk.[[ByteLength]].
+  let byteLength = chunk.byteLength;
+
+  // Step 7: Let transferredBuffer be ! SameRealmTransfer(buffer).
+  let transferredBuffered = SameRealmTransfer(buffer);
+
+  // Step 8: If ! ReadableStreamHasDefaultReader(stream) is true
+  if (ReadableStreamHasDefaultReader(stream)) {
+    // Step a: If ! ReadableStreamGetNumReadRequests(stream) is 0,
+    if (ReadableStreamGetNumReadRequests(stream) === 0) {
+      // Step i: Perform
+      //         ! ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+      //                                                           transferredBuffer,
+      //                                                           byteOffset,
+      //                                                           byteLength).
+      ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+                                                      transferredBuffer,
+                                                      byteOffset, byteLength);
+    }
+
+    // Step b: Otherwise,
+    else {
+      // Step i: Assert: controller.[[queue]] is empty.
+      assert(UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT).length === 0,
+             "controller queue must be empty");
+
+      // Step ii: Let transferredView be
+      //          ! Construct(%Uint8Array%, transferredBuffer, byteOffset, byteLength).
+      let transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
+
+      // Step iii: Perform ! ReadableStreamFulfillReadRequest(stream, transferredView, false).
+      ReadableStreamFulfillReadRequest(stream, transferredView, false);
+    }
+  }
+
+  // Step 9: Otherwise,
+  else {
+    // Step a: If ! ReadableStreamHasBYOBReader(stream) is true,
+    if (ReadableStreamHasBYOBReader(stream)) {
+      // Step i: Perform
+      //         ! ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+      //                                                           transferredBuffer,
+      //                                                           byteOffset,
+      //                                                           byteLength).
+      ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+                                                      transferredBuffer,
+                                                      byteOffset, byteLength);
+
+      // Step ii: Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
+      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
+    }
+
+    // Step b: Otherwise,
+    else {
+      // Step i: Assert: ! IsReadableStreamLocked(stream) is false.
+      assert(!IsReadableStreamLocked(stream),
+             "stream must be unlocked if there is neither a byob or default reader");
+
+      // Step ii: Perform
+      //          ! ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+      //                                                            transferredBuffer,
+      //                                                            byteOffset,
+      //                                                            byteLength).
+      ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+                                                      transferredBuffer,
+                                                      byteOffset, byteLength);
+    }
+  }
+}
+
+// Streams spec, 3.12.9. ReadableByteStreamControllerEnqueueChunkToQueue ( controller, buffer, byteOffset, byteLength )
+function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer,
+                                                         byteOffset, byteLength) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Append Record {[[buffer]]: buffer,
+  //                        [[byteOffset]]: byteOffset,
+  //                        [[byteLength]]: byteLength}
+  //         as the last element of controller.[[queue]].
+  let queue =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT);
+  let record = new Record();
+  record.buffer = buffer;
+  record.byteOffset = byteOffset;
+  record.byteLength = byteLength;
+  ArrayStaticPush(queue, record);
+
+  // Step 2: Add byteLength to controller.[[totalQueuedBytes]].
+  let totalQueuedBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  totalQueuedBytes += byteLength;
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+}
+
+// Streams spec, 3.12.10. ReadableByteStreamControllerError ( controller, e )
+function ReadableByteStreamControllerError(controller, e) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Assert: stream.[[state]] is "readable".
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE,
+         "controller's stream should be in the readable state");
+
+  // Step 3: Perform ! ReadableByteStreamControllerClearPendingPullIntos(controller).
+  ReadableByteStreamControllerClearPendingPullIntos(controller);
+
+  // Step 4: Let controller.[[queue]] be a new empty List.
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT,
+                        new List());
+
+  // Step 5: Perform ! ReadableStreamError(stream, e).
+  ReadableStreamError(stream, e);
+}
+
+// Streams spec, 3.12.11. ReadableByteStreamControllerFillHeadPullIntoDescriptor ( controler, size, pullIntoDescriptor )
+function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size,
+                                                                pullIntoDescriptor) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Assert: either controller.[[pendingPullIntos]] is empty, or the
+  //         first element of controller.[[pendingPullIntos]] is pullIntoDescriptor.
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  assert(pendingPullIntos.length === 0 || pendingPullIntos[0] === pullIntoDescritpor,
+         "pullIntoDescriptor should be first pending pull into");
+
+  // Step 2: Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
+  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
+
+  // Step 3: Set pullIntoDescriptor.[[bytesFilled]] to pullIntoDescriptor.[[bytesFilled]] + size.
+  pullIntoDescriptor.bytesFilled += size;
+}
+
+// Streams spec, 3.12.12. ReadableByteStreamControllerFillPullIntoDescriptorFromQueue ( controller, pullIntoDescriptor )
+function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let elementSize be pullIntoDescriptor.[[elementSize]].
+  let elementSize = pullIntoDescriptor.elementSize;
+
+  // Step 2: Let currentAlignedBytes be pullIntoDescriptor.[[bytesFilled]] −
+  //         (pullIntoDescriptor.[[bytesFilled]] mod elementSize).
+  let currentAlignedBytes = pullIntoDescriptor.bytesFilled -
+    (pullIntoDescriptor.bytesFilled % elementSize);
+
+  // Step 3: Let maxBytesToCopy be min(controller.[[totalQueuedBytes]],
+  //         pullIntoDescriptor.[[byteLength]] − pullIntoDescriptor.[[bytesFilled]]).
+  let totalQueuedBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  let maxBytesToCopy = std_Math_min(totalQueuedBytes,
+    pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
+
+  // Step 4: Let maxBytesFilled be pullIntoDescriptor.[[bytesFilled]] + maxBytesToCopy.
+  let maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
+
+  // Step 5: Let maxAlignedBytes be maxBytesFilled − (maxBytesFilled mod elementSize).
+  let maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);
+
+  // Step 6: Let totalBytesToCopyRemaining be maxBytesToCopy.
+  let totalBytesToCopyRemaining = maxBytesToCopy;
+
+  // Step 7: Let ready be false.
+  let ready = false;
+
+  // Step 8: If maxAlignedBytes > currentAlignedBytes,
+  if (maxAlignedBytes > currentAlignedBytes) {
+    // Step a: Set totalBytesToCopyRemaining to maxAlignedBytes −
+    //         pullIntoDescriptor.[[bytesFilled]].
+    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
+
+    // Step b: Let ready be true.
+    ready = true;
+  }
+
+  // Step 9: Let queue be controller.[[queue]].
+  let queue =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_QUEUE_SLOT);
+
+  // Step 10: Repeat the following steps while totalBytesToCopyRemaining > 0,
+  while (totalBytesToCopyRemaining > 0) {
+    assert(queue.length > 0, "queue must not be empty if we have bytes to copy");
+
+    // Step a: Let headOfQueue be the first element of queue.
+    let headOfQueue = queue[0];
+
+    // Step b: Let bytesToCopy be min(totalBytesToCopyRemaining,
+    //                                headOfQueue.[[byteLength]]).
+    let bytesToCopy = std_Math_min(totalBytesToCopyRemaining,
+                                   headOfQueue.byteLength);
+
+    // Step c: Let destStart be pullIntoDescriptor.[[byteOffset]] +
+    //         pullIntoDescriptor.[[bytesFilled]].
+    let destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
+
+    // Step d: Perform ! CopyDataBlockBytes(headOfQueue.[[buffer]].[[ArrayBufferData]],
+    //                                      headOfQueue.[[byteOffset]],
+    //                                      pullIntoDescriptor.[[buffer]].[[ArrayBufferData]],
+    //                                      destStart, bytesToCopy).
+    // TODO: fix this... we need toIndex
+    //ArrayBufferCopyData(headOfQueue.buffer, pullIntoDescriptor,
+
+    // Step e: If headOfQueue.[[byteLength]] is bytesToCopy,
+    if (headOfQueue.byteLength === bytesToCopy) {
+      // Step i: Remove the first element of queue, shifting all other elements
+      //         downward (so that the second becomes the first, and so on).
+      ArrayStaticShift(queue);
+    }
+
+    // Step f: Otherwise,
+    else {
+      // Step i: Set headOfQueue.[[byteOffset]] to headOfQueue.[[byteOffset]] +
+      //         bytesToCopy.
+      headOfQueue.byteOffset += bytesToCopy;
+
+      // Step ii: Set headOfQueue.[[byteLength]] to headOfQueue.[[byteLength]] −
+      //          bytesToCopy.
+      headOfQueue.byteLength -= bytesToCopy;
+    }
+
+    // Step g: Set controller.[[totalQueuedBytes]] to
+    //         controller.[[totalQueuedBytes]] − bytesToCopy.
+    totalQueuedBytes =
+      UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+    totalQueuedBytes -= bytesToCopy;
+    UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT,
+                          totalQueuedBytes);
+
+    // Step h: Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,
+    //                                                                          bytesToCopy,
+    //                                                                          pullIntoDescriptor).
+    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,
+                                                           bytesToCopy,
+                                                           pullIntoDescriptor);
+
+    // Step i: Set totalBytesToCopyRemaining to totalBytesToCopyRemaining − bytesToCopy.
+    totalBytesToCopyRemaining -= bytesToCopy;
+  }
+
+  // Step 11: If ready is false,
+  if (!ready) {
+    // Step a: Assert: controller.[[totalQueuedBytes]] is 0.
+    assert(UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT) === 0,
+           "should have no queued bytes");
+
+    // Step b: Assert: pullIntoDescriptor.[[bytesFilled]] > 0.
+    assert(pullIntoDescriptor.bytesFilled > 0, "should have filled some bytes");
+
+    // Step c: Assert: pullIntoDescriptor.[[bytesFilled]] <
+    //         pullIntoDescriptor.[[elementSize]].
+    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize,
+           "if not ready, then should not have enough bytes for a single element");
+  }
+
+  // Step 12: Return ready.
+  return ready;
+}
+
+// Streams spec 3.12.13. ReadableByteStreamControllerGetDesiredSize ( controller )
+function ReadableByteStreamControllerGetDesiredSize(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Return controller.[[strategyHWM]] − controller.[[totalQueuedBytes]].
+  let strategyHWM =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_STRATEGY_HWM_SLOT);
+  let totalQueuedBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  return strategyHWM - totalQueuedBytes;
+}
+
+// Streams spec 3.12.14. ReadableByteStreamControllerHandleQueueDrain ( controller )
+function ReadableByteStreamControllerHandleQueueDrain(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Assert: controller.[[controlledReadableStream]].[[state]] is "readable".
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  assert(UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE,
+         "controller's stream must be in the readable state");
+
+  // Step 2: If controller.[[totalQueuedBytes]] is 0 and
+  //         controller.[[closeRequested]] is true,
+  let totalQueueBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (totalQueueBytes === 0 && closeRequested) {
+    // Step a: Perform ! ReadableStreamClose(controller.[[controlledReadableStream]]).
+    ReadableStreamClose(stream);
+  }
+
+  // Step 3: Otherwise,
+  else {
+    // Step a: Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
+    ReadableByteStreamControllerCallPullIfNeeded(controller);
+  }
+}
+
+// Streams spec 3.12.15. ReadableByteStreamControllerInvalidateBYOBRequest ( controller )
+function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: If controller.[[byobRequest]] is undefined, return.
+  let byobRequest =
+    UnsafeGetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT);
+  if (byobRequest === undefined) {
+    return;
+  }
+
+  // Step 2: Set controller.[[byobRequest]].[[associatedReadableByteStreamController]]
+  //         to undefined.
+  UnsafeSetReservedSlot(byobRequest, READABLESTREAMBYOBREQUEST_ASSOCIATED_READABLEBYTESTREAMCONTROLLER_SLOT,
+                        undefined);
+
+  // Step 3: Set controller.[[byobRequest]].[[view]] to undefined.
+  UnsafeSetReservedSlot(byobRequest, READABLESTREAMBYOBREQUEST_VIEW_SLOT,
+                        undefined);
+
+  // Step 4: Set controller.[[byobRequest]] to undefined.
+  UnsafeSetReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_BYOB_REQUEST_SLOT,
+                        undefined);
+}
+
+// Streams spec 3.12.16. ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue ( controller )
+function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Assert: controller.[[closeRequested]] is false.
+  assert(!UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT),
+         "controller must not be closing");
+
+  // Step 2: Repeat the following steps while controller.[[pendingPullIntos]]
+  //         is not empty,
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  while (pendingPullIntos.length > 0) {
+    // Step a: If controller.[[totalQueuedBytes]] is 0, return.
+    let totalQueuedBytes =
+      UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+    if (totalQueuedBytes === 0) {
+      return;
+    }
+
+    // Step b: Let pullIntoDescriptor be the first element of
+    //         controller.[[pendingPullIntos]].
+    let pullIntoDescriptor = pendingPullIntos[0];
+
+    // Step c: If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)
+    //         is true,
+    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,
+                                                                    pullIntoDescriptor)) {
+      // Step i: Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
+      ReadableByteStreamControllerShiftPendingPullInto(controller);
+
+      // Step ii: Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]],
+      //                                                                         pullIntoDescriptor).
+      let stream =
+        UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+      assert(IsReadableStream(stream), "controller should have a ReadableStream");
+      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
+    }
+
+    assert(pendingPullIntos ===
+           UnsafeGetObjectFrom(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT),
+           "the pendingPullIntos list should not have been replaced");
+  }
+}
+
+// Streams spec, 3.12.17. ReadableByteStreamControllerPullInto ( controller, view )
+function ReadableByteStreamControllerPullInto(controller, view) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: Let elementSize be 1.
+  let elementSize = 1;
+
+  // Step 3: Let ctor be %DataView%.
+  let ctor = DataView;
+
+  // Step 4: If view has a [[TypedArrayName]] internal slot (i.e., it is not a
+  //         DataView),
+  if (IsTypedArray(view)) {
+    // Step a: Set elementSize to the element size specified in the typed array
+    //         constructors table for view.[[TypedArrayName]].
+    // Step b: Set ctor to the constructor specified in the typed array
+    //         constructors table for view.[[TypedArrayName]].
+    // TODO: does not properly handle clamped array or float64 array
+    // TODO: make a new intrinsic that does the right thing here
+    if (IsUint8TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Uint8Array");
+    } else if (IsInt8TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Int8Array");
+    } else if (IsUint16TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Uint16Array");
+    } else if (IsInt16TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Int16Array");
+    } else if (IsUint32TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Uint32Array");
+    } else if (IsInt32TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Int32Array");
+    } else if (IsFloat32TypedArray(view)) {
+      ctor = GetBuiltinConstructor("Float32Array");
+    }
+    elementSize = ctor.BYTES_PER_ELEMENT;
+  }
+
+  // Step 5: Let pullIntoDescriptor be Record {[[buffer]]: view.[[ViewedArrayBuffer]],
+  //                                           [[byteOffset]]: view.[[ByteOffset]],
+  //                                           [[byteLength]]: view.[[ByteLength]],
+  //                                           [[bytesFilled]]: 0,
+  //                                           [[elementSize]]: elementSize,
+  //                                           [[ctor]]: ctor,
+  //                                           [[readerType]]: "byob"}.
+  let pullIntoDescriptor = new Record();
+  pullIntoDescriptor.buffer = view.buffer;
+  pullIntoDescriptor.byteOffset = view.byteOffset;
+  pullIntoDescriptor.byteLength = view.byteLength;
+  pullIntoDescriptor.bytesFilled = 0;
+  pullIntoDescriptor.elementSize = elementSize;
+  pullIntoDescriptor.ctor = ctor;
+  pullIntoDescriptor.readerType = "byob";
+
+  // Step 6: If controller.[[pendingPullIntos]] is not empty,
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  if (pendingPullIntos > 0) {
+    // Step a: Set pullIntoDescriptor.[[buffer]] to
+    //         ! SameRealmTransfer(pullIntoDescriptor.[[buffer]]).
+    pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
+
+    // Step b: Append pullIntoDescriptor as the last element of
+    //         controller.[[pendingPullIntos]].
+    ArrayStaticPush(pendingPullIntos, pullIntoDescriptor);
+
+    // Step c: Return ! ReadableStreamAddReadIntoRequest(stream).
+    return ReadableStreamAddReadIntoRequest(stream);
+  }
+
+  // Step 7: If stream.[[state]] is "closed",
+  let state = UnsafeGetInt32FromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    // Step a: Let emptyView be ! Construct(ctor, view.[[buffer]],
+    //                                            view.[[byteOffset]], 0).
+    let emptyView = new ctor(view.buffer, view.byteOffset, 0);
+
+    // Step b: Return a promise resolved with
+    //         ! CreateIterResultObject(emptyView, true).
+    return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                        CreateIterResultObject(emptyView, true));
+  }
+
+  // Step 8: If controller.[[totalQueuedBytes]] > 0,
+  let totalQueuedBytes =
+    UnsafeGetInt32FromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_TOTAL_QUEUED_BYTES_SLOT);
+  if (totalQueuedBytes > 0) {
+    // Step a: If ! ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,
+    //                                                                          pullIntoDescriptor)
+    //         is true,
+    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller,
+                                                                    pullIntoDescriptor)) {
+      // Step i: Let filledView be
+      //         ! ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor).
+      let filledView =
+        ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
+
+      // Step ii: Perform ! ReadableByteStreamControllerHandleQueueDrain(controller).
+      ReadableByteStreamControllerHandleQueueDrain(controller);
+
+      // Step iii: Return a promise resolved with
+      //           ! CreateIterResultObject(filledView, false).
+      return callFunction(Promise_static_resolve, GetPromiseCtor(),
+                          CreateIterResultObject(filledView, false));
+    }
+
+    // Step b: If controller.[[closeRequested]] is true,
+    let closeRequested =
+      UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+    if (closeRequested) {
+      try {
+        // Step i: Let e be a TypeError exception.
+        ThrowTypeError(JSMSG_READABLESTREAMCONTROLLER_CLOSED, "read");
+      } catch (e) {
+        // Step ii: Perform ! ReadableByteStreamControllerError(controller, e).
+        ReadableByteStreamControllerError(controller, e);
+
+        // Step iii: Return a promise rejected with e.
+        return callFunction(Promise_static_reject, GetPromiseCtor(), e);
+      }
+    }
+  }
+
+  // Step 9: Set pullIntoDescriptor.[[buffer]] to
+  //         ! SameRealmTransfer(pullIntoDescriptor.[[buffer]]).
+  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
+
+  // Step 10: Append pullIntoDescriptor as the last element of
+  //          controller.[[pendingPullIntos]].
+  ArrayStaticPush(pendingPullIntos, pullIntoDescriptor);
+
+  // Step 11: Let promise be ! ReadableStreamAddReadIntoRequest(stream).
+  let promise = ReadableStreamAddReadIntoRequest(stream);
+
+  // Step 12: Perform ! ReadableByteStreamControllerCallPullIfNeeded(controller).
+  ReadableByteStreamControllerCallPullIfNeeded(controller);
+
+  // Step 13: Return promise.
+  return promise;
+}
+
+// Streams spec 3.12.18. ReadableByteStreamControllerRespond( controller, bytesWritten )
+function ReadableByteStreamControllerRespond(controller, bytesWritten) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let bytesWritten be ? ToNumber(bytesWritten).
+  bytesWritten = ToNumber(bytesWritten);
+
+  // Step 2: If ! IsFiniteNonNegativeNumber(bytesWritten) is false,
+  if (Number_isNaN(bytesWritten) || !Number_isFinite(bytesWritten) ||
+      bytesWritten < 0) {
+    ThrowSomething("RangeError", "bytesWritten NaN, Infinity or < 0");
+  }
+
+  // Step 3: Assert: controller.[[pendingPullIntos]] is not empty.
+  assert(UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT).length !== 0,
+         "controller must have at least one pending operation");
+
+  // Step 4: Perform ? ReadableByteStreamControllerRespondInternal(controller, bytesWritten).
+  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
+}
+
+// Streams spec 3.12.19. ReadableByteStreamControllerRespondInClosedState( controller, firstDescriptor )
+function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Set firstDescriptor.[[buffer]] to
+  //         ! SameRealmTransfer(firstDescriptor.[[buffer]]).
+  firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer);
+
+  // Step 2: Assert: firstDescriptor.[[bytesFilled]] is 0.
+  assert(firstDescriptor.bytesFilled === 0, "first descriptor should be empty");
+
+  // Step 3: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 4: Repeat the following steps while
+  //         ! ReadableStreamGetNumReadIntoRequests(stream) > 0,
+  while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
+    // Step a: Let pullIntoDescriptor be
+    //         ! ReadableByteStreamControllerShiftPendingPullInto(controller).
+    let pullIntoDescriptor =
+      ReadableByteStreamControllerShiftPendingPullInto(controller);
+
+    // Step b: Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor).
+    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
+  }
+}
+
+// Streams spec 3.12.20. ReadableByteStreamControllerRespondInReadableState( controller, bytesWritten, pullIntoDescriptor )
+function ReadableByteStreamControllerRespondInReadableState(controller,
+                                                            bytesWritten,
+                                                            pullIntoDescriptor) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: If pullIntoDescriptor.[[bytesFilled]] + bytesWritten > pullIntoDescriptor.[[byteLength]],
+  //         throw a RangeError exception.
+  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
+    ThrowSomething("RangeError", "bytesWritten exceeds remaining length");
+  }
+
+  // Step 2: Perform ! ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller,
+  //                                                                          bytesWritten,
+  //                                                                          pullIntoDescriptor).
+  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten,
+                                                         pullIntoDescriptor);
+
+  // Step 3: If pullIntoDescriptor.[[bytesFilled]] <
+  //         pullIntoDescriptor.[[elementSize]], return.
+  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
+    return;
+  }
+
+  // Step 4: Perform ! ReadableByteStreamControllerShiftPendingPullInto(controller).
+  ReadableByteStreamControllerShiftPendingPullInto(controller);
+
+  // Step 5: Let remainderSize be pullIntoDescriptor.[[bytesFilled]] mod
+  //         pullIntoDescriptor.[[elementSize]].
+  let remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
+
+  // Step 6: If remainderSize > 0,
+  if (remainderSize > 0) {
+    // Step a: Let end be pullIntoDescriptor.[[byteOffset]] +
+    //         pullIntoDescriptor.[[bytesFilled]].
+    let end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
+
+    // Step b: Let remainder be ? CloneArrayBuffer(pullIntoDescriptor.[[buffer]],
+    //                                             end − remainderSize,
+    //                                             remainderSize, %ArrayBuffer%).
+    // TODO
+
+    // Step c: Perform ! ReadableByteStreamControllerEnqueueChunkToQueue(controller,
+    //                                                                   remainder, 0,
+    //                                                                   remainder.[[ByteLength]]).
+    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0,
+                                                    remainder.byteLength);
+  }
+
+  // Step 7: Set pullIntoDescriptor.[[buffer]] to
+  //         ! SameRealmTransfer(pullIntoDescriptor.[[buffer]]).
+  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
+
+  // Step 8: Set pullIntoDescriptor.[[bytesFilled]] to pullIntoDescriptor.[[bytesFilled]] −
+  //         remainderSize.
+  pullIntoDescriptor.bytesFilled -= remainderSize;
+
+  // Step 9: Perform ! ReadableByteStreamControllerCommitPullIntoDescriptor(controller.[[controlledReadableStream]],
+  //                                                                        pullIntoDescriptor).
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+  ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
+
+  // Step 10: Perform ! ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller).
+  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
+}
+
+// Streams spec, 3.12.21. ReadableByteStreamControllerRespondInternal ( controller, bytesWritten )
+function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let firstDescriptor be the first element of controller.[[pendingPullIntos]].
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  let firstDescriptor = pendingPullIntos[0];\
+
+  // Step 2: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 3: If stream.[[state]] is "closed",
+  let state = UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state === READABLESTREAM_CLOSED_STATE) {
+    // Step a: If bytesWritten is not 0, throw a TypeError exception.
+    if (bytesWritten !== 0) {
+      ThrowTypeError(JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_CLOSED);
+    }
+
+    // Step b: Perform
+    //         ! ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor).
+    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
+  }
+
+  // Step 4: Otherwise,
+  else {
+    // Step a: Assert: stream.[[state]] is "readable".
+    assert(state === READABLESTREAM_READABLE_STATE,
+           "stream should be readable");
+
+    // Step b: Perform ? ReadableByteStreamControllerRespondInReadableState(controller,
+    //                                                                      bytesWritten,
+    //                                                                      firstDescriptor).
+    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten,
+                                                       firstDescriptor);
+  }
+}
+
+// Streams spec, 3.12.22. ReadableByteStreamControllerRespondWithNewView ( controller, view )
+function ReadableByteStreamControllerRespondWithNewView(controller, view) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Assert: controller.[[pendingPullIntos]] is not empty.
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  assert(pendingPullIntos.length > 0,
+         "controller should have a pending request");
+
+  // Step 2: Let firstDescriptor be the first element of controller.[[pendingPullIntos]].
+  let firstDescriptor = pendingPullIntos[0];
+
+  // Step 3: If firstDescriptor.[[byteOffset]] + firstDescriptor.[[bytesFilled]]
+  //         is not view.[[ByteOffset]], throw a RangeError exception.
+  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
+    ThrowSomething("RangeError", "view size does not match requested data");
+  }
+
+  // Step 4: If firstDescriptor.[[byteLength]] is not view.[[ByteOffset]],
+  //         throw a RangeError exception.
+  if (firstDescriptor.byteLength !== view.byteOffset) {
+    ThrowSomething("RangeError", "view offset does not match requested position");
+  }
+
+  // Step 5: Set firstDescriptor.[[buffer]] to view.[[ViewedArrayBuffer]].
+  firstDescriptor.buffer = view.buffer;
+
+  // Step 6: Perform ? ReadableByteStreamControllerRespondInternal(controller,
+  //                                                               view.[[ByteLength]]).
+  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
+}
+
+// Streams spec, 3.12.23. ReadableByteStreamControllerShiftPendingPullInto ( controller )
+function ReadableByteStreamControllerShiftPendingPullInto(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let descriptor be the first element of controller.[[pendingPullIntos]].
+  // Step 2: Remove descriptor from controller.[[pendingPullIntos]], shifting
+  //         all other elements downward (so that the second becomes the first,
+  //         and so on).
+  let pendingPullIntos =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_PENDING_PULL_INTOS_SLOT);
+  let descriptor = ArrayStaticShift(pendingPullIntos);
+
+  // Step 3: Perform ! ReadableByteStreamControllerInvalidateBYOBRequest(controller).
+  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
+
+  // Step 4: Return descriptor.
+  return descriptor;
+}
+
+// Streams spec, 3.12.24. ReadableByteStreamControllerShouldCallPull ( controller )
+function ReadableByteStreamControllerShouldCallPull(controller) {
+  assert(IsReadableByteStreamController(controller),
+         "must operate on ReadableByteStreamController");
+
+  // Step 1: Let stream be controller.[[controlledReadableStream]].
+  let stream =
+    UnsafeGetObjectFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT);
+  assert(IsReadableStream(stream), "controller should have a ReadableStream");
+
+  // Step 2: If stream.[[state]] is not "readable", return false.
+  let state = UnsafeGetBooleanFromReservedSlot(stream, READABLESTREAM_STATE_SLOT);
+  if (state !== READABLESTREAM_READABLE_STATE) {
+    return false;
+  }
+
+  // Step 3: If controller.[[closeRequested]] is true, return false.
+  let closeRequested =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_CLOSE_REQUESTED_SLOT);
+  if (closeRequested) {
+    return false;
+  }
+
+  // Step 4: If controller.[[started]] is false, return false.
+  let started =
+    UnsafeGetBooleanFromReservedSlot(controller, READABLEBYTESTREAMCONTROLLER_STARTED_SLOT);
+  if (!started) {
+    return false;
+  }
+
+  // Step 5: If ! ReadableStreamHasDefaultReader(stream) is true and
+  //         ! ReadableStreamGetNumReadRequests(stream) > 0, return true.
+  if (ReadableStreamHasDefaultReader(stream) &&
+      ReadableStreamGetNumReadRequests(stream) > 0) {
+    return true;
+  }
+
+  // Step 6: If ! ReadableStreamHasBYOBReader(stream) is true and
+  //         ! ReadableStreamGetNumReadIntoRequests(stream) > 0, return true.
+  if (ReadableStreamHasBYOBReader(stream) &&
+      ReadableStreamGetNumReadIntoRequests(stream) > 0) {
+    return true;
+  }
+
+  // Step 7: If ! ReadableByteStreamControllerGetDesiredSize(controller) > 0,
+  //         return true.
+  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
+    return true;
+  }
+
+  // Step 8: Return false.
+  return false;
+}
+
+// TODO: continue here
 
 // Streams spec, 3.3.1. Class Definition
 function ReadableStreamController(stream) {
   if (!IsObject(this) || !IsReadableStreamController(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
   }
   if (!IsObject(this) || !IsReadableStream(stream)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ReadableStreamController", typeof stream);
@@ -425,22 +3580,16 @@ function FinishClosingReadableStream(str
 // Streams spec, 3.5.7. GetReadableStreamDesiredSize ( stream )
 function GetReadableStreamDesiredSize(stream) {
   let queueSize = GetTotalQueueSize(
     UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT));
   let streamHWM = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_HWM_SLOT);
   return streamHWM - queueSize;
 }
 
-// Streams spec, 3.5.11. IsReadableStreamLocked ( stream )
-function IsReadableStreamLocked(stream) {
-  assert(IsReadableStream(stream), "IsReadableStream(stream)");
-  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
-}
-
 // Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
 function ReadFromReadableStreamReader(reader) {
   let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
   let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
   if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
     return callFunction(Promise_static_resolve, GetPromiseCtor(), CreateIterResultObject(undefined, true));
@@ -516,21 +3665,16 @@ function ShouldReadableStreamPull(stream
     if (readerReadRequests.length !== 0) {
       return true;
     }
   }
   let desiredSize = GetReadableStreamDesiredSize(stream);
   return desiredSize > 0;
 }
 
-// Streams spec, 3.5.16. TeeReadableStream ( stream, shouldClone )
-function TeeReadableStream(stream, shouldClone) {
-  ThrowSomething("Error", "Not implemented TeeReadableStream");
-}
-
 // Streams spec, 6.3.1. DequeueValue ( queue )
 function DequeueValue(queue) {
   var pair = callFunction(std_Array_shift, queue);
   return pair.value;
 }
 
 // Streams spec, 6.3.2. EnqueueValueWithSize ( queue, value, size )
 function EnqueueValueWithSize(queue, value, size) {
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -80,29 +80,21 @@
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
 #define PROMISE_REJECTION_TRACKER_OPERATION_REJECT false
 #define PROMISE_REJECTION_TRACKER_OPERATION_HANDLE true
 
 // Used for ReadableStream.
-#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
-#define READABLESTREAM_CONTROLLER_SLOT 1
-#define READABLESTREAM_DISTURBED_SLOT 2
-#define READABLESTREAM_PULL_AGAIN_SLOT 3
-#define READABLESTREAM_PULLING_SLOT 4
-#define READABLESTREAM_QUEUE_SLOT 5
-#define READABLESTREAM_READER_SLOT 6
-#define READABLESTREAM_STARTED_SLOT 7
-#define READABLESTREAM_STATE_SLOT 8
-#define READABLESTREAM_STORED_ERROR_SLOT 9
-#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
-#define READABLESTREAM_STRATEGY_HWM_SLOT 11
-#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+#define READABLESTREAM_CONTROLLER_SLOT 0
+#define READABLESTREAM_DISTURBED_SLOT 1
+#define READABLESTREAM_READER_SLOT 2
+#define READABLESTREAM_STATE_SLOT 3
+#define READABLESTREAM_STORED_ERROR_SLOT 4
 
 #define READABLESTREAM_READABLE_STATE 0
 #define READABLESTREAM_CLOSED_STATE 1
 #define READABLESTREAM_ERRORED_STATE 2
 
 #define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
 
 #define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
diff --git a/js/src/js.msg b/js/src/js.msg
--- a/js/src/js.msg
+++ b/js/src/js.msg
@@ -534,8 +534,25 @@ MSG_DEF(JSMSG_MISSING_NAMESPACE_EXPORT, 
 MSG_DEF(JSMSG_MISSING_EXPORT,            1, JSEXN_SYNTAXERR, "local binding for export '{0}' not found")
 
 // Promise
 MSG_DEF(JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF,       0, JSEXN_TYPEERR, "A promise cannot be resolved with itself.")
 MSG_DEF(JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY, 0, JSEXN_TYPEERR, "GetCapabilitiesExecutor function already invoked with non-undefined values.")
 MSG_DEF(JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE,    0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the resolve function.")
 MSG_DEF(JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE,     0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the reject function.")
 MSG_DEF(JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON,0, JSEXN_INTERNALERR, "Promise rejection value is a non-unwrappable cross-compartment wrapper.")
+
+// ReadableStream
+MSG_DEF(JSMSG_READABLESTREAM_NOT_LOCKED,                 1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on a locked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_LOCKED,                     1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on an unlocked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER, 0, JSEXN_TYPEERR, "ReadableStream.getReader('byob') requires a ReadableByteStreamController.")
+MSG_DEF(JSMSG_READABLESTREAM_CONTROLLER_SET,             0, JSEXN_TYPEERR, "The ReadableStream already has a controller defined.")
+MSG_DEF(JSMSG_READABLESTREAMDEFAULTREADER_NOT_OWNED,     1, JSEXN_TYPEERR, "ReadableStreamDefaultReader method '{0}' may only be called on a reader owned by a stream.")
+MSG_DEF(JSMSG_READABLESTREAMDEFAULTREADER_NOT_EMPTY,     1, JSEXN_TYPEERR, "ReadableStreamDefaultReader method '{0}' may not be called on a reader with read requests.")
+MSG_DEF(JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW,  0, JSEXN_TYPEERR, "ReadableStreamBYOBReader.read() was passed an empty TypedArrayBuffer view.")
+MSG_DEF(JSMSG_READABLESTREAMREADER_RELEASED,             0, JSEXN_TYPEERR, "The ReadableStream reader was released.")
+MSG_DEF(JSMSG_READABLESTREAMCONTROLLER_CLOSED,           1, JSEXN_TYPEERR, "The ReadableStream controller method '{0}' called on a stream already closing.")
+MSG_DEF(JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE,     1, JSEXN_TYPEERR, "The ReadableStream controller method '{0}' may only be called on a stream in the 'readable' state.")
+MSG_DEF(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE,0, JSEXN_RANGEERR, "ReadableByteStreamController requires a positive integer or undefined for 'autoAllocateChunkSize'.")
+MSG_DEF(JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK,    0, JSEXN_TYPEERR, "ReadableByteStreamController passed a bad chunk.")
+MSG_DEF(JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL, 0, JSEXN_TYPEERR, "The ReadableByteStreamController cannot be closed while the buffer is being filled.")
+MSG_DEF(JSMSG_READABLESTREAMBYOBREADER_NO_CONTROLLER,    1, JSEXN_TYPEERR, "ReadableStreamBYOBRequest method '{0}' called on a request with no controller.")
+MSG_DEF(JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_CLOSED,  0, JSEXN_TYPEERR, "ReadableStreamBYOBRequest method 'respond' called with non-zero number of bytes with a closed controller.")
