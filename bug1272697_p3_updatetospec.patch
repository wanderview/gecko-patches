# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  7f7bb62c242f92a4f7e8dbbcb06b63ad8b53a01b
Bug 1272697 P3 Update to latest ReadableStream spec. r=till

diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
--- a/js/src/builtin/ReadableStream.h
+++ b/js/src/builtin/ReadableStream.h
@@ -11,17 +11,17 @@
 
 namespace js {
 
 class AutoSetNewObjectMetadata;
 
 class ReadableStream : public NativeObject
 {
   public:
-    static const unsigned RESERVED_SLOTS = 13;
+    static const unsigned RESERVED_SLOTS = 5;
     static const ClassSpec classSpec_;
     static const Class class_;
     static const ClassSpec protoClassSpec_;
     static const Class protoClass_;
 };
 
 class ReadableStreamController : public NativeObject
 {
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -1,69 +1,65 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Streams spec, 3.2.3.
-function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+function ReadableStream(underlyingSource = {}, {size, highWaterMark} = {}) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
   }
-  if (underlyingSource === undefined) {
-    underlyingSource = {};
-  }
-  if (highWaterMark === undefined) {
-    highWaterMark = 1;
+
+  // Step 1. Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
+  // Step 2. Set this@[[reader]] and this@[[storedError]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
+  // Step 3. Set this@[[disturbed]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
+  // Step 4. Set this@[[readableStreamController]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, undefined);
+
+  // Step 5. Let type be ? GetV(underlyingSource, "type").
+  // Step 6. Let typeString be ? ToString(type).
+  // Step 7. If typeString is "bytes",
+  if (underlyingSource.type === "bytes") {
+    // Step a. If highWaterMark is undefined, let highWaterMark be 0.
+    if (highWaterMark === undefined) {
+      highWaterMark = 0;
+    }
+    // Step b. Set this@[[readableStreamController]] to ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
+    let ReadableByteStreamControllerCtor = GetReadableByteStreamControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableByteStreamControllerCtor(this, underlyingSource,
+                                                               highWaterMark));
   }
 
-  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
-  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
-  // Step 2. Set this@[[queue]] to a new empty List.
-  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
-  // Step 3. Set this@[[state]] to "readable".
-  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
-  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
-  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
-  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
-  // Step 6. Set this@[[disturbed]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
-  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
-  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
-  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
+  // Step 8. Otherwise, if type is undefined,
+  else if (underlyingSource.type === undefined) {
+    // Step a. If highWaterMark is undefined, let highWaterMark be 1.
+    if (highWaterMark === undefined) {
+      highWaterMark = 1;
+    }
 
-  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
-  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
-  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
-  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
-  // Step 11. ReturnIfAbrupt(startResult).
-  let startResult = InvokeOrNoop(underlyingSource, "start",
-    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
-  // Step 12. Resolve startResult as a promise:
-  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
-  callFunction(Promise_then, p, () => {
-this._log += 'resolved ' + startResult;
-    // Set this@[[started]] to true.
-    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
-    // Perform RequestReadableStreamPull(this).
-    RequestReadableStreamPull(this);
-  }, (r) => {
-    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
-    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
-      ErrorReadableStream(this, r);
-    }
-  });
+    // Step b. Set this@[[readableStreamController]] to ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
+    let ReadableStreamDefaultControllerCtor = GetReadableStreamDefaultControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableStreamDefaultControllerCtor(this, underlyingSource,
+                                                                  highWaterMark));
+  }
+
+  // Step 9. Otherwise, throw a RangeError exception.
+  else {
+    ThrowSomething("RangeError", "underlyingSource.type must be 'bytes' or undefined");
+  }
 }
 
+// TODO: implement new controller classes
+
 // Streams spec, 3.2.4.1. get locked
 function ReadableStream_locked() {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
   }
 
   return IsReadableStreamLocked(this);
 }
@@ -75,34 +71,53 @@ function ReadableStream_cancel(reason) {
       ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
   if (IsReadableStreamLocked(this)) {
     try {
-      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_LOCKED, "cancel");
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
-function ReadableStream_getReader() {
+function ReadableStream_getReader({ mode } = {}) {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
   }
 
-  return AcquireReadableStreamReader(this);
+  // Step 2: If mode is "byob",
+  if (mode === "byob") {
+    // Step a: If ! IsReadableByteStreamController(this@[[readableStreamController]]) is false, throw a TypeError exception.
+    let controller = UnsafeGetObjectReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT);
+    if (!IsReadableByteStreamController(controller)) {
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER);
+    }
+    // Step b: Return ? AcquireReadableStreamBYOBReader(this).
+    return AcquireReadableStreamBYOBReader(this);
+  }
+
+  // Step 3: Return ? AcquireReadableStreamBYOBReader(this).
+  if (mode === undefined) {
+    return AcquireReadableStreamDefaultReader(this);
+  }
+
+  ThrowSomething("RangeError", "mode must be 'byob' or undefined");
 }
 
+// TODO: continue here
+
 // Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
 function ReadableStream_pipeThrough({ writable, readable }, options) {
   ReadableStream_pipeTo.call(this, writable, options);
   return readable;
 }
 
 // Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
 function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -72,29 +72,21 @@
 #define PROMISE_STATE_PENDING   0
 #define PROMISE_STATE_FULFILLED 1
 #define PROMISE_STATE_REJECTED  2
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
 // Used for ReadableStream.
-#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
-#define READABLESTREAM_CONTROLLER_SLOT 1
-#define READABLESTREAM_DISTURBED_SLOT 2
-#define READABLESTREAM_PULL_AGAIN_SLOT 3
-#define READABLESTREAM_PULLING_SLOT 4
-#define READABLESTREAM_QUEUE_SLOT 5
-#define READABLESTREAM_READER_SLOT 6
-#define READABLESTREAM_STARTED_SLOT 7
-#define READABLESTREAM_STATE_SLOT 8
-#define READABLESTREAM_STORED_ERROR_SLOT 9
-#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
-#define READABLESTREAM_STRATEGY_HWM_SLOT 11
-#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+#define READABLESTREAM_CONTROLLER_SLOT 0
+#define READABLESTREAM_DISTURBED_SLOT 1
+#define READABLESTREAM_READER_SLOT 2
+#define READABLESTREAM_STATE_SLOT 3
+#define READABLESTREAM_STORED_ERROR_SLOT 4
 
 #define READABLESTREAM_READABLE_STATE 0
 #define READABLESTREAM_CLOSED_STATE 1
 #define READABLESTREAM_ERRORED_STATE 2
 
 #define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
 
 #define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
diff --git a/js/src/js.msg b/js/src/js.msg
--- a/js/src/js.msg
+++ b/js/src/js.msg
@@ -532,8 +532,12 @@ MSG_DEF(JSMSG_MISSING_NAMESPACE_EXPORT, 
 MSG_DEF(JSMSG_MISSING_EXPORT,            1, JSEXN_SYNTAXERR, "local binding for export '{0}' not found")
 
 // Promise
 MSG_DEF(JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF,       0, JSEXN_TYPEERR, "A promise cannot be resolved with itself.")
 MSG_DEF(JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY, 0, JSEXN_TYPEERR, "GetCapabilitiesExecutor function already invoked with non-undefined values.")
 MSG_DEF(JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE,    0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the resolve function.")
 MSG_DEF(JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE,     0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the reject function.")
 MSG_DEF(JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON,0, JSEXN_INTERNALERR, "Promise rejection value is a non-unwrappable cross-compartment wrapper.")
+
+// ReadableStream
+MSG_DEF(JSMSG_READABLESTREAM_NOT_LOCKED,                 1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on a locked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER, 0, JSEXN_TYPEERR, "ReadableStream.getReader('byob') requires a ReadableByteStreamController.")
