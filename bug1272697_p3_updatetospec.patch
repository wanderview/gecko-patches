# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a1513377dd07d790a383b2802be1d5e2a2990c13
Bug 1272697 P3 Update to latest ReadableStream spec. r=till

diff --git a/js/src/builtin/ReadableStream.h b/js/src/builtin/ReadableStream.h
--- a/js/src/builtin/ReadableStream.h
+++ b/js/src/builtin/ReadableStream.h
@@ -11,17 +11,17 @@
 
 namespace js {
 
 class AutoSetNewObjectMetadata;
 
 class ReadableStream : public NativeObject
 {
   public:
-    static const unsigned RESERVED_SLOTS = 13;
+    static const unsigned RESERVED_SLOTS = 5;
     static const ClassSpec classSpec_;
     static const Class class_;
     static const ClassSpec protoClassSpec_;
     static const Class protoClass_;
 };
 
 class ReadableStreamController : public NativeObject
 {
diff --git a/js/src/builtin/ReadableStream.js b/js/src/builtin/ReadableStream.js
--- a/js/src/builtin/ReadableStream.js
+++ b/js/src/builtin/ReadableStream.js
@@ -1,129 +1,419 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Streams spec, 3.2.3.
-function ReadableStream(underlyingSource, {size, highWaterMark} = {}) {
+function ReadableStream(underlyingSource = {}, {size, highWaterMark} = {}) {
   if (!IsObject(this) || !IsReadableStream(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ctor", typeof this);
   }
-  if (underlyingSource === undefined) {
-    underlyingSource = {};
-  }
-  if (highWaterMark === undefined) {
-    highWaterMark = 1;
+
+  // Step 1: Set this@[[state]] to "readable".
+  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT,
+                        READABLESTREAM_READABLE_STATE);
+  // Step 2: Set this@[[reader]] and this@[[storedError]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
+  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
+  // Step 3: Set this@[[disturbed]] to false.
+  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
+  // Step 4: Set this@[[readableStreamController]] to undefined.
+  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, undefined);
+
+  // Step 5: Let type be ? GetV(underlyingSource, "type").
+  // Step 6: Let typeString be ? ToString(type).
+  // Step 7: If typeString is "bytes",
+  if (underlyingSource.type === "bytes") {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 0.
+    if (highWaterMark === undefined) {
+      highWaterMark = 0;
+    }
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableByteStreamController, « this, underlyingSource, highWaterMark »).
+    let ReadableByteStreamControllerCtor = GetReadableByteStreamControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableByteStreamControllerCtor(this,
+                                                               underlyingSource,
+                                                               highWaterMark));
   }
 
-  // Step 1. Set this@[[underlyingSource]] to underlyingSource.
-  UnsafeSetReservedSlot(this, READABLESTREAM_UNDERLYING_SOURCE_SLOT, underlyingSource);
-  // Step 2. Set this@[[queue]] to a new empty List.
-  UnsafeSetReservedSlot(this, READABLESTREAM_QUEUE_SLOT, new List());
-  // Step 3. Set this@[[state]] to "readable".
-  UnsafeSetReservedSlot(this, READABLESTREAM_STATE_SLOT, READABLESTREAM_READABLE_STATE);
-  // Step 4. Set this@[[started]], this@[[closeRequested]], this@[[pullAgain]], and this@[[pulling]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_CLOSE_REQUESTED_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULL_AGAIN_SLOT, false);
-  UnsafeSetReservedSlot(this, READABLESTREAM_PULLING_SLOT, false);
-  // Step 5. Set this@[[reader]] and this@[[storedError]] to undefined.
-  UnsafeSetReservedSlot(this, READABLESTREAM_READER_SLOT, undefined);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STORED_ERROR_SLOT, undefined);
-  // Step 6. Set this@[[disturbed]] to false.
-  UnsafeSetReservedSlot(this, READABLESTREAM_DISTURBED_SLOT, false);
-  // Step 7. Set this@[[controller]] to Construct(ReadableStreamController, this).
-  var ReadableStreamControllerCtor = GetReadableStreamControllerCtor();
-  UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT, new ReadableStreamControllerCtor(this));
+  // Step 8: Otherwise, if type is undefined,
+  else if (underlyingSource.type === undefined) {
+    // Step a: If highWaterMark is undefined, let highWaterMark be 1.
+    if (highWaterMark === undefined) {
+      highWaterMark = 1;
+    }
 
-  // Step 8. Let normalizedStrategy be ValidateAndNormalizeQueuingStrategy(size, highWaterMark). 
-  let normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
-  // Step 9. Set this@[[strategySize]] to normalizedStrategy.[[size]] and this@[[strategyHWM]] to normalizedStrategy.[[highWaterMark]].
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_SIZE_SLOT, normalizedStrategy.size);
-  UnsafeSetReservedSlot(this, READABLESTREAM_STRATEGY_HWM_SLOT, normalizedStrategy.highWaterMark);
-  // Step 10. Let startResult be InvokeOrNoop(underlyingSource, "start", this@[[controller]]).
-  // Step 11. ReturnIfAbrupt(startResult).
-  let startResult = InvokeOrNoop(underlyingSource, "start",
-    UnsafeGetObjectFromReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT));
-  // Step 12. Resolve startResult as a promise:
-  var p = callFunction(Promise_static_resolve, GetPromiseCtor(), startResult);
-  callFunction(Promise_then, p, () => {
-this._log += 'resolved ' + startResult;
-    // Set this@[[started]] to true.
-    UnsafeSetReservedSlot(this, READABLESTREAM_STARTED_SLOT, true);
-    // Perform RequestReadableStreamPull(this).
-    RequestReadableStreamPull(this);
-  }, (r) => {
-    // If this@[[state]] is "readable", perform ErrorReadableStream(this, r).
-    if (UnsafeGetInt32FromReservedSlot(this, READABLESTREAM_STATE_SLOT) === READABLESTREAM_READABLE_STATE) {
-      ErrorReadableStream(this, r);
-    }
-  });
+    // Step b: Set this@[[readableStreamController]] to
+    //         ? Construct(ReadableStreamDefaultController, « this, underlyingSource, size, highWaterMark »).
+    let ReadableStreamDefaultControllerCtor = GetReadableStreamDefaultControllerCtor();
+    UnsafeSetReservedSlot(this, READABLESTREAM_CONTROLLER_SLOT,
+                          new ReadableStreamDefaultControllerCtor(this,
+                                                                  underlyingSource,
+                                                                  highWaterMark));
+  }
+
+  // Step 9: Otherwise, throw a RangeError exception.
+  else {
+    ThrowSomething("RangeError",
+                   "underlyingSource.type must be 'bytes' or undefined");
+  }
 }
 
+// TODO: implement new controller classes
+
 // Streams spec, 3.2.4.1. get locked
 function ReadableStream_locked() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "locked",
+                   typeof this);
   }
 
+  // Step 2: Return ! IsReadableStreamLocked(this).
   return IsReadableStreamLocked(this);
 }
 
-// Streams spec, 3.2.4.2. cancel(reason)
+// Streams spec, 3.2.4.2. cancel ( reason )
 function ReadableStream_cancel(reason) {
+  // Step 1: If ! IsReadableStream(this) is false, return a promise rejected
+  //         with a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
     try {
-      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel", typeof this);
+      ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "cancel",
+                     typeof this);
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 2: If ! IsReadableStreamLocked(this) is true, return a promise
+  //         rejected with a TypeError exception.
   if (IsReadableStreamLocked(this)) {
     try {
-      ThrowSomething("TypeError", "IsReadableStreamLocked(this)");
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_LOCKED, "cancel");
     } catch (e) {
       return callFunction(Promise_static_reject, GetPromiseCtor(), e);
     }
   }
 
+  // Step 3: Return ! ReadableStreamCancel(this, reason).
   return CancelReadableStream(this, reason);
 }
 
 // Streams spec, 3.2.4.3. getReader()
-function ReadableStream_getReader() {
+function ReadableStream_getReader({ mode } = {}) {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception.
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "getReader",
+                   typeof this);
   }
 
-  return AcquireReadableStreamReader(this);
+  // Step 2: If mode is "byob",
+  if (mode === "byob") {
+    // Step a: If ! IsReadableByteStreamController(this@[[readableStreamController]])
+    //         is false, throw a TypeError exception.
+    let controller = UnsafeGetObjectReservedSlot(this,
+                                                 READABLESTREAM_CONTROLLER_SLOT);
+    if (!IsReadableByteStreamController(controller)) {
+      ThrowTypeError(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER);
+    }
+    // Step b: Return ? AcquireReadableStreamBYOBReader(this).
+    return AcquireReadableStreamBYOBReader(this);
+  }
+
+  // Step 3: If mode is undefined, return
+  //         ? AcquireReadableStreamDefaultReader(this).
+  if (mode === undefined) {
+    return AcquireReadableStreamDefaultReader(this);
+  }
+
+  ThrowSomething("RangeError", "mode must be 'byob' or undefined");
 }
 
 // Streams spec, 3.2.4.4. pipeThrough({ writable, readable }, options)
-function ReadableStream_pipeThrough({ writable, readable }, options) {
-  ReadableStream_pipeTo.call(this, writable, options);
-  return readable;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.5. pipeTo(dest, { preventClose, preventAbort, preventCancel } = {})
-function ReadableStream_pipeTo(dest,  { preventClose, preventAbort, preventCancel } = {}) {
-  return null;
-}
+// TODO: Unimplemented since spec is not complete yet.
 
 // Streams spec, 3.2.4.6. tee()
 function ReadableStream_tee() {
+  // Step 1: If ! IsReadableStream(this) is false, throw a TypeError exception
   if (!IsObject(this) || !IsReadableStream(this)) {
-    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee", typeof this);
+    ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "tee",
+                   typeof this);
   }
 
-  let branches = TeeReadableStream(this, false);
-  return branches;
+  // Step 2: Let branches be ? ReadableStreamTee(this, false).
+  let branches = ReadableStreamTee(this, false);
+
+  // Step 3: Return ! CreateArrayFromList(branches).
+  assert(branches.length == 2, "ReadableStreamTee() must return two branches.");
+  return [ branches[0], branches[1] ];
 }
 
+// Streams spec, 3.3.1. AcquireReadableStreamBYOBReader ( stream )
+function AcquireReadableStreamBYOBReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamBYOBReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamBYOBReaderCtor();
+  return new ReadableStreamBYOBReaderCtor(stream);
+}
+
+// Streams spec, 3.3.2. AcquireReadableStreamDefaultReader ( stream )
+function AcquireReadableStreamDefaultReader(stream) {
+  // Step 1: Return ? Construct(ReadableStreamDefaultReader, « stream »)
+  let ReadableStreamBYOBReaderCtor = GetReadableStreamDefaultReaderCtor();
+  return new ReadableStreamDefaultReaderCtor(stream);
+}
+
+// Streams spec, 3.3.3. IsReadableStream ( x )
+// Implemented via intrinsic_isInstanceOfBuiltin<ReadableStream>()
+
+// Streams spec, 3.3.4. IsReadableStreamDisturbed ( stream )
+function IsReadableStreamDisturbed(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStreamController(this), "IsReadableStream(stream)");
+
+  // Step 2: Return stream@[[disturbed]].
+  return UnsafeGetBooleanReservedSlot(stream, READABLESTREAM_DISTURBED_SLOT);
+}
+
+// Streams spec, 3.3.5. IsReadableStreamLocked ( stream )
+function IsReadableStreamLocked(stream) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: If stream@[[reader]] is undefined, return false.
+  // Step 3: Return true.
+  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
+}
+
+// Streams spec, 3.3.6. ReadableStreamTee ( stream, shouldClone )
+function ReadableStreamTee(stream, shouldClone) {
+  // Step 1: Assert: ! IsReadableStream(stream) is true.
+  assert(IsReadableStream(stream), "IsReadableStream(stream)");
+
+  // Step 2: Assert: Type(shouldClone) is Boolean.
+  assert(typeof shouldClone === 'boolean', "Type(shouldClone) is Boolean");
+
+  // Step 3: Let reader be ? AcquireReadableStreamDefaultReader(stream).
+  let reader = AcquireReadableStreamDefaultReader(stream);
+
+  // Step 4: Let teeState be Record {[[closedOrErrored]]: false, [[canceled1]]: false, [[canceled2]]: false, [[reason1]]: undefined, [[reason2]]: undefined, [[promise]]: a new promise}.
+  let teeState = new Record();
+  teeState.closedOrErrored: false;
+  teeState.canceled1: false;
+  teeState.canceled2: false;
+  teeState.reason1: undefined;
+  teeState.reason2: undefined;
+  teeState.promise: CreateDeferred();
+
+  // Step 5: Let pull be a new ReadableStreamTee pull function.
+  // Step 6: Set pull@[[reader]] to reader, pull@[[teeState]] to teeState, and
+  //         pull@[[shouldClone]] to shouldClone.
+  let pull = () => {
+    // ReadableStreamTee pull function
+    // Step 1: Let reader be F@[[reader]], branch1 be F@[[branch1]],
+    //         branch2 be F@[[branch2]], teeState be F@[[teeState]], and
+    //         shouldClone be F@[[shouldClone]].
+    // Implemented via closure.
+    let branch1 = UnsafeGetObjectFromReservedSlot(branch1Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+    let branch2 = UnsafeGetObjectFromReservedSlot(branch2Stream,
+                                                  READABLESTREAM_CONTROLLER_SLOT);
+
+    // Step 2: Return the result of transforming
+    //         ! ReadableStreamDefaultReaderRead(reader) by a fulfillment
+    //         handler which takes the argument result and performs the
+    //         following steps:
+    let readPromise = ReadableStreamDefaultReaderRead(stream);
+    callFunction(Promise_then, readPromise, result => {
+      // Step a: Assert: Type(result) is Object.
+      assert(IsObject(result), "Read result should be an object");
+
+      // Step b: Let value be ? Get(result, "value").
+      let value = result.value;
+
+      // Step c: Let done be ? Get(result, "done").
+      let done = result.done;
+
+      // Step d: Assert: Type(done) is Boolean.
+      assert(typeof done === 'boolean', "Read result.done should be a boolean");
+
+      // Step e: If done is true and teeState.[[closedOrErrored]] is false,
+      if (done && !teeState.closedOrErrored) {
+        // Step i: If teeState.[[canceled1]] is false,
+        if (!teeState.canceled1) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch1).
+          ReadableStreamDefaultControllerClose(branch1);
+        }
+
+        // Step ii: If teeState.[[canceled2]] is false,
+        if (!teeState.canceled2) {
+
+          // Step 1: Perform ! ReadableStreamDefaultControllerClose(branch2).
+          ReadableStreamDefaultControllerClose(branch2);
+        }
+
+        // Step iii: Set teeState.[[closedOrErrored]] to true.
+        teeState.closedOrErrored = true;
+      }
+
+      // Step f: If teeState.[[closedOrErrored]] is true, return undefined.
+      if (teeState.closedOrErrored) {
+        return;
+      }
+
+      // Step g: If teeState.[[canceled1]] is false,
+      if (!teeState.canceled1) {
+        // Step i: Let value1 be value.
+        let value1 = value;
+
+        // Step ii: If shouldClone is true, set value1 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value1).
+        ReadableStreamDefaultControllerEnqueue(branch1, value1);
+      }
+
+      // Step h: If teeState.[[canceled2]] is false,
+      if (!teeState.canceled2) {
+        // Step i: Let value2 be value.
+        let value2 = value;
+
+        // Step ii: If shouldClone is true, set value2 to ? StructuredClone(value).
+        // No way to trigger StructuredClone() and spec always passes false
+        // at the moment.
+        assert(!shouldClone, "tee(shouldClone=true) should not be exposed");
+
+        // Step iii: Perform ? ReadableStreamDefaultControllerEnqueue(branch1, value2).
+        ReadableStreamDefaultControllerEnqueue(branch2, value2);
+      }
+    });
+  };
+
+  // Step 7: Let cancel1 be a new ReadableStreamTee branch 1 cancel function.
+  // Step 8: Set cancel1@[[stream]] to stream and cancel1@[[teeState]] to
+  //         teeState.
+  let cancel1 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled1]] to true.
+    teeState.canceled1 = true;
+
+    // Step 3: Set teeState.[[reason1]] to reason.
+    teeState.reason1 = reason;
+
+    // Step 4: If teeState.[[canceled2]] is true,
+    if (teeState.canceled2) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(Promise_resolve, teeState.promise, cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.promise;
+  };
+
+  // Step 9: Let cancel2 be a new ReadableStreamTee branch 2 cancel function.
+  // Step 10: Set cancel2@[[stream]] to stream and cancel2@[[teeState]] to
+  //          teeState.
+  let cancel2 = undefined;
+  let cancel2 = (reason) => {
+    // ReadableStreamTee cancel function
+    // Step 1: Let stream be F@[[stream]] and teeState be F@[[teeState]].
+    // Implemented via closure
+
+    // Step 2: Set teeState.[[canceled2]] to true.
+    teeState.canceled2 = true;
+
+    // Step 3: Set teeState.[[reason2]] to reason.
+    teeState.reason2 = reason;
+
+    // Step 4: If teeState.[[canceled1]] is true,
+    if (teeState.canceled1) {
+      // Step a: Let compositeReason be
+      //         ! CreateArrayFromList(« teeState.[[reason1]], teeState.[[reason2]] »).
+      let compositeReason = [ teeState.reason1, teeState.reason2 ];
+
+      // Step b: Let cancelResult be ! ReadableStreamCancel(stream, compositeReason).
+      let cancelResult = ReadableStreamCancel(stream, compositeReason);
+
+      // Step c: Resolve teeState.[[promise]] with cancelResult.
+      callFunction(Promise_resolve, teeState.promise, cancelResult);
+    }
+
+    // Step 5: Return teeState.[[promise]].
+    return teeState.promise;
+  };
+
+  // Step 11: Let underlyingSource1 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 12: Perform ! CreateDataProperty(underlyingSource1, "pull", pull).
+  // Step 13: Perform ! CreateDataProperty(underlyingSource1, "cancel", cancel1).
+  let underlyingSource1 = {
+    pull: pull,
+    cancel: cancel1
+  };
+
+  // Step 14: Let branch1Stream be ! Construct(ReadableStream, underlyingSource1).
+  let ReadableStreamCtor = GetReadableStreamCtor();
+  let branch1Stream = new ReadableStreamCtor(underlyingSource1);
+
+  // Step 15: Let underlyingSource2 be ! ObjectCreate(%ObjectPrototype%).
+  // Step 16: Perform ! CreateDataProperty(underlyingSource2, "pull", pull).
+  // Step 17: Perform ! CreateDataProperty(underlyingSource2, "cancel", cancel2).
+  let underlyingSource2 = {
+    pull: pull,
+    cancel: cancel2
+  };
+
+  // Step 18: Let branch2Stream be ! Construct(ReadableStream, underlyingSource2).
+  let branch2Stream = new ReadableStreamCtor(underlyingSource2);
+
+  // Step 19: Set pull@[[branch1]] to branch1Stream@[[readableStreamController]].
+  // Step 20: Set pull@[[branch2]] to branch2Stream@[[readableStreamController]].
+  // Implemented via the pull closure above.
+
+  // Step 21: Upon rejection of reader@[[closedPromise]] with reason r,
+  let readerClosedPromise =
+    UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_CLOSED_PROMISE_SLOT);
+  callFunction(Promise_catch, readerClosedPromise, reason => {
+    // Step a: If teeState.[[closedOrErrored]] is true, return undefined.
+    if (teeState.closedOrErrored) {
+      return;
+    }
+    // Step b: Perform ! ReadableStreamDefaultControllerError(pull@[[branch1]], r).
+    ReadableStreamDefaultControllerError(branch1Stream, reason);
+    // Step c: Perform ! ReadableStreamDefaultControllerError(pull@[[branch2]], r).
+    ReadableStreamDefaultControllerError(branch2Stream, reason);
+    // Step d: Set teeState.[[closedOrErrored]] to true.
+    teeState.closedOrErrored = true;
+  });
+
+  // Step 22: Return « branch1, branch2 ».
+  let result = new List();
+  result[0] = branch1Stream;
+  result[1] = branch2Stream;
+  return result;
+}
+
+// TODO: continue here
 
 // Streams spec, 3.3.1. Class Definition
 function ReadableStreamController(stream) {
   if (!IsObject(this) || !IsReadableStreamController(this)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStreamController", "ctor", typeof this);
   }
   if (!IsObject(this) || !IsReadableStream(stream)) {
     ThrowTypeError(JSMSG_INCOMPATIBLE_PROTO, "ReadableStream", "ReadableStreamController", typeof stream);
@@ -425,22 +715,16 @@ function FinishClosingReadableStream(str
 // Streams spec, 3.5.7. GetReadableStreamDesiredSize ( stream )
 function GetReadableStreamDesiredSize(stream) {
   let queueSize = GetTotalQueueSize(
     UnsafeGetObjectFromReservedSlot(stream, READABLESTREAM_QUEUE_SLOT));
   let streamHWM = UnsafeGetReservedSlot(stream, READABLESTREAM_STRATEGY_HWM_SLOT);
   return streamHWM - queueSize;
 }
 
-// Streams spec, 3.5.11. IsReadableStreamLocked ( stream )
-function IsReadableStreamLocked(stream) {
-  assert(IsReadableStream(stream), "IsReadableStream(stream)");
-  return UnsafeGetReservedSlot(stream, READABLESTREAM_READER_SLOT) !== undefined;
-}
-
 // Streams spec, 3.5.13. ReadFromReadableStreamReader ( reader )
 function ReadFromReadableStreamReader(reader) {
   let ownerReadableStream = UnsafeGetObjectFromReservedSlot(reader, READABLESTREAMREADER_OWNER_READABLE_STREAM_SLOT);
   assert(ownerReadableStream !== undefined, "reader@[[ownerReadableStream]] is not undefined");
   UnsafeSetReservedSlot(ownerReadableStream, READABLESTREAM_DISTURBED_SLOT, true);
   let ownerReadableStreamState = UnsafeGetInt32FromReservedSlot(ownerReadableStream, READABLESTREAM_STATE_SLOT);
   if (ownerReadableStreamState === READABLESTREAM_CLOSED_STATE) {
     return callFunction(Promise_static_resolve, GetPromiseCtor(), CreateIterResultObject(undefined, true));
@@ -516,21 +800,16 @@ function ShouldReadableStreamPull(stream
     if (readerReadRequests.length !== 0) {
       return true;
     }
   }
   let desiredSize = GetReadableStreamDesiredSize(stream);
   return desiredSize > 0;
 }
 
-// Streams spec, 3.5.16. TeeReadableStream ( stream, shouldClone )
-function TeeReadableStream(stream, shouldClone) {
-  ThrowSomething("Error", "Not implemented TeeReadableStream");
-}
-
 // Streams spec, 6.3.1. DequeueValue ( queue )
 function DequeueValue(queue) {
   var pair = callFunction(std_Array_shift, queue);
   return pair.value;
 }
 
 // Streams spec, 6.3.2. EnqueueValueWithSize ( queue, value, size )
 function EnqueueValueWithSize(queue, value, size) {
diff --git a/js/src/builtin/SelfHostingDefines.h b/js/src/builtin/SelfHostingDefines.h
--- a/js/src/builtin/SelfHostingDefines.h
+++ b/js/src/builtin/SelfHostingDefines.h
@@ -72,29 +72,21 @@
 #define PROMISE_STATE_PENDING   0
 #define PROMISE_STATE_FULFILLED 1
 #define PROMISE_STATE_REJECTED  2
 
 #define PROMISE_HANDLER_IDENTITY 0
 #define PROMISE_HANDLER_THROWER  1
 
 // Used for ReadableStream.
-#define READABLESTREAM_CLOSE_REQUESTED_SLOT 0
-#define READABLESTREAM_CONTROLLER_SLOT 1
-#define READABLESTREAM_DISTURBED_SLOT 2
-#define READABLESTREAM_PULL_AGAIN_SLOT 3
-#define READABLESTREAM_PULLING_SLOT 4
-#define READABLESTREAM_QUEUE_SLOT 5
-#define READABLESTREAM_READER_SLOT 6
-#define READABLESTREAM_STARTED_SLOT 7
-#define READABLESTREAM_STATE_SLOT 8
-#define READABLESTREAM_STORED_ERROR_SLOT 9
-#define READABLESTREAM_STRATEGY_SIZE_SLOT 10
-#define READABLESTREAM_STRATEGY_HWM_SLOT 11
-#define READABLESTREAM_UNDERLYING_SOURCE_SLOT 12
+#define READABLESTREAM_CONTROLLER_SLOT 0
+#define READABLESTREAM_DISTURBED_SLOT 1
+#define READABLESTREAM_READER_SLOT 2
+#define READABLESTREAM_STATE_SLOT 3
+#define READABLESTREAM_STORED_ERROR_SLOT 4
 
 #define READABLESTREAM_READABLE_STATE 0
 #define READABLESTREAM_CLOSED_STATE 1
 #define READABLESTREAM_ERRORED_STATE 2
 
 #define READABLESTREAMCONTROLLER_CONTROLLED_READABLE_STREAM_SLOT 0
 
 #define READABLESTREAMREADER_CLOSED_PROMISE_SLOT 0
diff --git a/js/src/js.msg b/js/src/js.msg
--- a/js/src/js.msg
+++ b/js/src/js.msg
@@ -533,8 +533,12 @@ MSG_DEF(JSMSG_MISSING_NAMESPACE_EXPORT, 
 MSG_DEF(JSMSG_MISSING_EXPORT,            1, JSEXN_SYNTAXERR, "local binding for export '{0}' not found")
 
 // Promise
 MSG_DEF(JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF,       0, JSEXN_TYPEERR, "A promise cannot be resolved with itself.")
 MSG_DEF(JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY, 0, JSEXN_TYPEERR, "GetCapabilitiesExecutor function already invoked with non-undefined values.")
 MSG_DEF(JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE,    0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the resolve function.")
 MSG_DEF(JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE,     0, JSEXN_TYPEERR, "A Promise subclass passed a non-callable value as the reject function.")
 MSG_DEF(JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON,0, JSEXN_INTERNALERR, "Promise rejection value is a non-unwrappable cross-compartment wrapper.")
+
+// ReadableStream
+MSG_DEF(JSMSG_READABLESTREAM_NOT_LOCKED,                 1, JSEXN_TYPEERR, "The ReadableStream method '{0}' may only be called on a locked stream.")
+MSG_DEF(JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER, 0, JSEXN_TYPEERR, "ReadableStream.getReader('byob') requires a ReadableByteStreamController.")
