# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c8ed1d1644d16508d2278bd19a00e5f230ed30d5
Bug 1112071 Change Cache ManagerId to use QuotaManager's concept of origin. r=ehsan

diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -395,17 +395,17 @@ private:
 
     MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
 
     {
       ManagerList::ForwardIterator iter(sFactory->mManagerList);
       while (iter.HasMore()) {
         nsRefPtr<Manager> manager = iter.GetNext();
         if (aOrigin.IsVoid() ||
-            manager->mManagerId->ExtendedOrigin() == aOrigin) {
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
           manager->Abort();
         }
       }
     }
   }
 
   static void
   ShutdownAllOnBackgroundThread()
diff --git a/dom/cache/ManagerId.cpp b/dom/cache/ManagerId.cpp
--- a/dom/cache/ManagerId.cpp
+++ b/dom/cache/ManagerId.cpp
@@ -16,53 +16,42 @@ namespace cache {
 
 // static
 nsresult
 ManagerId::Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   // The QuotaManager::GetInfoFromPrincipal() has special logic for system
-  // and about: principals.  We currently don't need the system principal logic
-  // because ManagerId only uses the origin for in memory comparisons.  We
-  // also don't do any special logic to host the same Cache for different about:
-  // pages, so we don't need those checks either.
-  //
-  // But, if we get the same QuotaManager directory for different about:
-  // origins, we probably only want one Manager instance.  So, we might
-  // want to start using the QM's concept of origin uniqueness here.
-  //
-  // TODO: consider using QuotaManager's modified origin here (bug 1112071)
-
-  nsCString origin;
-  nsresult rv = aPrincipal->GetOriginNoSuffix(origin);
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                   nullptr,   //group
+                                                   &quotaOrigin,
+                                                   nullptr);  // is app
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  nsCString jarPrefix;
-  rv = aPrincipal->GetJarPrefix(jarPrefix);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  nsRefPtr<ManagerId> ref = new ManagerId(aPrincipal, origin, jarPrefix);
+  nsRefPtr<ManagerId> ref = new ManagerId(aPrincipal, quotaOrigin);
   ref.forget(aManagerIdOut);
 
   return NS_OK;
 }
 
 already_AddRefed<nsIPrincipal>
 ManagerId::Principal() const
 {
   MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIPrincipal> ref = mPrincipal;
   return ref.forget();
 }
 
-ManagerId::ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
-                     const nsACString& aJarPrefix)
+ManagerId::ManagerId(nsIPrincipal* aPrincipal, const nsACString& aQuotaOrigin)
     : mPrincipal(aPrincipal)
-    , mExtendedOrigin(aJarPrefix + aOrigin)
+    , mQuotaOrigin(aQuotaOrigin)
 {
   MOZ_ASSERT(mPrincipal);
 }
 
 ManagerId::~ManagerId()
 {
   // If we're already on the main thread, then default destruction is fine
   if (NS_IsMainThread()) {
diff --git a/dom/cache/ManagerId.h b/dom/cache/ManagerId.h
--- a/dom/cache/ManagerId.h
+++ b/dom/cache/ManagerId.h
@@ -24,36 +24,35 @@ class ManagerId final
 {
 public:
   // Main thread only
   static nsresult Create(nsIPrincipal* aPrincipal, ManagerId** aManagerIdOut);
 
   // Main thread only
   already_AddRefed<nsIPrincipal> Principal() const;
 
-  const nsACString& ExtendedOrigin() const { return mExtendedOrigin; }
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
 
   bool operator==(const ManagerId& aOther) const
   {
-    return mExtendedOrigin == aOther.mExtendedOrigin;
+    return mQuotaOrigin == aOther.mQuotaOrigin;
   }
 
 private:
-  ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin,
-            const nsACString& aJarPrefix);
+  ManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
   ~ManagerId();
 
   ManagerId(const ManagerId&) = delete;
   ManagerId& operator=(const ManagerId&) = delete;
 
   // only accessible on main thread
   nsCOMPtr<nsIPrincipal> mPrincipal;
 
   // immutable to allow threadsfe access
-  const nsCString mExtendedOrigin;
+  const nsCString mQuotaOrigin;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(mozilla::dom::cache::ManagerId)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
