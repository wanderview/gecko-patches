# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  feff79e5b1374439f17c5ea10a559acf1380a8d5
Bug 1301678 Make InterceptedChannel use a different state variable to indicated the channel is closed. r=jdm

diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -36,16 +36,17 @@ DoAddCacheEntryHeaders(nsHttpChannel *se
                        nsHttpResponseHead *responseHead,
                        nsISupports *securityInfo);
 
 NS_IMPL_ISUPPORTS(InterceptedChannelBase, nsIInterceptedChannel)
 
 InterceptedChannelBase::InterceptedChannelBase(nsINetworkInterceptController* aController)
 : mController(aController)
 , mReportCollector(new ConsoleReportCollector())
+, mClosed(false)
 {
 }
 
 InterceptedChannelBase::~InterceptedChannelBase()
 {
 }
 
 NS_IMETHODIMP
@@ -178,17 +179,17 @@ InterceptedChannelChrome::GetChannel(nsI
 {
   NS_IF_ADDREF(*aChannel = mChannel);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::ResetInterception()
 {
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   mSynthesizedCacheEntry->AsyncDoom(nullptr);
   mSynthesizedCacheEntry = nullptr;
 
@@ -197,16 +198,18 @@ InterceptedChannelChrome::ResetIntercept
   nsCOMPtr<nsIURI> uri;
   mChannel->GetURI(getter_AddRefs(uri));
 
   nsresult rv = mChannel->StartRedirectChannelToURI(uri, nsIChannelEventSink::REDIRECT_INTERNAL);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mResponseBody->Close();
   mResponseBody = nullptr;
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::SynthesizeStatus(uint16_t aStatus, const nsACString& aReason)
 {
   if (!mSynthesizedCacheEntry) {
     return NS_ERROR_NOT_AVAILABLE;
@@ -223,17 +226,17 @@ InterceptedChannelChrome::SynthesizeHead
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
 {
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Make sure the cache entry's output stream is always closed.  If the
   // channel was intercepted with a null-body response then its possible
   // the synthesis completed without a stream copy operation.
   mResponseBody->Close();
 
@@ -294,41 +297,47 @@ InterceptedChannelChrome::FinishSynthesi
 
     mSynthesizedCacheEntry = nullptr;
 
     if (!mChannel->AwaitingCacheCallbacks()) {
       rv = mChannel->ContinueConnect();
       NS_ENSURE_SUCCESS(rv, rv);
     }
   }
+
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::Cancel(nsresult aStatus)
 {
   MOZ_ASSERT(NS_FAILED(aStatus));
 
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   // we need to use AsyncAbort instead of Cancel since there's no active pump
   // to cancel which will provide OnStart/OnStopRequest to the channel.
   nsresult rv = mChannel->AsyncAbort(aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
+
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::SetChannelInfo(dom::ChannelInfo* aChannelInfo)
 {
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   return aChannelInfo->ResurrectInfoOnChannel(mChannel);
 }
 
 NS_IMETHODIMP
 InterceptedChannelChrome::GetInternalContentPolicyType(nsContentPolicyType* aPolicyType)
@@ -375,27 +384,30 @@ InterceptedChannelContent::GetChannel(ns
 {
   NS_IF_ADDREF(*aChannel = mChannel);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::ResetInterception()
 {
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   mResponseBody->Close();
   mResponseBody = nullptr;
   mSynthesizedInput = nullptr;
 
   mChannel->ResetInterception();
+
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::SynthesizeStatus(uint16_t aStatus, const nsACString& aReason)
 {
   if (!mResponseBody) {
     return NS_ERROR_NOT_AVAILABLE;
@@ -412,17 +424,17 @@ InterceptedChannelContent::SynthesizeHea
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::FinishSynthesizedResponse(const nsACString& aFinalURLSpec)
 {
-  if (NS_WARN_IF(!mChannel)) {
+  if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   // Make sure the body output stream is always closed.  If the channel was
   // intercepted with a null-body response then its possible the synthesis
   // completed without a stream copy operation.
   mResponseBody->Close();
 
@@ -453,42 +465,46 @@ InterceptedChannelContent::FinishSynthes
   } else {
     mChannel->OverrideWithSynthesizedResponse(mSynthesizedResponseHead.ref(),
                                               mSynthesizedInput,
                                               mStreamListener);
   }
 
   mResponseBody = nullptr;
   mStreamListener = nullptr;
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::Cancel(nsresult aStatus)
 {
   MOZ_ASSERT(NS_FAILED(aStatus));
 
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
   // we need to use AsyncAbort instead of Cancel since there's no active pump
   // to cancel which will provide OnStart/OnStopRequest to the channel.
   nsresult rv = mChannel->AsyncAbort(aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
   mStreamListener = nullptr;
+  mClosed = true;
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::SetChannelInfo(dom::ChannelInfo* aChannelInfo)
 {
-  if (!mChannel) {
+  if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   return aChannelInfo->ResurrectInfoOnChannel(mChannel);
 }
 
 NS_IMETHODIMP
 InterceptedChannelContent::GetInternalContentPolicyType(nsContentPolicyType* aPolicyType)
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -34,16 +34,18 @@ protected:
   nsCOMPtr<nsIOutputStream> mResponseBody;
 
   // Response head for use when synthesizing
   Maybe<nsAutoPtr<nsHttpResponseHead>> mSynthesizedResponseHead;
 
   nsCOMPtr<nsIConsoleReportCollector> mReportCollector;
   nsCOMPtr<nsISupports> mReleaseHandle;
 
+  bool mClosed;
+
   void EnsureSynthesizedResponse();
   void DoNotifyController();
   nsresult DoSynthesizeStatus(uint16_t aStatus, const nsACString& aReason);
   nsresult DoSynthesizeHeader(const nsACString& aName, const nsACString& aValue);
 
   virtual ~InterceptedChannelBase();
 public:
   explicit InterceptedChannelBase(nsINetworkInterceptController* aController);
