# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a03ae0fe6dc3e5ded6cc69db3f357ecbe3fbf5d0

diff --git a/dom/serviceworkers/ServiceWorkerImpl.cpp b/dom/serviceworkers/ServiceWorkerImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerImpl.cpp
@@ -36,17 +36,40 @@ ServiceWorkerImpl::RemoveServiceWorker(S
   MOZ_DIAGNOSTIC_ASSERT(mOuter == aWorker);
   mOuter = nullptr;
 }
 
 void
 ServiceWorkerImpl::GetRegistration(ServiceWorkerRegistrationCallback&& aSuccessCB,
                                    ServiceWorkerFailureCallback&& aFailureCB)
 {
-  aSuccessCB(mReg->Descriptor());
+  if (!mOuter) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
+  nsIGlobalObject* global = mOuter->GetParentObject();
+  if (!global) {
+    aFailureCB(CopyableErrorResult(NS_ERROR_DOM_INVALID_STATE_ERR));
+    return;
+  }
+
+  nsCOMPtr<nsIRunnable> r = NS_NewRunnableFunction(
+    "ServiceWorkerImpl::GetRegistration",
+    [reg = mReg, successCB = std::move(aSuccessCB)] () mutable {
+      successCB(reg->Descriptor());
+    });
+
+  nsresult rv =
+    global->EventTargetFor(TaskCategory::Other)->Dispatch(r.forget(),
+                                                          NS_DISPATCH_NORMAL);
+  if (NS_FAILED(rv)) {
+    aFailureCB(CopyableErrorResult(rv));
+    return;
+  }
 }
 
 void
 ServiceWorkerImpl::PostMessage(RefPtr<ServiceWorkerCloneData>&& aData,
                                const ClientInfo& aClientInfo,
                                const ClientState& aClientState)
 {
   mInfo->PostMessage(std::move(aData), aClientInfo, aClientState);
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationImpl.cpp
@@ -128,25 +128,33 @@ ServiceWorkerRegistrationMainThread::Upd
   Unused <<
     global->EventTargetFor(TaskCategory::Other)->Dispatch(r.forget(),
                                                           NS_DISPATCH_NORMAL);
 }
 
 void
 ServiceWorkerRegistrationMainThread::RegistrationRemoved()
 {
+  NS_ENSURE_TRUE_VOID(mOuter);
+
+  nsIGlobalObject* global = mOuter->GetParentObject();
+  NS_ENSURE_TRUE_VOID(global);
+
   // Queue a runnable to clean up the registration.  This is necessary
   // because there may be runnables in the event queue already to
   // update the registration state.  We want to let those run
   // if possible before clearing our mOuter reference.
   nsCOMPtr<nsIRunnable> r = NewRunnableMethod(
     "ServiceWorkerRegistrationMainThread::RegistrationRemoved",
     this,
     &ServiceWorkerRegistrationMainThread::RegistrationRemovedInternal);
-  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch(TaskCategory::Other, r.forget()));
+
+  Unused <<
+    global->EventTargetFor(TaskCategory::Other)->Dispatch(r.forget(),
+                                                          NS_DISPATCH_NORMAL);
 }
 
 bool
 ServiceWorkerRegistrationMainThread::MatchesDescriptor(const ServiceWorkerRegistrationDescriptor& aDescriptor)
 {
   return mOuter->MatchesDescriptor(aDescriptor);
 }
 
