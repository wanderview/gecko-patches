# HG changeset patch
# Parent 5fdd6c375b1108ddc90317a0d5dc426c9f23a7de
# User Ben Kelly <ben@wanderview.com>
Bug 1154325 P2 Use Blobs for CacheStorage keys to avoid encoding issues. r=ehsan

diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -23,21 +23,21 @@
 #include "mozilla/dom/ResponseBinding.h"
 #include "nsIContentPolicy.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 namespace db {
 
-const int32_t kMaxWipeSchemaVersion = 6;
+const int32_t kMaxWipeSchemaVersion = 7;
 
 namespace {
 
-const int32_t kLatestSchemaVersion = 6;
+const int32_t kLatestSchemaVersion = 7;
 const int32_t kMaxEntriesPerStatement = 255;
 
 } // anonymous namespace
 
 // If any of the static_asserts below fail, it means that you have changed
 // the corresponding WebIDL enum in a way that may be incompatible with the
 // existing data stored in the DOM Cache.  You would need to update the Cache
 // database schema accordingly and adjust the failing static_assert.
@@ -191,16 +191,18 @@ nsresult
 CreateSchema(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   nsAutoCString pragmas(
     // Enable auto-vaccum but in incremental mode in order to avoid doing a lot
     // of work at the end of each transaction.
+    // NOTE: This must be done here instead of InitializeConnection() because it
+    //       only works when the database is empty.
     "PRAGMA auto_vacuum = INCREMENTAL; "
   );
 
   nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   int32_t schemaVersion;
   rv = aConn->GetSchemaVersion(&schemaVersion);
@@ -299,20 +301,23 @@ CreateSchema(mozIStorageConnection* aCon
     // We need an index on response_headers, but not on request_headers,
     // because we quickly need to determine if a VARY header is present.
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE INDEX response_headers_name_index "
                 "ON response_headers (name);"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+    // NOTE: key allows NULL below since that is how "" is represented
+    //       in a BLOB column.  We use BLOB to avoid encoding issues
+    //       with storing DOMStrings.
     rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
       "CREATE TABLE storage ("
         "namespace INTEGER NOT NULL, "
-        "key TEXT NOT NULL, "
+        "key BLOB NULL, "
         "cache_id INTEGER NOT NULL REFERENCES caches(id), "
         "PRIMARY KEY(namespace, key) "
       ");"
     ));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
@@ -680,26 +685,27 @@ StorageGetCacheId(mozIStorageConnection*
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aFoundCacheOut);
   MOZ_ASSERT(aCacheIdOut);
 
   *aFoundCacheOut = false;
 
+  // Use IS for matching the key since an EmptryString() key maps to NULL.
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT cache_id FROM storage WHERE namespace=?1 AND key=?2 ORDER BY rowid;"
+    "SELECT cache_id FROM storage WHERE namespace=?1 AND key IS ?2 ORDER BY rowid;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aNamespace);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringParameter(1, aKey);
+  rv = state->BindStringAsBlobParameter(1, aKey);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   if (!hasMoreData) {
     return rv;
@@ -723,17 +729,17 @@ StoragePutCache(mozIStorageConnection* a
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "INSERT INTO storage (namespace, key, cache_id) VALUES(?1, ?2, ?3);"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aNamespace);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringParameter(1, aKey);
+  rv = state->BindStringAsBlobParameter(1, aKey);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64Parameter(2, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -742,26 +748,27 @@ StoragePutCache(mozIStorageConnection* a
 
 nsresult
 StorageForgetCache(mozIStorageConnection* aConn, Namespace aNamespace,
                    const nsAString& aKey)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
+  // Use IS for matching the key since an EmptryString() key maps to NULL.
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "DELETE FROM storage WHERE namespace=?1 AND key=?2;"
+    "DELETE FROM storage WHERE namespace=?1 AND key IS ?2;"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aNamespace);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindStringParameter(1, aKey);
+  rv = state->BindStringAsBlobParameter(1, aKey);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
@@ -779,18 +786,19 @@ StorageGetKeys(mozIStorageConnection* aC
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt32Parameter(0, aNamespace);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   bool hasMoreData = false;
   while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
     nsAutoString key;
-    rv = state->GetString(0, key);
+    rv = state->GetBlobAsString(0, key);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
     aKeysOut.AppendElement(key);
   }
 
   return rv;
 }
 
 namespace {
 
@@ -1186,19 +1194,17 @@ InsertEntry(mozIStorageConnection* aConn
 
   rv = state->BindInt32Parameter(15,
     static_cast<int32_t>(aResponse.headersGuard()));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = BindId(state, 16, aResponseBodyId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  rv = state->BindBlobParameter(17, reinterpret_cast<const uint8_t*>
-                                  (aResponse.securityInfo().get()),
-                                aResponse.securityInfo().Length());
+  rv = state->BindUTF8StringAsBlobParameter(17, aResponse.securityInfo());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindInt64Parameter(18, aCacheId);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
@@ -1323,22 +1329,18 @@ ReadResponse(mozIStorageConnection* aCon
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   aSavedResponseOut->mHasBodyId = !nullBody;
 
   if (aSavedResponseOut->mHasBodyId) {
     rv = ExtractId(state, 5, &aSavedResponseOut->mBodyId);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
-  uint8_t* data = nullptr;
-  uint32_t dataLength = 0;
-  rv = state->GetBlob(6, &dataLength, &data);
+  rv = state->GetBlobAsUTF8String(6, aSavedResponseOut->mValue.securityInfo());
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  aSavedResponseOut->mValue.securityInfo().Adopt(
-    reinterpret_cast<char*>(data), dataLength);
 
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "SELECT "
       "name, "
       "value "
     "FROM response_headers "
     "WHERE entry_id=?1;"
   ), getter_AddRefs(state));
