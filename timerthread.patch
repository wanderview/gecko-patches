# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4451bb1b097020367d8a5685fc0edd8f952a37b2

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -361,25 +361,65 @@ TimerThread::Shutdown()
   mThread->Shutdown();    // wait for the thread to die
 
   nsTimerEvent::Shutdown();
 
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown end\n"));
   return NS_OK;
 }
 
+namespace {
+
+struct MicrosecondsToInterval
+{
+  PRIntervalTime operator[](size_t aMs) const {
+    return PR_MicrosecondsToInterval(aMs);
+  }
+};
+
+struct IntervalComparator
+{
+  int operator()(PRIntervalTime aInterval) const {
+    return (0 < aInterval) ? -1 : 1;
+  }
+};
+
+} // namespace
+
 NS_IMETHODIMP
 TimerThread::Run()
 {
   NS_SetCurrentThreadName("Timer");
 
   MonitorAutoLock lock(mMonitor);
 
+  // We need to know how many microseconds give a positive PRIntervalTime. This
+  // is platform-dependent and we calculate it at runtime, finding a value |v|
+  // such that |PR_MicrosecondsToInterval(v) > 0| and then binary-searching in
+  // the range [0, v) to find the ms-to-interval scale.
+  uint32_t usForPosInterval = 1;
+  while (PR_MicrosecondsToInterval(usForPosInterval) == 0) {
+    usForPosInterval <<= 1;
+  }
+
+  size_t usIntervalResolution;
+  BinarySearchIf(MicrosecondsToInterval(), 0, usForPosInterval, IntervalComparator(), &usIntervalResolution);
+  MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution - 1) == 0);
+  MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution) == 1);
+
+  TimeDuration intervalResolution =
+    TimeDuration::FromMicroseconds(usIntervalResolution);
+
+  // Half of the amount of microseconds needed to get positive PRIntervalTime.
+  // We use this to decide how to round our wait times later
+  TimeDuration halfIntervalResolution =
+    TimeDuration::FromMicroseconds(usIntervalResolution / 2);
   bool forceRunNextTimer = false;
 
+
   while (!mShutdown) {
     TimeDuration waitFor(TimeDuration::Forever());
     bool forceRunThisTimer = forceRunNextTimer;
     forceRunNextTimer = false;
 
     if (mSleeping) {
       // Sleep for 0.1 seconds while not firing timers.
       uint32_t milliseconds = 100;
@@ -444,38 +484,43 @@ TimerThread::Run()
           now = TimeStamp::Now();
         }
       }
 
       RemoveLeadingCanceledTimersInternal();
 
       if (!mTimers.IsEmpty()) {
         TimeStamp timeout = mTimers[0]->Value()->mTimeout;
+
+        // Note that we can only sleep for integer values of a certain
+        // resolution. We use halfIntervalResolution, calculated
+        // before, to do the optimal rounding (i.e., of how to decide what
+        // interval is so small we should not wait at all).
         TimeDuration delay = timeout - now;
 
         if (ChaosMode::isActive(ChaosFeature::TimerScheduling)) {
           // The mean value of sFractions must be 1 to ensure that
           // the average of a long sequence of timeouts converges to the
           // actual sum of their times.
           static const float sFractions[] = {
             0.0f, 0.25f, 0.5f, 0.75f, 1.0f, 1.75f, 2.75f
           };
           delay += TimeDuration::FromMicroseconds(
             sFractions[ChaosMode::randomUint32LessThan(ArrayLength(sFractions))]);
           forceRunNextTimer = true;
         }
 
         // If the delay is less than the actual measurable resolution on
         // this platform then fire the timer immediately.
-        if (delay < TimeDuration::Resolution()) {
+        if (delay < halfIntervalResolution) {
           forceRunNextTimer = false;
           goto next; // round down; execute event now
         }
 
-        waitFor = delay;
+        waitFor = TimeDuration::Max(delay, intervalResolution);
       }
 
       if (MOZ_LOG_TEST(GetTimerLog(), LogLevel::Debug)) {
         if (waitFor == TimeDuration::Forever())
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
                  ("waiting for forever\n"));
         else
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
