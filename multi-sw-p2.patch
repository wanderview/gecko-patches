# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dbcb16c3e28d27e2f3e7c2a5edbbae9c7b31ee4d
Multiple SW instances P2

diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -91,17 +91,17 @@ ServiceWorkerPrivate::ServiceWorkerPriva
   MOZ_ASSERT(aInfo);
 
   mIdleWorkerTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
   MOZ_ASSERT(mIdleWorkerTimer);
 }
 
 ServiceWorkerPrivate::~ServiceWorkerPrivate()
 {
-  MOZ_ASSERT(!mWorkerPrivate);
+  MOZ_ASSERT(mWorkerPrivateList.IsEmpty());
   MOZ_ASSERT(!mTokenCount);
   MOZ_ASSERT(!mInfo);
   MOZ_ASSERT(mSupportsArray.IsEmpty());
 
   mIdleWorkerTimer->Cancel();
 }
 
 namespace {
@@ -1677,18 +1677,18 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   AssertIsOnMainThread();
 
   // XXXcatalinb: We need to have a separate load group that's linked to
   // an existing tab child to pass security checks on b2g.
   // This should be fixed in bug 1125961, but for now we enforce updating
   // the overriden load group when intercepting a fetch.
   MOZ_ASSERT_IF(aWhy == FetchEvent, aLoadGroup);
 
-  if (mWorkerPrivate) {
-    mWorkerPrivate->UpdateOverridenLoadGroup(aLoadGroup);
+  if (!mWorkerPrivateList.IsEmpty()) {
+    mWorkerPrivateList[0]->UpdateOverridenLoadGroup(aLoadGroup);
     RenewKeepAliveToken(aWhy);
 
     return NS_OK;
   }
 
   // Sanity check: mSupportsArray should be empty if we're about to
   // spin up a new worker.
   MOZ_ASSERT(mSupportsArray.IsEmpty());
@@ -1750,34 +1750,36 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
 
   WorkerPrivate::OverrideLoadInfoLoadGroup(info);
 
   AutoJSAPI jsapi;
   jsapi.Init();
   ErrorResult error;
   NS_ConvertUTF8toUTF16 scriptSpec(mInfo->ScriptSpec());
 
-  mWorkerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
+  RefPtr<WorkerPrivate> workerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
                                               scriptSpec,
                                               false, WorkerTypeService,
                                               mInfo->Scope(), &info, error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
+  mWorkerPrivateList.AppendElement(workerPrivate.forget());
+
   RenewKeepAliveToken(aWhy);
 
   return NS_OK;
 }
 
 void
 ServiceWorkerPrivate::StoreISupports(nsISupports* aSupports)
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(mWorkerPrivate);
+  MOZ_ASSERT(!mWorkerPrivateList.IsEmpty());
   MOZ_ASSERT(!mSupportsArray.Contains(aSupports));
 
   mSupportsArray.AppendElement(aSupports);
 }
 
 void
 ServiceWorkerPrivate::RemoveISupports(nsISupports* aSupports)
 {
@@ -1787,26 +1789,28 @@ ServiceWorkerPrivate::RemoveISupports(ns
 
 void
 ServiceWorkerPrivate::TerminateWorker()
 {
   AssertIsOnMainThread();
 
   mIdleWorkerTimer->Cancel();
   mIdleKeepAliveToken = nullptr;
-  if (mWorkerPrivate) {
+  if (!mWorkerPrivateList.IsEmpty()) {
     if (Preferences::GetBool("dom.serviceWorkers.testing.enabled")) {
       nsCOMPtr<nsIObserverService> os = services::GetObserverService();
       if (os) {
         os->NotifyObservers(this, "service-worker-shutdown", nullptr);
       }
     }
 
-    NS_WARN_IF(!mWorkerPrivate->Terminate());
-    mWorkerPrivate = nullptr;
+    for (uint32_t i = 0; i < mWorkerPrivateList.Length(); ++i) {
+      NS_WARN_IF(mWorkerPrivateList[i]->Terminate());
+    }
+    mWorkerPrivateList.Clear();
     mSupportsArray.Clear();
 
     // Any pending events are never going to fire on this worker.  Cancel
     // them so that intercepted channels can be reset and other resources
     // cleaned up.
     nsTArray<RefPtr<WorkerRunnable>> pendingEvents;
     mPendingFunctionalEvents.SwapElements(pendingEvents);
     for (uint32_t i = 0; i < pendingEvents.Length(); ++i) {
@@ -1826,17 +1830,18 @@ ServiceWorkerPrivate::NoteDeadServiceWor
 void
 ServiceWorkerPrivate::Activated()
 {
   AssertIsOnMainThread();
 
   // If we had to queue up events due to the worker activating, that means
   // the worker must be currently running.  We should be called synchronously
   // when the worker becomes activated.
-  MOZ_ASSERT_IF(!mPendingFunctionalEvents.IsEmpty(), mWorkerPrivate);
+  MOZ_ASSERT_IF(!mPendingFunctionalEvents.IsEmpty(),
+                !mWorkerPrivateList.IsEmpty());
 
   nsTArray<RefPtr<WorkerRunnable>> pendingEvents;
   mPendingFunctionalEvents.SwapElements(pendingEvents);
 
   for (uint32_t i = 0; i < pendingEvents.Length(); ++i) {
     RefPtr<WorkerRunnable> r = pendingEvents[i].forget();
     if (NS_WARN_IF(!r->Dispatch())) {
       NS_WARNING("Failed to dispatch pending functional event!");
@@ -1849,19 +1854,19 @@ ServiceWorkerPrivate::GetDebugger(nsIWor
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aResult);
 
   if (!mDebuggerCount) {
     return NS_OK;
   }
 
-  MOZ_ASSERT(mWorkerPrivate);
+  MOZ_ASSERT(!mWorkerPrivateList.IsEmpty());
 
-  nsCOMPtr<nsIWorkerDebugger> debugger = do_QueryInterface(mWorkerPrivate->Debugger());
+  nsCOMPtr<nsIWorkerDebugger> debugger = do_QueryInterface(mWorkerPrivateList[0]->Debugger());
   debugger.forget(aResult);
 
   return NS_OK;
 }
 
 nsresult
 ServiceWorkerPrivate::AttachDebugger()
 {
@@ -1921,17 +1926,17 @@ ServiceWorkerPrivate::NoteIdleWorkerCall
 
   RefPtr<ServiceWorkerPrivate> swp = static_cast<ServiceWorkerPrivate*>(aPrivate);
 
   MOZ_ASSERT(aTimer == swp->mIdleWorkerTimer, "Invalid timer!");
 
   // Release ServiceWorkerPrivate's token, since the grace period has ended.
   swp->mIdleKeepAliveToken = nullptr;
 
-  if (swp->mWorkerPrivate) {
+  if (!swp->mWorkerPrivateList.IsEmpty()) {
     // If we still have a workerPrivate at this point it means there are pending
     // waitUntil promises. Wait a bit more until we forcibly terminate the
     // worker.
     uint32_t timeout = Preferences::GetInt("dom.serviceWorkers.idle_extended_timeout");
     DebugOnly<nsresult> rv =
       swp->mIdleWorkerTimer->InitWithFuncCallback(ServiceWorkerPrivate::TerminateWorkerCallback,
                                                   aPrivate,
                                                   timeout,
@@ -1962,17 +1967,17 @@ ServiceWorkerPrivate::TerminateWorkerCal
 
   serviceWorkerPrivate->TerminateWorker();
 }
 
 void
 ServiceWorkerPrivate::RenewKeepAliveToken(WakeUpReason aWhy)
 {
   // We should have an active worker if we're renewing the keep alive token.
-  MOZ_ASSERT(mWorkerPrivate);
+  MOZ_ASSERT(!mWorkerPrivateList.IsEmpty());
 
   // If there is at least one debugger attached to the worker, the idle worker
   // timeout was canceled when the first debugger attached to the worker. It
   // should not be reset until the last debugger detaches from the worker.
   if (!mDebuggerCount) {
     ResetIdleTimeout();
   }
 
@@ -2015,21 +2020,21 @@ ServiceWorkerPrivate::ReleaseToken()
     }
   }
 }
 
 already_AddRefed<KeepAliveToken>
 ServiceWorkerPrivate::CreateEventKeepAliveToken()
 {
   AssertIsOnMainThread();
-  MOZ_ASSERT(mWorkerPrivate);
+  MOZ_ASSERT(!mWorkerPrivateList.IsEmpty());
   MOZ_ASSERT(mIdleKeepAliveToken);
   RefPtr<KeepAliveToken> ref = new KeepAliveToken(this);
   return ref.forget();
 }
 
 WorkerPrivate*
 ServiceWorkerPrivate::GetNextWorkerPrivate() const
 {
-  return mWorkerPrivate;
+  return mWorkerPrivateList.IsEmpty() ? nullptr : mWorkerPrivateList.ElementAt(0).get();
 }
 
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -198,17 +198,17 @@ private:
   // The info object owns us. It is possible to outlive it for a brief period
   // of time if there are pending waitUntil promises, in which case it
   // will be null and |SpawnWorkerIfNeeded| will always fail.
   ServiceWorkerInfo* MOZ_NON_OWNING_REF mInfo;
 
   // The WorkerPrivate object can only be closed by this class or by the
   // RuntimeService class if gecko is shutting down. Closing the worker
   // multiple times is OK, since the second attempt will be a no-op.
-  RefPtr<WorkerPrivate> mWorkerPrivate;
+  nsTArray<RefPtr<WorkerPrivate>> mWorkerPrivateList;
 
   nsCOMPtr<nsITimer> mIdleWorkerTimer;
 
   // We keep a token for |dom.serviceWorkers.idle_timeout| seconds to give the
   // worker a grace period after each event.
   RefPtr<KeepAliveToken> mIdleKeepAliveToken;
 
   uint64_t mDebuggerCount;
