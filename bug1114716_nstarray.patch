# HG changeset patch
# Parent 960a1c2f4c0b772209f67797a0266ea379f62f30
# User Ben Kelly <ben@wanderview.com>
Bug 1114716 Add nsTArray RemoveLastElement() and SwapToEndAndRemoveElementAt(i).


diff --git a/xpcom/glue/nsTArray.h b/xpcom/glue/nsTArray.h
--- a/xpcom/glue/nsTArray.h
+++ b/xpcom/glue/nsTArray.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsTArray_h__
 #define nsTArray_h__
 
+#include <algorithm>
 #include "nsTArrayForwardDeclare.h"
 #include "mozilla/Alignment.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/BinarySearch.h"
 #include "mozilla/MathAlgorithms.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
 #include "mozilla/TypeTraits.h"
@@ -1397,16 +1398,33 @@ public:
     DestructRange(aStart, aCount);
     this->ShiftData(aStart, aCount, 0,
                     sizeof(elem_type), MOZ_ALIGNOF(elem_type));
   }
 
   // A variation on the RemoveElementsAt method defined above.
   void RemoveElementAt(index_type aIndex) { RemoveElementsAt(aIndex, 1); }
 
+  // Convenience method to remove the last element.
+  void RemoveLastElement() { RemoveElementAt(Length() - 1); }
+
+  // Efficiently remove an element at the given index by swapping it to the
+  // end of the array and then removing it.  This of course changes the
+  // order of the array as a side effect and can therefore only be used
+  // when ordering is not significant.
+  void SwapToEndAndRemoveElementAt(index_type aIndex)
+  {
+    MOZ_ASSERT(aIndex < Length(), "Invalid index");
+    index_type lastIndex = Length() - 1;
+    if (aIndex < lastIndex) {
+      std::swap(ElementAt(aIndex), ElementAt(lastIndex));
+    }
+    RemoveElementAt(lastIndex);
+  }
+
   // A variation on the RemoveElementsAt method defined above.
   void Clear() { RemoveElementsAt(0, Length()); }
 
   // This helper function combines IndexOf with RemoveElementAt to "search
   // and destroy" the first element that is equal to the given element.
   // @param aItem The item to search for.
   // @param aComp The Comparator used to determine element equality.
   // @return true if the element was found
diff --git a/xpcom/tests/TestTArray.cpp b/xpcom/tests/TestTArray.cpp
--- a/xpcom/tests/TestTArray.cpp
+++ b/xpcom/tests/TestTArray.cpp
@@ -1152,16 +1152,35 @@ static bool test_SetLengthAndRetainStora
 
 #undef FOR_EACH
 #undef LPAREN
 #undef RPAREN
 
   return true;
 }
 
+static bool test_SwapToEndAndRemoveElementAt() {
+  const uint32_t values[] = { 16, 5, 9, 512, 32, 127 };
+  const uint32_t numValues = sizeof(values) / sizeof(uint32_t);
+
+  nsTArray<uint32_t> a;
+  a.AppendElements(values, numValues);
+
+  a.SwapToEndAndRemoveElementAt(0);
+  const uint32_t expected1[] = { 127, 5, 9, 512, 32 };
+  CHECK_ARRAY(a, expected1);
+
+  int lastIndex = numValues - 2;
+  a.SwapToEndAndRemoveElementAt(lastIndex);
+  const uint32_t expected2[] = { 127, 5, 9, 512 };
+  CHECK_ARRAY(a, expected2);
+
+  return true;
+}
+
 //----
 
 typedef bool (*TestFunc)();
 #define DECL_TEST(name) { #name, name }
 
 static const struct Test {
   const char* name;
   TestFunc    func;
@@ -1180,16 +1199,17 @@ static const struct Test {
   DECL_TEST(test_autoarray),
 #endif
   DECL_TEST(test_indexof),
   DECL_TEST(test_heap),
   DECL_TEST(test_swap),
   DECL_TEST(test_fallible),
   DECL_TEST(test_conversion_operator),
   DECL_TEST(test_SetLengthAndRetainStorage_no_ctor),
+  DECL_TEST(test_SwapToEndAndRemoveElementAt),
   { nullptr, nullptr }
 };
 
 }
 
 using namespace TestTArray;
 
 int main(int argc, char **argv) {
