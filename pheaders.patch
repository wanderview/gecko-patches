# HG changeset patch
# Parent c49b47dad55445a5df085c3b223021742c6d51c8
# User Ben Kelly <ben@wanderview.com>
Refactor to remove IPC headers from Headers.h to fix windows build.

diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -75,17 +75,17 @@ ToPCacheRequest(PCacheRequest& aOut, con
   if(NS_WARN_IF(NS_FAILED(GetURLWithoutQuery(aOut.url(),
                                               aOut.urlWithoutQuery())))) {
     // Fallback to just not providing ignoreSearch support
     // TODO: Should we error out here instead?
     aIn.GetUrl(aOut.urlWithoutQuery());
   }
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
-  aOut.headers() = headers->AsPHeaders();
+  headers->GetPHeaders(aOut.headers());
   aOut.mode() = aIn.Mode();
   aOut.credentials() = aIn.Credentials();
 }
 
 static void
 ToPCacheRequest(PCacheRequest& aOut, const RequestOrScalarValueString& aIn)
 {
   nsRefPtr<Request> request;
@@ -129,17 +129,17 @@ ToPCacheRequest(PCacheRequest& aOut,
 static void
 ToPCacheResponse(PCacheResponse& aOut, const Response& aIn)
 {
   aOut.type() = aIn.Type();
   aOut.status() = aIn.Status();
   aIn.GetStatusText(aOut.statusText());
   nsRefPtr<Headers> headers = aIn.Headers_();
   MOZ_ASSERT(headers);
-  aOut.headers() = headers->AsPHeaders();
+  headers->GetPHeaders(aOut.headers());
 }
 
 static void
 ToPCacheQueryParams(PCacheQueryParams& aOut, const QueryParams& aIn)
 {
   aOut.ignoreSearch() = aIn.mIgnoreSearch.WasPassed() &&
                         aIn.mIgnoreSearch.Value();
   aOut.ignoreMethod() = aIn.mIgnoreMethod.WasPassed() &&
diff --git a/dom/cache/CacheDBSchema.cpp b/dom/cache/CacheDBSchema.cpp
--- a/dom/cache/CacheDBSchema.cpp
+++ b/dom/cache/CacheDBSchema.cpp
@@ -48,25 +48,27 @@ BindListParamsToQuery(mozIStorageStateme
 }
 
 // static
 nsresult
 CacheDBSchema::Create(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(aConn);
 
-  nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
+  nsAutoCString pragmas(
 #if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_GONK)
     // Switch the journaling mode to TRUNCATE to avoid changing the directory
     // structure at the conclusion of every transaction for devices with slower
     // file systems.
     "PRAGMA journal_mode = TRUNCATE; "
 #endif
     "PRAGMA foreign_keys = ON; "
-  ));
+  );
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
   if (NS_FAILED(rv)) { return rv; }
 
   int32_t schemaVersion;
   rv = aConn->GetSchemaVersion(&schemaVersion);
   if (NS_FAILED(rv)) { return rv; }
 
   mozStorageTransaction trans(aConn, false,
                               mozIStorageConnection::TRANSACTION_IMMEDIATE);
@@ -599,17 +601,17 @@ CacheDBSchema::InsertEntry(mozIStorageCo
     "INSERT INTO request_headers ("
       "name, "
       "value, "
       "map_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
-  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers().list();
+  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers();
   for (uint32_t i = 0; i < requestHeaders.Length(); ++i) {
     rv = statement->BindUTF8StringParameter(0, requestHeaders[i].name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindUTF8StringParameter(1, requestHeaders[i].value());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindInt32Parameter(2, mapId);
@@ -623,17 +625,17 @@ CacheDBSchema::InsertEntry(mozIStorageCo
     "INSERT INTO response_headers ("
       "name, "
       "value, "
       "map_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
-  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers().list();
+  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers();
   for (uint32_t i = 0; i < responseHeaders.Length(); ++i) {
     rv = statement->BindUTF8StringParameter(0, responseHeaders[i].name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindUTF8StringParameter(1, responseHeaders[i].value());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindInt32Parameter(2, mapId);
@@ -691,17 +693,17 @@ CacheDBSchema::ReadResponse(mozIStorageC
     "WHERE map_id=?1 "
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
   rv = statement->BindInt32Parameter(0, aEntryId);
   if (NS_FAILED(rv)) { return rv; }
 
   while(NS_SUCCEEDED(statement->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    PHeadersEntry* header = aResponseOut.headers().list().AppendElement();
+    PHeadersEntry* header = aResponseOut.headers().AppendElement();
     if (!header) { return NS_ERROR_OUT_OF_MEMORY; }
 
     rv = statement->GetUTF8String(0, header->name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->GetUTF8String(1, header->value());
     if (NS_FAILED(rv)) { return rv; }
   }
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -3,17 +3,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/CacheStorageChild.h"
 
 #include "mozilla/dom/CacheStorageChildListener.h"
 
-using mozilla::dom::CacheStorageChild;
+namespace mozilla {
+namespace dom {
+
 using mozilla::dom::cache::RequestId;
 
 CacheStorageChild::CacheStorageChild(CacheStorageChildListener& aListener)
   : mListener(&aListener)
 {
 }
 
 CacheStorageChild::~CacheStorageChild()
@@ -82,8 +84,11 @@ CacheStorageChild::RecvKeysResponse(cons
 }
 
 void
 CacheStorageChild::ClearListener()
 {
   MOZ_ASSERT(mListener);
   mListener = nullptr;
 }
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/cache/PCacheRequest.ipdlh b/dom/cache/PCacheRequest.ipdlh
--- a/dom/cache/PCacheRequest.ipdlh
+++ b/dom/cache/PCacheRequest.ipdlh
@@ -11,17 +11,17 @@ using struct mozilla::void_t from "ipc/I
 namespace mozilla {
 namespace dom {
 
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
-  PHeaders headers;
+  PHeadersEntry[] headers;
   RequestMode mode;
   RequestCredentials credentials;
 };
 
 union PCacheRequestOrVoid
 {
   void_t;
   PCacheRequest;
diff --git a/dom/cache/PCacheResponse.ipdlh b/dom/cache/PCacheResponse.ipdlh
--- a/dom/cache/PCacheResponse.ipdlh
+++ b/dom/cache/PCacheResponse.ipdlh
@@ -10,17 +10,17 @@ using mozilla::void_t from "ipc/IPCMessa
 namespace mozilla {
 namespace dom {
 
 struct PCacheResponse
 {
   ResponseType type;
   uint32_t status;
   nsCString statusText;
-  PHeaders headers;
+  PHeadersEntry[] headers;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
diff --git a/dom/fetch/Headers.cpp b/dom/fetch/Headers.cpp
--- a/dom/fetch/Headers.cpp
+++ b/dom/fetch/Headers.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/Headers.h"
 
 #include "mozilla/ErrorResult.h"
+#include "mozilla/dom/PHeaders.h"
 #include "mozilla/dom/UnionTypes.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/Preferences.h"
 
 #include "nsCharSeparatedTokenizer.h"
 #include "nsContentUtils.h"
 #include "nsDOMString.h"
 #include "nsNetUtil.h"
@@ -25,16 +26,28 @@ NS_IMPL_CYCLE_COLLECTING_ADDREF(Headers)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(Headers)
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Headers, mOwner)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Headers)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsISupports)
 NS_INTERFACE_MAP_END
 
+Headers::Headers(nsISupports* aOwner, const nsTArray<PHeadersEntry>& aHeaders,
+                 HeadersGuardEnum aGuard)
+  : mOwner(aOwner)
+  , mGuard(aGuard)
+{
+  SetIsDOMBinding();
+
+  for (uint32_t i = 0; i < aHeaders.Length(); ++i) {
+    mList.AppendElement(Entry(aHeaders[i].name(), aHeaders[i].value()));
+  }
+}
+
 // static
 bool
 Headers::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   using mozilla::dom::workers::WorkerPrivate;
   using mozilla::dom::workers::GetWorkerPrivateFromContext;
 
   if (NS_IsMainThread()) {
@@ -89,51 +102,50 @@ Headers::Append(const nsACString& aName,
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
     return;
   }
 
-  mHeaders.list().AppendElement(PHeadersEntry(nsCString(lowerName),
-                                              nsCString(aValue)));
+  mList.AppendElement(Entry(lowerName, aValue));
 }
 
 void
 Headers::Delete(const nsACString& aName, ErrorResult& aRv)
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidMutableHeader(lowerName, nullptr, aRv)) {
     return;
   }
 
   // remove in reverse order to minimize copying
-  for (int32_t i = mHeaders.list().Length() - 1; i >= 0; --i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      mHeaders.list().RemoveElementAt(i);
+  for (int32_t i = mList.Length() - 1; i >= 0; --i) {
+    if (lowerName == mList[i].mName) {
+      mList.RemoveElementAt(i);
     }
   }
 }
 
 void
 Headers::Get(const nsACString& aName, nsCString& aValue, ErrorResult& aRv) const
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return;
   }
 
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      aValue = mHeaders.list()[i].value();
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
+      aValue = mList[i].mValue;
       return;
     }
   }
 
   // No value found, so return null to content
   aValue.SetIsVoid(true);
 }
 
@@ -144,35 +156,35 @@ Headers::GetAll(const nsACString& aName,
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return;
   }
 
   aResults.SetLength(0);
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      aResults.AppendElement(mHeaders.list()[i].value());
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
+      aResults.AppendElement(mList[i].mValue);
     }
   }
 }
 
 bool
 Headers::Has(const nsACString& aName, ErrorResult& aRv) const
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return false;
   }
 
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    if (lowerName == mList[i].mName) {
       return true;
     }
   }
   return false;
 }
 
 void
 Headers::Set(const nsACString& aName, const nsACString& aValue, ErrorResult& aRv)
@@ -182,51 +194,59 @@ Headers::Set(const nsACString& aName, co
 
   if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
     return;
   }
 
   int32_t firstIndex = INT32_MAX;
 
   // remove in reverse order to minimize copying
-  for (int32_t i = mHeaders.list().Length() - 1; i >= 0; --i) {
-    if (lowerName == mHeaders.list()[i].name()) {
+  for (int32_t i = mList.Length() - 1; i >= 0; --i) {
+    if (lowerName == mList[i].mName) {
       firstIndex = std::min(firstIndex, i);
-      mHeaders.list().RemoveElementAt(i);
+      mList.RemoveElementAt(i);
     }
   }
 
   if (firstIndex < INT32_MAX) {
-    PHeadersEntry* entry = mHeaders.list().InsertElementAt(firstIndex);
-    entry->name() = lowerName;
-    entry->value() = aValue;
+    Entry* entry = mList.InsertElementAt(firstIndex);
+    entry->mName = lowerName;
+    entry->mValue = aValue;
   } else {
-    mHeaders.list().AppendElement(PHeadersEntry(nsCString(lowerName), nsCString(aValue)));
+    mList.AppendElement(Entry(lowerName, aValue));
   }
 }
 
 void
 Headers::SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv)
 {
   // Rather than re-validate all current headers, just require code to set
   // this prior to populating the Headers object.  Allow setting immutable
   // late, though, as that is pretty much required to have a  useful, immutable
   // headers object.
-  if (aGuard != HeadersGuardEnum::Immutable && mHeaders.list().Length() > 0) {
+  if (aGuard != HeadersGuardEnum::Immutable && mList.Length() > 0) {
     aRv.Throw(NS_ERROR_FAILURE);
   }
   mGuard = aGuard;
 }
 
 JSObject*
 Headers::WrapObject(JSContext* aCx)
 {
   return mozilla::dom::HeadersBinding::Wrap(aCx, this);
 }
 
+void
+Headers::GetPHeaders(nsTArray<PHeadersEntry>& aPHeadersOut) const
+{
+  for (uint32_t i = 0; i < mList.Length(); ++i) {
+    aPHeadersOut.AppendElement(PHeadersEntry(mList[i].mName, mList[i].mValue));
+  }
+}
+
 Headers::~Headers()
 {
 }
 
 // static
 bool
 Headers::IsSimpleHeader(const nsACString& aName, const nsACString* aValue)
 {
@@ -295,17 +315,17 @@ Headers::IsForbiddenResponseHeader(const
 {
   return mGuard == HeadersGuardEnum::Response &&
          nsContentUtils::IsForbiddenResponseHeader(aName);
 }
 
 void
 Headers::Fill(const Headers& aInit, ErrorResult&)
 {
-  mHeaders.list() = aInit.mHeaders.list();
+  mList = aInit.mList;
 }
 
 void
 Headers::Fill(const Sequence<Sequence<nsCString>>& aInit, ErrorResult& aRv)
 {
   for (uint32_t i = 0; i < aInit.Length() && !aRv.Failed(); ++i) {
     const Sequence<nsCString>& tuple = aInit[i];
     if (tuple.Length() != 2) {
diff --git a/dom/fetch/Headers.h b/dom/fetch/Headers.h
--- a/dom/fetch/Headers.h
+++ b/dom/fetch/Headers.h
@@ -3,56 +3,65 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_Headers_h
 #define mozilla_dom_Headers_h
 
 #include "mozilla/dom/HeadersBinding.h"
-#include "mozilla/dom/PHeaders.h"
+#include "nsTArray.h"
 #include "nsWrapperCache.h"
 
 class nsPIDOMWindow;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
 template<typename T> class MozMap;
 class HeadersOrByteStringSequenceSequenceOrByteStringMozMap;
+class PHeadersEntry;
 
 class Headers MOZ_FINAL : public nsISupports
                         , public nsWrapperCache
 {
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Headers)
 
 private:
+  struct Entry
+  {
+    Entry(const nsACString& aName, const nsACString& aValue)
+      : mName(aName)
+      , mValue(aValue)
+    { }
+
+    Entry() { }
+
+    nsCString mName;
+    nsCString mValue;
+  };
+
   nsRefPtr<nsISupports> mOwner;
   HeadersGuardEnum mGuard;
-  PHeaders mHeaders;
+  nsTArray<Entry> mList;
 
 public:
   explicit Headers(nsISupports* aOwner, HeadersGuardEnum aGuard = HeadersGuardEnum::Default)
     : mOwner(aOwner)
     , mGuard(aGuard)
   {
     SetIsDOMBinding();
   }
 
-  Headers(nsISupports* aOwner, const PHeaders& aHeaders,
-          HeadersGuardEnum aGuard = HeadersGuardEnum::Default)
-    : mOwner(aOwner)
-    , mGuard(aGuard)
-    , mHeaders(aHeaders)
-  {
-  }
+  Headers(nsISupports* aOwner, const nsTArray<PHeadersEntry>& aHeaders,
+          HeadersGuardEnum aGuard = HeadersGuardEnum::Default);
 
   static bool PrefEnabled(JSContext* cx, JSObject* obj);
 
   static already_AddRefed<Headers>
   Constructor(const GlobalObject& aGlobal,
               const Optional<HeadersOrByteStringSequenceSequenceOrByteStringMozMap>& aInit,
               ErrorResult& aRv);
 
@@ -67,17 +76,17 @@ public:
 
   // ChromeOnly
   HeadersGuardEnum Guard() const { return mGuard; }
   void SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv);
 
   virtual JSObject* WrapObject(JSContext* aCx);
   nsISupports* GetParentObject() const { return mOwner; }
 
-  PHeaders& AsPHeaders() { return mHeaders; }
+  void GetPHeaders(nsTArray<PHeadersEntry>& aPHeadersOut) const;
 
 private:
   Headers(const Headers& aOther) MOZ_DELETE;
   virtual ~Headers();
 
   static bool IsSimpleHeader(const nsACString& aName,
                              const nsACString* aValue = nullptr);
   static bool IsInvalidName(const nsACString& aName, ErrorResult& aRv);
diff --git a/dom/fetch/PHeaders.ipdlh b/dom/fetch/PHeaders.ipdlh
--- a/dom/fetch/PHeaders.ipdlh
+++ b/dom/fetch/PHeaders.ipdlh
@@ -6,15 +6,10 @@ namespace mozilla {
 namespace dom {
 
 struct PHeadersEntry
 {
   nsCString name;
   nsCString value;
 };
 
-struct PHeaders
-{
-  PHeadersEntry[] list;
-};
-
 } // namespace dom
 } // namespace mozilla
