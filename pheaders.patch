# HG changeset patch
# Parent c49b47dad55445a5df085c3b223021742c6d51c8
# User Ben Kelly <ben@wanderview.com>
Simplify PHeaders ipdl to avoid unnecessary top level type.


diff --git a/dom/cache/CacheDBSchema.cpp b/dom/cache/CacheDBSchema.cpp
--- a/dom/cache/CacheDBSchema.cpp
+++ b/dom/cache/CacheDBSchema.cpp
@@ -599,17 +599,17 @@ CacheDBSchema::InsertEntry(mozIStorageCo
     "INSERT INTO request_headers ("
       "name, "
       "value, "
       "map_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
-  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers().list();
+  const nsTArray<PHeadersEntry>& requestHeaders = aRequest.headers();
   for (uint32_t i = 0; i < requestHeaders.Length(); ++i) {
     rv = statement->BindUTF8StringParameter(0, requestHeaders[i].name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindUTF8StringParameter(1, requestHeaders[i].value());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindInt32Parameter(2, mapId);
@@ -623,17 +623,17 @@ CacheDBSchema::InsertEntry(mozIStorageCo
     "INSERT INTO response_headers ("
       "name, "
       "value, "
       "map_id "
     ") VALUES (?1, ?2, ?3)"
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
-  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers().list();
+  const nsTArray<PHeadersEntry>& responseHeaders = aResponse.headers();
   for (uint32_t i = 0; i < responseHeaders.Length(); ++i) {
     rv = statement->BindUTF8StringParameter(0, responseHeaders[i].name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindUTF8StringParameter(1, responseHeaders[i].value());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->BindInt32Parameter(2, mapId);
@@ -691,17 +691,17 @@ CacheDBSchema::ReadResponse(mozIStorageC
     "WHERE map_id=?1 "
   ), getter_AddRefs(statement));
   if (NS_FAILED(rv)) { return rv; }
 
   rv = statement->BindInt32Parameter(0, aEntryId);
   if (NS_FAILED(rv)) { return rv; }
 
   while(NS_SUCCEEDED(statement->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    PHeadersEntry* header = aResponseOut.headers().list().AppendElement();
+    PHeadersEntry* header = aResponseOut.headers().AppendElement();
     if (!header) { return NS_ERROR_OUT_OF_MEMORY; }
 
     rv = statement->GetUTF8String(0, header->name());
     if (NS_FAILED(rv)) { return rv; }
 
     rv = statement->GetUTF8String(1, header->value());
     if (NS_FAILED(rv)) { return rv; }
   }
diff --git a/dom/cache/PCacheRequest.ipdlh b/dom/cache/PCacheRequest.ipdlh
--- a/dom/cache/PCacheRequest.ipdlh
+++ b/dom/cache/PCacheRequest.ipdlh
@@ -11,17 +11,17 @@ using struct mozilla::void_t from "ipc/I
 namespace mozilla {
 namespace dom {
 
 struct PCacheRequest
 {
   nsCString method;
   nsString url;
   nsString urlWithoutQuery;
-  PHeaders headers;
+  PHeadersEntry[] headers;
   RequestMode mode;
   RequestCredentials credentials;
 };
 
 union PCacheRequestOrVoid
 {
   void_t;
   PCacheRequest;
diff --git a/dom/cache/PCacheResponse.ipdlh b/dom/cache/PCacheResponse.ipdlh
--- a/dom/cache/PCacheResponse.ipdlh
+++ b/dom/cache/PCacheResponse.ipdlh
@@ -10,17 +10,17 @@ using mozilla::void_t from "ipc/IPCMessa
 namespace mozilla {
 namespace dom {
 
 struct PCacheResponse
 {
   ResponseType type;
   uint32_t status;
   nsCString statusText;
-  PHeaders headers;
+  PHeadersEntry[] headers;
 };
 
 union PCacheResponseOrVoid
 {
   void_t;
   PCacheResponse;
 };
 
diff --git a/dom/fetch/Headers.cpp b/dom/fetch/Headers.cpp
--- a/dom/fetch/Headers.cpp
+++ b/dom/fetch/Headers.cpp
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/Headers.h"
 
 #include "mozilla/ErrorResult.h"
+#include "mozilla/dom/PHeaders.h"
 #include "mozilla/dom/UnionTypes.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/Preferences.h"
 
 #include "nsCharSeparatedTokenizer.h"
 #include "nsContentUtils.h"
 #include "nsDOMString.h"
 #include "nsNetUtil.h"
@@ -89,51 +90,51 @@ Headers::Append(const nsACString& aName,
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
     return;
   }
 
-  mHeaders.list().AppendElement(PHeadersEntry(nsCString(lowerName),
+  mHeaders.AppendElement(PHeadersEntry(nsCString(lowerName),
                                               nsCString(aValue)));
 }
 
 void
 Headers::Delete(const nsACString& aName, ErrorResult& aRv)
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidMutableHeader(lowerName, nullptr, aRv)) {
     return;
   }
 
   // remove in reverse order to minimize copying
-  for (int32_t i = mHeaders.list().Length() - 1; i >= 0; --i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      mHeaders.list().RemoveElementAt(i);
+  for (int32_t i = mHeaders.Length() - 1; i >= 0; --i) {
+    if (lowerName == mHeaders[i].name()) {
+      mHeaders.RemoveElementAt(i);
     }
   }
 }
 
 void
 Headers::Get(const nsACString& aName, nsCString& aValue, ErrorResult& aRv) const
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return;
   }
 
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      aValue = mHeaders.list()[i].value();
+  for (uint32_t i = 0; i < mHeaders.Length(); ++i) {
+    if (lowerName == mHeaders[i].name()) {
+      aValue = mHeaders[i].value();
       return;
     }
   }
 
   // No value found, so return null to content
   aValue.SetIsVoid(true);
 }
 
@@ -144,35 +145,35 @@ Headers::GetAll(const nsACString& aName,
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return;
   }
 
   aResults.SetLength(0);
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
-      aResults.AppendElement(mHeaders.list()[i].value());
+  for (uint32_t i = 0; i < mHeaders.Length(); ++i) {
+    if (lowerName == mHeaders[i].name()) {
+      aResults.AppendElement(mHeaders[i].value());
     }
   }
 }
 
 bool
 Headers::Has(const nsACString& aName, ErrorResult& aRv) const
 {
   nsAutoCString lowerName;
   ToLowerCase(aName, lowerName);
 
   if (IsInvalidName(lowerName, aRv)) {
     return false;
   }
 
-  for (uint32_t i = 0; i < mHeaders.list().Length(); ++i) {
-    if (lowerName == mHeaders.list()[i].name()) {
+  for (uint32_t i = 0; i < mHeaders.Length(); ++i) {
+    if (lowerName == mHeaders[i].name()) {
       return true;
     }
   }
   return false;
 }
 
 void
 Headers::Set(const nsACString& aName, const nsACString& aValue, ErrorResult& aRv)
@@ -182,40 +183,40 @@ Headers::Set(const nsACString& aName, co
 
   if (IsInvalidMutableHeader(lowerName, &aValue, aRv)) {
     return;
   }
 
   int32_t firstIndex = INT32_MAX;
 
   // remove in reverse order to minimize copying
-  for (int32_t i = mHeaders.list().Length() - 1; i >= 0; --i) {
-    if (lowerName == mHeaders.list()[i].name()) {
+  for (int32_t i = mHeaders.Length() - 1; i >= 0; --i) {
+    if (lowerName == mHeaders[i].name()) {
       firstIndex = std::min(firstIndex, i);
-      mHeaders.list().RemoveElementAt(i);
+      mHeaders.RemoveElementAt(i);
     }
   }
 
   if (firstIndex < INT32_MAX) {
-    PHeadersEntry* entry = mHeaders.list().InsertElementAt(firstIndex);
+    PHeadersEntry* entry = mHeaders.InsertElementAt(firstIndex);
     entry->name() = lowerName;
     entry->value() = aValue;
   } else {
-    mHeaders.list().AppendElement(PHeadersEntry(nsCString(lowerName), nsCString(aValue)));
+    mHeaders.AppendElement(PHeadersEntry(nsCString(lowerName), nsCString(aValue)));
   }
 }
 
 void
 Headers::SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv)
 {
   // Rather than re-validate all current headers, just require code to set
   // this prior to populating the Headers object.  Allow setting immutable
   // late, though, as that is pretty much required to have a  useful, immutable
   // headers object.
-  if (aGuard != HeadersGuardEnum::Immutable && mHeaders.list().Length() > 0) {
+  if (aGuard != HeadersGuardEnum::Immutable && mHeaders.Length() > 0) {
     aRv.Throw(NS_ERROR_FAILURE);
   }
   mGuard = aGuard;
 }
 
 JSObject*
 Headers::WrapObject(JSContext* aCx)
 {
@@ -295,17 +296,17 @@ Headers::IsForbiddenResponseHeader(const
 {
   return mGuard == HeadersGuardEnum::Response &&
          nsContentUtils::IsForbiddenResponseHeader(aName);
 }
 
 void
 Headers::Fill(const Headers& aInit, ErrorResult&)
 {
-  mHeaders.list() = aInit.mHeaders.list();
+  mHeaders = aInit.mHeaders;
 }
 
 void
 Headers::Fill(const Sequence<Sequence<nsCString>>& aInit, ErrorResult& aRv)
 {
   for (uint32_t i = 0; i < aInit.Length() && !aRv.Failed(); ++i) {
     const Sequence<nsCString>& tuple = aInit[i];
     if (tuple.Length() != 2) {
diff --git a/dom/fetch/Headers.h b/dom/fetch/Headers.h
--- a/dom/fetch/Headers.h
+++ b/dom/fetch/Headers.h
@@ -4,49 +4,51 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_Headers_h
 #define mozilla_dom_Headers_h
 
 #include "mozilla/dom/HeadersBinding.h"
 #include "mozilla/dom/PHeaders.h"
+#include "nsTArray.h"
 #include "nsWrapperCache.h"
 
 class nsPIDOMWindow;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
 
 template<typename T> class MozMap;
 class HeadersOrByteStringSequenceSequenceOrByteStringMozMap;
+class PHeadersEntry;
 
 class Headers MOZ_FINAL : public nsISupports
                         , public nsWrapperCache
 {
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(Headers)
 
 private:
   nsRefPtr<nsISupports> mOwner;
   HeadersGuardEnum mGuard;
-  PHeaders mHeaders;
+  nsTArray<PHeadersEntry> mHeaders;
 
 public:
   explicit Headers(nsISupports* aOwner, HeadersGuardEnum aGuard = HeadersGuardEnum::Default)
     : mOwner(aOwner)
     , mGuard(aGuard)
   {
     SetIsDOMBinding();
   }
 
-  Headers(nsISupports* aOwner, const PHeaders& aHeaders,
+  Headers(nsISupports* aOwner, const nsTArray<PHeadersEntry>& aHeaders,
           HeadersGuardEnum aGuard = HeadersGuardEnum::Default)
     : mOwner(aOwner)
     , mGuard(aGuard)
     , mHeaders(aHeaders)
   {
   }
 
   static bool PrefEnabled(JSContext* cx, JSObject* obj);
@@ -67,17 +69,17 @@ public:
 
   // ChromeOnly
   HeadersGuardEnum Guard() const { return mGuard; }
   void SetGuard(HeadersGuardEnum aGuard, ErrorResult& aRv);
 
   virtual JSObject* WrapObject(JSContext* aCx);
   nsISupports* GetParentObject() const { return mOwner; }
 
-  PHeaders& AsPHeaders() { return mHeaders; }
+  nsTArray<PHeadersEntry>& AsPHeaders() { return mHeaders; }
 
 private:
   Headers(const Headers& aOther) MOZ_DELETE;
   virtual ~Headers();
 
   static bool IsSimpleHeader(const nsACString& aName,
                              const nsACString* aValue = nullptr);
   static bool IsInvalidName(const nsACString& aName, ErrorResult& aRv);
diff --git a/dom/fetch/PHeaders.ipdlh b/dom/fetch/PHeaders.ipdlh
--- a/dom/fetch/PHeaders.ipdlh
+++ b/dom/fetch/PHeaders.ipdlh
@@ -6,15 +6,10 @@ namespace mozilla {
 namespace dom {
 
 struct PHeadersEntry
 {
   nsCString name;
   nsCString value;
 };
 
-struct PHeaders
-{
-  PHeadersEntry[] list;
-};
-
 } // namespace dom
 } // namespace mozilla
