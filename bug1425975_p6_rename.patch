# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b94e86888476eade62232624e4fe033f7162bde5
Bug 1425975 P6 Rename some service worker methods to not reference documents. r=asuth

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1613,17 +1613,17 @@ ServiceWorkerManager::WorkerIsIdle(Servi
   if (!reg) {
     return;
   }
 
   if (reg->GetActive() != aWorker) {
     return;
   }
 
-  if (!reg->IsControllingDocuments() && reg->mPendingUninstall) {
+  if (!reg->IsControllingClients() && reg->mPendingUninstall) {
     RemoveRegistration(reg);
     return;
   }
 
   reg->TryToActivateAsync();
 }
 
 already_AddRefed<ServiceWorkerJobQueue>
@@ -2361,17 +2361,17 @@ ServiceWorkerManager::MaybeStopControlli
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   mControlledDocuments.Remove(aDoc, getter_AddRefs(registration));
   // A document which was uncontrolled does not maintain that state itself, so
   // it will always call MaybeStopControlling() even if there isn't an
   // associated registration. So this check is required.
   if (registration) {
-    StopControllingADocument(registration);
+    StopControllingRegistration(registration);
   }
 }
 
 void
 ServiceWorkerManager::MaybeCheckNavigationUpdate(nsIDocument* aDoc)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aDoc);
@@ -2414,17 +2414,17 @@ ServiceWorkerManager::StartControllingAD
 
   Maybe<ClientInfo> clientInfo = aDoc->GetClientInfo();
   if (NS_WARN_IF(clientInfo.isNothing())) {
     ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
                                           __func__);
     return ref.forget();
   }
 
-  aRegistration->StartControllingADocument();
+  aRegistration->StartControllingClient();
   mControlledDocuments.Put(aDoc, aRegistration);
 
   StartControllingClient(clientInfo.ref(), aRegistration);
 
   // Mark the document's ClientSource as controlled using the ClientHandle
   // interface.  While we could get at the ClientSource directly from the
   // document here, our goal is to move ServiceWorkerManager to a separate
   // process.  Using the ClientHandle supports this remote operation.
@@ -2433,20 +2433,20 @@ ServiceWorkerManager::StartControllingAD
                                 SystemGroup::EventTargetFor(TaskCategory::Other));
   ref = Move(clientHandle->Control(activeWorker->Descriptor()));
 
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
   return Move(ref);
 }
 
 void
-ServiceWorkerManager::StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration)
+ServiceWorkerManager::StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  aRegistration->StopControllingADocument();
-  if (aRegistration->IsControllingDocuments() || !aRegistration->IsIdle()) {
+  aRegistration->StopControllingClient();
+  if (aRegistration->IsControllingClients() || !aRegistration->IsIdle()) {
     return;
   }
 
   if (aRegistration->mPendingUninstall) {
     RemoveRegistration(aRegistration);
     return;
   }
 
@@ -3241,17 +3241,17 @@ ServiceWorkerManager::MaybeClaimClient(n
 
   if (aWorkerRegistration != matchingRegistration ||
       aWorkerRegistration == controllingRegistration) {
     ref = GenericPromise::CreateAndResolve(true, __func__);
     return ref.forget();
   }
 
   if (controllingRegistration) {
-    StopControllingADocument(controllingRegistration);
+    StopControllingRegistration(controllingRegistration);
   }
 
   ref = StartControllingADocument(aWorkerRegistration, aDocument);
   return ref.forget();
 }
 
 already_AddRefed<GenericPromise>
 ServiceWorkerManager::MaybeClaimClient(nsIDocument* aDoc,
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -398,17 +398,17 @@ private:
   void
   NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
 
   RefPtr<GenericPromise>
   StartControllingADocument(ServiceWorkerRegistrationInfo* aRegistration,
                             nsIDocument* aDoc);
 
   void
-  StopControllingADocument(ServiceWorkerRegistrationInfo* aRegistration);
+  StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.cpp b/dom/workers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/workers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/workers/ServiceWorkerRegistrationInfo.cpp
@@ -76,30 +76,30 @@ ServiceWorkerRegistrationInfo::Clear()
 
   NotifyChromeRegistrationListeners();
 }
 
 ServiceWorkerRegistrationInfo::ServiceWorkerRegistrationInfo(
     const nsACString& aScope,
     nsIPrincipal* aPrincipal,
     ServiceWorkerUpdateViaCache aUpdateViaCache)
-  : mControlledDocumentsCounter(0)
+  : mControlledClientsCounter(0)
   , mUpdateState(NoUpdate)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mLastUpdateTime(0)
   , mUpdateViaCache(aUpdateViaCache)
   , mScope(aScope)
   , mPrincipal(aPrincipal)
   , mPendingUninstall(false)
 {}
 
 ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
 {
-  if (IsControllingDocuments()) {
+  if (IsControllingClients()) {
     NS_WARNING("ServiceWorkerRegistrationInfo is still controlling documents. This can be a bug or a leak in ServiceWorker API or in any other API that takes the document alive.");
   }
 }
 
 NS_IMPL_ISUPPORTS(ServiceWorkerRegistrationInfo, nsIServiceWorkerRegistrationInfo)
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetPrincipal(nsIPrincipal** aPrincipal)
@@ -243,17 +243,17 @@ ServiceWorkerRegistrationInfo::TryToActi
 
 /*
  * TryToActivate should not be called directly, use TryToActivateAsync instead.
  */
 void
 ServiceWorkerRegistrationInfo::TryToActivate()
 {
   AssertIsOnMainThread();
-  bool controlling = IsControllingDocuments();
+  bool controlling = IsControllingClients();
   bool skipWaiting = mWaitingWorker && mWaitingWorker->SkipWaitingFlag();
   bool idle = IsIdle();
   if (idle && (!controlling || skipWaiting)) {
     Activate();
   }
 }
 
 void
diff --git a/dom/workers/ServiceWorkerRegistrationInfo.h b/dom/workers/ServiceWorkerRegistrationInfo.h
--- a/dom/workers/ServiceWorkerRegistrationInfo.h
+++ b/dom/workers/ServiceWorkerRegistrationInfo.h
@@ -12,17 +12,17 @@
 
 namespace mozilla {
 namespace dom {
 namespace workers {
 
 class ServiceWorkerRegistrationInfo final
   : public nsIServiceWorkerRegistrationInfo
 {
-  uint32_t mControlledDocumentsCounter;
+  uint32_t mControlledClientsCounter;
 
   enum
   {
     NoUpdate,
     NeedTimeCheckAndUpdate,
     NeedUpdate
   } mUpdateState;
 
@@ -74,32 +74,32 @@ public:
 
     return newest.forget();
   }
 
   already_AddRefed<ServiceWorkerInfo>
   GetServiceWorkerInfoById(uint64_t aId);
 
   void
-  StartControllingADocument()
+  StartControllingClient()
   {
-    ++mControlledDocumentsCounter;
+    ++mControlledClientsCounter;
   }
 
   void
-  StopControllingADocument()
+  StopControllingClient()
   {
-    MOZ_ASSERT(mControlledDocumentsCounter);
-    --mControlledDocumentsCounter;
+    MOZ_ASSERT(mControlledClientsCounter);
+    --mControlledClientsCounter;
   }
 
   bool
-  IsControllingDocuments() const
+  IsControllingClients() const
   {
-    return mActiveWorker && mControlledDocumentsCounter;
+    return mActiveWorker && mControlledClientsCounter;
   }
 
   void
   Clear();
 
   void
   TryToActivateAsync();
 
diff --git a/dom/workers/ServiceWorkerUnregisterJob.cpp b/dom/workers/ServiceWorkerUnregisterJob.cpp
--- a/dom/workers/ServiceWorkerUnregisterJob.cpp
+++ b/dom/workers/ServiceWorkerUnregisterJob.cpp
@@ -133,17 +133,17 @@ ServiceWorkerUnregisterJob::Unregister()
   // "Set registration's uninstalling flag."
   registration->mPendingUninstall = true;
 
   // "Resolve promise with true"
   mResult = true;
   InvokeResultCallbacks(NS_OK);
 
   // "If no service worker client is using registration..."
-  if (!registration->IsControllingDocuments() && registration->IsIdle()) {
+  if (!registration->IsControllingClients() && registration->IsIdle()) {
     // "Invoke [[Clear Registration]]..."
     swm->RemoveRegistration(registration);
   }
 
   Finish(NS_OK);
 }
 
 } // namespace workers
