# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8134a71748db7f1d065147bfaf21e371e4474ce7
Bug 1325254 P1 Make TimerThread::mTimers store RefPtr<nsTimerImpl> objects. r=froydnj

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -358,17 +358,17 @@ nsresult
 TimerThread::Shutdown()
 {
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown begin\n"));
 
   if (!mThread) {
     return NS_ERROR_NOT_INITIALIZED;
   }
 
-  nsTArray<nsTimerImpl*> timers;
+  nsTArray<RefPtr<nsTimerImpl>> timers;
   {
     // lock scope
     MonitorAutoLock lock(mMonitor);
 
     mShutdown = true;
 
     // notify the cond var so that Run() can return
     if (mWaiting) {
@@ -377,25 +377,23 @@ TimerThread::Shutdown()
     }
 
     // Need to copy content of mTimers array to a local array
     // because call to timers' ReleaseCallback() (and release its self)
     // must not be done under the lock. Destructor of a callback
     // might potentially call some code reentering the same lock
     // that leads to unexpected behavior or deadlock.
     // See bug 422472.
-    timers.AppendElements(mTimers);
-    mTimers.Clear();
+    mTimers.SwapElements(timers);
   }
 
   uint32_t timersCount = timers.Length();
   for (uint32_t i = 0; i < timersCount; i++) {
-    nsTimerImpl* timer = timers[i];
+    RefPtr<nsTimerImpl> timer = timers[i].forget();
     timer->ReleaseCallback();
-    ReleaseTimerInternal(timer);
   }
 
   mThread->Shutdown();    // wait for the thread to die
 
   nsTimerEvent::Shutdown();
 
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown end\n"));
   return NS_OK;
@@ -633,53 +631,36 @@ TimerThread::AddTimerInternal(nsTimerImp
   mMonitor.AssertCurrentThreadOwns();
   if (mShutdown) {
     return -1;
   }
 
   TimeStamp now = TimeStamp::Now();
 
   TimerAdditionComparator c(now, aTimer);
-  nsTimerImpl** insertSlot = mTimers.InsertElementSorted(aTimer, c);
+  RefPtr<nsTimerImpl>* insertSlot = mTimers.InsertElementSorted(aTimer, c);
 
   if (!insertSlot) {
     return -1;
   }
 
-  NS_ADDREF(aTimer);
-
 #ifdef MOZ_TASK_TRACER
   // Caller of AddTimer is the parent task of its timer event, so we store the
   // TraceInfo here for later used.
   aTimer->GetTLSTraceInfo();
 #endif
 
   return insertSlot - mTimers.Elements();
 }
 
 bool
 TimerThread::RemoveTimerInternal(nsTimerImpl* aTimer)
 {
   mMonitor.AssertCurrentThreadOwns();
-  if (!mTimers.RemoveElement(aTimer)) {
-    return false;
-  }
-
-  ReleaseTimerInternal(aTimer);
-  return true;
-}
-
-void
-TimerThread::ReleaseTimerInternal(nsTimerImpl* aTimer)
-{
-  if (!mShutdown) {
-    // copied to a local array before releasing in shutdown
-    mMonitor.AssertCurrentThreadOwns();
-  }
-  NS_RELEASE(aTimer);
+  mTimers.RemoveElement(aTimer);
 }
 
 already_AddRefed<nsTimerImpl>
 TimerThread::PostTimerEvent(already_AddRefed<nsTimerImpl> aTimerRef)
 {
   mMonitor.AssertCurrentThreadOwns();
 
   RefPtr<nsTimerImpl> timer(aTimerRef);
diff --git a/xpcom/threads/TimerThread.h b/xpcom/threads/TimerThread.h
--- a/xpcom/threads/TimerThread.h
+++ b/xpcom/threads/TimerThread.h
@@ -72,17 +72,17 @@ private:
   nsCOMPtr<nsIThread> mThread;
   Monitor mMonitor;
 
   bool mShutdown;
   bool mWaiting;
   bool mNotified;
   bool mSleeping;
 
-  nsTArray<nsTimerImpl*> mTimers;
+  nsTArray<RefPtr<nsTimerImpl>> mTimers;
 };
 
 struct TimerAdditionComparator
 {
   TimerAdditionComparator(const mozilla::TimeStamp& aNow,
                           nsTimerImpl* aTimerToInsert) :
     now(aNow)
 #ifdef DEBUG
