# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  fc148a99f8a6fd2ee24a448232a5d895f28073c7
Bug 1300659 P3 Make setTimeout() and setInterval() use the MainThreadTaskQueue. r=smaug

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -548,18 +548,32 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsTime
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsTimeout)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mWindow)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mScriptHandler)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTimeout, AddRef)
 NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTimeout, Release)
 
 nsresult
-nsTimeout::InitTimer(uint32_t aDelay)
-{
+nsTimeout::InitTimer(nsIEventTarget* aTarget, uint32_t aDelay)
+{
+  // If the given target does not match the timer's current target
+  // then we need to override it before the Init.  Note that GetTarget()
+  // will return the current thread after setting the target to nullptr.
+  // So we need to special case the nullptr target comparison.
+  nsCOMPtr<nsIEventTarget> currentTarget;
+  MOZ_ALWAYS_SUCCEEDS(mTimer->GetTarget(getter_AddRefs(currentTarget)));
+  if ((aTarget && currentTarget != aTarget) ||
+      (!aTarget && currentTarget != NS_GetCurrentThread())) {
+    // Always call Cancel() in case we are re-using a timer.  Otherwise
+    // the subsequent SetTarget() may fail.
+    MOZ_ALWAYS_SUCCEEDS(mTimer->Cancel());
+    MOZ_ALWAYS_SUCCEEDS(mTimer->SetTarget(aTarget));
+  }
+
   return mTimer->InitWithNameableFuncCallback(
     nsGlobalWindow::TimerCallback, this, aDelay,
     nsITimer::TYPE_ONE_SHOT, nsGlobalWindow::TimerNameCallback);
 }
 
 // Return true if this timeout has a refcount of 1. This is used to check
 // that dummy_timeout doesn't leak from nsGlobalWindow::RunTimeout.
 bool
@@ -11823,17 +11837,17 @@ nsGlobalWindow::Resume()
     uint32_t delay = std::max(remaining, DOMMinTimeoutValue());
 
     t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
     if (!t->mTimer) {
       t->remove();
       continue;
     }
 
-    nsresult rv = t->InitTimer(delay);
+    nsresult rv = t->InitTimer(GetMainThreadTaskQueue(), delay);
     if (NS_FAILED(rv)) {
       t->mTimer = nullptr;
       t->remove();
       continue;
     }
 
     // Add a reference for the new timer's closure.
     t->AddRef();
@@ -12527,17 +12541,17 @@ nsGlobalWindow::SetTimeoutOrInterval(nsI
     nsresult rv;
     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     RefPtr<nsTimeout> copy = timeout;
 
-    rv = timeout->InitTimer(realInterval);
+    rv = timeout->InitTimer(GetMainThreadTaskQueue(), realInterval);
     if (NS_FAILED(rv)) {
       return rv;
     }
 
     // The timeout is now also held in the timer's closure.
     Unused << copy.forget();
   }
 
@@ -12791,17 +12805,18 @@ nsGlobalWindow::RescheduleTimeout(nsTime
     aTimeout->mTimeRemaining = delay;
     return true;
   }
 
   aTimeout->mWhen = currentNow + delay;
 
   // Reschedule the OS timer. Don't bother returning any error codes if
   // this fails since the callers of this method don't care about them.
-  nsresult rv = aTimeout->InitTimer(delay.ToMilliseconds());
+  nsresult rv = aTimeout->InitTimer(GetMainThreadTaskQueue(),
+                                    delay.ToMilliseconds());
 
   if (NS_FAILED(rv)) {
     NS_ERROR("Error initializing timer for DOM timeout!");
 
     // We failed to initialize the new OS timer, this timer does
     // us no good here so we just cancel it (just in case) and
     // null out the pointer to the OS timer, this will release the
     // OS timer. As we continue executing the code below we'll end
@@ -12850,31 +12865,63 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
     // timers that *should* have fired before aTimeout *will* be fired
     // now.
 
     deadline = aTimeout->mWhen;
   } else {
     deadline = now;
   }
 
+  // Run a limited number of timers at once to avoid janking the main
+  // thread.  Any timers beyond this will get picked up on the next
+  // timer runnable which should fire immediately.  Chrome windows are
+  // exempty from this limit.
+  static const uint32_t kMaxSequentialTimeouts = 1;
+
   // The timeout list is kept in deadline order. Discover the latest timeout
   // whose deadline has expired. On some platforms, native timeout events fire
   // "early", but we handled that above by setting deadline to aTimeout->mWhen
   // if the timer fired early.  So we can stop walking if we get to timeouts
   // whose mWhen is greater than deadline, since once that happens we know
   // nothing past that point is expired.
   last_expired_timeout = nullptr;
+  uint32_t count = 0;
+  bool foundTarget = false;
   for (nsTimeout *timeout = mTimeouts.getFirst();
        timeout && timeout->mWhen <= deadline;
        timeout = timeout->getNext()) {
     if (timeout->mFiringDepth == 0) {
       // Mark any timeouts that are on the list to be fired with the
       // firing depth so that we can reentrantly run timeouts
       timeout->mFiringDepth = firingDepth;
       last_expired_timeout = timeout;
+
+      // Note that we have seen the timer this runnable was dispatched
+      // to fire.
+      if (timeout == aTimeout) {
+        foundTarget = true;
+      }
+
+      // Apply throttling to the number of timers we will fire in a
+      // single runnable before yielding the main thread.
+      //
+      // While we would like to throttle immediately after finding our
+      // limited number of timers, we MUST fire our target timer.  We
+      // cannot rely on another timer's runnable firing because that
+      // timer might get cleared as a result of this runnable.
+      //
+      // Note, the fact that our target timeout is not always the first
+      // timer we encounter suggests we have other bugs.  We should
+      // receive timer callbacks in the same order we store our mTimers
+      // list.  It seems they can come slightly out of order after
+      // suspend/resume, however.
+      count += 1;
+      if (foundTarget && count >= kMaxSequentialTimeouts && !IsChromeWindow()) {
+        break;
+      }
     }
   }
 
   // Maybe the timeout that the event was fired for has been deleted
   // and there are no others timeouts with deadlines that make them
   // eligible for execution yet. Go away.
   if (!last_expired_timeout) {
     return;
@@ -13083,17 +13130,18 @@ nsresult nsGlobalWindow::ResetTimersForN
       timeout->remove();
       // InsertTimeoutIntoList will addref |timeout| and reset
       // mFiringDepth.  Make sure to undo that after calling it.
       uint32_t firingDepth = timeout->mFiringDepth;
       InsertTimeoutIntoList(timeout);
       timeout->mFiringDepth = firingDepth;
       timeout->Release();
 
-      nsresult rv = timeout->InitTimer(delay.ToMilliseconds());
+      nsresult rv = timeout->InitTimer(GetMainThreadTaskQueue(),
+                                       delay.ToMilliseconds());
 
       if (NS_FAILED(rv)) {
         NS_WARNING("Error resetting non background timer for DOM timeout!");
         return rv;
       }
 
       timeout = nextTimeout;
     } else {
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -160,17 +160,20 @@ private:
   ~nsTimeout();
 
 public:
   nsTimeout();
 
   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsTimeout)
   NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING(nsTimeout)
 
-  nsresult InitTimer(uint32_t aDelay);
+  // The callback target may be specified to use a particular task queue
+  // for the resulting timer runnable.  A nullptr callback target will result
+  // in the default main thread being used.
+  nsresult InitTimer(nsIEventTarget* aCallbackTarget, uint32_t aDelay);
 
   bool HasRefCntOne();
 
   // Window for which this timeout fires
   RefPtr<nsGlobalWindow> mWindow;
 
   // The actual timer object
   nsCOMPtr<nsITimer> mTimer;
