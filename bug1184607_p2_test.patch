# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  01352f84500564c3c70e2cc5c5bacfb529bff66c
Bug 1184607 P2 Add a wpt test to verify service worker redirect logic. r=ehsan

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -609,16 +609,17 @@ FetchDriver::BeginAndGetFilteredResponse
       break;
     case InternalRequest::RESPONSETAINT_CORS:
       filteredResponse = aResponse->CORSResponse();
       break;
     case InternalRequest::RESPONSETAINT_OPAQUE:
       filteredResponse = aResponse->OpaqueResponse();
       break;
     case InternalRequest::RESPONSETAINT_OPAQUEREDIRECT:
+      printf_stderr("### ### FetchDriver create opaqueredirect Response\n");
       filteredResponse = aResponse->OpaqueRedirectResponse();
       break;
     default:
       MOZ_CRASH("Unexpected case");
   }
 
   MOZ_ASSERT(filteredResponse);
   MOZ_ASSERT(mObserver);
@@ -829,32 +830,35 @@ FetchDriver::OnStopRequest(nsIRequest* a
 NS_IMETHODIMP
 FetchDriver::AsyncOnChannelRedirect(nsIChannel* aOldChannel,
                                     nsIChannel* aNewChannel,
                                     uint32_t aFlags,
                                     nsIAsyncVerifyRedirectCallback *aCallback)
 {
   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
 
+  printf_stderr("### ### FetchDriver::AsyncOnChannelRedirect()\n");
+
   nsresult rv;
 
   if (NS_WARN_IF(mRequest->GetRedirectMode() == RequestRedirect::Error)) {
     aOldChannel->Cancel(NS_BINDING_FAILED);
     return NS_BINDING_FAILED;
   }
 
   // Section 4.2, Step 4.6-4.7, enforcing a redirect count is done by Necko.
   // The pref used is "network.http.redirection-limit" which is set to 20 by
   // default.
   //
   // Step 4.8. We only unset this for spec compatibility. Any actions we take
   // on mRequest here do not affect what the channel does.
   mRequest->UnsetSameOriginDataURL();
 
   if (mRequest->GetRedirectMode() == RequestRedirect::Manual) {
+    printf_stderr("### ### FetchDriver set response tainting to opaqueredirect\n");
     mRequest->SetResponseTainting(InternalRequest::RESPONSETAINT_OPAQUEREDIRECT);
     return NS_BINDING_FAILED;
   }
 
   MOZ_ASSERT(mRequest->GetRedirectMode() == RequestRedirect::Follow);
 
   //
   // Requests that require preflight are not permitted to redirect.
diff --git a/dom/fetch/Request.cpp b/dom/fetch/Request.cpp
--- a/dom/fetch/Request.cpp
+++ b/dom/fetch/Request.cpp
@@ -233,16 +233,17 @@ Request::Constructor(const GlobalObject&
   RequestCache cache = aInit.mCache.WasPassed() ?
                        aInit.mCache.Value() : fallbackCache;
   if (cache != RequestCache::EndGuard_) {
     request->ClearCreatedByFetchEvent();
     request->SetCacheMode(cache);
   }
 
   if (aInit.mRedirect.WasPassed()) {
+    printf_stderr("### ### setting redirect value via init\n");
     request->SetRedirectMode(aInit.mRedirect.Value());
   }
 
   // Request constructor step 14.
   if (aInit.mMethod.WasPassed()) {
     nsAutoCString method(aInit.mMethod.Value());
     nsAutoCString upperCaseMethod = method;
     ToUpperCase(upperCaseMethod);
diff --git a/testing/web-platform/mozilla/meta/MANIFEST.json b/testing/web-platform/mozilla/meta/MANIFEST.json
--- a/testing/web-platform/mozilla/meta/MANIFEST.json
+++ b/testing/web-platform/mozilla/meta/MANIFEST.json
@@ -137,16 +137,22 @@
           }
         ],
         "service-workers/service-worker/fetch-event-network-error.https.html": [
           {
             "path": "service-workers/service-worker/fetch-event-network-error.https.html",
             "url": "/_mozilla/service-workers/service-worker/fetch-event-network-error.https.html"
           }
         ],
+        "service-workers/service-worker/fetch-event-redirect.https.html": [
+          {
+            "path": "service-workers/service-worker/fetch-event-redirect.https.html",
+            "url": "/_mozilla/service-workers/service-worker/fetch-event-redirect.https.html"
+          }
+        ],
         "service-workers/service-worker/fetch-event-respond-with-stops-propagation.https.html": [
           {
             "path": "service-workers/service-worker/fetch-event-respond-with-stops-propagation.https.html",
             "url": "/_mozilla/service-workers/service-worker/fetch-event-respond-with-stops-propagation.https.html"
           }
         ],
         "service-workers/service-worker/fetch-event.https.html": [
           {
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-event-redirect.https.html b/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-event-redirect.https.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/fetch-event-redirect.https.html
@@ -0,0 +1,132 @@
+<!DOCTYPE html>
+<title>Service Worker: Fetch Event Redirect Handling</title>
+<script src="/resources/testharness.js"></script>
+<script src="resources/testharness-helpers.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/get-host-info.sub.js"></script>
+<script src="resources/test-helpers.sub.js"></script>
+<body>
+<script>
+
+// - Request navigation with manual redirect, SW fetches same-origin redirect
+// - Request navigation with manual redirect, SW fetches cross-origin redirect
+// - Request non-navigation with manual redirect, SW fetches same-origin redirect
+// - Request non-navigation with manual redirect, SW fetches cross-origin redirect
+// - Request non-navigation with follow redirect, SW fetches same-origin redirect
+// - Request non-navigation with follow redirect, SW fetches cross-origin redirect
+// - Request non-navigation with error redirect, SW fetches same-origin redirect
+// - Request non-navigation with error redirect, SW fetches cross-origin redirect
+
+// Test cases:
+//  Request(navigation-or-not, RequestRedirect, RequestMode), type of SW redirect
+
+// Request(Nav, manual, same-origin, no-creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception succeeds
+// Request(Nav, manual, same-origin, no-creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception succeeds
+// Request(Nav, manual, same-origin, creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception succeeds
+// Request(Nav, manual, same-origin, creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception succeeds
+// Request(Non-nav, manual, same-origin, no-creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, same-origin, no-creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, cors, no-creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, cors, no-creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, no-cors, no-creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, no-cors, no-creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, same-origin, creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, same-origin, creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, cors, creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, cors, creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, no-cors, creds), SW fetches same-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, manual, no-cors, creds), SW fetches cross-origin redirect
+//  - opaqueredirect, interception fails
+// Request(Non-nav, follow, same-origin, no-creds), SW fetches same-origin redirect
+//  - redirect succeeds, interception succeeds
+// Request(Non-nav, follow, same-origin, no-creds), SW fetches cross-origin redirect
+//  - redirect fails, error response, interception fails
+// Request(Non-nav, follow, cors, no-creds), SW fetches same-origin redirect
+//  - redirect succeeds, basic response, interception succeeds
+// Request(Non-nav, follow, cors, no-creds), SW fetches cross-origin redirect
+//  - ?
+// Request(Non-nav, follow, no-cors, no-creds), SW fetches same-origin redirect
+//  - redirect succeeds, interception succeeds
+// Request(Non-nav, follow, no-cors, no-creds), SW fetches cross-origin redirect
+//  - redirect succeeds, interception succeeds
+// Request(Non-nav, follow, same-origin, creds), SW fetches same-origin redirect
+// Request(Non-nav, follow, same-origin, creds), SW fetches cross-origin redirect
+// Request(Non-nav, follow, cors, creds), SW fetches same-origin redirect
+// Request(Non-nav, follow, cors, creds), SW fetches cross-origin redirect
+// Request(Non-nav, follow, no-cors, creds), SW fetches same-origin redirect
+// Request(Non-nav, follow, no-cors, creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, same-origin, no-creds), SW fetches same-origin redirect
+// Request(Non-nav, error, same-origin, no-creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, cors, no-creds), SW fetches same-origin redirect
+// Request(Non-nav, error, cors, no-creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, no-cors, no-creds), SW fetches same-origin redirect
+// Request(Non-nav, error, no-cors, no-creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, same-origin, creds), SW fetches same-origin redirect
+// Request(Non-nav, error, same-origin, creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, cors, creds), SW fetches same-origin redirect
+// Request(Non-nav, error, cors, creds), SW fetches cross-origin redirect
+// Request(Non-nav, error, no-cors, creds), SW fetches same-origin redirect
+// Request(Non-nav, error, no-cors, creds), SW fetches cross-origin redirect
+
+var host_info = get_host_info();
+var worker = 'resources/fetch-rewrite-worker.js';
+var frameURL = 'resources/fetch-event-redirect-iframe.html';
+var redirect = 'redirect.py';
+var empty = base_path() + 'resources/empty.js';
+
+function executeTest(frame, data) {
+  return new Promise(function(resolve, reject) {
+    var channel = new MessageChannel();
+    channel.port1.onmessage = function(e) {
+      if (e.data.results === 'finish') {
+        resolve();
+      } else {
+        reject(e.data.results);
+      }
+    };
+    frame.contentWindow.postMessage(data, host_info['HTTPS_ORIGIN'],
+                                    [channel.port2]);
+  });
+}
+
+async_test(function(t) {
+  var scope = frameURL;
+  service_worker_unregister_and_register(t, worker, scope).then(function(reg) {
+    return wait_for_state(t, reg.installing, 'activated');
+  }).then(function() {
+    return with_iframe(frameURL);
+  }).then(function(frame) {
+    return executeTest(frame, {
+      url: scope + '?url=' + encodeURIComponent(redirect + '?Redirect=' +
+                             encodeURIComponent(host_info['HTTPS_ORIGIN'] + empty)),
+      request_init: { redirect: 'manual' }
+    });
+  }).then(function() {
+    return service_worker_unregister_and_done(t, scope);
+  }).catch(unreached_rejection(t));
+}, 'Non-navigation request with manual redirect should fail opaqueredirect interception');
+
+    /*
+    var url = scope + '?url=' +
+              encodeURIComponent(host_info['HTTPS_ORIGIN'] + path);
+    var req = new Request(url);
+    return assert_promise_rejects(fetch(req));
+    */
+
+</script>
+</body>
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-event-redirect-iframe.html b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-event-redirect-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-event-redirect-iframe.html
@@ -0,0 +1,18 @@
+<script>
+window.addEventListener('message', function(evt) {
+  var port = evt.ports[0];
+  executeFetch(evt.data).then(function() {
+    port.postMessage({results: 'finish'});
+  }).catch(function(e) {
+    port.postMessage({results: 'failure:' + e});
+  });
+});
+
+function executeFetch(data) {
+  return new Promise(function(resolve, reject) {
+    dump('### ### iframe ' + JSON.stringify(data.request_init) + '\n');
+    var request = new Request(data.url, data.request_init);
+    fetch(request).then(resolve, reject);
+  });
+}
+</script>
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-rewrite-worker.js b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-rewrite-worker.js
--- a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-rewrite-worker.js
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/fetch-rewrite-worker.js
@@ -7,34 +7,31 @@ function get_query_params(url) {
   var params = search.substring(1).split('&');
   params.forEach(function(param) {
       var element = param.split('=');
       ret[decodeURIComponent(element[0])] = decodeURIComponent(element[1]);
     });
   return ret;
 }
 
-function get_request_init(params) {
+function get_request_init(base, params) {
   var init = {};
-  if (params['method']) {
-    init['method'] = params['method'];
-  }
-  if (params['mode']) {
-    init['mode'] = params['mode'];
-  }
-  if (params['credentials']) {
-    init['credentials'] = params['credentials'];
-  }
+  init['method'] = params['method'] || base['method'];
+  init['mode'] = params['mode'] || base['mode'];
+  init['credentials'] = params['credentials'] || base['credentials'];
+  init['redirect'] = params['redirect'] || base['redirect'];
   return init;
 }
 
 self.addEventListener('fetch', function(event) {
+    dump('### ### fetch event ' + event.request.redirect + ', ' + event.request.url + '\n');
     var params = get_query_params(event.request.url);
-    var init = get_request_init(params);
+    var init = get_request_init(event.request, params);
     var url = params['url'];
+    dump('### ### new url ' + url + '\n');
     if (params['ignore']) {
       return;
     }
     if (params['reject']) {
       event.respondWith(new Promise(function(resolve, reject) {
           reject();
         }));
       return;
@@ -57,11 +54,22 @@ self.addEventListener('fetch', function(
       event.respondWith(new Response(new Blob([array], {type: 'image/png'})));
       return;
     }
     event.respondWith(new Promise(function(resolve, reject) {
         var request = event.request;
         if (url) {
           request = new Request(url, init);
         }
-        fetch(request).then(resolve, reject);
+        fetch(request).then(function(response) {
+          dump('### ### request.redirect:' + request.redirect + ' response type ' + response.type + ' status ' + response.status + ' url ' + response.url + '\n');
+          var expectedType = params['expected-type'];
+          if (expectedType && response.type !== expectedType) {
+            reject('unexpected Response type');
+            return;
+          }
+          response.clone().text().then(function(text) {
+            dump('### ### response body: ' + text + '\n');
+            resolve(response);
+          });
+        }, reject)
       }));
   });
diff --git a/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/redirect.py b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/redirect.py
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/mozilla/tests/service-workers/service-worker/resources/redirect.py
@@ -0,0 +1,25 @@
+def main(request, response):
+    if 'Status' in request.GET:
+        status = int(request.GET["status"])
+    else:
+        status = 302
+
+    headers = []
+
+    url = request.GET['Redirect']
+    headers.append(("Location", url))
+
+    if "ACAOrigin" in request.GET:
+        for item in request.GET["ACAOrigin"].split(","):
+            headers.append(("Access-Control-Allow-Origin", item))
+
+    for suffix in ["Headers", "Methods", "Credentials"]:
+        query = "ACA%s" % suffix
+        header = "Access-Control-Allow-%s" % suffix
+        if query in request.GET:
+            headers.append((header, request.GET[query]))
+
+    if "ACEHeaders" in request.GET:
+        headers.append(("Access-Control-Expose-Headers", request.GET[query]))
+
+    return status, headers, ""
