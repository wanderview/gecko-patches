# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  be07066d1d44a81f33bad55e8132ca4e40edebb9
Bug 1204254 P7 Allow the body nsIInputStream to be passed in StartSynthesizeResponse(). r=asuth

diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -234,17 +234,18 @@ public:
     mInternalResponse->UnfilteredHeaders()->GetEntries(entries);
     for (uint32_t i = 0; i < entries.Length(); ++i) {
        mChannel->SynthesizeHeader(entries[i].mName, entries[i].mValue);
     }
 
     auto castLoadInfo = static_cast<LoadInfo*>(loadInfo.get());
     castLoadInfo->SynthesizeServiceWorkerTainting(mInternalResponse->GetTainting());
 
-    rv = mChannel->StartSynthesizedResponse(mResponseURLSpec);
+    rv = mChannel->StartSynthesizedResponse(nullptr, nullptr, nullptr,
+                                            mResponseURLSpec);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->Cancel(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
     // Only start copying after we have begun synthesizing the response.
     // Some of the necko invariants can fail if we trigger an OnDataAvailable
     // too early.
diff --git a/netwerk/base/nsINetworkInterceptController.idl b/netwerk/base/nsINetworkInterceptController.idl
--- a/netwerk/base/nsINetworkInterceptController.idl
+++ b/netwerk/base/nsINetworkInterceptController.idl
@@ -1,19 +1,22 @@
 /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 #include "nsIContentPolicy.idl"
 
+interface nsICancelable;
 interface nsIChannel;
 interface nsIConsoleReportCollector;
+interface nsIInputStream;
 interface nsIOutputStream;
+interface nsIRunnable;
 interface nsIURI;
 
 %{C++
 #include "nsIConsoleReportCollector.h"
 namespace mozilla {
 class TimeStamp;
 
 namespace dom {
@@ -52,21 +55,34 @@ interface nsIInterceptedChannel : nsISup
      * Attach a header name/value pair to the forthcoming synthesized response.
      * Overwrites any existing header value.
      */
     void synthesizeHeader(in ACString name, in ACString value);
 
     /**
      * Instruct a channel that has been intercepted that a response is
      * starting to be synthesized.  No further header modification is
-     * after this point. The caller may optionally pass a spec for a URL that
-     * this response originates from; an empty string will cause the original
-     * intercepted request's URL to be used instead.
+     * after this point.  There are a few parameters:
+     * - A body stream may be optionally passed.  If nullptr, then an
+     *   empty body is assumed.
+     * - A runnable callback may be optionally passed.  It will be invoked
+     *   when the body is complete.  For a nullptr body this may be
+     *   synchronously on the current thread.  Otherwise it will be invoked
+     *   asynchronously on the current thread.
+     * - A cancelable callback may be optionall passed.  This will be
+     *   invoked if there is an error while reading the body.  It will
+     *   be invoked on the current thread.
+     * - The caller may optionally pass a spec for a URL that this response
+     *   originates from; an empty string will cause the original
+     *   intercepted request's URL to be used instead.
      */
-    void startSynthesizedResponse(in ACString finalURLSpec);
+    void startSynthesizedResponse(in nsIInputStream body,
+                                  in nsIRunnable bodyConsumedCallback,
+                                  in nsICancelable bodyFailedCallback,
+                                  in ACString finalURLSpec);
 
     /**
      * Instruct a channel that has been intercepted that response synthesis
      * has completed and all outstanding resources can be closed.
      */
     void finishSynthesizedResponse();
 
     /**
diff --git a/netwerk/protocol/http/HttpChannelParentListener.cpp b/netwerk/protocol/http/HttpChannelParentListener.cpp
--- a/netwerk/protocol/http/HttpChannelParentListener.cpp
+++ b/netwerk/protocol/http/HttpChannelParentListener.cpp
@@ -307,17 +307,17 @@ public:
     , mChannel(aChannel)
   {
   }
 
   NS_IMETHOD Run() override
   {
     // The URL passed as an argument here doesn't matter, since the child will
     // receive a redirection notification as a result of this synthesized response.
-    mChannel->StartSynthesizedResponse(EmptyCString());
+    mChannel->StartSynthesizedResponse(nullptr, nullptr, nullptr, EmptyCString());
     mChannel->FinishSynthesizedResponse();
     return NS_OK;
   }
 };
 
 NS_IMETHODIMP
 HttpChannelParentListener::ChannelIntercepted(nsIInterceptedChannel* aChannel)
 {
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -288,17 +288,20 @@ InterceptedChannelChrome::SynthesizeHead
   if (!mSynthesizedCacheEntry) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
-InterceptedChannelChrome::StartSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedChannelChrome::StartSynthesizedResponse(nsIInputStream* aBody,
+                                                   nsIRunnable* aBodyCompletionCallback,
+                                                   nsICancelable* aBodyFailedCallback,
+                                                   const nsACString& aFinalURLSpec)
 {
   if (mClosed) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   EnsureSynthesizedResponse();
 
   // If the synthesized response is a redirect, then we want to respect
@@ -497,17 +500,20 @@ InterceptedChannelContent::SynthesizeHea
   if (!mResponseBody) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   return DoSynthesizeHeader(aName, aValue);
 }
 
 NS_IMETHODIMP
-InterceptedChannelContent::StartSynthesizedResponse(const nsACString& aFinalURLSpec)
+InterceptedChannelContent::StartSynthesizedResponse(nsIInputStream* aBody,
+                                                    nsIRunnable* aBodyCompletionCallback,
+                                                    nsICancelable* aBodyFailedCallback,
+                                                    const nsACString& aFinalURLSpec)
 {
   if (NS_WARN_IF(mClosed)) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
   EnsureSynthesizedResponse();
 
   nsCOMPtr<nsIURI> originalURI;
diff --git a/netwerk/protocol/http/InterceptedChannel.h b/netwerk/protocol/http/InterceptedChannel.h
--- a/netwerk/protocol/http/InterceptedChannel.h
+++ b/netwerk/protocol/http/InterceptedChannel.h
@@ -164,17 +164,20 @@ class InterceptedChannelChrome : public 
   // ResetInterception is called.
   bool mOldApplyConversion;
 public:
   InterceptedChannelChrome(nsHttpChannel* aChannel,
                            nsINetworkInterceptController* aController,
                            nsICacheEntry* aEntry);
 
   NS_IMETHOD ResetInterception() override;
-  NS_IMETHOD StartSynthesizedResponse(const nsACString& aFinalURLSpec) override;
+  NS_IMETHOD StartSynthesizedResponse(nsIInputStream* aBody,
+                                      nsIRunnable* aBodyCompletionCallback,
+                                      nsICancelable* aBodyFailedCallback,
+                                      const nsACString& aFinalURLSpec) override;
   NS_IMETHOD FinishSynthesizedResponse() override;
   NS_IMETHOD GetChannel(nsIChannel** aChannel) override;
   NS_IMETHOD GetSecureUpgradedChannelURI(nsIURI** aURI) override;
   NS_IMETHOD SynthesizeStatus(uint16_t aStatus, const nsACString& aReason) override;
   NS_IMETHOD SynthesizeHeader(const nsACString& aName, const nsACString& aValue) override;
   NS_IMETHOD Cancel(nsresult aStatus) override;
   NS_IMETHOD SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo) override;
   NS_IMETHOD GetInternalContentPolicyType(nsContentPolicyType *aInternalContentPolicyType) override;
@@ -198,17 +201,20 @@ class InterceptedChannelContent : public
   bool mSecureUpgrade;
 public:
   InterceptedChannelContent(HttpChannelChild* aChannel,
                             nsINetworkInterceptController* aController,
                             InterceptStreamListener* aListener,
                             bool aSecureUpgrade);
 
   NS_IMETHOD ResetInterception() override;
-  NS_IMETHOD StartSynthesizedResponse(const nsACString& aFinalURLSpec) override;
+  NS_IMETHOD StartSynthesizedResponse(nsIInputStream* aBody,
+                                      nsIRunnable* aBodyCompletionCallback,
+                                      nsICancelable* aBodyFailedCallback,
+                                      const nsACString& aFinalURLSpec) override;
   NS_IMETHOD FinishSynthesizedResponse() override;
   NS_IMETHOD GetChannel(nsIChannel** aChannel) override;
   NS_IMETHOD GetSecureUpgradedChannelURI(nsIURI** aURI) override;
   NS_IMETHOD SynthesizeStatus(uint16_t aStatus, const nsACString& aReason) override;
   NS_IMETHOD SynthesizeHeader(const nsACString& aName, const nsACString& aValue) override;
   NS_IMETHOD Cancel(nsresult aStatus) override;
   NS_IMETHOD SetChannelInfo(mozilla::dom::ChannelInfo* aChannelInfo) override;
   NS_IMETHOD GetInternalContentPolicyType(nsContentPolicyType *aInternalContentPolicyType) override;
