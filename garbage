# HG changeset patch
# Parent b4de774cff7a38c0075a5af58e16e1b6097f723d
# User Ben Kelly <ben@wanderview.com>
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Context.h"
 
 #include "mozilla/DebugOnly.h"
 #include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/quota/OriginOrPatternString.h"
 #include "mozilla/dom/quota/QuotaManager.h"
 #include "nsIFile.h"
 #include "nsIPrincipal.h"
 #include "nsIRunnable.h"
 #include "nsThreadUtils.h"
@@ -132,16 +133,18 @@ private:
   }
 
   enum State
   {
     STATE_INIT,
     STATE_CALL_WAIT_FOR_OPEN_ALLOWED,
     STATE_WAIT_FOR_OPEN_ALLOWED,
     STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_CREATE_DB_URI,
+    STATE_RUN_ON_TARGET,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Clear()
   {
     NS_ASSERT_OWNINGTHREAD(Action::Resolver);
@@ -269,33 +272,79 @@ Context::QuotaInitRunnable::Run()
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   mQuotaInfo.mHasUnlimStoragePerm,
                                                   getter_AddRefs(mQuotaInfo.mDir));
-      if (NS_FAILED(rv)) {
+      if (NS_WARN_IF(NS_FAILED(rv))) {
         Resolve(rv);
         return NS_OK;
       }
 
+      mState = STATE_CREATE_DB_URI;
+
+      rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+
+      break;
+    }
+    // ----------------------
+    case STATE_CREATE_DB_URI:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+
+      // It would be nice not to have this special-cased here and instead do it
+      // as part of an action.  Unfortunately, though, the DB URI must be
+      // created on the main thread after we have gotten the quota dir on the
+      // IO thread.  This is a unique circumstance.
+
+      // Update our saved QuotaInfo with the calculated URI.
+      nsresult rv = FileUtils::CreateDbFileUrl(mQuotaInfo);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+
+      mState = STATE_RUN_ON_TARGET;
+
+      rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        Resolve(rv);
+        return NS_OK;
+      }
+      break;
+    }
+    // ----------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      // Can't assert quota IO thread because its an idle thread that can get
+      // recreated.  At least assert we're not on main thread or owning thread.
+      MOZ_ASSERT(!NS_IsMainThread());
+      MOZ_ASSERT(_mOwningThread.GetThread() != PR_GetCurrentThread());
+
       mState = STATE_RUNNING;
 
       if (!mQuotaIOThreadAction) {
         Resolve(NS_OK);
         return NS_OK;
       }
 
       // Execute the provided initialization Action.  We pass ourselves as the
       // Resolver.  The Action must either call Resolve() immediately or hold
       // a ref to us and call Resolve() later.
       mQuotaIOThreadAction->RunOnTarget(this, mQuotaInfo);
-
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
       NS_ASSERT_OWNINGTHREAD(Action::Resolver);
       if (mQuotaIOThreadAction) {
         mQuotaIOThreadAction->CompleteOnInitiatingThread(mResult);
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -28,100 +28,58 @@ DBAction::DBAction(Mode aMode)
 
 DBAction::~DBAction()
 {
 }
 
 void
 DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo)
 {
+  MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aResolver);
-  MOZ_ASSERT(aQuotaInfo.mDir);
 
   nsCOMPtr<nsIFile> dbDir;
-  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aResolver->Resolve(rv);
-    return;
-  }
-
-  rv = dbDir->Append(NS_LITERAL_STRING("cache"));
+  nsresult rv = aQuotaInfo.mDbDir->Clone(getter_AddRefs(dbDir));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
 
   nsCOMPtr<mozIStorageConnection> conn;
-  rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
+  rv = OpenConnection(aQuotaInfo, getter_AddRefs(conn));
   if (NS_WARN_IF(NS_FAILED(rv))) {
     aResolver->Resolve(rv);
     return;
   }
   MOZ_ASSERT(conn);
 
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
-DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+DBAction::OpenConnection(const QuotaInfo& aQuotaInfo,
                          mozIStorageConnection** aConnOut)
 {
-  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConnOut);
 
-  bool exists;
-  nsresult rv = aDBDir->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (!exists) {
-    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
-    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  }
-
-  nsCOMPtr<nsIFile> dbFile;
-  rv = aDBDir->Clone(getter_AddRefs(dbFile));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = dbFile->Append(NS_LITERAL_STRING("db.sqlite"));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = dbFile->Exists(&exists);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // XXX: Jonas tells me nsIFileURL usage off-main-thread is dangerous,
-  //      but this is what IDB does to access mozIStorageConnection so
-  //      it seems at least this corner case mostly works.
-  // TODO: move this to main thread where GetInfoFromPrincipal() is executed (bug 1110485)
-  nsCOMPtr<nsIURI> uri;
-  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
-  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
-
-  nsAutoCString type;
-  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
-
-  rv = dbFileUrl->SetQuery(
-    NS_LITERAL_CSTRING("persistenceType=") + type +
-    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
-    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
   nsCOMPtr<mozIStorageService> ss =
     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
   if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
 
-  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+  nsresult rv = ss->OpenDatabaseWithFileURL(aQuotaInfo.mDbFileUrl, aConnOut);
   if (rv == NS_ERROR_FILE_CORRUPTED) {
-    dbFile->Remove(false);
+    nsCOMPtr<nsIFile> dbFile;
+    rv = aQuotaInfo.mDbFileUrl->GetFile(getter_AddRefs(dbFile));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, aConnOut);
+    rv = dbFile->Remove(false);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(aQuotaInfo.mDbFileUrl, aConnOut);
   }
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   MOZ_ASSERT(*aConnOut);
   return rv;
 }
 
 SyncDBAction::SyncDBAction(Mode aMode)
   : DBAction(aMode)
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -23,40 +23,44 @@ class DBAction : public Action
 {
 protected:
   enum Mode
   {
     Existing,
     Create
   };
 
-  DBAction(Mode aMode);
+  explicit DBAction(Mode aMode);
+
+  // virtual because Actions are deleted through their base pointer.
   virtual ~DBAction();
 
   // Just as the resolver must be ref'd until cancel or resolve, you may also
   // ref the DB connection.  The connection can only be referenced from the
   // target thread and must be released upon cancel or resolve.
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) = 0;
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo) MOZ_OVERRIDE;
 
 private:
-  nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
+  nsresult OpenConnection(const QuotaInfo& aQuotaInfo,
                           mozIStorageConnection** aConnOut);
 
   const Mode mMode;
 };
 
 class SyncDBAction : public DBAction
 {
 protected:
-  SyncDBAction(Mode aMode);
+  explicit SyncDBAction(Mode aMode);
+
+  // virtual because Actions are deleted through their base pointer.
   virtual ~SyncDBAction();
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) = 0;
 
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -22,16 +22,64 @@ namespace cache {
 
 using mozilla::dom::quota::FileInputStream;
 using mozilla::dom::quota::FileOutputStream;
 using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
 using mozilla::unused;
 
 // static
 nsresult
+FileUtils::CreateDbFileUrl(QuotaInfo& aQuotaInfo)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIFile> dbDir;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool exists;
+  rv = dbDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    rv = dbDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = dbDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("caches.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIURI> uri;
+  rv = NS_NewFileURI(getter_AddRefs(uri), dbFile);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
+
+  rv = dbFileUrl->SetQuery(
+    NS_LITERAL_CSTRING("persistenceType=") + type +
+    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
+    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  aQuotaInfo.mDbDir = dbDir.forget();
+  aQuotaInfo.mDbFileUrl = dbFileUrl.forget();
+
+  return NS_OK;
+}
+
+// static
+nsresult
 FileUtils::BodyCreateDir(nsIFile* aBaseDir)
 {
   MOZ_ASSERT(aBaseDir);
 
   nsCOMPtr<nsIFile> aBodyDir;
   nsresult rv = aBaseDir->Clone(getter_AddRefs(aBodyDir));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -9,30 +9,33 @@
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/cache/Types.h"
 #include "nsStreamUtils.h"
 #include "nsTArrayForwardDeclare.h"
 
 struct nsID;
 class nsIFile;
+class nsIFileURL;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class FileUtils MOZ_FINAL
 {
 public:
   enum BodyFileType
   {
     BODY_FILE_FINAL,
     BODY_FILE_TMP
   };
 
+  static nsresult CreateDbFileUrl(QuotaInfo& aQuotaInfo);
+
   static nsresult BodyCreateDir(nsIFile* aBaseDir);
   static nsresult BodyGetCacheDir(nsIFile* aBaseDir, const nsID& aId,
                                   nsIFile** aCacheDirOut);
 
   static nsresult
   BodyIdToFile(nsIFile* aBaseDir, const nsID& aId, BodyFileType aType,
                nsIFile** aBodyFileOut);
 
diff --git a/dom/cache/QuotaClient.cpp b/dom/cache/QuotaClient.cpp
--- a/dom/cache/QuotaClient.cpp
+++ b/dom/cache/QuotaClient.cpp
@@ -133,24 +133,24 @@ QuotaClient::GetUsageForOrigin(Persisten
       } else {
         NS_WARNING("Unknown Cache directory found!");
       }
 
       continue;
     }
 
     // Ignore transient sqlite files
-    if (leafName.EqualsLiteral("db.sqlite-journal") ||
-        leafName.EqualsLiteral("db.sqlite-shm") ||
-        leafName.Find(NS_LITERAL_CSTRING("db.sqlite-mj"), false, 0, 0) == 0) {
+    if (leafName.EqualsLiteral("caches.sqlite-journal") ||
+        leafName.EqualsLiteral("caches.sqlite-shm") ||
+        leafName.Find(NS_LITERAL_CSTRING("caches.sqlite-mj"), false, 0, 0) == 0) {
       continue;
     }
 
-    if (leafName.EqualsLiteral("db.sqlite") ||
-        leafName.EqualsLiteral("db.sqlite-wal")) {
+    if (leafName.EqualsLiteral("caches.sqlite") ||
+        leafName.EqualsLiteral("caches.sqlite-wal")) {
       int64_t fileSize;
       rv = file->GetFileSize(&fileSize);
       if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
       MOZ_ASSERT(fileSize >= 0);
 
       aUsageInfo->AppendToDatabaseUsage(fileSize);
       continue;
     }
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -5,16 +5,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Types_h
 #define mozilla_dom_cache_Types_h
 
 #include <stdint.h>
 #include "nsCOMPtr.h"
 #include "nsIFile.h"
+#include "nsIFileURL.h"
 #include "nsString.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 enum Namespace
 {
@@ -27,16 +28,18 @@ typedef uintptr_t RequestId;
 static const RequestId INVALID_REQUEST_ID = 0;
 
 typedef int32_t CacheId;
 
 struct QuotaInfo
 {
   QuotaInfo() : mIsApp(false), mHasUnlimStoragePerm(false) { }
   nsCOMPtr<nsIFile> mDir;
+  nsCOMPtr<nsIFile> mDbDir;
+  nsCOMPtr<nsIFileURL> mDbFileUrl;
   nsCString mGroup;
   nsCString mOrigin;
   bool mIsApp;
   bool mHasUnlimStoragePerm;
 };
 
 } // namespace cache
 } // namespace dom
