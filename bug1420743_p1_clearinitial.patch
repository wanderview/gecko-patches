# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  8f9e4bd47281d8411831c993276482a9a3864f61
Bug 1420743 P1 Do a better job of clearing docshell's mInitialClientSource at the end of page load. r=baku

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -7792,16 +7792,21 @@ nsDocShell::OnSecurityChange(nsIWebProgr
   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   return NS_OK;
 }
 
 nsresult
 nsDocShell::EndPageLoad(nsIWebProgress* aProgress,
                         nsIChannel* aChannel, nsresult aStatus)
 {
+  // Make sure to discard the initial client if we never created the initial
+  // about:blank document.  Do this before possibly returning from the method
+  // due to an error.
+  mInitialClientSource.reset();
+
   if (!aChannel) {
     return NS_ERROR_NULL_POINTER;
   }
 
   nsCOMPtr<nsIConsoleReportCollector> reporter = do_QueryInterface(aChannel);
   if (reporter) {
     nsCOMPtr<nsILoadGroup> loadGroup;
     aChannel->GetLoadGroup(getter_AddRefs(loadGroup));
@@ -7831,20 +7836,16 @@ nsDocShell::EndPageLoad(nsIWebProgress* 
         internalLoadGroup->OnEndPageLoad(aChannel);
       }
     }
   }
 
   // Timing is picked up by the window, we don't need it anymore
   mTiming = nullptr;
 
-  // Make sure to discard the initial client if we never created the initial
-  // about:blank document.
-  mInitialClientSource.reset();
-
   // clean up reload state for meta charset
   if (eCharsetReloadRequested == mCharsetReloadState) {
     mCharsetReloadState = eCharsetReloadStopOrigional;
   } else {
     mCharsetReloadState = eCharsetReloadInit;
   }
 
   // Save a pointer to the currently-loading history entry.
diff --git a/dom/base/nsGlobalWindowInner.cpp b/dom/base/nsGlobalWindowInner.cpp
--- a/dom/base/nsGlobalWindowInner.cpp
+++ b/dom/base/nsGlobalWindowInner.cpp
@@ -1742,16 +1742,24 @@ nsGlobalWindowInner::EnsureClientSource(
 {
   MOZ_DIAGNOSTIC_ASSERT(mDoc);
 
   bool newClientSource = false;
 
   nsCOMPtr<nsIChannel> channel = mDoc->GetChannel();
   nsCOMPtr<nsILoadInfo> loadInfo = channel ? channel->GetLoadInfo() : nullptr;
 
+  // Take the initial client source from the docshell immediately.  Even if we
+  // don't end up using it here we should consume it.
+  UniquePtr<ClientSource> initialClientSource;
+  nsIDocShell* docshell = GetDocShell();
+  if (docshell) {
+    initialClientSource = docshell->TakeInitialClientSource();
+  }
+
   // Try to get the reserved client from the LoadInfo.  A Client is
   // reserved at the start of the channel load if there is not an
   // initial about:blank document that will be reused.  It is also
   // created if the channel load encounters a cross-origin redirect.
   if (loadInfo) {
     UniquePtr<ClientSource> reservedClient = loadInfo->TakeReservedClientSource();
     if (reservedClient) {
       mClientSource.reset();
@@ -1762,22 +1770,19 @@ nsGlobalWindowInner::EnsureClientSource(
 
   // We don't have a LoadInfo reserved client, but maybe we should
   // be inheriting an initial one from the docshell.  This means
   // that the docshell started the channel load before creating the
   // initial about:blank document.  This is an optimization, though,
   // and it created an initial Client as a placeholder for the document.
   // In this case we want to inherit this placeholder Client here.
   if (!mClientSource) {
-    nsIDocShell* docshell = GetDocShell();
-    if (docshell) {
-      mClientSource = docshell->TakeInitialClientSource();
-      if (mClientSource) {
-        newClientSource = true;
-      }
+    mClientSource = Move(initialClientSource);
+    if (mClientSource) {
+      newClientSource = true;
     }
   }
 
   // If we don't have a reserved client or an initial client, then create
   // one now.  This can happen in certain cases where we avoid preallocating
   // the client in the docshell.  This mainly occurs in situations where
   // the principal is not clearly inherited from the parent; e.g. sandboxed
   // iframes, window.open(), etc.
