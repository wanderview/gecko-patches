# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  4d0818b3e8ce9643d2561eb2d78326f38e0f925d
Bug 1430139 P3 Remove workers namespace from service worker code. r=asuth

diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -54,17 +54,16 @@
 #include "mozilla/dom/IPCBlobUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/dom/TouchEvent.h"
 #include "mozilla/dom/ShadowRoot.h"
 #include "mozilla/dom/XULCommandEvent.h"
 #include "mozilla/dom/WorkerPrivate.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/EventDispatcher.h"
 #include "mozilla/EventListenerManager.h"
 #include "mozilla/EventStateManager.h"
 #include "mozilla/gfx/DataSurfaceHelpers.h"
 #include "mozilla/HTMLEditor.h"
 #include "mozilla/IMEStateManager.h"
 #include "mozilla/InternalMutationEvent.h"
 #include "mozilla/Likely.h"
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -78,17 +78,17 @@
 #include "nsIDOMComment.h"
 #include "mozilla/dom/DocumentType.h"
 #include "mozilla/dom/NodeIterator.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/TreeWalker.h"
 
 #include "nsIServiceManager.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "imgLoader.h"
 
 #include "nsCanvasFrame.h"
 #include "nsContentCID.h"
 #include "nsError.h"
 #include "nsPresContext.h"
 #include "nsThreadUtils.h"
 #include "nsNodeInfoManager.h"
@@ -5508,17 +5508,17 @@ nsDocument::DispatchContentLoadedEvents(
   Element* root = GetRootElement();
   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::manifest)) {
     nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
                                         NS_LITERAL_STRING("MozApplicationManifest"),
                                         true, true);
   }
 
   if (mMaybeServiceWorkerControlled) {
-    using mozilla::dom::workers::ServiceWorkerManager;
+    using mozilla::dom::ServiceWorkerManager;
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (swm) {
       Maybe<ClientInfo> clientInfo = GetClientInfo();
       if (clientInfo.isSome()) {
         swm->MaybeCheckNavigationUpdate(clientInfo.ref());
       }
     }
   }
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -319,28 +319,28 @@ DOMInterfaces = {
     'binaryNames': {
         'message': 'messageMoz',
     },
     'implicitJSContext': [ '__stringifier', 'filename', 'lineNumber', 'stack' ],
 },
 
 'ExtendableEvent': {
     'headerFile': 'mozilla/dom/ServiceWorkerEvents.h',
-    'nativeType': 'mozilla::dom::workers::ExtendableEvent',
+    'nativeType': 'mozilla::dom::ExtendableEvent',
     'implicitJSContext': [ 'waitUntil' ],
 },
 
 'ExtendableMessageEvent': {
     'headerFile': 'mozilla/dom/ServiceWorkerEvents.h',
-    'nativeType': 'mozilla::dom::workers::ExtendableMessageEvent',
+    'nativeType': 'mozilla::dom::ExtendableMessageEvent',
 },
 
 'FetchEvent': {
     'headerFile': 'ServiceWorkerEvents.h',
-    'nativeType': 'mozilla::dom::workers::FetchEvent',
+    'nativeType': 'mozilla::dom::FetchEvent',
     'binaryNames': {
         'request': 'request_'
     },
     'implicitJSContext': [ 'respondWith' ],
 },
 
 'FileReader': {
     'implicitJSContext': [ 'readAsArrayBuffer' ],
@@ -717,22 +717,22 @@ DOMInterfaces = {
 },
 
 'PromiseNativeHandler': {
     'wrapperCache': False,
 },
 
 'PushEvent': {
     'headerFile': 'ServiceWorkerEvents.h',
-    'nativeType': 'mozilla::dom::workers::PushEvent',
+    'nativeType': 'mozilla::dom::PushEvent',
 },
 
 'PushMessageData': {
     'headerFile': 'ServiceWorkerEvents.h',
-    'nativeType': 'mozilla::dom::workers::PushMessageData',
+    'nativeType': 'mozilla::dom::PushMessageData',
 },
 
 'Range': {
     'nativeType': 'nsRange',
     'binaryNames': {
         '__stringifier': 'ToString'
     }
 },
@@ -759,18 +759,18 @@ DOMInterfaces = {
     'nativeType': 'nsDOMCSSRGBColor',
 },
 
 'Screen': {
     'nativeType': 'nsScreen',
 },
 
 'ServiceWorker': {
-    'nativeType': 'mozilla::dom::workers::ServiceWorker',
-    'headerFile': 'mozilla/dom/workers/bindings/ServiceWorker.h',
+    'nativeType': 'mozilla::dom::ServiceWorker',
+    'headerFile': 'mozilla/dom/ServiceWorker.h',
 },
 
 'ServiceWorkerGlobalScope': {
     'headerFile': 'mozilla/dom/WorkerScope.h',
 },
 
 'ServiceWorkerRegistration': {
     'implicitJSContext': [ 'pushManager' ],
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -7,28 +7,27 @@
 #include "Clients.h"
 
 #include "ClientDOMUtil.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientManager.h"
 #include "mozilla/dom/ClientsBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "mozilla/dom/WorkerPrivate.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "mozilla/SystemGroup.h"
 #include "nsIGlobalObject.h"
 #include "nsString.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
 using mozilla::dom::workers::WorkerPrivate;
-using mozilla::dom::workers::ServiceWorkerManager;
 using mozilla::ipc::PrincipalInfo;
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(Clients);
 NS_IMPL_CYCLE_COLLECTING_RELEASE(Clients);
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(Clients, mGlobal);
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(Clients)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -13,30 +13,27 @@
 #include "ClientValidation.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/Navigator.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/WorkerScope.h"
+#include "mozilla/dom/ServiceWorker.h"
 #include "mozilla/dom/ServiceWorkerContainer.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
-#include "mozilla/dom/workers/bindings/ServiceWorker.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "nsContentUtils.h"
 #include "nsIDocShell.h"
 #include "nsPIDOMWindow.h"
 
 namespace mozilla {
 namespace dom {
 
 using mozilla::dom::ipc::StructuredCloneData;
-using mozilla::dom::workers::ServiceWorkerInfo;
-using mozilla::dom::workers::ServiceWorkerManager;
-using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
 using mozilla::dom::workers::WorkerPrivate;
 using mozilla::ipc::PrincipalInfo;
 using mozilla::ipc::PrincipalInfoToPrincipal;
 
 void
 ClientSource::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(ClientSource);
diff --git a/dom/events/Event.h b/dom/events/Event.h
--- a/dom/events/Event.h
+++ b/dom/events/Event.h
@@ -26,25 +26,23 @@ class nsIContent;
 class nsIDOMEventTarget;
 class nsPresContext;
 
 namespace mozilla {
 namespace dom {
 
 class EventTarget;
 class EventMessageAutoOverride;
+// ExtendableEvent is a ServiceWorker event that is not
+// autogenerated since it has some extra methods.
+class ExtendableEvent;
 class WantsPopupControlCheck;
 #define GENERATED_EVENT(EventClass_) class EventClass_;
 #include "mozilla/dom/GeneratedEventList.h"
 #undef GENERATED_EVENT
-// ExtendableEvent is a ServiceWorker event that is not
-// autogenerated since it has some extra methods.
-namespace workers {
-class ExtendableEvent;
-} // namespace workers
 
 // Dummy class so we can cast through it to get from nsISupports to
 // Event subclasses with only two non-ambiguous static casts.
 class EventBase : public nsIDOMEvent
 {
 };
 
 class Event : public EventBase,
@@ -101,17 +99,17 @@ public:
   {                                       \
     return nullptr;                       \
   }
 #include "mozilla/dom/GeneratedEventList.h"
 #undef GENERATED_EVENT
 
   // ExtendableEvent is a ServiceWorker event that is not
   // autogenerated since it has some extra methods.
-  virtual workers::ExtendableEvent* AsExtendableEvent()
+  virtual ExtendableEvent* AsExtendableEvent()
   {
     return nullptr;
   }
 
   // nsIDOMEvent Interface
   NS_DECL_NSIDOMEVENT
 
   void InitPresContextData(nsPresContext* aPresContext);
diff --git a/dom/events/MessageEvent.cpp b/dom/events/MessageEvent.cpp
--- a/dom/events/MessageEvent.cpp
+++ b/dom/events/MessageEvent.cpp
@@ -3,17 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/MessageEvent.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/MessagePort.h"
 #include "mozilla/dom/MessagePortBinding.h"
-#include "mozilla/dom/workers/bindings/ServiceWorker.h"
+#include "mozilla/dom/ServiceWorker.h"
 
 #include "mozilla/HoldDropJSObjects.h"
 #include "jsapi.h"
 #include "nsGlobalWindow.h" // So we can assign an nsGlobalWindow* to mWindowSource
 
 namespace mozilla {
 namespace dom {
 
diff --git a/dom/events/MessageEvent.h b/dom/events/MessageEvent.h
--- a/dom/events/MessageEvent.h
+++ b/dom/events/MessageEvent.h
@@ -12,22 +12,19 @@
 #include "nsCycleCollectionParticipant.h"
 
 namespace mozilla {
 namespace dom {
 
 struct MessageEventInit;
 class MessagePort;
 class OwningWindowProxyOrMessagePortOrServiceWorker;
+class ServiceWorker;
 class WindowProxyOrMessagePortOrServiceWorker;
 
-namespace workers {
-class ServiceWorker;
-}
-
 /**
  * Implements the MessageEvent event, used for cross-document messaging and
  * server-sent events.
  *
  * See http://www.whatwg.org/specs/web-apps/current-work/#messageevent for
  * further details.
  */
 class MessageEvent final : public Event
@@ -74,17 +71,17 @@ protected:
   ~MessageEvent();
 
 private:
   JS::Heap<JS::Value> mData;
   nsString mOrigin;
   nsString mLastEventId;
   RefPtr<nsPIDOMWindowOuter> mWindowSource;
   RefPtr<MessagePort> mPortSource;
-  RefPtr<workers::ServiceWorker> mServiceWorkerSource;
+  RefPtr<ServiceWorker> mServiceWorkerSource;
 
   nsTArray<RefPtr<MessagePort>> mPorts;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_MessageEvent_h_
diff --git a/dom/notification/Notification.cpp b/dom/notification/Notification.cpp
--- a/dom/notification/Notification.cpp
+++ b/dom/notification/Notification.cpp
@@ -20,16 +20,17 @@
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/NotificationEvent.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
 #include "mozilla/dom/ServiceWorkerGlobalScopeBinding.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 
 #include "nsAlertsUtils.h"
 #include "nsComponentManagerUtils.h"
 #include "nsContentPermissionHelper.h"
 #include "nsContentUtils.h"
 #include "nsCRTGlue.h"
 #include "nsDOMJSUtils.h"
 #include "nsGlobalWindow.h"
@@ -48,17 +49,16 @@
 #include "nsIXPConnect.h"
 #include "nsNetUtil.h"
 #include "nsProxyRelease.h"
 #include "nsServiceManagerUtils.h"
 #include "nsStructuredCloneContainer.h"
 #include "nsThreadUtils.h"
 #include "nsToolkitCompsCID.h"
 #include "nsXULAppAPI.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 
 namespace mozilla {
 namespace dom {
 
 using namespace workers;
diff --git a/dom/push/PushNotifier.cpp b/dom/push/PushNotifier.cpp
--- a/dom/push/PushNotifier.cpp
+++ b/dom/push/PushNotifier.cpp
@@ -7,30 +7,29 @@
 #include "PushNotifier.h"
 
 #include "nsContentUtils.h"
 #include "nsCOMPtr.h"
 #include "nsICategoryManager.h"
 #include "nsIXULRuntime.h"
 #include "nsNetUtil.h"
 #include "nsXPCOM.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 
 #include "mozilla/Services.h"
 #include "mozilla/Unused.h"
 
 #include "mozilla/dom/BodyUtil.h"
 #include "mozilla/dom/ContentChild.h"
 #include "mozilla/dom/ContentParent.h"
 
 namespace mozilla {
 namespace dom {
 
 using workers::AssertIsOnMainThread;
-using workers::ServiceWorkerManager;
 
 PushNotifier::PushNotifier()
 {}
 
 PushNotifier::~PushNotifier()
 {}
 
 NS_IMPL_CYCLE_COLLECTION_0(PushNotifier)
diff --git a/dom/serviceworkers/ServiceWorker.cpp b/dom/serviceworkers/ServiceWorker.cpp
--- a/dom/serviceworkers/ServiceWorker.cpp
+++ b/dom/serviceworkers/ServiceWorker.cpp
@@ -22,56 +22,55 @@
 #undef PostMessage
 #endif
 
 using mozilla::ErrorResult;
 using namespace mozilla::dom;
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 bool
 ServiceWorkerVisible(JSContext* aCx, JSObject* aObj)
 {
   if (NS_IsMainThread()) {
     return DOMPrefs::ServiceWorkersEnabled();
   }
 
   return IS_INSTANCE_OF(ServiceWorkerGlobalScope, aObj);
 }
 
 ServiceWorker::ServiceWorker(nsPIDOMWindowInner* aWindow,
                              ServiceWorkerInfo* aInfo)
   : DOMEventTargetHelper(aWindow),
     mInfo(aInfo)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aInfo);
 
   // This will update our state too.
   mInfo->AppendWorker(this);
 }
 
 ServiceWorker::~ServiceWorker()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mInfo->RemoveWorker(this);
 }
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorker, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorker, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorker)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 JSObject*
 ServiceWorker::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   return ServiceWorkerBinding::Wrap(aCx, this, aGivenProto);
 }
 
 void
 ServiceWorker::GetScriptURL(nsString& aURL) const
 {
   CopyUTF8toUTF16(mInfo->ScriptSpec(), aURL);
@@ -111,11 +110,10 @@ ServiceWorker::PostMessage(JSContext* aC
   }
 
   ServiceWorkerPrivate* workerPrivate = mInfo->WorkerPrivate();
   aRv = workerPrivate->SendMessageEvent(aCx, aMessage, aTransferable,
                                         ClientInfoAndState(clientInfo.ref().ToIPC(),
                                                            clientState.ref().ToIPC()));
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorker.h b/dom/serviceworkers/ServiceWorker.h
--- a/dom/serviceworkers/ServiceWorker.h
+++ b/dom/serviceworkers/ServiceWorker.h
@@ -1,28 +1,26 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworker_h__
-#define mozilla_dom_workers_serviceworker_h__
+#ifndef mozilla_dom_serviceworker_h__
+#define mozilla_dom_serviceworker_h__
 
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState.
 
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
-namespace workers {
-
 class ServiceWorkerInfo;
 class ServiceWorkerManager;
 class SharedWorker;
 
 bool
 ServiceWorkerVisible(JSContext* aCx, JSObject* aObj);
 
 class ServiceWorker final : public DOMEventTargetHelper
@@ -72,13 +70,12 @@ private:
 
   // This class is reference-counted and will be destroyed from Release().
   ~ServiceWorker();
 
   ServiceWorkerState mState;
   const RefPtr<ServiceWorkerInfo> mInfo;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworker_h__
+#endif // mozilla_dom_serviceworker_h__
diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -23,20 +23,16 @@
 #include "mozilla/dom/ServiceWorkerContainerBinding.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
 #include "ServiceWorker.h"
 
 namespace mozilla {
 namespace dom {
 
-using mozilla::dom::workers::ServiceWorkerInfo;
-using mozilla::dom::workers::ServiceWorkerManager;
-using mozilla::dom::workers::ServiceWorkerRegistrationInfo;
-
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ServiceWorkerContainer)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerContainer, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerContainer, DOMEventTargetHelper)
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerContainer, DOMEventTargetHelper,
                                    mControllerWorker, mReadyPromise)
@@ -212,17 +208,17 @@ ServiceWorkerContainer::Register(const n
     return nullptr;
   }
 
   RefPtr<Promise> ret = static_cast<Promise*>(promise.get());
   MOZ_ASSERT(ret);
   return ret.forget();
 }
 
-already_AddRefed<workers::ServiceWorker>
+already_AddRefed<ServiceWorker>
 ServiceWorkerContainer::GetController()
 {
   if (!mControllerWorker) {
     // If we don't have a controller reference cached, then we need to
     // check if we should create one.  We try to do this in a thread-agnostic
     // way here to help support workers in the future.  There are still
     // some main thread calls for now, though.
 
@@ -253,17 +249,17 @@ ServiceWorkerContainer::GetController()
     NS_ENSURE_TRUE(inner, nullptr);
 
     // Right now we only know how to create ServiceWorker DOM objects on
     // the main thread with a window.  In the future this should operate
     // on only nsIGlobalObject somehow.
     mControllerWorker = info->GetOrCreateInstance(inner);
   }
 
-  RefPtr<workers::ServiceWorker> ref = mControllerWorker;
+  RefPtr<ServiceWorker> ref = mControllerWorker;
   return ref.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerContainer::GetRegistrations(ErrorResult& aRv)
 {
   nsresult rv;
   nsCOMPtr<nsIServiceWorkerManager> swm = do_GetService(SERVICEWORKERMANAGER_CONTRACTID, &rv);
diff --git a/dom/serviceworkers/ServiceWorkerContainer.h b/dom/serviceworkers/ServiceWorkerContainer.h
--- a/dom/serviceworkers/ServiceWorkerContainer.h
+++ b/dom/serviceworkers/ServiceWorkerContainer.h
@@ -12,20 +12,16 @@
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 struct RegistrationOptions;
 
-namespace workers {
-class ServiceWorker;
-} // namespace workers
-
 // Lightweight serviceWorker APIs collection.
 class ServiceWorkerContainer final : public DOMEventTargetHelper
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerContainer, DOMEventTargetHelper)
 
   IMPL_EVENT_HANDLER(controllerchange)
@@ -39,17 +35,17 @@ public:
   virtual JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   already_AddRefed<Promise>
   Register(const nsAString& aScriptURL,
            const RegistrationOptions& aOptions,
            ErrorResult& aRv);
 
-  already_AddRefed<workers::ServiceWorker>
+  already_AddRefed<ServiceWorker>
   GetController();
 
   already_AddRefed<Promise>
   GetRegistration(const nsAString& aDocumentURL,
                   ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetRegistrations(ErrorResult& aRv);
@@ -71,17 +67,17 @@ public:
 
 private:
   ~ServiceWorkerContainer();
 
   void RemoveReadyPromise();
 
   // This only changes when a worker hijacks everything in its scope by calling
   // claim.
-  RefPtr<workers::ServiceWorker> mControllerWorker;
+  RefPtr<ServiceWorker> mControllerWorker;
 
   RefPtr<Promise> mReadyPromise;
 };
 
 } // namespace dom
 } // namespace mozilla
 
-#endif /* mozilla_dom_workers_serviceworkercontainer_h__ */
+#endif /* mozilla_dom_serviceworkercontainer_h__ */
diff --git a/dom/serviceworkers/ServiceWorkerEvents.cpp b/dom/serviceworkers/ServiceWorkerEvents.cpp
--- a/dom/serviceworkers/ServiceWorkerEvents.cpp
+++ b/dom/serviceworkers/ServiceWorkerEvents.cpp
@@ -19,16 +19,17 @@
 #include "nsContentUtils.h"
 #include "nsComponentManagerUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "nsStreamUtils.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsSerializationHelper.h"
 #include "nsQueryObject.h"
+#include "ServiceWorker.h"
 #include "ServiceWorkerManager.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Move.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/BodyUtil.h"
 #include "mozilla/dom/Client.h"
@@ -37,17 +38,16 @@
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/PushMessageDataBinding.h"
 #include "mozilla/dom/PushUtil.h"
 #include "mozilla/dom/Request.h"
 #include "mozilla/dom/TypedArray.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/WorkerScope.h"
-#include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
 #include "js/Conversions.h"
 #include "js/TypeDecls.h"
 #include "WorkerPrivate.h"
 #include "xpcpublic.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
@@ -89,23 +89,24 @@ AsyncLog(nsIInterceptedChannel* aInterce
   StringArrayAppender::Append(paramsList, sizeof...(Params) + 1,
                               aFirstParam, Forward<Params>(aParams)...);
   AsyncLog(aInterceptedChannel, aRespondWithScriptSpec, aRespondWithLineNumber,
            aRespondWithColumnNumber, aMessageName, paramsList);
 }
 
 } // anonymous namespace
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 CancelChannelRunnable::CancelChannelRunnable(
   nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
   nsresult aStatus)
-  : Runnable("dom::workers::CancelChannelRunnable")
+  : Runnable("dom::CancelChannelRunnable")
   , mChannel(aChannel)
   , mRegistration(aRegistration)
   , mStatus(aStatus)
 {
 }
 
 NS_IMETHODIMP
 CancelChannelRunnable::Run()
@@ -192,25 +193,25 @@ struct RespondWithClosure
 };
 
 class FinishResponse final : public Runnable
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
 
 public:
   explicit FinishResponse(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel)
-    : Runnable("dom::workers::FinishResponse")
+    : Runnable("dom::FinishResponse")
     , mChannel(aChannel)
   {
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     nsresult rv = mChannel->FinishSynthesizedResponse();
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mChannel->CancelInterception(NS_ERROR_INTERCEPTION_FAILED);
       return NS_OK;
     }
 
     TimeStamp timeStamp = TimeStamp::Now();
@@ -278,30 +279,30 @@ class StartResponse final : public Runna
 
 public:
   StartResponse(nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel,
                 InternalResponse* aInternalResponse,
                 const ChannelInfo& aWorkerChannelInfo,
                 const nsACString& aScriptSpec,
                 const nsACString& aResponseURLSpec,
                 UniquePtr<RespondWithClosure>&& aClosure)
-    : Runnable("dom::workers::StartResponse")
+    : Runnable("dom::StartResponse")
     , mChannel(aChannel)
     , mInternalResponse(aInternalResponse)
     , mWorkerChannelInfo(aWorkerChannelInfo)
     , mScriptSpec(aScriptSpec)
     , mResponseURLSpec(aResponseURLSpec)
     , mClosure(Move(aClosure))
   {
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     nsCOMPtr<nsIChannel> underlyingChannel;
     nsresult rv = mChannel->GetChannel(getter_AddRefs(underlyingChannel));
     NS_ENSURE_SUCCESS(rv, rv);
     NS_ENSURE_TRUE(underlyingChannel, NS_ERROR_UNEXPECTED);
     nsCOMPtr<nsILoadInfo> loadInfo = underlyingChannel->GetLoadInfo();
 
     if (!loadInfo || !CSPPermitsResponse(loadInfo)) {
@@ -380,17 +381,17 @@ public:
       obsService->NotifyObservers(underlyingChannel, "service-worker-synthesized-response", nullptr);
     }
 
     return rv;
   }
 
   bool CSPPermitsResponse(nsILoadInfo* aLoadInfo)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aLoadInfo);
     nsresult rv;
     nsCOMPtr<nsIURI> uri;
     nsCString url = mInternalResponse->GetUnfilteredURL();
     if (url.IsEmpty()) {
       // Synthetic response. The buck stops at the worker script.
       url = mScriptSpec;
     }
@@ -921,17 +922,17 @@ public:
     MOZ_ALWAYS_SUCCEEDS(mWorkerPrivate->DispatchToMainThread(
                           NewRunnableMethod("WaitUntilHandler::ReportOnMainThread",
                                             this, &WaitUntilHandler::ReportOnMainThread)));
   }
 
   void
   ReportOnMainThread()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       // browser shutdown
       return;
     }
 
     // TODO: Make the error message a localized string. (bug 1222720)
     nsString message;
@@ -1307,9 +1308,10 @@ NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INH
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(ExtendableMessageEvent)
 NS_INTERFACE_MAP_END_INHERITING(Event)
 
 NS_IMPL_ADDREF_INHERITED(ExtendableMessageEvent, Event)
 NS_IMPL_RELEASE_INHERITED(ExtendableMessageEvent, Event)
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerEvents.h b/dom/serviceworkers/ServiceWorkerEvents.h
--- a/dom/serviceworkers/ServiceWorkerEvents.h
+++ b/dom/serviceworkers/ServiceWorkerEvents.h
@@ -1,47 +1,42 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerevents_h__
-#define mozilla_dom_workers_serviceworkerevents_h__
+#ifndef mozilla_dom_serviceworkerevents_h__
+#define mozilla_dom_serviceworkerevents_h__
 
 #include "mozilla/dom/DOMPrefs.h"
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/ExtendableEventBinding.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
-#include "mozilla/dom/workers/bindings/ServiceWorker.h"
 #include "mozilla/dom/workers/Workers.h"
 
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
+
 class Blob;
 class Client;
 class MessagePort;
+struct PushEventInit;
 class Request;
 class ResponseOrPromise;
-
-struct PushEventInit;
-} // namespace dom
-} // namespace mozilla
-
-BEGIN_WORKERS_NAMESPACE
-
+class ServiceWorker;
 class ServiceWorkerRegistrationInfo;
 
 class CancelChannelRunnable final : public Runnable
 {
   nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
   const nsresult mStatus;
 public:
@@ -320,11 +315,12 @@ public:
   {
     aLastEventId = mLastEventId;
     return NS_OK;
   }
 
   void GetPorts(nsTArray<RefPtr<MessagePort>>& aPorts);
 };
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
 
-#endif /* mozilla_dom_workers_serviceworkerevents_h__ */
+#endif /* mozilla_dom_serviceworkerevents_h__ */
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -3,17 +3,18 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerInfo.h"
 
 #include "ServiceWorkerScriptCache.h"
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 using mozilla::ipc::PrincipalInfo;
 
 static_assert(nsIServiceWorkerInfo::STATE_PARSED == static_cast<uint16_t>(ServiceWorkerState::Parsed),
               "ServiceWorkerState enumeration value should match state values from nsIServiceWorkerInfo.");
 static_assert(nsIServiceWorkerInfo::STATE_INSTALLING == static_cast<uint16_t>(ServiceWorkerState::Installing),
               "ServiceWorkerState enumeration value should match state values from nsIServiceWorkerInfo.");
 static_assert(nsIServiceWorkerInfo::STATE_INSTALLED == static_cast<uint16_t>(ServiceWorkerState::Installed),
@@ -27,34 +28,34 @@ static_assert(nsIServiceWorkerInfo::STAT
 static_assert(nsIServiceWorkerInfo::STATE_UNKNOWN == static_cast<uint16_t>(ServiceWorkerState::EndGuard_),
               "ServiceWorkerState enumeration value should match state values from nsIServiceWorkerInfo.");
 
 NS_IMPL_ISUPPORTS(ServiceWorkerInfo, nsIServiceWorkerInfo)
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetScriptSpec(nsAString& aScriptSpec)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   CopyUTF8toUTF16(mScriptSpec, aScriptSpec);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetCacheName(nsAString& aCacheName)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   aCacheName = mCacheName;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetState(uint16_t* aState)
 {
   MOZ_ASSERT(aState);
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   *aState = static_cast<uint16_t>(State());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetDebugger(nsIWorkerDebugger** aResult)
 {
   if (NS_WARN_IF(!aResult)) {
@@ -63,43 +64,43 @@ ServiceWorkerInfo::GetDebugger(nsIWorker
 
   return mServiceWorkerPrivate->GetDebugger(aResult);
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetHandlesFetchEvents(bool* aValue)
 {
   MOZ_ASSERT(aValue);
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   *aValue = HandlesFetch();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetInstalledTime(PRTime* _retval)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(_retval);
   *_retval = mInstalledTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetActivatedTime(PRTime* _retval)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(_retval);
   *_retval = mActivatedTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::GetRedundantTime(PRTime* _retval)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(_retval);
   *_retval = mRedundantTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerInfo::AttachDebugger()
 {
@@ -143,17 +144,17 @@ ServiceWorkerInfo::RemoveWorker(ServiceW
 
 namespace {
 
 class ChangeStateUpdater final : public Runnable
 {
 public:
   ChangeStateUpdater(const nsTArray<ServiceWorker*>& aInstances,
                      ServiceWorkerState aState)
-    : Runnable("dom::workers::ChangeStateUpdater")
+    : Runnable("dom::ChangeStateUpdater")
     , mState(aState)
   {
     for (size_t i = 0; i < aInstances.Length(); ++i) {
       mInstances.AppendElement(aInstances[i]);
     }
   }
 
   NS_IMETHOD Run() override
@@ -176,17 +177,17 @@ private:
   ServiceWorkerState mState;
 };
 
 }
 
 void
 ServiceWorkerInfo::UpdateState(ServiceWorkerState aState)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 #ifdef DEBUG
   // Any state can directly transition to redundant, but everything else is
   // ordered.
   if (aState != ServiceWorkerState::Redundant) {
     MOZ_ASSERT_IF(State() == ServiceWorkerState::EndGuard_,
                   aState == ServiceWorkerState::Installing);
     MOZ_ASSERT_IF(State() == ServiceWorkerState::Installing,
                   aState == ServiceWorkerState::Installed);
@@ -262,17 +263,17 @@ uint64_t
 ServiceWorkerInfo::GetNextID() const
 {
   return ++gServiceWorkerInfoCurrentID;
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerInfo::GetOrCreateInstance(nsPIDOMWindowInner* aWindow)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aWindow);
 
   RefPtr<ServiceWorker> ref;
 
   for (uint32_t i = 0; i < mInstances.Length(); ++i) {
     MOZ_ASSERT(mInstances[i]);
     if (mInstances[i]->GetOwner() == aWindow) {
       ref = mInstances[i];
@@ -315,9 +316,10 @@ ServiceWorkerInfo::UpdateRedundantTime()
   MOZ_ASSERT(State() == ServiceWorkerState::Redundant);
   MOZ_ASSERT(mRedundantTime == 0);
 
   mRedundantTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
 }
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerInfo.h b/dom/serviceworkers/ServiceWorkerInfo.h
--- a/dom/serviceworkers/ServiceWorkerInfo.h
+++ b/dom/serviceworkers/ServiceWorkerInfo.h
@@ -1,24 +1,23 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerinfo_h
-#define mozilla_dom_workers_serviceworkerinfo_h
+#ifndef mozilla_dom_serviceworkerinfo_h
+#define mozilla_dom_serviceworkerinfo_h
 
 #include "mozilla/dom/ServiceWorkerBinding.h" // For ServiceWorkerState
 #include "mozilla/dom/workers/Workers.h"
 #include "nsIServiceWorkerManager.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorker;
 class ServiceWorkerPrivate;
 
 /*
  * Wherever the spec treats a worker instance and a description of said worker
  * as the same thing; i.e. "Resolve foo with
  * _GetNewestWorker(serviceWorkerRegistration)", we represent the description
@@ -101,23 +100,23 @@ public:
   const nsCString&
   Scope() const
   {
     return mDescriptor.Scope();
   }
 
   bool SkipWaitingFlag() const
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     return mSkipWaitingFlag;
   }
 
   void SetSkipWaitingFlag()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mSkipWaitingFlag = true;
   }
 
   ServiceWorkerInfo(nsIPrincipal* aPrincipal,
                     const nsACString& aScope,
                     const nsACString& aScriptSpec,
                     const nsAString& aCacheName,
                     nsLoadFlags aLoadFlags);
@@ -160,32 +159,32 @@ public:
 
   void
   UpdateState(ServiceWorkerState aState);
 
   // Only used to set initial state when loading from disk!
   void
   SetActivateStateUncheckedWithoutEvent(ServiceWorkerState aState)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mDescriptor.SetState(aState);
   }
 
   void
   SetHandlesFetch(bool aHandlesFetch)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch == Unknown);
     mHandlesFetch = aHandlesFetch ? Enabled : Disabled;
   }
 
   bool
   HandlesFetch() const
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_DIAGNOSTIC_ASSERT(mHandlesFetch != Unknown);
     return mHandlesFetch != Disabled;
   }
 
   void
   AppendWorker(ServiceWorker* aWorker);
 
   void
@@ -231,13 +230,12 @@ public:
     if (aTime == 0) {
       return;
     }
 
     mActivatedTime = aTime;
   }
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerinfo_h
+#endif // mozilla_dom_serviceworkerinfo_h
diff --git a/dom/serviceworkers/ServiceWorkerJob.cpp b/dom/serviceworkers/ServiceWorkerJob.cpp
--- a/dom/serviceworkers/ServiceWorkerJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerJob.cpp
@@ -7,17 +7,16 @@
 #include "ServiceWorkerJob.h"
 
 #include "nsProxyRelease.h"
 #include "nsThreadUtils.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 ServiceWorkerJob::Type
 ServiceWorkerJob::GetType() const
 {
   return mType;
 }
 
 ServiceWorkerJob::State
@@ -36,40 +35,40 @@ bool
 ServiceWorkerJob::ResultCallbacksInvoked() const
 {
   return mResultCallbacksInvoked;
 }
 
 bool
 ServiceWorkerJob::IsEquivalentTo(ServiceWorkerJob* aJob) const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aJob);
   return mType == aJob->mType &&
          mScope.Equals(aJob->mScope) &&
          mScriptSpec.Equals(aJob->mScriptSpec) &&
          mPrincipal->Equals(aJob->mPrincipal);
 }
 
 void
 ServiceWorkerJob::AppendResultCallback(Callback* aCallback)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mState != State::Finished);
   MOZ_DIAGNOSTIC_ASSERT(aCallback);
   MOZ_DIAGNOSTIC_ASSERT(mFinalCallback != aCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aCallback));
   MOZ_DIAGNOSTIC_ASSERT(!mResultCallbacksInvoked);
   mResultCallbackList.AppendElement(aCallback);
 }
 
 void
 ServiceWorkerJob::StealResultCallbacksFrom(ServiceWorkerJob* aJob)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aJob);
   MOZ_ASSERT(aJob->mState == State::Initial);
 
   // Take the callbacks from the other job immediately to avoid the
   // any possibility of them existing on both jobs at once.
   nsTArray<RefPtr<Callback>> callbackList;
   callbackList.SwapElements(aJob->mResultCallbackList);
 
@@ -78,17 +77,17 @@ ServiceWorkerJob::StealResultCallbacksFr
     // each callback.
     AppendResultCallback(callback);
   }
 }
 
 void
 ServiceWorkerJob::Start(Callback* aFinalCallback)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(!mCanceled);
 
   MOZ_DIAGNOSTIC_ASSERT(aFinalCallback);
   MOZ_DIAGNOSTIC_ASSERT(!mFinalCallback);
   MOZ_ASSERT(!mResultCallbackList.Contains(aFinalCallback));
   mFinalCallback = aFinalCallback;
 
   MOZ_DIAGNOSTIC_ASSERT(mState == State::Initial);
@@ -110,52 +109,52 @@ ServiceWorkerJob::Start(Callback* aFinal
   // Otherwise start asynchronously.  We should never run a job synchronously.
   MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
     NS_DispatchToMainThread(runnable.forget())));
 }
 
 void
 ServiceWorkerJob::Cancel()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mCanceled);
   mCanceled = true;
 }
 
 ServiceWorkerJob::ServiceWorkerJob(Type aType,
                                    nsIPrincipal* aPrincipal,
                                    const nsACString& aScope,
                                    const nsACString& aScriptSpec)
   : mType(aType)
   , mPrincipal(aPrincipal)
   , mScope(aScope)
   , mScriptSpec(aScriptSpec)
   , mState(State::Initial)
   , mCanceled(false)
   , mResultCallbacksInvoked(false)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mPrincipal);
   MOZ_ASSERT(!mScope.IsEmpty());
   // Some job types may have an empty script spec
 }
 
 ServiceWorkerJob::~ServiceWorkerJob()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   // Jobs must finish or never be started.  Destroying an actively running
   // job is an error.
   MOZ_ASSERT(mState != State::Started);
   MOZ_ASSERT_IF(mState == State::Finished, mResultCallbacksInvoked);
 }
 
 void
 ServiceWorkerJob::InvokeResultCallbacks(ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(mState == State::Started);
 
   MOZ_DIAGNOSTIC_ASSERT(!mResultCallbacksInvoked);
   mResultCallbacksInvoked = true;
 
   nsTArray<RefPtr<Callback>> callbackList;
   callbackList.SwapElements(mResultCallbackList);
 
@@ -177,17 +176,17 @@ ServiceWorkerJob::InvokeResultCallbacks(
 {
   ErrorResult converted(aRv);
   InvokeResultCallbacks(converted);
 }
 
 void
 ServiceWorkerJob::Finish(ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // Avoid double-completion because it can result on operating on cleaned
   // up data.  This should not happen, though, so also assert to try to
   // narrow down the causes.
   MOZ_DIAGNOSTIC_ASSERT(mState == State::Started);
   if (mState != State::Started) {
     return;
   }
@@ -233,11 +232,10 @@ ServiceWorkerJob::Finish(ErrorResult& aR
 
 void
 ServiceWorkerJob::Finish(nsresult aRv)
 {
   ErrorResult converted(aRv);
   Finish(converted);
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerJob.h b/dom/serviceworkers/ServiceWorkerJob.h
--- a/dom/serviceworkers/ServiceWorkerJob.h
+++ b/dom/serviceworkers/ServiceWorkerJob.h
@@ -1,29 +1,28 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerjob_h
-#define mozilla_dom_workers_serviceworkerjob_h
+#ifndef mozilla_dom_serviceworkerjob_h
+#define mozilla_dom_serviceworkerjob_h
 
 #include "nsCOMPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIPrincipal;
 
 namespace mozilla {
 
 class ErrorResult;
 
 namespace dom {
-namespace workers {
 
 class ServiceWorkerJob
 {
 public:
   // Implement this interface to receive notification when a job completes.
   class Callback
   {
   public:
@@ -139,13 +138,12 @@ private:
   State mState;
   bool mCanceled;
   bool mResultCallbacksInvoked;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJob)
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerjob_h
+#endif // mozilla_dom_serviceworkerjob_h
diff --git a/dom/serviceworkers/ServiceWorkerJobQueue.cpp b/dom/serviceworkers/ServiceWorkerJobQueue.cpp
--- a/dom/serviceworkers/ServiceWorkerJobQueue.cpp
+++ b/dom/serviceworkers/ServiceWorkerJobQueue.cpp
@@ -6,54 +6,53 @@
 
 #include "ServiceWorkerJobQueue.h"
 
 #include "ServiceWorkerJob.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerJobQueue::Callback final : public ServiceWorkerJob::Callback
 {
   RefPtr<ServiceWorkerJobQueue> mQueue;
 
   ~Callback()
   {
   }
 
 public:
   explicit Callback(ServiceWorkerJobQueue* aQueue)
     : mQueue(aQueue)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mQueue);
   }
 
   virtual void
   JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mQueue->JobFinished(aJob);
   }
 
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue::Callback, override)
 };
 
 ServiceWorkerJobQueue::~ServiceWorkerJobQueue()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mJobList.IsEmpty());
 }
 
 void
 ServiceWorkerJobQueue::JobFinished(ServiceWorkerJob* aJob)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aJob);
 
   // XXX There are some corner cases where jobs can double-complete.  Until
   // we track all these down we do a non-fatal assert in debug builds and
   // a runtime check to verify the queue is in the correct state.
   NS_ASSERTION(!mJobList.IsEmpty(),
                "Job queue should contain the job that just completed.");
   NS_ASSERTION(mJobList.SafeElementAt(0, nullptr) == aJob,
@@ -69,33 +68,33 @@ ServiceWorkerJobQueue::JobFinished(Servi
   }
 
   RunJob();
 }
 
 void
 ServiceWorkerJobQueue::RunJob()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mJobList.IsEmpty());
   MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob::State::Initial);
 
   RefPtr<Callback> callback = new Callback(this);
   mJobList[0]->Start(callback);
 }
 
 ServiceWorkerJobQueue::ServiceWorkerJobQueue()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 }
 
 void
 ServiceWorkerJobQueue::ScheduleJob(ServiceWorkerJob* aJob)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aJob);
   MOZ_ASSERT(!mJobList.Contains(aJob));
 
   if (mJobList.IsEmpty()) {
     mJobList.AppendElement(aJob);
     RunJob();
     return;
   }
@@ -109,26 +108,25 @@ ServiceWorkerJobQueue::ScheduleJob(Servi
   }
 
   mJobList.AppendElement(aJob);
 }
 
 void
 ServiceWorkerJobQueue::CancelAll()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   for (RefPtr<ServiceWorkerJob>& job : mJobList) {
     job->Cancel();
   }
 
   // Remove jobs that are queued but not started since they should never
   // run after being canceled.  This means throwing away all jobs except
   // for the job at the front of the list.
   if (!mJobList.IsEmpty()) {
     MOZ_ASSERT(mJobList[0]->GetState() == ServiceWorkerJob::State::Started);
     mJobList.TruncateLength(1);
   }
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerJobQueue.h b/dom/serviceworkers/ServiceWorkerJobQueue.h
--- a/dom/serviceworkers/ServiceWorkerJobQueue.h
+++ b/dom/serviceworkers/ServiceWorkerJobQueue.h
@@ -1,23 +1,22 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerjobqueue_h
-#define mozilla_dom_workers_serviceworkerjobqueue_h
+#ifndef mozilla_dom_serviceworkerjobqueue_h
+#define mozilla_dom_serviceworkerjobqueue_h
 
 #include "mozilla/RefPtr.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerJob;
 
 class ServiceWorkerJobQueue final
 {
   class Callback;
 
   nsTArray<RefPtr<ServiceWorkerJob>> mJobList;
@@ -37,13 +36,12 @@ public:
   ScheduleJob(ServiceWorkerJob* aJob);
 
   void
   CancelAll();
 
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerJobQueue)
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerjobqueue_h
+#endif // mozilla_dom_serviceworkerjobqueue_h
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -91,17 +91,18 @@
 #ifdef PostMessage
 #undef PostMessage
 #endif
 
 using namespace mozilla;
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 #define PURGE_DOMAIN_DATA "browser:purge-domain-data"
 #define PURGE_SESSION_HISTORY "browser:purge-session-history"
 #define CLEAR_ORIGIN_DATA "clear-origin-attributes-data"
 
 static_assert(nsIHttpChannelInternal::CORS_MODE_SAME_ORIGIN == static_cast<uint32_t>(RequestMode::Same_origin),
               "RequestMode enumeration value should match Necko CORS mode value.");
 static_assert(nsIHttpChannelInternal::CORS_MODE_NO_CORS == static_cast<uint32_t>(RequestMode::No_cors),
@@ -218,17 +219,17 @@ PopulateRegistrationData(nsIPrincipal* a
 
   return NS_OK;
 }
 
 class TeardownRunnable final : public Runnable
 {
 public:
   explicit TeardownRunnable(ServiceWorkerManagerChild* aActor)
-    : Runnable("dom::workers::TeardownRunnable")
+    : Runnable("dom::ServiceWorkerManager::TeardownRunnable")
     , mActor(aActor)
   {
     MOZ_ASSERT(mActor);
   }
 
   NS_IMETHOD Run() override
   {
     MOZ_ASSERT(mActor);
@@ -438,17 +439,17 @@ class ServiceWorkerResolveWindowPromiseO
   PromiseWindowProxy mPromise;
 
   ~ServiceWorkerResolveWindowPromiseOnRegisterCallback()
   {}
 
   virtual void
   JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aJob);
     RefPtr<Promise> promise = mPromise.Get();
     if (!promise) {
       return;
     }
 
     if (aStatus.Failed()) {
       promise->MaybeReject(aStatus);
@@ -481,24 +482,24 @@ public:
 
 namespace {
 
 class PropagateSoftUpdateRunnable final : public Runnable
 {
 public:
   PropagateSoftUpdateRunnable(const OriginAttributes& aOriginAttributes,
                               const nsAString& aScope)
-    : Runnable("dom::workers::PropagateSoftUpdateRunnable")
+    : Runnable("dom::ServiceWorkerManager::PropagateSoftUpdateRunnable")
     , mOriginAttributes(aOriginAttributes)
     , mScope(aScope)
   {}
 
   NS_IMETHOD Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (swm) {
       swm->PropagateSoftUpdate(mOriginAttributes, mScope);
     }
 
     return NS_OK;
   }
@@ -570,26 +571,26 @@ private:
 //   notified by the parent (aInternalMethod == true)
 class SoftUpdateRunnable final : public CancelableRunnable
 {
 public:
   SoftUpdateRunnable(const OriginAttributes& aOriginAttributes,
                      const nsACString& aScope,
                      bool aInternalMethod,
                      GenericPromise::Private* aPromise)
-    : CancelableRunnable("dom::workers::SoftUpdateRunnable")
+    : CancelableRunnable("dom::ServiceWorkerManager::SoftUpdateRunnable")
     , mAttrs(aOriginAttributes)
     , mScope(aScope)
     , mInternalMethod(aInternalMethod)
     , mPromise(aPromise)
   {}
 
   NS_IMETHOD Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       return NS_ERROR_FAILURE;
     }
 
     if (mInternalMethod) {
       RefPtr<PromiseResolverCallback> callback =
@@ -641,27 +642,27 @@ public:
     eFailure,
   };
 
   UpdateRunnable(nsIPrincipal* aPrincipal,
                  const nsACString& aScope,
                  ServiceWorkerUpdateFinishCallback* aCallback,
                  Type aType,
                  GenericPromise::Private* aPromise)
-    : CancelableRunnable("dom::workers::UpdateRunnable")
+    : CancelableRunnable("dom::ServiceWorkerManager::UpdateRunnable")
     , mPrincipal(aPrincipal)
     , mScope(aScope)
     , mCallback(aCallback)
     , mType(aType)
     , mPromise(aPromise)
   {}
 
   NS_IMETHOD Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       return NS_ERROR_FAILURE;
     }
 
     if (mType == ePostpone) {
       swm->Update(mPrincipal, mScope, mCallback);
@@ -706,17 +707,17 @@ private:
 
   RefPtr<GenericPromise::Private> mPromise;
 };
 
 class ResolvePromiseRunnable final : public CancelableRunnable
 {
 public:
   explicit ResolvePromiseRunnable(GenericPromise::Private* aPromise)
-    : CancelableRunnable("dom::workers::ResolvePromiseRunnable")
+    : CancelableRunnable("dom::ServiceWorkerManager::ResolvePromiseRunnable")
     , mPromise(aPromise)
   {}
 
   NS_IMETHOD
   Run() override
   {
     MaybeResolve();
     return NS_OK;
@@ -786,17 +787,17 @@ IsFromAuthenticatedOrigin(nsIDocument* a
 // automatically reject the Promise.
 NS_IMETHODIMP
 ServiceWorkerManager::Register(mozIDOMWindow* aWindow,
                                nsIURI* aScopeURI,
                                nsIURI* aScriptURI,
                                uint16_t aUpdateViaCache,
                                nsISupports** aPromise)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
@@ -930,33 +931,33 @@ ServiceWorkerManager::Register(mozIDOMWi
   RefPtr<ServiceWorkerRegisterJob> job = new ServiceWorkerRegisterJob(
     documentPrincipal, cleanedScope, spec, loadGroup,
     static_cast<ServiceWorkerUpdateViaCache>(aUpdateViaCache)
   );
 
   job->AppendResultCallback(cb);
   queue->ScheduleJob(job);
 
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_REGISTRATIONS, 1);
 
   promise.forget(aPromise);
   return NS_OK;
 }
 
 /*
  * Implements the async aspects of the getRegistrations algorithm.
  */
 class GetRegistrationsRunnable final : public Runnable
 {
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   RefPtr<Promise> mPromise;
 public:
   GetRegistrationsRunnable(nsPIDOMWindowInner* aWindow, Promise* aPromise)
-    : Runnable("dom::workers::GetRegistrationsRunnable")
+    : Runnable("dom::ServiceWorkerManager::GetRegistrationsRunnable")
     , mWindow(aWindow)
     , mPromise(aPromise)
   {}
 
   NS_IMETHOD
   Run() override
   {
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
@@ -1035,17 +1036,17 @@ public:
 };
 
 // If we return an error code here, the ServiceWorkerContainer will
 // automatically reject the Promise.
 NS_IMETHODIMP
 ServiceWorkerManager::GetRegistrations(mozIDOMWindow* aWindow,
                                        nsISupports** aPromise)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
   // Don't allow a service worker to access service worker registrations
@@ -1087,17 +1088,17 @@ class GetRegistrationRunnable final : pu
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   RefPtr<Promise> mPromise;
   nsString mDocumentURL;
 
 public:
   GetRegistrationRunnable(nsPIDOMWindowInner* aWindow,
                           Promise* aPromise,
                           const nsAString& aDocumentURL)
-    : Runnable("dom::workers::GetRegistrationRunnable")
+    : Runnable("dom::ServiceWorkerManager::GetRegistrationRunnable")
     , mWindow(aWindow)
     , mPromise(aPromise)
     , mDocumentURL(aDocumentURL)
   {}
 
   NS_IMETHOD
   Run() override
   {
@@ -1158,17 +1159,17 @@ public:
 
 // If we return an error code here, the ServiceWorkerContainer will
 // automatically reject the Promise.
 NS_IMETHODIMP
 ServiceWorkerManager::GetRegistration(mozIDOMWindow* aWindow,
                                       const nsAString& aDocumentURL,
                                       nsISupports** aPromise)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
   // Don't allow a service worker to access service worker registrations
@@ -1204,17 +1205,17 @@ ServiceWorkerManager::GetRegistration(mo
 
 class GetReadyPromiseRunnable final : public Runnable
 {
   nsCOMPtr<nsPIDOMWindowInner> mWindow;
   RefPtr<Promise> mPromise;
 
 public:
   GetReadyPromiseRunnable(nsPIDOMWindowInner* aWindow, Promise* aPromise)
-    : Runnable("dom::workers::GetReadyPromiseRunnable")
+    : Runnable("dom::ServiceWorkerManager::GetReadyPromiseRunnable")
     , mWindow(aWindow)
     , mPromise(aPromise)
   {}
 
   NS_IMETHOD
   Run() override
   {
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
@@ -1367,17 +1368,17 @@ ServiceWorkerManager::SendNotificationCl
                                aOriginSuffix, aScope, aID, aTitle, aDir, aLang,
                                aBody, aTag, aIcon, aData, aBehavior);
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetReadyPromise(mozIDOMWindow* aWindow,
                                       nsISupports** aPromise)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   auto* window = nsPIDOMWindowInner::From(aWindow);
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
@@ -1402,17 +1403,17 @@ ServiceWorkerManager::GetReadyPromise(mo
     new GetReadyPromiseRunnable(window, promise);
   promise.forget(aPromise);
   return NS_DispatchToCurrentThread(runnable);
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::RemoveReadyPromise(mozIDOMWindow* aWindow)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aWindow);
 
   if (!aWindow) {
     return NS_ERROR_FAILURE;
   }
 
   mPendingReadyPromises.Remove(aWindow);
   return NS_OK;
@@ -1473,17 +1474,17 @@ ServiceWorkerManager::CheckReadyPromise(
 
   return false;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerManager::GetActiveWorkerInfoForScope(const OriginAttributes& aOriginAttributes,
                                                   const nsACString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   if (NS_FAILED(rv)) {
     return nullptr;
   }
   nsCOMPtr<nsIPrincipal> principal =
     BasePrincipal::CreateCodebasePrincipal(scopeURI, aOriginAttributes);
@@ -1494,17 +1495,17 @@ ServiceWorkerManager::GetActiveWorkerInf
   }
 
   return registration->GetActive();
 }
 
 ServiceWorkerInfo*
 ServiceWorkerManager::GetActiveWorkerInfoForDocument(nsIDocument* aDocument)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   Maybe<ClientInfo> clientInfo(aDocument->GetClientInfo());
   if (clientInfo.isNothing()) {
     return nullptr;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration;
   GetClientRegistration(clientInfo.ref(), getter_AddRefs(registration));
@@ -1525,24 +1526,24 @@ class UnregisterJobCallback final : publ
   ~UnregisterJobCallback()
   {
   }
 
 public:
   explicit UnregisterJobCallback(nsIServiceWorkerUnregisterCallback* aCallback)
     : mCallback(aCallback)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mCallback);
   }
 
   void
   JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aJob);
 
     if (aStatus.Failed()) {
       mCallback->UnregisterFailed();
       return;
     }
 
     MOZ_ASSERT(aJob->GetType() == ServiceWorkerJob::Type::Unregister);
@@ -1556,17 +1557,17 @@ public:
 
 } // anonymous namespace
 
 NS_IMETHODIMP
 ServiceWorkerManager::Unregister(nsIPrincipal* aPrincipal,
                                  nsIServiceWorkerUnregisterCallback* aCallback,
                                  const nsAString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!aPrincipal) {
     return NS_ERROR_FAILURE;
   }
 
   nsresult rv;
 
 // This is not accessible by content, and callers should always ensure scope is
@@ -1599,17 +1600,17 @@ ServiceWorkerManager::Unregister(nsIPrin
   queue->ScheduleJob(job);
   return NS_OK;
 }
 
 nsresult
 ServiceWorkerManager::NotifyUnregister(nsIPrincipal* aPrincipal,
                                        const nsAString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   nsresult rv;
 
 // This is not accessible by content, and callers should always ensure scope is
 // a correct URI, so this is wrapped in DEBUG
 #ifdef DEBUG
   nsCOMPtr<nsIURI> scopeURI;
@@ -1634,17 +1635,17 @@ ServiceWorkerManager::NotifyUnregister(n
 
   queue->ScheduleJob(job);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::WorkerIsIdle(ServiceWorkerInfo* aWorker)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(aWorker);
 
   RefPtr<ServiceWorkerRegistrationInfo> reg =
     GetRegistration(aWorker->Principal(), aWorker->Scope());
   if (!reg) {
     return;
   }
 
@@ -1696,17 +1697,17 @@ ServiceWorkerManager::GetInstance()
       swr = ServiceWorkerRegistrar::Get();
       if (!swr) {
         return nullptr;
       }
     }
 
     firstTime = false;
 
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     gInstance = new ServiceWorkerManager();
     gInstance->Init(swr);
     ClearOnShutdown(&gInstance);
   }
   RefPtr<ServiceWorkerManager> copy = gInstance.get();
   return copy.forget();
 }
@@ -1771,17 +1772,17 @@ ServiceWorkerManager::HandleError(JSCont
                                   const nsString& aMessage,
                                   const nsString& aFilename,
                                   const nsString& aLine,
                                   uint32_t aLineNumber,
                                   uint32_t aColumnNumber,
                                   uint32_t aFlags,
                                   JSExnType aExnType)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(aPrincipal, scopeKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
@@ -1795,17 +1796,17 @@ ServiceWorkerManager::HandleError(JSCont
   ReportToAllClients(aScope, aMessage, aFilename, aLine, aLineNumber,
                      aColumnNumber, aFlags);
 }
 
 void
 ServiceWorkerManager::LoadRegistration(
                              const ServiceWorkerRegistrationData& aRegistration)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIPrincipal> principal =
     PrincipalInfoToPrincipal(aRegistration.principal());
   if (!principal) {
     return;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -1851,17 +1852,17 @@ ServiceWorkerManager::LoadRegistration(
     registration->GetActive()->SetActivatedTime(aRegistration.currentWorkerActivatedTime());
   }
 }
 
 void
 ServiceWorkerManager::LoadRegistrations(
                   const nsTArray<ServiceWorkerRegistrationData>& aRegistrations)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   for (uint32_t i = 0, len = aRegistrations.Length(); i < len; ++i) {
     LoadRegistration(aRegistrations[i]);
   }
 }
 
 void
 ServiceWorkerManager::StoreRegistration(
@@ -2165,17 +2166,17 @@ ServiceWorkerManager::MaybeRemoveRegistr
     }
   }
 }
 
 bool
 ServiceWorkerManager::StartControlling(const ClientInfo& aClientInfo,
                                        const ServiceWorkerDescriptor& aServiceWorker)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIPrincipal> principal =
     PrincipalInfoToPrincipal(aServiceWorker.PrincipalInfo());
   NS_ENSURE_TRUE(principal, false);
 
   nsCOMPtr<nsIURI> scope;
   nsresult rv =
     NS_NewURI(getter_AddRefs(scope), aServiceWorker.Scope(), nullptr, nullptr);
@@ -2188,17 +2189,17 @@ ServiceWorkerManager::StartControlling(c
   StartControllingClient(aClientInfo, registration);
 
   return true;
 }
 
 void
 ServiceWorkerManager::MaybeCheckNavigationUpdate(const ClientInfo& aClientInfo)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   // We perform these success path navigation update steps when the
   // document tells us its more or less done loading.  This avoids
   // slowing down page load and also lets pages consistently get
   // updatefound events when they fire.
   //
   // 9.8.20 If respondWithEntered is false, then:
   // 9.8.22 Else: (respondWith was entered and succeeded)
   //    If request is a non-subresource request, then: Invoke Soft Update
@@ -2250,17 +2251,17 @@ ServiceWorkerManager::GetScopeForUrl(nsI
   aScope = NS_ConvertUTF8toUTF16(r->mScope);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::AddRegistrationEventListener(const nsAString& aScope,
                                                    ServiceWorkerRegistrationListener* aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aListener);
 #ifdef DEBUG
   // Ensure a registration is only listening for it's own scope.
   nsAutoString regScope;
   aListener->GetScope(regScope);
   MOZ_ASSERT(!regScope.IsEmpty());
   MOZ_ASSERT(aScope.Equals(regScope));
 #endif
@@ -2269,17 +2270,17 @@ ServiceWorkerManager::AddRegistrationEve
   mServiceWorkerRegistrationListeners.AppendElement(aListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::RemoveRegistrationEventListener(const nsAString& aScope,
                                                       ServiceWorkerRegistrationListener* aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aListener);
 #ifdef DEBUG
   // Ensure a registration is unregistering for it's own scope.
   nsAutoString regScope;
   aListener->GetScope(regScope);
   MOZ_ASSERT(!regScope.IsEmpty());
   MOZ_ASSERT(aScope.Equals(regScope));
 #endif
@@ -2288,17 +2289,17 @@ ServiceWorkerManager::RemoveRegistration
   mServiceWorkerRegistrationListeners.RemoveElement(aListener);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations(
   ServiceWorkerRegistrationInfo* aRegistration)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     nsAutoString regScope;
     target->GetScope(regScope);
     MOZ_ASSERT(!regScope.IsEmpty());
 
@@ -2313,17 +2314,17 @@ ServiceWorkerManager::FireUpdateFoundOnS
  * This is used for installing, waiting and active.
  */
 nsresult
 ServiceWorkerManager::GetServiceWorkerForScope(nsPIDOMWindowInner* aWindow,
                                                const nsAString& aScope,
                                                WhichServiceWorker aWhichWorker,
                                                nsISupports** aServiceWorker)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
 
   nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
   MOZ_ASSERT(doc);
 
@@ -2383,42 +2384,42 @@ class ContinueDispatchFetchEventRunnable
   nsCOMPtr<nsILoadGroup> mLoadGroup;
   bool mIsReload;
 public:
   ContinueDispatchFetchEventRunnable(
     ServiceWorkerPrivate* aServiceWorkerPrivate,
     nsIInterceptedChannel* aChannel,
     nsILoadGroup* aLoadGroup,
     bool aIsReload)
-    : Runnable("dom::workers::ContinueDispatchFetchEventRunnable")
+    : Runnable("dom::ServiceWorkerManager::ContinueDispatchFetchEventRunnable")
     , mServiceWorkerPrivate(aServiceWorkerPrivate)
     , mChannel(aChannel)
     , mLoadGroup(aLoadGroup)
     , mIsReload(aIsReload)
   {
     MOZ_ASSERT(aServiceWorkerPrivate);
     MOZ_ASSERT(aChannel);
   }
 
   void
   HandleError()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     NS_WARNING("Unexpected error while dispatching fetch event!");
     nsresult rv = mChannel->ResetInterception();
     if (NS_FAILED(rv)) {
       NS_WARNING("Failed to resume intercepted network request");
       mChannel->CancelInterception(rv);
     }
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     nsCOMPtr<nsIChannel> channel;
     nsresult rv = mChannel->GetChannel(getter_AddRefs(channel));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       HandleError();
       return NS_OK;
     }
 
@@ -2455,17 +2456,17 @@ public:
 
 } // anonymous namespace
 
 void
 ServiceWorkerManager::DispatchFetchEvent(nsIInterceptedChannel* aChannel,
                                          ErrorResult& aRv)
 {
   MOZ_ASSERT(aChannel);
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIChannel> internalChannel;
   aRv = aChannel->GetChannel(getter_AddRefs(internalChannel));
   if (NS_WARN_IF(aRv.Failed())) {
     return;
   }
 
   nsCOMPtr<nsILoadGroup> loadGroup;
@@ -2572,17 +2573,17 @@ ServiceWorkerManager::DispatchFetchEvent
     new ContinueDispatchFetchEventRunnable(serviceWorker->WorkerPrivate(),
                                            aChannel, loadGroup,
                                            loadInfo->GetIsDocshellReload());
 
   // When this service worker was registered, we also sent down the permissions
   // for the runnable. They should have arrived by now, but we still need to
   // wait for them if they have not.
   nsCOMPtr<nsIRunnable> permissionsRunnable = NS_NewRunnableFunction(
-    "dom::workers::ServiceWorkerManager::DispatchFetchEvent", [=]() {
+    "dom::ServiceWorkerManager::DispatchFetchEvent", [=]() {
       nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
       MOZ_ALWAYS_SUCCEEDS(permMgr->WhenPermissionsAvailable(serviceWorker->Principal(),
                                                             continueRunnable));
     });
 
   nsCOMPtr<nsIUploadChannel2> uploadChannel = do_QueryInterface(internalChannel);
 
   // If there is no upload stream, then continue immediately
@@ -2655,17 +2656,17 @@ ServiceWorkerManager::GetActive(nsPIDOMW
                                   WhichServiceWorker::ACTIVE_WORKER,
                                   aServiceWorker);
 }
 
 void
 ServiceWorkerManager::TransitionServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                                                 WhichServiceWorker aWhichOne)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     nsAutoString regScope;
     target->GetScope(regScope);
     MOZ_ASSERT(!regScope.IsEmpty());
 
     NS_ConvertUTF16toUTF8 utf8Scope(regScope);
@@ -2675,17 +2676,17 @@ ServiceWorkerManager::TransitionServiceW
     }
   }
 }
 
 void
 ServiceWorkerManager::InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                                                 WhichServiceWorker aWhichOnes)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     nsAutoString regScope;
     target->GetScope(regScope);
     MOZ_ASSERT(!regScope.IsEmpty());
 
     NS_ConvertUTF16toUTF8 utf8Scope(regScope);
@@ -2694,17 +2695,17 @@ ServiceWorkerManager::InvalidateServiceW
       target->InvalidateWorkers(aWhichOnes);
     }
   }
 }
 
 void
 ServiceWorkerManager::NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsTObserverArray<ServiceWorkerRegistrationListener*>::ForwardIterator it(mServiceWorkerRegistrationListeners);
   while (it.HasMore()) {
     RefPtr<ServiceWorkerRegistrationListener> target = it.GetNext();
     nsAutoString regScope;
     target->GetScope(regScope);
     MOZ_ASSERT(!regScope.IsEmpty());
 
     NS_ConvertUTF16toUTF8 utf8Scope(regScope);
@@ -2714,17 +2715,17 @@ ServiceWorkerManager::NotifyServiceWorke
     }
   }
 }
 
 void
 ServiceWorkerManager::SoftUpdate(const OriginAttributes& aOriginAttributes,
                                  const nsACString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mShuttingDown) {
     return;
   }
 
   RefPtr<GenericPromise::Private> promise =
     new GenericPromise::Private(__func__);
 
@@ -2748,24 +2749,24 @@ class UpdateJobCallback final : public S
   RefPtr<ServiceWorkerUpdateFinishCallback> mCallback;
 
   ~UpdateJobCallback() = default;
 
 public:
   explicit UpdateJobCallback(ServiceWorkerUpdateFinishCallback* aCallback)
     : mCallback(aCallback)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mCallback);
   }
 
   void
   JobFinished(ServiceWorkerJob* aJob, ErrorResult& aStatus) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aJob);
 
     if (aStatus.Failed()) {
       mCallback->UpdateFailed(aStatus);
       return;
     }
 
     MOZ_DIAGNOSTIC_ASSERT(aJob->GetType() == ServiceWorkerJob::Type::Update);
@@ -2780,17 +2781,17 @@ public:
 
 } // anonymous namespace
 
 void
 ServiceWorkerManager::SoftUpdateInternal(const OriginAttributes& aOriginAttributes,
                                          const nsACString& aScope,
                                          ServiceWorkerUpdateFinishCallback* aCallback)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aCallback);
 
   if (mShuttingDown) {
     return;
   }
 
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope);
@@ -2852,17 +2853,17 @@ ServiceWorkerManager::SoftUpdateInternal
   queue->ScheduleJob(job);
 }
 
 void
 ServiceWorkerManager::Update(nsIPrincipal* aPrincipal,
                              const nsACString& aScope,
                              ServiceWorkerUpdateFinishCallback* aCallback)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<GenericPromise::Private> promise =
     new GenericPromise::Private(__func__);
 
   RefPtr<CancelableRunnable> successRunnable =
     new UpdateRunnable(aPrincipal, aScope, aCallback,
                        UpdateRunnable::eSuccess, promise);
 
@@ -3021,17 +3022,17 @@ ServiceWorkerManager::SetSkipWaitingFlag
   if (worker->State() == ServiceWorkerState::Installed) {
     registration->TryToActivateAsync();
   }
 }
 
 void
 ServiceWorkerManager::UpdateClientControllers(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerInfo> activeWorker = aRegistration->GetActive();
   MOZ_DIAGNOSTIC_ASSERT(activeWorker);
 
   AutoTArray<RefPtr<ClientHandle>, 16> handleList;
   for (auto iter = mControlledClients.Iter(); !iter.Done(); iter.Next()) {
     if (iter.UserData()->mRegistrationInfo != aRegistration) {
       continue;
@@ -3116,17 +3117,17 @@ ServiceWorkerManager::GetRegistration(co
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::CreateNewRegistration(
     const nsCString& aScope,
     nsIPrincipal* aPrincipal,
     ServiceWorkerUpdateViaCache aUpdateViaCache)
 {
 #ifdef DEBUG
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIURI> scopeURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 
   RefPtr<ServiceWorkerRegistrationInfo> tmp =
     GetRegistration(aPrincipal, aScope);
   MOZ_ASSERT(!tmp);
 #endif
@@ -3185,17 +3186,17 @@ namespace {
  * Returns true if the |url| passed in is part of the given root |domain|.
  * For example, if |url| is "www.mozilla.org", and we pass in |domain| as
  * "mozilla.org", this will return true. It would return false the other way
  * around.
  */
 bool
 HasRootDomain(nsIURI* aURI, const nsACString& aDomain)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aURI);
 
   nsAutoCString host;
   nsresult rv = aURI->GetHost(host);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return false;
   }
 
@@ -3220,17 +3221,17 @@ HasRootDomain(nsIURI* aURI, const nsACSt
   return prevChar == '.';
 }
 
 } // namespace
 
 NS_IMETHODIMP
 ServiceWorkerManager::GetAllRegistrations(nsIArray** aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIMutableArray> array(do_CreateInstance(NS_ARRAY_CONTRACTID));
   if (!array) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
     for (auto it2 = it1.UserData()->mInfos.Iter(); !it2.Done(); it2.Next()) {
@@ -3278,17 +3279,17 @@ ServiceWorkerManager::RemoveAndPropagate
   Remove(aHost);
   PropagateRemove(aHost);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::Remove(const nsACString& aHost)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
     ServiceWorkerManager::RegistrationDataPerPrincipal* data = it1.UserData();
     for (auto it2 = data->mInfos.Iter(); !it2.Done(); it2.Next()) {
       ServiceWorkerRegistrationInfo* reg = it2.UserData();
       nsCOMPtr<nsIURI> scopeURI;
       nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), it2.Key(),
                               nullptr, nullptr);
@@ -3298,46 +3299,46 @@ ServiceWorkerManager::Remove(const nsACS
       }
     }
   }
 }
 
 void
 ServiceWorkerManager::PropagateRemove(const nsACString& aHost)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mActor->SendPropagateRemove(nsCString(aHost));
 }
 
 void
 ServiceWorkerManager::RemoveAll()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
     ServiceWorkerManager::RegistrationDataPerPrincipal* data = it1.UserData();
     for (auto it2 = data->mInfos.Iter(); !it2.Done(); it2.Next()) {
       ServiceWorkerRegistrationInfo* reg = it2.UserData();
       ForceUnregister(data, reg);
     }
   }
 }
 
 void
 ServiceWorkerManager::PropagateRemoveAll()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(XRE_IsParentProcess());
   mActor->SendPropagateRemoveAll();
 }
 
 void
 ServiceWorkerManager::RemoveAllRegistrations(OriginAttributesPattern* aPattern)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_ASSERT(aPattern);
 
   for (auto it1 = mRegistrationInfos.Iter(); !it1.Done(); it1.Next()) {
     ServiceWorkerManager::RegistrationDataPerPrincipal* data = it1.UserData();
 
     // We can use iteration because ForceUnregister (and Unregister) are
     // async. Otherwise doing some R/W operations on an hashtable during
@@ -3357,31 +3358,31 @@ ServiceWorkerManager::RemoveAllRegistrat
       ForceUnregister(data, reg);
     }
   }
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::AddListener(nsIServiceWorkerManagerListener* aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!aListener || mListeners.Contains(aListener)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   mListeners.AppendElement(aListener);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::RemoveListener(nsIServiceWorkerManagerListener* aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!aListener || !mListeners.Contains(aListener)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   mListeners.RemoveElement(aListener);
 
   return NS_OK;
@@ -3424,41 +3425,41 @@ ServiceWorkerManager::Observe(nsISupport
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::PropagateSoftUpdate(JS::Handle<JS::Value> aOriginAttributes,
                                           const nsAString& aScope,
                                           JSContext* aCx)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   OriginAttributes attrs;
   if (!aOriginAttributes.isObject() || !attrs.Init(aCx, aOriginAttributes)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   PropagateSoftUpdate(attrs, aScope);
   return NS_OK;
 }
 
 void
 ServiceWorkerManager::PropagateSoftUpdate(const OriginAttributes& aOriginAttributes,
                                           const nsAString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mActor->SendPropagateSoftUpdate(aOriginAttributes, nsString(aScope));
 }
 
 NS_IMETHODIMP
 ServiceWorkerManager::PropagateUnregister(nsIPrincipal* aPrincipal,
                                           nsIServiceWorkerUnregisterCallback* aCallback,
                                           const nsAString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   PrincipalInfo principalInfo;
   if (NS_WARN_IF(NS_FAILED(PrincipalToPrincipalInfo(aPrincipal,
                                                     &principalInfo)))) {
     return NS_ERROR_FAILURE;
   }
 
@@ -3502,25 +3503,25 @@ class UpdateTimerCallback final : public
   {
   }
 
 public:
   UpdateTimerCallback(nsIPrincipal* aPrincipal, const nsACString& aScope)
     : mPrincipal(aPrincipal)
     , mScope(aScope)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mPrincipal);
     MOZ_ASSERT(!mScope.IsEmpty());
   }
 
   NS_IMETHOD
   Notify(nsITimer* aTimer) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (!swm) {
       // shutting down, do nothing
       return NS_OK;
     }
 
     swm->UpdateTimerFired(mPrincipal, mScope);
@@ -3538,17 +3539,17 @@ public:
 };
 
 NS_IMPL_ISUPPORTS(UpdateTimerCallback, nsITimerCallback, nsINamed)
 
 bool
 ServiceWorkerManager::MayHaveActiveServiceWorkerInstance(ContentParent* aContent,
                                                          nsIPrincipal* aPrincipal)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   if (mShuttingDown) {
     return false;
   }
 
   nsAutoCString scopeKey;
   nsresult rv = PrincipalToScopeKey(aPrincipal, scopeKey);
@@ -3563,17 +3564,17 @@ ServiceWorkerManager::MayHaveActiveServi
 
   return true;
 }
 
 void
 ServiceWorkerManager::ScheduleUpdateTimer(nsIPrincipal* aPrincipal,
                                           const nsACString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aScope.IsEmpty());
 
   if (mShuttingDown) {
     return;
   }
 
   nsAutoCString scopeKey;
@@ -3613,17 +3614,17 @@ ServiceWorkerManager::ScheduleUpdateTime
     return;
   }
 }
 
 void
 ServiceWorkerManager::UpdateTimerFired(nsIPrincipal* aPrincipal,
                                        const nsACString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aScope.IsEmpty());
 
   if (mShuttingDown) {
     return;
   }
 
   // First cleanup the timer.
@@ -3657,26 +3658,27 @@ ServiceWorkerManager::UpdateTimerFired(n
 
   SoftUpdate(attrs, aScope);
 }
 
 void
 ServiceWorkerManager::MaybeSendUnregister(nsIPrincipal* aPrincipal,
                                           const nsACString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aScope.IsEmpty());
 
   if (!mActor) {
     return;
   }
 
   PrincipalInfo principalInfo;
   nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
   Unused << mActor->SendUnregister(principalInfo, NS_ConvertUTF8toUTF16(aScope));
 }
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerManager.h b/dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h
+++ b/dom/serviceworkers/ServiceWorkerManager.h
@@ -21,17 +21,17 @@
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ClientHandle.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerCommon.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/dom/ServiceWorkerRegistrarTypes.h"
-#include "mozilla/dom/workers/ServiceWorkerRegistrationInfo.h"
+#include "mozilla/dom/ServiceWorkerRegistrationInfo.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsTArrayForwardDeclare.h"
 #include "nsTObserverArray.h"
 
 class nsIConsoleReportCollector;
@@ -41,25 +41,22 @@ namespace mozilla {
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
-class ServiceWorkerRegistrar;
-class ServiceWorkerRegistrationListener;
-
-namespace workers {
-
 class ServiceWorkerInfo;
 class ServiceWorkerJobQueue;
 class ServiceWorkerManagerChild;
 class ServiceWorkerPrivate;
+class ServiceWorkerRegistrar;
+class ServiceWorkerRegistrationListener;
 
 class ServiceWorkerUpdateFinishCallback
 {
 protected:
   virtual ~ServiceWorkerUpdateFinishCallback()
   {}
 
 public:
@@ -487,13 +484,12 @@ private:
                         const nsAString& aLang,
                         const nsAString& aBody,
                         const nsAString& aTag,
                         const nsAString& aIcon,
                         const nsAString& aData,
                         const nsAString& aBehavior);
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_workers_serviceworkermanager_h
diff --git a/dom/serviceworkers/ServiceWorkerManagerChild.cpp b/dom/serviceworkers/ServiceWorkerManagerChild.cpp
--- a/dom/serviceworkers/ServiceWorkerManagerChild.cpp
+++ b/dom/serviceworkers/ServiceWorkerManagerChild.cpp
@@ -9,17 +9,16 @@
 #include "ServiceWorkerUpdaterChild.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
-namespace workers {
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerChild::RecvNotifyRegister(
                                      const ServiceWorkerRegistrationData& aData)
 {
   if (mShuttingDown) {
     return IPC_OK();
   }
@@ -112,11 +111,10 @@ ServiceWorkerManagerChild::AllocPService
 
 bool
 ServiceWorkerManagerChild::DeallocPServiceWorkerUpdaterChild(PServiceWorkerUpdaterChild* aActor)
 {
   delete aActor;
   return true;
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerManagerChild.h b/dom/serviceworkers/ServiceWorkerManagerChild.h
--- a/dom/serviceworkers/ServiceWorkerManagerChild.h
+++ b/dom/serviceworkers/ServiceWorkerManagerChild.h
@@ -14,17 +14,16 @@ namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
-namespace workers {
 
 class ServiceWorkerManagerChild final : public PServiceWorkerManagerChild
 {
   friend class mozilla::ipc::BackgroundChildImpl;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerManagerChild)
 
@@ -58,13 +57,12 @@ private:
     : mShuttingDown(false)
   {}
 
   ~ServiceWorkerManagerChild() {}
 
   bool mShuttingDown;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerManagerChild_h
diff --git a/dom/serviceworkers/ServiceWorkerManagerParent.cpp b/dom/serviceworkers/ServiceWorkerManagerParent.cpp
--- a/dom/serviceworkers/ServiceWorkerManagerParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerManagerParent.cpp
@@ -14,28 +14,27 @@
 #include "mozilla/Unused.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
-namespace workers {
 
 namespace {
 
 uint64_t sServiceWorkerManagerParentID = 0;
 
 class RegisterServiceWorkerCallback final : public Runnable
 {
 public:
   RegisterServiceWorkerCallback(const ServiceWorkerRegistrationData& aData,
                                 uint64_t aParentID)
-    : Runnable("dom::workers::RegisterServiceWorkerCallback")
+    : Runnable("dom::RegisterServiceWorkerCallback")
     , mData(aData)
     , mParentID(aParentID)
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
   }
 
   NS_IMETHOD
@@ -70,17 +69,17 @@ private:
 };
 
 class UnregisterServiceWorkerCallback final : public Runnable
 {
 public:
   UnregisterServiceWorkerCallback(const PrincipalInfo& aPrincipalInfo,
                                   const nsString& aScope,
                                   uint64_t aParentID)
-    : Runnable("dom::workers::UnregisterServiceWorkerCallback")
+    : Runnable("dom::UnregisterServiceWorkerCallback")
     , mPrincipalInfo(aPrincipalInfo)
     , mScope(aScope)
     , mParentID(aParentID)
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
   }
 
@@ -119,17 +118,17 @@ private:
 };
 
 class CheckPrincipalWithCallbackRunnable final : public Runnable
 {
 public:
   CheckPrincipalWithCallbackRunnable(already_AddRefed<ContentParent> aParent,
                                      const PrincipalInfo& aPrincipalInfo,
                                      Runnable* aCallback)
-    : Runnable("dom::workers::CheckPrincipalWithCallbackRunnable")
+    : Runnable("dom::CheckPrincipalWithCallbackRunnable")
     , mContentParent(aParent)
     , mPrincipalInfo(aPrincipalInfo)
     , mCallback(aCallback)
     , mBackgroundEventTarget(GetCurrentThreadEventTarget())
   {
     AssertIsInMainProcess();
     AssertIsOnBackgroundThread();
 
@@ -353,11 +352,10 @@ ServiceWorkerManagerParent::ActorDestroy
 
   if (mService) {
     // This object is about to be released and with it, also mService will be
     // released too.
     mService->UnregisterActor(this);
   }
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerManagerParent.h b/dom/serviceworkers/ServiceWorkerManagerParent.h
--- a/dom/serviceworkers/ServiceWorkerManagerParent.h
+++ b/dom/serviceworkers/ServiceWorkerManagerParent.h
@@ -13,17 +13,16 @@ namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
 
 namespace dom {
-namespace workers {
 
 class ServiceWorkerManagerService;
 
 class ServiceWorkerManagerParent final : public PServiceWorkerManagerParent
 {
   friend class mozilla::ipc::BackgroundParentImpl;
 
 public:
@@ -72,13 +71,12 @@ private:
 
   RefPtr<ServiceWorkerManagerService> mService;
 
   // We use this ID in the Service in order to avoid the sending of messages to
   // ourself.
   uint64_t mID;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerManagerParent_h
diff --git a/dom/serviceworkers/ServiceWorkerManagerService.cpp b/dom/serviceworkers/ServiceWorkerManagerService.cpp
--- a/dom/serviceworkers/ServiceWorkerManagerService.cpp
+++ b/dom/serviceworkers/ServiceWorkerManagerService.cpp
@@ -13,17 +13,16 @@
 #include "mozilla/Unused.h"
 #include "nsAutoPtr.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
-namespace workers {
 
 namespace {
 
 ServiceWorkerManagerService* sInstance = nullptr;
 
 } // namespace
 
 ServiceWorkerManagerService::ServiceWorkerManagerService()
@@ -105,17 +104,17 @@ ServiceWorkerManagerService::PropagateRe
 #endif
     }
   }
 
   // Send permissions fot the newly registered service worker to all of the
   // content processes.
   PrincipalInfo pi = aData.principal();
   NS_DispatchToMainThread(NS_NewRunnableFunction(
-    "dom::workers::ServiceWorkerManagerService::PropagateRegistration", [pi]() {
+    "dom::ServiceWorkerManagerService::PropagateRegistration", [pi]() {
       nsTArray<ContentParent*> cps;
       ContentParent::GetAll(cps);
       for (auto* cp : cps) {
         nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(pi);
         if (principal) {
           cp->TransmitPermissionsForPrincipal(principal);
         }
       }
@@ -288,11 +287,10 @@ ServiceWorkerManagerService::UpdaterActo
       mPendingUpdaterActors.RemoveElementAt(i);
       return;
     }
   }
 
   MOZ_CRASH("The actor should be found");
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerManagerService.h b/dom/serviceworkers/ServiceWorkerManagerService.h
--- a/dom/serviceworkers/ServiceWorkerManagerService.h
+++ b/dom/serviceworkers/ServiceWorkerManagerService.h
@@ -17,21 +17,18 @@ namespace mozilla {
 class OriginAttributes;
 
 namespace ipc {
 class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
+class ServiceWorkerManagerParent;
 class ServiceWorkerRegistrationData;
-
-namespace workers {
-
-class ServiceWorkerManagerParent;
 class ServiceWorkerUpdaterParent;
 
 class ServiceWorkerManagerService final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(ServiceWorkerManagerService)
 
   static already_AddRefed<ServiceWorkerManagerService> Get();
@@ -73,13 +70,12 @@ private:
     nsCString mScope;
     ServiceWorkerUpdaterParent* mActor;
     uint64_t mParentId;
   };
 
   nsTArray<PendingUpdaterActor> mPendingUpdaterActors;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerManagerService_h
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.cpp b/dom/serviceworkers/ServiceWorkerPrivate.cpp
--- a/dom/serviceworkers/ServiceWorkerPrivate.cpp
+++ b/dom/serviceworkers/ServiceWorkerPrivate.cpp
@@ -35,17 +35,18 @@
 #include "mozilla/dom/PromiseNativeHandler.h"
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/RequestBinding.h"
 #include "mozilla/Unused.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 using mozilla::ipc::PrincipalInfo;
 
 NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE(ServiceWorkerPrivate)
 NS_IMPL_CYCLE_COLLECTION(ServiceWorkerPrivate, mSupportsArray)
 
 NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(ServiceWorkerPrivate, AddRef)
@@ -64,39 +65,39 @@ Atomic<uint32_t> gDOMDisableOpenClickDel
 class KeepAliveToken final : public nsISupports
 {
 public:
   NS_DECL_ISUPPORTS
 
   explicit KeepAliveToken(ServiceWorkerPrivate* aPrivate)
     : mPrivate(aPrivate)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aPrivate);
     mPrivate->AddToken();
   }
 
 private:
   ~KeepAliveToken()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mPrivate->ReleaseToken();
   }
 
   RefPtr<ServiceWorkerPrivate> mPrivate;
 };
 
 NS_IMPL_ISUPPORTS0(KeepAliveToken)
 
 ServiceWorkerPrivate::ServiceWorkerPrivate(ServiceWorkerInfo* aInfo)
   : mInfo(aInfo)
   , mDebuggerCount(0)
   , mTokenCount(0)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aInfo);
 
   mIdleWorkerTimer = NS_NewTimer();
   MOZ_ASSERT(mIdleWorkerTimer);
 }
 
 ServiceWorkerPrivate::~ServiceWorkerPrivate()
 {
@@ -133,46 +134,46 @@ public:
         "CheckScriptEvaluationWithCallback::mServiceWorkerPrivate", aServiceWorkerPrivate))
     , mKeepAliveToken(new nsMainThreadPtrHolder<KeepAliveToken>(
         "CheckScriptEvaluationWithCallback::mKeepAliveToken", aKeepAliveToken))
     , mScriptEvaluationCallback(aScriptEvaluationCallback)
 #ifdef DEBUG
     , mDone(false)
 #endif
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   ~CheckScriptEvaluationWithCallback()
   {
     MOZ_ASSERT(mDone);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     aWorkerPrivate->AssertIsOnWorkerThread();
 
     bool fetchHandlerWasAdded = aWorkerPrivate->FetchHandlerWasAdded();
     nsCOMPtr<nsIRunnable> runnable = NewRunnableMethod<bool>(
-      "dom::workers::CheckScriptEvaluationWithCallback::ReportFetchFlag",
+      "dom::CheckScriptEvaluationWithCallback::ReportFetchFlag",
       this,
       &CheckScriptEvaluationWithCallback::ReportFetchFlag,
       fetchHandlerWasAdded);
     aWorkerPrivate->DispatchToMainThread(runnable.forget());
 
     ReportScriptEvaluationResult(aWorkerPrivate->WorkerScriptExecutedSuccessfully());
 
     return true;
   }
 
   void
   ReportFetchFlag(bool aFetchHandlerWasAdded)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mServiceWorkerPrivate->SetHandlesFetch(aFetchHandlerWasAdded);
   }
 
   nsresult
   Cancel() override
   {
     ReportScriptEvaluationResult(false);
     return WorkerRunnable::Cancel();
@@ -382,17 +383,17 @@ private:
     if (mPendingPromisesCount) {
       return;
     }
 
     CycleCollectedJSContext* cx = CycleCollectedJSContext::Get();
     MOZ_ASSERT(cx);
 
     RefPtr<nsIRunnable> r =
-      NewRunnableMethod("dom::workers::KeepAliveHandler::MaybeDone",
+      NewRunnableMethod("dom::KeepAliveHandler::MaybeDone",
                         this,
                         &KeepAliveHandler::MaybeDone);
     cx->DispatchToMicroTask(r.forget());
   }
 };
 
 NS_IMPL_ISUPPORTS0(KeepAliveHandler)
 
@@ -400,17 +401,17 @@ class RegistrationUpdateRunnable : publi
 {
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
   const bool mNeedTimeCheck;
 
 public:
   RegistrationUpdateRunnable(
     nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration,
     bool aNeedTimeCheck)
-    : Runnable("dom::workers::RegistrationUpdateRunnable")
+    : Runnable("dom::RegistrationUpdateRunnable")
     , mRegistration(aRegistration)
     , mNeedTimeCheck(aNeedTimeCheck)
   {
     MOZ_DIAGNOSTIC_ASSERT(mRegistration);
   }
 
   NS_IMETHOD
   Run() override
@@ -429,17 +430,17 @@ class ExtendableEventWorkerRunnable : pu
 protected:
   nsMainThreadPtrHandle<KeepAliveToken> mKeepAliveToken;
 
 public:
   ExtendableEventWorkerRunnable(WorkerPrivate* aWorkerPrivate,
                                 KeepAliveToken* aKeepAliveToken)
     : WorkerRunnable(aWorkerPrivate)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aWorkerPrivate);
     MOZ_ASSERT(aKeepAliveToken);
 
     mKeepAliveToken =
       new nsMainThreadPtrHolder<KeepAliveToken>(
         "ExtendableEventWorkerRunnable::mKeepAliveToken", aKeepAliveToken);
   }
 
@@ -497,17 +498,17 @@ public:
   SendMessageEventRunnable(WorkerPrivate*  aWorkerPrivate,
                            KeepAliveToken* aKeepAliveToken,
                            const ClientInfoAndState& aClientInfoAndState)
     : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
     , StructuredCloneHolder(CloningSupported, TransferringSupported,
                             StructuredCloneScope::SameProcessDifferentThread)
     , mClientInfoAndState(aClientInfoAndState)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     JS::Rooted<JS::Value> messageData(aCx);
     nsCOMPtr<nsIGlobalObject> sgo = aWorkerPrivate->GlobalScope();
     ErrorResult rv;
@@ -552,17 +553,17 @@ public:
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendMessageEvent(JSContext* aCx,
                                        JS::Handle<JS::Value> aMessage,
                                        const Sequence<JSObject*>& aTransferable,
                                        const ClientInfoAndState& aClientInfoAndState)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   ErrorResult rv(SpawnWorkerIfNeeded(MessageEvent, nullptr));
   if (NS_WARN_IF(rv.Failed())) {
     return rv.StealNSResult();
   }
 
   JS::Rooted<JS::Value> transferable(aCx, JS::UndefinedHandleValue);
 
@@ -637,17 +638,17 @@ public:
   LifecycleEventWorkerRunnable(WorkerPrivate* aWorkerPrivate,
                                KeepAliveToken* aToken,
                                const nsAString& aEventName,
                                LifeCycleEventCallback* aCallback)
       : ExtendableEventWorkerRunnable(aWorkerPrivate, aToken)
       , mEventName(aEventName)
       , mCallback(aCallback)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
     return DispatchLifecycleEvent(aCx, aWorkerPrivate);
   }
@@ -875,27 +876,27 @@ public:
     WorkerPrivate* workerPrivate = mWorkerPrivate;
     mWorkerPrivate->AssertIsOnWorkerThread();
 
     if (NS_WARN_IF(aReason > nsIPushErrorReporter::DELIVERY_INTERNAL_ERROR) ||
         mMessageId.IsEmpty()) {
       return;
     }
     nsCOMPtr<nsIRunnable> runnable = NewRunnableMethod<uint16_t>(
-      "dom::workers::PushErrorReporter::ReportOnMainThread",
+      "dom::PushErrorReporter::ReportOnMainThread",
       this,
       &PushErrorReporter::ReportOnMainThread,
       aReason);
     MOZ_ALWAYS_TRUE(NS_SUCCEEDED(
       workerPrivate->DispatchToMainThread(runnable.forget())));
   }
 
   void ReportOnMainThread(uint16_t aReason)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIPushErrorReporter> reporter =
       do_GetService("@mozilla.org/push/Service;1");
     if (reporter) {
       nsresult rv = reporter->ReportDeliveryError(mMessageId, aReason);
       Unused << NS_WARN_IF(NS_FAILED(rv));
     }
   }
 };
@@ -911,17 +912,17 @@ public:
                         const nsAString& aMessageId,
                         const Maybe<nsTArray<uint8_t>>& aData,
                         nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> aRegistration)
       : ExtendableFunctionalEventWorkerRunnable(
           aWorkerPrivate, aKeepAliveToken, aRegistration)
       , mMessageId(aMessageId)
       , mData(aData)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aWorkerPrivate);
     MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
@@ -969,17 +970,17 @@ public:
 class SendPushSubscriptionChangeEventRunnable final : public ExtendableEventWorkerRunnable
 {
 
 public:
   explicit SendPushSubscriptionChangeEventRunnable(
     WorkerPrivate* aWorkerPrivate, KeepAliveToken* aKeepAliveToken)
       : ExtendableEventWorkerRunnable(aWorkerPrivate, aKeepAliveToken)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aWorkerPrivate);
     MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
@@ -1214,17 +1215,17 @@ public:
       , mLang(aLang)
       , mBody(aBody)
       , mTag(aTag)
       , mIcon(aIcon)
       , mData(aData)
       , mBehavior(aBehavior)
       , mScope(aScope)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aWorkerPrivate);
     MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     MOZ_ASSERT(aWorkerPrivate);
@@ -1384,17 +1385,17 @@ public:
     mHeaderNames.AppendElement(aHeader);
     mHeaderValues.AppendElement(aValue);
     return NS_OK;
   }
 
   nsresult
   Init()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     nsCOMPtr<nsIChannel> channel;
     nsresult rv = mInterceptedChannel->GetChannel(getter_AddRefs(channel));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIURI> uri;
     rv = mInterceptedChannel->GetSecureUpgradedChannelURI(getter_AddRefs(uri));
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1548,25 +1549,25 @@ public:
 private:
   ~FetchEventRunnable() {}
 
   class ResumeRequest final : public Runnable {
     nsMainThreadPtrHandle<nsIInterceptedChannel> mChannel;
   public:
     explicit ResumeRequest(
       nsMainThreadPtrHandle<nsIInterceptedChannel>& aChannel)
-      : Runnable("dom::workers::FetchEventRunnable::ResumeRequest")
+      : Runnable("dom::FetchEventRunnable::ResumeRequest")
       , mChannel(aChannel)
     {
       mChannel->SetFinishResponseStart(TimeStamp::Now());
     }
 
     NS_IMETHOD Run() override
     {
-      AssertIsOnMainThread();
+      MOZ_ASSERT(NS_IsMainThread());
 
       TimeStamp timeStamp = TimeStamp::Now();
       mChannel->SetHandleFetchEventEnd(timeStamp);
       mChannel->SetChannelResetEnd(timeStamp);
       mChannel->SaveTimeStamps();
 
       nsresult rv = mChannel->ResetInterception();
       if (NS_FAILED(rv)) {
@@ -1693,17 +1694,17 @@ NS_IMPL_ISUPPORTS_INHERITED(FetchEventRu
 
 } // anonymous namespace
 
 nsresult
 ServiceWorkerPrivate::SendFetchEvent(nsIInterceptedChannel* aChannel,
                                      nsILoadGroup* aLoadGroup,
                                      const nsAString& aClientId, bool aIsReload)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(!mInfo || !swm)) {
     return NS_ERROR_FAILURE;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     swm->GetRegistration(mInfo->Principal(), mInfo->Scope());
@@ -1794,17 +1795,17 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
 }
 
 nsresult
 ServiceWorkerPrivate::SpawnWorkerIfNeeded(WakeUpReason aWhy,
                                           nsIRunnable* aLoadFailedRunnable,
                                           bool* aNewWorkerCreated,
                                           nsILoadGroup* aLoadGroup)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // Defaults to no new worker created, but if there is one, we'll set the value
   // to true at the end of this function.
   if (aNewWorkerCreated) {
     *aNewWorkerCreated = false;
   }
 
   if (mWorkerPrivate) {
@@ -1938,34 +1939,34 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   }
 
   return NS_OK;
 }
 
 void
 ServiceWorkerPrivate::StoreISupports(nsISupports* aSupports)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mWorkerPrivate);
   MOZ_ASSERT(!mSupportsArray.Contains(aSupports));
 
   mSupportsArray.AppendElement(aSupports);
 }
 
 void
 ServiceWorkerPrivate::RemoveISupports(nsISupports* aSupports)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mSupportsArray.RemoveElement(aSupports);
 }
 
 void
 ServiceWorkerPrivate::TerminateWorker()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   mIdleWorkerTimer->Cancel();
   mIdleKeepAliveToken = nullptr;
   if (mWorkerPrivate) {
     if (DOMPrefs::ServiceWorkersTestingEnabled()) {
       nsCOMPtr<nsIObserverService> os = services::GetObserverService();
       if (os) {
         os->NotifyObservers(nullptr, "service-worker-shutdown", nullptr);
@@ -1985,17 +1986,17 @@ ServiceWorkerPrivate::TerminateWorker()
       pendingEvents[i]->Cancel();
     }
   }
 }
 
 void
 ServiceWorkerPrivate::NoteDeadServiceWorkerInfo()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mInfo = nullptr;
   TerminateWorker();
 }
 
 namespace {
 
 class UpdateStateControlRunnable final : public MainThreadWorkerControlRunnable
 {
@@ -2018,17 +2019,17 @@ public:
   }
 };
 
 } // anonymous namespace
 
 void
 ServiceWorkerPrivate::UpdateState(ServiceWorkerState aState)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!mWorkerPrivate) {
     MOZ_DIAGNOSTIC_ASSERT(mPendingFunctionalEvents.IsEmpty());
     return;
   }
 
   RefPtr<WorkerRunnable> r =
     new UpdateStateControlRunnable(mWorkerPrivate, aState);
@@ -2047,17 +2048,17 @@ ServiceWorkerPrivate::UpdateState(Servic
       NS_WARNING("Failed to dispatch pending functional event!");
     }
   }
 }
 
 nsresult
 ServiceWorkerPrivate::GetDebugger(nsIWorkerDebugger** aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aResult);
 
   if (!mDebuggerCount) {
     return NS_OK;
   }
 
   MOZ_ASSERT(mWorkerPrivate);
 
@@ -2065,17 +2066,17 @@ ServiceWorkerPrivate::GetDebugger(nsIWor
   debugger.forget(aResult);
 
   return NS_OK;
 }
 
 nsresult
 ServiceWorkerPrivate::AttachDebugger()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // When the first debugger attaches to a worker, we spawn a worker if needed,
   // and cancel the idle timeout. The idle timeout should not be reset until
   // the last debugger detached from the worker.
   if (!mDebuggerCount) {
     nsresult rv = SpawnWorkerIfNeeded(AttachEvent, nullptr);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -2085,17 +2086,17 @@ ServiceWorkerPrivate::AttachDebugger()
   ++mDebuggerCount;
 
   return NS_OK;
 }
 
 nsresult
 ServiceWorkerPrivate::DetachDebugger()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!mDebuggerCount) {
     return NS_ERROR_UNEXPECTED;
   }
 
   --mDebuggerCount;
 
   // When the last debugger detaches from a worker, we either reset the idle
@@ -2109,17 +2110,17 @@ ServiceWorkerPrivate::DetachDebugger()
   }
 
   return NS_OK;
 }
 
 bool
 ServiceWorkerPrivate::IsIdle() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mTokenCount == 0 || (mTokenCount == 1 && mIdleKeepAliveToken);
 }
 
 namespace {
 
 class ServiceWorkerPrivateTimerCallback final : public nsITimerCallback
                                               , public nsINamed
 {
@@ -2159,17 +2160,17 @@ private:
 
 NS_IMPL_ISUPPORTS(ServiceWorkerPrivateTimerCallback, nsITimerCallback, nsINamed);
 
 } // anonymous namespace
 
 void
 ServiceWorkerPrivate::NoteIdleWorkerCallback(nsITimer* aTimer)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_ASSERT(aTimer == mIdleWorkerTimer, "Invalid timer!");
 
   // Release ServiceWorkerPrivate's token, since the grace period has ended.
   mIdleKeepAliveToken = nullptr;
 
   if (mWorkerPrivate) {
     // If we still have a workerPrivate at this point it means there are pending
@@ -2182,17 +2183,17 @@ ServiceWorkerPrivate::NoteIdleWorkerCall
       mIdleWorkerTimer->InitWithCallback(cb, timeout, nsITimer::TYPE_ONE_SHOT);
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
 }
 
 void
 ServiceWorkerPrivate::TerminateWorkerCallback(nsITimer* aTimer)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_ASSERT(aTimer == this->mIdleWorkerTimer, "Invalid timer!");
 
   // mInfo must be non-null at this point because NoteDeadServiceWorkerInfo
   // which zeroes it calls TerminateWorker which cancels our timer which will
   // ensure we don't get invoked even if the nsTimerEvent is in the event queue.
   ServiceWorkerManager::LocalizeAndReportToAllClients(
     mInfo->Scope(),
@@ -2229,24 +2230,24 @@ ServiceWorkerPrivate::ResetIdleTimeout()
   DebugOnly<nsresult> rv =
     mIdleWorkerTimer->InitWithCallback(cb, timeout, nsITimer::TYPE_ONE_SHOT);
   MOZ_ASSERT(NS_SUCCEEDED(rv));
 }
 
 void
 ServiceWorkerPrivate::AddToken()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   ++mTokenCount;
 }
 
 void
 ServiceWorkerPrivate::ReleaseToken()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_ASSERT(mTokenCount > 0);
   --mTokenCount;
   if (!mTokenCount) {
     TerminateWorker();
   }
 
   // mInfo can be nullptr here if NoteDeadServiceWorkerInfo() is called while
@@ -2257,28 +2258,29 @@ ServiceWorkerPrivate::ReleaseToken()
       swm->WorkerIsIdle(mInfo);
     }
   }
 }
 
 already_AddRefed<KeepAliveToken>
 ServiceWorkerPrivate::CreateEventKeepAliveToken()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mWorkerPrivate);
   MOZ_ASSERT(mIdleKeepAliveToken);
   RefPtr<KeepAliveToken> ref = new KeepAliveToken(this);
   return ref.forget();
 }
 
 void
 ServiceWorkerPrivate::SetHandlesFetch(bool aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (NS_WARN_IF(!mInfo)) {
     return;
   }
 
   mInfo->SetHandlesFetch(aValue);
 }
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerPrivate.h b/dom/serviceworkers/ServiceWorkerPrivate.h
--- a/dom/serviceworkers/ServiceWorkerPrivate.h
+++ b/dom/serviceworkers/ServiceWorkerPrivate.h
@@ -1,40 +1,37 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerprivate_h
-#define mozilla_dom_workers_serviceworkerprivate_h
+#ifndef mozilla_dom_serviceworkerprivate_h
+#define mozilla_dom_serviceworkerprivate_h
 
 #include "nsCOMPtr.h"
 #include "WorkerPrivate.h"
 
 #define NOTIFICATION_CLICK_EVENT_NAME "notificationclick"
 #define NOTIFICATION_CLOSE_EVENT_NAME "notificationclose"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
 
 class ClientInfoAndState;
-
-namespace workers {
-
+class KeepAliveToken;
 class ServiceWorkerInfo;
 class ServiceWorkerRegistrationInfo;
-class KeepAliveToken;
 
 class LifeCycleEventCallback : public Runnable
 {
 public:
-  LifeCycleEventCallback() : Runnable("dom::workers::LifeCycleEventCallback") {}
+  LifeCycleEventCallback() : Runnable("dom::LifeCycleEventCallback") {}
 
   // Called on the worker thread.
   virtual void
   SetResult(bool aResult) = 0;
 };
 
 // ServiceWorkerPrivate is a wrapper for managing the on-demand aspect of
 // service workers. It handles all event dispatching to the worker and ensures
@@ -232,13 +229,12 @@ private:
   // cleared whenever the worker is terminated.
   nsTArray<nsCOMPtr<nsISupports>> mSupportsArray;
 
   // Array of function event worker runnables that are pending due to
   // the worker activating.  Main thread only.
   nsTArray<RefPtr<WorkerRunnable>> mPendingFunctionalEvents;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerprivate_h
+#endif // mozilla_dom_serviceworkerprivate_h
diff --git a/dom/serviceworkers/ServiceWorkerRegisterJob.cpp b/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
--- a/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegisterJob.cpp
@@ -5,33 +5,32 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerRegisterJob.h"
 
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 ServiceWorkerRegisterJob::ServiceWorkerRegisterJob(
     nsIPrincipal* aPrincipal,
     const nsACString& aScope,
     const nsACString& aScriptSpec,
     nsILoadGroup* aLoadGroup,
     ServiceWorkerUpdateViaCache aUpdateViaCache)
   : ServiceWorkerUpdateJob(Type::Register, aPrincipal, aScope, aScriptSpec,
                            aLoadGroup, aUpdateViaCache)
 {
 }
 
 void
 ServiceWorkerRegisterJob::AsyncExecute()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (Canceled() || !swm) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   RefPtr<ServiceWorkerRegistrationInfo> registration =
@@ -72,11 +71,10 @@ ServiceWorkerRegisterJob::AsyncExecute()
   SetRegistration(registration);
   Update();
 }
 
 ServiceWorkerRegisterJob::~ServiceWorkerRegisterJob()
 {
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegisterJob.h b/dom/serviceworkers/ServiceWorkerRegisterJob.h
--- a/dom/serviceworkers/ServiceWorkerRegisterJob.h
+++ b/dom/serviceworkers/ServiceWorkerRegisterJob.h
@@ -1,22 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerregisterjob_h
-#define mozilla_dom_workers_serviceworkerregisterjob_h
+#ifndef mozilla_dom_serviceworkerregisterjob_h
+#define mozilla_dom_serviceworkerregisterjob_h
 
 #include "ServiceWorkerUpdateJob.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 // The register job.  This implements the steps in the spec Register algorithm,
 // but then uses ServiceWorkerUpdateJob to implement the Update and Install
 // spec algorithms.
 class ServiceWorkerRegisterJob final : public ServiceWorkerUpdateJob
 {
 public:
   ServiceWorkerRegisterJob(nsIPrincipal* aPrincipal,
@@ -29,13 +28,12 @@ private:
   // Implement the Register algorithm steps and then call the parent class
   // Update() to complete the job execution.
   virtual void
   AsyncExecute() override;
 
   virtual ~ServiceWorkerRegisterJob();
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerregisterjob_h
+#endif // mozilla_dom_serviceworkerregisterjob_h
diff --git a/dom/serviceworkers/ServiceWorkerRegistrar.h b/dom/serviceworkers/ServiceWorkerRegistrar.h
--- a/dom/serviceworkers/ServiceWorkerRegistrar.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrar.h
@@ -1,16 +1,16 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_ServiceWorkerRegistrar_h
-#define mozilla_dom_workers_ServiceWorkerRegistrar_h
+#ifndef mozilla_dom_ServiceWorkerRegistrar_h
+#define mozilla_dom_ServiceWorkerRegistrar_h
 
 #include "mozilla/Monitor.h"
 #include "mozilla/Telemetry.h"
 #include "nsClassHashtable.h"
 #include "nsIAsyncShutdown.h"
 #include "nsIObserver.h"
 #include "nsCOMPtr.h"
 #include "nsString.h"
@@ -97,9 +97,9 @@ protected:
   // PBackground thread only
   bool mShuttingDown;
   uint32_t mRunnableCounter;
 };
 
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_ServiceWorkerRegistrar_h
+#endif // mozilla_dom_ServiceWorkerRegistrar_h
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.cpp b/dom/serviceworkers/ServiceWorkerRegistration.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistration.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistration.cpp
@@ -182,17 +182,17 @@ NS_IMPL_CYCLE_COLLECTION_INHERITED(Servi
                                    mPushManager,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 
 ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
                                                                          const nsAString& aScope)
   : ServiceWorkerRegistration(aWindow, aScope)
   , mListeningForEvents(false)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aWindow);
   StartListeningForEvents();
 }
 
 ServiceWorkerRegistrationMainThread::~ServiceWorkerRegistrationMainThread()
 {
   StopListeningForEvents();
   MOZ_ASSERT(!mListeningForEvents);
@@ -242,68 +242,68 @@ ServiceWorkerRegistrationMainThread::Get
   return ref.forget();
 }
 
 // XXXnsm, maybe this can be optimized to only add when a event handler is
 // registered.
 void
 ServiceWorkerRegistrationMainThread::StartListeningForEvents()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!mListeningForEvents);
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (swm) {
     swm->AddRegistrationEventListener(mScope, this);
     mListeningForEvents = true;
   }
 }
 
 void
 ServiceWorkerRegistrationMainThread::StopListeningForEvents()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (!mListeningForEvents) {
     return;
   }
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (swm) {
     swm->RemoveRegistrationEventListener(mScope, this);
   }
   mListeningForEvents = false;
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerRegistrationMainThread::GetInstalling()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (!mInstallingWorker) {
     mInstallingWorker = GetWorkerReference(WhichServiceWorker::INSTALLING_WORKER);
   }
 
   RefPtr<ServiceWorker> ret = mInstallingWorker;
   return ret.forget();
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerRegistrationMainThread::GetWaiting()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (!mWaitingWorker) {
     mWaitingWorker = GetWorkerReference(WhichServiceWorker::WAITING_WORKER);
   }
 
   RefPtr<ServiceWorker> ret = mWaitingWorker;
   return ret.forget();
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerRegistrationMainThread::GetActive()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (!mActiveWorker) {
     mActiveWorker = GetWorkerReference(WhichServiceWorker::ACTIVE_WORKER);
   }
 
   RefPtr<ServiceWorker> ret = mActiveWorker;
   return ret.forget();
 }
 
@@ -311,17 +311,17 @@ void
 ServiceWorkerRegistrationMainThread::UpdateFound()
 {
   DispatchTrustedEvent(NS_LITERAL_STRING("updatefound"));
 }
 
 void
 ServiceWorkerRegistrationMainThread::TransitionWorker(WhichServiceWorker aWhichOne)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // We assert the worker's previous state because the 'statechange'
   // event is dispatched in a queued runnable.
   if (aWhichOne == WhichServiceWorker::INSTALLING_WORKER) {
     MOZ_ASSERT_IF(mInstallingWorker, mInstallingWorker->State() == ServiceWorkerState::Installing);
     mWaitingWorker = mInstallingWorker.forget();
   } else if (aWhichOne == WhichServiceWorker::WAITING_WORKER) {
     MOZ_ASSERT_IF(mWaitingWorker, mWaitingWorker->State() == ServiceWorkerState::Installed);
@@ -329,17 +329,17 @@ ServiceWorkerRegistrationMainThread::Tra
   } else {
     MOZ_ASSERT_UNREACHABLE("Invalid transition!");
   }
 }
 
 void
 ServiceWorkerRegistrationMainThread::InvalidateWorkers(WhichServiceWorker aWhichOnes)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (aWhichOnes & WhichServiceWorker::INSTALLING_WORKER) {
     mInstallingWorker = nullptr;
   }
 
   if (aWhichOnes & WhichServiceWorker::WAITING_WORKER) {
     mWaitingWorker = nullptr;
   }
 
@@ -362,17 +362,17 @@ ServiceWorkerRegistrationMainThread::Reg
 
 namespace {
 
 void
 UpdateInternal(nsIPrincipal* aPrincipal,
                const nsAString& aScope,
                ServiceWorkerUpdateFinishCallback* aCallback)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(aCallback);
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // browser shutdown
     return;
   }
@@ -387,17 +387,17 @@ class MainThreadUpdateCallback final : p
   ~MainThreadUpdateCallback()
   { }
 
 public:
   explicit MainThreadUpdateCallback(nsPIDOMWindowInner* aWindow,
                                     Promise* aPromise)
     : mPromise(aWindow, aPromise)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   UpdateSucceeded(ServiceWorkerRegistrationInfo* aRegistration) override
   {
     if (RefPtr<Promise> promise = mPromise.Get()) {
       promise->MaybeResolveWithUndefined();
     }
@@ -459,17 +459,17 @@ class WorkerThreadUpdateCallback final :
   ~WorkerThreadUpdateCallback()
   {
   }
 
 public:
   explicit WorkerThreadUpdateCallback(PromiseWorkerProxy* aPromiseProxy)
     : mPromiseProxy(aPromiseProxy)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   UpdateSucceeded(ServiceWorkerRegistrationInfo* aRegistration) override
   {
     ErrorResult rv(NS_OK);
     Finish(rv);
   }
@@ -507,17 +507,17 @@ public:
     : Runnable("dom::UpdateRunnable")
     , mPromiseProxy(aPromiseProxy)
     , mScope(aScope)
   {}
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     ErrorResult result;
 
     nsCOMPtr<nsIPrincipal> principal;
     // UpdateInternal may try to reject the promise synchronously leading
     // to a deadlock.
     {
       MutexAutoLock lock(mPromiseProxy->Lock());
       if (mPromiseProxy->CleanedUp()) {
@@ -554,27 +554,27 @@ public:
     : mPromise(aWindow, aPromise)
   {
     MOZ_ASSERT(aPromise);
   }
 
   NS_IMETHOD
   UnregisterSucceeded(bool aState) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     if (RefPtr<Promise> promise = mPromise.Get()) {
       promise->MaybeResolve(aState);
     }
     return NS_OK;
   }
 
   NS_IMETHOD
   UnregisterFailed() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     if (RefPtr<Promise> promise = mPromise.Get()) {
       promise->MaybeReject(NS_ERROR_DOM_SECURITY_ERR);
     }
     return NS_OK;
   }
 
 private:
@@ -590,17 +590,17 @@ class FulfillUnregisterPromiseRunnable f
   Maybe<bool> mState;
 public:
   FulfillUnregisterPromiseRunnable(PromiseWorkerProxy* aProxy,
                                    const Maybe<bool>& aState)
     : WorkerRunnable(aProxy->GetWorkerPrivate())
     , mPromiseWorkerProxy(aProxy)
     , mState(aState)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mPromiseWorkerProxy);
   }
 
   bool
   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
   {
     RefPtr<Promise> promise = mPromiseWorkerProxy->WorkerPromise();
     if (mState.isSome()) {
@@ -624,37 +624,37 @@ public:
     : mPromiseWorkerProxy(aProxy)
   {
     MOZ_ASSERT(aProxy);
   }
 
   NS_IMETHOD
   UnregisterSucceeded(bool aState) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     Finish(Some(aState));
     return NS_OK;
   }
 
   NS_IMETHOD
   UnregisterFailed() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     Finish(Nothing());
     return NS_OK;
   }
 
 private:
   ~WorkerUnregisterCallback()
   {}
 
   void
   Finish(const Maybe<bool>& aState)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     if (!mPromiseWorkerProxy) {
       return;
     }
 
     RefPtr<PromiseWorkerProxy> proxy = mPromiseWorkerProxy.forget();
     MutexAutoLock lock(proxy->Lock());
     if (proxy->CleanedUp()) {
       return;
@@ -685,17 +685,17 @@ public:
     , mScope(aScope)
   {
     MOZ_ASSERT(aProxy);
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     // XXXnsm: There is a rare chance of this failing if the worker gets
     // destroyed. In that case, unregister() called from a SW is no longer
     // guaranteed to run. We should fix this by having a main thread proxy
     // maintain a strongref to ServiceWorkerRegistrationInfo and use its
     // principal. Can that be trusted?
     nsCOMPtr<nsIPrincipal> principal;
     {
@@ -722,17 +722,17 @@ public:
     return NS_OK;
   }
 };
 } // namespace
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::Update(ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIGlobalObject> go = do_QueryInterface(GetOwner());
   if (!go) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   RefPtr<Promise> promise = Promise::Create(go, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
@@ -747,17 +747,17 @@ ServiceWorkerRegistrationMainThread::Upd
   UpdateInternal(doc->NodePrincipal(), mScope, cb);
 
   return promise.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::Unregister(ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIGlobalObject> go = do_QueryInterface(GetOwner());
   if (!go) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   // Although the spec says that the same-origin checks should also be done
   // asynchronously, we do them in sync because the Promise created by the
@@ -814,17 +814,17 @@ ServiceWorkerRegistrationMainThread::Unr
 
 // Notification API extension.
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::ShowNotification(JSContext* aCx,
                                                       const nsAString& aTitle,
                                                       const NotificationOptions& aOptions,
                                                       ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsPIDOMWindowInner> window = GetOwner();
   if (NS_WARN_IF(!window)) {
     aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   nsCOMPtr<nsIDocument> doc = window->GetExtantDoc();
   if (NS_WARN_IF(!doc)) {
@@ -847,30 +847,30 @@ ServiceWorkerRegistrationMainThread::Sho
   }
 
   return p.forget();
 }
 
 already_AddRefed<Promise>
 ServiceWorkerRegistrationMainThread::GetNotifications(const GetNotificationOptions& aOptions, ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsPIDOMWindowInner> window = GetOwner();
   if (NS_WARN_IF(!window)) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
   return Notification::Get(window, aOptions, mScope, aRv);
 }
 
 already_AddRefed<PushManager>
 ServiceWorkerRegistrationMainThread::GetPushManager(JSContext* aCx,
                                                     ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!mPushManager) {
     nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
 
     if (!globalObject) {
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
@@ -984,31 +984,31 @@ public:
     MOZ_ASSERT(mRegistration);
     // Copy scope so we can return it on the main thread.
     mRegistration->GetScope(mScope);
   }
 
   void
   StartListeningForEvents()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(!mListeningForEvents);
     MOZ_ASSERT(mWorkerPrivate);
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
     if (swm) {
       // FIXME(nsm): Maybe the function shouldn't take an explicit scope.
       swm->AddRegistrationEventListener(mScope, this);
       mListeningForEvents = true;
     }
   }
 
   void
   StopListeningForEvents()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     MOZ_ASSERT(mListeningForEvents);
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
     // We aren't going to need this anymore and we shouldn't hold on since the
     // worker will go away soon.
     mWorkerPrivate = nullptr;
@@ -1022,31 +1022,31 @@ public:
 
   // ServiceWorkerRegistrationListener
   void
   UpdateFound() override;
 
   void
   TransitionWorker(WhichServiceWorker aWhichOne) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     NS_WARNING("FIXME: Not implemented!");
   }
 
   void
   InvalidateWorkers(WhichServiceWorker aWhichOnes) override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     // FIXME(nsm);
   }
 
   void
   RegistrationRemoved() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   GetScope(nsAString& aScope) const override
   {
     aScope = mScope;
   }
 
@@ -1106,17 +1106,17 @@ ServiceWorkerRegistrationWorkerThread::S
 }
 
 ServiceWorkerRegistrationWorkerThread::~ServiceWorkerRegistrationWorkerThread()
 {
   ReleaseListener();
   MOZ_ASSERT(!mListener);
 }
 
-already_AddRefed<workers::ServiceWorker>
+already_AddRefed<ServiceWorker>
 ServiceWorkerRegistrationWorkerThread::GetInstalling()
 {
   // FIXME(nsm): Will be implemented after Bug 1113522.
   return nullptr;
 }
 
 already_AddRefed<ServiceWorker>
 ServiceWorkerRegistrationWorkerThread::GetWaiting()
@@ -1279,17 +1279,17 @@ public:
     }
     return true;
   }
 };
 
 void
 WorkerListener::UpdateFound()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   if (mWorkerPrivate) {
     RefPtr<FireUpdateFoundRunnable> r =
       new FireUpdateFoundRunnable(mWorkerPrivate, this);
     Unused << NS_WARN_IF(!r->Dispatch());
   }
 }
 
 // Notification API extension.
@@ -1362,17 +1362,17 @@ ServiceWorkerRegistration::CreateForMain
 
   RefPtr<ServiceWorkerRegistration> registration =
     new ServiceWorkerRegistrationMainThread(aWindow, aScope);
 
   return registration.forget();
 }
 
 /* static */ already_AddRefed<ServiceWorkerRegistration>
-ServiceWorkerRegistration::CreateForWorker(workers::WorkerPrivate* aWorkerPrivate,
+ServiceWorkerRegistration::CreateForWorker(WorkerPrivate* aWorkerPrivate,
                                            const nsAString& aScope)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   RefPtr<ServiceWorkerRegistration> registration =
     new ServiceWorkerRegistrationWorkerThread(aWorkerPrivate, aScope);
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistration.h b/dom/serviceworkers/ServiceWorkerRegistration.h
--- a/dom/serviceworkers/ServiceWorkerRegistration.h
+++ b/dom/serviceworkers/ServiceWorkerRegistration.h
@@ -21,21 +21,16 @@ class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 class PushManager;
 class WorkerListener;
 
-namespace workers {
-class ServiceWorker;
-class WorkerPrivate;
-} // namespace workers
-
 // Used by ServiceWorkerManager to notify ServiceWorkerRegistrations of
 // updatefound event and invalidating ServiceWorker instances.
 class ServiceWorkerRegistrationListener
 {
 public:
   NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
 
   virtual void
@@ -67,23 +62,23 @@ public:
 
   static already_AddRefed<ServiceWorkerRegistration>
   CreateForWorker(workers::WorkerPrivate* aWorkerPrivate,
                   const nsAString& aScope);
 
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
-  virtual already_AddRefed<workers::ServiceWorker>
+  virtual already_AddRefed<ServiceWorker>
   GetInstalling() = 0;
 
-  virtual already_AddRefed<workers::ServiceWorker>
+  virtual already_AddRefed<ServiceWorker>
   GetWaiting() = 0;
 
-  virtual already_AddRefed<workers::ServiceWorker>
+  virtual already_AddRefed<ServiceWorker>
   GetActive() = 0;
 
   virtual void
   GetScope(nsAString& aScope) const = 0;
 
   virtual ServiceWorkerUpdateViaCache
   GetUpdateViaCache(ErrorResult& aRv) const = 0;
 
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -4,43 +4,44 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerRegistrationInfo.h"
 
 #include "ServiceWorkerManager.h"
 #include "ServiceWorkerPrivate.h"
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 namespace {
 
 class ContinueActivateRunnable final : public LifeCycleEventCallback
 {
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> mRegistration;
   bool mSuccess;
 
 public:
   explicit ContinueActivateRunnable(const nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo>& aRegistration)
     : mRegistration(aRegistration)
     , mSuccess(false)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   SetResult(bool aResult) override
   {
     mSuccess = aResult;
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mRegistration->FinishActivate(mSuccess);
     mRegistration = nullptr;
     return NS_OK;
   }
 };
 
 } // anonymous namespace
 
@@ -100,33 +101,33 @@ ServiceWorkerRegistrationInfo::~ServiceW
   MOZ_DIAGNOSTIC_ASSERT(!IsControllingClients());
 }
 
 NS_IMPL_ISUPPORTS(ServiceWorkerRegistrationInfo, nsIServiceWorkerRegistrationInfo)
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetPrincipal(nsIPrincipal** aPrincipal)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   NS_ADDREF(*aPrincipal = mPrincipal);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetScope(nsAString& aScope)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   CopyUTF8toUTF16(mScope, aScope);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetScriptSpec(nsAString& aScriptSpec)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   RefPtr<ServiceWorkerInfo> newest = Newest();
   if (newest) {
     CopyUTF8toUTF16(newest->ScriptSpec(), aScriptSpec);
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -134,95 +135,95 @@ ServiceWorkerRegistrationInfo::GetUpdate
 {
     *aUpdateViaCache = static_cast<uint16_t>(GetUpdateViaCache());
     return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetLastUpdateTime(PRTime* _retval)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(_retval);
   *_retval = mLastUpdateTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetInstallingWorker(nsIServiceWorkerInfo **aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mInstallingWorker);
   info.forget(aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetWaitingWorker(nsIServiceWorkerInfo **aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mWaitingWorker);
   info.forget(aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetActiveWorker(nsIServiceWorkerInfo **aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   nsCOMPtr<nsIServiceWorkerInfo> info = do_QueryInterface(mActiveWorker);
   info.forget(aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::GetWorkerByID(uint64_t aID, nsIServiceWorkerInfo **aResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aResult);
 
   RefPtr<ServiceWorkerInfo> info = GetServiceWorkerInfoById(aID);
   // It is ok to return null for a missing service worker info.
   info.forget(aResult);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::AddListener(
                             nsIServiceWorkerRegistrationInfoListener *aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!aListener || mListeners.Contains(aListener)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   mListeners.AppendElement(aListener);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 ServiceWorkerRegistrationInfo::RemoveListener(
                             nsIServiceWorkerRegistrationInfoListener *aListener)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!aListener || !mListeners.Contains(aListener)) {
     return NS_ERROR_INVALID_ARG;
   }
 
   mListeners.RemoveElement(aListener);
 
   return NS_OK;
 }
 
 already_AddRefed<ServiceWorkerInfo>
 ServiceWorkerRegistrationInfo::GetServiceWorkerInfoById(uint64_t aId)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerInfo> serviceWorker;
   if (mEvaluatingWorker && mEvaluatingWorker->ID() == aId) {
     serviceWorker = mEvaluatingWorker;
   } else if (mInstallingWorker && mInstallingWorker->ID() == aId) {
     serviceWorker = mInstallingWorker;
   } else if (mWaitingWorker && mWaitingWorker->ID() == aId) {
     serviceWorker = mWaitingWorker;
@@ -243,17 +244,17 @@ ServiceWorkerRegistrationInfo::TryToActi
 }
 
 /*
  * TryToActivate should not be called directly, use TryToActivateAsync instead.
  */
 void
 ServiceWorkerRegistrationInfo::TryToActivate()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   bool controlling = IsControllingClients();
   bool skipWaiting = mWaitingWorker && mWaitingWorker->SkipWaitingFlag();
   bool idle = IsIdle();
   if (idle && (!controlling || skipWaiting)) {
     Activate();
   }
 }
 
@@ -274,17 +275,17 @@ ServiceWorkerRegistrationInfo::Activate(
 
   // FIXME(nsm): Unlink appcache if there is one.
 
   // "Queue a task to fire a simple event named controllerchange..."
   MOZ_DIAGNOSTIC_ASSERT(mActiveWorker);
   swm->UpdateClientControllers(this);
 
   nsCOMPtr<nsIRunnable> failRunnable = NewRunnableMethod<bool>(
-    "dom::workers::ServiceWorkerRegistrationInfo::FinishActivate",
+    "dom::ServiceWorkerRegistrationInfo::FinishActivate",
     this,
     &ServiceWorkerRegistrationInfo::FinishActivate,
     false /* success */);
 
   nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> handle(
     new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(
       "ServiceWorkerRegistrationInfoProxy", this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueActivateRunnable(handle);
@@ -318,28 +319,28 @@ ServiceWorkerRegistrationInfo::FinishAct
     return;
   }
   swm->StoreRegistration(mPrincipal, this);
 }
 
 void
 ServiceWorkerRegistrationInfo::RefreshLastUpdateCheckTime()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   mLastUpdateTime =
     mCreationTime + static_cast<PRTime>((TimeStamp::Now() -
                                          mCreationTimeStamp).ToMicroseconds());
   NotifyChromeRegistrationListeners();
 }
 
 bool
 ServiceWorkerRegistrationInfo::IsLastUpdateCheckTimeOverOneDay() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // For testing.
   if (Preferences::GetBool("dom.serviceWorkers.testUpdateOverOneDay")) {
     return true;
   }
 
   const int64_t kSecondsPerDay = 86400;
   const int64_t nowMicros =
@@ -354,17 +355,17 @@ ServiceWorkerRegistrationInfo::IsLastUpd
   }
   return false;
 }
 
 void
 ServiceWorkerRegistrationInfo::AsyncUpdateRegistrationStateProperties(WhichServiceWorker aWorker,
                                                                       TransitionType aTransition)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // browser shutdown started during this async step
     return;
   }
 
   if (aTransition == Invalidate) {
     swm->InvalidateServiceWorkerRegistrationWorker(this, aWorker);
@@ -377,21 +378,21 @@ ServiceWorkerRegistrationInfo::AsyncUpda
     }
   }
 }
 
 void
 ServiceWorkerRegistrationInfo::UpdateRegistrationStateProperties(WhichServiceWorker aWorker,
                                                                  TransitionType aTransition)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIRunnable> runnable =
     NewRunnableMethod<WhichServiceWorker, TransitionType>(
-      "dom::workers::ServiceWorkerRegistrationInfo::"
+      "dom::ServiceWorkerRegistrationInfo::"
       "AsyncUpdateRegistrationStateProperties",
       this,
       &ServiceWorkerRegistrationInfo::AsyncUpdateRegistrationStateProperties,
       aWorker,
       aTransition);
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable.forget()));
 }
 
@@ -402,17 +403,17 @@ ServiceWorkerRegistrationInfo::NotifyChr
   for (size_t index = 0; index < listeners.Length(); ++index) {
     listeners[index]->OnChange();
   }
 }
 
 void
 ServiceWorkerRegistrationInfo::MaybeScheduleTimeCheckAndUpdate()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // shutting down, do nothing
     return;
   }
 
   if (mUpdateState == NoUpdate) {
@@ -420,68 +421,68 @@ ServiceWorkerRegistrationInfo::MaybeSche
   }
 
   swm->ScheduleUpdateTimer(mPrincipal, mScope);
 }
 
 void
 ServiceWorkerRegistrationInfo::MaybeScheduleUpdate()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
     // shutting down, do nothing
     return;
   }
 
   mUpdateState = NeedUpdate;
 
   swm->ScheduleUpdateTimer(mPrincipal, mScope);
 }
 
 bool
 ServiceWorkerRegistrationInfo::CheckAndClearIfUpdateNeeded()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   bool result = mUpdateState == NeedUpdate ||
                (mUpdateState == NeedTimeCheckAndUpdate &&
                 IsLastUpdateCheckTimeOverOneDay());
 
   mUpdateState = NoUpdate;
 
   return result;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetEvaluating() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mEvaluatingWorker;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetInstalling() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mInstallingWorker;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetWaiting() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mWaitingWorker;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetActive() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mActiveWorker;
 }
 
 ServiceWorkerInfo*
 ServiceWorkerRegistrationInfo::GetByID(uint64_t aID) const
 {
   if (mActiveWorker && mActiveWorker->ID() == aID) {
     return mActiveWorker;
@@ -496,45 +497,45 @@ ServiceWorkerRegistrationInfo::GetByID(u
     return mEvaluatingWorker;
   }
   return nullptr;
 }
 
 void
 ServiceWorkerRegistrationInfo::SetEvaluating(ServiceWorkerInfo* aServiceWorker)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aServiceWorker);
   MOZ_ASSERT(!mEvaluatingWorker);
   MOZ_ASSERT(!mInstallingWorker);
   MOZ_ASSERT(mWaitingWorker != aServiceWorker);
   MOZ_ASSERT(mActiveWorker != aServiceWorker);
 
   mEvaluatingWorker = aServiceWorker;
 }
 
 void
 ServiceWorkerRegistrationInfo::ClearEvaluating()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!mEvaluatingWorker) {
     return;
   }
 
   mEvaluatingWorker->UpdateState(ServiceWorkerState::Redundant);
   // We don't update the redundant time for the sw here, since we've not expose
   // evalutingWorker yet.
   mEvaluatingWorker = nullptr;
 }
 
 void
 ServiceWorkerRegistrationInfo::ClearInstalling()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (!mInstallingWorker) {
     return;
   }
 
   UpdateRegistrationStateProperties(WhichServiceWorker::INSTALLING_WORKER,
                                     Invalidate);
   mInstallingWorker->UpdateState(ServiceWorkerState::Redundant);
@@ -542,29 +543,29 @@ ServiceWorkerRegistrationInfo::ClearInst
   mInstallingWorker = nullptr;
 
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionEvaluatingToInstalling()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mEvaluatingWorker);
   MOZ_ASSERT(!mInstallingWorker);
 
   mInstallingWorker = mEvaluatingWorker.forget();
   mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionInstallingToWaiting()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mInstallingWorker);
 
   if (mWaitingWorker) {
     MOZ_ASSERT(mInstallingWorker->CacheName() != mWaitingWorker->CacheName());
     mWaitingWorker->UpdateState(ServiceWorkerState::Redundant);
     mWaitingWorker->UpdateRedundantTime();
   }
 
@@ -581,17 +582,17 @@ ServiceWorkerRegistrationInfo::Transitio
     return;
   }
   swm->StoreRegistration(mPrincipal, this);
 }
 
 void
 ServiceWorkerRegistrationInfo::SetActive(ServiceWorkerInfo* aServiceWorker)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aServiceWorker);
 
   // TODO: Assert installing, waiting, and active are nullptr once the SWM
   //       moves to the parent process.  After that happens this code will
   //       only run for browser initialization and not for cross-process
   //       overrides.
   MOZ_ASSERT(mInstallingWorker != aServiceWorker);
   MOZ_ASSERT(mWaitingWorker != aServiceWorker);
@@ -612,17 +613,17 @@ ServiceWorkerRegistrationInfo::SetActive
   // registrar.
   UpdateRegistrationStateProperties(WhichServiceWorker::ACTIVE_WORKER, Invalidate);
   NotifyChromeRegistrationListeners();
 }
 
 void
 ServiceWorkerRegistrationInfo::TransitionWaitingToActive()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mWaitingWorker);
 
   if (mActiveWorker) {
     MOZ_ASSERT(mWaitingWorker->CacheName() != mActiveWorker->CacheName());
     mActiveWorker->UpdateState(ServiceWorkerState::Redundant);
     mActiveWorker->UpdateRedundantTime();
   }
 
@@ -665,9 +666,10 @@ ServiceWorkerRegistrationInfo::SetLastUp
 {
   if (aTime == 0) {
     return;
   }
 
   mLastUpdateTime = aTime;
 }
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.h
@@ -1,25 +1,24 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerregistrationinfo_h
-#define mozilla_dom_workers_serviceworkerregistrationinfo_h
+#ifndef mozilla_dom_serviceworkerregistrationinfo_h
+#define mozilla_dom_serviceworkerregistrationinfo_h
 
-#include "mozilla/dom/workers/ServiceWorkerInfo.h"
+#include "mozilla/dom/ServiceWorkerInfo.h"
 #include "mozilla/dom/ServiceWorkerCommon.h"
 #include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
 #include "nsProxyRelease.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerRegistrationInfo final
   : public nsIServiceWorkerRegistrationInfo
 {
   uint32_t mControlledClientsCounter;
 
   enum
   {
@@ -217,13 +216,12 @@ private:
   // Used by devtools to track changes to the properties of *nsIServiceWorkerRegistrationInfo*.
   // Note, this doesn't necessarily need to be in sync with the DOM registration objects, but
   // it does need to be called in the same task that changed |mInstallingWorker|,
   // |mWaitingWorker| or |mActiveWorker|.
   void
   NotifyChromeRegistrationListeners();
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerregistrationinfo_h
+#endif // mozilla_dom_serviceworkerregistrationinfo_h
diff --git a/dom/serviceworkers/ServiceWorkerScriptCache.cpp b/dom/serviceworkers/ServiceWorkerScriptCache.cpp
--- a/dom/serviceworkers/ServiceWorkerScriptCache.cpp
+++ b/dom/serviceworkers/ServiceWorkerScriptCache.cpp
@@ -29,32 +29,33 @@
 #include "ServiceWorkerManager.h"
 #include "Workers.h"
 #include "nsStringStream.h"
 
 using mozilla::dom::cache::Cache;
 using mozilla::dom::cache::CacheStorage;
 using mozilla::ipc::PrincipalInfo;
 
-BEGIN_WORKERS_NAMESPACE
+namespace mozilla {
+namespace dom {
 
 namespace serviceWorkerScriptCache {
 
 namespace {
 
 // XXX A sandbox nsIGlobalObject does not preserve its reflector, so |aSandbox|
 // must be kept alive as long as the CacheStorage if you want to ensure that
 // the CacheStorage will continue to work. Failures will manifest as errors
 // like "JavaScript error: , line 0: TypeError: The expression cannot be
 // converted to return the specified type."
 already_AddRefed<CacheStorage>
 CreateCacheStorage(JSContext* aCx, nsIPrincipal* aPrincipal, ErrorResult& aRv,
                    JS::MutableHandle<JSObject*> aSandbox)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   nsIXPConnect* xpc = nsContentUtils::XPConnect();
   MOZ_ASSERT(xpc, "This should never be null!");
   aRv = xpc->CreateSandbox(aCx, aPrincipal, aSandbox.address());
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
@@ -104,17 +105,17 @@ public:
     , mLoadFlags(nsIChannel::LOAD_BYPASS_SERVICE_WORKER)
     , mState(WaitingForInitialization)
     , mNetworkResult(NS_OK)
     , mCacheResult(NS_OK)
     , mIsMainScript(aIsMainScript)
     , mIsFromCache(false)
   {
     MOZ_ASSERT(aManager);
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal,
              const nsAString& aURL,
              nsILoadGroup* aLoadGroup,
              Cache* const aCache);
 
@@ -124,23 +125,23 @@ public:
   void
   NetworkFinish(nsresult aRv);
 
   void
   CacheFinish(nsresult aRv);
 
   const nsString& URL() const
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     return mURL;
   }
 
   const nsString& Buffer() const
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     return mBuffer;
   }
 
   const ChannelInfo&
   GetChannelInfo() const
   {
     return mChannelInfo;
   }
@@ -168,17 +169,17 @@ public:
   URLList() const
   {
     return mURLList;
   }
 
 private:
   ~CompareNetwork()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(!mCC);
   }
 
   void
   Finish();
 
   nsresult
   SetPrincipalInfo(nsIChannel* aChannel);
@@ -226,17 +227,17 @@ public:
   NS_DECL_NSISTREAMLOADEROBSERVER
 
   explicit CompareCache(CompareNetwork* aCN)
     : mCN(aCN)
     , mState(WaitingForInitialization)
     , mInCache(false)
   {
     MOZ_ASSERT(aCN);
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   nsresult
   Initialize(Cache* const aCache, const nsAString& aURL);
 
   void
   Finish(nsresult aStatus, bool aInCache);
 
@@ -246,30 +247,30 @@ public:
   virtual void
   ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   virtual void
   RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   const nsString& Buffer() const
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     return mBuffer;
   }
 
   bool
   InCache()
   {
     return mInCache;
   }
 
 private:
   ~CompareCache()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   ManageValueResult(JSContext* aCx, JS::Handle<JS::Value> aValue);
 
   RefPtr<CompareNetwork> mCN;
   nsCOMPtr<nsIInputStreamPump> mPump;
 
@@ -296,46 +297,46 @@ public:
                           CompareCallback* aCallback)
     : mRegistration(aRegistration)
     , mCallback(aCallback)
     , mLoadFlags(nsIChannel::LOAD_BYPASS_SERVICE_WORKER)
     , mState(WaitingForInitialization)
     , mPendingCount(0)
     , mAreScriptsEqual(true)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aRegistration);
   }
 
   nsresult
   Initialize(nsIPrincipal* aPrincipal, const nsAString& aURL,
              const nsAString& aCacheName, nsILoadGroup* aLoadGroup);
 
   void
   ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   void
   RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override;
 
   CacheStorage*
   CacheStorage_()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mCacheStorage);
     return mCacheStorage;
   }
 
   void
   ComparisonFinished(nsresult aStatus,
                      bool aIsMainScript,
                      bool aIsEqual,
                      const nsACString& aMaxScope,
                      nsLoadFlags aLoadFlags)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     if (mState == Finished) {
       return;
     }
 
     MOZ_DIAGNOSTIC_ASSERT(mState == WaitingForScriptOrComparisonResult);
 
     if (NS_WARN_IF(NS_FAILED(aStatus))) {
       Fail(aStatus);
@@ -368,32 +369,32 @@ public:
 
     // Write to Cache so ScriptLoader reads succeed.
     WriteNetworkBufferToNewCache();
   }
 
 private:
   ~CompareManager()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mCNList.Length() == 0);
   }
 
   void
   Fail(nsresult aStatus);
 
   void
   Cleanup();
 
   nsresult
   FetchScript(const nsAString& aURL,
               bool aIsMainScript,
               Cache* const aCache = nullptr)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
 
     MOZ_DIAGNOSTIC_ASSERT(mState == WaitingForInitialization ||
                           mState == WaitingForScriptOrComparisonResult);
 
     RefPtr<CompareNetwork> cn = new CompareNetwork(this,
                                                    mRegistration,
                                                    aIsMainScript);
     mCNList.AppendElement(cn);
@@ -555,17 +556,17 @@ private:
 
     mState = WaitingForPut;
     guard.release();
   }
 
   void
   WriteNetworkBufferToNewCache()
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(mCNList.Length() != 0);
     MOZ_ASSERT(mCacheStorage);
     MOZ_ASSERT(mNewCacheName.IsEmpty());
 
     ErrorResult result;
     result = serviceWorkerScriptCache::GenerateCacheName(mNewCacheName);
     if (NS_WARN_IF(result.Failed())) {
       MOZ_ASSERT(!result.IsErrorWithMessage());
@@ -582,17 +583,17 @@ private:
 
     mState = WaitingForOpen;
     cacheOpenPromise->AppendNativeHandler(this);
   }
 
   nsresult
   WriteToCache(JSContext* aCx, Cache* aCache, CompareNetwork* aCN)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     MOZ_ASSERT(aCache);
     MOZ_ASSERT(aCN);
     MOZ_DIAGNOSTIC_ASSERT(mState == WaitingForOpen);
 
     // We don't have to save any information from a failed CompareNetwork.
     if (!aCN->Succeeded()) {
       return NS_OK;
     }
@@ -681,17 +682,17 @@ NS_IMPL_ISUPPORTS0(CompareManager)
 
 nsresult
 CompareNetwork::Initialize(nsIPrincipal* aPrincipal,
                            const nsAString& aURL,
                            nsILoadGroup* aLoadGroup,
                            Cache* const aCache)
 {
   MOZ_ASSERT(aPrincipal);
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   nsCOMPtr<nsIURI> uri;
   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, nullptr, nullptr);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   mURL = aURL;
@@ -846,17 +847,17 @@ CompareNetwork::CacheFinish(nsresult aRv
     Finish();
     return;
   }
 }
 
 void
 CompareNetwork::Abort()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState != Finished) {
     mState = Finished;
 
     MOZ_ASSERT(mChannel);
     mChannel->Cancel(NS_BINDING_ABORTED);
     mChannel = nullptr;
 
@@ -865,17 +866,17 @@ CompareNetwork::Abort()
       mCC = nullptr;
     }
   }
 }
 
 NS_IMETHODIMP
 CompareNetwork::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState == Finished) {
     return NS_OK;
   }
 
   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
   MOZ_ASSERT_IF(mIsMainScript, channel == mChannel);
   mChannel = channel;
@@ -931,17 +932,17 @@ CompareNetwork::OnStopRequest(nsIRequest
   return NS_OK;
 }
 
 NS_IMETHODIMP
 CompareNetwork::OnStreamComplete(nsIStreamLoader* aLoader, nsISupports* aContext,
                                  nsresult aStatus, uint32_t aLen,
                                  const uint8_t* aString)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState == Finished) {
     return NS_OK;
   }
 
   nsresult rv = NS_ERROR_FAILURE;
   auto guard = MakeScopeExit([&] {
     NetworkFinish(rv);
@@ -1050,17 +1051,17 @@ CompareNetwork::OnStreamComplete(nsIStre
 
   rv = NS_OK;
   return NS_OK;
 }
 
 nsresult
 CompareCache::Initialize(Cache* const aCache, const nsAString& aURL)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aCache);
   MOZ_DIAGNOSTIC_ASSERT(mState == WaitingForInitialization);
 
   // This JSContext will not end up executing JS code because here there are
   // no ReadableStreams involved.
   AutoJSAPI jsapi;
   jsapi.Init();
 
@@ -1090,34 +1091,34 @@ CompareCache::Finish(nsresult aStatus, b
     mInCache = aInCache;
     mCN->CacheFinish(aStatus);
   }
 }
 
 void
 CompareCache::Abort()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState != Finished) {
     mState = Finished;
 
     if (mPump) {
       mPump->Cancel(NS_BINDING_ABORTED);
       mPump = nullptr;
     }
   }
 }
 
 NS_IMETHODIMP
 CompareCache::OnStreamComplete(nsIStreamLoader* aLoader, nsISupports* aContext,
                                nsresult aStatus, uint32_t aLen,
                                const uint8_t* aString)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState == Finished) {
     return aStatus;
   }
 
   if (NS_WARN_IF(NS_FAILED(aStatus))) {
     Finish(aStatus, false);
     return aStatus;
@@ -1138,44 +1139,44 @@ CompareCache::OnStreamComplete(nsIStream
 
   Finish(NS_OK, true);
   return NS_OK;
 }
 
 void
 CompareCache::ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   switch (mState) {
     case Finished:
       return;
     case WaitingForScript:
       ManageValueResult(aCx, aValue);
       return;
     default:
       MOZ_CRASH("Unacceptable state.");
   }
 }
 
 void
 CompareCache::RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState != Finished) {
     Finish(NS_ERROR_FAILURE, false);
     return;
   }
 }
 
 void
 CompareCache::ManageValueResult(JSContext* aCx, JS::Handle<JS::Value> aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   // The cache returns undefined if the object is not stored.
   if (aValue.isUndefined()) {
     Finish(NS_OK, false);
     return;
   }
 
   MOZ_ASSERT(aValue.isObject());
@@ -1239,17 +1240,17 @@ CompareCache::ManageValueResult(JSContex
 }
 
 nsresult
 CompareManager::Initialize(nsIPrincipal* aPrincipal,
                            const nsAString& aURL,
                            const nsAString& aCacheName,
                            nsILoadGroup* aLoadGroup)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(mPendingCount == 0);
   MOZ_DIAGNOSTIC_ASSERT(mState == WaitingForInitialization);
 
   // RAII Cleanup when fails.
   auto guard = MakeScopeExit([&] { Cleanup(); });
 
   mURL = aURL;
@@ -1298,17 +1299,17 @@ CompareManager::Initialize(nsIPrincipal*
 // 1. Retrieve the Cache object by a given CacheName of OldCache.
 // 2. Retrieve the URLs saved in OldCache.
 // 3. Retrieve the Cache object of the NewCache for the newly created SW.
 // 4. Put the value in the cache.
 // For this reason we have mState to know what callback we are handling.
 void
 CompareManager::ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mCallback);
 
   switch (mState) {
     case Finished:
       return;
     case WaitingForExistingOpen:
       ManageOldCache(aCx, aValue);
       return;
@@ -1332,17 +1333,17 @@ CompareManager::ResolvedCallback(JSConte
     default:
       MOZ_DIAGNOSTIC_ASSERT(false);
   }
 }
 
 void
 CompareManager::RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   switch (mState) {
     case Finished:
       return;
     case WaitingForExistingOpen:
       NS_WARNING("Could not open the existing cache.");
       break;
     case WaitingForExistingKeys:
       NS_WARNING("Could not get the existing URLs.");
@@ -1358,26 +1359,26 @@ CompareManager::RejectedCallback(JSConte
   }
 
   Fail(NS_ERROR_FAILURE);
 }
 
 void
 CompareManager::Fail(nsresult aStatus)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   mCallback->ComparisonResult(aStatus, false /* aIsEqual */,
                               EmptyString(), EmptyCString(), mLoadFlags);
   Cleanup();
 }
 
 void
 CompareManager::Cleanup()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (mState != Finished) {
     mState = Finished;
 
     MOZ_ASSERT(mCallback);
     mCallback = nullptr;
 
     // Abort and release CompareNetworks.
@@ -1388,17 +1389,17 @@ CompareManager::Cleanup()
   }
 }
 
 } // namespace
 
 nsresult
 PurgeCache(nsIPrincipal* aPrincipal, const nsAString& aCacheName)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
 
   if (aCacheName.IsEmpty()) {
     return NS_OK;
   }
 
   AutoJSAPI jsapi;
   jsapi.Init();
@@ -1446,17 +1447,17 @@ GenerateCacheName(nsAString& aName)
 }
 
 nsresult
 Compare(ServiceWorkerRegistrationInfo* aRegistration,
         nsIPrincipal* aPrincipal, const nsAString& aCacheName,
         const nsAString& aURL, CompareCallback* aCallback,
         nsILoadGroup* aLoadGroup)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aRegistration);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(!aURL.IsEmpty());
   MOZ_ASSERT(aCallback);
 
   RefPtr<CompareManager> cm = new CompareManager(aRegistration, aCallback);
 
   nsresult rv = cm->Initialize(aPrincipal, aURL, aCacheName, aLoadGroup);
@@ -1464,9 +1465,10 @@ Compare(ServiceWorkerRegistrationInfo* a
     return rv;
   }
 
   return NS_OK;
 }
 
 } // namespace serviceWorkerScriptCache
 
-END_WORKERS_NAMESPACE
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerScriptCache.h b/dom/serviceworkers/ServiceWorkerScriptCache.h
--- a/dom/serviceworkers/ServiceWorkerScriptCache.h
+++ b/dom/serviceworkers/ServiceWorkerScriptCache.h
@@ -1,25 +1,24 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_ServiceWorkerScriptCache_h
-#define mozilla_dom_workers_ServiceWorkerScriptCache_h
+#ifndef mozilla_dom_ServiceWorkerScriptCache_h
+#define mozilla_dom_ServiceWorkerScriptCache_h
 
 #include "nsString.h"
 
 class nsILoadGroup;
 class nsIPrincipal;
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerRegistrationInfo;
 
 namespace serviceWorkerScriptCache {
 
 nsresult
 PurgeCache(nsIPrincipal* aPrincipal, const nsAString& aCacheName);
 
@@ -47,13 +46,12 @@ public:
 
 nsresult
 Compare(ServiceWorkerRegistrationInfo* aRegistration,
         nsIPrincipal* aPrincipal, const nsAString& aCacheName,
         const nsAString& aURL, CompareCallback* aCallback, nsILoadGroup* aLoadGroup);
 
 } // namespace serviceWorkerScriptCache
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_ServiceWorkerScriptCache_h
+#endif // mozilla_dom_ServiceWorkerScriptCache_h
diff --git a/dom/serviceworkers/ServiceWorkerUnregisterJob.cpp b/dom/serviceworkers/ServiceWorkerUnregisterJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUnregisterJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUnregisterJob.cpp
@@ -5,28 +5,27 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerUnregisterJob.h"
 
 #include "nsIPushService.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerUnregisterJob::PushUnsubscribeCallback final :
         public nsIUnsubscribeResultCallback
 {
 public:
   NS_DECL_ISUPPORTS
 
   explicit PushUnsubscribeCallback(ServiceWorkerUnregisterJob* aJob)
     : mJob(aJob)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   NS_IMETHOD
   OnUnsubscribe(nsresult aStatus, bool) override
   {
     // Warn if unsubscribing fails, but don't prevent the worker from
     // unregistering.
     Unused << NS_WARN_IF(NS_FAILED(aStatus));
@@ -52,28 +51,28 @@ ServiceWorkerUnregisterJob::ServiceWorke
   , mResult(false)
   , mSendToParent(aSendToParent)
 {
 }
 
 bool
 ServiceWorkerUnregisterJob::GetResult() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   return mResult;
 }
 
 ServiceWorkerUnregisterJob::~ServiceWorkerUnregisterJob()
 {
 }
 
 void
 ServiceWorkerUnregisterJob::AsyncExecute()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   if (Canceled()) {
     Finish(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // Push API, section 5: "When a service worker registration is unregistered,
   // any associated push subscription must be deactivated." To ensure the
@@ -92,17 +91,17 @@ ServiceWorkerUnregisterJob::AsyncExecute
   if (NS_WARN_IF(NS_FAILED(rv))) {
     Unregister();
   }
 }
 
 void
 ServiceWorkerUnregisterJob::Unregister()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (Canceled() || !swm) {
     Finish(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // Step 1 of the Unregister algorithm requires checking that the
@@ -141,11 +140,10 @@ ServiceWorkerUnregisterJob::Unregister()
   if (!registration->IsControllingClients() && registration->IsIdle()) {
     // "Invoke [[Clear Registration]]..."
     swm->RemoveRegistration(registration);
   }
 
   Finish(NS_OK);
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerUnregisterJob.h b/dom/serviceworkers/ServiceWorkerUnregisterJob.h
--- a/dom/serviceworkers/ServiceWorkerUnregisterJob.h
+++ b/dom/serviceworkers/ServiceWorkerUnregisterJob.h
@@ -1,22 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerunregisterjob_h
-#define mozilla_dom_workers_serviceworkerunregisterjob_h
+#ifndef mozilla_dom_serviceworkerunregisterjob_h
+#define mozilla_dom_serviceworkerunregisterjob_h
 
 #include "ServiceWorkerJob.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerUnregisterJob final : public ServiceWorkerJob
 {
 public:
   ServiceWorkerUnregisterJob(nsIPrincipal* aPrincipal,
                              const nsACString& aScope,
                              bool aSendToParent);
 
@@ -33,13 +32,12 @@ private:
 
   void
   Unregister();
 
   bool mResult;
   bool mSendToParent;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerunregisterjob_h
+#endif // mozilla_dom_serviceworkerunregisterjob_h
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.cpp
@@ -8,17 +8,16 @@
 
 #include "nsIScriptError.h"
 #include "nsIURL.h"
 #include "ServiceWorkerScriptCache.h"
 #include "Workers.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 namespace {
 
 /**
  * The spec mandates slightly different behaviors for computing the scope
  * prefix string in case a Service-Worker-Allowed header is specified versus
  * when it's not available.
  *
@@ -116,58 +115,58 @@ class ServiceWorkerUpdateJob::ContinueUp
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> mJob;
   bool mSuccess;
 
 public:
   explicit ContinueUpdateRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob>& aJob)
     : mJob(aJob)
     , mSuccess(false)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   SetResult(bool aResult) override
   {
     mSuccess = aResult;
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mJob->ContinueUpdateAfterScriptEval(mSuccess);
     mJob = nullptr;
     return NS_OK;
   }
 };
 
 class ServiceWorkerUpdateJob::ContinueInstallRunnable final : public LifeCycleEventCallback
 {
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> mJob;
   bool mSuccess;
 
 public:
   explicit ContinueInstallRunnable(const nsMainThreadPtrHandle<ServiceWorkerUpdateJob>& aJob)
     : mJob(aJob)
     , mSuccess(false)
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
   }
 
   void
   SetResult(bool aResult) override
   {
     mSuccess = aResult;
   }
 
   NS_IMETHOD
   Run() override
   {
-    AssertIsOnMainThread();
+    MOZ_ASSERT(NS_IsMainThread());
     mJob->ContinueAfterInstallEvent(mSuccess);
     mJob = nullptr;
     return NS_OK;
   }
 };
 
 ServiceWorkerUpdateJob::ServiceWorkerUpdateJob(
     nsIPrincipal* aPrincipal,
@@ -179,17 +178,17 @@ ServiceWorkerUpdateJob::ServiceWorkerUpd
   , mLoadGroup(aLoadGroup)
   , mUpdateViaCache(aUpdateViaCache)
 {
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerUpdateJob::GetRegistration() const
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   RefPtr<ServiceWorkerRegistrationInfo> ref = mRegistration;
   return ref.forget();
 }
 
 ServiceWorkerUpdateJob::ServiceWorkerUpdateJob(
     Type aType,
     nsIPrincipal* aPrincipal,
     const nsACString& aScope,
@@ -204,17 +203,17 @@ ServiceWorkerUpdateJob::ServiceWorkerUpd
 
 ServiceWorkerUpdateJob::~ServiceWorkerUpdateJob()
 {
 }
 
 void
 ServiceWorkerUpdateJob::FailUpdateJob(ErrorResult& aRv)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aRv.Failed());
 
   // Cleanup after a failed installation.  This essentially implements
   // step 12 of the Install algorithm.
   //
   //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
   //
   // The spec currently only runs this after an install event fails,
@@ -240,17 +239,17 @@ ServiceWorkerUpdateJob::FailUpdateJob(ns
 {
   ErrorResult rv(aRv);
   FailUpdateJob(rv);
 }
 
 void
 ServiceWorkerUpdateJob::AsyncExecute()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(GetType() == Type::Update);
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (Canceled() || !swm) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
@@ -283,27 +282,27 @@ ServiceWorkerUpdateJob::AsyncExecute()
 
   SetRegistration(registration);
   Update();
 }
 
 void
 ServiceWorkerUpdateJob::SetRegistration(ServiceWorkerRegistrationInfo* aRegistration)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_ASSERT(!mRegistration);
   MOZ_ASSERT(aRegistration);
   mRegistration = aRegistration;
 }
 
 void
 ServiceWorkerUpdateJob::Update()
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(!Canceled());
 
   // SetRegistration() must be called before Update().
   MOZ_ASSERT(mRegistration);
   MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin the script download and comparison steps starting at step 5
   // of the Update algorithm.
@@ -337,17 +336,17 @@ ServiceWorkerUpdateJob::GetUpdateViaCach
 
 void
 ServiceWorkerUpdateJob::ComparisonResult(nsresult aStatus,
                                          bool aInCacheAndEqual,
                                          const nsAString& aNewCacheName,
                                          const nsACString& aMaxScope,
                                          nsLoadFlags aLoadFlags)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (NS_WARN_IF(Canceled() || !swm)) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // Handle failure of the download or comparison.  This is part of Update
@@ -456,17 +455,17 @@ ServiceWorkerUpdateJob::ComparisonResult
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 }
 
 void
 ServiceWorkerUpdateJob::ContinueUpdateAfterScriptEval(bool aScriptEvaluationResult)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (Canceled() || !swm) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // Step 7.5 of the Update algorithm verifying that the script evaluated
@@ -483,17 +482,17 @@ ServiceWorkerUpdateJob::ContinueUpdateAf
   }
 
   Install(swm);
 }
 
 void
 ServiceWorkerUpdateJob::Install(ServiceWorkerManager* aSWM)
 {
-  AssertIsOnMainThread();
+  MOZ_ASSERT(NS_IsMainThread());
   MOZ_DIAGNOSTIC_ASSERT(!Canceled());
   MOZ_DIAGNOSTIC_ASSERT(aSWM);
 
   MOZ_ASSERT(!mRegistration->GetInstalling());
 
   // Begin step 2 of the Install algorithm.
   //
   //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
@@ -504,27 +503,27 @@ ServiceWorkerUpdateJob::Install(ServiceW
   InvokeResultCallbacks(NS_OK);
 
   // The job promise cannot be rejected after this point, but the job can
   // still fail; e.g. if the install event handler throws, etc.
 
   // fire the updatefound event
   nsCOMPtr<nsIRunnable> upr =
     NewRunnableMethod<RefPtr<ServiceWorkerRegistrationInfo>>(
-      "dom::workers::ServiceWorkerManager::"
+      "dom::ServiceWorkerManager::"
       "FireUpdateFoundOnServiceWorkerRegistrations",
       aSWM,
       &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
       mRegistration);
   NS_DispatchToMainThread(upr);
 
   // Call ContinueAfterInstallEvent(false) on main thread if the SW
   // script fails to load.
   nsCOMPtr<nsIRunnable> failRunnable = NewRunnableMethod<bool>(
-    "dom::workers::ServiceWorkerUpdateJob::ContinueAfterInstallEvent",
+    "dom::ServiceWorkerUpdateJob::ContinueAfterInstallEvent",
     this,
     &ServiceWorkerUpdateJob::ContinueAfterInstallEvent,
     false);
 
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
     new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(
       "ServiceWorkerUpdateJob", this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueInstallRunnable(handle);
@@ -573,11 +572,10 @@ ServiceWorkerUpdateJob::ContinueAfterIns
   // flushed from the queue before proceeding.
 
   // Step 22 of the Install algorithm.  Activate is executed after the completion
   // of this job.  The controlling client and skipWaiting checks are performed
   // in TryToActivate().
   mRegistration->TryToActivateAsync();
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerUpdateJob.h b/dom/serviceworkers/ServiceWorkerUpdateJob.h
--- a/dom/serviceworkers/ServiceWorkerUpdateJob.h
+++ b/dom/serviceworkers/ServiceWorkerUpdateJob.h
@@ -1,23 +1,22 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef mozilla_dom_workers_serviceworkerupdatejob_h
-#define mozilla_dom_workers_serviceworkerupdatejob_h
+#ifndef mozilla_dom_serviceworkerupdatejob_h
+#define mozilla_dom_serviceworkerupdatejob_h
 
 #include "ServiceWorkerJob.h"
 #include "ServiceWorkerRegistration.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerManager;
 
 // A job class that performs the Update and Install algorithms from the
 // service worker spec.  This class is designed to be inherited and customized
 // as a different job type.  This is necessary because the register job
 // performs largely the same operations as the update job, but has a few
 // different starting steps.
@@ -101,13 +100,12 @@ private:
   ContinueAfterInstallEvent(bool aInstallEventSuccess);
 
   nsCOMPtr<nsILoadGroup> mLoadGroup;
   ServiceWorkerUpdateViaCache mUpdateViaCache;
 
   RefPtr<ServiceWorkerRegistrationInfo> mRegistration;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
-#endif // mozilla_dom_workers_serviceworkerupdatejob_h
+#endif // mozilla_dom_serviceworkerupdatejob_h
diff --git a/dom/serviceworkers/ServiceWorkerUpdaterChild.cpp b/dom/serviceworkers/ServiceWorkerUpdaterChild.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdaterChild.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdaterChild.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerUpdaterChild.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 ServiceWorkerUpdaterChild::ServiceWorkerUpdaterChild(GenericPromise* aPromise,
                                                      CancelableRunnable* aSuccessRunnable,
                                                      CancelableRunnable* aFailureRunnable)
   : mSuccessRunnable(aSuccessRunnable)
   , mFailureRunnable(aFailureRunnable)
 {
   // TODO: remove the main thread restriction after fixing bug 1364821.
@@ -59,11 +58,10 @@ ServiceWorkerUpdaterChild::ActorDestroy(
 
   if (mFailureRunnable) {
     mFailureRunnable->Cancel();
   }
 
   mPromiseHolder.DisconnectIfExists();
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerUpdaterChild.h b/dom/serviceworkers/ServiceWorkerUpdaterChild.h
--- a/dom/serviceworkers/ServiceWorkerUpdaterChild.h
+++ b/dom/serviceworkers/ServiceWorkerUpdaterChild.h
@@ -8,17 +8,16 @@
 #define mozilla_dom_ServiceWorkerUpdaterChild_h
 
 #include "mozilla/dom/PServiceWorkerUpdaterChild.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/MozPromise.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerUpdaterChild final : public PServiceWorkerUpdaterChild
 {
 public:
   ServiceWorkerUpdaterChild(GenericPromise* aPromise,
                             CancelableRunnable* aSuccessRunnable,
                             CancelableRunnable* aFailureRunnable);
 
@@ -30,13 +29,12 @@ private:
   ActorDestroy(ActorDestroyReason aWhy) override;
 
   MozPromiseRequestHolder<GenericPromise> mPromiseHolder;
 
   RefPtr<CancelableRunnable> mSuccessRunnable;
   RefPtr<CancelableRunnable> mFailureRunnable;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerUpdaterChild_h
diff --git a/dom/serviceworkers/ServiceWorkerUpdaterParent.cpp b/dom/serviceworkers/ServiceWorkerUpdaterParent.cpp
--- a/dom/serviceworkers/ServiceWorkerUpdaterParent.cpp
+++ b/dom/serviceworkers/ServiceWorkerUpdaterParent.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerUpdaterParent.h"
 #include "ServiceWorkerManagerService.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 bool
 ServiceWorkerUpdaterParent::Proceed(ServiceWorkerManagerService* aService)
 {
   if (!SendProceed(true)) {
     return false;
   }
 
@@ -25,11 +24,10 @@ ServiceWorkerUpdaterParent::Proceed(Serv
 void
 ServiceWorkerUpdaterParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   if (mService) {
     mService->UpdaterActorDestroyed(this);
   }
 }
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/serviceworkers/ServiceWorkerUpdaterParent.h b/dom/serviceworkers/ServiceWorkerUpdaterParent.h
--- a/dom/serviceworkers/ServiceWorkerUpdaterParent.h
+++ b/dom/serviceworkers/ServiceWorkerUpdaterParent.h
@@ -7,30 +7,28 @@
 #ifndef mozilla_dom_ServiceWorkerUpdaterParent_h
 #define mozilla_dom_ServiceWorkerUpdaterParent_h
 
 #include "mozilla/dom/PServiceWorkerUpdaterParent.h"
 #include "mozilla/BasePrincipal.h"
 
 namespace mozilla {
 namespace dom {
-namespace workers {
 
 class ServiceWorkerManagerService;
 
 class ServiceWorkerUpdaterParent final : public PServiceWorkerUpdaterParent
 {
 public:
   void
   ActorDestroy(ActorDestroyReason aWhy) override;
 
   bool
   Proceed(ServiceWorkerManagerService* aService);
 
 private:
   RefPtr<ServiceWorkerManagerService> mService;
 };
 
-} // namespace workers
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ServiceWorkerUpdaterParent_h
diff --git a/dom/serviceworkers/moz.build b/dom/serviceworkers/moz.build
--- a/dom/serviceworkers/moz.build
+++ b/dom/serviceworkers/moz.build
@@ -4,38 +4,31 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 with Files("**"):
     BUG_COMPONENT = ("Core", "DOM: Service Workers")
 
 # Public stuff.
 EXPORTS.mozilla.dom += [
+    'ServiceWorker.h',
     'ServiceWorkerCommon.h',
     'ServiceWorkerContainer.h',
     'ServiceWorkerDescriptor.h',
     'ServiceWorkerEvents.h',
+    'ServiceWorkerInfo.h',
     'ServiceWorkerInterceptController.h',
     'ServiceWorkerIPCUtils.h',
-    'ServiceWorkerRegistrar.h',
-    'ServiceWorkerRegistration.h',
-    'ServiceWorkerUtils.h',
-]
-
-EXPORTS.mozilla.dom.workers += [
-    'ServiceWorkerInfo.h',
     'ServiceWorkerManager.h',
     'ServiceWorkerManagerChild.h',
     'ServiceWorkerManagerParent.h',
+    'ServiceWorkerRegistrar.h',
+    'ServiceWorkerRegistration.h',
     'ServiceWorkerRegistrationInfo.h',
-]
-
-# Stuff needed for the bindings, not really public though.
-EXPORTS.mozilla.dom.workers.bindings += [
-    'ServiceWorker.h',
+    'ServiceWorkerUtils.h',
 ]
 
 UNIFIED_SOURCES += [
     'ServiceWorker.cpp',
     'ServiceWorkerContainer.cpp',
     'ServiceWorkerDescriptor.cpp',
     'ServiceWorkerEvents.cpp',
     'ServiceWorkerInfo.cpp',
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -106,17 +106,17 @@
 #include "nsThreadManager.h"
 #endif
 
 #include "Navigator.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "mozilla/dom/ServiceWorkerEvents.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "SharedWorker.h"
 #include "WorkerDebuggerManager.h"
 #include "WorkerHolder.h"
 #include "WorkerNavigator.h"
 #include "WorkerRunnable.h"
 #include "WorkerScope.h"
 #include "WorkerThread.h"
 
diff --git a/dom/workers/WorkerScope.cpp b/dom/workers/WorkerScope.cpp
--- a/dom/workers/WorkerScope.cpp
+++ b/dom/workers/WorkerScope.cpp
@@ -41,18 +41,18 @@
 #endif
 
 #include "Crypto.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "mozilla/dom/ServiceWorkerRegistration.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 extern already_AddRefed<nsIScriptTimeoutHandler>
 NS_CreateJSTimeoutHandler(JSContext* aCx,
                           mozilla::dom::workers::WorkerPrivate* aWorkerPrivate,
diff --git a/image/ImageCacheKey.cpp b/image/ImageCacheKey.cpp
--- a/image/ImageCacheKey.cpp
+++ b/image/ImageCacheKey.cpp
@@ -6,17 +6,17 @@
 #include "ImageCacheKey.h"
 
 #include "mozilla/Move.h"
 #include "ImageURL.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsLayoutUtils.h"
 #include "nsString.h"
 #include "mozilla/dom/File.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "nsIDocument.h"
 #include "nsPrintfCString.h"
 
 namespace mozilla {
 
 using namespace dom;
 
 namespace image {
@@ -159,17 +159,16 @@ ImageCacheKey::ComputeHash(ImageURL* aUR
 
 /* static */ void*
 ImageCacheKey::GetControlledDocumentToken(nsIDocument* aDocument)
 {
   // For non-controlled documents, we just return null.  For controlled
   // documents, we cast the pointer into a void* to avoid dereferencing
   // it (since we only use it for comparisons), and return it.
   void* pointer = nullptr;
-  using dom::workers::ServiceWorkerManager;
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (aDocument && swm) {
     ErrorResult rv;
     if (aDocument->GetController().isSome()) {
       pointer = aDocument;
     }
   }
   return pointer;
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -26,19 +26,19 @@
 #include "mozilla/dom/ipc/PendingIPCBlobChild.h"
 #include "mozilla/dom/ipc/TemporaryIPCBlobChild.h"
 #include "mozilla/dom/quota/PQuotaChild.h"
 #include "mozilla/dom/StorageIPC.h"
 #include "mozilla/dom/GamepadEventChannelChild.h"
 #include "mozilla/dom/GamepadTestChannelChild.h"
 #include "mozilla/dom/LocalStorage.h"
 #include "mozilla/dom/MessagePortChild.h"
+#include "mozilla/dom/ServiceWorkerManagerChild.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/dom/TabGroup.h"
-#include "mozilla/dom/workers/ServiceWorkerManagerChild.h"
 #include "mozilla/ipc/IPCStreamAlloc.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "mozilla/ipc/PChildToParentStreamChild.h"
 #include "mozilla/ipc/PParentToChildStreamChild.h"
 #include "mozilla/layout/VsyncChild.h"
 #include "mozilla/net/HttpBackgroundChannelChild.h"
 #include "mozilla/net/PUDPSocketChild.h"
 #include "mozilla/dom/network/UDPSocketChild.h"
@@ -378,27 +378,27 @@ BackgroundChildImpl::DeallocPCamerasChil
 
 // -----------------------------------------------------------------------------
 // ServiceWorkerManager
 // -----------------------------------------------------------------------------
 
 dom::PServiceWorkerManagerChild*
 BackgroundChildImpl::AllocPServiceWorkerManagerChild()
 {
-  RefPtr<dom::workers::ServiceWorkerManagerChild> agent =
-    new dom::workers::ServiceWorkerManagerChild();
+  RefPtr<dom::ServiceWorkerManagerChild> agent =
+    new dom::ServiceWorkerManagerChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPServiceWorkerManagerChild(
                                              PServiceWorkerManagerChild* aActor)
 {
-  RefPtr<dom::workers::ServiceWorkerManagerChild> child =
-    dont_AddRef(static_cast<dom::workers::ServiceWorkerManagerChild*>(aActor));
+  RefPtr<dom::ServiceWorkerManagerChild> child =
+    dont_AddRef(static_cast<dom::ServiceWorkerManagerChild*>(aActor));
   MOZ_ASSERT(child);
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Cache API
 // -----------------------------------------------------------------------------
 
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -18,26 +18,26 @@
 #include "mozilla/dom/DOMTypes.h"
 #include "mozilla/dom/FileSystemBase.h"
 #include "mozilla/dom/FileSystemRequestParent.h"
 #include "mozilla/dom/GamepadEventChannelParent.h"
 #include "mozilla/dom/GamepadTestChannelParent.h"
 #include "mozilla/dom/PGamepadEventChannelParent.h"
 #include "mozilla/dom/PGamepadTestChannelParent.h"
 #include "mozilla/dom/MessagePortParent.h"
+#include "mozilla/dom/ServiceWorkerManagerParent.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
 #include "mozilla/dom/cache/ActorUtils.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/IPCBlobInputStreamParent.h"
 #include "mozilla/dom/ipc/PendingIPCBlobParent.h"
 #include "mozilla/dom/ipc/TemporaryIPCBlobParent.h"
 #include "mozilla/dom/quota/ActorsParent.h"
 #include "mozilla/dom/StorageIPC.h"
-#include "mozilla/dom/workers/ServiceWorkerManagerParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/IPCStreamAlloc.h"
 #include "mozilla/ipc/PBackgroundSharedTypes.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "mozilla/ipc/PChildToParentStreamParent.h"
 #include "mozilla/ipc/PParentToChildStreamParent.h"
 #include "mozilla/layout/VsyncParent.h"
@@ -102,17 +102,16 @@ public:
 } // namespace
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::BroadcastChannelParent;
 using mozilla::dom::ServiceWorkerRegistrationData;
-using mozilla::dom::workers::ServiceWorkerManagerParent;
 
 BackgroundParentImpl::BackgroundParentImpl()
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
 
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundParentImpl);
 }
@@ -654,31 +653,31 @@ BackgroundParentImpl::DeallocPBroadcastC
 }
 
 mozilla::dom::PServiceWorkerManagerParent*
 BackgroundParentImpl::AllocPServiceWorkerManagerParent()
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  RefPtr<dom::workers::ServiceWorkerManagerParent> agent =
-    new dom::workers::ServiceWorkerManagerParent();
+  RefPtr<dom::ServiceWorkerManagerParent> agent =
+    new dom::ServiceWorkerManagerParent();
   return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPServiceWorkerManagerParent(
                                             PServiceWorkerManagerParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  RefPtr<dom::workers::ServiceWorkerManagerParent> parent =
-    dont_AddRef(static_cast<dom::workers::ServiceWorkerManagerParent*>(aActor));
+  RefPtr<dom::ServiceWorkerManagerParent> parent =
+    dont_AddRef(static_cast<dom::ServiceWorkerManagerParent*>(aActor));
   MOZ_ASSERT(parent);
   return true;
 }
 
 mozilla::ipc::IPCResult
 BackgroundParentImpl::RecvShutdownServiceWorkerRegistrar()
 {
   AssertIsInMainProcess();
diff --git a/netwerk/ipc/NeckoParent.cpp b/netwerk/ipc/NeckoParent.cpp
--- a/netwerk/ipc/NeckoParent.cpp
+++ b/netwerk/ipc/NeckoParent.cpp
@@ -30,17 +30,17 @@
 #endif
 #include "mozilla/dom/ChromeUtils.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/TabContext.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/dom/network/TCPSocketParent.h"
 #include "mozilla/dom/network/TCPServerSocketParent.h"
 #include "mozilla/dom/network/UDPSocketParent.h"
-#include "mozilla/dom/workers/ServiceWorkerManager.h"
+#include "mozilla/dom/ServiceWorkerManager.h"
 #include "mozilla/LoadContext.h"
 #include "mozilla/MozPromise.h"
 #include "nsPrintfCString.h"
 #include "nsHTMLDNSPrefetch.h"
 #include "nsEscape.h"
 #include "SerializedLoadContext.h"
 #include "nsAuthInformationHolder.h"
 #include "nsIAuthPromptCallback.h"
@@ -48,25 +48,25 @@
 #include "nsINetworkPredictor.h"
 #include "nsINetworkPredictorVerifier.h"
 #include "nsISpeculativeConnect.h"
 #include "nsNetUtil.h"
 
 using mozilla::OriginAttributes;
 using mozilla::dom::ChromeUtils;
 using mozilla::dom::ContentParent;
+using mozilla::dom::ServiceWorkerManager;
 using mozilla::dom::TabContext;
 using mozilla::dom::TabParent;
 using mozilla::net::PTCPSocketParent;
 using mozilla::dom::TCPSocketParent;
 using mozilla::net::PTCPServerSocketParent;
 using mozilla::dom::TCPServerSocketParent;
 using mozilla::net::PUDPSocketParent;
 using mozilla::dom::UDPSocketParent;
-using mozilla::dom::workers::ServiceWorkerManager;
 using mozilla::ipc::AutoIPCStream;
 using mozilla::ipc::OptionalPrincipalInfo;
 using mozilla::ipc::PrincipalInfo;
 using mozilla::ipc::LoadInfoArgsToLoadInfo;
 using IPC::SerializedLoadContext;
 
 namespace mozilla {
 namespace net {
