# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2b347cd70b1d6cce3fe057bbd084a9e6ae3b97e5

diff --git a/devtools/server/actors/addon.js b/devtools/server/actors/addon.js
--- a/devtools/server/actors/addon.js
+++ b/devtools/server/actors/addon.js
@@ -177,29 +177,27 @@ BrowserAddonActor.prototype = {
   },
 
   preNest: function () {
     let e = Services.wm.getEnumerator(null);
     while (e.hasMoreElements()) {
       let win = e.getNext();
       let windowUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils);
-      windowUtils.suppressEventHandling(true);
       windowUtils.suspendTimeouts();
     }
   },
 
   postNest: function () {
     let e = Services.wm.getEnumerator(null);
     while (e.hasMoreElements()) {
       let win = e.getNext();
       let windowUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
                            .getInterface(Ci.nsIDOMWindowUtils);
       windowUtils.resumeTimeouts();
-      windowUtils.suppressEventHandling(false);
     }
   },
 
   /**
    * Return true if the given global is associated with this addon and should be
    * added as a debuggee, false otherwise.
    */
   _shouldAddNewGlobalAsDebuggee: function (aGlobal) {
diff --git a/devtools/server/actors/chrome.js b/devtools/server/actors/chrome.js
--- a/devtools/server/actors/chrome.js
+++ b/devtools/server/actors/chrome.js
@@ -159,27 +159,25 @@ ChromeActor.prototype._detach = function
  */
 ChromeActor.prototype.preNest = function () {
   // Disable events in all open windows.
   let e = Services.wm.getEnumerator(null);
   while (e.hasMoreElements()) {
     let win = e.getNext();
     let windowUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
                          .getInterface(Ci.nsIDOMWindowUtils);
-    windowUtils.suppressEventHandling(true);
     windowUtils.suspendTimeouts();
   }
 };
 
 /**
  * Prepare to exit a nested event loop by enabling debuggee events.
  */
 ChromeActor.prototype.postNest = function (aNestData) {
   // Enable events in all open windows.
   let e = Services.wm.getEnumerator(null);
   while (e.hasMoreElements()) {
     let win = e.getNext();
     let windowUtils = win.QueryInterface(Ci.nsIInterfaceRequestor)
                          .getInterface(Ci.nsIDOMWindowUtils);
     windowUtils.resumeTimeouts();
-    windowUtils.suppressEventHandling(false);
   }
 };
diff --git a/devtools/server/actors/webbrowser.js b/devtools/server/actors/webbrowser.js
--- a/devtools/server/actors/webbrowser.js
+++ b/devtools/server/actors/webbrowser.js
@@ -1782,33 +1782,31 @@ TabActor.prototype = {
   preNest() {
     if (!this.window) {
       // The tab is already closed.
       return;
     }
     let windowUtils = this.window
                           .QueryInterface(Ci.nsIInterfaceRequestor)
                           .getInterface(Ci.nsIDOMWindowUtils);
-    windowUtils.suppressEventHandling(true);
     windowUtils.suspendTimeouts();
   },
 
   /**
    * Prepare to exit a nested event loop by enabling debuggee events.
    */
   postNest(nestData) {
     if (!this.window) {
       // The tab is already closed.
       return;
     }
     let windowUtils = this.window
                           .QueryInterface(Ci.nsIInterfaceRequestor)
                           .getInterface(Ci.nsIDOMWindowUtils);
     windowUtils.resumeTimeouts();
-    windowUtils.suppressEventHandling(false);
   },
 
   _changeTopLevelDocument(window) {
     // Fake a will-navigate on the previous document
     // to let a chance to unregister it
     this._willNavigate(this.window, window.location.href, null, true);
 
     this._windowDestroyed(this.window, null, true);
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -8760,33 +8760,16 @@ nsDocShell::RestoreFromHistory()
     newCv->SetTextZoom(textZoom);
     newCv->SetFullZoom(pageZoom);
     newCv->SetOverrideDPPX(overrideDPPX);
     newCv->SetAuthorStyleDisabled(styleDisabled);
   }
 
   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDoc);
   if (document) {
-    RefPtr<nsDocShell> parent = GetParentDocshell();
-    if (parent) {
-      nsCOMPtr<nsIDocument> d = parent->GetDocument();
-      if (d) {
-        if (d->EventHandlingSuppressed()) {
-          document->SuppressEventHandling(nsIDocument::eEvents,
-                                          d->EventHandlingSuppressed());
-        }
-
-        // Ick, it'd be nicer to not rewalk all of the subdocs here.
-        if (d->AnimationsPaused()) {
-          document->SuppressEventHandling(nsIDocument::eAnimationsOnly,
-                                          d->AnimationsPaused());
-        }
-      }
-    }
-
     // Use the uri from the mLSHE we had when we entered this function
     // (which need not match the document's URI if anchors are involved),
     // since that's the history entry we're loading.  Note that if we use
     // origLSHE we don't have to worry about whether the entry in question
     // is still mLSHE or whether it's now mOSHE.
     nsCOMPtr<nsIURI> uri;
     origLSHE->GetURI(getter_AddRefs(uri));
     SetCurrentURI(uri, document->GetChannel(), true, 0);
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -8750,24 +8750,28 @@ nsGlobalWindow::EnterModalState()
   nsIDocument* topDoc = topWin->GetExtantDoc();
   nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
   if (capturingContent && topDoc &&
       nsContentUtils::ContentIsCrossDocDescendantOf(capturingContent, topDoc)) {
     nsIPresShell::SetCapturingContent(nullptr, 0);
   }
 
   if (topWin->mModalStateDepth == 0) {
-    NS_ASSERTION(!topWin->mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
-
-    topWin->mSuspendedDoc = topDoc;
+    topWin->NewSuspend();
+
+    // NewSuspend() will suppress all events by default.  But modal state
+    // should only suppress animations.
     if (topDoc) {
+      MOZ_ASSERT(topWin->mSuspendedDoc == topDoc);
+      // So first, enable animation suppression.
       topDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly);
-    }
-
-    topWin->NewSuspend();
+      // Then undo the event suppression performed by NewSuspend().  We
+      // will put this back in LeaveModalState().
+      topDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+    }
   }
   topWin->mModalStateDepth++;
 }
 
 void
 nsGlobalWindow::LeaveModalState()
 {
   MOZ_ASSERT(IsOuterWindow(), "Modal state is maintained on outer windows");
@@ -8780,24 +8784,28 @@ nsGlobalWindow::LeaveModalState()
   }
 
   MOZ_ASSERT(topWin->mModalStateDepth != 0);
   MOZ_ASSERT(NewIsSuspended());
   MOZ_ASSERT(topWin->NewIsSuspended());
   topWin->mModalStateDepth--;
 
   if (topWin->mModalStateDepth == 0) {
-    topWin->NewResume();
-
     if (topWin->mSuspendedDoc) {
+      // Put make the event suppression initially set by NewSuspend() in
+      // EnterModalState().
+      topWin->mSuspendedDoc->SuppressEventHandling(nsIDocument::eEvents);
+
+      // Then reverse the animation suppression enabled in EnterModalState().
       nsCOMPtr<nsIDocument> currentDoc = topWin->GetExtantDoc();
       topWin->mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eAnimationsOnly,
                                                                   currentDoc == topWin->mSuspendedDoc);
-      topWin->mSuspendedDoc = nullptr;
-    }
+    }
+
+    topWin->NewResume();
   }
 
   // Remember the time of the last dialog quit.
   nsGlobalWindow *inner = topWin->GetCurrentInnerWindowInternal();
   if (inner)
     inner->mLastDialogQuitTime = TimeStamp::Now();
 
   if (topWin->mModalStateDepth == 0) {
@@ -11596,18 +11604,29 @@ nsGlobalWindow::CloneStorageEvent(const 
   return event.forget();
 }
 
 void
 nsGlobalWindow::NewSuspend()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewSuspend, ());
-
-  CallOnChildren(&nsGlobalWindow::NewSuspend);
+  if (mDoc) {
+    mSuspendedDoc = mDoc;
+    mDoc->SuppressEventHandling(nsIDocument::eEvents);
+  }
+  NewSuspendInternal();
+}
+
+void
+nsGlobalWindow::NewSuspendInternal()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  CallOnChildren(&nsGlobalWindow::NewSuspendInternal);
 
   mSuspendDepth += 1;
   if (mSuspendDepth != 1) {
     return;
   }
 
   nsCOMPtr<nsIDeviceSensors> ac = do_GetService(NS_DEVICE_SENSORS_CONTRACTID);
   if (ac) {
@@ -11644,19 +11663,34 @@ nsGlobalWindow::NewSuspend()
   }
 }
 
 void
 nsGlobalWindow::NewResume()
 {
   MOZ_ASSERT(NS_IsMainThread());
   FORWARD_TO_INNER_VOID(NewResume, ());
-
-  CallOnChildren(&nsGlobalWindow::NewResume);
-
+  NewResumeInternal();
+  if (mSuspendedDoc) {
+    mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents,
+                                                        mDoc == mSuspendedDoc);
+    if (!mSuspendedDoc->EventHandlingSuppressed()) {
+      mSuspendedDoc = nullptr;
+    }
+  }
+}
+
+void
+nsGlobalWindow::NewResumeInternal()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  CallOnChildren(&nsGlobalWindow::NewResumeInternal);
+
+  MOZ_ASSERT_IF(mDoc, mDoc->EventHandlingSuppressed());
   MOZ_ASSERT(mSuspendDepth != 0);
   mSuspendDepth -= 1;
   if (mSuspendDepth != 0) {
     return;
   }
 
   // We should not be able to resume a frozen window.  It must be Thaw()'d first.
   MOZ_ASSERT(mFreezeDepth == 0);
@@ -11850,42 +11884,68 @@ nsGlobalWindow::NewSyncSuspendAndFreezeS
 
   // Attempt to find our parent windows.
   nsCOMPtr<Element> frame = outer->GetFrameElementInternal();
   nsPIDOMWindowOuter* parentOuter = frame ? frame->OwnerDoc()->GetWindow()
                                           : nullptr;
   nsGlobalWindow* parentInner =
     parentOuter ? nsGlobalWindow::Cast(parentOuter->GetCurrentInnerWindow())
                 : nullptr;
+  nsIDocument* parentDoc = parentInner ? parentInner->GetExtantDoc() : nullptr;
 
   // If our outer is in a modal state, but our parent is not in a modal
   // state, then we must apply the suspend directly.  If our parent is
   // in a modal state then we should get the suspend automatically
   // via the parentSuspendDepth application below.
   if ((!parentInner || !parentInner->IsInModalState()) && IsInModalState()) {
     NewSuspend();
+    if (mDoc) {
+      MOZ_ASSERT(mSuspendedDoc == mDoc);
+      mDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly);
+      mDoc->UnsuppressEventHandlingAndFireEvents(nsIDocument::eEvents, true);
+    }
   }
 
   uint32_t parentFreezeDepth = parentInner ? parentInner->mFreezeDepth : 0;
   uint32_t parentSuspendDepth = parentInner ? parentInner->mSuspendDepth : 0;
+  uint32_t parentEventSuppressDepth = parentDoc ? parentDoc->EventHandlingSuppressed()
+                                                : 0;
+  uint32_t parentAnimationsPaused = parentDoc ? parentDoc->AnimationsPaused() : 0;
 
   // Since every Freeze() calls Suspend(), the suspend count must
   // be equal or greater to the freeze count.
   MOZ_ASSERT(parentFreezeDepth <= parentSuspendDepth);
 
   // First apply the Freeze() calls.
   for (uint32_t i = 0; i < parentFreezeDepth; ++i) {
     NewFreeze();
   }
 
   // Now apply only the number of Suspend() calls to reach the target
   // suspend count after applying the Freeze() calls.
-  for (uint32_t i = 0; i < (parentSuspendDepth - parentFreezeDepth); ++i) {
+  for (uint32_t i = 0; i < (parentSuspendDepth - mSuspendDepth); ++i) {
     NewSuspend();
   }
+
+  if (mDoc) {
+    if (parentEventSuppressDepth > mDoc->EventHandlingSuppressed()) {
+      mDoc->SuppressEventHandling(nsIDocument::eEvents,
+                                  parentEventSuppressDepth - mDoc->EventHandlingSuppressed());
+    }
+
+    if (parentAnimationsPaused > mDoc->AnimationsPaused()) {
+      mDoc->SuppressEventHandling(nsIDocument::eAnimationsOnly,
+                                  parentAnimationsPaused - mDoc->AnimationsPaused());
+    }
+  }
+
+  MOZ_ASSERT(parentFreezeDepth == mFreezeDepth);
+  MOZ_ASSERT(parentSuspendDepth == mSuspendDepth);
+  MOZ_ASSERT_IF(mDoc, parentEventSuppressDepth == mDoc->EventHandlingSuppressed());
+  MOZ_ASSERT_IF(mDoc, parentAnimationsPaused == mDoc->AnimationsPaused());
 }
 
 template<typename Method>
 void
 nsGlobalWindow::CallOnChildren(Method aMethod)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1487,16 +1487,18 @@ private:
                         bool aNavigate,
                         nsIArray *argv,
                         nsISupports *aExtraArgument,
                         nsPIDOMWindowOuter **aReturn);
 
   template<typename Method>
   void CallOnChildren(Method aMethod);
 
+  void NewSuspendInternal();
+  void NewResumeInternal();
   void NewFreezeInternal();
   void NewThawInternal();
 
 public:
   // Timeout Functions
   // Language agnostic timeout function (all args passed).
   // |interval| is in milliseconds.
   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
diff --git a/dom/bindings/BindingUtils.cpp b/dom/bindings/BindingUtils.cpp
--- a/dom/bindings/BindingUtils.cpp
+++ b/dom/bindings/BindingUtils.cpp
@@ -2727,24 +2727,17 @@ IsNonExposedGlobal(JSContext* aCx, JSObj
 
   return false;
 }
 
 void
 HandlePrerenderingViolation(nsPIDOMWindowInner* aWindow)
 {
   // Suspend the window and its workers, and its children too.
-  // TODO: should this be a freeze?
   aWindow->NewSuspend();
-
-  // Suspend event handling on the document
-  nsCOMPtr<nsIDocument> doc = aWindow->GetExtantDoc();
-  if (doc) {
-    doc->SuppressEventHandling(nsIDocument::eEvents);
-  }
 }
 
 bool
 EnforceNotInPrerendering(JSContext* aCx, JSObject* aObj)
 {
   JS::Rooted<JSObject*> thisObj(aCx, js::CheckedUnwrap(aObj));
   if (!thisObj) {
     // Without a this object, we cannot check the safety.
diff --git a/dom/xhr/XMLHttpRequestMainThread.cpp b/dom/xhr/XMLHttpRequestMainThread.cpp
--- a/dom/xhr/XMLHttpRequestMainThread.cpp
+++ b/dom/xhr/XMLHttpRequestMainThread.cpp
@@ -2914,20 +2914,16 @@ XMLHttpRequestMainThread::SendInternal(c
   if (mFlagSynchronous) {
     mFlagSyncLooping = true;
 
     nsCOMPtr<nsIDocument> suspendedDoc;
     nsCOMPtr<nsIRunnable> resumeTimeoutRunnable;
     if (GetOwner()) {
       if (nsCOMPtr<nsPIDOMWindowOuter> topWindow = GetOwner()->GetOuterWindow()->GetTop()) {
         if (nsCOMPtr<nsPIDOMWindowInner> topInner = topWindow->GetCurrentInnerWindow()) {
-          suspendedDoc = topWindow->GetExtantDoc();
-          if (suspendedDoc) {
-            suspendedDoc->SuppressEventHandling(nsIDocument::eEvents);
-          }
           topWindow->NewSuspend();
           resumeTimeoutRunnable = new nsResumeTimeoutsEvent(topInner);
         }
       }
     }
 
     StopProgressEventTimer();
 
