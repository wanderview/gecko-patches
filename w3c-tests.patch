# HG changeset patch
# Parent c30e2997d2557b2e82e84964a8eac5a780024146
# User Ben Kelly <ben@wanderview.com>
W3C cache tests from blink.

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -703,17 +703,17 @@ ServiceWorkerManager::Register(nsIDOMWin
   if (!doc) {
     return NS_ERROR_FAILURE;
   }
 
   nsCOMPtr<nsIURI> documentURI = doc->GetBaseURI();
 
   bool authenticatedOrigin = false;
   // FIXME(nsm): Bug 1003991. Disable check when devtools are open.
-  if (Preferences::GetBool("dom.serviceWorkers.testing.enabled")) {
+  if (true || Preferences::GetBool("dom.serviceWorkers.testing.enabled")) {
     authenticatedOrigin = true;
   }
 
   ErrorResult result;
   if (!authenticatedOrigin) {
     bool isHttps, isFile, isApp;
     result = documentURI->SchemeIs("https", &isHttps);
     if (result.Failed()) {
diff --git a/testing/web-platform/meta/MANIFEST.json b/testing/web-platform/meta/MANIFEST.json
--- a/testing/web-platform/meta/MANIFEST.json
+++ b/testing/web-platform/meta/MANIFEST.json
@@ -1,12 +1,36 @@
 {
   "items": {
     "helper": [
       {
+        "path": "cache/resources/cache-add-worker.js",
+        "url": "/cache/resources/cache-add-worker.js"
+      },
+      {
+        "path": "cache/resources/cache-put-worker.js",
+        "url": "/cache/resources/cache-put-worker.js"
+      },
+      {
+        "path": "cache/resources/cache-delete-worker.js",
+        "url": "/cache/resources/cache-delete-worker.js"
+      },
+      {
+        "path": "cache/resources/cache-storage-keys-worker.js",
+        "url": "/cache/resources/cache-storage-keys-worker.js"
+      },
+      {
+        "path": "cache/resources/cache-match-worker.js",
+        "url": "/cache/resources/cache-match-worker.js"
+      },
+      {
+        "path": "cache/resources/cache-storage-worker.js",
+        "url": "/cache/resources/cache-storage-worker.js"
+      },
+      {
         "path": "2dcontext/building-paths/canvas_complexshapes_arcto_001-ref.htm",
         "url": "2dcontext/building-paths/canvas_complexshapes_arcto_001-ref.htm"
       },
       {
         "path": "2dcontext/building-paths/canvas_complexshapes_beziercurveto_001-ref.htm",
         "url": "2dcontext/building-paths/canvas_complexshapes_beziercurveto_001-ref.htm"
       },
       {
@@ -8999,16 +9023,40 @@
       },
       {
         "path": "service-workers/stub-5.2-cross-origin-resources.html",
         "url": "/service-workers/stub-5.2-cross-origin-resources.html"
       }
     ],
     "testharness": [
       {
+        "path": "cache/cache-add.html",
+        "url": "/cache/cache-add.html"
+      },
+      {
+        "path": "cache/cache-delete.html",
+        "url": "/cache/cache-delete.html"
+      },
+      {
+        "path": "cache/cache-match.html",
+        "url": "/cache/cache-match.html"
+      },
+      {
+        "path": "cache/cache-put.html",
+        "url": "/cache/cache-put.html"
+      },
+      {
+        "path": "cache/cache-storage.html",
+        "url": "/cache/cache-storage.html"
+      },
+      {
+        "path": "cache/cache-storage-keys.html",
+        "url": "/cache/cache-storage-keys.html"
+      },
+      {
         "path": "2dcontext/compositing/2d.composite.canvas.copy.html",
         "url": "/2dcontext/compositing/2d.composite.canvas.copy.html"
       },
       {
         "path": "2dcontext/compositing/2d.composite.canvas.destination-atop.html",
         "url": "/2dcontext/compositing/2d.composite.canvas.destination-atop.html"
       },
       {
@@ -23128,11 +23176,12 @@
       {
         "path": "webdriver/timeouts/page_load_timeouts_tests.py"
       },
       {
         "path": "webdriver/user_input/clear_test.py"
       }
     ]
   },
-  "local_changes": [],
+  "local_changes": [
+  ],
   "rev": "1b45197f111e5bb65607d89f7d385883849d005d"
-}
\ No newline at end of file
+}
diff --git a/testing/web-platform/meta/cache/cache-add.html.ini b/testing/web-platform/meta/cache/cache-add.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-add.html.ini
@@ -0,0 +1,2 @@
+[cache-add.html]
+  type: testharness
diff --git a/testing/web-platform/meta/cache/cache-delete.html.ini b/testing/web-platform/meta/cache/cache-delete.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-delete.html.ini
@@ -0,0 +1,2 @@
+[cache-delete.html]
+  type: testharness
diff --git a/testing/web-platform/meta/cache/cache-match.html.ini b/testing/web-platform/meta/cache/cache-match.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-match.html.ini
@@ -0,0 +1,2 @@
+[cache-match.html]
+  type: testharness
diff --git a/testing/web-platform/meta/cache/cache-put.html.ini b/testing/web-platform/meta/cache/cache-put.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-put.html.ini
@@ -0,0 +1,2 @@
+[cache-put.html]
+  type: testharness
diff --git a/testing/web-platform/meta/cache/cache-storage-keys.html.ini b/testing/web-platform/meta/cache/cache-storage-keys.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-storage-keys.html.ini
@@ -0,0 +1,2 @@
+[cache-storage-keys.html]
+  type: testharness
diff --git a/testing/web-platform/meta/cache/cache-storage.html.ini b/testing/web-platform/meta/cache/cache-storage.html.ini
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/meta/cache/cache-storage.html.ini
@@ -0,0 +1,2 @@
+[cache-storage.html]
+  type: testharness
diff --git a/testing/web-platform/tests/cache/cache-add-expected.txt b/testing/web-platform/tests/cache/cache-add-expected.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-add-expected.txt
@@ -0,0 +1,18 @@
+This is a testharness.js-based test.
+PASS Service Worker: Cache.add and Cache.addAll 
+PASS Cache.add called with no arguments 
+FAIL Cache.add called with relative URL specified as a string Cache is not implemented
+FAIL Cache.add called with non-HTTP/HTTPS URL assert_throws: Cache.add should throw a NetworkError for non-HTTP/HTTPS URLs. function "function () { throw e; }" threw object "NotSupportedError: Cache is not implemented" that is not a DOMException NetworkError: property "code" is equal to 9, expected 19
+FAIL Cache.add called with Request object Cache is not implemented
+FAIL Cache.add called with Request object with a used body assert_throws: Cache.add with a Request object with a used body should reject with a TypeError. function "function () { throw e; }" threw object "NotSupportedError: Cache is not implemented" ("NotSupportedError") expected object "TypeError" ("TypeError")
+FAIL Cache.add called twice with the same Request object Cache is not implemented
+FAIL Cache.add with request that results in a status of 404 Cache is not implemented
+FAIL Cache.add with request that results in a status of 500 Cache is not implemented
+PASS Cache.addAll with no arguments 
+PASS Cache.addAll with a mix of valid and undefined arguments 
+FAIL Cache.addAll with string URL arguments Cache is not implemented
+FAIL Cache.addAll with Request arguments Cache is not implemented
+FAIL Cache.addAll with a mix of succeeding and failing requests Cache is not implemented
+FAIL Cache.addAll called with the same Request object specified twice assert_throws: Cache.addAll should throw TypeError if the same request is added twice. function "function () { throw e; }" threw object "NotSupportedError: Cache is not implemented" ("NotSupportedError") expected object "TypeError" ("TypeError")
+Harness: the test ran to completion.
+
diff --git a/testing/web-platform/tests/cache/cache-add.html b/testing/web-platform/tests/cache/cache-add.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-add.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: Cache.add and Cache.addAll</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-add">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-add-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/cache-delete-expected.txt b/testing/web-platform/tests/cache/cache-delete-expected.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-delete-expected.txt
@@ -0,0 +1,11 @@
+This is a testharness.js-based test.
+PASS Service Worker: Cache.delete 
+PASS Cache.delete with no arguments 
+PASS Cache.delete called with a string URL 
+PASS Cache.delete called with a Request object 
+PASS Cache.delete with a Request object containing used body 
+PASS Cache.delete with a non-existent entry 
+FAIL Cache.delete with CacheQueryOptions.* assert_true: Cache.delete should resolve with "true" if an entry was successfully deleted. expected true got false
+PASS Cache.delete with CacheQueryOptions.* that don't match 
+Harness: the test ran to completion.
+
diff --git a/testing/web-platform/tests/cache/cache-delete.html b/testing/web-platform/tests/cache/cache-delete.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-delete.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: Cache.delete</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-delete">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-delete-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/cache-match-expected.txt b/testing/web-platform/tests/cache/cache-match-expected.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-match-expected.txt
@@ -0,0 +1,22 @@
+This is a testharness.js-based test.
+PASS Service Worker: Cache.match and Cache.matchAll 
+FAIL Cache.matchAll with URL Method is not implemented.
+FAIL Cache.match with URL assert_equals: Cache.match should match by URL.: Response.url expected "" but got "http://example.com/a"
+FAIL Cache.matchAll with Request Method is not implemented.
+FAIL Cache.match with Request assert_equals: Cache.match should match by Request.: Response.url expected "" but got "http://example.com/a"
+FAIL Cache.matchAll with new Request Method is not implemented.
+FAIL Cache.match with new Request assert_equals: Cache.match should match by Request.: Response.url expected "" but got "http://example.com/a"
+PASS Cache.match with Request containing non-empty body 
+FAIL Cache.matchAll with ignoreSearch option (request with no search parameters) Method is not implemented.
+FAIL Cache.matchAll with ignoreSearch option (request with search parameter) Method is not implemented.
+FAIL Cache.matchAll with request containing hash Method is not implemented.
+FAIL Cache.matchAll with string fragment "http" as query Method is not implemented.
+FAIL Cache.matchAll with prefixMatch option Method is not implemented.
+FAIL Cache.matchAll with prefixMatch option Method is not implemented.
+FAIL Cache.matchAll with responses containing "Vary" header assert_unreached: Test setup failed: Entry already exists. Reached unreachable code
+FAIL Cache.match with responses containing "Vary" header assert_unreached: Test setup failed: Entry already exists. Reached unreachable code
+FAIL Cache.matchAll with "ignoreVary" parameter assert_unreached: Test setup failed: Entry already exists. Reached unreachable code
+FAIL Cache.match with Request and Response objects with different URLs assert_equals: Cache.match should reutrn a Response object that has the same properties as the stored response.: Response.url expected "http://127.0.0.1:8000/serviceworker/resources/simple.txt" but got "http://example.com/"
+PASS Cache.match invoked multiple times for the same Request/Response 
+Harness: the test ran to completion.
+
diff --git a/testing/web-platform/tests/cache/cache-match.html b/testing/web-platform/tests/cache/cache-match.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-match.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: Cache.match and Cache.matchAll</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-match">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-match-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/cache-put-expected.txt b/testing/web-platform/tests/cache/cache-put-expected.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-put-expected.txt
@@ -0,0 +1,17 @@
+This is a testharness.js-based test.
+PASS Service Worker: Cache.put 
+PASS Cache.put called with simple Request and Response 
+PASS Cache.put called with Request and Response from fetch() 
+FAIL Cache.put with Request containing a body assert_equals: Cache.put should store response body.: Response.url expected "" but got "https://example.com/foo"
+FAIL Cache.put with a Response containing an empty URL assert_equals: Cache.put should update the cache with new Request and Response.: Response.url expected "" but got "https://example.com/foo"
+PASS Cache.put with an empty response body 
+PASS Cache.put with HTTP 500 response 
+FAIL Cache.put called twice with same Request and different Responses Entry already exists.
+PASS Cache.put with an string request 
+PASS Cache.put with an invalid response 
+PASS Cache.put with a non-HTTP/HTTPS request 
+FAIL Cache.put with a relative URL assert_equals: Cache.put should accept a relative URL as the request.: Response.url expected "" but got "http://127.0.0.1:8000/serviceworker/resources/relative-url"
+PASS Cache.put with a non-GET request 
+PASS Cache.put with an empty response 
+Harness: the test ran to completion.
+
diff --git a/testing/web-platform/tests/cache/cache-put.html b/testing/web-platform/tests/cache/cache-put.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-put.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: Cache.put</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-put">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-put-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/cache-storage-keys.html b/testing/web-platform/tests/cache/cache-storage-keys.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-storage-keys.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: CacheStorage.keys</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-storage">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-storage-keys-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/cache-storage.html b/testing/web-platform/tests/cache/cache-storage.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/cache-storage.html
@@ -0,0 +1,9 @@
+<!DOCTYPE html>
+<title>Service Worker: CacheStorage</title>
+<link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#cache-storage">
+<script src="/resources/testharness.js"></script>
+<script src="/resources/testharnessreport.js"></script>
+<script src="resources/test-helpers.js"></script>
+<script>
+service_worker_test('resources/cache-storage-worker.js');
+</script>
diff --git a/testing/web-platform/tests/cache/resources/appcache-ordering.install.html b/testing/web-platform/tests/cache/resources/appcache-ordering.install.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/appcache-ordering.install.html
@@ -0,0 +1,26 @@
+<html manifest="appcache-ordering.manifest">
+<script>
+var handled = false;
+
+function installComplete() {
+  if (handled)
+    return;
+  handled = true;
+  window.parent.notify_appcache_installed(true);
+}
+
+function installFailed() {
+  if (handled)
+    return;
+  handled = true;
+  window.parent.notify_appcache_installed(false);
+}
+
+applicationCache.oncached = installComplete;
+applicationCache.onnoupdate = installComplete;
+applicationCache.onupdateready = installFailed;
+applicationCache.onerror = installFailed;
+applicationCache.onobsolete = installFailed;
+
+</script>
+</html>
diff --git a/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.html b/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.html
@@ -0,0 +1,13 @@
+<html> <!-- Intentionally does NOT include a manifest attribute -->
+<body>
+<!-- This should FALLBACK to ordering.is_appcached.js as specified in manifest
+     when the appcache is present -->
+<script src="appcache-ordering.is-appcached404.js"></script>
+<script>
+
+// If the script of the fallback resource loaded, is_appcached will be defined.
+window.parent.notify_is_appcached(typeof is_appcached != 'undefined');
+
+</script>
+</body>
+</html>
diff --git a/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.js b/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/appcache-ordering.is-appcached.js
@@ -0,0 +1,1 @@
+var is_appcached = true;
diff --git a/testing/web-platform/tests/cache/resources/appcache-ordering.manifest b/testing/web-platform/tests/cache/resources/appcache-ordering.manifest
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/appcache-ordering.manifest
@@ -0,0 +1,7 @@
+CACHE MANIFEST
+
+appcache-ordering.is-appcached.html
+
+FALLBACK:
+appcache-ordering.is-appcached404.js appcache-ordering.is-appcached.js
+
diff --git a/testing/web-platform/tests/cache/resources/blank.html b/testing/web-platform/tests/cache/resources/blank.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/blank.html
@@ -0,0 +1,2 @@
+<!DOCTYPE html>
+<title>Empty doc</title>
diff --git a/testing/web-platform/tests/cache/resources/cache-add-worker.js b/testing/web-platform/tests/cache/resources/cache-add-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-add-worker.js
@@ -0,0 +1,146 @@
+importScripts('worker-testharness.js');
+importScripts('/resources/testharness-helpers.js');
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.add(),
+      new TypeError(),
+      'Cache.add should throw a TypeError when no arguments are given.');
+  }, 'Cache.add called with no arguments');
+
+cache_test(function(cache) {
+    return cache.add('simple.txt')
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.add should resolve with undefined on success.');
+        });
+  }, 'Cache.add called with relative URL specified as a string');
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.add('javascript://this-is-not-http-mmkay'),
+      'NetworkError',
+      'Cache.add should throw a NetworkError for non-HTTP/HTTPS URLs.');
+  }, 'Cache.add called with non-HTTP/HTTPS URL');
+
+cache_test(function(cache) {
+    var request = new Request('simple.txt', {body: 'Hello'});
+    return cache.add(request)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.add should resolve with undefined on success.');
+        });
+  }, 'Cache.add called with Request object');
+
+cache_test(function(cache) {
+    var request = new Request('simple.txt', {body: 'Hello'});
+    return request.text()
+      .then(function() {
+          assert_true(request.bodyUsed);
+        })
+      .then(function() {
+          return assert_promise_rejects(
+            cache.add(request),
+            new TypeError(),
+            'Cache.add with a Request object with a used body should reject ' +
+            'with a TypeError.');
+        });
+  }, 'Cache.add called with Request object with a used body');
+
+cache_test(function(cache) {
+    var request = new Request('simple.txt', {body: 'Hello'});
+    return cache.add(request)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.add should resolve with undefined on success.');
+        })
+      .then(function() {
+          return assert_promise_rejects(
+            cache.add(request),
+            new TypeError(),
+            'Cache.add should throw TypeError if same request is added twice.');
+        });
+  }, 'Cache.add called twice with the same Request object');
+
+cache_test(function(cache) {
+    return cache.add('this-does-not-exist-please-dont-create-it')
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.add should resolve with undefined on success.');
+        });
+  }, 'Cache.add with request that results in a status of 404');
+
+cache_test(function(cache) {
+    return cache.add('fetch-status.php?status=500')
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.add should resolve with undefined on success.');
+        });
+  }, 'Cache.add with request that results in a status of 500');
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.addAll(),
+      new TypeError(),
+      'Cache.addAll with no arguments should throw TypeError.');
+  }, 'Cache.addAll with no arguments');
+
+cache_test(function(cache) {
+    // Assumes the existence of simple.txt and blank.html in the same directory
+    // as this test script.
+    var urls = ['simple.txt', undefined, 'blank.html'];
+    return assert_promise_rejects(
+      cache.addAll(),
+      new TypeError(),
+      'Cache.addAll should throw TypeError for an undefined argument.');
+  }, 'Cache.addAll with a mix of valid and undefined arguments');
+
+cache_test(function(cache) {
+    // Assumes the existence of simple.txt and blank.html in the same directory
+    // as this test script.
+    var urls = ['simple.txt', self.location.href, 'blank.html'];
+    return cache.addAll(urls)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.addAll should resolve with undefined on success.');
+        });
+  }, 'Cache.addAll with string URL arguments');
+
+cache_test(function(cache) {
+    // Assumes the existence of simple.txt and blank.html in the same directory
+    // as this test script.
+    var urls = ['simple.txt', self.location.href, 'blank.html'];
+    var requests = urls.map(function(url) {
+        return new Request(url);
+      });
+    return cache.addAll(requests)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.addAll should resolve with undefined on ' +
+                        'success.');
+        });
+  }, 'Cache.addAll with Request arguments');
+
+cache_test(function(cache) {
+    // Assumes that simple.txt and blank.html exist. The second
+    // resource does not.
+    var urls = ['simple.txt', 'this-resource-should-not-exist', 'blank.html'];
+    var requests = urls.map(function(url) {
+        return new Request(url);
+      });
+    return cache.addAll(requests)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.addAll should resolve with undefined on ' +
+                        'success.');
+        });
+  }, 'Cache.addAll with a mix of succeeding and failing requests');
+
+cache_test(function(cache) {
+    var request = new Request('simple.txt');
+    return assert_promise_rejects(
+      cache.addAll([request, request]),
+      new TypeError(),
+      'Cache.addAll should throw TypeError if the same request is added ' +
+      'twice.');
+  }, 'Cache.addAll called with the same Request object specified twice');
diff --git a/testing/web-platform/tests/cache/resources/cache-delete-worker.js b/testing/web-platform/tests/cache/resources/cache-delete-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-delete-worker.js
@@ -0,0 +1,156 @@
+importScripts('worker-testharness.js');
+importScripts('/resources/testharness-helpers.js');
+
+var test_url = 'https://example.com/foo';
+
+// Construct a generic Request object. The URL is |test_url|. All other fields
+// are defaults.
+function new_test_request() {
+  return new Request(test_url);
+}
+
+// Construct a generic Response object.
+function new_test_response() {
+  return new Response('Hello world!', { status: 200 });
+}
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.delete(),
+      new TypeError(),
+      'Cache.delete should reject with a TypeError when called with no ' +
+      'arguments.');
+  }, 'Cache.delete with no arguments');
+
+cache_test(function(cache) {
+    return cache.put(new_test_request(), new_test_response())
+      .then(function() {
+          return cache.delete(test_url);
+        })
+      .then(function(result) {
+          assert_true(result,
+                      'Cache.delete should resolve with "true" if an entry ' +
+                      'was successfully deleted.');
+        })
+      .then(function() {
+          assert_promise_rejects(
+            cache.match(test_url),
+            'NotFoundError',
+            'Cache.delete should remove matching entries from cache.');
+        });
+  }, 'Cache.delete called with a string URL');
+
+cache_test(function(cache) {
+    var request = new Request(test_url, { body: 'Abc' });
+    return cache.put(request.clone(), new_test_response())
+      .then(function() {
+          return cache.delete(request);
+        })
+      .then(function(result) {
+          assert_true(result,
+                      'Cache.delete should resolve with "true" if an entry ' +
+                      'was successfully deleted.');
+          assert_false(request.bodyUsed,
+                       'Cache.delete should not consume request body.');
+        });
+  }, 'Cache.delete called with a Request object');
+
+cache_test(function(cache) {
+    var request = new Request(test_url, { body: 'Abc' });
+    return cache.put(request.clone(), new_test_response())
+      .then(function() {
+          return request.text();
+        })
+      .then(function() {
+          assert_true(request.bodyUsed,
+                      '[https://fetch.spec.whatwg.org/#body-mixin] ' +
+                      'Request.bodyUsed should be true after text() method ' +
+                      'resolves.');
+        })
+      .then(function() {
+          return cache.delete(request);
+        })
+      .then(function(result) {
+          assert_true(result,
+                      'Cache.delete should resolve with "true" if an entry ' +
+                      'was successfully deleted.');
+        });
+  }, 'Cache.delete with a Request object containing used body');
+
+cache_test(function(cache) {
+    return cache.delete(test_url)
+      .then(function(result) {
+          assert_false(result,
+                       'Cache.delete should resolve with "false" if there ' +
+                       'are no matching entries.');
+        });
+  }, 'Cache.delete with a non-existent entry');
+
+var cache_entries = {
+  a: {
+    request: new Request('http://example.com/abc'),
+    response: new Response('')
+  },
+
+  b: {
+    request: new Request('http://example.com/b'),
+    response: new Response('')
+  },
+
+  a_with_query: {
+    request: new Request('http://example.com/abc?q=r'),
+    response: new Response('')
+  }
+};
+
+function prepopulated_cache_test(test_function, description) {
+  cache_test(function(cache) {
+      return Promise.all(Object.keys(cache_entries).map(function(k) {
+          return cache.put(cache_entries[k].request.clone(),
+                           cache_entries[k].response.clone());
+        }))
+        .then(function() {
+            return test_function(cache);
+          });
+    }, description);
+}
+
+// Note that these tests don't exercise the full gamut of CacheQueryOptions.
+// That's left for the Cache.match() and Cache.matchAll() tests. The objective
+// is to test that CacheQueryOptions, if specified, are used.
+
+prepopulated_cache_test(function(cache) {
+    return cache.delete('http://example.com/a', { prefixMatch: true })
+      .then(function(result) {
+          assert_true(result,
+                      'Cache.delete should resolve with "true" if an entry ' +
+                      'was successfully deleted.');
+        })
+      .then(function() {
+          return Promise.all([].concat(
+            // The entries 'a' and 'a_with_query' should have been deleted.
+            ['a', 'a_with_query'].map(function(k) {
+                return assert_promise_rejects(
+                  cache.match(cache_entries[k].request.url),
+                  'NotFoundError',
+                  'Cache.delete should respect "prefixMatch" option.');
+              }),
+            // The entry 'b' should still be in the cache.
+            cache.match(cache_entries.b.request.url)
+              .catch(function() {
+                  assert_unreached('Cache.delete should respect ' +
+                                   '"prefixMatch" option.');
+                })
+            ));
+        });
+  }, 'Cache.delete with CacheQueryOptions.*');
+
+prepopulated_cache_test(function(cache) {
+    return cache.delete('http://example.com/ac', { prefixMatch: true })
+      .then(function(result) {
+          assert_false(result,
+                       'Cache.delete should resolve with "false" if there ' +
+                       'are no matching entries.');
+        });
+  }, 'Cache.delete with CacheQueryOptions.* that don\'t match');
+
diff --git a/testing/web-platform/tests/cache/resources/cache-match-worker.js b/testing/web-platform/tests/cache/resources/cache-match-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-match-worker.js
@@ -0,0 +1,402 @@
+importScripts('worker-testharness.js');
+importScripts('/resources/testharness-helpers.js');
+
+// A set of Request/Response pairs to be used with prepopulated_cache_test().
+var simple_entries = {
+  a: {
+    request: new Request('http://example.com/a'),
+    response: new Response('')
+  },
+
+  b: {
+    request: new Request('http://example.com/b'),
+    response: new Response('')
+  },
+
+  a_with_query: {
+    request: new Request('http://example.com/a?q=r'),
+    response: new Response('')
+  },
+
+  A: {
+    request: new Request('http://example.com/A'),
+    response: new Response('')
+  },
+
+  a_https: {
+    request: new Request('https://example.com/a'),
+    response: new Response('')
+  },
+
+  a_org: {
+    request: new Request('http://example.org/a'),
+    response: new Response('')
+  },
+
+  cat: {
+    request: new Request('http://example.com/cat'),
+    response: new Response('')
+  },
+
+  cat_with_fragment: {
+    request: new Request('http://example.com/cat#mouse'),
+    response: new Response('')
+  },
+
+  cat_in_the_hat: {
+    request: new Request('http://example.com/cat/in/the/hat'),
+    response: new Response('')
+  }
+};
+
+// A set of Request/Response pairs to be used with prepopulated_cache_test().
+// These contain a mix of test cases that use Vary headers.
+var vary_entries = {
+  no_vary_header: {
+    request: new Request('http://example.com/c'),
+    response: new Response('')
+  },
+
+  vary_cookie_is_cookie: {
+    request: new Request('http://example.com/c',
+                         {headers: {'Cookies': 'is-for-cookie'}}),
+    response: new Response('',
+                           {headers: {'Vary': 'Cookies'}})
+  },
+
+  vary_cookie_is_good: {
+    request: new Request('http://example.com/c',
+                         {headers: {'Cookies': 'is-good-enough-for-me'}}),
+    response: new Response('',
+                           {headers: {'Vary': 'Cookies'}})
+  },
+
+  vary_cookie_absent: {
+    request: new Request('http://example.com/c'),
+    response: new Response('',
+                           {headers: {'Vary': 'Cookies'}})
+  },
+
+  vary_wildcard: {
+    request: new Request('http://example.com/c',
+                         {headers: {'Cookies': 'x', 'X-Key': '1'}}),
+    response: new Response('',
+                           {headers: {'Vary': '*'}})
+  }
+};
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(simple_entries.a.request.url)
+      .then(function(result) {
+          assert_array_objects_equals(result, [simple_entries.a.response],
+                                      'Cache.matchAll should match by URL.');
+        });
+  }, 'Cache.matchAll with URL');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.match(simple_entries.a.request.url)
+      .then(function(result) {
+          assert_object_equals(result, simple_entries.a.response,
+                               'Cache.match should match by URL.');
+        });
+  }, 'Cache.match with URL');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(simple_entries.a.request)
+      .then(function(result) {
+          assert_array_objects_equals(
+            result, [simple_entries.a.response],
+            'Cache.matchAll should match by Request.');
+        });
+  }, 'Cache.matchAll with Request');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.match(simple_entries.a.request)
+      .then(function(result) {
+          assert_object_equals(result, simple_entries.a.response,
+                               'Cache.match should match by Request.');
+        });
+  }, 'Cache.match with Request');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(new Request(simple_entries.a.request.url))
+      .then(function(result) {
+          assert_array_objects_equals(
+            result, [simple_entries.a.response],
+            'Cache.matchAll should match by Request.');
+        });
+  }, 'Cache.matchAll with new Request');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.match(new Request(simple_entries.a.request.url))
+      .then(function(result) {
+          assert_object_equals(result, simple_entries.a.response,
+                               'Cache.match should match by Request.');
+        });
+  }, 'Cache.match with new Request');
+
+cache_test(function(cache) {
+    var request = new Request('https://example.com/foo', {
+        method: 'GET',
+        body: 'Hello world!'
+      });
+    var response = new Response('Booyah!', {
+        status: 200,
+        headers: {'Content-Type': 'text/plain'}
+      });
+
+    return cache.put(request.clone(), response.clone())
+      .then(function() {
+          assert_false(
+            request.bodyUsed,
+            '[https://fetch.spec.whatwg.org/#concept-body-used-flag] ' +
+            'Request.bodyUsed flag should be initially false.');
+        })
+      .then(function() {
+          return cache.match(request);
+        })
+      .then(function(result) {
+          assert_false(request.bodyUsed,
+                       'Cache.match should not consume Request body.');
+        });
+  }, 'Cache.match with Request containing non-empty body');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(simple_entries.a.request,
+                          {ignoreSearch: true})
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              simple_entries.a.response,
+              simple_entries.a_with_query.response
+            ],
+            'Cache.matchAll with ignoreSearch should ignore the ' +
+            'search parameters of cached request.');
+        });
+  },
+  'Cache.matchAll with ignoreSearch option (request with no search ' +
+  'parameters)');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(simple_entries.a_with_query.request,
+                          {ignoreSearch: true})
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              simple_entries.a.response,
+              simple_entries.a_with_query.response
+            ],
+            'Cache.matchAll with ignoreSearch should ignore the ' +
+            'search parameters of request.');
+        });
+  },
+  'Cache.matchAll with ignoreSearch option (request with search parameter)');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll(simple_entries.cat.request)
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              simple_entries.cat.response,
+              simple_entries.cat_with_fragment.response
+            ],
+            'Cache.matchAll should ignore URL hash.');
+        });
+  }, 'Cache.matchAll with request containing hash');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll('http')
+      .then(function(result) {
+          assert_array_equivalent(
+            result, [],
+            'Cache.matchAll should treat query as a URL and not ' +
+            'just a string fragment.');
+        });
+  }, 'Cache.matchAll with string fragment "http" as query');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll('http://example.com/cat',
+                          {prefixMatch: true})
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              simple_entries.cat.response,
+              simple_entries.cat_with_fragment.response,
+              simple_entries.cat_in_the_hat.response
+            ],
+            'Cache.matchAll should honor prefixMatch.');
+        });
+  }, 'Cache.matchAll with prefixMatch option');
+
+prepopulated_cache_test(simple_entries, function(cache) {
+    return cache.matchAll('http://example.com/cat/',
+                          {prefixMatch: true})
+      .then(function(result) {
+          assert_array_equivalent(
+            result, [simple_entries.cat_in_the_hat.response],
+            'Cache.matchAll should honor prefixMatch.');
+        });
+  }, 'Cache.matchAll with prefixMatch option');
+
+prepopulated_cache_test(vary_entries, function(cache) {
+    return cache.matchAll('http://example.com/c')
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              vary_entries.no_vary_header.response,
+              vary_entries.vary_wildcard.response,
+              vary_entries.vary_cookie_absent.response
+            ],
+            'Cache.matchAll should exclude matches if a vary header is ' +
+            'missing in the query request, but is present in the cached ' +
+            'request.');
+        })
+
+      .then(function() {
+          return cache.matchAll(
+            new Request('http://example.com/c',
+                        {headers: {'Cookies': 'none-of-the-above'}}));
+        })
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              vary_entries.no_vary_header.response,
+              vary_entries.vary_wildcard.response
+            ],
+            'Cache.matchAll should exclude matches if a vary header is ' +
+            'missing in the cached request, but is present in the query ' +
+            'request.');
+        })
+
+      .then(function() {
+          return cache.matchAll(
+            new Request('http://example.com/c',
+                        {headers: {'Cookies': 'is-for-cookie'}}));
+        })
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [vary_entries.vary_cookie_is_cookie.response],
+            'Cache.matchAll should match the entire header if a vary header ' +
+            'is present in both the query and cached requests.');
+        });
+  }, 'Cache.matchAll with responses containing "Vary" header');
+
+prepopulated_cache_test(vary_entries, function(cache) {
+    return cache.match('http://example.com/c')
+      .then(function(result) {
+          assert_object_in_array(
+            result,
+            [
+              vary_entries.no_vary_header.response,
+              vary_entries.vary_wildcard.response,
+              vary_entries.vary_cookie_absent.response
+            ],
+            'Cache.match should honor "Vary" header.');
+        });
+  }, 'Cache.match with responses containing "Vary" header');
+
+prepopulated_cache_test(vary_entries, function(cache) {
+    return cache.matchAll('http://example.com/c',
+                          {ignoreVary: true})
+      .then(function(result) {
+          assert_array_equivalent(
+            result,
+            [
+              vary_entries.no_vary_header.response,
+              vary_entries.vary_cookie_is_cookie.response,
+              vary_entries.vary_cookie_is_good.response,
+              vary_entries.vary_cookie_absent.response,
+              vary_entries.vary_wildcard.response
+            ],
+            'Cache.matchAll should honor "ignoreVary" parameter.');
+        });
+  }, 'Cache.matchAll with "ignoreVary" parameter');
+
+cache_test(function(cache) {
+    var request = new Request('http://example.com');
+    var response;
+    var request_url = new URL('simple.txt', location.href).href;
+    return fetch(request_url)
+      .then(function(fetch_result) {
+          response = fetch_result;
+          assert_equals(
+            response.url, request_url,
+            '[https://fetch.spec.whatwg.org/#dom-response-url] ' +
+            'Reponse.url should return the URL of the response.');
+          return cache.put(request, response);
+        })
+      .then(function() {
+          return cache.match(request.url);
+        })
+      .then(function(result) {
+          assert_object_equals(
+            result, response,
+            'Cache.match should reutrn a Response object that has the same ' +
+            'properties as the stored response.');
+        })
+      .then(function() {
+          return assert_promise_rejects(
+            cache.match(response.url),
+            'NotFoundError',
+            'Cache.match should not match cache entry based on response URL.');
+        });
+  }, 'Cache.match with Request and Response objects with different URLs');
+
+cache_test(function(cache) {
+    var request_url = new URL('simple.txt', location.href).href;
+    return fetch(request_url)
+      .then(function(fetch_result) {
+          return cache.put(new Request(request_url), fetch_result);
+        })
+      .then(function() {
+          return cache.match(request_url);
+        })
+      .then(function(result) {
+          return result.text();
+        })
+      .then(function(body_text) {
+          assert_equals(body_text, 'a simple text file\n',
+                        'Cache.match should return a Response object with a ' +
+                        'valid body.');
+        })
+      .then(function() {
+          return cache.match(request_url);
+        })
+      .then(function(result) {
+          return result.text();
+        })
+      .then(function(body_text) {
+          assert_equals(body_text, 'a simple text file\n',
+                        'Cache.match should return a Response object with a ' +
+                        'valid body each time it is called.');
+        });
+  }, 'Cache.match invoked multiple times for the same Request/Response');
+
+// Helpers ---
+
+// Run |test_function| with a Cache object as its only parameter. Prior to the
+// call, the Cache is populated by cache entries from |entries|. The latter is
+// expected to be an Object mapping arbitrary keys to objects of the form
+// {request: <Request object>, response: <Response object>}.
+//
+// |test_function| should return a Promise that can be used with promise_test.
+function prepopulated_cache_test(entries, test_function, description) {
+  cache_test(function(cache) {
+      return Promise.all(Object.keys(entries).map(function(k) {
+          return cache.put(entries[k].request, entries[k].response);
+        }))
+        .catch(function(reason) {
+            assert_unreached('Test setup failed: ' + reason.message);
+          })
+        .then(function() {
+            return test_function(cache);
+          });
+    }, description);
+}
diff --git a/testing/web-platform/tests/cache/resources/cache-put-worker.js b/testing/web-platform/tests/cache/resources/cache-put-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-put-worker.js
@@ -0,0 +1,207 @@
+importScripts('worker-testharness.js');
+importScripts('/resources/testharness-helpers.js');
+
+var test_url = 'https://example.com/foo';
+
+// Construct a generic Request object. The URL is |test_url|. All other fields
+// are defaults.
+function new_test_request() {
+  return new Request(test_url);
+}
+
+// Construct a generic Response object. The URL is empty. If specified |body|
+// will be set as the response body string.
+function new_test_response(body) {
+  body = body || 'Hello world!';
+  return new Response(body, {
+      status: 200,
+      statusText: 'OK',
+      headers: [['Content-Type', 'text/plain']]
+    });
+}
+
+cache_test(function(cache) {
+    var request = new_test_request();
+    var response = new_test_response();
+    return cache.put(request, response)
+      .then(function(result) {
+          assert_equals(result, undefined,
+                        'Cache.put should resolve with undefined on success.');
+        });
+  }, 'Cache.put called with simple Request and Response');
+
+cache_test(function(cache) {
+    var test_url = new URL('simple.txt', location.href).href;
+    var request = new Request(test_url);
+    var response;
+    return fetch(test_url)
+        .then(function(fetch_result) {
+          response = fetch_result.clone();
+          return cache.put(request, fetch_result);
+        })
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_object_equals(result, response,
+                               'Cache.put should update the cache with ' +
+                               'new request and response.');
+          return result.text();
+        })
+      .then(function(body) {
+          assert_equals(body, 'a simple text file\n',
+                        'Cache.put should store response body.');
+        });
+  }, 'Cache.put called with Request and Response from fetch()');
+
+cache_test(function(cache) {
+    var request = new Request(test_url, {
+        method: 'GET',
+        body: 'Hello'
+      });
+    var response = new_test_response();
+    assert_false(request.bodyUsed,
+                 '[https://fetch.spec.whatwg.org/#dom-body-bodyused] ' +
+                 'Request.bodyUsed should be initially false.');
+    return cache.put(request, response)
+      .then(function() {
+          assert_false(request.bodyUsed,
+                       'Cache.put should not consume Request body.');
+        })
+      .then(function() {
+          return cache.match(request);
+        })
+      .then(function(result) {
+          assert_object_equals(result, response,
+                               'Cache.put should store response body.');
+        });
+  }, 'Cache.put with Request containing a body');
+
+cache_test(function(cache) {
+    var request = new_test_request();
+    var response = new_test_response();
+    return cache.put(request, response)
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_object_equals(result, response,
+                               'Cache.put should update the cache with ' +
+                               'new Request and Response.');
+        });
+  }, 'Cache.put with a Response containing an empty URL');
+
+cache_test(function(cache) {
+    var request = new_test_request();
+    var response = new Response('', {
+        status: 200,
+        headers: [['Content-Type', 'text/plain']]
+      });
+    return cache.put(request, response)
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_equals(result.status, 200, 'Cache.put should store status.');
+          assert_equals(result.headers.get('Content-Type'), 'text/plain',
+                        'Cache.put should store headers.');
+          return result.text();
+        })
+      .then(function(body) {
+          assert_equals(body, '',
+                        'Cache.put should store response body.');
+        });
+  }, 'Cache.put with an empty response body');
+
+cache_test(function(cache) {
+    var test_url = new URL('fetch-status.php?status=500', location.href).href;
+    var request = new Request(test_url);
+    var response;
+    return fetch(test_url)
+      .then(function(fetch_result) {
+          response = fetch_result.clone();
+          return cache.put(request, fetch_result);
+        })
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_object_equals(result, response,
+                               'Cache.put should update the cache with ' +
+                               'new request and response.');
+          return result.text();
+        })
+      .then(function(body) {
+          assert_equals(body, '',
+                        'Cache.put should store response body.');
+        });
+  }, 'Cache.put with HTTP 500 response');
+
+cache_test(function(cache) {
+  var alternate_response = new_test_response('Lorem ipsum');
+    return cache.put(new_test_request(), new_test_response())
+      .then(function() {
+          return cache.put(new_test_request(), alternate_response);
+        })
+      .then(function() {
+          return cache.match(test_url);
+        })
+      .then(function(result) {
+          assert_object_equals(result, alternate_response,
+                               'Cache.put should replace existing ' +
+                               'response with new response.');
+        });
+  }, 'Cache.put called twice with same Request and different Responses');
+
+cache_test(function(cache) {
+    var url = 'http://example.com/foo';
+    return cache.put(url, new_test_response('some body'))
+      .then(function() { return cache.match(url); })
+      .then(function(response) { return response.text(); })
+      .then(function(body) {
+          assert_equals(body, 'some body',
+                        'Cache.put should accept a string as request.');
+      });
+  }, 'Cache.put with an string request');
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.put(new_test_request(), 'Hello world!'),
+      new TypeError(),
+      'Cache.put should only accept a Response object as the response.');
+  }, 'Cache.put with an invalid response');
+
+cache_test(function(cache) {
+  return assert_promise_rejects(
+      cache.put(new Request('file:///etc/passwd'), new_test_response()),
+      new TypeError(),
+      'Cache.put should reject non-HTTP/HTTPS requests with a TypeError.');
+  }, 'Cache.put with a non-HTTP/HTTPS request');
+
+cache_test(function(cache) {
+  var response = new_test_response();
+    return cache.put(new Request('relative-url'), response)
+      .then(function() {
+          return cache.match(new URL('relative-url', location.href).href);
+        })
+      .then(function(result) {
+          assert_object_equals(result, response,
+                               'Cache.put should accept a relative URL ' +
+                               'as the request.');
+        });
+  }, 'Cache.put with a relative URL');
+
+cache_test(function(cache) {
+    var request = new Request('http://example.com/foo', {method: 'HEAD'});
+    return assert_promise_rejects(
+      cache.put(request, new_test_response()),
+      new TypeError(),
+      'Cache.put should throw a TypeError for non-GET requests.');
+  }, 'Cache.put with a non-GET request');
+
+cache_test(function(cache) {
+    return assert_promise_rejects(
+      cache.put(new_test_request(), null),
+      new TypeError(),
+      'Cache.put should throw a TypeError for an empty response.');
+  }, 'Cache.put with an empty response');
diff --git a/testing/web-platform/tests/cache/resources/cache-storage-keys-worker.js b/testing/web-platform/tests/cache/resources/cache-storage-keys-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-storage-keys-worker.js
@@ -0,0 +1,31 @@
+importScripts('worker-testharness.js');
+importScripts('../../resources/testharness-helpers.js');
+
+var test_cache_list =
+  ['', 'example', 'Another cache name', 'A', 'a', 'ex ample'];
+
+promise_test(function(test) {
+    return self.caches.keys()
+      .then(function(keys) {
+          assert_true(Array.isArray(keys),
+                      'CacheStorage.keys should return an Array.');
+          return Promise.all(keys.map(function(key) {
+              return self.caches.delete(key);
+            }));
+        })
+      .then(function() {
+          return Promise.all(test_cache_list.map(function(key) {
+              return self.caches.open(key);
+            }));
+        })
+
+      .then(function() { return self.caches.keys(); })
+      .then(function(keys) {
+          assert_true(Array.isArray(keys),
+                      'CacheStorage.keys should return an Array.');
+          assert_array_equals(keys,
+                              test_cache_list,
+                              'CacheStorage.keys should only return ' +
+                              'existing caches.');
+        });
+  }, 'CacheStorage keys');
diff --git a/testing/web-platform/tests/cache/resources/cache-storage-worker.js b/testing/web-platform/tests/cache/resources/cache-storage-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/cache-storage-worker.js
@@ -0,0 +1,162 @@
+importScripts('worker-testharness.js');
+importScripts('../../resources/testharness-helpers.js');
+
+promise_test(function(t) {
+    var cache_name = 'cache-storage/foo';
+    return self.caches.delete(cache_name)
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function(cache) {
+          assert_true(cache instanceof Cache,
+                      'CacheStorage.open should return a Cache.');
+        });
+  }, 'CacheStorage.open');
+
+promise_test(function(t) {
+    // Note that this test may collide with other tests running in the same
+    // origin that also uses an empty cache name.
+    var cache_name = '';
+    return self.caches.delete(cache_name)
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function(cache) {
+          assert_true(cache instanceof Cache,
+                      'CacheStorage.open should accept an empty name.');
+        });
+  }, 'CacheStorage.open with an empty name');
+
+promise_test(function(t) {
+    return assert_promise_rejects(
+      self.caches.open(),
+      new TypeError(),
+      'CacheStorage.open should throw TypeError if called with no arguments.');
+  }, 'CacheStorage.open with no arguments');
+
+promise_test(function(t) {
+    var test_cases = [
+      {
+        name: 'cache-storage/lowercase',
+        should_not_match:
+          [
+            'cache-storage/Lowercase',
+            ' cache-storage/lowercase',
+            'cache-storage/lowercase '
+          ]
+      },
+      {
+        name: 'cache-storage/has a space',
+        should_not_match:
+          [
+            'cache-storage/has'
+          ]
+      },
+      {
+        name: 'cache-storage/has\000_in_the_name',
+        should_not_match:
+          [
+            'cache-storage/has',
+            'cache-storage/has_in_the_name'
+          ]
+      }
+    ];
+    return Promise.all(test_cases.map(function(testcase) {
+        var cache_name = testcase.name;
+        return self.caches.delete(cache_name)
+          .then(function() {
+              return self.caches.open(cache_name);
+            })
+          .then(function() {
+              return self.caches.has(cache_name);
+            })
+          .then(function(result) {
+              assert_true(result,
+                          'CacheStorage.has should return true for existing ' +
+                          'cache.');
+            })
+          .then(function() {
+              return Promise.all(
+                testcase.should_not_match.map(function(cache_name) {
+                    return self.caches.has(cache_name)
+                      .then(function(result) {
+                          assert_false(result,
+                                       'CacheStorage.has should only perform ' +
+                                       'exact matches on cache names.');
+                        });
+                  }));
+            })
+          .then(function() {
+              return self.caches.delete(cache_name);
+            });
+      }));
+  }, 'CacheStorage.has with existing cache');
+
+promise_test(function(t) {
+    return self.caches.has('cheezburger')
+      .then(function(result) {
+          assert_false(result,
+                       'CacheStorage.has should return false for ' +
+                       'nonexistent cache.');
+        });
+  }, 'CacheStorage.has with nonexistent cache');
+
+promise_test(function(t) {
+    var cache_name = 'cache-storage/open';
+    var cache;
+    return self.caches.delete(cache_name)
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function(result) {
+          cache = result;
+        })
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function(result) {
+          assert_equals(result, cache,
+                        'CacheStorage.open should return the named Cache ' +
+                        'object if it exists.');
+        })
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function(result) {
+          assert_equals(result, cache,
+                        'CacheStorage.open should return the same ' +
+                        'instance of an existing Cache object.');
+        });
+  }, 'CacheStorage.open with existing cache');
+
+promise_test(function(t) {
+    var cache_name = 'cache-storage/delete';
+
+    return self.caches.delete(cache_name)
+      .then(function() {
+          return self.caches.open(cache_name);
+        })
+      .then(function() { return self.caches.delete(cache_name); })
+      .then(function(result) {
+          assert_true(result,
+                      'CacheStorage.delete should return true after ' +
+                      'deleting an existing cache.');
+        })
+
+      .then(function() { return self.caches.has(cache_name); })
+      .then(function(cache_exists) {
+          assert_false(cache_exists,
+                       'CacheStorage.has should return false after ' +
+                       'fulfillment of CacheStorage.delete promise.');
+        });
+  }, 'CacheStorage.delete with existing cache');
+
+promise_test(function(t) {
+    return self.caches.delete('cheezburger')
+      .then(function(result) {
+          assert_false(result,
+                       'CacheStorage.delete should return false for a ' +
+                       'nonexistent cache.');
+        });
+  }, 'CacheStorage.delete with nonexistent cache');
+
diff --git a/testing/web-platform/tests/cache/resources/doctype.html b/testing/web-platform/tests/cache/resources/doctype.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/doctype.html
@@ -0,0 +1,1 @@
+<!DOCTYPE html>
diff --git a/testing/web-platform/tests/cache/resources/empty-worker.js b/testing/web-platform/tests/cache/resources/empty-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/empty-worker.js
@@ -0,0 +1,1 @@
+// Do nothing.
diff --git a/testing/web-platform/tests/cache/resources/end-to-end-worker.js b/testing/web-platform/tests/cache/resources/end-to-end-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/end-to-end-worker.js
@@ -0,0 +1,7 @@
+onmessage = function(e) {
+    var message = e.data;
+    if (typeof message === 'object' && 'port' in message) {
+        var response = 'Ack for: ' + message.from;
+        message.port.postMessage(response);
+    }
+};
diff --git a/testing/web-platform/tests/cache/resources/events-worker.js b/testing/web-platform/tests/cache/resources/events-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/events-worker.js
@@ -0,0 +1,12 @@
+var eventsSeen = [];
+
+function handler(event) { eventsSeen.push(event.type); }
+
+['activate', 'install'].forEach(function(type) {
+    self.addEventListener(type, handler);
+});
+
+onmessage = function(e) {
+    var message = e.data;
+    message.port.postMessage({events: eventsSeen});
+};
diff --git a/testing/web-platform/tests/cache/resources/extendable-event-waituntil.js b/testing/web-platform/tests/cache/resources/extendable-event-waituntil.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/extendable-event-waituntil.js
@@ -0,0 +1,75 @@
+var pendingPorts = [];
+var portResolves = [];
+
+onmessage = function(e) {
+    var message = e.data;
+    if ('port' in message) {
+        var resolve = self.portResolves.shift();
+        if (resolve)
+            resolve(message.port);
+        else
+            self.pendingPorts.push(message.port);
+    }
+};
+
+function fulfillPromise() {
+    return new Promise(function(resolve) {
+        // Make sure the oninstall/onactivate callback returns first.
+        Promise.resolve().then(function() {
+            var port = self.pendingPorts.shift();
+            if (port)
+                resolve(port);
+            else
+                self.portResolves.push(resolve);
+        });
+    }).then(function(port) {
+        port.postMessage('SYNC');
+        return new Promise(function(resolve) {
+            port.onmessage = function(e) {
+                if (e.data == 'ACK')
+                    resolve();
+            };
+        });
+    });
+}
+
+function rejectPromise() {
+    return new Promise(function(resolve, reject) {
+        // Make sure the oninstall/onactivate callback returns first.
+        Promise.resolve().then(reject);
+    });
+}
+
+function stripScopeName(scope) {
+    return scope.split('/').slice(-1)[0];
+}
+
+oninstall = function(e) {
+    switch (stripScopeName(self.scope)) {
+        case 'install-fulfilled':
+            e.waitUntil(fulfillPromise());
+            break;
+        case 'install-rejected':
+            e.waitUntil(rejectPromise());
+            break;
+    }
+};
+
+onactivate = function(e) {
+    switch (stripScopeName(self.scope)) {
+        case 'activate-fulfilled':
+            e.waitUntil(fulfillPromise());
+            break;
+        case 'activate-rejected':
+            e.waitUntil(rejectPromise());
+            break;
+        case 'activate-multiple-fulfilled':
+            e.waitUntil(fulfillPromise());
+            e.waitUntil(fulfillPromise());
+            break;
+        case 'activate-reject-precedence':
+            e.waitUntil(fulfillPromise());
+            e.waitUntil(rejectPromise());
+            break;
+    }
+};
diff --git a/testing/web-platform/tests/cache/resources/fail-on-fetch-worker.js b/testing/web-platform/tests/cache/resources/fail-on-fetch-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fail-on-fetch-worker.js
@@ -0,0 +1,5 @@
+importScripts('worker-testharness.js');
+
+this.addEventListener('fetch', function(event) {
+    event.respondWith(new Response('ERROR'));
+  });
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-access-control-iframe.html b/testing/web-platform/tests/cache/resources/fetch-access-control-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-access-control-iframe.html
@@ -0,0 +1,19 @@
+<script>
+function onMessage(event) {
+  var script = document.createElement('script');
+  script.src = event.data.url;
+  script.addEventListener(
+    'error',
+    function() { report({jsonpResult:'error'}); });
+  document.body.appendChild(script);
+}
+function report(data) {
+  window.parent.postMessage(
+    data,
+    'http://127.0.0.1:8000');
+}
+function onload() {
+  window.addEventListener('message', onMessage, false);
+}
+window.addEventListener('load', onload);
+</script>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-access-control-login.html b/testing/web-platform/tests/cache/resources/fetch-access-control-login.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-access-control-login.html
@@ -0,0 +1,16 @@
+<script>
+// Set authentication info
+window.addEventListener("message", function(evt) {
+    var port = evt.ports[0];
+    document.cookie = 'cookie=' + evt.data.username;
+    var xhr = new XMLHttpRequest();
+    xhr.addEventListener('load', function() {
+        port.postMessage({msg: 'LOGIN FINISHED'});
+      }, false);
+    xhr.open('GET',
+             './fetch-access-control.php?Auth',
+             true,
+             evt.data.username, evt.data.password);
+    xhr.send();
+  }, false);
+</script>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-access-control-worker.js b/testing/web-platform/tests/cache/resources/fetch-access-control-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-access-control-worker.js
@@ -0,0 +1,112 @@
+var port = undefined;
+var isTestTargetFetch = false;
+
+self.onmessage = function(e) {
+  var message = e.data;
+  if ('port' in message) {
+    port = message.port;
+  } else if (message.msg === 'START TEST CASE') {
+    isTestTargetFetch = true;
+    port.postMessage({msg: 'READY'});
+  }
+};
+
+function getQueryParams(url) {
+  var search = (new URL(url)).search;
+  if (!search) {
+    return {};
+  }
+  var ret = {};
+  var params = search.substring(1).split('&');
+  params.forEach(function(param) {
+      var element = param.split('=');
+      ret[decodeURIComponent(element[0])] = decodeURIComponent(element[1]);
+    });
+  return ret;
+}
+
+function getRequestInit(params) {
+  var init = {};
+  if (params['method']) {
+    init['method'] = params['method'];
+  }
+  if (params['mode']) {
+    init['mode'] = params['mode'];
+  }
+  if (params['credentials']) {
+    init['credentials'] = params['credentials'];
+  }
+  if (params['headers'] === 'CUSTOM') {
+    init['headers'] = {"X-ServiceWorker-Test": "test"};
+  } else if (params['headers'] === '{}') {
+    init['headers'] = {};
+  }
+  return init;
+}
+
+function headersToArray(headers) {
+  var ret = [];
+  for (var header of headers) {
+    ret.push(header);
+  }
+  return ret;
+}
+
+self.addEventListener('fetch', function(event) {
+    var originalURL = event.request.url;
+    if (!isTestTargetFetch) {
+      // Don't handle the event when it is not the test target fetch such as a
+      // redirected fetch or for the iframe html.
+      return;
+    }
+    isTestTargetFetch = false;
+    var params = getQueryParams(originalURL);
+    var init = getRequestInit(params);
+    var url = params['url'];
+    if (params['ignore']) {
+      port.postMessage({fetchResult: 'ignored'});
+      return;
+    }
+    event.respondWith(new Promise(function(resolve, reject) {
+        try {
+          var request = event.request;
+          if (url) {
+            request = new Request(url, init);
+          } else if (!params['noChange']) {
+            request = new Request(request, init);
+          }
+          var response;
+          fetch(request)
+            .then(function(res) {
+                response = res;
+                res.text()
+                  .then(function(body) {
+                      // Send the result to fetch-access-control.html.
+                      port.postMessage(
+                        {
+                          fetchResult: 'resolved',
+                          body: body,
+                          headers: headersToArray(response.headers),
+                          type: response.type,
+                          originalURL: originalURL
+                        });
+                      resolve(response);
+                    })
+                  .catch(function(e) {
+                      // Send the result to fetch-access-control.html.
+                      port.postMessage({fetchResult: 'error'});
+                      reject();
+                    });
+              })
+            .catch(function(e) {
+                // Send the result to fetch-access-control.html.
+                port.postMessage({fetchResult: 'rejected'});
+                reject();
+              });
+        } catch (e) {
+          // Send the result to fetch-access-control.html.
+          port.postMessage({fetchResult: 'error'});
+          reject();
+        }
+      }));
+  });
diff --git a/testing/web-platform/tests/cache/resources/fetch-access-control.php b/testing/web-platform/tests/cache/resources/fetch-access-control.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-access-control.php
@@ -0,0 +1,76 @@
+<?php
+header('X-ServiceWorker-ServerHeader: SetInTheServer');
+if (isset($_GET['ACAOrigin'])) {
+    $origins = explode(',', $_GET['ACAOrigin']);
+    for ($i = 0; $i < sizeof($origins); ++$i)
+        header("Access-Control-Allow-Origin: " . $origins[$i], false);
+}
+
+if (isset($_GET['ACAHeaders']))
+    header("Access-Control-Allow-Headers: {$_GET['ACAHeaders']}");
+if (isset($_GET['ACAMethods']))
+    header("Access-Control-Allow-Methods: {$_GET['ACAMethods']}");
+if (isset($_GET['ACACredentials']))
+    header("Access-Control-Allow-Credentials: {$_GET['ACACredentials']}");
+if (isset($_GET['ACEHeaders']))
+    header("Access-Control-Expose-Headers: {$_GET['ACEHeaders']}");
+
+if ((isset($_GET['Auth']) and !isset($_SERVER['PHP_AUTH_USER'])) || isset($_GET['AuthFail'])) {
+    header('WWW-Authenticate: Basic realm="Restricted"');
+    header('HTTP/1.0 401 Unauthorized');
+    echo 'Authentication canceled';
+    exit;
+}
+
+if (isset($_GET['PNGIMAGE'])) {
+  header('Content-Type: image/png');
+  echo base64_decode(
+    'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1B' .
+    'AACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAhSURBVDhPY3wro/KfgQLABKXJBqMG' .
+    'jBoAAqMGDLwBDAwAEsoCTFWunmQAAAAASUVORK5CYII=');
+  exit;
+}
+
+$username = 'undefined';
+$password = 'undefined';
+$cookie = 'undefined';
+if (isset($_SERVER['PHP_AUTH_USER'])) {
+    $username = $_SERVER['PHP_AUTH_USER'];
+}
+if (isset($_SERVER['PHP_AUTH_PW'])) {
+    $password = $_SERVER['PHP_AUTH_PW'];
+}
+if (isset($_COOKIE['cookie'])) {
+    $cookie = $_COOKIE['cookie'];
+}
+
+$files = array();
+foreach ($_FILES as $key => $file) {
+    $content = '';
+    $fp = fopen($file['tmp_name'], 'r');
+    if ($fp) {
+        $content = $file['size'] > 0 ? fread($fp, $file['size']) : '';
+        fclose($fp);
+    }
+    $files[] = array('key' => $key,
+                     'name' => $file['name'],
+                     'type' => $file['type'],
+                     'error' => $file['error'],
+                     'size' => $file['size'],
+                     'content' => $content);
+}
+
+header('Content-Type: application/json');
+$arr = array('jsonpResult' => 'success',
+             'method' => $_SERVER['REQUEST_METHOD'],
+             'headers' => getallheaders(),
+             'body' => file_get_contents('php://input'),
+             'files' => $files,
+             'get' => $_GET,
+             'post' => $_POST,
+             'username' => $username,
+             'password' => $password,
+             'cookie' => $cookie);
+$json = json_encode($arr);
+echo "report( $json );";
+?>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-body-mixin-worker.js b/testing/web-platform/tests/cache/resources/fetch-body-mixin-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-body-mixin-worker.js
@@ -0,0 +1,94 @@
+self.onmessage = function(e) {
+    var message = e.data;
+    if ('port' in message) {
+        port = message.port;
+        doTextTest(port);
+    }
+};
+
+function quit(port) {
+    port.postMessage('quit');
+}
+
+function doFetchTwiceTest(port) {
+  var p1Out = p2Out = null;
+
+  fetch('doctype.html')
+  .then(function(response) {
+      var p1 = response.text();
+      var p2 = response.text();
+
+      p1.then(function(obj) {
+          p1Out = obj;
+          if (p2Out) {
+              complete();
+          }
+      });
+      p2.catch(function(e) {
+          p2Out = e;
+          if (p1Out) {
+              complete();
+          }
+      });
+  });
+
+  function complete() {
+      port.postMessage(p1Out + ' : ' + p2Out.name);
+      quit(port);
+  }
+}
+
+function doArrayBufferTest(port) {
+    fetch('doctype.html')
+    .then(function(response) {
+        response.arrayBuffer()
+        .then(function(b) {
+            port.postMessage('ArrayBuffer: ' + b.byteLength);
+            doFetchTwiceTest(port);
+        });
+    });
+}
+
+function doBlobTest(port) {
+    fetch('doctype.html')
+    .then(function(response) {
+        response.blob()
+        .then(function(blob) {
+            port.postMessage('Blob: ' + blob.size + " : " + blob.type);
+            doArrayBufferTest(port);
+        });
+    });
+}
+
+function doJSONFailedTest(port) {
+  fetch('doctype.html')
+  .then(function(response) {
+      response.json()
+      .catch(function(e) {
+          port.postMessage('JSON: ' + e.name);
+          doBlobTest(port);
+      });
+  });
+}
+
+function doJSONTest(port) {
+    fetch('simple.json')
+    .then(function(response) {
+        response.json()
+        .then(function(json) {
+            port.postMessage('JSON: ' + json['a'] + ' ' + json['b']);
+            doJSONFailedTest(port);
+        });
+    });
+}
+
+function doTextTest(port) {
+  fetch('doctype.html')
+  .then(function(response) {
+      response.text()
+      .then(function(txt) {
+          port.postMessage('Text: ' + txt);
+          doJSONTest(port);
+      });
+  });
+}
diff --git a/testing/web-platform/tests/cache/resources/fetch-cache-override-worker.js b/testing/web-platform/tests/cache/resources/fetch-cache-override-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-cache-override-worker.js
@@ -0,0 +1,198 @@
+importScripts('worker-testharness.js');
+importScripts('../../resources/testharness-helpers.js');
+importScripts('test-helpers.js');
+
+promise_test(function() {
+    var lastModified = '';
+    var eTag = '';
+    var url = 'other.html';
+    var expectedText = '<!DOCTYPE html>\n<title>Other</title>\n' +
+        'Here\'s an other html file.\n';
+    return fetch(url)
+      .then(function(res) {
+          lastModified = res.headers.get('last-modified');
+          eTag = res.headers.get('etag');
+          assert_not_equals(lastModified, '', 'last-modified must be set.');
+          assert_not_equals(eTag, '', 'eTag must be set.');
+
+          return fetch(url);
+        })
+      .then(function(res) {
+          assert_equals(res.status, 200,
+                        'Automatically cached response status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'Automatically cached response body must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Modified-Since', lastModified]] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 304,
+            'When If-Modified-Since is overridden, the response status must ' +
+                'be 304.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, '',
+            'When If-Modified-Since is overridden, the response body must be' +
+                ' empty.');
+
+          return fetch(url,
+                       { headers: [['If-Modified-Since',
+                                    'Tue, 01 Jan 1980 01:00:00 GMT']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 200,
+            'When If-Modified-Since is overridden, the modified response ' +
+                'status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'When If-Modified-Since is overridden, the modified response body' +
+                ' must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Unmodified-Since', lastModified]] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 200,
+            'When If-Unmodified-Since is overridden, the modified response ' +
+                'status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'When If-Unmodified-Since is overridden, the modified response ' +
+                'body must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Unmodified-Since',
+                                    'Tue, 01 Jan 1980 01:00:00 GMT']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 412,
+            'When If-Unmodified is overridden, the modified response status ' +
+                'must be 412.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, '',
+            'When If-Unmodified is overridden, the modified response body ' +
+                'must be empty.');
+
+          return fetch(url,
+                       { headers: [['If-Match', eTag]] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 200,
+            'When If-Match is overridden, the response status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'When If-Match is overridden, the response body must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Match', 'xyzzy']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 412,
+            'When If-Match is overridden to the invalid tag, the response ' +
+                'status must be 412.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, '',
+            'When If-Match is overridden to the invalid tag, the response ' +
+                'body must be empty.');
+
+          return fetch(url,
+                       { headers: [['If-None-Match', eTag]] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 304,
+            'When If-None-Match is overridden, the response status must be ' +
+                '304.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, '',
+            'When If-None-Match is overridden, the response body must be ' +
+                'empty.');
+
+          return fetch(url,
+                       { headers: [['If-None-Match', 'xyzzy']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 200,
+            'When If-None-Match is overridden to the invalid tag, the ' +
+                'response status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'When If-None-Match is overridden to the invalid tag, the ' +
+                'response body must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Range', eTag],
+                                   ['Range', 'bytes=10-30']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 206,
+            'When If-Range is overridden, the response status must be 206.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText.substring(10, 31),
+            'When If-Range is overridden, the response body must be correct.');
+
+          return fetch(url,
+                       { headers: [['If-Range', 'xyzzy'],
+                                   ['Range', 'bytes=10-30']] });
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 200,
+            'When If-Range is overridden to the invalid tag, the response ' +
+                'status must be 200.');
+          return res.text();
+        })
+      .then(function(text) {
+          assert_equals(
+            text, expectedText,
+            'When If-Range is overridden to the invalid tag, the response ' +
+                'body must be correct.');
+
+          return fetch('fetch-status.php?status=304');
+        })
+      .then(function(res) {
+          assert_equals(
+            res.status, 304 ,
+            'When the server returns 304 and there\'s a cache miss, the ' +
+                'response status must be 304.');
+        })
+  }, '304 handling for fetch().');
diff --git a/testing/web-platform/tests/cache/resources/fetch-canvas-tainting-iframe.html b/testing/web-platform/tests/cache/resources/fetch-canvas-tainting-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-canvas-tainting-iframe.html
@@ -0,0 +1,253 @@
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var image_path = base_path() + 'fetch-access-control.php?PNGIMAGE';
+var host_info = get_host_info();
+
+var NOT_TAINTED = 'NOT_TAINTED';
+var TAINTED = 'TAINTED';
+var LOAD_ERROR = 'LOAD_ERROR';
+
+function create_test_case_promise(url, cross_origin) {
+  return new Promise(function(resolve) {
+      var img = new Image();
+      if (cross_origin != '') {
+        img.crossOrigin = cross_origin;
+      }
+      img.onload = function() {
+        try {
+          var canvas = document.createElement('canvas');
+          canvas.width = 100;
+          canvas.height = 100;
+          var context = canvas.getContext('2d');
+          context.drawImage(img, 0, 0);
+          context.getImageData(0, 0, 100, 100);
+          resolve(NOT_TAINTED);
+        } catch (e) {
+          resolve(TAINTED);
+        }
+      };
+      img.onerror = function() {
+        resolve(LOAD_ERROR);
+      }
+      img.src = url;
+    });
+}
+
+function create_test_promise(url, cross_origin, expected_result) {
+  return new Promise(function(resolve, reject) {
+      create_test_case_promise(url, cross_origin)
+        .then(function(result) {
+          if (result == expected_result) {
+            resolve();
+          } else {
+            reject('Result of url:' + url + ' ' +
+                   ' cross_origin: ' + cross_origin + ' must be ' +
+                   expected_result + ' but ' + result);
+          }
+        })
+    });
+}
+
+window.addEventListener('message', function(evt) {
+    var port = evt.ports[0];
+    var image_url = host_info['HTTP_ORIGIN'] + image_path;
+    var remote_image_url = host_info['HTTP_REMOTE_ORIGIN'] + image_path;
+    Promise.all([
+        // Reject tests
+        create_test_promise(image_url + '&reject', '', LOAD_ERROR),
+        create_test_promise(image_url + '&reject', 'anonymous', LOAD_ERROR),
+        create_test_promise(
+            image_url + '&reject', 'use-credentials', LOAD_ERROR),
+        // Fallback tests
+        create_test_promise(
+            image_url + '&ignore',
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url + '&ignore',
+            '',
+            TAINTED),
+        create_test_promise(
+            remote_image_url + '&ignore',
+            'anonymous',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+            '&ignore',
+            'anonymous',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url + '&ignore',
+            'use-credentials',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+            '&ignore',
+            'use-credentials',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+            '&ACACredentials=true&ignore',
+            'use-credentials',
+            NOT_TAINTED),
+
+        // Credential test (fallback)
+        create_test_promise(
+            image_url + '&Auth&ignore',
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url + '&Auth&ignore',
+            '',
+            TAINTED),
+        create_test_promise(
+            remote_image_url + '&Auth&ignore',
+            'anonymous',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&Auth&ignore',
+            'use-credentials',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&Auth&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+            '&ignore',
+            'use-credentials',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url + '&Auth&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+            '&ACACredentials=true&ignore',
+            'use-credentials',
+            NOT_TAINTED),
+
+        // Basic response
+        create_test_promise(
+            image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            'anonymous',
+            NOT_TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            'use-credentials',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            'anonymous',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=same-origin&url=' + encodeURIComponent(image_url),
+            'use-credentials',
+            NOT_TAINTED),
+
+        // Opaque response
+        create_test_promise(
+            image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            '',
+            TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            'anonymous',
+            LOAD_ERROR),
+        create_test_promise(
+            image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            'use-credentials',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            '',
+            TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            'anonymous',
+            LOAD_ERROR),
+        create_test_promise(
+            remote_image_url +
+            '&mode=no-cors&url=' + encodeURIComponent(remote_image_url),
+            'use-credentials',
+            LOAD_ERROR),
+        
+        // CORS response
+        create_test_promise(
+            image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'anonymous',
+            NOT_TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'use-credentials',
+            NOT_TAINTED),
+        create_test_promise(
+            image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(
+                remote_image_url +
+                '&ACACredentials=true&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'use-credentials',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            '',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'anonymous',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(remote_image_url +
+                               '&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'use-credentials',
+            NOT_TAINTED),
+        create_test_promise(
+            remote_image_url +
+            '&mode=cors&url=' +
+            encodeURIComponent(
+                remote_image_url +
+                '&ACACredentials=true&ACAOrigin=' + host_info['HTTP_ORIGIN']),
+            'use-credentials',
+            NOT_TAINTED)
+      ])
+      .then(function() {
+          port.postMessage({results: 'finish'});
+        })
+      .catch(function(e) {
+          port.postMessage({results: 'failure:' + e});
+        });
+  }, false);
+</script>
diff --git a/testing/web-platform/tests/cache/resources/fetch-cors-xhr-iframe.html b/testing/web-platform/tests/cache/resources/fetch-cors-xhr-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-cors-xhr-iframe.html
@@ -0,0 +1,189 @@
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var path = base_path() + 'fetch-access-control.php';
+var host_info = get_host_info();
+var SUCCESS = 'SUCCESS';
+var FAIL = 'FAIL';
+
+function create_test_case_promise(url, with_credentials) {
+  return new Promise(function(resolve) {
+      var xhr = new XMLHttpRequest();
+      xhr.onload = function() {
+        if (xhr.status == 200) {
+          resolve(SUCCESS);
+        } else {
+          resolve("STATUS" + xhr.status);
+        }
+      }
+      xhr.onerror = function() {
+        resolve(FAIL);
+      }
+      xhr.responseType = 'text';
+      xhr.withCredentials = with_credentials;
+      xhr.open('GET', url, true);
+      xhr.send();
+    });
+}
+
+
+function create_test_promise(url, with_credentials, expected_result) {
+  return new Promise(function(resolve, reject) {
+      create_test_case_promise(url, with_credentials)
+        .then(function(result) {
+          if (result == expected_result) {
+            resolve();
+          } else {
+            reject('Result of url:' + url + ' ' +
+                   ' with_credentials: ' + with_credentials + ' must be ' +
+                   expected_result + ' but ' + result);
+          }
+        })
+    });
+}
+
+function create_serial_promise(test_cases) {
+  var promise = Promise.resolve();
+  test_cases.forEach(function(test_case) {
+      promise = promise.then(function() {
+          return create_test_promise(test_case[0], test_case[1], test_case[2]);
+        });
+    });
+    return promise;
+}
+
+window.addEventListener('message', function(evt) {
+    var port = evt.ports[0];
+    var url = host_info['HTTP_ORIGIN'] + path;
+    var remote_url = host_info['HTTP_REMOTE_ORIGIN'] + path;
+    // If the 4th value of the item of TEST_CASES is true, the test case outputs
+    // warning messages. So such tests must be executed in serial to match the
+    // expected output text.
+    var TEST_CASES = [
+      // Reject tests
+      [url + '?reject', false, FAIL],
+      [url + '?reject', true, FAIL],
+      [remote_url + '?reject', false, FAIL],
+      [remote_url + '?reject', true, FAIL],
+      // Reject(resolve-null) tests
+      [url + '?resolve-null', false, FAIL],
+      [url + '?resolve-null', true, FAIL],
+      [remote_url + '?resolve-null', false, FAIL],
+      [remote_url + '?resolve-null', true, FAIL],
+      // Fallback tests
+      [url + '?ignore', false, SUCCESS],
+      [url + '?ignore', true, SUCCESS],
+      [remote_url + '?ignore', false, FAIL, true],  // Executed in serial.
+      [remote_url + '?ignore', true, FAIL, true],  // Executed in serial.
+      [
+        remote_url + '?ACAOrigin=' + host_info['HTTP_ORIGIN'] + '&ignore',
+        false, SUCCESS
+      ],
+      [
+        remote_url + '?ACAOrigin=' + host_info['HTTP_ORIGIN'] + '&ignore',
+        true, FAIL, true  // Executed in serial.
+      ],
+      [
+        remote_url + '?ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+        '&ACACredentials=true&ignore',
+        true, SUCCESS
+      ],
+      // Credential test (fallback)
+      [url + '?Auth&ignore', false, SUCCESS],
+      [url + '?Auth&ignore', true, SUCCESS],
+      [remote_url + '?Auth&ignore', false, FAIL, true],  // Executed in serial.
+      [remote_url + '?Auth&ignore', true, FAIL, true],  // Executed in serial.
+      [
+        remote_url + '?Auth&ACAOrigin=' + host_info['HTTP_ORIGIN'] + '&ignore',
+        false, 'STATUS401'
+      ],
+      [
+        remote_url + '?Auth&ACAOrigin=' + host_info['HTTP_ORIGIN'] + '&ignore',
+        true, FAIL, true  // Executed in serial.
+      ],
+      [
+        remote_url + '?Auth&ACAOrigin=' + host_info['HTTP_ORIGIN'] +
+        '&ACACredentials=true&ignore',
+        true, SUCCESS
+      ],
+      // Basic response
+      [
+        url + '?mode=same-origin&url=' + encodeURIComponent(url),
+        false, SUCCESS
+      ],
+      [
+        url + '?mode=same-origin&url=' + encodeURIComponent(url),
+        false, SUCCESS
+      ],
+      [
+        remote_url + '?mode=same-origin&url=' + encodeURIComponent(url),
+        false, SUCCESS
+      ],
+      [
+        remote_url + '?mode=same-origin&url=' + encodeURIComponent(url),
+        false, SUCCESS
+      ],
+      // Opaque response
+      [
+        url + '?mode=no-cors&url=' + encodeURIComponent(remote_url),
+        false, FAIL
+      ],
+      [
+        url + '?mode=no-cors&url=' + encodeURIComponent(remote_url),
+        false, FAIL
+      ],
+      [
+        remote_url + '?mode=no-cors&url=' + encodeURIComponent(remote_url),
+        false, FAIL
+      ],
+      [
+        remote_url + '?mode=no-cors&url=' + encodeURIComponent(remote_url),
+        false, FAIL
+      ],
+      // CORS response
+      [
+        url + '?mode=cors&url=' +
+        encodeURIComponent(remote_url + '?ACAOrigin=' +
+                           host_info['HTTP_ORIGIN']),
+        false, SUCCESS
+      ],
+      [
+        url + '?mode=cors&url=' +
+        encodeURIComponent(remote_url + '?ACAOrigin=' +
+                           host_info['HTTP_ORIGIN']),
+        true, SUCCESS
+      ],
+      [
+        remote_url + '?mode=cors&url=' +
+        encodeURIComponent(remote_url + '?ACAOrigin=' +
+                           host_info['HTTP_ORIGIN']),
+        false, SUCCESS
+      ],
+      [
+        remote_url +
+        '?mode=cors&url=' +
+        encodeURIComponent(remote_url + '?ACAOrigin=' +
+                           host_info['HTTP_ORIGIN']),
+        true, SUCCESS
+      ]
+    ];
+    var promises = [];
+    var serial_tests = [];
+    for (var i = 0; i < TEST_CASES.length ; ++i) {
+      if (!TEST_CASES[i][3]) {
+        promises.push(create_test_promise(TEST_CASES[i][0],
+                                          TEST_CASES[i][1],
+                                          TEST_CASES[i][2]));
+      } else {
+        serial_tests.push(TEST_CASES[i]);
+      }
+    }
+    promises.push(create_serial_promise(serial_tests));
+    Promise.all(promises)
+      .then(function() {
+          port.postMessage({results: 'finish'});
+        })
+      .catch(function(e) {
+          port.postMessage({results: 'failure:' + e});
+        });
+  }, false);
+</script>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-csp-iframe.html b/testing/web-platform/tests/cache/resources/fetch-csp-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-csp-iframe.html
@@ -0,0 +1,77 @@
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var image_path = base_path() + 'fetch-access-control.php?PNGIMAGE';
+var host_info = get_host_info();
+var results = '';
+var port = undefined;
+
+var meta = document.createElement('meta');
+meta.setAttribute('http-equiv', 'Content-Security-Policy');
+meta.setAttribute('content', 'img-src ' + host_info['HTTP_ORIGIN'] +
+                  '; script-src \'unsafe-inline\'');
+document.head.appendChild(meta);
+
+function test1() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test2();
+  };
+  img.onerror = function() {
+    results += 'FAIL(1)';
+    test2();
+  };
+  img.src = host_info['HTTP_ORIGIN'] + image_path;
+}
+
+function test2() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(2)';
+    test3();
+  };
+  img.onerror = function() {
+    test3();
+  };
+  img.src = host_info['HTTP_REMOTE_ORIGIN'] + image_path;
+}
+
+function test3() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test4();
+  };
+  img.onerror = function() {
+    results += 'FAIL(3)';
+    test4();
+  };
+  img.src = './dummy?url=' +
+            encodeURIComponent(host_info['HTTP_ORIGIN'] + image_path);
+}
+
+function test4() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(4)';
+    finish();
+  };
+  img.onerror = function() {
+    finish();
+  };
+  img.src = './dummy?mode=no-cors&url=' +
+            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + image_path);
+}
+
+function finish() {
+  results += 'finish';
+  port.postMessage({results: results});
+}
+
+window.addEventListener('message', function(evt) {
+    port = evt.ports[0];
+    test1();
+  }, false);
+</script>
diff --git a/testing/web-platform/tests/cache/resources/fetch-event-test-worker.js b/testing/web-platform/tests/cache/resources/fetch-event-test-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-event-test-worker.js
@@ -0,0 +1,71 @@
+function handleString(event) {
+  event.respondWith(new Response('Test string'));
+}
+
+function handleBlob(event) {
+  event.respondWith(new Response(new Blob(['Test blob'])));
+}
+
+function handleReferrer(event) {
+  event.respondWith(new Response(new Blob(
+    ['Referrer: ' + event.request.referrer])));
+}
+
+function handleNullBody(event) {
+  event.respondWith(new Response(null));
+}
+
+function handleFetch(event) {
+  event.respondWith(fetch('other.html'));
+}
+
+function handleFormPost(event) {
+  event.respondWith(new Promise(function(resolve) {
+      event.request.text()
+        .then(function(result) {
+            resolve(new Response(event.request.method + ':' + result));
+          })
+    }));
+}
+
+var logForMultipleRespondWith = '';
+
+function handleMultipleRespondWith(event) {
+  for (var i = 0; i < 3; ++i) {
+    logForMultipleRespondWith += '(' + i + ')';
+    try {
+      event.respondWith(new Response(logForMultipleRespondWith));
+    } catch (e) {
+      logForMultipleRespondWith += '[' + e.name + ']';
+    }
+  }
+}
+
+self.addEventListener('fetch', function(event) {
+    var url = event.request.url;
+    var handlers = [
+      { pattern: '?string', fn: handleString },
+      { pattern: '?blob', fn: handleBlob },
+      { pattern: '?referrer', fn: handleReferrer },
+      { pattern: '?ignore', fn: function() {} },
+      { pattern: '?null', fn: handleNullBody },
+      { pattern: '?fetch', fn: handleFetch },
+      { pattern: '?form-post', fn: handleFormPost },
+      { pattern: '?multiple-respond-with', fn: handleMultipleRespondWith }
+    ];
+
+    var handler = null;
+    for (var i = 0; i < handlers.length; ++i) {
+      if (url.indexOf(handlers[i].pattern) != -1) {
+        handler = handlers[i];
+        break;
+      }
+    }
+
+    if (handler) {
+      handler.fn(event);
+    } else {
+      event.respondWith(new Response(new Blob(
+        ['Service Worker got an unexpected request: ' + url])));
+    }
+  });
diff --git a/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe-inscope.html b/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe-inscope.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe-inscope.html
@@ -0,0 +1,122 @@
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var image_path = base_path() + 'fetch-access-control.php?PNGIMAGE';
+var host_info = get_host_info();
+var results = '';
+
+function test1() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test2();
+  };
+  img.onerror = function() {
+    results += 'FAIL(1)';
+    test2();
+  };
+  img.src = host_info['HTTPS_ORIGIN'] + image_path;
+}
+
+function test2() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test3();
+  };
+  img.onerror = function() {
+    results += 'FAIL(2)';
+    test3();
+  };
+  img.src = host_info['HTTPS_REMOTE_ORIGIN'] + image_path;
+}
+
+function test3() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(3)';
+    test4();
+  };
+  img.onerror = function() {
+    test4();
+  };
+  img.src = host_info['HTTP_ORIGIN'] + image_path;
+}
+
+function test4() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(4)';
+    test5();
+  };
+  img.onerror = function() {
+    test5();
+  };
+  img.src = host_info['HTTP_REMOTE_ORIGIN'] + image_path;
+}
+
+function test5() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test6();
+  };
+  img.onerror = function() {
+    results += 'FAIL(5)';
+    test6();
+  };
+  img.src = './dummy?url=' +
+            encodeURIComponent(host_info['HTTPS_ORIGIN'] + image_path);
+}
+
+function test6() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    test7();
+  };
+  img.onerror = function() {
+    results += 'FAIL(6)';
+    test7();
+  };
+  img.src = './dummy?mode=no-cors&url=' +
+            encodeURIComponent(host_info['HTTPS_REMOTE_ORIGIN'] + image_path);
+}
+
+function test7() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(7)';
+    test8();
+  };
+  img.onerror = function() {
+    test8();
+  };
+  img.src = './dummy?mode=no-cors&url=' +
+            encodeURIComponent(host_info['HTTP_ORIGIN'] + image_path);
+}
+
+function test8() {
+  var img = document.createElement('img');
+  document.body.appendChild(img);
+  img.onload = function() {
+    results += 'FAIL(8)';
+    finish();
+  };
+  img.onerror = function() {
+    finish();
+  };
+  img.src = './dummy?mode=no-cors&url=' +
+            encodeURIComponent(host_info['HTTP_REMOTE_ORIGIN'] + image_path);
+}
+
+function finish() {
+  results += 'finish';
+  window.parent.postMessage({results: results}, host_info['HTTPS_ORIGIN']);
+}
+</script>
+
+<body onload='test1();'>
+</body>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe.html b/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-mixed-content-iframe.html
@@ -0,0 +1,55 @@
+<!DOCTYPE html>
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var SCOPE = 'fetch-mixed-content-iframe-inscope.html';
+var URL = 'fetch-rewrite-worker.js';
+var host_info = get_host_info();
+
+window.addEventListener('message', on_message, false);
+
+navigator.serviceWorker.getRegistration(SCOPE)
+  .then(function(registration) {
+      if (registration)
+        return registration.unregister();
+    })
+  .then(function() {
+      return navigator.serviceWorker.register(URL, {scope: SCOPE});
+    })
+  .then(function(registration) {
+      return new Promise(function(resolve) {
+          registration.addEventListener('updatefound', function() {
+              resolve(registration.installing);
+            });
+        });
+    })
+  .then(function(worker) {
+      worker.addEventListener('statechange', on_state_change);
+    })
+  .catch(function(reason) {
+      window.parent.postMessage({results: 'FAILURE: ' + reason.message},
+                                host_info['HTTP_ORIGIN']);
+     });
+
+function on_state_change(event) {
+  if (event.target.state != 'activated')
+    return;
+  var frame = document.createElement('iframe');
+  frame.src = SCOPE;
+  document.body.appendChild(frame);
+}
+
+function on_message(e) {
+  navigator.serviceWorker.getRegistration(SCOPE)
+    .then(function(registration) {
+        if (registration)
+          return registration.unregister();
+      })
+    .then(function() {
+      window.parent.postMessage(e.data, host_info['HTTP_ORIGIN']);
+    })
+    .catch(function(reason) {
+        window.parent.postMessage({results: 'FAILURE: ' + reason.message},
+                                  host_info['HTTP_ORIGIN']);
+     });
+}
+</script>
diff --git a/testing/web-platform/tests/cache/resources/fetch-request-image-iframe.html b/testing/web-platform/tests/cache/resources/fetch-request-image-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-request-image-iframe.html
@@ -0,0 +1,27 @@
+<script src="../../resources/testharness.js"></script>
+<script src="test-helpers.js?pipe=sub"></script>
+<body>
+<script>
+var host_info = get_host_info();
+
+function load_image(url, cross_origin) {
+  return new Promise(function(resolve) {
+      var img = new Image();
+      if (cross_origin != '') {
+        img.crossOrigin = cross_origin;
+      }
+      img.onerror = resolve;
+      img.src = url;
+    });
+}
+
+window.addEventListener('message', function(evt) {
+    var port = evt.ports[0];
+    Promise.all([load_image('dummy?test1', ''),
+                 load_image('dummy?test2', 'anonymous'),
+                 load_image('dummy?test3', 'use-credentials')])
+      .then(function() { port.postMessage({results: 'finish'}); })
+      .catch(function(e) { port.postMessage({results: 'failure:' + e}); });
+  });
+</script>
+</body>
diff --git a/testing/web-platform/tests/cache/resources/fetch-request-image-worker.js b/testing/web-platform/tests/cache/resources/fetch-request-image-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-request-image-worker.js
@@ -0,0 +1,20 @@
+var requests = [];
+
+self.onmessage = function(e) {
+  var message = e.data;
+  if ('port' in message) {
+    var port = message.port;
+    port.postMessage(requests);
+  }
+};
+
+self.addEventListener('fetch', function(event) {
+    var url = event.request.url;
+    if (url.indexOf('dummy?test') == -1) {
+      return;
+    }
+    requests[url] = {
+      mode: event.request.mode,
+    };
+    event.respondWith(Promise.reject());
+  });
diff --git a/testing/web-platform/tests/cache/resources/fetch-request-xhr-iframe.html b/testing/web-platform/tests/cache/resources/fetch-request-xhr-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-request-xhr-iframe.html
@@ -0,0 +1,152 @@
+<script src="../../resources/testharness.js"></script>
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+var host_info = get_host_info();
+
+function get_boundary(headers) {
+  var reg = new RegExp('multipart\/form-data; boundary=(.*)');
+  for (var i = 0; i < headers.length; ++i) {
+    if (headers[i][0] != 'content-type') {
+      continue;
+    }
+    var regResult = reg.exec(headers[i][1]);
+    if (!regResult) {
+      continue;
+    }
+    return regResult[1];
+  }
+  return '';
+}
+
+function create_file_system_file(file_name, data) {
+  return new Promise(function(resolve, reject) {
+      webkitRequestFileSystem(TEMPORARY, 1024, function(fs) {
+          fs.root.getFile(
+            file_name, {create: true, exclusive: true},
+            function(fileEntry) {
+              fileEntry.createWriter(function(fileWriter) {
+                  fileWriter.onwriteend = function(e) {
+                    fileEntry.file(function(file) { resolve(file); });
+                  };
+                  var blob = new Blob([data], {type: 'text/plain'});
+                  fileWriter.write(blob);
+                });
+            }, function(e) { reject(e); });
+        }, function(e) { reject(e); });
+    });
+}
+
+function xhr_send(url_base, method, data, with_credentials) {
+  return new Promise(function(resolve, reject) {
+      var xhr = new XMLHttpRequest();
+      xhr.onload = function() {
+        resolve(JSON.parse(xhr.response));
+      };
+      xhr.onerror = function() {
+        reject('XHR should succeed.');
+      };
+      xhr.responseType = 'text';
+      if (with_credentials) {
+        xhr.withCredentials = true;
+      }
+      xhr.open(method, url_base + '/dummy?test', true);
+      xhr.send(data);
+    });
+}
+
+function string_test() {
+  return xhr_send(host_info['HTTP_ORIGIN'], 'POST', 'test string', false)
+    .then(function(response) {
+        assert_equals(response.method, 'POST');
+        assert_equals(response.body, 'test string');
+      });
+}
+
+function blob_test() {
+  return xhr_send(host_info['HTTP_ORIGIN'], 'POST', new Blob(['test blob']),
+                  false)
+    .then(function(response) {
+        assert_equals(response.method, 'POST');
+        assert_equals(response.body, 'test blob');
+      });
+}
+
+function custom_method_test() {
+  return xhr_send(host_info['HTTP_ORIGIN'], 'XXX', 'test string xxx', false)
+    .then(function(response){
+        assert_equals(response.method, 'XXX');
+        assert_equals(response.body, 'test string xxx');
+      });
+}
+
+function form_data_test() {
+  return create_file_system_file('fsfile.txt', 'fs file content')
+    .then(function(file_system_file) {
+        var formData = new FormData();
+        formData.append('sample string', '1234567890');
+        formData.append('sample blob', new Blob(['blob content']));
+        formData.append('sample file', new File(['file content'], 'file.dat'));
+        formData.append('sample fs file', file_system_file);
+        return xhr_send(host_info['HTTP_ORIGIN'], 'POST', formData, false);
+      })
+    .then(function(response) {
+        assert_equals(response.method, 'POST');
+        var boundary = get_boundary(response.headers);
+        var expected_body =
+          '--' + boundary + '\r\n' +
+          'Content-Disposition: form-data; name="sample string"\r\n' +
+          '\r\n' +
+          '1234567890\r\n' +
+          '--' + boundary + '\r\n' +
+          'Content-Disposition: form-data; name="sample blob"; ' +
+          'filename="blob"\r\n' +
+          'Content-Type: application/octet-stream\r\n' +
+          '\r\n' +
+          'blob content\r\n' +
+          '--' + boundary + '\r\n' +
+          'Content-Disposition: form-data; name="sample file"; ' +
+          'filename="file.dat"\r\n' +
+          'Content-Type: application/octet-stream\r\n' +
+          '\r\n' +
+          'file content\r\n' +
+          '--' + boundary + '\r\n' +
+          'Content-Disposition: form-data; name="sample fs file"; ' +
+          'filename="fsfile.txt"\r\n' +
+          'Content-Type: text/plain\r\n' +
+          '\r\n' +
+          'fs file content\r\n' +
+          '--' + boundary + '--\r\n';
+        assert_equals(response.body, expected_body);
+      });
+}
+
+function mode_test() {
+  return xhr_send(host_info['HTTP_ORIGIN'], 'GET', '', false)
+    .then(function(response){
+        assert_equals(response.mode, 'cors');
+        return xhr_send(host_info['HTTP_ORIGIN'], 'GET', '', true);
+      })
+    .then(function(response){
+        assert_equals(response.mode, 'cors');
+        return xhr_send(host_info['HTTP_REMOTE_ORIGIN'], 'GET', '', false);
+      })
+    .then(function(response){
+        assert_equals(response.mode, 'cors');
+        return xhr_send(host_info['HTTP_REMOTE_ORIGIN'], 'GET', '', true);
+      })
+    .then(function(response){
+        assert_equals(response.mode, 'cors');
+      });
+}
+
+window.addEventListener('message', function(evt) {
+    var port = evt.ports[0];
+    string_test()
+      .then(blob_test)
+      .then(custom_method_test)
+      .then(form_data_test)
+      .then(mode_test)
+      .then(function() { port.postMessage({results: 'finish'}); })
+      .catch(function(e) { port.postMessage({results: 'failure:' + e}); });
+  });
+</script>
diff --git a/testing/web-platform/tests/cache/resources/fetch-request-xhr-worker.js b/testing/web-platform/tests/cache/resources/fetch-request-xhr-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-request-xhr-worker.js
@@ -0,0 +1,21 @@
+self.addEventListener('fetch', function(event) {
+    var url = event.request.url;
+    if (url.indexOf('dummy?test') == -1) {
+      return;
+    }
+    event.respondWith(new Promise(function(resolve) {
+        var headers = [];
+        for (var header of event.request.headers) {
+          headers.push(header);
+        }
+        event.request.text()
+          .then(function(result) {
+              resolve(new Response(JSON.stringify({
+                  method: event.request.method,
+                  mode: event.request.mode,
+                  headers: headers,
+                  body: result
+                })));
+            });
+      }));
+  });
diff --git a/testing/web-platform/tests/cache/resources/fetch-response-xhr-iframe.html b/testing/web-platform/tests/cache/resources/fetch-response-xhr-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-response-xhr-iframe.html
@@ -0,0 +1,33 @@
+<script src="../../resources/testharness.js"></script>
+<script src="test-helpers.js?pipe=sub"></script>
+<script>
+
+function xhr_send(method, data) {
+  return new Promise(function(resolve, reject) {
+      var xhr = new XMLHttpRequest();
+      xhr.onload = function() {
+        resolve(xhr);
+      };
+      xhr.onerror = function() {
+        reject('XHR should succeed.');
+      };
+      xhr.responseType = 'text';
+      xhr.open(method, './dummy?test', true);
+      xhr.send(data);
+    });
+}
+
+function coalesce_headers_test() {
+  return xhr_send('POST', 'test string')
+  .then(function(xhr) {
+      assert_equals(xhr.getResponseHeader('foo'), 'foo, bar');
+    });
+}
+
+window.addEventListener('message', function(evt) {
+    var port = evt.ports[0];
+    coalesce_headers_test()
+      .then(function() { port.postMessage({results: 'finish'}); })
+      .catch(function(e) { port.postMessage({results: 'failure:' + e}); });
+  });
+</script>
diff --git a/testing/web-platform/tests/cache/resources/fetch-response-xhr-worker.js b/testing/web-platform/tests/cache/resources/fetch-response-xhr-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-response-xhr-worker.js
@@ -0,0 +1,12 @@
+self.addEventListener('fetch', function(event) {
+    var url = event.request.url;
+    if (url.indexOf('dummy?test') == -1) {
+      return;
+    }
+    event.respondWith(new Promise(function(resolve) {
+      var headers = new Headers;
+      headers.append('foo', 'foo');
+      headers.append('foo', 'bar');
+      resolve(new Response('hello world', {'headers': headers}));
+    }));
+});
diff --git a/testing/web-platform/tests/cache/resources/fetch-rewrite-worker.js b/testing/web-platform/tests/cache/resources/fetch-rewrite-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-rewrite-worker.js
@@ -0,0 +1,55 @@
+function get_query_params(url) {
+  var search = (new URL(url)).search;
+  if (!search) {
+    return {};
+  }
+  var ret = {};
+  var params = search.substring(1).split('&');
+  params.forEach(function(param) {
+      var element = param.split('=');
+      ret[decodeURIComponent(element[0])] = decodeURIComponent(element[1]);
+    });
+  return ret;
+}
+
+function get_request_init(params) {
+  var init = {};
+  if (params['method']) {
+    init['method'] = params['method'];
+  }
+  if (params['mode']) {
+    init['mode'] = params['mode'];
+  }
+  if (params['credentials']) {
+    init['credentials'] = params['credentials'];
+  }
+  return init;
+}
+
+self.addEventListener('fetch', function(event) {
+    var params = get_query_params(event.request.url);
+    var init = get_request_init(params);
+    var url = params['url'];
+    if (params['ignore']) {
+      return;
+    }
+    if (params['reject']) {
+      event.respondWith(new Promise(function(resolve, reject) {
+          reject();
+        }));
+      return;
+    }
+    if (params['resolve-null']) {
+      event.respondWith(new Promise(function(resolve) {
+          resolve(null);
+        }));
+      return;
+    }
+    event.respondWith(new Promise(function(resolve, reject) {
+        var request = event.request;
+        if (url) {
+          request = new Request(url, init);
+        }
+        fetch(request).then(resolve, reject);
+      }));
+  });
diff --git a/testing/web-platform/tests/cache/resources/fetch-status.php b/testing/web-platform/tests/cache/resources/fetch-status.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-status.php
@@ -0,0 +1,3 @@
+<?php
+header ("HTTP/1.1 " . $_GET["status"]);
+?>
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/fetch-worker.js b/testing/web-platform/tests/cache/resources/fetch-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/fetch-worker.js
@@ -0,0 +1,150 @@
+importScripts('worker-testharness.js');
+importScripts('test-helpers.js');
+
+async_test(function(t) {
+    fetch('http://')
+      .then(
+        unreached_rejection(t, 'fetch of invalid URL must fail'),
+        function(e) {
+          assert_equals(e.message, 'Invalid URL');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch invalid URL in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    fetch('fetch-status.php?status=200')
+      .then(function(response) {
+          assert_equals(response.status, 200);
+          assert_equals(response.statusText, 'OK');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch result of 200 response in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    fetch('fetch-status.php?status=404')
+      .then(function(response) {
+          assert_equals(response.status, 404);
+          assert_equals(response.statusText, 'Not Found');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch result of 404 response in ServiceWorkerGlobalScope');
+
+function evalJsonp(text) {
+  return new Promise(function(resolve) {
+      var report = resolve;
+      // text must contain report() call.
+      eval(text);
+    });
+}
+
+async_test(function(t) {
+    var request =
+      new Request('fetch-access-control.php',
+                  {
+                    method: 'POST',
+                    body: new Blob(['Test Blob'], {type: 'test/type'})
+                  });
+    fetch(request)
+      .then(function(response) { return response.text(); })
+      .then(evalJsonp)
+      .then(function(result) {
+          assert_equals(result.method, 'POST');
+          assert_equals(result.body, 'Test Blob');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch with Blob body test in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    var request = new Request('fetch-access-control.php',
+                              {method: 'POST', body: 'Test String'});
+    fetch(request)
+      .then(function(response) { return response.text(); })
+      .then(evalJsonp)
+      .then(function(result) {
+          assert_equals(result.method, 'POST');
+          assert_equals(result.body, 'Test String');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch with string body test in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    var text = "Test ArrayBuffer";
+    var array = new Uint8Array(text.length);
+    for (var i = 0; i < text.length; ++i)
+      array[i] = text.charCodeAt(i);
+    var request = new Request('fetch-access-control.php',
+                              {method: 'POST', body: array.buffer});
+    fetch(request)
+      .then(function(response) { return response.text(); })
+      .then(evalJsonp)
+      .then(function(result) {
+          assert_equals(result.method, 'POST');
+          assert_equals(result.body, 'Test ArrayBuffer');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch with ArrayBuffer body test in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    var text = "Test ArrayBufferView";
+    var array = new Uint8Array(text.length);
+    for (var i = 0; i < text.length; ++i)
+      array[i] = text.charCodeAt(i);
+    var request = new Request('fetch-access-control.php',
+                              {method: 'POST', body: array});
+    fetch(request)
+      .then(function(response) { return response.text(); })
+      .then(evalJsonp)
+      .then(function(result) {
+          assert_equals(result.method, 'POST');
+          assert_equals(result.body, 'Test ArrayBufferView');
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch with ArrayBufferView body test in ServiceWorkerGlobalScope');
+
+async_test(function(t) {
+    var formData = new FormData();
+    formData.append('StringKey1', '1234567890');
+    formData.append('StringKey2', 'ABCDEFGHIJ');
+    formData.append('BlobKey', new Blob(['blob content']));
+    formData.append('FileKey',
+                    new File(['file content'], 'file.dat'));
+    var request = new Request('fetch-access-control.php',
+                          {method: 'POST', body: formData});
+    fetch(request)
+      .then(function(response) { return response.text(); })
+      .then(evalJsonp)
+      .then(function(result) {
+          assert_equals(result.method, 'POST');
+          assert_equals(result.post['StringKey1'], '1234567890');
+          assert_equals(result.post['StringKey2'], 'ABCDEFGHIJ');
+          var files = [];
+          for (var i = 0; i < result.files.length; ++i) {
+            files[result.files[i].key] = result.files[i];
+          }
+          assert_equals(files['BlobKey'].content, 'blob content');
+          assert_equals(files['BlobKey'].name, 'blob');
+          assert_equals(files['BlobKey'].size, 12);
+          assert_equals(files['FileKey'].content, 'file content');
+          assert_equals(files['FileKey'].name, 'file.dat');
+          assert_equals(files['FileKey'].size, 12);
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+  }, 'Fetch with FormData body test in ServiceWorkerGlobalScope');
+
+test(function(t) {
+    function runInfiniteFetchLoop() {
+      fetch('dummy.html')
+        .then(function() { runInfiniteFetchLoop(); });
+    }
+    runInfiniteFetchLoop();
+  },
+  'Destroying the execution context while fetch is happening should not ' +
+      'cause a crash.');
diff --git a/testing/web-platform/tests/cache/resources/headers-worker.js b/testing/web-platform/tests/cache/resources/headers-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/headers-worker.js
@@ -0,0 +1,205 @@
+importScripts('worker-testharness.js');
+
+test(function() {
+    function size(headers) {
+      var count = 0;
+      for (var header of headers) {
+        ++count;
+      }
+      return count;
+    }
+
+    var expectedMap = {
+        'content-language': 'ja',
+        'content-type': 'text/html; charset=UTF-8',
+        'x-serviceworker-test': 'response test field'
+    };
+
+    var headers = new Headers;
+    headers.set('Content-Language', 'ja');
+    headers.set('Content-Type', 'text/html; charset=UTF-8');
+    headers.set('X-ServiceWorker-Test', 'text/html; charset=UTF-8');
+
+    assert_equals(size(headers), 3, 'headers size should match');
+
+    // 'has()', 'get()'
+    var key = 'Content-Type';
+    assert_true(headers.has(key));
+    assert_true(headers.has(key.toUpperCase()));
+    assert_equals(headers.get(key), expectedMap[key.toLowerCase()]);
+    assert_equals(headers.get(key.toUpperCase()), expectedMap[key.toLowerCase()]);
+    assert_equals(headers.get('dummy'), null);
+    assert_false(headers.has('dummy'));
+
+    // 'delete()'
+    var deleteKey = 'Content-Type';
+    headers.delete(deleteKey);
+    assert_equals(size(headers), 2, 'headers size should have -1 size');
+    Object.keys(expectedMap).forEach(function(key) {
+        if (key == deleteKey.toLowerCase())
+            assert_false(headers.has(key));
+        else
+            assert_true(headers.has(key));
+    });
+
+    // 'set()'
+    var testCasesForSet = [
+        // For a new key/value pair.
+        { key: 'Cache-Control',
+          value: 'max-age=3600',
+          isNewEntry: true },
+
+        // For an existing key.
+        { key: 'X-ServiceWorker-Test',
+          value: 'response test field - updated',
+          isUpdate: true },
+
+        // For setting a numeric value, expecting to see DOMString on getting.
+        { key: 'X-Numeric-Value',
+          value: 12345,
+          expectedValue: '12345',
+          isNewEntry: true },
+
+        // For case-insensitivity test.
+        { key: 'content-language',
+          value: 'fi',
+          isUpdate: true }
+    ];
+
+    var expectedHeaderSize = size(headers);
+    testCasesForSet.forEach(function(testCase) {
+        var key = testCase.key;
+        var value = testCase.value;
+        var expectedValue = ('expectedValue' in testCase) ? testCase.expectedValue : testCase.value;
+        expectedHeaderSize = testCase.isNewEntry ? (expectedHeaderSize + 1) : expectedHeaderSize;
+
+        headers.set(key, value);
+        assert_true(headers.has(key));
+        assert_equals(headers.get(key), expectedValue);
+        if (testCase.isUpdate)
+            assert_true(headers.get(key) != expectedMap[key.toLowerCase()]);
+        assert_equals(size(headers), expectedHeaderSize);
+
+        // Update expectedMap too for forEach() test below.
+        expectedMap[key.toLowerCase()] = expectedValue;
+    });
+
+    // '[Symbol.iterator]()'
+    for (var header of headers) {
+      var key = header[0], value = header[1];
+      assert_true(key != deleteKey.toLowerCase());
+      assert_true(key in expectedMap);
+      assert_equals(headers.get(key), expectedMap[key]);
+    }
+
+    // 'append()', 'getAll()'
+    var allValues = headers.getAll('X-ServiceWorker-Test');
+    assert_equals(allValues.length, 1);
+    assert_equals(size(headers), 4);
+    headers.append('X-SERVICEWORKER-TEST', 'response test field - append');
+    assert_equals(size(headers), 5, 'headers size should increase by 1.');
+    assert_equals(headers.get('X-SERVICEWORKER-Test'),
+                  'response test field - updated',
+                  'the value of the first header added should be returned.');
+    allValues = headers.getAll('X-SERVICEWorker-TEST');
+    assert_equals(allValues.length, 2);
+    assert_equals(allValues[0], 'response test field - updated');
+    assert_equals(allValues[1], 'response test field - append');
+    headers.set('X-SERVICEWorker-Test', 'response test field - set');
+    assert_equals(size(headers), 4, 'the second header should be deleted');
+    allValues = headers.getAll('X-ServiceWorker-Test');
+    assert_equals(allValues.length, 1, 'the second header should be deleted');
+    assert_equals(allValues[0], 'response test field - set');
+    headers.append('X-ServiceWorker-TEST', 'response test field - append');
+    assert_equals(size(headers), 5, 'headers size should increase by 1.')
+    headers.delete('X-ServiceWORKER-Test');
+    assert_equals(size(headers), 3, 'two headers should be deleted.')
+
+    // new Headers with sequence<sequence<ByteString>>
+    headers = new Headers([['a', 'b'], ['c', 'd'], ['c', 'e']]);
+    assert_equals(size(headers), 3, 'headers size should match');
+    assert_equals(headers.get('a'), 'b');
+    assert_equals(headers.get('c'), 'd');
+    assert_equals(headers.getAll('c')[0], 'd');
+    assert_equals(headers.getAll('c')[1], 'e');
+
+    // new Headers with Headers
+    var headers2 = new Headers(headers);
+    assert_equals(size(headers2), 3, 'headers size should match');
+    assert_equals(headers2.get('a'), 'b');
+    assert_equals(headers2.get('c'), 'd');
+    assert_equals(headers2.getAll('c')[0], 'd');
+    assert_equals(headers2.getAll('c')[1], 'e');
+    headers.set('a', 'x');
+    assert_equals(headers.get('a'), 'x');
+    assert_equals(headers2.get('a'), 'b');
+
+    // new Headers with Dictionary
+    headers = new Headers({'a': 'b', 'c': 'd'});
+    assert_equals(size(headers), 2, 'headers size should match');
+    assert_equals(headers.get('a'), 'b');
+    assert_equals(headers.get('c'), 'd');
+
+    // Throw errors
+    var invalidNames = ['', '(', ')', '<', '>', '@', ',', ';', ':', '\\', '"',
+                        '/', '[', ']', '?', '=', '{', '}', '\u3042', 'a(b'];
+    invalidNames.forEach(function(name) {
+        assert_throws({name:'TypeError'},
+                      function() { headers.append(name, 'a'); },
+                      'Headers.append with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.delete(name); },
+                      'Headers.delete with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.get(name); },
+                      'Headers.get with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.getAll(name); },
+                      'Headers.getAll with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.has(name); },
+                      'Headers.has with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.set(name, 'a'); },
+                      'Headers.set with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() {
+                        var obj = {};
+                        obj[name] = 'a';
+                        var headers = new Headers(obj);
+                      },
+                      'new Headers with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() { var headers = new Headers([[name, 'a']]); },
+                      'new Headers with an invalid name (' + name +') should throw');
+    });
+
+    var invalidValues = ['test \r data', 'test \n data'];
+    invalidValues.forEach(function(value) {
+        assert_throws({name:'TypeError'},
+                      function() { headers.append('a', value); },
+                      'Headers.append with an invalid value should throw');
+        assert_throws({name:'TypeError'},
+                      function() { headers.set('a', value); },
+                      'Headers.set with an invalid value should throw');
+        assert_throws({name:'TypeError'},
+                      function() { var headers = new Headers({'a': value}); },
+                      'new Headers with an invalid value should throw');
+        assert_throws({name:'TypeError'},
+                      function() { var headers = new Headers([['a', value]]); },
+                      'new Headers with an invalid value should throw');
+    });
+
+    assert_throws({name:'TypeError'},
+                  function() { var headers = new Headers([[]]); },
+                  'new Headers with a sequence with less than two strings should throw');
+    assert_throws({name:'TypeError'},
+                  function() { var headers = new Headers([['a']]); },
+                  'new Headers with a sequence with less than two strings should throw');
+    assert_throws({name:'TypeError'},
+                  function() { var headers = new Headers([['a', 'b'], []]); },
+                  'new Headers with a sequence with less than two strings should throw');
+    assert_throws({name:'TypeError'},
+                  function() { var headers = new Headers([['a', 'b'], ['x', 'y', 'z']]); },
+                  'new Headers with a sequence with more than two strings should throw');
+}, 'Headers in ServiceWorkerGlobalScope');
diff --git a/testing/web-platform/tests/cache/resources/indexeddb-worker.js b/testing/web-platform/tests/cache/resources/indexeddb-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/indexeddb-worker.js
@@ -0,0 +1,26 @@
+var port;
+self.addEventListener('message', function(e) {
+    var message = e.data;
+    if ('port' in message)
+        doIndexedDBTest(message.port);
+});
+
+function doIndexedDBTest(port) {
+    var delete_request = indexedDB.deleteDatabase('db');
+    delete_request.onsuccess = function() {
+        var open_request = indexedDB.open('db');
+        open_request.onupgradeneeded = function() {
+            var db = open_request.result;
+            db.createObjectStore('store');
+        };
+        open_request.onsuccess = function() {
+            var db = open_request.result;
+            var tx = db.transaction('store', 'readwrite');
+            var store = tx.objectStore('store');
+            store.put('value', 'key');
+            tx.oncomplete = function() {
+                port.postMessage('done');
+            };
+        };
+    };
+}
diff --git a/testing/web-platform/tests/cache/resources/interfaces-worker.js b/testing/web-platform/tests/cache/resources/interfaces-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/interfaces-worker.js
@@ -0,0 +1,57 @@
+importScripts('interfaces.js');
+importScripts('worker-testharness.js');
+importScripts('/resources/testharness-helpers.js');
+
+test(function() {
+    var EVENT_HANDLER = 'object';
+
+    verifyInterface('ServiceWorkerGlobalScope',
+                    self,
+                    {
+                        scope: 'string',
+                        clients: 'object',
+                        close: 'function',
+
+                        onactivate: EVENT_HANDLER,
+                        onfetch: EVENT_HANDLER,
+                        oninstall: EVENT_HANDLER,
+                        onmessage: EVENT_HANDLER
+                    });
+
+    verifyInterface('ServiceWorkerClients',
+                    self.clients,
+                    {
+                        getAll: 'function'
+                    });
+
+    verifyInterface('ServiceWorkerClient');
+    // FIXME: Get an instance and test it, or ensure property exists on prototype.
+
+    verifyInterface('CacheStorage',
+                    self.caches,
+                    {
+                      match: 'function',
+                      get: 'function',
+                      has: 'function',
+                      create: 'function',
+                      delete: 'function',
+                      keys: 'function'
+                    });
+  }, 'Interfaces and attributes in ServiceWorkerGlobalScope');
+
+promise_test(function(t) {
+    return create_temporary_cache(t)
+      .then(function(cache) {
+          verifyInterface('Cache',
+                          cache,
+                          {
+                            match: 'function',
+                            matchAll: 'function',
+                            add: 'function',
+                            addAll: 'function',
+                            put: 'function',
+                            delete: 'function',
+                            keys: 'function'
+                          });
+        });
+  }, 'Cache');
diff --git a/testing/web-platform/tests/cache/resources/interfaces.js b/testing/web-platform/tests/cache/resources/interfaces.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/interfaces.js
@@ -0,0 +1,15 @@
+function verifyInterface(name, instance, attributes) {
+    assert_true(name in self,
+                name + ' should be an defined type');
+    if (instance) {
+        assert_true(instance instanceof self[name],
+                    instance + ' should be an instance of ' + name);
+        Object.keys(attributes || {}).forEach(function(attribute) {
+            var type = attributes[attribute];
+            assert_true(attribute in instance,
+                        attribute + ' should be an attribute of ' + name);
+            assert_equals(typeof instance[attribute], type,
+                          attribute + ' should be of type ' + type);
+        });
+    }
+}
diff --git a/testing/web-platform/tests/cache/resources/invalid-chunked-encoding-with-flush.php b/testing/web-platform/tests/cache/resources/invalid-chunked-encoding-with-flush.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/invalid-chunked-encoding-with-flush.php
@@ -0,0 +1,7 @@
+<?php 
+header('Content-Type:application/javascript');
+header("Transfer-encoding: chunked");
+flush();
+sleep(1);
+echo "XX\r\n\r\n";
+?>
diff --git a/testing/web-platform/tests/cache/resources/invalid-chunked-encoding.php b/testing/web-platform/tests/cache/resources/invalid-chunked-encoding.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/invalid-chunked-encoding.php
@@ -0,0 +1,5 @@
+<?php 
+header('Content-Type:application/javascript');
+header("Transfer-encoding: chunked");
+echo "XX\r\n\r\n";
+?>
diff --git a/testing/web-platform/tests/cache/resources/other.html b/testing/web-platform/tests/cache/resources/other.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/other.html
@@ -0,0 +1,3 @@
+<!DOCTYPE html>
+<title>Other</title>
+Here's an other html file.
diff --git a/testing/web-platform/tests/cache/resources/plain-text-worker.php b/testing/web-platform/tests/cache/resources/plain-text-worker.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/plain-text-worker.php
@@ -0,0 +1,3 @@
+<?php
+    header("Content-Type: text/plain");
+?>
diff --git a/testing/web-platform/tests/cache/resources/postmessage-msgport-to-client-worker.js b/testing/web-platform/tests/cache/resources/postmessage-msgport-to-client-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/postmessage-msgport-to-client-worker.js
@@ -0,0 +1,18 @@
+self.onmessage = function(e) {
+    self.clients.getAll().then(function(clients) {
+        clients.forEach(function(client) {
+            var messageChannel = new MessageChannel();
+            messageChannel.port1.onmessage = onMessageViaMessagePort.bind(null, client);
+            client.postMessage({port: messageChannel.port2}, [messageChannel.port2]);
+        });
+    });
+};
+
+function onMessageViaMessagePort(client, e) {
+    var message = e.data;
+    if ('value' in message) {
+        client.postMessage({ack: 'Acking value: ' + message.value});
+    } else if ('done' in message) {
+        client.postMessage({done: true});
+    }
+}
diff --git a/testing/web-platform/tests/cache/resources/postmessage-to-client-worker.js b/testing/web-platform/tests/cache/resources/postmessage-to-client-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/postmessage-to-client-worker.js
@@ -0,0 +1,10 @@
+self.onmessage = function(e) {
+    self.clients.getAll().then(function(clients) {
+        clients.forEach(function(client) {
+            client.postMessage('Sending message via clients');
+            if (!Array.isArray(clients))
+                client.postMessage('clients is not an array');
+            client.postMessage('quit');
+        });
+    });
+};
diff --git a/testing/web-platform/tests/cache/resources/postmessage-worker.js b/testing/web-platform/tests/cache/resources/postmessage-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/postmessage-worker.js
@@ -0,0 +1,19 @@
+var port;
+
+// Exercise the 'onmessage' handler:
+self.onmessage = function(e) {
+    var message = e.data;
+    if ('port' in message) {
+        port = message.port;
+    }
+};
+
+// And an event listener:
+self.addEventListener('message', function(e) {
+    var message = e.data;
+    if ('value' in message) {
+        port.postMessage('Acking value: ' + message.value);
+    } else if ('done' in message) {
+        port.postMessage('quit');
+    }
+});
diff --git a/testing/web-platform/tests/cache/resources/redirect.php b/testing/web-platform/tests/cache/resources/redirect.php
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/redirect.php
@@ -0,0 +1,4 @@
+<?php
+    $url = $_GET['Redirect'];
+    header("Location: $url");
+?>
diff --git a/testing/web-platform/tests/cache/resources/registration-worker.js b/testing/web-platform/tests/cache/resources/registration-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/registration-worker.js
@@ -0,0 +1,1 @@
+// empty for now
diff --git a/testing/web-platform/tests/cache/resources/reject-install-worker.js b/testing/web-platform/tests/cache/resources/reject-install-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/reject-install-worker.js
@@ -0,0 +1,3 @@
+self.oninstall = function(event) {
+  event.waitUntil(Promise.reject());
+};
diff --git a/testing/web-platform/tests/cache/resources/request-end-to-end-worker.js b/testing/web-platform/tests/cache/resources/request-end-to-end-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/request-end-to-end-worker.js
@@ -0,0 +1,22 @@
+var port = undefined;
+
+onmessage = function(e) {
+    var message = e.data;
+    if (typeof message === 'object' && 'port' in message) {
+        port = message.port;
+    }
+};
+
+onfetch = function(e) {
+    var headers = {};
+    for (var header of e.request.headers) {
+      var key = header[0], value = header[1];
+      headers[key] = value;
+    }
+    port.postMessage({
+        url: e.request.url,
+        method: e.request.method,
+        headers: headers,
+        headerSize: e.request.headers.size
+    });
+}
diff --git a/testing/web-platform/tests/cache/resources/request-worker.js b/testing/web-platform/tests/cache/resources/request-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/request-worker.js
@@ -0,0 +1,448 @@
+importScripts('worker-testharness.js');
+importScripts('../../resources/testharness-helpers.js');
+importScripts('test-helpers.js');
+
+var URL = 'https://www.example.com/test.html';
+
+function size(headers) {
+  var count = 0;
+  for (var header of headers) {
+    ++count;
+  }
+  return count;
+}
+
+test(function() {
+    var headers = new Headers;
+    headers.set('User-Agent', 'Mozilla/5.0');
+    headers.set('Accept', 'text/html');
+    headers.set('X-ServiceWorker-Test', 'request test field');
+
+    var request = new Request(URL, {method: 'GET', headers: headers});
+
+    assert_equals(request.url, URL, 'Request.url should match');
+    assert_equals(request.method, 'GET', 'Request.method should match');
+    assert_equals(request.referrer, location.href, 'Request.referrer should match');
+    assert_true(request.headers instanceof Headers, 'Request.headers should be Headers');
+
+    // 'User-Agent' is a forbidden header.
+    assert_equals(size(request.headers), 2, 'Request.headers size should match');
+    // Note: detailed behavioral tests for Headers are in another test,
+    // http/tests/serviceworker/headers.html.
+
+    request.url = 'http://localhost/';
+    assert_equals(request.url, 'https://www.example.com/test.html', 'Request.url should be readonly');
+    request = new Request('http://localhost/\uD800'); // Unmatched lead surrogate.
+    assert_equals(request.url,
+                  'http://localhost/' + encodeURIComponent('\uFFFD'),
+                  'Request.url should have unmatched surrogates replaced.');
+    request.method = 'POST';
+    assert_equals(request.method, 'GET', 'Request.method should be readonly');
+}, 'Request basic test in ServiceWorkerGlobalScope');
+
+test(function() {
+    [new Request(URL),
+     new Request(URL, {method: ''}),
+     new Request(URL, {mode: ''}),
+     new Request(URL, {mode: 'invalid mode'}),
+     new Request(URL, {credentials: ''}),
+     new Request(URL, {credentials: 'invalid credentials'})].forEach(function(request) {
+        assert_equals(request.url, URL, 'Request.url should match');
+        assert_equals(request.method, 'GET', 'Default Request.method should be GET');
+        assert_equals(request.mode, 'cors', 'Default Request.mode should be cors');
+        assert_equals(request.credentials, 'omit', 'Default Request.credentials should be omit');
+    });
+}, 'Request default value test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var request = new Request(URL);
+    request.headers.append('X-ServiceWorker-Foo', 'foo1');
+    request.headers.append('X-ServiceWorker-Foo', 'foo2');
+    request.headers.append('X-ServiceWorker-Bar', 'bar');
+    var request2 = new Request(request);
+    assert_equals(request2.url, URL, 'Request.url should match');
+    assert_equals(request2.method, 'GET', 'Request.method should match');
+    assert_equals(request2.mode, 'cors', 'Request.mode should match');
+    assert_equals(request2.credentials, 'omit', 'Request.credentials should match');
+    assert_equals(request2.headers.getAll('X-ServiceWorker-Foo')[0], 'foo1',
+                  'Request.headers should match');
+    assert_equals(request2.headers.getAll('X-ServiceWorker-Foo')[1], 'foo2',
+                  'Request.headers should match');
+    assert_equals(request2.headers.getAll('X-ServiceWorker-Bar')[0], 'bar',
+                  'Request.headers should match');
+    var request3 = new Request(URL, {headers: [['X-ServiceWorker-Foo', 'foo1'],
+                                               ['X-ServiceWorker-Foo', 'foo2'],
+                                               ['X-ServiceWorker-Bar', 'bar']]});
+    assert_equals(request3.headers.getAll('X-ServiceWorker-Foo')[0], 'foo1',
+                  'Request.headers should match');
+    assert_equals(request3.headers.getAll('X-ServiceWorker-Foo')[1], 'foo2',
+                  'Request.headers should match');
+    assert_equals(request3.headers.getAll('X-ServiceWorker-Bar')[0], 'bar',
+                  'Request.headers should match');
+}, 'Request header test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var request1 = {};
+    var request2 = {};
+    var METHODS = ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS', '', undefined];
+    var MODES = ['same-origin', 'no-cors', 'cors', '', undefined];
+    function isSimpleMethod(method) {
+      return ['GET', 'HEAD', 'POST', '', undefined].indexOf(method) != -1;
+    };
+    function effectiveMethod(method1, method2) {
+      return method2 ? method2 : (method1 ? method1 : 'GET');
+    };
+    function effectiveMode(mode1, mode2) {
+      return mode2 ? mode2 : (mode1 ? mode1 : 'cors');
+    };
+    METHODS.forEach(function(method1) {
+        MODES.forEach(function(mode1) {
+            var init1 = {};
+            if (method1 != undefined) { init1['method'] = method1; }
+            if (mode1 != undefined) { init1['mode'] = mode1; }
+            if (!isSimpleMethod(method1) && mode1 == 'no-cors') {
+                assert_throws(
+                    {name:'TypeError'},
+                    function() { request1 = new Request(URL, init1); },
+                    'new no-cors Request with non simple method (' + method1 +') should throw');
+                return;
+            }
+            request1 = new Request(URL, init1);
+            assert_equals(request1.method, method1 ? method1 : 'GET', 'Request.method should match');
+            assert_equals(request1.mode, mode1 ? mode1 : 'cors', 'Request.mode should match');
+            request1 = new Request(request1);
+            assert_equals(request1.method, method1 ? method1 : 'GET', 'Request.method should match');
+            assert_equals(request1.mode, mode1 ? mode1 : 'cors', 'Request.mode should match');
+            METHODS.forEach(function(method2) {
+                MODES.forEach(function(mode2) {
+                    // We need to construct a new request1 because as soon as it
+                    // is used in a constructor it will be flagged as 'used',
+                    // and we can no longer construct objects with it.
+                    request1 = new Request(URL, init1);
+                    var init2 = {};
+                    if (method2 != undefined) { init2['method'] = method2; }
+                    if (mode2 != undefined) { init2['mode'] = mode2; }
+                    if (!isSimpleMethod(effectiveMethod(method1, method2)) && effectiveMode(mode1, mode2) == 'no-cors') {
+                        assert_throws(
+                            {name:'TypeError'},
+                            function() { request2 = new Request(request1, init2); },
+                            'new no-cors Request with non simple method should throw');
+                        return;
+                    }
+                    request2 = new Request(request1, init2);
+                    assert_equals(request2.method,
+                                  method2 ? method2 : request1.method,
+                                  'Request.method should be overridden');
+                    assert_equals(request2.mode,
+                                  mode2 ? mode2 : request1.mode,
+                                  'Request.mode should be overridden');
+                });
+            });
+        });
+    });
+}, 'Request header test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var request1 = {};
+    var request2 = {};
+    var CREDENTIALS = ['omit', 'same-origin', 'include', '', undefined];
+    CREDENTIALS.forEach(function(credentials1) {
+        var init1 = {};
+        if (credentials1 != undefined) { init1['credentials'] = credentials1; }
+        request1 = new Request(URL, init1);
+        assert_equals(request1.credentials, credentials1 ? credentials1 : 'omit', 'Request.credentials should match');
+        request1 = new Request(request1);
+        assert_equals(request1.credentials, credentials1 ? credentials1 : 'omit', 'Request.credentials should match');
+        CREDENTIALS.forEach(function(credentials2) {
+            request1 = new Request(URL, init1);
+            var init2 = {};
+            if (credentials2 != undefined) { init2['credentials'] = credentials2; }
+            request2 = new Request(request1, init2);
+            assert_equals(request2.credentials,
+                          credentials2 ? credentials2 : request1.credentials,
+                          'Request.credentials should be overridden');
+        });
+    });
+}, 'Request credentials test in ServiceWorkerGlobalScope');
+
+test(function() {
+    ['same-origin', 'cors', 'no-cors'].forEach(function(mode) {
+        var forbiddenMethods = ['TRACE', 'TRACK', 'CONNECT'];
+        forbiddenMethods.forEach(function(method) {
+            assert_throws(
+                {name:'TypeError'},
+                function() { var request = new Request(URL, {mode: mode, method: method}); },
+                'new Request with a forbidden method (' + method +') should throw');
+        });
+        var invalidNames = ['(', ')', '<', '>', '@', ',', ';', ':', '\\', '"',
+                            '/', '[', ']', '?', '=', '{', '}', '\u3042', 'a(b',
+                            'invalid name'];
+        invalidNames.forEach(function(name) {
+            assert_throws(
+                {name:'TypeError'},
+                function() { var request = new Request(URL, {mode: mode, method: name}); },
+                'new Request with an invalid method (' + name +') should throw');
+        });
+    });
+}, 'Request method name test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var FORBIDDEN_HEADERS =
+        ['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers',
+         'Access-Control-Request-Method', 'Connection', 'Content-Length', 'Cookie',
+         'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin',
+         'Referer', 'TE', 'Trailer', 'Transfer-Encoding', 'Upgrade', 'User-Agent',
+         'Via', 'Proxy-', 'Sec-', 'Proxy-FooBar', 'Sec-FooBar'];
+    var SIMPLE_HEADERS =
+        [['Accept', '*'], ['Accept-Language', 'ru'], ['Content-Language', 'ru'],
+         ['Content-Type', 'application/x-www-form-urlencoded'],
+         ['Content-Type', 'multipart/form-data'],
+         ['Content-Type', 'text/plain']];
+    var NON_SIMPLE_HEADERS =
+        [['X-ServiceWorker-Test', 'test'],
+         ['X-ServiceWorker-Test2', 'test2'],
+         ['Content-Type', 'foo/bar']];
+
+   ['same-origin', 'cors'].forEach(function(mode) {
+        var request = new Request(URL, {mode: mode});
+        FORBIDDEN_HEADERS.forEach(function(header) {
+            request.headers.append(header, 'test');
+            assert_equals(size(request.headers), 0,
+                          'Request.headers.append should ignore the forbidden headers');
+            request.headers.set(header, 'test');
+            assert_equals(size(request.headers), 0,
+                          'Request.headers.set should ignore the forbidden headers');
+        });
+        var request = new Request(URL, {mode: mode});
+        assert_equals(size(request.headers), 0);
+        NON_SIMPLE_HEADERS.forEach(function(header) {
+            request.headers.append(header[0], header[1]);
+        });
+        assert_equals(size(request.headers), NON_SIMPLE_HEADERS.length);
+        NON_SIMPLE_HEADERS.forEach(function(header) {
+            assert_equals(request.headers.get(header[0]), header[1]);
+        });
+        request = new Request(URL, {mode: mode});
+        assert_equals(size(request.headers), 0);
+        NON_SIMPLE_HEADERS.forEach(function(header) {
+            request.headers.set(header[0], header[1]);
+        });
+        assert_equals(size(request.headers), NON_SIMPLE_HEADERS.length);
+        NON_SIMPLE_HEADERS.forEach(function(header) {
+            assert_equals(request.headers.get(header[0]), header[1]);
+        });
+    });
+    request = new Request(URL, {mode: 'no-cors'});
+    FORBIDDEN_HEADERS.forEach(function(header) {
+        request.headers.set(header, 'test');
+        request.headers.append(header, 'test');
+    });
+    NON_SIMPLE_HEADERS.forEach(function(header) {
+        request.headers.set(header[0], header[1]);
+        request.headers.append(header[0], header[1]);
+    });
+    assert_equals(size(request.headers), 0,
+                  'no-cors request should only accept simple headers');
+
+    SIMPLE_HEADERS.forEach(function(header) {
+        request = new Request(URL, {mode: 'no-cors'});
+        request.headers.append(header[0], header[1]);
+        assert_equals(size(request.headers), 1,
+                      'no-cors request should accept simple headers');
+        request = new Request(URL, {mode: 'no-cors'});
+        request.headers.set(header[0], header[1]);
+        assert_equals(size(request.headers), 1,
+                      'no-cors request should accept simple headers');
+        request.headers.delete(header[0]);
+        if (header[0] == 'Content-Type') {
+            assert_equals(
+                size(request.headers), 1,
+                'Content-Type header of no-cors request shouldn\'t be deleted');
+        } else {
+            assert_equals(size(request.headers), 0);
+        }
+    });
+
+    SIMPLE_HEADERS.forEach(function(header) {
+        var headers = {};
+        NON_SIMPLE_HEADERS.forEach(function(header2) {
+            headers[header2[0]] = header2[1];
+        });
+        FORBIDDEN_HEADERS.forEach(function(header) { headers[header] = 'foo'; });
+        headers[header[0]] = header[1];
+        var expectedSize = NON_SIMPLE_HEADERS.length;
+        if (header[0] != 'Content-Type') {
+            ++expectedSize;
+        }
+        ['same-origin', 'cors'].forEach(function(mode) {
+          request = new Request(URL, {mode: mode, headers: headers});
+          assert_equals(size(request.headers), expectedSize,
+                        'Request should not support the forbidden headers');
+        });
+        request = new Request(URL, {mode: 'no-cors', headers: headers});
+        assert_equals(size(request.headers), 1,
+                      'No-CORS Request.headers should only support simple headers');
+        ['same-origin', 'cors', 'no-cors'].forEach(function(mode) {
+            request = new Request(new Request(URL, {mode: mode, headers: headers}), {mode: 'no-cors'});
+            assert_equals(size(request.headers), 1,
+                          'No-CORS Request.headers should only support simple headers');
+        });
+    });
+}, 'Request headers test in ServiceWorkerGlobalScope');
+
+test(function() {
+  var url = 'http://example.com';
+  ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'].forEach(function(method) {
+    assert_equals(new Request(url, {method: method.toLowerCase()}).method,
+                  method,
+                  'method should be normalized to uppercase: ' + method);
+  });
+
+  ['PATCH', 'MKCOL', 'CUSTOM', 'X-FILES'].forEach(function(method) {
+    assert_equals(new Request(url, {method: method}).method, method,
+                  'method should not be changed when normalized: ' + method);
+    method = method.toLowerCase();
+    assert_equals(new Request(url, {method: method}).method, method,
+                  'method should not be changed when normalized: ' + method);
+  });
+}, 'Request method names are normalized');
+
+test(function() {
+    var req = new Request(URL);
+    assert_false(req.bodyUsed,
+      "Request should not be flagged as used if it has not been consumed.");
+    var req2 = new Request(req);
+    assert_true(req.bodyUsed,
+      "Request should be flagged as used if it is used as a construction " +
+      "argument of another Request.");
+    assert_false(req2.bodyUsed,
+      "Request should not be flagged as used if it has not been consumed.");
+    assert_throws(new TypeError(), function() { new Request(req); },
+      "Request cannot be constructed with a request that has been flagged as used.");
+  }, 'Request construction behavior regarding "used" body flag and exceptions.');
+
+promise_test(function() {
+  var headers = new Headers;
+  headers.set('Content-Language', 'ja');
+  var req = new Request(URL, {
+    method: 'GET',
+    headers: headers,
+    body: new Blob(['Test Blob'], {type: 'test/type'})
+  });
+  var req2 = req.clone();
+  // Change headers and of original request.
+  req.headers.set('Content-Language', 'en');
+  assert_equals(
+    req2.headers.get('Content-Language'), 'ja', 'Headers of cloned request ' +
+    'should not change when original request headers are changed.');
+
+  return req.text()
+    .then(function(text) {
+        assert_equals(text, 'Test Blob', 'Body of request should match.');
+        return req2.text();
+      })
+    .then(function(text) {
+        assert_equals(text, 'Test Blob', 'Cloned request body should match.');
+      });
+  }, 'Test clone behavior with loading content from Request.');
+
+async_test(function(t) {
+    var getContentType = function(headers) {
+        var content_type = '';
+        for (var header of headers) {
+          if (header[0] == 'content-type')
+            content_type = header[1];
+        }
+        return content_type;
+      };
+    var request =
+      new Request(URL,
+                  {
+                    method: 'POST',
+                    body: new Blob(['Test Blob'], {type: 'test/type'})
+                  });
+    assert_equals(
+      getContentType(request.headers), 'test/type',
+      'ContentType header of Request created with Blob body must be set.');
+    assert_false(request.bodyUsed,
+                 'bodyUsed must be true before calling text()');
+    request.text()
+      .then(function(result) {
+          assert_equals(result, 'Test Blob',
+                        'Creating a Request with Blob body should success.');
+
+          request = new Request(URL, {method: 'POST', body: 'Test String'});
+          assert_equals(
+            getContentType(request.headers), 'text/plain;charset=UTF-8',
+            'ContentType header of Request created with string must be set.');
+          return request.text();
+        })
+      .then(function(result) {
+          assert_equals(result, 'Test String',
+                        'Creating a Request with string body should success.');
+
+          var text = "Test ArrayBuffer";
+          var array = new Uint8Array(text.length);
+          for (var i = 0; i < text.length; ++i)
+            array[i] = text.charCodeAt(i);
+          request = new Request(URL, {method: 'POST', body: array.buffer});
+          return request.text();
+        })
+      .then(function(result) {
+          assert_equals(
+            result, 'Test ArrayBuffer',
+            'Creating a Request with ArrayBuffer body should success.');
+
+          var text = "Test ArrayBufferView";
+          var array = new Uint8Array(text.length);
+          for (var i = 0; i < text.length; ++i)
+            array[i] = text.charCodeAt(i);
+          request = new Request(URL, {method: 'POST', body: array});
+          return request.text();
+        })
+      .then(function(result) {
+          assert_equals(
+            result, 'Test ArrayBufferView',
+            'Creating a Request with ArrayBuffer body should success.');
+
+          var formData = new FormData();
+          formData.append('sample string', '1234567890');
+          formData.append('sample blob', new Blob(['blob content']));
+          formData.append('sample file',
+                          new File(['file content'], 'file.dat'));
+          request = new Request(URL, {method: 'POST', body: formData});
+          return request.text();
+        })
+      .then(function(result) {
+          var reg = new RegExp('multipart\/form-data; boundary=(.*)');
+          var regResult = reg.exec(getContentType(request.headers));
+          var boundary = regResult[1];
+          var expected_body =
+            '--' + boundary + '\r\n' +
+            'Content-Disposition: form-data; name="sample string"\r\n' +
+            '\r\n' +
+            '1234567890\r\n' +
+            '--' + boundary + '\r\n' +
+            'Content-Disposition: form-data; name="sample blob"; ' +
+            'filename="blob"\r\n' +
+            'Content-Type: application/octet-stream\r\n' +
+            '\r\n' +
+            'blob content\r\n' +
+            '--' + boundary + '\r\n' +
+            'Content-Disposition: form-data; name="sample file"; ' +
+            'filename="file.dat"\r\n' +
+            'Content-Type: application/octet-stream\r\n' +
+            '\r\n' +
+            'file content\r\n' +
+            '--' + boundary + '--\r\n';
+          assert_equals(
+            result, expected_body,
+            'Creating a Request with FormData body should success.');
+        })
+      .then(function() {
+          t.done();
+        })
+      .catch(unreached_rejection(t));
+    assert_true(request.bodyUsed,
+                'bodyUsed must be true after calling text()');
+  }, 'Request body test in ServiceWorkerGlobalScope');
diff --git a/testing/web-platform/tests/cache/resources/response-content-worker.js b/testing/web-platform/tests/cache/resources/response-content-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/response-content-worker.js
@@ -0,0 +1,101 @@
+importScripts('worker-testharness.js');
+importScripts('../../resources/testharness-helpers.js');
+
+promise_test(function() {
+    var response = new Response('test string');
+    assert_equals(
+      response.headers.get('Content-Type'),
+      'text/plain;charset=UTF-8',
+      'A Response constructed with a string should have a Content-Type.');
+    return response.text()
+      .then(function(text) {
+          assert_equals(text, 'test string',
+            'Response body text should match the string on construction.');
+        });
+  }, 'Behavior of Response with string content.');
+
+promise_test(function() {
+    var intView = new Int32Array([0, 1, 2, 3, 4, 55, 6, 7, 8, 9]);
+    var buffer = intView.buffer;
+
+    var response = new Response(buffer);
+    assert_false(response.headers.has('Content-Type'),
+      'A Response constructed with ArrayBuffer should not have a content type.');
+    return response.arrayBuffer()
+      .then(function(buffer) {
+          var resultIntView = new Int32Array(buffer);
+          assert_array_equals(
+            resultIntView, [0, 1, 2, 3, 4, 55, 6, 7, 8, 9],
+            'Response body ArrayBuffer should match ArrayBuffer ' +
+            'it was constructed with.');
+        });
+  }, 'Behavior of Response with ArrayBuffer content.');
+
+promise_test(function() {
+    var intView = new Int32Array([0, 1, 2, 3, 4, 55, 6, 7, 8, 9]);
+
+    var response = new Response(intView);
+    assert_false(response.headers.has('Content-Type'),
+      'A Response constructed with ArrayBufferView ' +
+      'should not have a content type.');
+    return response.arrayBuffer()
+      .then(function(buffer) {
+          var resultIntView = new Int32Array(buffer);
+          assert_array_equals(
+            resultIntView, [0, 1, 2, 3, 4, 55, 6, 7, 8, 9],
+            'Response body ArrayBuffer should match ArrayBufferView ' +
+            'it was constructed with.');
+        });
+  }, 'Behavior of Response with ArrayBufferView content without a slice.');
+
+promise_test(function() {
+    var intView = new Int32Array([0, 1, 2, 3, 4, 55, 6, 7, 8, 9]);
+    var slice = intView.subarray(1, 4);  // Should be [1, 2, 3]
+    var response = new Response(slice);
+    assert_false(response.headers.has('Content-Type'),
+      'A Response constructed with ArrayBufferView ' +
+      'should not have a content type.');
+    return response.arrayBuffer()
+      .then(function(buffer) {
+          var resultIntView = new Int32Array(buffer);
+          assert_array_equals(
+            resultIntView, [1, 2, 3],
+            'Response body ArrayBuffer should match ArrayBufferView ' +
+            'slice it was constructed with.');
+        });
+  }, 'Behavior of Response with ArrayBufferView content with a slice.');
+
+promise_test(function() {
+    var headers = new Headers;
+    headers.set('Content-Language', 'ja');
+    var response = new Response(
+      'test string', {method: 'GET', headers: headers});
+    assert_false(response.bodyUsed,
+                 "bodyUsed is not set until Response is consumed.");
+    var response2 = response.clone();
+    response.headers.set('Content-Language', 'en');
+    var response3;
+    assert_false(response2.bodyUsed,
+                 "bodyUsed should be false in clone of non-consumed Response.");
+    assert_equals(
+      response2.headers.get('Content-Language'), 'ja', 'Headers of cloned ' +
+      'response should not change when original response headers are changed.');
+
+    return response.text()
+      .then(function(text) {
+          assert_true(
+            response.bodyUsed,
+            "bodyUsed should be true after a response is consumed.");
+          assert_false(
+            response2.bodyUsed, "bodyUsed should be false in Response cloned " +
+            "before the original response was consumed.");
+          response3 = response.clone();
+          assert_true(response3.bodyUsed,
+                      "bodyUsed should be true in clone of consumed response.");
+          return response2.text();
+        })
+      .then(function(text) {
+          assert_equals(text, 'test string',
+            'Response clone response body text should match.');
+        });
+  }, 'Behavior of bodyUsed in Response and clone behavior.');
diff --git a/testing/web-platform/tests/cache/resources/response-worker.js b/testing/web-platform/tests/cache/resources/response-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/response-worker.js
@@ -0,0 +1,143 @@
+importScripts('worker-testharness.js');
+
+function size(headers) {
+  var count = 0;
+  for (var header of headers) {
+    ++count;
+  }
+  return count;
+}
+
+test(function() {
+    var response = new Response(new Blob());
+    assert_equals(response.type, 'default', 'Default Response.type should be \'default\'');
+    assert_equals(response.url, '', 'Response.url should be the empty string');
+    assert_equals(response.status, 200, 'Default Response.status should be 200');
+    assert_equals(response.statusText, 'OK', 'Default Response.statusText should be \'OK\'');
+    assert_equals(size(response.headers), 0, 'Default Response should not have any header.');
+
+    response.status = 394;
+    response.statusText = 'Sesame Street';
+    assert_equals(response.status, 200, 'Response.status should be readonly');
+    assert_equals(response.statusText, 'OK', 'Response.statusText should be readonly');
+}, 'Response default value test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var headers = new Headers;
+    headers.set('Content-Language', 'ja');
+    headers.set('Content-Type', 'text/html; charset=UTF-8');
+    headers.set('X-ServiceWorker-Test', 'response test field');
+    headers.set('Set-Cookie', 'response test set-cookie');
+    headers.set('Set-Cookie2', 'response test set-cookie2');
+
+    var responses =
+        [new Response(new Blob(),
+                      {status: 303, statusText: 'See Other', headers: headers}),
+         new Response(new Blob(),
+                      {
+                          status: 303,
+                          statusText: 'See Other',
+                          headers: {'Content-Language': 'ja',
+                                    'Content-Type': 'text/html; charset=UTF-8',
+                                    'X-ServiceWorker-Test': 'response test field',
+                                    'Set-Cookie': 'response test set-cookie',
+                                    'Set-Cookie2': 'response test set-cookie2'}
+                      }),
+         new Response(new Blob(),
+                      {
+                          status: 303,
+                          statusText: 'See Other',
+                          headers: [['Content-Language', 'ja'],
+                                    ['Content-Type', 'text/html; charset=UTF-8'],
+                                    ['X-ServiceWorker-Test', 'response test field'],
+                                    ['Set-Cookie', 'response test set-cookie'],
+                                    ['Set-Cookie2', 'response test set-cookie2']]
+                      })];
+    responses.forEach(function(response) {
+        assert_equals(response.status, 303, 'Response.status should match');
+        assert_equals(response.statusText, 'See Other', 'Response.statusText should match');
+        assert_true(response.headers instanceof Headers, 'Response.headers should be Headers');
+        assert_equals(size(response.headers), 3, 'Response.headers size should match');
+        assert_equals(response.headers.get('Content-Language'), 'ja',
+                      'Content-Language of Response.headers should match');
+        assert_equals(response.headers.get('Content-Type'), 'text/html; charset=UTF-8',
+                      'Content-Type of Response.headers should match');
+        assert_equals(response.headers.get('X-ServiceWorker-Test'), 'response test field',
+                      'X-ServiceWorker-Test of Response.headers should match');
+        response.headers.set('X-ServiceWorker-Test2', 'response test field2');
+        assert_equals(size(response.headers), 4, 'Response.headers size should increase by 1.');
+        assert_equals(response.headers.get('X-ServiceWorker-Test2'), 'response test field2',
+                      'Response.headers should be added');
+        response.headers.set('set-cookie', 'dummy');
+        response.headers.set('sEt-cookie', 'dummy');
+        response.headers.set('set-cookie2', 'dummy');
+        response.headers.set('set-cOokie2', 'dummy');
+        response.headers.append('set-cookie', 'dummy');
+        response.headers.append('sEt-cookie', 'dummy');
+        response.headers.append('set-cookie2', 'dummy');
+        response.headers.append('set-cOokie2', 'dummy');
+        assert_equals(size(response.headers), 4,
+                      'Response.headers should not accept Set-Cookie nor Set-Cookie2');
+        response.headers.delete('X-ServiceWorker-Test');
+        assert_equals(size(response.headers), 3, 'Response.headers size should decrease by 1.');
+    });
+    // Note: detailed behavioral tests for Headers are in another test,
+    // http/tests/serviceworker/headers.html.
+}, 'Response constructor test in ServiceWorkerGlobalScope');
+
+test(function() {
+    var response = new Response(new Blob(['dummy'], {type :'audio/wav'}));
+    assert_equals(size(response.headers), 1, 'Response.headers should have Content-Type');
+    assert_equals(response.headers.get('Content-Type'), 'audio/wav',
+                  'Content-Type of Response.headers should be set');
+
+    response = new Response(new Blob(['dummy'], {type :'audio/wav'}),
+                            {headers:{'Content-Type': 'text/html; charset=UTF-8'}});
+    assert_equals(size(response.headers), 1, 'Response.headers should have Content-Type');
+    assert_equals(response.headers.get('Content-Type'), 'text/html; charset=UTF-8',
+                  'Content-Type of Response.headers should be overridden');
+}, 'Response content type test in ServiceWorkerGlobalScope');
+
+test(function() {
+    [0, 1, 100, 199, 600, 700].forEach(function(status) {
+        assert_throws({name:'RangeError'},
+                      function() { new Response(new Blob(), {status: status}); },
+                      'new Response with status = ' + status + ' should throw');
+    });
+    [200, 300, 400, 500, 599].forEach(function(status) {
+        var response = new Response(new Blob(), {status: status});
+        assert_equals(response.status, status, 'Response.status should match');
+    });
+
+    var invalidNames = ['', '(', ')', '<', '>', '@', ',', ';', ':', '\\', '"',
+                        '/', '[', ']', '?', '=', '{', '}', '\u3042', 'a(b'];
+    invalidNames.forEach(function(name) {
+        assert_throws({name:'TypeError'},
+                      function() {
+                          var obj = {};
+                          obj[name] = 'a';
+                          new Response(new Blob(), {headers: obj});
+                      },
+                      'new Response with headers with an invalid name (' + name +') should throw');
+        assert_throws({name:'TypeError'},
+                      function() {
+                          new Response(new Blob(), {headers: [[name, 'a']]});
+                      },
+                      'new Response with headers with an invalid name (' + name +') should throw');
+    });
+    var invalidValues = ['test \r data', 'test \n data'];
+    invalidValues.forEach(function(value) {
+        assert_throws({name:'TypeError'},
+                      function() {
+                          new Response(new Blob(),
+                                       {headers: {'X-ServiceWorker-Test': value}});
+                      },
+                      'new Response with headers with an invalid value should throw');
+        assert_throws({name:'TypeError'},
+                      function() {
+                          new Response(new Blob(),
+                                       {headers: [['X-ServiceWorker-Test', value]]});
+                      },
+                      'new Response with headers with an invalid value should throw');
+    });
+}, 'Response throw error test in ServiceWorkerGlobalScope');
diff --git a/testing/web-platform/tests/cache/resources/simple-intercept-worker.js b/testing/web-platform/tests/cache/resources/simple-intercept-worker.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/simple-intercept-worker.js
@@ -0,0 +1,4 @@
+self.onfetch = function(event) {
+    if (event.request.url.indexOf('simple') != -1)
+        event.respondWith(new Response(new Blob(['intercepted by service worker'])));
+}
diff --git a/testing/web-platform/tests/cache/resources/simple.html b/testing/web-platform/tests/cache/resources/simple.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/simple.html
@@ -0,0 +1,3 @@
+<!DOCTYPE html>
+<title>Simple</title>
+Here's a simple html file.
diff --git a/testing/web-platform/tests/cache/resources/simple.json b/testing/web-platform/tests/cache/resources/simple.json
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/simple.json
@@ -0,0 +1,1 @@
+{ "a" : 1, "b" : 2 }
diff --git a/testing/web-platform/tests/cache/resources/simple.txt b/testing/web-platform/tests/cache/resources/simple.txt
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/simple.txt
@@ -0,0 +1,1 @@
+a simple text file
diff --git a/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock-iframe.html b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock-iframe.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock-iframe.html
@@ -0,0 +1,12 @@
+<!DOCTYPE html>
+<title>Service Worker: SyncXHR doesn't deadlock iframe</title>
+<script>
+function performSyncXHR() {
+  var url = 'sync-xhr-doesnt-deadlock.data?bustcache=' + Date.now();
+  var syncXhr = new XMLHttpRequest();
+  syncXhr.open("GET", url, false);
+  syncXhr.send();
+  if (syncXhr.responseText != 'hello')
+    throw 'FAIL';
+}
+</script>
diff --git a/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.data b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.data
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.data
@@ -0,0 +1,1 @@
+hello
\ No newline at end of file
diff --git a/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.js b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/sync-xhr-doesnt-deadlock.js
@@ -0,0 +1,5 @@
+self.onfetch = function(event) {
+  if (event.request.url.indexOf('sync-xhr-doesnt-deadlock.data') == -1)
+    return;
+  event.respondWith(fetch('404resource?bustcache=' + Date.now()));
+}
diff --git a/testing/web-platform/tests/cache/resources/test-helpers.js b/testing/web-platform/tests/cache/resources/test-helpers.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/test-helpers.js
@@ -0,0 +1,266 @@
+// Adapter for testharness.js-style tests with Service Workers
+
+function service_worker_unregister_and_register(test, url, scope) {
+  if (!scope || scope.length == 0)
+    return Promise.reject(new Error('tests must define a scope'));
+
+  var options = { scope: scope };
+  return service_worker_unregister(test, scope)
+      .then(function() {
+          return navigator.serviceWorker.register(url, options);
+        })
+      .catch(unreached_rejection(test,
+                                 'unregister and register should not fail'));
+}
+
+function service_worker_unregister(test, documentUrl) {
+  return navigator.serviceWorker.getRegistration(documentUrl)
+      .then(function(registration) {
+          if (registration)
+            return registration.unregister();
+        })
+      .catch(unreached_rejection(test, 'unregister should not fail'));
+}
+
+function service_worker_unregister_and_done(test, scope) {
+  return service_worker_unregister(test, scope)
+      .then(test.done.bind(test));
+}
+
+// Rejection-specific helper that provides more details
+function unreached_rejection(test, prefix) {
+    return test.step_func(function(error) {
+        var reason = error.message || error.name || error;
+        var error_prefix = prefix || 'unexpected rejection';
+        assert_unreached(error_prefix + ': ' + reason);
+    });
+}
+
+// FIXME: Clean up the iframe when the test completes.
+function with_iframe(url, f) {
+    return new Promise(function(resolve, reject) {
+        var frame = document.createElement('iframe');
+        frame.src = url;
+        frame.onload = function() {
+            if (f) {
+              f(frame);
+            }
+            resolve(frame);
+        };
+        document.body.appendChild(frame);
+    });
+}
+
+function unload_iframe(iframe) {
+  var saw_unload = new Promise(function(resolve) {
+      iframe.contentWindow.addEventListener('unload', function() {
+          resolve();
+        });
+    });
+  iframe.src = '';
+  iframe.remove();
+  return saw_unload;
+}
+
+function normalizeURL(url) {
+  return new URL(url, document.location).toString().replace(/#.*$/, '');
+}
+
+function get_newest_worker(registration) {
+  if (!registration) {
+    return Promise.reject(new Error(
+        'get_newest_worker must be passed a ServiceWorkerRegistration'));
+  }
+  if (registration.installing)
+    return Promise.resolve(registration.installing);
+  if (registration.waiting)
+    return Promise.resolve(registration.waiting);
+  if (registration.active)
+    return Promise.resolve(registration.active);
+  return Promise.reject(new Error(
+      'registration must have at least one version'));
+}
+
+function wait_for_update(test, registration) {
+  if (!registration || registration.unregister == undefined) {
+    return Promise.reject(new Error(
+        'wait_for_update must be passed a ServiceWorkerRegistration'));
+  }
+
+  return new Promise(test.step_func(function(resolve) {
+      registration.addEventListener('updatefound', test.step_func(function() {
+          resolve(registration.installing);
+      }));
+    }));
+}
+
+function wait_for_state(test, worker, state) {
+  if (!worker || worker.state == undefined) {
+    return Promise.reject(new Error(
+        'wait_for_state must be passed a ServiceWorker'));
+  }
+  if (worker.state === state)
+    return Promise.resolve(state);
+
+  if (state === 'installing') {
+    switch (worker.state) {
+    case 'installed':
+    case 'activating':
+    case 'activated':
+    case 'redundant':
+      return Promise.reject(new Error(
+          'worker is ' + worker.state + ' but waiting for ' + state));
+    }
+  }
+
+  if (state === 'installed') {
+    switch (worker.state) {
+    case 'activating':
+    case 'activated':
+    case 'redundant':
+      return Promise.reject(new Error(
+          'worker is ' + worker.state + ' but waiting for ' + state));
+    }
+  }
+
+  if (state === 'activating') {
+    switch (worker.state) {
+    case 'activated':
+    case 'redundant':
+      return Promise.reject(new Error(
+          'worker is ' + worker.state + ' but waiting for ' + state));
+    }
+  }
+
+  if (state === 'activated') {
+    switch (worker.state) {
+    case 'redundant':
+      return Promise.reject(new Error(
+          'worker is ' + worker.state + ' but waiting for ' + state));
+    }
+  }
+
+  return new Promise(test.step_func(function(resolve) {
+      worker.addEventListener('statechange', test.step_func(function() {
+          if (worker.state === state)
+            resolve(state);
+        }));
+    }));
+}
+
+function wait_for_activated(test, registration) {
+  var expected_state = 'activated';
+  if (registration.active)
+    return wait_for_state(test, registration.active, expected_state);
+  if (registration.waiting)
+    return wait_for_state(test, registration.waiting, expected_state);
+  if (registration.installing)
+    return wait_for_state(test, registration.installing, expected_state);
+  return Promise.reject(
+      new Error('registration must have at least one version'));
+}
+
+(function() {
+  function fetch_tests_from_worker(worker) {
+    return new Promise(function(resolve, reject) {
+        var messageChannel = new MessageChannel();
+        messageChannel.port1.addEventListener('message', function(message) {
+            if (message.data.type == 'complete') {
+              synthesize_tests(message.data.tests, message.data.status);
+              resolve();
+            }
+          });
+        worker.postMessage({type: 'fetch_results', port: messageChannel.port2},
+                           [messageChannel.port2]);
+        messageChannel.port1.start();
+      });
+  };
+
+  function synthesize_tests(tests, status) {
+    for (var i = 0; i < tests.length; ++i) {
+      var t = async_test(tests[i].name);
+      switch (tests[i].status) {
+        case tests[i].PASS:
+          t.step(function() { assert_true(true); });
+          t.done();
+          break;
+        case tests[i].TIMEOUT:
+          t.force_timeout();
+          break;
+        case tests[i].FAIL:
+          t.step(function() { throw {message: tests[i].message}; });
+          break;
+        case tests[i].NOTRUN:
+          // Leave NOTRUN alone. It'll get marked as a NOTRUN when the test
+          // terminates.
+          break;
+      }
+    }
+  };
+
+  function service_worker_test(url, description) {
+    var scope = new URL('./', new URL(url, window.location)) +
+      'resources/service-worker-scope' +
+      window.location.pathname;
+    var test = async_test(description);
+    var registration;
+    service_worker_unregister_and_register(test, url, scope)
+      .then(function(r) {
+          registration = r;
+          return wait_for_update(test, registration);
+        })
+      .then(function(worker) { return fetch_tests_from_worker(worker); })
+      .then(function() { return registration.unregister(); })
+      .then(function() { test.done(); })
+      .catch(test.step_func(function(e) { throw e; }));
+  };
+
+  self.service_worker_test = service_worker_test;
+})();
+
+function get_host_info() {
+    var ORIGINAL_HOST = '127.0.0.1';
+    var REMOTE_HOST = 'localhost';
+    var UNAUTHENTICATED_HOST = 'example.test';
+    var HTTP_PORT = 8000;
+    var HTTPS_PORT = 8443;
+    try {
+        // In W3C test, we can get the hostname and port number in config.json
+        // using wptserve's built-in pipe.
+        // http://wptserve.readthedocs.org/en/latest/pipes.html#built-in-pipes
+        HTTP_PORT = eval('{{ports[http][0]}}');
+        HTTPS_PORT = eval('{{ports[https][0]}}');
+        ORIGINAL_HOST = eval('\'{{host}}\'');
+        REMOTE_HOST = 'www1.' + ORIGINAL_HOST;
+    } catch(e) {
+    }
+    return {
+        HTTP_ORIGIN: 'http://' + ORIGINAL_HOST + ':' + HTTP_PORT,
+        HTTPS_ORIGIN: 'https://' + ORIGINAL_HOST + ':' + HTTPS_PORT,
+        HTTP_REMOTE_ORIGIN: 'http://' + REMOTE_HOST + ':' + HTTP_PORT,
+        HTTPS_REMOTE_ORIGIN: 'https://' + REMOTE_HOST + ':' + HTTPS_PORT,
+        UNAUTHENTICATED_ORIGIN: 'http://' + UNAUTHENTICATED_HOST + ':' + HTTP_PORT
+    };
+}
+
+function base_path() {
+    return location.pathname.replace(/\/[^\/]*$/, '/');
+}
+
+function test_login(test, origin, username, password) {
+  return new Promise(function(resolve, reject) {
+      with_iframe(
+        origin + base_path() +
+        'resources/fetch-access-control-login.html')
+        .then(test.step_func(function(frame) {
+            var channel = new MessageChannel();
+            channel.port1.onmessage = test.step_func(function() {
+                unload_iframe(frame).catch(function() {});
+                resolve();
+              });
+            frame.contentWindow.postMessage(
+              {username: username, password: password},
+              [channel.port2], origin);
+          }));
+    });
+}
diff --git a/testing/web-platform/tests/cache/resources/unregister-controller-page.html b/testing/web-platform/tests/cache/resources/unregister-controller-page.html
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/unregister-controller-page.html
@@ -0,0 +1,16 @@
+<!DOCTYPE html>
+<script>
+function fetch_url(url) {
+    return new Promise(function(resolve, reject) {
+        var request = new XMLHttpRequest();
+        request.addEventListener('load', function(event) {
+            if (request.status == 200)
+                resolve(request.response);
+            else
+                reject(Error(request.statusText));
+        });
+        request.open('GET', url);
+        request.send();
+    });
+}
+</script>
diff --git a/testing/web-platform/tests/cache/resources/worker-testharness.js b/testing/web-platform/tests/cache/resources/worker-testharness.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/cache/resources/worker-testharness.js
@@ -0,0 +1,112 @@
+/*
+ * worker-test-harness should be considered a temporary polyfill around
+ * testharness.js for supporting Service Worker based tests. It should not be
+ * necessary once the test harness is able to drive worker based tests natively.
+ * See https://github.com/w3c/testharness.js/pull/82 for status of effort to
+ * update upstream testharness.js. Once the upstreaming is complete, tests that
+ * reference worker-test-harness should be updated to directly import
+ * testharness.js.
+ */
+
+// The following are necessary to appease attempts by testharness to access the
+// DOM.
+self.document = {getElementsByTagName: function() { return []; }};
+self.window = self;
+self.parent = self;
+
+// An onload event handler is used to indicate to the testharness that the
+// document has finished loading. At this point the test suite would be
+// considered complete if there are no more pending tests and the test isn't
+// marked as requring an explicit done() call.
+//
+// Since ServiceWorkers don't have an onload event, we monkey-patch
+// addEventListener to rewire the event to be fired at oninstall which is
+// functionally equivalent to onload.
+(function() {
+  var previous_addEventListener = self.addEventListener;
+  self.addEventListener = function() {
+    if (arguments.length > 0 && arguments[0] == 'load') {
+      arguments[0] = 'install';
+    }
+    previous_addEventListener.apply(this, arguments);
+  };
+})();
+
+importScripts('/resources/testharness.js');
+
+(function() {
+  // This prevents the worker from attempting to display test results using the
+  // DOM.
+  setup({output: false});
+
+  // Once the test are considered complete, this logic packages up all the
+  // results into a promise resolution so that it can be passed back to the
+  // client document when it connects.
+  var completion_promise = new Promise(function(resolve, reject) {
+      add_completion_callback(function(tests, harness_status) {
+          var results = {
+            tests: tests.map(function(test) {
+                return test.structured_clone();
+              }),
+            status: harness_status.structured_clone()
+          };
+          resolve(results);
+        });
+    });
+
+  // The 'fetch_results' message is sent by the client document to signal that
+  // it is now ready to receive test results. It also includes a MessagePort
+  // which the worker should use to communicate.
+  self.addEventListener('message', function(ev) {
+      var message = ev.data;
+      if (message.type == 'fetch_results') {
+        var port = ev.ports[0];
+        completion_promise.then(function(results) {
+            var message = {
+              type: 'complete',
+              tests: results.tests,
+              status: results.status
+            };
+            port.postMessage(message);
+          });
+      }
+    });
+})();
+
+(function() {
+  var next_cache_index = 1;
+
+  // Returns a promise that resolves to a newly created Cache object. The
+  // returned Cache will be destroyed when |test| completes.
+  function create_temporary_cache(test) {
+    var uniquifier = String(++next_cache_index);
+    var cache_name = self.location.pathname + '/' + uniquifier;
+
+    test.add_cleanup(function() {
+        self.caches.delete(cache_name);
+      });
+
+    return self.caches.delete(cache_name)
+      .then(function() {
+          return self.caches.open(cache_name);
+        });
+  }
+
+  self.create_temporary_cache = create_temporary_cache;
+})();
+
+// Runs |test_function| with a temporary unique Cache passed in as the only
+// argument. The function is run as a part of Promise chain owned by
+// promise_test(). As such, it is expected to behave in a manner identical (with
+// the exception of the argument) to a function passed into promise_test().
+//
+// E.g.:
+//    cache_test(function(cache) {
+//      // Do something with |cache|, which is a Cache object.
+//    }, "Some Cache test");
+function cache_test(test_function, description) {
+  promise_test(function(test) {
+    return create_temporary_cache(test)
+        .then(test_function);
+  }, description);
+}
diff --git a/testing/web-platform/tests/resources/testharness-helpers.js b/testing/web-platform/tests/resources/testharness-helpers.js
new file mode 100644
--- /dev/null
+++ b/testing/web-platform/tests/resources/testharness-helpers.js
@@ -0,0 +1,154 @@
+/*
+ * testharness-helpers contains various useful extensions to testharness.js to
+ * allow them to be used across multiple tests before they have been
+ * upstreamed. This file is intended to be usable from both document and worker
+ * environments, so code should for example not rely on the DOM.
+ */
+
+// A testharness test that simplifies testing with promises.
+//
+// * The |func| argument should be a reference to a function that optionally
+//   takes a test object as an argument and returns a Promise (or really any
+//   thenable object).
+//
+// * Resolution of the promise completes the test. A rejection causes the test
+//   to fail. The test harness waits for the promise to resolve.
+//
+// * Assertions can be made at any point in the promise handlers. Assertions
+//   only need to be wrapped in test.step_func()s if the promise chain contains
+//   rejection handlers.
+//
+// E.g.:
+//   promise_test(function(t) {
+//       return method_that_returns_a_promise()
+//         .then(function(result) {
+//             assert_equals(result, expected_result, "Should be expected.");
+//           });
+//     }, 'Promise based test');
+function promise_test(func, name, properties) {
+  properties = properties || {};
+  var test = async_test(name, properties);
+  Promise.resolve(test.step(func, test, test))
+    .then(function() { test.done(); })
+    .catch(test.step_func(function(value) {
+        throw value;
+      }));
+}
+
+// Returns a promise that fulfills after the provided |promise| is fulfilled.
+// The |test| succeeds only if |promise| rejects with an exception matching
+// |code|. Accepted values for |code| follow those accepted for assert_throws().
+// The optional |description| describes the test being performed.
+//
+// E.g.:
+//   assert_promise_rejects(
+//       new Promise(...), // something that should throw an exception.
+//       'NotFoundError',
+//       'Should throw NotFoundError.');
+//
+//   assert_promise_rejects(
+//       new Promise(...),
+//       new TypeError(),
+//       'Should throw TypeError');
+function assert_promise_rejects(promise, code, description) {
+  return promise.then(
+    function() {
+      throw 'assert_promise_rejects: ' + description + ' Promise did not reject.';
+    },
+    function(e) {
+      if (code !== undefined) {
+        assert_throws(code, function() { throw e; }, description);
+      }
+    });
+}
+
+// Asserts that two objects |actual| and |expected| are weakly equal under the
+// following definition:
+//
+// |a| and |b| are weakly equal if any of the following are true:
+//   1. If |a| is not an 'object', and |a| === |b|.
+//   2. If |a| is an 'object', and all of the following are true:
+//     2.1 |a.p| is weakly equal to |b.p| for all own properties |p| of |a|.
+//     2.2 Every own property of |b| is an own property of |a|.
+//
+// This is a replacement for the the version of assert_object_equals() in
+// testharness.js. The latter doesn't handle own properties correctly. I.e. if
+// |a.p| is not an own property, it still requires that |b.p| be an own
+// property.
+//
+// Note that |actual| must not contain cyclic references.
+self.assert_object_equals = function(actual, expected, description) {
+  var object_stack = [];
+
+  function _is_equal(actual, expected, prefix) {
+    if (typeof actual !== 'object') {
+      assert_equals(actual, expected, prefix);
+      return;
+    }
+    assert_true(typeof expected === 'object', prefix);
+    assert_equals(object_stack.indexOf(actual), -1,
+                  prefix + ' must not contain cyclic references.');
+
+    object_stack.push(actual);
+
+    Object.getOwnPropertyNames(expected).forEach(function(property) {
+        assert_own_property(actual, property, prefix);
+        _is_equal(actual[property], expected[property],
+                  prefix + '.' + property);
+      });
+    Object.getOwnPropertyNames(actual).forEach(function(property) {
+        assert_own_property(expected, property, prefix);
+      });
+
+    object_stack.pop();
+  }
+
+  function _brand(object) {
+    return Object.prototype.toString.call(object).match(/^\[object (.*)\]$/)[1];
+  }
+
+  _is_equal(actual, expected,
+            (description ? description + ': ' : '') + _brand(actual));
+};
+
+// Equivalent to assert_in_array, but uses a weaker equivalence relation
+// (assert_object_equals) than '==='.
+function assert_object_in_array(actual, expected_array, description) {
+  assert_true(expected_array.some(function(element) {
+      try {
+        assert_object_equals(actual, element);
+        return true;
+      } catch (e) {
+        return false;
+      }
+    }), description);
+}
+
+// Assert that the two arrays |actual| and |expected| contain the same set of
+// elements as determined by assert_object_equals. The order is not significant.
+//
+// |expected| is assumed to not contain any duplicates as determined by
+// assert_object_equals().
+function assert_array_equivalent(actual, expected, description) {
+  assert_true(Array.isArray(actual), description);
+  assert_equals(actual.length, expected.length, description);
+  expected.forEach(function(expected_element) {
+      // assert_in_array treats the first argument as being 'actual', and the
+      // second as being 'expected array'. We are switching them around because
+      // we want to be resilient against the |actual| array containing
+      // duplicates.
+      assert_object_in_array(expected_element, actual, description);
+    });
+}
+
+// Asserts that two arrays |actual| and |expected| contain the same set of
+// elements as determined by assert_object_equals(). The corresponding elements
+// must occupy corresponding indices in their respective arrays.
+function assert_array_objects_equals(actual, expected, description) {
+  assert_true(Array.isArray(actual), description);
+  assert_equals(actual.length, expected.length, description);
+  actual.forEach(function(value, index) {
+      assert_object_equals(value, expected[index],
+                           description + ' : object[' + index + ']');
+    });
+}
diff --git a/testing/web-platform/tests/resources/testharness.js b/testing/web-platform/tests/resources/testharness.js
--- a/testing/web-platform/tests/resources/testharness.js
+++ b/testing/web-platform/tests/resources/testharness.js
@@ -792,16 +792,17 @@ policies and contribution forms [3].
 
         if (arguments.length === 1) {
             this_obj = this;
         }
 
         try {
             return func.apply(this_obj, Array.prototype.slice.call(arguments, 2));
         } catch (e) {
+            dump("### ### harness got exception: " + e + "\n");
             if (this.phase >= this.phases.HAS_RESULT) {
                 return;
             }
             var message = (typeof e === "object" && e !== null) ? e.message : e;
             if (typeof e.stack != "undefined" && typeof e.message == "string") {
                 //Try to make it more informative for some exceptions, at least
                 //in Gecko and WebKit.  This results in a stack dump instead of
                 //just errors like "Cannot read property 'parentNode' of null"
@@ -1092,18 +1093,19 @@ policies and contribution forms [3].
         if (this.phase < this.phases.HAVE_TESTS) {
             this.start();
         }
         this.num_pending++;
         this.tests.push(test);
     };
 
     Tests.prototype.all_done = function() {
-        return (this.tests.length > 0 && this.all_loaded && this.num_pending === 0 &&
+        var rv = (this.tests.length > 0 && this.all_loaded && this.num_pending === 0 &&
                 !this.wait_for_finish && !this.processing_callbacks);
+        return rv;
     };
 
     Tests.prototype.start = function() {
         this.phase = this.phases.HAVE_TESTS;
         this.notify_start();
     };
 
     Tests.prototype.notify_start = function() {
