# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  2383ff1b5c2354d8b0414ddf1b7e1ff1db7c9e47
Bug 1300659 P5 Suspend a window if its main thread TaskQueue falls to far behind. r=smaug

diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -3582,16 +3582,52 @@ nsGlobalWindow::DefineArgumentsProperty(
 
   nsIScriptContext *ctx = GetOuterWindowInternal()->mContext;
   NS_ENSURE_TRUE(aArguments && ctx, NS_ERROR_NOT_INITIALIZED);
 
   JS::Rooted<JSObject*> obj(RootingCx(), GetWrapperPreserveColor());
   return ctx->SetProperty(obj, "arguments", aArguments);
 }
 
+void
+nsGlobalWindow::MaybeApplyBackPressure()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // If we are already suspended, then we don't need to apply back
+  // pressure for TaskQueue reasons.  This also avoids repeatedly
+  // calling SuspendTimeout() if this routine is executed many times
+  // before dropping below the backpressure threshold.
+  if (IsSuspended()) {
+    return;
+  }
+
+  RefPtr<SelfClosingTaskQueueTarget> taskQueue = TabGroup()->GetTaskQueue();
+  if (!taskQueue) {
+    return;
+  }
+
+  static const uint32_t kTaskQueueBackPressure = 5000;
+  if (taskQueue->ImpreciseLengthForHeuristics() < kTaskQueueBackPressure) {
+    return;
+  }
+
+  // First attempt to queue a runnable to resume running timeouts.  We do
+  // this first in order to verify we can dispatch successfully.
+  nsCOMPtr<nsIRunnable> r = NewRunnableMethod(this, &nsGlobalWindow::Resume);
+  nsresult rv = taskQueue->Dispatch(r.forget(), NS_DISPATCH_NORMAL);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  // Since the resume is dispatched we can go ahead and suspend the window
+  // now.  Once the task queue drains the resume will automatically get
+  // executed balancing this suspend.
+  // TODO: Consider suppressing event handling as well.
+  Suspend();
+}
+
 //*****************************************************************************
 // nsGlobalWindow::nsIScriptObjectPrincipal
 //*****************************************************************************
 
 nsIPrincipal*
 nsGlobalWindow::GetPrincipal()
 {
   if (mDoc) {
@@ -12989,16 +13025,18 @@ nsGlobalWindow::RunTimeout(nsTimeout *aT
   }
 
   // Take the dummy timeout off the head of the list
   dummy_timeout->remove();
   timeoutExtraRef = nullptr;
   MOZ_ASSERT(dummy_timeout->HasRefCntOne(), "dummy_timeout may leak");
 
   mTimeoutInsertionPoint = last_insertion_point;
+
+  MaybeApplyBackPressure();
 }
 
 void
 nsGlobalWindow::ClearTimeoutOrInterval(int32_t aTimerID)
 {
   MOZ_RELEASE_ASSERT(IsInnerWindow());
 
   uint32_t public_id = (uint32_t)aTimerID;
diff --git a/dom/base/nsGlobalWindow.h b/dom/base/nsGlobalWindow.h
--- a/dom/base/nsGlobalWindow.h
+++ b/dom/base/nsGlobalWindow.h
@@ -1743,16 +1743,22 @@ private:
   void FireOnNewGlobalObject();
 
   void DisconnectEventTargetObjects();
 
   // Called only on outer windows to compute the value that will be returned by
   // IsSecureContext() for the inner window that corresponds to aDocument.
   bool ComputeIsSecureContext(nsIDocument* aDocument);
 
+  // Apply back pressure to the window if the main thread TaskQueue exists
+  // and has too many runnables waiting to run.  For example, suspend timers
+  // until we have a chance to catch up, etc.
+  void
+  MaybeApplyBackPressure();
+
   mozilla::dom::TabGroup* TabGroupInner();
   mozilla::dom::TabGroup* TabGroupOuter();
 
 public:
   mozilla::dom::TabGroup* TabGroup();
   mozilla::dom::DocGroup* GetDocGroup();
 
 protected:
