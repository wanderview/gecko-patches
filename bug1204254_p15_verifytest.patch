# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1f66bfeecb7dd7623c4f56b686ea14b7b02f8265
Bug 1204254 P15 Try to make test_devtools_serviceworker_interception.html handle --verify runs again. r=asuth

diff --git a/dom/workers/test/serviceworkers/fetch.js b/dom/workers/test/serviceworkers/fetch.js
--- a/dom/workers/test/serviceworkers/fetch.js
+++ b/dom/workers/test/serviceworkers/fetch.js
@@ -1,11 +1,13 @@
 addEventListener('fetch', function(event) {
   if (event.request.url.indexOf("fail.html") !== -1) {
     event.respondWith(fetch("hello.html", {"integrity": "abc"}));
   } else if (event.request.url.indexOf("fake.html") !== -1) {
     event.respondWith(fetch("hello.html"));
   }
 });
 
-addEventListener("activate", function(event) {
-  event.waitUntil(clients.claim());
+addEventListener('message', function(event) {
+  if (event.data === 'claim') {
+    event.waitUntil(clients.claim());
+  }
 });
diff --git a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
--- a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
+++ b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
@@ -41,33 +41,68 @@ function createTestWindow(aURL) {
       }
 
       win.removeEventListener("DOMContentLoaded", callback);
       aResolve(win.content);
     });
   });
 }
 
+// Using utils.js doesn't seem to work in this chrome test, so redefine
+// waitForState() here.
+function waitForState(worker, state, context) {
+  return new Promise(resolve => {
+    if (worker.state === state) {
+      resolve(context);
+      return;
+    }
+    worker.addEventListener('statechange', function onStateChange() {
+      if (worker.state === state) {
+        worker.removeEventListener('statechange', onStateChange);
+        resolve(context);
+      }
+    });
+  });
+}
+
+function waitForControlled(win) {
+  return new Promise(resolve => {
+    if (win.navigator.serviceWorker.controller) {
+      return resolve();
+    }
+
+    win.navigator.serviceWorker.addEventListener('controllerchange', resolve,
+                                                 { once: true });
+  });
+}
+
 function executeTest(aWindow) {
   var registration;
 
   return Promise.resolve()
     // Should not be intercepted.
     .then(_ => fetchAndCheckTimedChannel(aWindow, false, true, "hello.html"))
 
     // Regist a service worker.
     .then(_ => register(aWindow, workerURL, workerScope))
     .then(r => registration = r)
+    .then(_ => waitForState(registration.installing || registration.active, 'activated'))
 
-    // Should be intercpeted and synthesized.
+    // When run consecutively we sometime end up resurrecting a previous
+    // service worker.  In that case our active event does not run and claim
+    // the window.  So do the claim for a message event instead.
+    .then(_ => registration.active.postMessage('claim'))
+    .then(_ => waitForControlled(aWindow))
+
+    // Should be intercepted and synthesized.
     .then(_ => fetchAndCheckTimedChannel(aWindow, true, false, "fake.html"))
 
     // Should be intercepted but still fetch from network.
     .then(_ => fetchAndCheckTimedChannel(aWindow, true, true,
-                                         "hello.html?ForBypassingHttpCache"))
+                                         "hello.html?ForBypassingHttpCache=" + Date.now()))
 
     // Tear down
     .then(_ => registration.unregister())
     .then(_ => aWindow.close());
 }
 
 function register(aWindow, aURL, aScope) {
   return aWindow.navigator.serviceWorker.register(aURL, {scope: aScope})
diff --git a/dom/workers/test/serviceworkers/test_fetch_integrity.html b/dom/workers/test/serviceworkers/test_fetch_integrity.html
--- a/dom/workers/test/serviceworkers/test_fetch_integrity.html
+++ b/dom/workers/test/serviceworkers/test_fetch_integrity.html
@@ -51,16 +51,18 @@ add_task(async function test_integrity_s
 
   // The SW will claim us once it activates; this is async, start listening now.
   let waitForControlled = new Promise((resolve) => {
     navigator.serviceWorker.oncontrollerchange = resolve;
   });
 
   let registration = await navigator.serviceWorker.register("fetch.js",
                                                             { scope: "./" });
+  let worker = registration.installing || registration.active;
+  worker.postMessage('claim');
   await waitForControlled;
 
   info("Test for mNavigationInterceptions.")
   // The client_win will reload to another URL after opening filename2.
   let client_win = window.open(filename2);
 
   // XXX windowID should be innerWindowID
   let mainWindowID = SpecialPowers.getDOMWindowUtils(window).outerWindowID;
