# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0729c18a23586f98874b7a1950d036fbf796f1af
Bug 1204254 P15 Try to make test_devtools_serviceworker_interception.html handle --verify runs again. r=asuth

diff --git a/dom/workers/test/serviceworkers/chrome.ini b/dom/workers/test/serviceworkers/chrome.ini
--- a/dom/workers/test/serviceworkers/chrome.ini
+++ b/dom/workers/test/serviceworkers/chrome.ini
@@ -4,16 +4,17 @@ support-files =
   chrome_helpers.js
   empty.js
   fetch.js
   hello.html
   serviceworker.html
   serviceworkerinfo_iframe.html
   serviceworkermanager_iframe.html
   serviceworkerregistrationinfo_iframe.html
+  utils.js
   worker.js
   worker2.js
 
 [test_devtools_serviceworker_interception.html]
 [test_devtools_track_serviceworker_time.html]
 [test_privateBrowsing.html]
 [test_serviceworkerinfo.xul]
 [test_serviceworkermanager.xul]
diff --git a/dom/workers/test/serviceworkers/fetch.js b/dom/workers/test/serviceworkers/fetch.js
--- a/dom/workers/test/serviceworkers/fetch.js
+++ b/dom/workers/test/serviceworkers/fetch.js
@@ -1,11 +1,13 @@
 addEventListener('fetch', function(event) {
   if (event.request.url.indexOf("fail.html") !== -1) {
     event.respondWith(fetch("hello.html", {"integrity": "abc"}));
   } else if (event.request.url.indexOf("fake.html") !== -1) {
     event.respondWith(fetch("hello.html"));
   }
 });
 
-addEventListener("activate", function(event) {
-  event.waitUntil(clients.claim());
+addEventListener('message', function(event) {
+  if (event.data === 'claim') {
+    event.waitUntil(clients.claim());
+  }
 });
diff --git a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
--- a/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
+++ b/dom/workers/test/serviceworkers/test_devtools_serviceworker_interception.html
@@ -11,16 +11,17 @@
   <link rel="stylesheet"
         type="text/css"
         href="chrome://mochikit/content/tests/SimpleTest/test.css"?>
 </head>
 <body>
 <p id="display"></p>
 <div id="content" style="display: none"></div>
 <pre id="test"></pre>
+<script src="utils.js"></script>
 <script class="testbody" type="text/javascript">
 
 // Constants
 const Ci = Components.interfaces;
 const workerScope = "http://mochi.test:8888/chrome/dom/workers/test/serviceworkers/";
 const workerURL = workerScope + "fetch.js";
 const contentPage = workerScope + "hello.html";
 
@@ -52,22 +53,35 @@ function executeTest(aWindow) {
   return Promise.resolve()
     // Should not be intercepted.
     .then(_ => fetchAndCheckTimedChannel(aWindow, false, true, "hello.html"))
 
     // Regist a service worker.
     .then(_ => register(aWindow, workerURL, workerScope))
     .then(r => registration = r)
 
-    // Should be intercpeted and synthesized.
+    // If this test is re-run then we may end up resurrecting the previous
+    // registration and worker.  In those cases we will have an active instead
+    // of installing.  This happens because because the test window itself
+    // is controlled.  If we were using iframes we could ensure the registration
+    // was removed before ending the test.
+    .then(_ => waitForState(registration.installing || registration.active, 'activated'))
+
+    // When run consecutively we sometime end up resurrecting a previous
+    // service worker.  In that case our active event does not run and claim
+    // the window.  So do the claim for a message event instead.
+    .then(_ => registration.active.postMessage('claim'))
+    .then(_ => waitForControlled(aWindow))
+
+    // Should be intercepted and synthesized.
     .then(_ => fetchAndCheckTimedChannel(aWindow, true, false, "fake.html"))
 
     // Should be intercepted but still fetch from network.
     .then(_ => fetchAndCheckTimedChannel(aWindow, true, true,
-                                         "hello.html?ForBypassingHttpCache"))
+                                         "hello.html?ForBypassingHttpCache=" + Date.now()))
 
     // Tear down
     .then(_ => registration.unregister())
     .then(_ => aWindow.close());
 }
 
 function register(aWindow, aURL, aScope) {
   return aWindow.navigator.serviceWorker.register(aURL, {scope: aScope})
diff --git a/dom/workers/test/serviceworkers/test_fetch_integrity.html b/dom/workers/test/serviceworkers/test_fetch_integrity.html
--- a/dom/workers/test/serviceworkers/test_fetch_integrity.html
+++ b/dom/workers/test/serviceworkers/test_fetch_integrity.html
@@ -51,16 +51,18 @@ add_task(async function test_integrity_s
 
   // The SW will claim us once it activates; this is async, start listening now.
   let waitForControlled = new Promise((resolve) => {
     navigator.serviceWorker.oncontrollerchange = resolve;
   });
 
   let registration = await navigator.serviceWorker.register("fetch.js",
                                                             { scope: "./" });
+  let worker = registration.installing || registration.active;
+  worker.postMessage('claim');
   await waitForControlled;
 
   info("Test for mNavigationInterceptions.")
   // The client_win will reload to another URL after opening filename2.
   let client_win = window.open(filename2);
 
   // XXX windowID should be innerWindowID
   let mainWindowID = SpecialPowers.getDOMWindowUtils(window).outerWindowID;
diff --git a/dom/workers/test/serviceworkers/utils.js b/dom/workers/test/serviceworkers/utils.js
--- a/dom/workers/test/serviceworkers/utils.js
+++ b/dom/workers/test/serviceworkers/utils.js
@@ -7,8 +7,19 @@ function waitForState(worker, state, con
     worker.addEventListener('statechange', function onStateChange() {
       if (worker.state === state) {
         worker.removeEventListener('statechange', onStateChange);
         resolve(context);
       }
     });
   });
 }
+
+function waitForControlled(win) {
+  return new Promise(resolve => {
+    if (win.navigator.serviceWorker.controller) {
+      return resolve();
+    }
+
+    win.navigator.serviceWorker.addEventListener('controllerchange', resolve,
+                                                 { once: true });
+  });
+}
