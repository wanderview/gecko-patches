# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0a7e377493e087ed144c850839c36e69e12993b6
Bug 1363829 P17 Make browser_net_simple-request-data.js wait for all async tests to complete before finishing. r=honza

diff --git a/devtools/client/netmonitor/test/browser_net_simple-request-data.js b/devtools/client/netmonitor/test/browser_net_simple-request-data.js
--- a/devtools/client/netmonitor/test/browser_net_simple-request-data.js
+++ b/devtools/client/netmonitor/test/browser_net_simple-request-data.js
@@ -8,46 +8,52 @@
  */
 
 // The following intermittent rejections should not be left uncaught. This test
 // has been whitelisted until the issue is fixed.
 //
 // NOTE: Whitelisting a class of rejections should be limited. Normally you
 //       should use "expectUncaughtRejection" to flag individual failures.
 Cu.import("resource://testing-common/PromiseTestUtils.jsm", this);
-PromiseTestUtils.whitelistRejectionsGlobally(/cookies is undefined/);
 PromiseTestUtils.whitelistRejectionsGlobally(/requestItem is undefined/);
 
 function test() {
   // Disable tcp fast open, because it is setting a response header indicator
   // (bug 1352274). TCP Fast Open is not present on all platforms therefore the
   // number of response headers will vary depending on the platform.
   Services.prefs.setBoolPref("network.tcp.tcp_fastopen_enable", false);
 
   let { L10N } = require("devtools/client/netmonitor/src/utils/l10n");
 
-  initNetMonitor(SIMPLE_SJS).then(({ tab, monitor }) => {
+  initNetMonitor(SIMPLE_SJS).then(async ({ tab, monitor }) => {
     info("Starting test... ");
 
     let { document, store, windowRequire } = monitor.panelWin;
     let Actions = windowRequire("devtools/client/netmonitor/src/actions/index");
     let { EVENTS } = windowRequire("devtools/client/netmonitor/src/constants");
     let {
       getDisplayedRequests,
       getSelectedRequest,
       getSortedRequests,
     } = windowRequire("devtools/client/netmonitor/src/selectors/index");
 
     store.dispatch(Actions.batchEnable(false));
 
-    waitForNetworkEvents(monitor, 1)
-      .then(() => teardown(monitor))
-      .then(finish);
+    let promiseList = [];
+    promiseList.push(waitForNetworkEvents(monitor, 1));
 
-    monitor.panelWin.once(EVENTS.NETWORK_EVENT, () => {
+    function expectEvent(evt, cb) {
+      promiseList.push(new Promise((resolve, reject) => {
+        monitor.panelWin.once(evt, _ => {
+          cb().then(resolve, reject);
+        });
+      }));
+    }
+
+    expectEvent(EVENTS.NETWORK_EVENT, async () => {
       is(getSelectedRequest(store.getState()), null,
         "There shouldn't be any selected item in the requests menu.");
       is(store.getState().requests.requests.size, 1,
         "The requests menu should not be empty after the first request.");
       is(!!document.querySelector(".network-details-panel"), false,
         "The network details panel should still be hidden after first request.");
 
       let requestItem = getSortedRequests(store.getState()).get(0);
@@ -100,17 +106,17 @@ function test() {
         document,
         getDisplayedRequests(store.getState()),
         requestItem,
         "GET",
         SIMPLE_SJS
       );
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_REQUEST_HEADERS, async () => {
+    expectEvent(EVENTS.RECEIVED_REQUEST_HEADERS, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.requestHeaders;
       });
 
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       ok(requestItem.requestHeaders,
@@ -126,43 +132,43 @@ function test() {
         document,
         getDisplayedRequests(store.getState()),
         requestItem,
         "GET",
         SIMPLE_SJS
       );
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_REQUEST_COOKIES, async () => {
+    expectEvent(EVENTS.RECEIVED_REQUEST_COOKIES, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.requestCookies;
       });
 
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       ok(requestItem.requestCookies,
         "There should be a requestCookies data available.");
-      is(requestItem.requestCookies.cookies.length, 2,
+      is(requestItem.requestCookies.length, 2,
         "The requestCookies data has an incorrect |cookies| property.");
 
       verifyRequestItemTarget(
         document,
         getDisplayedRequests(store.getState()),
         requestItem,
         "GET",
         SIMPLE_SJS
       );
     });
 
     monitor.panelWin.once(EVENTS.RECEIVED_REQUEST_POST_DATA, () => {
       ok(false, "Trap listener: this request doesn't have any post data.");
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_RESPONSE_HEADERS, async () => {
+    expectEvent(EVENTS.RECEIVED_RESPONSE_HEADERS, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.responseHeaders;
       });
 
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       ok(requestItem.responseHeaders,
@@ -176,39 +182,39 @@ function test() {
         document,
         getDisplayedRequests(store.getState()),
         requestItem,
         "GET",
         SIMPLE_SJS
       );
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_RESPONSE_COOKIES, async () => {
+    expectEvent(EVENTS.RECEIVED_RESPONSE_COOKIES, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.responseCookies;
       });
 
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       ok(requestItem.responseCookies,
         "There should be a responseCookies data available.");
-      is(requestItem.responseCookies.cookies.length, 2,
+      is(requestItem.responseCookies.length, 2,
         "The responseCookies data has an incorrect |cookies| property.");
 
       verifyRequestItemTarget(
         document,
         getDisplayedRequests(store.getState()),
         requestItem,
         "GET",
         SIMPLE_SJS
       );
     });
 
-    monitor.panelWin.once(EVENTS.STARTED_RECEIVING_RESPONSE, async () => {
+    expectEvent(EVENTS.STARTED_RECEIVING_RESPONSE, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.httpVersion &&
                requestItem.status &&
                requestItem.statusText &&
                requestItem.headersSize;
       });
 
@@ -231,17 +237,17 @@ function test() {
         SIMPLE_SJS,
         {
           status: "200",
           statusText: "Och Aye"
         }
       );
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_RESPONSE_CONTENT, async () => {
+    expectEvent(EVENTS.RECEIVED_RESPONSE_CONTENT, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.transferredSize &&
                requestItem.contentSize &&
                requestItem.mimeType &&
                requestItem.responseContent;
       });
 
@@ -279,17 +285,17 @@ function test() {
           type: "plain",
           fullMimeType: "text/plain; charset=utf-8",
           transferred: L10N.getFormatStrWithNumbers("networkMenu.sizeB", 12),
           size: L10N.getFormatStrWithNumbers("networkMenu.sizeB", 12),
         }
       );
     });
 
-    monitor.panelWin.once(EVENTS.UPDATING_EVENT_TIMINGS, async () => {
+    expectEvent(EVENTS.UPDATING_EVENT_TIMINGS, async () => {
       await waitUntil(() => {
         let requestItem = getSortedRequests(store.getState()).get(0);
         return requestItem.eventTimings;
       });
 
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       is(typeof requestItem.totalTime, "number",
@@ -304,17 +310,17 @@ function test() {
         "GET",
         SIMPLE_SJS,
         {
           time: true
         }
       );
     });
 
-    monitor.panelWin.once(EVENTS.RECEIVED_EVENT_TIMINGS, () => {
+    expectEvent(EVENTS.RECEIVED_EVENT_TIMINGS, async () => {
       let requestItem = getSortedRequests(store.getState()).get(0);
 
       ok(requestItem.eventTimings,
         "There should be a eventTimings data available.");
       is(typeof requestItem.eventTimings.timings.blocked, "number",
         "The eventTimings data has an incorrect |timings.blocked| property.");
       is(typeof requestItem.eventTimings.timings.dns, "number",
         "The eventTimings data has an incorrect |timings.dns| property.");
@@ -337,10 +343,14 @@ function test() {
         SIMPLE_SJS,
         {
           time: true
         }
       );
     });
 
     tab.linkedBrowser.reload();
+
+    await Promise.all(promiseList);
+    await teardown(monitor);
+    finish();
   });
 }
