
# HG changeset patch
# User Michael Layzell <michael@thelayzells.com>
# Date 1475866785 14400
# Node ID 7ee25aab52f5a7ff546313192df4ee1436e3b804
# Parent  24d65b1e1a763d5717c420d7f3f540124301ccc4
Bug 1303196 - Part 3: Update the named window resolution logic to be scoped to TabGroup instead of being process-global, r=bz

MozReview-Commit-ID: FaGoj6wmEuG


diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3685,43 +3685,16 @@ nsDocShell::FindItemWithName(const char1
     } else if (name.LowerCaseEqualsLiteral("_parent")) {
       GetSameTypeParent(getter_AddRefs(foundItem));
       if (!foundItem) {
         foundItem = this;
       }
     } else if (name.LowerCaseEqualsLiteral("_top")) {
       GetSameTypeRootTreeItem(getter_AddRefs(foundItem));
       NS_ASSERTION(foundItem, "Must have this; worst case it's us!");
-    }
-    // _main is an IE target which should be case-insensitive but isn't
-    // see bug 217886 for details
-    else if (name.LowerCaseEqualsLiteral("_content") ||
-             name.EqualsLiteral("_main")) {
-      // Must pass our same type root as requestor to the
-      // treeowner to make sure things work right.
-      nsCOMPtr<nsIDocShellTreeItem> root;
-      GetSameTypeRootTreeItem(getter_AddRefs(root));
-      if (mTreeOwner) {
-        NS_ASSERTION(root, "Must have this; worst case it's us!");
-        mTreeOwner->FindItemWithName(aName, root, aOriginalRequestor,
-                                     getter_AddRefs(foundItem));
-      }
-#ifdef DEBUG
-      else {
-        NS_ERROR("Someone isn't setting up the tree owner.  "
-                 "You might like to try that.  "
-                 "Things will.....you know, work.");
-        // Note: _content should always exist.  If we don't have one
-        // hanging off the treeowner, just create a named window....
-        // so don't return here, in case we did that and can now find
-        // it.
-        // XXXbz should we be using |root| instead of creating
-        // a new window?
-      }
-#endif
     } else {
       // Do the search for item by an actual name.
       DoFindItemWithName(aName, aRequestor, aOriginalRequestor,
                          getter_AddRefs(foundItem));
     }
 
     if (foundItem && !CanAccessItem(foundItem, aOriginalRequestor)) {
       foundItem = nullptr;
@@ -3785,33 +3758,38 @@ nsDocShell::DoFindItemWithName(const cha
   // docShellTreeOwner to do the search.
   nsCOMPtr<nsIDocShellTreeItem> parentAsTreeItem =
     do_QueryInterface(GetAsSupports(mParent));
   if (parentAsTreeItem) {
     if (parentAsTreeItem == reqAsTreeItem) {
       return NS_OK;
     }
 
-    if (parentAsTreeItem->ItemType() == mItemType) {
+    // If we have a same-type parent, respecting browser and app boundaries.
+    // NOTE: Could use GetSameTypeParent if the issues described in bug 1310344 are fixed.
+    if (!GetIsMozBrowserOrApp() && parentAsTreeItem->ItemType() == mItemType) {
       return parentAsTreeItem->FindItemWithName(
         aName,
         static_cast<nsIDocShellTreeItem*>(this),
         aOriginalRequestor,
         aResult);
     }
   }
 
-  // If the parent is null or not of the same type fall through and ask tree
-  // owner.
-
-  // This may fail, but comparing against null serves the same purpose
-  nsCOMPtr<nsIDocShellTreeOwner> reqAsTreeOwner(do_QueryInterface(aRequestor));
-  if (mTreeOwner && mTreeOwner != reqAsTreeOwner) {
-    return mTreeOwner->FindItemWithName(aName, this, aOriginalRequestor,
-                                        aResult);
+  // If we have a null parent or the parent is not of the same type, we need to
+  // give up on finding it in our tree, and start looking in our TabGroup.
+  nsCOMPtr<nsPIDOMWindowOuter> window = GetWindow();
+  if (window) {
+    RefPtr<mozilla::dom::TabGroup> tabGroup =
+      nsGlobalWindow::Cast(window)->TabGroup();
+    // We don't want to make the request to our TabGroup if they are the ones
+    // which made a request to us.
+    if (tabGroup != aRequestor) {
+      tabGroup->FindItemWithName(aName, this, aOriginalRequestor, aResult);
+    }
   }
 
   return NS_OK;
 }
 
 bool
 nsDocShell::IsSandboxedFrom(nsIDocShell* aTargetDocShell)
 {
diff --git a/docshell/base/nsIDocShellTreeOwner.idl b/docshell/base/nsIDocShellTreeOwner.idl
--- a/docshell/base/nsIDocShellTreeOwner.idl
+++ b/docshell/base/nsIDocShellTreeOwner.idl
@@ -11,34 +11,16 @@
  */
 
 interface nsIDocShellTreeItem;
 interface nsITabParent;
 
 [scriptable, uuid(0e3dc4b1-4cea-4a37-af71-79f0afd07574)]
 interface nsIDocShellTreeOwner : nsISupports
 {
-	/*
-	Return the child DocShellTreeItem with the specified name.
-	name - This is the name of the item that is trying to be found.
-	aRequestor - This is the docshellTreeItem that is requesting the find.  This
-	parameter is used to identify when the child is asking its parent to find
-	a child with the specific name.  The parent uses this parameter to ensure
-	a resursive state does not occur by not again asking the requestor for find
-	a shell by the specified name.  Inversely the child uses it to ensure it
-	does not ask its parent to do the search if its parent is the one that
-	asked it to search.
-	aOriginalRequestor - The original treeitem that made the request, if any.
-	This is used to ensure that we don't run into cross-site issues.
-
-	*/
-	nsIDocShellTreeItem findItemWithName(in wstring name, 
-		in nsIDocShellTreeItem aRequestor,
-		in nsIDocShellTreeItem aOriginalRequestor);
-
 	/**
 	 * Called when a content shell is added to the docshell tree.  This is
 	 * _only_ called for "root" content shells (that is, ones whose parent is a
 	 * chrome shell).
 	 *
 	 * @param aContentShell the shell being added.
 	 * @param aPrimary whether the shell is primary.
 	 * @param aTargetable whether the shell can be a target for named window
diff --git a/docshell/test/chrome/bug364461_window.xul b/docshell/test/chrome/bug364461_window.xul
--- a/docshell/test/chrome/bug364461_window.xul
+++ b/docshell/test/chrome/bug364461_window.xul
@@ -209,17 +209,17 @@
       //  Check that navigation is not blocked after a document is restored
       //  from bfcache
       
       var test7Doc = "data:text/html,<html><head><title>test7</title>" +
                       "</head><body>" +
                       "<iframe src='data:text/html," +
                         "<html><head><title>test7-nested1</title></head>" +
                         "<body>test7-nested1<br/>" +
-                        "<a href=\"data:text/plain,aaa\" target=\"_main\">" +
+                        "<a href=\"data:text/plain,aaa\" target=\"_top\">" +
                           "Click me, hit back, click me again</a>" +
                         "</body></html>'>" +
                       "</iframe>" +
                     "</body></html>";
       
       gExpected = [{type: "pagehide", title: "test6", persisted: true},
                    {type: "load", title: "test7-nested1"},
                    {type: "pageshow", title: "test7-nested1", persisted: false},
diff --git a/dom/base/DocGroup.cpp b/dom/base/DocGroup.cpp
--- a/dom/base/DocGroup.cpp
+++ b/dom/base/DocGroup.cpp
@@ -110,16 +110,58 @@ TabGroup::Join(nsPIDOMWindowOuter* aWind
 
 void
 TabGroup::Leave(nsPIDOMWindowOuter* aWindow)
 {
   MOZ_ASSERT(mWindows.Contains(aWindow));
   mWindows.RemoveElement(aWindow);
 }
 
+nsresult
+TabGroup::FindItemWithName(const char16_t* aName,
+                           nsIDocShellTreeItem* aRequestor,
+                           nsIDocShellTreeItem* aOriginalRequestor,
+                           nsIDocShellTreeItem** aFoundItem)
+{
+  NS_ENSURE_ARG_POINTER(aFoundItem);
+  *aFoundItem = nullptr;
+
+#ifdef DEBUG
+  nsDependentString name(aName);
+  MOZ_ASSERT(!name.LowerCaseEqualsLiteral("_blank") &&
+             !name.LowerCaseEqualsLiteral("_top") &&
+             !name.LowerCaseEqualsLiteral("_parent") &&
+             !name.LowerCaseEqualsLiteral("_self"));
+#endif
+
+  for (nsPIDOMWindowOuter* outerWindow : mWindows) {
+    // Ignore non-toplevel windows
+    if (outerWindow->GetScriptableParentOrNull()) {
+      continue;
+    }
+
+    nsCOMPtr<nsIDocShellTreeItem> docshell = outerWindow->GetDocShell();
+    if (!docshell) {
+      continue;
+    }
+
+    nsCOMPtr<nsIDocShellTreeItem> root;
+    docshell->GetSameTypeRootTreeItem(getter_AddRefs(root));
+    MOZ_RELEASE_ASSERT(docshell == root);
+    if (root && aRequestor != root) {
+      root->FindItemWithName(aName, this, aOriginalRequestor, aFoundItem);
+      if (*aFoundItem) {
+        break;
+      }
+    }
+  }
+
+  return NS_OK;
+}
+
 NS_IMPL_ISUPPORTS(TabGroup, nsISupports)
 
 TabGroup::HashEntry::HashEntry(const nsACString* aKey)
   : nsCStringHashKey(aKey), mDocGroup(nullptr)
 {}
 
 }
 }
diff --git a/dom/base/DocGroup.h b/dom/base/DocGroup.h
--- a/dom/base/DocGroup.h
+++ b/dom/base/DocGroup.h
@@ -114,16 +114,33 @@ public:
 
   void Leave(nsPIDOMWindowOuter* aWindow);
 
   Iterator Iter()
   {
     return mDocGroups.Iter();
   }
 
+
+  // Returns the nsIDocShellTreeItem with the given name, searching each of the
+  // docShell trees which are within this TabGroup. It will pass itself as
+  // aRequestor to each docShellTreeItem which it asks to search for the name,
+  // and will not search the docShellTreeItem which is passed as aRequestor.
+  //
+  // This method is used in order to correctly namespace named windows based on
+  // their unit of related browsing contexts.
+  //
+  // It is illegal to pass in the special case-insensitive names "_blank",
+  // "_self", "_parent" or "_top", as those should be handled elsewhere.
+  nsresult
+  FindItemWithName(const char16_t* aName,
+                   nsIDocShellTreeItem* aRequestor,
+                   nsIDocShellTreeItem* aOriginalRequestor,
+                   nsIDocShellTreeItem** aFoundItem);
+
 private:
   ~TabGroup();
   DocGroupMap mDocGroups;
   nsTArray<nsPIDOMWindowOuter*> mWindows;
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/browser-element/mochitest/browserElement_BrowserWindowNamespace.js b/dom/browser-element/mochitest/browserElement_BrowserWindowNamespace.js
--- a/dom/browser-element/mochitest/browserElement_BrowserWindowNamespace.js
+++ b/dom/browser-element/mochitest/browserElement_BrowserWindowNamespace.js
@@ -30,16 +30,20 @@ function runTest() {
       }
       else {
         ok(true, "Got locationchange to " + e.detail.url);
       }
     });
 
     SimpleTest.executeSoon(function() {
       var iframe2 = document.createElement('iframe');
+      // Make sure that iframe1 and iframe2 are in the same TabGroup by linking
+      // them through opener. Right now this API requires chrome privileges, as
+      // it is on MozFrameLoaderOwner.
+      SpecialPowers.wrap(iframe2).presetOpenerWindow(iframe1.contentWindow);
       iframe2.setAttribute('mozbrowser', 'true');
 
       iframe2.addEventListener('mozbrowseropenwindow', function(e) {
         ok(false, "Got second mozbrowseropenwindow event.");
       });
 
       document.body.appendChild(iframe2);
       iframe2.src = 'file_browserElement_BrowserWindowNamespace.html#2';
diff --git a/embedding/browser/nsDocShellTreeOwner.cpp b/embedding/browser/nsDocShellTreeOwner.cpp
--- a/embedding/browser/nsDocShellTreeOwner.cpp
+++ b/embedding/browser/nsDocShellTreeOwner.cpp
@@ -180,92 +180,16 @@ nsDocShellTreeOwner::GetInterface(const 
 
   return NS_NOINTERFACE;
 }
 
 //*****************************************************************************
 // nsDocShellTreeOwner::nsIDocShellTreeOwner
 //*****************************************************************************
 
-NS_IMETHODIMP
-nsDocShellTreeOwner::FindItemWithName(const char16_t* aName,
-                                      nsIDocShellTreeItem* aRequestor,
-                                      nsIDocShellTreeItem* aOriginalRequestor,
-                                      nsIDocShellTreeItem** aFoundItem)
-{
-  NS_ENSURE_ARG(aName);
-  NS_ENSURE_ARG_POINTER(aFoundItem);
-
-  // if we don't find one, we return NS_OK and a null result
-  *aFoundItem = nullptr;
-  nsresult rv;
-
-  nsAutoString name(aName);
-
-  if (!mWebBrowser) {
-    return NS_OK; // stymied
-  }
-
-  /* special cases */
-  if (name.IsEmpty()) {
-    return NS_OK;
-  }
-  if (name.LowerCaseEqualsLiteral("_blank")) {
-    return NS_OK;
-  }
-  // _main is an IE target which should be case-insensitive but isn't
-  // see bug 217886 for details
-  // XXXbz what if our browser isn't targetable?  We need to handle that somehow.
-  if (name.LowerCaseEqualsLiteral("_content") || name.EqualsLiteral("_main")) {
-    nsCOMPtr<nsIDocShell> foundItem = mWebBrowser->mDocShell;
-    foundItem.forget(aFoundItem);
-    return NS_OK;
-  }
-
-  if (!SameCOMIdentity(aRequestor, mWebBrowser->mDocShell)) {
-    // This isn't a request coming up from our kid, so check with said kid
-    nsISupports* thisSupports = static_cast<nsIDocShellTreeOwner*>(this);
-    rv = mWebBrowser->mDocShell->FindItemWithName(aName, thisSupports,
-                                                  aOriginalRequestor, aFoundItem);
-    if (NS_FAILED(rv) || *aFoundItem) {
-      return rv;
-    }
-  }
-
-  // next, if we have a parent and it isn't the requestor, ask it
-  if (mTreeOwner) {
-    nsCOMPtr<nsIDocShellTreeOwner> reqAsTreeOwner(do_QueryInterface(aRequestor));
-    if (mTreeOwner != reqAsTreeOwner)
-      return mTreeOwner->FindItemWithName(aName, mWebBrowser->mDocShell,
-                                          aOriginalRequestor, aFoundItem);
-    return NS_OK;
-  }
-
-  // finally, failing everything else, search all windows
-  return FindItemWithNameAcrossWindows(aName, aRequestor, aOriginalRequestor,
-                                       aFoundItem);
-}
-
-nsresult
-nsDocShellTreeOwner::FindItemWithNameAcrossWindows(
-    const char16_t* aName,
-    nsIDocShellTreeItem* aRequestor,
-    nsIDocShellTreeItem* aOriginalRequestor,
-    nsIDocShellTreeItem** aFoundItem)
-{
-  // search for the item across the list of top-level windows
-  nsCOMPtr<nsPIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
-  if (!wwatch) {
-    return NS_OK;
-  }
-
-  return wwatch->FindItemWithName(aName, aRequestor, aOriginalRequestor,
-                                  aFoundItem);
-}
-
 void
 nsDocShellTreeOwner::EnsurePrompter()
 {
   if (mPrompter) {
     return;
   }
 
   nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
diff --git a/embedding/components/windowwatcher/nsWindowWatcher.cpp b/embedding/components/windowwatcher/nsWindowWatcher.cpp
--- a/embedding/components/windowwatcher/nsWindowWatcher.cpp
+++ b/embedding/components/windowwatcher/nsWindowWatcher.cpp
@@ -2055,76 +2055,35 @@ nsWindowWatcher::WinHasOption(const nsAC
    necessarily return a failure method value. check aFoundItem.
 */
 NS_IMETHODIMP
 nsWindowWatcher::FindItemWithName(const char16_t* aName,
                                   nsIDocShellTreeItem* aRequestor,
                                   nsIDocShellTreeItem* aOriginalRequestor,
                                   nsIDocShellTreeItem** aFoundItem)
 {
-  *aFoundItem = 0;
-
-  /* special cases */
+  *aFoundItem = nullptr;
   if (!aName || !*aName) {
     return NS_OK;
   }
 
   nsDependentString name(aName);
-
-  nsCOMPtr<nsISimpleEnumerator> windows;
-  GetWindowEnumerator(getter_AddRefs(windows));
-  if (!windows) {
-    return NS_ERROR_FAILURE;
+  if (name.LowerCaseEqualsLiteral("_blank") ||
+      name.LowerCaseEqualsLiteral("_top") ||
+      name.LowerCaseEqualsLiteral("_parent") ||
+      name.LowerCaseEqualsLiteral("_self")) {
+    return NS_OK;
   }
 
-  bool more;
-  nsresult rv = NS_OK;
-
-  do {
-    windows->HasMoreElements(&more);
-    if (!more) {
-      break;
-    }
-    nsCOMPtr<nsISupports> nextSupWindow;
-    windows->GetNext(getter_AddRefs(nextSupWindow));
-    nsCOMPtr<mozIDOMWindowProxy> nextWindow(do_QueryInterface(nextSupWindow));
-    if (nextWindow) {
-      nsCOMPtr<nsIDocShellTreeItem> treeItem;
-      GetWindowTreeItem(nextWindow, getter_AddRefs(treeItem));
-      if (treeItem) {
-        // Get the root tree item of same type, since roots are the only
-        // things that call into the treeowner to look for named items.
-        nsCOMPtr<nsIDocShellTreeItem> root;
-        treeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
-        NS_ASSERTION(root, "Must have root tree item of same type");
-        // Make sure not to call back into aRequestor
-        if (root != aRequestor) {
-          // Get the tree owner so we can pass it in as the requestor so
-          // the child knows not to call back up, since we're walking
-          // all windows already.
-          nsCOMPtr<nsIDocShellTreeOwner> rootOwner;
-          // Note: if we have no aRequestor, then we want to also look for
-          // "special" window names, so pass a null requestor.  This will mean
-          // that the treeitem calls back up to us, effectively (with a
-          // non-null aRequestor), so break the loop immediately after the
-          // call in that case.
-          if (aRequestor) {
-            root->GetTreeOwner(getter_AddRefs(rootOwner));
-          }
-          rv = root->FindItemWithName(aName, rootOwner, aOriginalRequestor,
-                                      aFoundItem);
-          if (NS_FAILED(rv) || *aFoundItem || !aRequestor) {
-            break;
-          }
-        }
-      }
-    }
-  } while (1);
-
-  return rv;
+  // If we are looking for an item and we don't have a docshell we are checking
+  // on, let's just look in the chrome tab group!
+  return TabGroup::GetChromeTabGroup()->FindItemWithName(aName,
+                                                         aRequestor,
+                                                         aOriginalRequestor,
+                                                         aFoundItem);
 }
 
 already_AddRefed<nsIDocShellTreeItem>
 nsWindowWatcher::GetCallerTreeItem(nsIDocShellTreeItem* aParentItem)
 {
   nsCOMPtr<nsIWebNavigation> callerWebNav = do_GetInterface(GetEntryGlobal());
   nsCOMPtr<nsIDocShellTreeItem> callerItem = do_QueryInterface(callerWebNav);
   if (!callerItem) {
diff --git a/xpfe/appshell/nsChromeTreeOwner.cpp b/xpfe/appshell/nsChromeTreeOwner.cpp
--- a/xpfe/appshell/nsChromeTreeOwner.cpp
+++ b/xpfe/appshell/nsChromeTreeOwner.cpp
@@ -132,104 +132,16 @@ NS_IMETHODIMP nsChromeTreeOwner::GetInte
 
   return QueryInterface(aIID, aSink);
 }
 
 //*****************************************************************************
 // nsChromeTreeOwner::nsIDocShellTreeOwner
 //*****************************************************************************   
 
-NS_IMETHODIMP nsChromeTreeOwner::FindItemWithName(const char16_t* aName,
-   nsIDocShellTreeItem* aRequestor, nsIDocShellTreeItem* aOriginalRequestor,
-   nsIDocShellTreeItem** aFoundItem)
-{
-   NS_DEFINE_CID(kWindowMediatorCID, NS_WINDOWMEDIATOR_CID);
-
-   NS_ENSURE_ARG_POINTER(aFoundItem);
-
-   *aFoundItem = nullptr;
-
-   bool fIs_Content = false;
-
-   /* Special Cases */
-   if(!aName || !*aName)
-      return NS_OK;
-
-   nsDependentString name(aName);
-
-   if(name.LowerCaseEqualsLiteral("_blank"))
-      return NS_OK;
-   // _main is an IE target which should be case-insensitive but isn't
-   // see bug 217886 for details
-   if(name.LowerCaseEqualsLiteral("_content") || name.EqualsLiteral("_main"))
-      {
-      NS_ENSURE_STATE(mXULWindow);
-      fIs_Content = true;
-      mXULWindow->GetPrimaryContentShell(aFoundItem);
-      if(*aFoundItem)
-         return NS_OK;
-      // Otherwise fall through and ask the other windows for a content area.
-      }
-
-   nsCOMPtr<nsIWindowMediator> windowMediator(do_GetService(kWindowMediatorCID));
-   NS_ENSURE_TRUE(windowMediator, NS_ERROR_FAILURE);
-
-   nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
-   NS_ENSURE_SUCCESS(windowMediator->GetXULWindowEnumerator(nullptr, 
-      getter_AddRefs(windowEnumerator)), NS_ERROR_FAILURE);
-   
-   bool more;
-   
-   windowEnumerator->HasMoreElements(&more);
-   while(more)
-      {
-      nsCOMPtr<nsISupports> nextWindow = nullptr;
-      windowEnumerator->GetNext(getter_AddRefs(nextWindow));
-      nsCOMPtr<nsIXULWindow> xulWindow(do_QueryInterface(nextWindow));
-      NS_ENSURE_TRUE(xulWindow, NS_ERROR_FAILURE);
-
-      nsCOMPtr<nsIDocShellTreeItem> shellAsTreeItem;
-     
-      if(fIs_Content)
-         {
-         xulWindow->GetPrimaryContentShell(aFoundItem);
-         }
-      else
-         {
-         // Note that we don't look for targetable content shells here...
-         // in fact, we aren't looking for content shells at all!
-         nsCOMPtr<nsIDocShell> shell;
-         xulWindow->GetDocShell(getter_AddRefs(shell));
-         shellAsTreeItem = do_QueryInterface(shell);
-         if (shellAsTreeItem) {
-           // Get the root tree item of same type, since roots are the only
-           // things that call into the treeowner to look for named items.
-           nsCOMPtr<nsIDocShellTreeItem> root;
-           shellAsTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
-           shellAsTreeItem = root;
-         }
-         if(shellAsTreeItem && aRequestor != shellAsTreeItem)
-            {
-            // Do this so we can pass in the tree owner as the requestor so the child knows not
-            // to call back up.
-            nsCOMPtr<nsIDocShellTreeOwner> shellOwner;
-            shellAsTreeItem->GetTreeOwner(getter_AddRefs(shellOwner));
-            nsCOMPtr<nsISupports> shellOwnerSupports(do_QueryInterface(shellOwner));
-
-            shellAsTreeItem->FindItemWithName(aName, shellOwnerSupports,
-                                              aOriginalRequestor, aFoundItem);
-            }
-         }
-      if(*aFoundItem)
-         return NS_OK;   
-      windowEnumerator->HasMoreElements(&more);
-      }
-   return NS_OK;      
-}
-
 NS_IMETHODIMP
 nsChromeTreeOwner::ContentShellAdded(nsIDocShellTreeItem* aContentShell,
                                      bool aPrimary, bool aTargetable,
                                      const nsAString& aID)
 {
   NS_ENSURE_STATE(mXULWindow);
   return mXULWindow->ContentShellAdded(aContentShell, aPrimary, aTargetable,
                                        aID);
diff --git a/xpfe/appshell/nsContentTreeOwner.cpp b/xpfe/appshell/nsContentTreeOwner.cpp
--- a/xpfe/appshell/nsContentTreeOwner.cpp
+++ b/xpfe/appshell/nsContentTreeOwner.cpp
@@ -165,135 +165,16 @@ NS_IMETHODIMP nsContentTreeOwner::GetInt
 
   return QueryInterface(aIID, aSink);
 }
 
 //*****************************************************************************
 // nsContentTreeOwner::nsIDocShellTreeOwner
 //*****************************************************************************   
 
-NS_IMETHODIMP nsContentTreeOwner::FindItemWithName(const char16_t* aName,
-   nsIDocShellTreeItem* aRequestor, nsIDocShellTreeItem* aOriginalRequestor,
-   nsIDocShellTreeItem** aFoundItem)
-{
-   NS_DEFINE_CID(kWindowMediatorCID, NS_WINDOWMEDIATOR_CID);
-
-   NS_ENSURE_ARG_POINTER(aFoundItem);
-
-   *aFoundItem = nullptr;
-
-   bool fIs_Content = false;
-
-   /* Special Cases */
-   if (!aName || !*aName)
-      return NS_OK;
-
-   nsDependentString name(aName);
-
-   if (name.LowerCaseEqualsLiteral("_blank"))
-      return NS_OK;
-   // _main is an IE target which should be case-insensitive but isn't
-   // see bug 217886 for details
-   if (name.LowerCaseEqualsLiteral("_content") ||
-       name.EqualsLiteral("_main")) {
-     // If we're being called with an aRequestor and it's targetable, just
-     // return it -- _main and _content from inside targetable content shells
-     // should just be that content shell.  Note that we don't have to worry
-     // about the case when it's not targetable because it's primary -- that
-     // will Just Work when we call GetPrimaryContentShell.
-     NS_ENSURE_STATE(mXULWindow);
-     if (aRequestor) {
-       // This better be the root item!
-#ifdef DEBUG
-       nsCOMPtr<nsIDocShellTreeItem> debugRoot;
-       aRequestor->GetSameTypeRootTreeItem(getter_AddRefs(debugRoot));
-       NS_ASSERTION(SameCOMIdentity(debugRoot, aRequestor),
-                    "Bogus aRequestor");
-#endif
-
-       int32_t count = mXULWindow->mTargetableShells.Count();
-       for (int32_t i = 0; i < count; ++i) {
-         nsCOMPtr<nsIDocShellTreeItem> item =
-           do_QueryReferent(mXULWindow->mTargetableShells[i]);
-         if (SameCOMIdentity(item, aRequestor)) {
-           NS_ADDREF(*aFoundItem = aRequestor);
-           return NS_OK;
-         }
-       }
-     }
-     mXULWindow->GetPrimaryContentShell(aFoundItem);
-     if(*aFoundItem)
-       return NS_OK;
-     // Fall through and keep looking...
-     fIs_Content = true;
-   }
-
-   nsCOMPtr<nsIWindowMediator> windowMediator(do_GetService(kWindowMediatorCID));
-   NS_ENSURE_TRUE(windowMediator, NS_ERROR_FAILURE);
-
-   nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
-   NS_ENSURE_SUCCESS(windowMediator->GetXULWindowEnumerator(nullptr, 
-      getter_AddRefs(windowEnumerator)), NS_ERROR_FAILURE);
-   
-   bool more;
-   
-   windowEnumerator->HasMoreElements(&more);
-   while(more) {
-     nsCOMPtr<nsISupports> nextWindow = nullptr;
-     windowEnumerator->GetNext(getter_AddRefs(nextWindow));
-     nsCOMPtr<nsIXULWindow> xulWindow(do_QueryInterface(nextWindow));
-     NS_ENSURE_TRUE(xulWindow, NS_ERROR_FAILURE);
-
-     if (fIs_Content) {
-       xulWindow->GetPrimaryContentShell(aFoundItem);
-     } else {
-       // Get all the targetable windows from xulWindow and search them
-       RefPtr<nsXULWindow> win;
-       xulWindow->QueryInterface(NS_GET_IID(nsXULWindow), getter_AddRefs(win));
-       if (win) {
-         int32_t count = win->mTargetableShells.Count();
-         int32_t i;
-         for (i = 0; i < count && !*aFoundItem; ++i) {
-           nsCOMPtr<nsIDocShellTreeItem> shellAsTreeItem =
-             do_QueryReferent(win->mTargetableShells[i]);
-           if (shellAsTreeItem) {
-             // Get the root tree item of same type, since roots are the only
-             // things that call into the treeowner to look for named items.
-             // XXXbz ideally we could guarantee that mTargetableShells only
-             // contains roots, but the current treeowner apis don't allow
-             // that... yet.
-             nsCOMPtr<nsIDocShellTreeItem> root;
-             shellAsTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
-             NS_ASSERTION(root, "Must have root tree item of same type");
-             shellAsTreeItem.swap(root);
-             if (aRequestor != shellAsTreeItem) {
-               // Do this so we can pass in the tree owner as the
-               // requestor so the child knows not to call back up.
-               nsCOMPtr<nsIDocShellTreeOwner> shellOwner;
-               shellAsTreeItem->GetTreeOwner(getter_AddRefs(shellOwner));
-               nsCOMPtr<nsISupports> shellOwnerSupports =
-                 do_QueryInterface(shellOwner);
-
-               shellAsTreeItem->FindItemWithName(aName, shellOwnerSupports,
-                                                 aOriginalRequestor,
-                                                 aFoundItem);
-             }
-           }
-         }
-       }
-     }
-     
-     if (*aFoundItem)
-       return NS_OK;
-
-     windowEnumerator->HasMoreElements(&more);
-   }
-   return NS_OK;      
-}
-
 NS_IMETHODIMP
 nsContentTreeOwner::ContentShellAdded(nsIDocShellTreeItem* aContentShell,
                                       bool aPrimary, bool aTargetable,
                                       const nsAString& aID)
 {
   NS_ENSURE_STATE(mXULWindow);
   return mXULWindow->ContentShellAdded(aContentShell, aPrimary, aTargetable,
                                        aID);

