# HG changeset patch
# Parent 243019c47e63acb95f1a44e424ab6202c1fc5a1b
# User Ben Kelly <ben@wanderview.com>
Bug 940273 P1 interdiff 051 remaining review comments


diff --git a/dom/cache/Cache.cpp b/dom/cache/Cache.cpp
--- a/dom/cache/Cache.cpp
+++ b/dom/cache/Cache.cpp
@@ -32,17 +32,17 @@ using mozilla::dom::RequestOrUSVString;
 
 static bool
 IsValidPutRequestMethod(const Request& aRequest, ErrorResult& aRv)
 {
   nsAutoCString method;
   aRequest.GetMethod(method);
   bool valid = method.LowerCaseEqualsLiteral("get");
   if (!valid) {
-    NS_ConvertUTF8toUTF16 label(method);
+    NS_ConvertASCIItoUTF16 label(method);
     aRv.ThrowTypeError(MSG_INVALID_REQUEST_METHOD, &label);
   }
   return valid;
 }
 
 static bool
 IsValidPutRequestMethod(const RequestOrUSVString& aRequest,
                         ErrorResult& aRv)
@@ -376,17 +376,17 @@ Cache::GetParentObject() const
 
 JSObject*
 Cache::WrapObject(JSContext* aContext)
 {
   return CacheBinding::Wrap(aContext, this);
 }
 
 void
-Cache::ActorDestroy(mozilla::ipc::IProtocol* aActor)
+Cache::DestroyInternal(CacheChild* aActor)
 {
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == aActor);
   mActor->ClearListener();
   mActor = nullptr;
 }
 
 void
@@ -515,17 +515,17 @@ Cache::AssertOwningThread() const
   NS_ASSERT_OWNINGTHREAD(Cache);
 }
 #endif
 
 Cache::~Cache()
 {
   if (mActor) {
     mActor->StartDestroy();
-    // ActorDestroy() is called synchronously by StartDestroy().  So we
+    // DestroyInternal() is called synchronously by StartDestroy().  So we
     // should have already cleared the mActor.
     MOZ_ASSERT(!mActor);
   }
 }
 
 RequestId
 Cache::AddRequestPromise(Promise* aPromise, ErrorResult& aRv)
 {
diff --git a/dom/cache/Cache.h b/dom/cache/Cache.h
--- a/dom/cache/Cache.h
+++ b/dom/cache/Cache.h
@@ -73,18 +73,20 @@ public:
        const CacheQueryOptions& aParams, ErrorResult& aRv);
 
   // binding methods
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
   nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
+  // Called when CacheChild actor is being destroyed
+  void DestroyInternal(CacheChild* aActor);
+
   // methods forwarded from CacheChild
-  void ActorDestroy(mozilla::ipc::IProtocol* aActor);
   void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                          const PCacheResponseOrVoid& aResponse);
   void RecvMatchAllResponse(RequestId aRequestId, nsresult aRv,
                             const nsTArray<PCacheResponse>& aResponses);
   void RecvAddAllResponse(RequestId aRequestId, nsresult aRv);
   void RecvPutResponse(RequestId aRequestId, nsresult aRv);
 
   void RecvDeleteResponse(RequestId aRequestId, nsresult aRv,
diff --git a/dom/cache/CacheChild.cpp b/dom/cache/CacheChild.cpp
--- a/dom/cache/CacheChild.cpp
+++ b/dom/cache/CacheChild.cpp
@@ -69,32 +69,32 @@ CacheChild::StartDestroy()
 {
   // StartDestroy() can get called from either Cache or the Feature.
   // Theoretically we can get double called if the right race happens.  Handle
   // that by just ignoring the second StartDestroy() call.
   if (!mListener) {
     return;
   }
 
-  mListener->ActorDestroy(this);
+  mListener->DestroyInternal(this);
 
-  // Cache listener should call ClearListener() in ActorDestroy()
+  // Cache listener should call ClearListener() in DestroyInternal()
   MOZ_ASSERT(!mListener);
 
   // Start actor destruction from parent process
   unused << SendTeardown();
 }
 
 void
 CacheChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheChild);
   if (mListener) {
-    mListener->ActorDestroy(this);
-    // Cache listener should call ClearListener() in ActorDestroy()
+    mListener->DestroyInternal(this);
+    // Cache listener should call ClearListener() in DestroyInternal()
     MOZ_ASSERT(!mListener);
   }
 
   if (mFeature) {
     mFeature->RemoveActor(this);
     mFeature = nullptr;
   }
 }
diff --git a/dom/cache/CacheChild.h b/dom/cache/CacheChild.h
--- a/dom/cache/CacheChild.h
+++ b/dom/cache/CacheChild.h
@@ -33,16 +33,17 @@ public:
   void ClearListener();
 
   // ActorChild methods
 
   // Synchronously call ActorDestroy on our Cache listener and then start the
   // actor destruction asynchronously from the parent-side.
   virtual void StartDestroy() MOZ_OVERRIDE;
 
+private:
   // PCacheChild methods
   virtual void
   ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
 
   virtual bool
   RecvMatchResponse(const RequestId& requestId, const nsresult& aRv,
                     const PCacheResponseOrVoid& aResponse) MOZ_OVERRIDE;
   virtual bool
@@ -56,17 +57,16 @@ public:
                   const nsresult& aRv) MOZ_OVERRIDE;
   virtual bool
   RecvDeleteResponse(const RequestId& requestId, const nsresult& aRv,
                      const bool& result) MOZ_OVERRIDE;
   virtual bool
   RecvKeysResponse(const RequestId& requestId, const nsresult& aRv,
                    nsTArray<PCacheRequest>&& requests) MOZ_OVERRIDE;
 
-private:
   nsRefPtr<Feature> mFeature;
 
   // Use a weak ref so actor does not hold DOM object alive past content use.
   // The Cache object must call ClearListener() to null this before its
   // destroyed.
   Cache* MOZ_NON_OWNING_REF mListener;
 
   NS_DECL_OWNINGTHREAD
diff --git a/dom/cache/CacheParent.h b/dom/cache/CacheParent.h
--- a/dom/cache/CacheParent.h
+++ b/dom/cache/CacheParent.h
@@ -27,16 +27,17 @@ struct StreamHolder;
 class CacheParent MOZ_FINAL : public PCacheParent
                             , public Manager::Listener
                             , public FetchPut::Listener
 {
 public:
   CacheParent(cache::Manager* aManager, CacheId aCacheId);
   virtual ~CacheParent();
 
+private:
   // PCacheParent method
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvTeardown() MOZ_OVERRIDE;
   virtual bool
   RecvMatch(const RequestId& aRequestId, const PCacheRequest& aRequest,
             const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool
   RecvMatchAll(const RequestId& aRequestId, const PCacheRequestOrVoid& aRequest,
@@ -66,17 +67,16 @@ public:
   virtual void OnCacheKeys(RequestId aRequestId, nsresult aRv,
                            const nsTArray<SavedRequest>& aSavedRequests,
                            StreamList* aStreamList) MOZ_OVERRIDE;
 
   // FetchPut::Listener methods
   virtual void OnFetchPut(FetchPut* aFetchPut, RequestId aRequestId,
                           nsresult aRv) MOZ_OVERRIDE;
 
-private:
   already_AddRefed<nsIInputStream>
   DeserializeCacheStream(const PCacheReadStreamOrVoid& aStreamOrVoid);
 
   nsRefPtr<cache::Manager> mManager;
   const CacheId mCacheId;
   nsTArray<nsRefPtr<FetchPut>> mFetchPutList;
 };
 
diff --git a/dom/cache/CacheStorage.cpp b/dom/cache/CacheStorage.cpp
--- a/dom/cache/CacheStorage.cpp
+++ b/dom/cache/CacheStorage.cpp
@@ -359,17 +359,17 @@ CacheStorage::ActorFailed()
     RequestId requestId = mPendingRequests[i].mRequestId;
     nsRefPtr<Promise> promise = RemoveRequestPromise(requestId);
     promise->MaybeReject(NS_ERROR_UNEXPECTED);
   }
   mPendingRequests.Clear();
 }
 
 void
-CacheStorage::ActorDestroy(IProtocol* aActor)
+CacheStorage::DestroyInternal(CacheStorageChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
   MOZ_ASSERT(mActor);
   MOZ_ASSERT(mActor == aActor);
   mActor->ClearListener();
   mActor = nullptr;
 
   // Note that we will never get an actor again in case another request is
@@ -503,17 +503,17 @@ CacheStorage::AssertOwningThread() const
 #endif
 
 CacheStorage::~CacheStorage()
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorage);
 
   if (mActor) {
     mActor->StartDestroy();
-    // ActorDestroy() is called synchronously by StartDestroy().  So we
+    // DestroyInternal() is called synchronously by StartDestroy().  So we
     // should have already cleared the mActor.
     MOZ_ASSERT(!mActor);
   }
 }
 
 void
 CacheStorage::MaybeRunPendingRequests()
 {
diff --git a/dom/cache/CacheStorage.h b/dom/cache/CacheStorage.h
--- a/dom/cache/CacheStorage.h
+++ b/dom/cache/CacheStorage.h
@@ -73,18 +73,20 @@ public:
 
   nsISupports* GetParentObject() const;
   virtual JSObject* WrapObject(JSContext* aContext) MOZ_OVERRIDE;
 
   // nsIIPCbackgroundChildCreateCallback methods
   virtual void ActorCreated(PBackgroundChild* aActor) MOZ_OVERRIDE;
   virtual void ActorFailed() MOZ_OVERRIDE;
 
+  // Called when CacheStorageChild actor is being destroyed
+  void DestroyInternal(CacheStorageChild* aActor);
+
   // Methods forwarded from CacheStorageChild
-  void ActorDestroy(mozilla::ipc::IProtocol* aActor);
   void RecvMatchResponse(RequestId aRequestId, nsresult aRv,
                          const PCacheResponseOrVoid& aResponse);
   void RecvHasResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvOpenResponse(RequestId aRequestId, nsresult aRv,
                         CacheChild* aActor);
   void RecvDeleteResponse(RequestId aRequestId, nsresult aRv, bool aSuccess);
   void RecvKeysResponse(RequestId aRequestId, nsresult aRv,
                         const nsTArray<nsString>& aKeys);
diff --git a/dom/cache/CacheStorageChild.cpp b/dom/cache/CacheStorageChild.cpp
--- a/dom/cache/CacheStorageChild.cpp
+++ b/dom/cache/CacheStorageChild.cpp
@@ -51,32 +51,32 @@ CacheStorageChild::StartDestroy()
 
   // StartDestroy() can get called from either CacheStorage or the Feature.
   // Theoretically we can get double called if the right race happens.  Handle
   // that by just ignoring the second StartDestroy() call.
   if (!mListener) {
     return;
   }
 
-  mListener->ActorDestroy(this);
+  mListener->DestroyInternal(this);
 
-  // CacheStorage listener should call ClearListener() in ActorDestroy()
+  // CacheStorage listener should call ClearListener() in DestroyInternal()
   MOZ_ASSERT(!mListener);
 
   // Start actor destruction from parent process
   unused << SendTeardown();
 }
 
 void
 CacheStorageChild::ActorDestroy(ActorDestroyReason aReason)
 {
   NS_ASSERT_OWNINGTHREAD(CacheStorageChild);
   if (mListener) {
-    mListener->ActorDestroy(this);
-    // CacheStorage listener should call ClearListener() in ActorDestroy()
+    mListener->DestroyInternal(this);
+    // CacheStorage listener should call ClearListener() in DestroyInternal()
     MOZ_ASSERT(!mListener);
   }
 
   if (mFeature) {
     mFeature->RemoveActor(this);
     mFeature = nullptr;
   }
 }
diff --git a/dom/cache/CacheStorageChild.h b/dom/cache/CacheStorageChild.h
--- a/dom/cache/CacheStorageChild.h
+++ b/dom/cache/CacheStorageChild.h
@@ -33,16 +33,17 @@ public:
   void ClearListener();
 
   // ActorChild methods
 
   // Synchronously call ActorDestroy on our CacheStorage listener and then start
   // the actor destruction asynchronously from the parent-side.
   virtual void StartDestroy() MOZ_OVERRIDE;
 
+private:
   // PCacheStorageChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvMatchResponse(const RequestId& requestId,
                                  const nsresult& aRv,
                                  const PCacheResponseOrVoid& response) MOZ_OVERRIDE;
   virtual bool RecvHasResponse(const cache::RequestId& aRequestId,
                                const nsresult& aRv,
                                const bool& aSuccess) MOZ_OVERRIDE;
@@ -51,17 +52,16 @@ public:
                                 PCacheChild* aActor) MOZ_OVERRIDE;
   virtual bool RecvDeleteResponse(const cache::RequestId& aRequestId,
                                   const nsresult& aRv,
                                   const bool& aResult) MOZ_OVERRIDE;
   virtual bool RecvKeysResponse(const cache::RequestId& aRequestId,
                                 const nsresult& aRv,
                                 nsTArray<nsString>&& aKeys) MOZ_OVERRIDE;
 
-private:
   // Use a weak ref so actor does not hold DOM object alive past content use.
   // The CacheStorage object must call ClearListener() to null this before its
   // destroyed.
   CacheStorage* MOZ_NON_OWNING_REF mListener;
 
   nsRefPtr<Feature> mFeature;
 
   NS_DECL_OWNINGTHREAD
diff --git a/dom/cache/CacheStorageParent.h b/dom/cache/CacheStorageParent.h
--- a/dom/cache/CacheStorageParent.h
+++ b/dom/cache/CacheStorageParent.h
@@ -26,16 +26,17 @@ class CacheStorageParent MOZ_FINAL : pub
                                    , public PrincipalVerifier::Listener
                                    , public Manager::Listener
 {
 public:
   CacheStorageParent(PBackgroundParent* aManagingActor, Namespace aNamespace,
                      const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
   virtual ~CacheStorageParent();
 
+private:
   // PCacheStorageParent methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvTeardown() MOZ_OVERRIDE;
   virtual bool RecvMatch(const RequestId& aRequestId,
                          const PCacheRequest& aRequest,
                          const PCacheQueryParams& aParams) MOZ_OVERRIDE;
   virtual bool RecvHas(const RequestId& aRequestId,
                        const nsString& aKey) MOZ_OVERRIDE;
@@ -57,17 +58,16 @@ public:
                             bool aCacheFound) MOZ_OVERRIDE;
   virtual void OnStorageOpen(RequestId aRequestId, nsresult aRv,
                              CacheId aCacheId) MOZ_OVERRIDE;
   virtual void OnStorageDelete(RequestId aRequestId, nsresult aRv,
                                bool aCacheDeleted) MOZ_OVERRIDE;
   virtual void OnStorageKeys(RequestId aRequestId, nsresult aRv,
                              const nsTArray<nsString>& aKeys) MOZ_OVERRIDE;
 
-private:
   CacheStreamControlParent*
   SerializeReadStream(CacheStreamControlParent *aStreamControl, const nsID& aId,
                       StreamList* aStreamList,
                       PCacheReadStream* aReadStreamOut);
 
   void RetryPendingRequests();
   void FailPendingRequests(nsresult aRv);
 
diff --git a/dom/cache/CacheStreamControlChild.h b/dom/cache/CacheStreamControlChild.h
--- a/dom/cache/CacheStreamControlChild.h
+++ b/dom/cache/CacheStreamControlChild.h
@@ -30,22 +30,22 @@ public:
   void AddListener(ReadStream* aListener);
   void RemoveListener(ReadStream* aListener);
 
   void NoteClosed(const nsID& aId);
 
   // ActorChild methods
   virtual void StartDestroy() MOZ_OVERRIDE;
 
+private:
   // PCacheStreamControlChild methods
   virtual void ActorDestroy(ActorDestroyReason aReason) MOZ_OVERRIDE;
   virtual bool RecvClose(const nsID& aId) MOZ_OVERRIDE;
   virtual bool RecvCloseAll() MOZ_OVERRIDE;
 
-private:
   nsTArray<ReadStream*> mListeners;
   nsRefPtr<Feature> mFeature;
   bool mDestroyStarted;
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/cache/FileUtils.cpp b/dom/cache/FileUtils.cpp
--- a/dom/cache/FileUtils.cpp
+++ b/dom/cache/FileUtils.cpp
@@ -264,17 +264,17 @@ FileUtils::BodyIdToFile(nsIFile* aBaseDi
 
   nsresult rv = BodyGetCacheDir(aBaseDir, aId, aBodyFileOut);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(!(*aBodyFileOut))) { return NS_ERROR_UNEXPECTED; }
 
   char idString[NSID_LENGTH];
   aId.ToProvidedString(idString);
 
-  NS_ConvertUTF8toUTF16 fileName(idString);
+  NS_ConvertASCIItoUTF16 fileName(idString);
 
   if (aType == BODY_FILE_FINAL) {
     fileName.AppendLiteral(".final");
   } else {
     fileName.AppendLiteral(".tmp");
   }
 
   rv = (*aBodyFileOut)->Append(fileName);
