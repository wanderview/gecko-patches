# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dd5c4b3cb885771c80eecbd45fcaafe0919a8ffd
Bug 1206124 P1 Fix "same-origin" and "cors" credentials in FetchDriver. r=nsm

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -591,23 +591,30 @@ FetchDriver::HttpFetch(bool aCORSFlag, b
   }
 
   nsCOMPtr<nsIStreamListener> listener = this;
 
   // Only use nsCORSListenerProxy if we are in CORS mode.  Otherwise it
   // will overwrite the CorsMode flag unconditionally to "cors" or
   // "cors-with-forced-preflight".
   if (mRequest->Mode() == RequestMode::Cors) {
+    // Passing false for the credentials flag to nsCORSListenerProxy is semantically
+    // the same as the "same-origin" RequestCredentials value.  We implement further
+    // blocking of credentials for "omit" by setting LOAD_ANONYMOUS manually for
+    // the initial channel here and in the redirect callback.
+    bool corsCredentials =
+      mRequest->GetCredentialsMode() == RequestCredentials::Include;
+
     // Set up a CORS proxy that will handle the various requirements of the CORS
     // protocol. It handles the preflight cache and CORS response headers.
     // If the request is allowed, it will start our original request
     // and our observer will be notified. On failure, our observer is notified
     // directly.
     nsRefPtr<nsCORSListenerProxy> corsListener =
-      new nsCORSListenerProxy(this, mPrincipal, useCredentials);
+      new nsCORSListenerProxy(this, mPrincipal, corsCredentials);
     rv = corsListener->Init(chan, DataURIHandling::Allow);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return FailWithNetworkError();
     }
     listener = corsListener.forget();
   }
 
   // If preflight is required, start a "CORS preflight fetch"
@@ -1092,16 +1099,34 @@ FetchDriver::OnRedirectVerifyCallback(ns
     // Otherwise, we rely on necko and the CORS proxy to do the right thing
     // as the redirect is followed.  In general this means basic or http
     // fetch.  If we've ever been CORS, we need to stay CORS.
     MOZ_ASSERT(nextOp.mType == BASIC_FETCH || nextOp.mType == HTTP_FETCH);
     MOZ_ASSERT_IF(mCORSFlagEverSet, nextOp.mType == HTTP_FETCH);
     MOZ_ASSERT_IF(mCORSFlagEverSet, nextOp.mCORSFlag);
   }
 
+  // The nsCORSListenerProxy only implements the "same-origin" RequestCredentials
+  // policy.  We need to manually set the LOAD_ANONYMOUS flag here to handle
+  // the "omit" RequestCredentials case on redirect.  We also have to manually
+  // set the flag for the "same-origin" case when we are cross-origin, but
+  // not in CORS mode.  We use the opaque response tainting to implement this.
+  // Note, there is an open issue regarding "same-origin" handling in no-cors
+  // mode: https://github.com/whatwg/fetch/issues/130
+  if (mRequest->GetCredentialsMode() == RequestCredentials::Omit ||
+      (mRequest->GetCredentialsMode() == RequestCredentials::Same_origin &&
+       mRequest->GetResponseTainting() == InternalRequest::RESPONSETAINT_OPAQUE)) {
+    nsLoadFlags flags;
+    aResult = mNewRedirectChannel->GetLoadFlags(&flags);
+    if (NS_SUCCEEDED(aResult)) {
+      flags |= nsIRequest::LOAD_ANONYMOUS;
+      aResult = mNewRedirectChannel->SetLoadFlags(flags);
+    }
+  }
+
   mOldRedirectChannel = nullptr;
   mNewRedirectChannel = nullptr;
   mRedirectCallback->OnRedirectVerifyCallback(aResult);
   mRedirectCallback = nullptr;
   return NS_OK;
 }
 
 void
