# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  af6185bfabbeaddbb4066ac3433a2f6c103806d2
Bug 1206124 P1 Fix "same-origin" and "cors" credentials in FetchDriver. r=nsm

diff --git a/dom/fetch/FetchDriver.cpp b/dom/fetch/FetchDriver.cpp
--- a/dom/fetch/FetchDriver.cpp
+++ b/dom/fetch/FetchDriver.cpp
@@ -411,26 +411,32 @@ FetchDriver::HttpFetch(bool aCORSFlag, b
   //
   // NS_StartCORSPreflight() will automatically kick off the original request
   // if it succeeds, so we need to have everything setup for the original
   // request too.
 
   // Step 3.3 "Let credentials flag be set if either request's credentials mode
   // is include, or request's credentials mode is same-origin and the CORS flag
   // is unset, and unset otherwise."
+  // NOTE: We also make "same-origin" credentials work for no-cors mode by
+  //       checking for opaque tainting here.  This indicates if the no-cors
+  //       request has ever been cross-origin.  See the following spec
+  //       issue: https://github.com/whatwg/fetch/issues/130
   bool useCredentials = false;
   if (mRequest->GetCredentialsMode() == RequestCredentials::Include ||
-      (mRequest->GetCredentialsMode() == RequestCredentials::Same_origin && !aCORSFlag)) {
+      (mRequest->GetCredentialsMode() == RequestCredentials::Same_origin && !aCORSFlag &&
+       mRequest->GetResponseTainting() != InternalRequest::RESPONSETAINT_OPAQUE)) {
     useCredentials = true;
   }
 
   // This is effectivetly the opposite of the use credentials flag in "HTTP
   // network or cache fetch" in the spec and decides whether to transmit
   // cookies and other identifying information. LOAD_ANONYMOUS also prevents
-  // new cookies sent by the server from being stored.
+  // new cookies sent by the server from being stored.  This value will
+  // propagate across redirects, which is what we want.
   const nsLoadFlags credentialsFlag = useCredentials ? 0 : nsIRequest::LOAD_ANONYMOUS;
 
   // From here on we create a channel and set its properties with the
   // information from the InternalRequest. This is an implementation detail.
   MOZ_ASSERT(mLoadGroup);
   nsCOMPtr<nsIChannel> chan;
   rv = NS_NewChannel(getter_AddRefs(chan),
                      uri,
@@ -587,27 +593,35 @@ FetchDriver::HttpFetch(bool aCORSFlag, b
       // If it is not an http channel, it has to be a jar one.
       MOZ_ASSERT(jarChannel);
       jarChannel->ForceNoIntercept();
     }
   }
 
   nsCOMPtr<nsIStreamListener> listener = this;
 
+  MOZ_ASSERT_IF(aCORSFlag, mRequest->Mode() == RequestMode::Cors);
+
   // Only use nsCORSListenerProxy if we are in CORS mode.  Otherwise it
   // will overwrite the CorsMode flag unconditionally to "cors" or
   // "cors-with-forced-preflight".
   if (mRequest->Mode() == RequestMode::Cors) {
+    // Passing false for the credentials flag to nsCORSListenerProxy is semantically
+    // the same as the "same-origin" RequestCredentials value.  We implement further
+    // blocking of credentials for "omit" by setting LOAD_ANONYMOUS manually above.
+    bool corsCredentials =
+      mRequest->GetCredentialsMode() == RequestCredentials::Include;
+
     // Set up a CORS proxy that will handle the various requirements of the CORS
     // protocol. It handles the preflight cache and CORS response headers.
     // If the request is allowed, it will start our original request
     // and our observer will be notified. On failure, our observer is notified
     // directly.
     nsRefPtr<nsCORSListenerProxy> corsListener =
-      new nsCORSListenerProxy(this, mPrincipal, useCredentials);
+      new nsCORSListenerProxy(this, mPrincipal, corsCredentials);
     rv = corsListener->Init(chan, DataURIHandling::Allow);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       return FailWithNetworkError();
     }
     listener = corsListener.forget();
   }
 
   // If preflight is required, start a "CORS preflight fetch"
@@ -1090,16 +1104,41 @@ FetchDriver::OnRedirectVerifyCallback(ns
     mOldRedirectChannel->Cancel(aResult);
   } else {
     // Otherwise, we rely on necko and the CORS proxy to do the right thing
     // as the redirect is followed.  In general this means basic or http
     // fetch.  If we've ever been CORS, we need to stay CORS.
     MOZ_ASSERT(nextOp.mType == BASIC_FETCH || nextOp.mType == HTTP_FETCH);
     MOZ_ASSERT_IF(mCORSFlagEverSet, nextOp.mType == HTTP_FETCH);
     MOZ_ASSERT_IF(mCORSFlagEverSet, nextOp.mCORSFlag);
+
+    // Examine and possibly set the LOAD_ANONYMOUS flag on the channel.
+    nsLoadFlags flags;
+    aResult = mNewRedirectChannel->GetLoadFlags(&flags);
+    if (NS_SUCCEEDED(aResult)) {
+      if (mRequest->GetCredentialsMode() == RequestCredentials::Same_origin &&
+          mRequest->GetResponseTainting() == InternalRequest::RESPONSETAINT_OPAQUE) {
+        // In the case of a "no-cors" mode request with "same-origin" credentials,
+        // we have to set LOAD_ANONYMOUS manually here in order to avoid sending
+        // credentials on a cross-origin redirect.
+        flags |= nsIRequest::LOAD_ANONYMOUS;
+        aResult = mNewRedirectChannel->SetLoadFlags(flags);
+      } else if (mRequest->GetCredentialsMode() == RequestCredentials::Omit ||
+                 (mRequest->GetCredentialsMode() == RequestCredentials::Same_origin &&
+                  nextOp.mCORSFlag)) {
+        // Make sure nothing in the redirect chain screws up our credentials
+        // settings.  LOAD_ANONYMOUS must be set if any of the following is true:
+        //  - RequestCredentials is "omit"
+        //  - RequestCredentials is "same-origin" and the CORS flag is set
+        MOZ_ASSERT(flags & nsIRequest::LOAD_ANONYMOUS);
+      } else {
+        // Otherwise, we should be sending credentials
+        MOZ_ASSERT(!(flags & nsIRequest::LOAD_ANONYMOUS));
+      }
+    }
   }
 
   mOldRedirectChannel = nullptr;
   mNewRedirectChannel = nullptr;
   mRedirectCallback->OnRedirectVerifyCallback(aResult);
   mRedirectCallback = nullptr;
   return NS_OK;
 }
