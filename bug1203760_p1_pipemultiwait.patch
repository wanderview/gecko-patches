# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  dd9e40b4695909f1595814c0e79e4d55d73dc283
Bug 1203760 P1 Allow pipe to wake up multiple streams at the same time. r=froydnj

diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -76,34 +76,46 @@ class nsPipeEvents
 {
 public:
   nsPipeEvents() { }
   ~nsPipeEvents();
 
   inline void NotifyInputReady(nsIAsyncInputStream* aStream,
                                nsIInputStreamCallback* aCallback)
   {
-    NS_ASSERTION(!mInputCallback, "already have an input event");
-    mInputStream = aStream;
-    mInputCallback = aCallback;
+    mInputList.AppendElement(InputEntry(aStream, aCallback));
   }
 
   inline void NotifyOutputReady(nsIAsyncOutputStream* aStream,
                                 nsIOutputStreamCallback* aCallback)
   {
-    NS_ASSERTION(!mOutputCallback, "already have an output event");
-    mOutputStream = aStream;
-    mOutputCallback = aCallback;
+    mOutputList.AppendElement(OutputEntry(aStream, aCallback));
   }
 
 private:
-  nsCOMPtr<nsIAsyncInputStream>     mInputStream;
-  nsCOMPtr<nsIInputStreamCallback>  mInputCallback;
-  nsCOMPtr<nsIAsyncOutputStream>    mOutputStream;
-  nsCOMPtr<nsIOutputStreamCallback> mOutputCallback;
+  template <typename S, typename C>
+  struct Entry
+  {
+    Entry(S* aStream, C* aCallback)
+      : mStream(aStream)
+      , mCallback(aCallback)
+    {
+      MOZ_ASSERT(mStream);
+      MOZ_ASSERT(mCallback);
+    }
+
+    nsCOMPtr<S> mStream;
+    nsCOMPtr<C> mCallback;
+  };
+
+  typedef Entry<nsIAsyncInputStream, nsIInputStreamCallback> InputEntry;
+  nsTArray<InputEntry> mInputList;
+
+  typedef Entry<nsIAsyncOutputStream, nsIOutputStreamCallback> OutputEntry;
+  nsTArray<OutputEntry> mOutputList;
 };
 
 //-----------------------------------------------------------------------------
 
 // This class is used to maintain input stream state.  Its broken out from the
 // nsPipeInputStream class because generally the nsPipe should be modifying
 // this state and not the input stream itself.
 struct nsPipeReadState
@@ -1077,26 +1089,25 @@ nsPipe::ValidateAllReadCursors()
 //-----------------------------------------------------------------------------
 // nsPipeEvents methods:
 //-----------------------------------------------------------------------------
 
 nsPipeEvents::~nsPipeEvents()
 {
   // dispatch any pending events
 
-  if (mInputCallback) {
-    mInputCallback->OnInputStreamReady(mInputStream);
-    mInputCallback = 0;
-    mInputStream = 0;
+  for (uint32_t i = 0; i < mInputList.Length(); ++i) {
+    mInputList[i].mCallback->OnInputStreamReady(mInputList[i].mStream);
   }
-  if (mOutputCallback) {
-    mOutputCallback->OnOutputStreamReady(mOutputStream);
-    mOutputCallback = 0;
-    mOutputStream = 0;
+  mInputList.Clear();
+
+  for (uint32_t i = 0; i < mOutputList.Length(); ++i) {
+    mOutputList[i].mCallback->OnOutputStreamReady(mOutputList[i].mStream);
   }
+  mOutputList.Clear();
 }
 
 //-----------------------------------------------------------------------------
 // nsPipeInputStream methods:
 //-----------------------------------------------------------------------------
 
 NS_IMPL_ADDREF(nsPipeInputStream);
 NS_IMPL_RELEASE(nsPipeInputStream);
