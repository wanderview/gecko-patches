# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  0d36b7d7e1f94d3f90e49915ed7c7ce1c8f54a2b
Bug 1256428 P18 Add spec annotations and tweak asserts in ServiceWorkerUpdateJob. r=jdm

diff --git a/dom/workers/ServiceWorkerUpdateJob.cpp b/dom/workers/ServiceWorkerUpdateJob.cpp
--- a/dom/workers/ServiceWorkerUpdateJob.cpp
+++ b/dom/workers/ServiceWorkerUpdateJob.cpp
@@ -130,16 +130,24 @@ ServiceWorkerUpdateJob::~ServiceWorkerUp
 }
 
 void
 ServiceWorkerUpdateJob::FailUpdateJob(ErrorResult& aRv)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aRv.Failed());
 
+  // Cleanup after a failed installation.  This essentially implements
+  // step 12 of the Install algorithm.
+  //
+  //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
+  //
+  // The spec currently only runs this after an install event fails,
+  // but we must handle many more internal errors.  So we check for
+  // cleanup on every non-successful exit.
   if (mRegistration) {
     if (mServiceWorker) {
       mServiceWorker->UpdateState(ServiceWorkerState::Redundant);
       serviceWorkerScriptCache::PurgeCache(mRegistration->mPrincipal,
                                            mServiceWorker->CacheName());
     }
 
     RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
@@ -179,30 +187,35 @@ ServiceWorkerUpdateJob::AsyncExecute()
   AssertIsOnMainThread();
   MOZ_ASSERT(GetType() == Type::Update);
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
+  // Begin step 1 of the Update algorithm.
+  //
+  //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#update-algorithm
+
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   RefPtr<ServiceWorkerRegistrationInfo> registration =
     swm->GetRegistration(mPrincipal, mScope);
 
   if (!registration || registration->mPendingUninstall) {
     ErrorResult rv;
     rv.ThrowTypeError<MSG_SW_UPDATE_BAD_REGISTRATION>(NS_ConvertUTF8toUTF16(mScope),
                                                       NS_LITERAL_STRING("uninstalled"));
     FailUpdateJob(rv);
     return;
   }
 
-  // If a different script has been registered between when this update
-  // was scheduled and it running now, then simply abort.
+  // If a Register job with a new script executed ahead of us in the job queue,
+  // then our update for the old script no longer makes sense.  Simply abort
+  // in this case.
   RefPtr<ServiceWorkerInfo> newest = registration->Newest();
   if (newest && !mScriptSpec.Equals(newest->ScriptSpec())) {
     ErrorResult rv;
     rv.ThrowTypeError<MSG_SW_UPDATE_BAD_REGISTRATION>(NS_ConvertUTF8toUTF16(mScope),
                                                       NS_LITERAL_STRING("changed"));
     FailUpdateJob(rv);
     return;
   }
@@ -220,26 +233,24 @@ ServiceWorkerUpdateJob::SetRegistration(
   MOZ_ASSERT(aRegistration);
   mRegistration = aRegistration;
 }
 
 void
 ServiceWorkerUpdateJob::Update()
 {
   AssertIsOnMainThread();
+  MOZ_ASSERT(!Canceled());
 
   // SetRegistration() must be called before Update().
   MOZ_ASSERT(mRegistration);
+  MOZ_ASSERT(!mRegistration->mInstallingWorker);
 
-  if (Canceled()) {
-    FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
-    return;
-  }
-
-  MOZ_ASSERT(!mRegistration->mInstallingWorker);
+  // Begin the script download and comparison steps starting at step 5
+  // of the Update algorithm.
 
   RefPtr<ServiceWorkerInfo> workerInfo = mRegistration->Newest();
   nsAutoString cacheName;
 
   // If the script has not changed, we need to perform a byte-for-byte
   // comparison.
   if (workerInfo && workerInfo->ScriptSpec().Equals(mScriptSpec)) {
     cacheName = workerInfo->CacheName();
@@ -265,27 +276,32 @@ ServiceWorkerUpdateJob::ComparisonResult
 {
   AssertIsOnMainThread();
 
   if (NS_WARN_IF(Canceled())) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
+  // Handle failure of the download or comparison.  This is part of Update
+  // step 5 as "If the algorithm asynchronously completes with null, then:".
   if (NS_WARN_IF(NS_FAILED(aStatus))) {
     FailUpdateJob(aStatus);
     return;
   }
 
   // The spec validates the response before performing the byte-for-byte check.
   // Here we perform the comparison in another module and then validate the
   // script URL and scope.  Make sure to do this validation before accepting
   // an byte-for-byte match since the service-worker-allowed header might have
   // changed since the last time it was installed.
 
+  // This is step 2 the "validate response" section of Update algorithm step 5.
+  // Step 1 is performed in the serviceWorkerScriptCache code.
+
   nsCOMPtr<nsIURI> scriptURI;
   nsresult rv = NS_NewURI(getter_AddRefs(scriptURI), mScriptSpec);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     FailUpdateJob(NS_ERROR_DOM_SECURITY_ERR);
     return;
   }
 
   nsCOMPtr<nsIURI> maxScopeURI;
@@ -317,24 +333,26 @@ ServiceWorkerUpdateJob::ComparisonResult
 
   if (!StringBeginsWith(mRegistration->mScope, maxPrefix)) {
     NS_WARNING("By default a service worker's scope is restricted to at or below it's script's location.");
     FailUpdateJob(NS_ERROR_DOM_SECURITY_ERR);
     return;
   }
 
   // The response has been validated, so now we can consider if its a
-  // byte-for-byte match.
+  // byte-for-byte match.  This is step 6 of the Update algorithm.
   if (aInCacheAndEqual) {
     Finish(NS_OK);
     return;
   }
 
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_UPDATED, 1);
 
+  // Begin step 7 of the Update algorithm to evaluate the new script.
+
   MOZ_ASSERT(!mServiceWorker);
   mServiceWorker = new ServiceWorkerInfo(mRegistration->mPrincipal,
                                          mRegistration->mScope,
                                          mScriptSpec, aNewCacheName);
 
   nsMainThreadPtrHandle<ServiceWorkerUpdateJob> handle(
       new nsMainThreadPtrHolder<ServiceWorkerUpdateJob>(this));
   RefPtr<LifeCycleEventCallback> callback = new ContinueUpdateRunnable(handle);
@@ -354,16 +372,19 @@ ServiceWorkerUpdateJob::ContinueUpdateAf
 {
   AssertIsOnMainThread();
 
   if (Canceled()) {
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
+  // Step 7.5 of the Update algorithm verifying that the script evaluated
+  // successfully.
+
   if (NS_WARN_IF(!aScriptEvaluationResult)) {
     ErrorResult error;
 
     NS_ConvertUTF8toUTF16 scriptSpec(mScriptSpec);
     NS_ConvertUTF8toUTF16 scope(mRegistration->mScope);
     error.ThrowTypeError<MSG_SW_SCRIPT_THREW>(scriptSpec, scope);
     FailUpdateJob(error);
     return;
@@ -371,35 +392,38 @@ ServiceWorkerUpdateJob::ContinueUpdateAf
 
   Install();
 }
 
 void
 ServiceWorkerUpdateJob::Install()
 {
   AssertIsOnMainThread();
-
-  if (Canceled()) {
-    return FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
-  }
+  MOZ_ASSERT(!Canceled());
 
   MOZ_ASSERT(!mRegistration->mInstallingWorker);
 
+  // Begin step 2 of the Install algorithm.
+  //
+  //  https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#installation-algorithm
+
   MOZ_ASSERT(mServiceWorker);
   mRegistration->mInstallingWorker = mServiceWorker.forget();
   mRegistration->mInstallingWorker->UpdateState(ServiceWorkerState::Installing);
   mRegistration->NotifyListenersOnChange();
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                  WhichServiceWorker::INSTALLING_WORKER);
 
+  // Step 6 of the Install algorithm resolving the job promise.
   InvokeResultCallbacks(NS_OK);
 
-  // The job should NOT fail from this point on.
+  // The job promise cannot be rejected after this point, but the job can
+  // still fail; e.g. if the install event handler throws, etc.
 
   // fire the updatefound event
   nsCOMPtr<nsIRunnable> upr =
     NS_NewRunnableMethodWithArg<RefPtr<ServiceWorkerRegistrationInfo>>(
       swm,
       &ServiceWorkerManager::FireUpdateFoundOnServiceWorkerRegistrations,
       mRegistration);
   NS_DispatchToMainThread(upr);
@@ -429,16 +453,18 @@ ServiceWorkerUpdateJob::ContinueAfterIns
   if (Canceled()) {
     return FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
   }
 
   MOZ_ASSERT(mRegistration->mInstallingWorker);
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
 
+  // Continue executing the Install algorithm at step 12.
+
   // "If installFailed is true"
   if (NS_WARN_IF(!aInstallEventSuccess)) {
     // The installing worker is cleaned up by FailUpdateJob().
     FailUpdateJob(NS_ERROR_DOM_ABORT_ERR);
     return;
   }
 
   // "If registration's waiting worker is not null"
@@ -454,15 +480,21 @@ ServiceWorkerUpdateJob::ContinueAfterIns
   mRegistration->NotifyListenersOnChange();
   swm->StoreRegistration(mPrincipal, mRegistration);
   swm->InvalidateServiceWorkerRegistrationWorker(mRegistration,
                                                  WhichServiceWorker::INSTALLING_WORKER |
                                                  WhichServiceWorker::WAITING_WORKER);
 
   Finish(NS_OK);
 
-  // Activate() is invoked out of band of atomic.
+  // Step 20 calls for explicitly waiting for queued event tasks to fire.  Instead,
+  // we simply queue a runnable to execute Activate.  This ensures the events are
+  // flushed from the queue before proceeding.
+
+  // Step 22 of the Install algorithm.  Activate is executed after the completion
+  // of this job.  The controlling client and skipWaiting checks are performed
+  // in TryToActivate().
   mRegistration->TryToActivateAsync();
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
