# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  bb6ce3887ee56ee47ec6af641f2afc9d54eb1457
Bug 1371787 P9 Change Timeout::mInterval member to a TimeDuration. r=ehsan

diff --git a/dom/base/Timeout.h b/dom/base/Timeout.h
--- a/dom/base/Timeout.h
+++ b/dom/base/Timeout.h
@@ -67,18 +67,18 @@ public:
 
   // Used to allow several reasons for setting a timeout, where each
   // 'Reason' value is using a possibly overlapping set of id:s.
   Reason mReason;
 
   // Returned as value of setTimeout()
   uint32_t mTimeoutId;
 
-  // Interval in milliseconds
-  uint32_t mInterval;
+  // Interval
+  TimeDuration mInterval;
 
   // Identifies which firing level this Timeout is being processed in
   // when sync loops trigger nested firing.
   uint32_t mFiringId;
 
   uint32_t mNestingLevel;
 
   // The popup state at timeout creation time if not created from
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -228,23 +228,16 @@ TimeoutManager::IsInvalidFiringId(uint32
   return !mFiringIdStack.Contains(aFiringId);
 }
 
 // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
 // uses 5.
 #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
 
 TimeDuration
-TimeoutManager::CalculateDelay(Timeout* aTimeout, int32_t aDefaultDelay) const
-{
-  return CalculateDelay(aTimeout,
-                        TimeDuration::FromMilliseconds(aDefaultDelay));
-}
-
-TimeDuration
 TimeoutManager::CalculateDelay(Timeout* aTimeout,
                                const TimeDuration& aDefaultDelay) const
 {
   MOZ_DIAGNOSTIC_ASSERT(aTimeout);
   TimeDuration result = aDefaultDelay;
 
   if (aTimeout->mIsInterval ||
       aTimeout->mNestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
@@ -386,17 +379,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   uint32_t maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
   if (static_cast<uint32_t>(interval) > maxTimeoutMs) {
     interval = maxTimeoutMs;
   }
 
   RefPtr<Timeout> timeout = new Timeout();
   timeout->mWindow = &mWindow;
   timeout->mIsInterval = aIsInterval;
-  timeout->mInterval = interval;
+  timeout->mInterval = TimeDuration::FromMilliseconds(interval);
   timeout->mScriptHandler = aHandler;
   timeout->mReason = aReason;
 
   // No popups from timeouts by default
   timeout->mPopupState = openAbused;
 
   switch (gTimeoutBucketingStrategy) {
   default:
@@ -436,17 +429,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   }
 
   uint32_t nestingLevel = sNestingLevel + 1;
   if (!aIsInterval) {
     timeout->mNestingLevel = nestingLevel;
   }
 
   // Now clamp the actual interval we will use for the timer based on
-  TimeDuration realInterval = CalculateDelay(timeout, interval);
+  TimeDuration realInterval = CalculateDelay(timeout, timeout->mInterval);
   timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), realInterval);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     nsresult rv = mExecutor->MaybeSchedule(timeout->When(),
                                            MinSchedulingDelay());
     if (NS_FAILED(rv)) {
       return rv;
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -51,20 +51,18 @@ public:
   void RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline);
   // Return true if |aTimeout| needs to be reinserted into the timeout list.
   bool RescheduleTimeout(mozilla::dom::Timeout* aTimeout, const TimeStamp& now);
 
   void ClearAllTimeouts();
   uint32_t GetTimeoutId(mozilla::dom::Timeout::Reason aReason);
 
   TimeDuration
-  CalculateDelay(Timeout* aTimeout, int32_t aDefaultDelay = 0) const;
-
-  TimeDuration
-  CalculateDelay(Timeout* aTimeout, const TimeDuration& aDefaultDelay) const;
+  CalculateDelay(Timeout* aTimeout,
+                 const TimeDuration& aDefaultDelay = TimeDuration()) const;
 
   // aTimeout is the timeout that we're about to start running.  This function
   // returns the current timeout.
   mozilla::dom::Timeout* BeginRunningTimeout(mozilla::dom::Timeout* aTimeout);
   // aTimeout is the last running timeout.
   void EndRunningTimeout(mozilla::dom::Timeout* aTimeout);
 
   void UnmarkGrayTimers();
