# HG changeset patch
# Parent 3b40951bf9cd45107965bc1e77ba56de3d9ee9b9
# User Kyle Huey <khuey@kylehuey.com>

nsFancyPipe

diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -43,16 +43,17 @@ include URIParams;
 include ProtocolTypes;
 
 // Workaround to prevent error if PContentChild.cpp & PContentBridgeParent.cpp
 // are put into different UnifiedProtocolsXX.cpp files.
 // XXX Remove this once bug 1069073 is fixed
 include "mozilla/dom/PContentBridgeParent.h";
 
 include "mozilla/dom/indexedDB/SerializationHelpers.h";
+include "mozilla/dom/PContentBridgeParent.h";
 
 using GeoPosition from "nsGeoPositionIPCSerialiser.h";
 
 using struct ChromePackage from "mozilla/chrome/RegistryMessageUtils.h";
 using struct ResourceMapping from "mozilla/chrome/RegistryMessageUtils.h";
 using struct OverrideMapping from "mozilla/chrome/RegistryMessageUtils.h";
 using base::ChildPrivileges from "base/process_util.h";
 using struct IPC::Permission from "mozilla/net/NeckoMessageUtils.h";
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -7,16 +7,17 @@
 #include "FileDescriptorSetChild.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/MessagePortChild.h"
 #include "mozilla/dom/cache/CacheChild.h"
 #include "mozilla/dom/cache/PCacheStorageChild.h"
 #include "mozilla/dom/cache/CacheStreamControlChild.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/PBackgroundTestChild.h"
 #include "nsTraceRefcnt.h"
 
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::CacheChild;
 using mozilla::dom::cache::PCacheChild;
 using mozilla::dom::cache::PCacheStreamControlChild;
 using mozilla::dom::cache::CacheStreamControlChild;
@@ -124,16 +125,29 @@ BackgroundChildImpl::DeallocPBackgroundI
                                              PBackgroundIDBFactoryChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+PBackgroundPipeTransportChild*
+BackgroundChildImpl::AllocPBackgroundPipeTransportChild(const intptr_t& aCookie)
+{
+  MOZ_ASSERT_UNREACHABLE("Not reached!");
+  return nullptr;
+}
+
+bool
+BackgroundChildImpl::DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor)
+{
+  return detail::DeallocPBackgroundPipeTransportChild(aActor);
+}
+
 auto
 BackgroundChildImpl::AllocPBlobChild(const BlobConstructorParams& aParams)
   -> PBlobChild*
 {
   MOZ_ASSERT(aParams.type() != BlobConstructorParams::T__None);
 
   return mozilla::dom::BlobChild::Create(this, aParams);
 }
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -59,16 +59,22 @@ protected:
   virtual PBackgroundIDBFactoryChild*
   AllocPBackgroundIDBFactoryChild(const OptionalWindowId& aOptionalWindowId)
                                   MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundIDBFactoryChild(PBackgroundIDBFactoryChild* aActor)
                                     MOZ_OVERRIDE;
 
+  virtual PBackgroundPipeTransportChild*
+  AllocPBackgroundPipeTransportChild(const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor) MOZ_OVERRIDE;
+
   virtual PBlobChild*
   AllocPBlobChild(const BlobConstructorParams& aParams) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBlobChild(PBlobChild* aActor) MOZ_OVERRIDE;
 
   virtual PFileDescriptorSetChild*
   AllocPFileDescriptorSetChild(const FileDescriptor& aFileDescriptor)
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -9,16 +9,17 @@
 #include "mozilla/dom/PBlobParent.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/ipc/BlobParent.h"
 #include "mozilla/dom/MessagePortParent.h"
 #include "mozilla/dom/cache/CacheStorageParent.h"
 #include "mozilla/dom/cache/PCacheParent.h"
 #include "mozilla/dom/cache/PCacheStreamControlParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "mozilla/ipc/PBackgroundTestParent.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
 #else
@@ -161,16 +162,37 @@ BackgroundParentImpl::DeallocPBackground
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
   return mozilla::dom::indexedDB::DeallocPBackgroundIDBFactoryParent(aActor);
 }
 
+
+PBackgroundPipeTransportParent*
+BackgroundParentImpl::AllocPBackgroundPipeTransportParent(const intptr_t& aCookie)
+{
+  return detail::AllocPBackgroundPipeTransportParent(aCookie);
+}
+
+bool
+BackgroundParentImpl::RecvPBackgroundPipeTransportConstructor(PBackgroundPipeTransportParent* aActor,
+							      const intptr_t& aCookie)
+{
+  // Nothing to do.  Everything interesting happens in alloc.
+  return true;
+}
+
+bool
+BackgroundParentImpl::DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor)
+{
+  return detail::DeallocPBackgroundPipeTransportParent(aActor);
+}
+
 auto
 BackgroundParentImpl::AllocPBlobParent(const BlobConstructorParams& aParams)
   -> PBlobParent*
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   if (NS_WARN_IF(aParams.type() !=
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -48,16 +48,26 @@ protected:
                                       PBackgroundIDBFactoryParent* aActor,
                                       const OptionalWindowId& aOptionalWindowId)
                                       MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBackgroundIDBFactoryParent(PBackgroundIDBFactoryParent* aActor)
                                      MOZ_OVERRIDE;
 
+  virtual PBackgroundPipeTransportParent*
+  AllocPBackgroundPipeTransportParent(const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  RecvPBackgroundPipeTransportConstructor(PBackgroundPipeTransportParent* aActor,
+					  const intptr_t& aCookie) MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor) MOZ_OVERRIDE;
+
   virtual PBlobParent*
   AllocPBlobParent(const BlobConstructorParams& aParams) MOZ_OVERRIDE;
 
   virtual bool
   DeallocPBlobParent(PBlobParent* aActor) MOZ_OVERRIDE;
 
   virtual PFileDescriptorSetParent*
   AllocPFileDescriptorSetParent(const FileDescriptor& aFileDescriptor)
diff --git a/ipc/glue/CrossProcessPipe.cpp b/ipc/glue/CrossProcessPipe.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/glue/CrossProcessPipe.cpp
@@ -0,0 +1,1034 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * A CrossProcessPipe is a pipe between the main process and a child process.
+ * The pipe can flow in either direction, but it is not duplex (meaning that
+ * a given pipe can only flow in one direction).  nsIPipe is the external
+ * facing interface we provide.
+ * 
+ */
+
+#include "mozilla/ipc/CrossProcessPipe.h"
+
+#include "mozilla/ipc/BackgroundChild.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/ipc/PBackgroundPipeTransportParent.h"
+#include "mozilla/ipc/PBackgroundPipeTransportChild.h"
+#include "mozilla/StaticMutex.h"
+#include "nsComponentManagerUtils.h"
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsIEventTarget.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIIPCSerializableInputStream.h"
+#include "nsIPipe.h"
+#include "nsISupportsImpl.h"
+#include "nsStreamUtils.h"
+#include "nsThreadUtils.h"
+#include "nsXULAppAPI.h"
+
+namespace {
+
+class CrossProcessPipe : public nsICrossProcessPipe
+{
+  typedef mozilla::ipc::PipeDirection PipeDirection;
+
+  nsCOMPtr<nsIAsyncInputStream> mInputStream;
+  nsCOMPtr<nsIAsyncOutputStream> mOutputStream;
+
+  ~CrossProcessPipe() {}
+
+public:
+  CrossProcessPipe() {}
+
+  void
+  InitializeStreams(PipeDirection aDirection);
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSICROSSPROCESSPIPE
+};
+
+// Handed out by CrossProcessPipe in the sending process for the other side's
+// stream.  All this knows how to do is serialize.  There's no reason this can't
+// be an output stream too, but we don't have any code that serializes output
+// streams today.
+class SerializationPlaceholderStream : public nsIAsyncInputStream,
+                                       public nsIIPCSerializableInputStream
+{
+  nsRefPtr<CrossProcessPipe> mCrossProcessPipe;
+
+public:
+  SerializationPlaceholderStream(CrossProcessPipe* aCrossProcessPipe)
+    : mCrossProcessPipe(aCrossProcessPipe)
+  {
+  }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIINPUTSTREAM
+  NS_DECL_NSIASYNCINPUTSTREAM
+  NS_DECL_NSIIPCSERIALIZABLEINPUTSTREAM
+};
+
+NS_IMPL_ISUPPORTS(SerializationPlaceholderStream,
+                  nsIAsyncInputStream,
+                  nsIInputStream,
+                  nsIIPCSerializableInputStream)
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Close()
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Available(uint64_t* aAvailableBytes)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::Read(char* aBuf, uint32_t aCount,
+                                     uint32_t* aBytesRead)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::ReadSegments(nsWriteSegmentFun aWriter,
+                                             void* aClosure, uint32_t aCount,
+                                             uint32_t* aBytesRead)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::IsNonBlocking(bool* aIsNonBlocking)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::CloseWithStatus(nsresult aStatus)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+SerializationPlaceholderStream::AsyncWait(nsIInputStreamCallback* aCallback,
+                                          uint32_t aFlags, uint32_t aRequestedCount,
+                                          nsIEventTarget* aEventTarget)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void
+SerializationPlaceholderStream::Serialize(mozilla::ipc::InputStreamParams& aParams,
+                                          FileDescriptorArray& aFileDesriptors)
+{
+  MOZ_ASSERT(mCrossProcessPipe);
+
+  mozilla::ipc::PipeInputStreamParams params;
+  params.pipeId() = (intptr_t)mCrossProcessPipe.get();
+
+  aParams = params;
+
+  // We can only be serialized once.  This also breaks the cycle the pipe has
+  // with us.
+  mCrossProcessPipe = nullptr;
+}
+
+bool
+SerializationPlaceholderStream::Deserialize(const mozilla::ipc::InputStreamParams& aParams,
+                                            const FileDescriptorArray& aFileDescriptors)
+{
+  MOZ_ASSERT_UNREACHABLE("Don't deserialize me!");
+  return false;
+}
+
+// The class for the "active" streams.  These are the streams that actually
+// support reading and writing, as opposed to just being serialized across the
+// process boundary.  When a SerializationPlaceholderStream crosses the process
+// boundary it comes out as an XPPActiveStream on the other side.
+//
+// The PBackgroundTransport must always be initiated from the child, because the
+// parent (PBackground) thread doesn't know where the other end of the transport
+// should be.  But the data can flow either direction.
+class XPPActiveStream : private mozilla::ipc::PBackgroundPipeTransportParent,
+                        private mozilla::ipc::PBackgroundPipeTransportChild,
+                        public nsIAsyncInputStream,
+                        public nsIAsyncOutputStream,
+                        public nsIIPCBackgroundChildCreateCallback
+{
+  typedef mozilla::ipc::PipeDirection PipeDirection;
+  typedef mozilla::ipc::PBackgroundChild PBackgroundChild;
+
+  // If true, we're the parent actor, otherwise, we're the child actor.
+  const bool mInMainProcess;
+  const intptr_t mPipeId;
+  // Are we the sending or receiving side?
+  const PipeDirection mDirection;
+
+  // Things only touched on the transport thread.
+
+  // The event target we are doing the transport on.  In the main process this
+  // is the PBackground thread.  In the child it is whatever thread is using
+  // the stream (probably a stream transport service thread).  In the main
+  // process this will be null until the transport actor is setup.
+  nsCOMPtr<nsIEventTarget> mTransportThread;
+  PBackgroundChild* mBackgroundChild;
+
+  // Stream implementation variables touched on multiple threads, and protected
+  // by mLock.
+  // mIsTransportActive is only ever written to on the transport thread, so it's
+  // ok to read unlocked on the transport thread.
+  bool mIsTransportActive;
+  nsresult mResultCode;
+  bool mClosed;
+  FallibleTArray<unsigned char> mData;
+  uint32_t mRequestedAsyncWaitCount;
+  nsCOMPtr<nsIInputStreamCallback> mInputAsyncWaitCallback;
+  nsCOMPtr<nsIOutputStreamCallback> mOutputAsyncWaitCallback;
+
+  mozilla::Mutex mLock;
+
+  struct XPPStreamListComparator {
+    static bool Equals(const nsRefPtr<XPPActiveStream>& aA, const intptr_t& aB) {
+      return aA->PipeId() == aB;
+    }
+  };
+
+  static nsTArray<nsRefPtr<XPPActiveStream>>* sInFlightList;
+  static mozilla::StaticMutex sInFlightMutex;
+
+  ~XPPActiveStream() { }
+
+  virtual bool
+  Recv__delete__(const nsresult& aResult) MOZ_OVERRIDE;
+
+  virtual bool
+  RecvChunk(const InfallibleTArray<unsigned char>& aData) MOZ_OVERRIDE;
+
+  virtual void
+  ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
+
+  void
+  CloseTransport(nsresult aRv);
+
+  void
+  FlushTransport();
+
+public:
+  PBackgroundPipeTransportParent*
+  AsParent() const {
+    MOZ_ASSERT(mInMainProcess);
+    return const_cast<XPPActiveStream*>(this);
+  }
+
+  static XPPActiveStream*
+  FromParent(PBackgroundPipeTransportParent* aParent) {
+    auto self = static_cast<XPPActiveStream*>(aParent);
+    MOZ_ASSERT(self->mInMainProcess);
+    return self;
+  }
+
+  XPPActiveStream(intptr_t aPipeId, PipeDirection aDirection)
+    : mInMainProcess(XRE_GetProcessType() == GeckoProcessType_Default)
+    , mPipeId(aPipeId)
+    , mDirection(aDirection)
+    , mBackgroundChild(nullptr)
+    , mIsTransportActive(false)
+    , mResultCode(NS_OK)
+    , mClosed(false)
+    , mRequestedAsyncWaitCount(0)
+    , mLock("XPPActiveStream lock")
+  {
+    if (!sInFlightList) {
+      sInFlightList = new nsTArray<nsRefPtr<XPPActiveStream>>;
+    }
+  }
+
+  intptr_t
+  PipeId() const {
+    return mPipeId;
+  }
+
+  bool IsOnTransportThread() const
+  {
+    bool isOnCurrentThread = false;
+    MOZ_ALWAYS_SUCCEEDS(mTransportThread->IsOnCurrentThread(&isOnCurrentThread));
+    return isOnCurrentThread;
+  }
+
+  void
+  AssertIsOnTransportThread() const
+  {
+#ifdef DEBUG
+    if (mTransportThread) {
+      MOZ_ASSERT(IsOnTransportThread());
+    }
+    else {
+      // If the transport thread is not setup yet we can't check the threading,
+      // but we can at least ensure that we're allowed to be unset.
+      MOZ_ASSERT(!mIsTransportActive);
+    }
+#endif
+  }
+
+  // Called to initialize mTransportThread.
+  void
+  NoteTransportThread()
+  {
+    MOZ_ASSERT(!mTransportThread);
+
+    // In the main process we must always be on the PBackground thread.
+    // But in a child process we could be on any thread.
+    if (mInMainProcess) {
+      mozilla::ipc::AssertIsOnBackgroundThread();
+    }
+
+    mTransportThread = do_GetCurrentThread();
+  }
+
+  bool
+  RecvIPDLConstructor();
+
+  bool
+  IsReceiving() const
+  {
+    return mDirection == mozilla::ipc::Receiving;
+  }
+
+  bool
+  IsSending() const
+  {
+    return mDirection == mozilla::ipc::Sending;
+  }
+
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  // We can't use the XPCOM macros directly, because nsIInputStream and
+  // nsIOutputStream have some of the same member functions.
+  // nsIInputStream
+  NS_IMETHOD
+  Close() MOZ_OVERRIDE
+  {
+    return CloseWithStatus(NS_OK);
+  }
+
+  NS_IMETHOD
+  Available(uint64_t* aBytesAvailable) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  Read(char* aBuf, uint32_t aCount, uint32_t* aBytesRead) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  ReadSegments(nsWriteSegmentFun aWriter, void* aClosure, uint32_t aCount,
+               uint32_t* aBytesRead) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  IsNonBlocking(bool* aIsNonBlocking) MOZ_OVERRIDE;
+
+  // The parts of nsIOutputStream that are not shared
+  NS_IMETHOD
+  Flush(void) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  Write(const char* aBuf, uint32_t aCount,
+        uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  WriteFrom(nsIInputStream* aFromStream, uint32_t aCount,
+            uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  WriteSegments(nsReadSegmentFun aReader, void* aClosure, uint32_t aCount,
+                uint32_t* aBytesWritten) MOZ_OVERRIDE;
+
+  // nsIAsyncInputStream
+  NS_IMETHOD
+  CloseWithStatus(nsresult aStatus) MOZ_OVERRIDE;
+
+  NS_IMETHOD
+  AsyncWait(nsIInputStreamCallback* aCallback, uint32_t aFlags,
+            uint32_t aRequestedCount,
+            nsIEventTarget* aEventTarget) MOZ_OVERRIDE;
+
+  // The parts of nsIAsyncOutputStream that are not shared
+  NS_IMETHOD
+  AsyncWait(nsIOutputStreamCallback* aCallback, uint32_t aFlags,
+            uint32_t aRequestedCount,
+            nsIEventTarget* aEventTarget) MOZ_OVERRIDE;
+
+  NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
+
+  nsresult
+  InitializeTransport();
+
+  bool
+  IPDLConstruct(mozilla::ipc::PBackgroundChild* aActor);
+
+  void
+  MaybeFireCallbacks();
+
+  static already_AddRefed<XPPActiveStream>
+  GetOrCreateById(intptr_t aId, mozilla::ipc::PipeDirection aDirection);
+};
+
+nsTArray<nsRefPtr<XPPActiveStream>>* XPPActiveStream::sInFlightList;
+mozilla::StaticMutex XPPActiveStream::sInFlightMutex;
+
+NS_IMPL_ADDREF(XPPActiveStream)
+NS_IMPL_RELEASE(XPPActiveStream)
+
+NS_INTERFACE_MAP_BEGIN(XPPActiveStream)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIAsyncInputStream)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIInputStream, IsReceiving())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAsyncInputStream, IsReceiving())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIOutputStream, IsSending())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAsyncOutputStream, IsSending())
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIIPCBackgroundChildCreateCallback, !mInMainProcess)
+NS_INTERFACE_MAP_END
+
+bool
+XPPActiveStream::Recv__delete__(const nsresult& aResult)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  // XXXkhuey should CloseWithStatus
+  mResultCode = aResult;
+  mClosed = true;
+  MaybeFireCallbacks();
+  mIsTransportActive = false;
+
+  return true;
+}
+
+bool
+XPPActiveStream::RecvChunk(const InfallibleTArray<unsigned char>& aData)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(IsReceiving());
+  MOZ_ASSERT(mIsTransportActive);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  // XXXkhuey IPDL move refs would be really useful here ...  
+  mData.AppendElements(aData);
+
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+void
+XPPActiveStream::ActorDestroy(ActorDestroyReason aWhy)
+{
+  AssertIsOnTransportThread();
+
+  // If the transport was already shutdown we don't care.
+  if (!mIsTransportActive) {
+    return;
+  }
+
+  // But if the transport was interrupted we need to close things.
+  // XXXtodo close things
+  mIsTransportActive = false;
+}
+
+void
+XPPActiveStream::CloseTransport(nsresult aRv)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  if (mInMainProcess) {
+    if (!PBackgroundPipeTransportParent::Send__delete__(this, aRv)) {
+      NS_WARNING("Send__delete__ failed!");
+    }
+  }
+  else {
+    if (!PBackgroundPipeTransportChild::Send__delete__(this, aRv)) {
+      NS_WARNING("Send__delete__ failed!");
+    }
+  }
+}
+
+void
+XPPActiveStream::FlushTransport()
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(mIsTransportActive);
+
+  nsTArray<unsigned char> dataToSend;
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+    dataToSend = mozilla::Move(mData);
+  }
+
+  if (mInMainProcess) {
+    if (!PBackgroundPipeTransportParent::SendChunk(dataToSend)) {
+      NS_WARNING("SendChunk failed!");
+    }
+  }
+  else {
+    if (!PBackgroundPipeTransportChild::SendChunk(dataToSend)) {
+      NS_WARNING("SendChunk failed!");
+    }
+  }
+}
+
+NS_IMETHODIMP
+XPPActiveStream::CloseWithStatus(nsresult aRv)
+{
+  if (mClosed) {
+    return NS_OK;
+  }
+
+  // If we are the sending end, we close the transport here.  If we are the
+  // receiving end, we just ignore anything further that we receive.  We could
+  // add support for shutting the transport but it would require not using the
+  // __delete__ message to signal the completion of the stream.
+  if (IsSending()) {
+    Flush();
+
+    {
+      mozilla::MutexAutoLock lock(mLock);
+      mClosed = true;
+      mResultCode = aRv;
+    }
+
+    if (IsOnTransportThread()) {
+      CloseTransport(aRv);
+    }
+    else {
+      nsCOMPtr<nsIRunnable> event =
+        NS_NewRunnableMethodWithArg<nsresult>(this, &XPPActiveStream::CloseTransport, aRv);
+      mTransportThread->Dispatch(event, 0);
+    }
+
+    return NS_OK;
+  }
+
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::IsNonBlocking(bool* aIsNonBlocking)
+{
+  // We can't assert that we're on the transport thread here, this may be tested
+  // on one thread to determine whether or not to send us to another thread.
+  MOZ_ASSERT(aIsNonBlocking);
+
+  *aIsNonBlocking = true;
+
+  return NS_OK;
+}
+
+bool
+XPPActiveStream::RecvIPDLConstructor()
+{
+  MOZ_ASSERT(mInMainProcess);
+
+  NoteTransportThread();
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  mIsTransportActive = true;
+
+  // And if we're waiting, begin.
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Available(uint64_t* aBytesAvailable)
+{
+  MOZ_ASSERT(IsReceiving());
+
+  mozilla::MutexAutoLock lock(mLock);
+  *aBytesAvailable = mData.Length();
+
+  if (*aBytesAvailable == 0 && !mIsTransportActive) {
+    if (!mClosed) {
+      return NS_OK;
+    }
+
+    return mResultCode == NS_OK ? NS_BASE_STREAM_CLOSED : mResultCode;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Read(char* aBuf, uint32_t aCount, uint32_t* aBytesRead)
+{
+  return ReadSegments(NS_CopySegmentToBuffer, aBuf, aCount, aBytesRead);
+}
+
+NS_IMETHODIMP
+XPPActiveStream::ReadSegments(nsWriteSegmentFun aWriter, void* aClosure,
+                              uint32_t aCount, uint32_t* aBytesRead)
+{
+  MOZ_ASSERT(IsReceiving());
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    auto countToCopy = std::min<uint32_t>(aCount, mData.Length());
+    while (countToCopy) {
+      uint32_t countCopied = 0;
+      nsresult rv = aWriter(this, aClosure, (char*)mData.Elements(), *aBytesRead,
+                            countToCopy, &countCopied);
+
+      if (NS_FAILED(rv) || countCopied == 0) {
+        // We're done.  Don't propagate errors.
+        return NS_OK;
+      }
+
+      MOZ_ASSERT(countCopied <= countToCopy);
+      mData.RemoveElementsAt(0, countCopied);
+      countToCopy -= countCopied;
+      *aBytesRead += countCopied;
+    }
+  }
+
+  if (*aBytesRead > 0) {
+    return NS_OK;
+  }
+
+  if (mClosed) {
+    return NS_OK;
+  }
+
+  // Otherwise the transport is not open or we're waiting for data.
+  return NS_BASE_STREAM_WOULD_BLOCK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Flush()
+{
+  MOZ_ASSERT(IsSending());
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    if (mClosed) {
+      return NS_BASE_STREAM_CLOSED;
+    }
+
+    if (!mIsTransportActive) {
+      // Can't flush if we're not open.
+      return NS_BASE_STREAM_WOULD_BLOCK;
+    }
+  }
+
+  if (IsOnTransportThread()) {
+    FlushTransport();
+  }
+  else {
+    nsCOMPtr<nsIRunnable> event = NS_NewRunnableMethod(this, &XPPActiveStream::FlushTransport);
+    mTransportThread->Dispatch(event, 0);
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::Write(const char* aBuf, uint32_t aCount,
+                       uint32_t* aBytesWritten)
+{
+  return WriteSegments(NS_CopySegmentToBuffer, (void*)aBuf, aCount, aBytesWritten);
+}
+
+NS_IMETHODIMP
+XPPActiveStream::WriteFrom(nsIInputStream* aFromStream, uint32_t aCount,
+                           uint32_t* aBytesWritten)
+{
+  MOZ_ASSERT(IsSending());
+
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::WriteSegments(nsReadSegmentFun aReader, void* aClosure,
+                               uint32_t aCount, uint32_t* aBytesWritten)
+{
+  MOZ_ASSERT(IsSending());
+
+  {
+    mozilla::MutexAutoLock lock(mLock);
+
+    if (mClosed) {
+      return NS_BASE_STREAM_CLOSED;
+    }
+
+    if (!mIsTransportActive) {
+      return NS_BASE_STREAM_WOULD_BLOCK;
+    }
+
+    const uint32_t originalLength = mData.Length();
+    *aBytesWritten = originalLength;
+
+    while (aCount) {
+      uint32_t countRead = 0;
+      uint32_t oldLength = mData.Length();
+      mData.SetLength(oldLength + aCount);
+
+      nsresult rv = aReader(this, aClosure, (char*)mData.Elements(),
+                            *aBytesWritten, aCount, &countRead);
+      if (NS_FAILED(rv) || countRead == 0) {
+        mData.SetLength(oldLength);
+        *aBytesWritten -= originalLength;
+        return NS_OK;
+      }
+
+      mData.SetLength(oldLength + countRead);
+      aCount -= countRead;
+      *aBytesWritten += countRead;
+    }
+
+    *aBytesWritten -= originalLength;
+  }
+
+  // XXXkhuey queue flush.
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::AsyncWait(nsIInputStreamCallback* aCallback, uint32_t aFlags,
+                           uint32_t aRequestedCount, nsIEventTarget* aEventTarget)
+{
+  MOZ_ASSERT(IsReceiving());
+
+  nsCOMPtr<nsIEventTarget> currentThread = do_GetCurrentThread();
+  if (aEventTarget && currentThread != aEventTarget) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mOutputAsyncWaitCallback);
+  if (NS_WARN_IF(mInputAsyncWaitCallback)) {
+    MOZ_ASSERT(mResultCode == NS_OK); // We shouldn't be closed if we're waiting
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // WAIT_CLOSURE_ONLY is kind of silly.
+  if (aFlags & nsIAsyncInputStream::WAIT_CLOSURE_ONLY) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  MOZ_ASSERT(!aFlags);
+
+  // If aRequestedCount is 0, we're allowed to wait for any amount.  Let's pick 1.
+  if (aRequestedCount == 0) {
+    aRequestedCount = 1;
+  }
+
+  mRequestedAsyncWaitCount = aRequestedCount;
+
+  mInputAsyncWaitCallback =
+    NS_NewInputStreamReadyEvent(aCallback, currentThread);
+
+  if (!mIsTransportActive && !mClosed && !mInMainProcess) {
+    InitializeTransport();
+  }
+
+  MaybeFireCallbacks();
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+XPPActiveStream::AsyncWait(nsIOutputStreamCallback* aCallback, uint32_t aFlags,
+                           uint32_t aRequestedCount, nsIEventTarget* aEventTarget)
+{
+  MOZ_ASSERT(IsSending());
+
+  nsCOMPtr<nsIEventTarget> currentThread = do_GetCurrentThread();
+  if (aEventTarget && currentThread != aEventTarget) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mInputAsyncWaitCallback);
+  if (NS_WARN_IF(mOutputAsyncWaitCallback)) {
+    MOZ_ASSERT(mResultCode == NS_OK); // We shouldn't be closed if we're waiting
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  // WAIT_CLOSURE_ONLY is kind of silly.
+  if (aFlags & nsIAsyncOutputStream::WAIT_CLOSURE_ONLY) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  MOZ_ASSERT(!aFlags);
+
+  // If aRequestedCount is 0, we're allowed to wait for any amount.  Let's pick 1.
+  if (aRequestedCount == 0) {
+    aRequestedCount = 1;
+  }
+
+  mRequestedAsyncWaitCount = aRequestedCount;
+
+  mOutputAsyncWaitCallback =
+    NS_NewOutputStreamReadyEvent(aCallback, currentThread);
+
+  if (!mIsTransportActive && !mClosed && !mInMainProcess) {
+    InitializeTransport();
+  }
+
+  MaybeFireCallbacks();
+
+  return NS_OK;
+}
+
+void
+XPPActiveStream::ActorCreated(PBackgroundChild* aActor)
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(!mBackgroundChild);
+  MOZ_ASSERT(aActor);
+
+  mBackgroundChild = aActor;
+  IPDLConstruct(mBackgroundChild);
+}
+
+void
+XPPActiveStream::ActorFailed()
+{
+  AssertIsOnTransportThread();
+  MOZ_ASSERT(!mBackgroundChild);
+
+  MOZ_ASSERT_UNREACHABLE("");
+}
+
+nsresult
+XPPActiveStream::InitializeTransport()
+{
+  // The transport is always initialized in the child.
+  // XXXkhuey guard against one call while another is in flight!
+  MOZ_ASSERT(!mInMainProcess);
+  MOZ_ASSERT(!mIsTransportActive);
+
+  NoteTransportThread();
+
+  if (!mozilla::ipc::BackgroundChild::GetOrCreateForCurrentThread(this)) {
+    CloseWithStatus(NS_ERROR_FAILURE);
+    return NS_ERROR_FAILURE;
+  }
+    
+  return NS_OK;
+}
+
+bool
+XPPActiveStream::IPDLConstruct(PBackgroundChild* aActor)
+{
+  // Construction must always be initiated from the child.
+  MOZ_ASSERT(!mInMainProcess);
+  MOZ_ASSERT(mPipeId);
+
+  mozilla::MutexAutoLock lock(mLock);
+
+  MOZ_ASSERT(!mIsTransportActive);
+
+  // If this fails, we'll abort inside IPDL.
+  MOZ_ALWAYS_TRUE(aActor->SendPBackgroundPipeTransportConstructor(this,
+                                                                  mPipeId));
+
+  mIsTransportActive = true;
+  MaybeFireCallbacks();
+
+  return true;
+}
+
+void
+XPPActiveStream::MaybeFireCallbacks()
+{
+  mLock.AssertCurrentThreadOwns();
+
+  if (IsReceiving()) {
+    MOZ_ASSERT(!mOutputAsyncWaitCallback);
+    if (mInputAsyncWaitCallback && (mData.Length() >= mRequestedAsyncWaitCount ||
+                                    mClosed)) {
+      mInputAsyncWaitCallback->OnInputStreamReady(this);
+      mRequestedAsyncWaitCount = 0;
+      mInputAsyncWaitCallback = nullptr;
+    }
+  } else if (IsSending()) {
+    MOZ_ASSERT(!mInputAsyncWaitCallback);
+    if (mOutputAsyncWaitCallback && (mRequestedAsyncWaitCount == 0 ||
+                                     mIsTransportActive)) {
+      // The requested count is pointless for writing, since once the transport
+      // layer is active we can write as much as we want.
+      mOutputAsyncWaitCallback->OnOutputStreamReady(this);
+      mRequestedAsyncWaitCount = 0;
+      mOutputAsyncWaitCallback = nullptr;
+    }
+  } else {
+    MOZ_ASSERT_UNREACHABLE("");
+  }
+}
+
+/* static */
+already_AddRefed<XPPActiveStream>
+XPPActiveStream::GetOrCreateById(intptr_t aId, mozilla::ipc::PipeDirection aDirection)
+{
+  nsRefPtr<XPPActiveStream> stream;
+
+  mozilla::StaticMutexAutoLock lock(sInFlightMutex);
+
+  XPPStreamListComparator comparator;
+  // XXXkhuey dereferencing a null pointer here is crazy. fix before landing
+  size_t index = sInFlightList ? sInFlightList->IndexOf(aId, 0, comparator) : sInFlightList->NoIndex;
+  if (index == sInFlightList->NoIndex) {
+    // We didn't find it.  Go ahead and create it.
+    stream = new XPPActiveStream(aId, aDirection);
+    // The ctor will have created sInFlightList.
+    sInFlightList->AppendElement(stream);
+    return stream.forget();
+  }
+
+  stream = sInFlightList->ElementAt(index).forget();
+  sInFlightList->RemoveElementAt(index);
+  return stream.forget(); // XXXkhuey assert direction matches
+}
+
+NS_IMPL_ISUPPORTS(CrossProcessPipe, nsICrossProcessPipe)
+
+void
+CrossProcessPipe::InitializeStreams(PipeDirection aDirection)
+{
+  MOZ_ASSERT(!mInputStream && !mOutputStream);
+
+  if (aDirection == mozilla::ipc::Sending) {
+    // If we're sending, the output stream is "active" and the input stream is
+    // just a serialization placeholder
+    mInputStream = new SerializationPlaceholderStream(this);
+    intptr_t id = reinterpret_cast<intptr_t>(this);
+    // XXXkhuey assert created
+    mOutputStream = XPPActiveStream::GetOrCreateById(id, aDirection).downcast<nsIAsyncOutputStream>();
+  }
+  else {
+    MOZ_CRASH("Implement me!");
+  }
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::Init(bool aIsSending)
+{
+  if (mInputStream || mOutputStream) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  InitializeStreams(aIsSending ? mozilla::ipc::Sending
+                               : mozilla::ipc::Receiving);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::GetInputStream(nsIAsyncInputStream** aInputStream)
+{
+  if (!mInputStream) {
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+
+  nsCOMPtr<nsIAsyncInputStream> inputStream = mInputStream;
+  inputStream.forget(aInputStream);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+CrossProcessPipe::GetOutputStream(nsIAsyncOutputStream** aOutputStream)
+{
+  if (!mOutputStream) {
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+
+  nsCOMPtr<nsIAsyncOutputStream> outputStream = mOutputStream;
+  outputStream.forget(aOutputStream);
+
+  return NS_OK;
+}
+
+} // anonymous namespace
+
+namespace mozilla {
+namespace ipc {
+
+already_AddRefed<nsICrossProcessPipe>
+CreateCrossProcessPipe(PipeDirection aDirection)
+{
+  nsRefPtr<CrossProcessPipe> xpp = new CrossProcessPipe();
+  xpp->InitializeStreams(aDirection);
+  return xpp.forget();
+}
+
+namespace detail {
+
+nsresult
+XPCOMCreateCrossProcessPipe(nsISupports* aOuter,
+                            REFNSIID aIID,
+                            void** aOutparam)
+{
+  if (aOuter) {
+    return NS_ERROR_NO_AGGREGATION;
+  }
+
+  nsRefPtr<CrossProcessPipe> xpp = new CrossProcessPipe();
+  return xpp->QueryInterface(aIID, aOutparam);
+}
+
+PBackgroundPipeTransportParent*
+AllocPBackgroundPipeTransportParent(const intptr_t& aCookie)
+{
+  nsRefPtr<XPPActiveStream> stream = XPPActiveStream::GetOrCreateById(aCookie, mozilla::ipc::Receiving);
+
+  MOZ_ASSERT(stream->PipeId() == aCookie);
+  if (!stream->RecvIPDLConstructor()) {
+    return nullptr;
+  }
+
+  return stream.forget().take()->AsParent(); // Owned by IPDL now.
+}
+
+bool
+DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor)
+{
+  nsRefPtr<XPPActiveStream> stream =
+    dont_AddRef(XPPActiveStream::FromParent(aActor));
+
+  return true;
+}
+
+// The constructor only goes from child to parent, so we don't need an
+// AllocPBackgroundPipeTransportChild.
+
+bool
+DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor)
+{
+  return false;
+}
+
+already_AddRefed<nsIInputStream>
+PipeInputStreamForId(intptr_t aPipeId)
+{
+  return XPPActiveStream::GetOrCreateById(aPipeId, mozilla::ipc::Receiving).downcast<nsIInputStream>();
+}
+
+} // namespace detail
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/CrossProcessPipe.h b/ipc/glue/CrossProcessPipe.h
new file mode 100644
--- /dev/null
+++ b/ipc/glue/CrossProcessPipe.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsCOMPtr.h"
+#include "nsICrossProcessPipe.h"
+
+class nsIInputStream;
+
+namespace mozilla {
+namespace ipc {
+
+enum PipeDirection {
+  Sending,
+  Receiving
+};
+
+/**
+ * Create a new CrossProcessPipe.  This pipe provides input and output streams,
+ * and the input stream can be serialized across IPDL.  The init method should
+ * not be called (it is only for use when creating pipes via XPCOM).
+ */
+already_AddRefed<nsICrossProcessPipe>
+CreateCrossProcessPipe(PipeDirection aDirection);
+
+// Implementation details
+
+class PBackgroundPipeTransportParent;
+class PBackgroundPipeTransportChild;
+
+namespace detail {
+
+#define NS_CROSSPROCESSPIPE_CID \
+  { 0x072e39cd, 0x7dbb, 0x408f, \
+    { 0x83, 0x15, 0x4e, 0xf0, 0xbb, 0xba, 0x8a, 0x9d } }
+
+
+#define NS_CROSSPROCESSPIPE_CONTRACTID "@mozilla.org/crossprocesspipe;1"
+
+nsresult
+XPCOMCreateCrossProcessPipe(nsISupports* aOuter,
+                            REFNSIID aIID,
+                            void** aResult);
+
+PBackgroundPipeTransportParent*
+AllocPBackgroundPipeTransportParent(const intptr_t& aCookie);
+
+bool
+DeallocPBackgroundPipeTransportParent(PBackgroundPipeTransportParent* aActor);
+
+// The constructor only goes from child to parent, so we don't need an
+// AllocPBackgroundPipeTransportChild.
+
+bool
+DeallocPBackgroundPipeTransportChild(PBackgroundPipeTransportChild* aActor);
+
+already_AddRefed<nsIInputStream>
+PipeInputStreamForId(intptr_t aPipeId);
+
+} // namespace detail
+} // namespace ipc
+} // namspace mozilla
diff --git a/ipc/glue/InputStreamParams.ipdlh b/ipc/glue/InputStreamParams.ipdlh
--- a/ipc/glue/InputStreamParams.ipdlh
+++ b/ipc/glue/InputStreamParams.ipdlh
@@ -48,26 +48,34 @@ struct RemoteInputStreamParams
 // XXX This may only be used for same-process inter-thread communication! The
 //     value should be reinterpret_cast'd to nsIInputStream. It carries a
 //     reference.
 struct SameProcessInputStreamParams
 {
   intptr_t addRefedInputStream;
 };
 
+struct PipeInputStreamParams
+{
+  // This is a pointer to the pipe in the other process, but we only ever use it
+  // as an identifier so it's not dangerous.
+  intptr_t pipeId;
+};
+
 union InputStreamParams
 {
   StringInputStreamParams;
   FileInputStreamParams;
   PartialFileInputStreamParams;
   BufferedInputStreamParams;
   MIMEInputStreamParams;
   MultiplexInputStreamParams;
   RemoteInputStreamParams;
   SameProcessInputStreamParams;
+  PipeInputStreamParams;
 };
 
 union OptionalInputStreamParams
 {
   void_t;
   InputStreamParams;
 };
 
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -5,16 +5,17 @@
 #include "InputStreamUtils.h"
 
 #include "nsIIPCSerializableInputStream.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/ipc/BlobChild.h"
 #include "mozilla/dom/ipc/BlobParent.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
 #include "nsID.h"
 #include "nsIXULRuntime.h"
 #include "nsMIMEInputStream.h"
 #include "nsMultiplexInputStream.h"
 #include "nsNetCID.h"
 #include "nsStringStream.h"
@@ -134,16 +135,29 @@ DeserializeInputStream(const InputStream
 
       stream = dont_AddRef(
         reinterpret_cast<nsIInputStream*>(params.addRefedInputStream()));
       MOZ_ASSERT(stream);
 
       return stream.forget();
     }
 
+    case InputStreamParams::TPipeInputStreamParams: {
+      MOZ_ASSERT(aFileDescriptors.IsEmpty());
+
+      const PipeInputStreamParams& params =
+	aParams.get_PipeInputStreamParams();
+
+      nsCOMPtr<nsIInputStream> stream =
+        detail::PipeInputStreamForId(params.pipeId());
+      MOZ_ASSERT(stream);
+
+      return stream.forget();
+    }
+
     default:
       MOZ_ASSERT(false, "Unknown params!");
       return nullptr;
   }
 
   MOZ_ASSERT(serializable);
 
   if (!serializable->Deserialize(aParams, aFileDescriptors)) {
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -1,13 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PBackgroundIDBFactory;
+include protocol PBackgroundPipeTransport;
 include protocol PBackgroundTest;
 include protocol PBlob;
 include protocol PFileDescriptorSet;
 include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PMessagePort;
 
@@ -30,30 +31,35 @@ union OptionalWindowId
 } // namespace indexedDB
 } // namespace dom
 
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PBackgroundIDBFactory;
+  manages PBackgroundPipeTransport;
   manages PBackgroundTest;
   manages PBlob;
   manages PFileDescriptorSet;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PMessagePort;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   PBackgroundTest(nsCString testArg);
 
   PBackgroundIDBFactory(OptionalWindowId optionalWindowId);
 
+  // The cookie is used to match up the transport on the background thread and
+  // the serialized stream that might come over on the main thread.
+  PBackgroundPipeTransport(intptr_t aCookie);
+
   PCacheStorage(Namespace namespaceEnum, nsCString origin, nsCString baseDomain);
 
   PMessagePort();
 
 both:
   PBlob(BlobConstructorParams params);
 
   PFileDescriptorSet(FileDescriptor fd);
diff --git a/ipc/glue/PBackgroundPipeTransport.ipdl b/ipc/glue/PBackgroundPipeTransport.ipdl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/PBackgroundPipeTransport.ipdl
@@ -0,0 +1,27 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+namespace mozilla {
+namespace ipc {
+
+async protocol PBackgroundPipeTransport
+{
+  manager PBackground;
+
+both:
+  // PBackgroundPipeTransport is always constructed from the child process,
+  // but once that is complete all method calls initiate from the sending side.
+
+  // Deletion of the protocol signals the end of the stream, if data was ever
+  // sent, or the destruction of the sending side machinery, if it was not.
+  __delete__(nsresult rv);
+
+  // Send data through the pipe.
+  Chunk(uint8_t[] aData);
+};
+
+} // namespace ipc
+} // namespace mozilla
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -1,26 +1,33 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+XPIDL_SOURCES += [
+    'nsICrossProcessPipe.idl',
+]
+
+XPIDL_MODULE = 'ipc_glue'
+
 EXPORTS += [
     'nsIIPCBackgroundChildCreateCallback.h',
     'nsIIPCSerializableInputStream.h',
     'nsIIPCSerializableURI.h',
 ]
 
 EXPORTS.mozilla.ipc += [
     'BackgroundChild.h',
     'BackgroundParent.h',
     'BackgroundUtils.h',
     'BrowserProcessSubThread.h',
     'CrossProcessMutex.h',
+    'CrossProcessPipe.h',
     'FileDescriptor.h',
     'FileDescriptorSetChild.h',
     'FileDescriptorSetParent.h',
     'FileDescriptorUtils.h',
     'GeckoChildProcessHost.h',
     'InputStreamUtils.h',
     'IOThreadChild.h',
     'MessageChannel.h',
@@ -131,16 +138,17 @@ SOURCES += [
 
 LOCAL_INCLUDES += [
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
+    'PBackgroundPipeTransport.ipdl',
     'PBackgroundSharedTypes.ipdlh',
     'PBackgroundTest.ipdl',
     'PFileDescriptorSet.ipdl',
     'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
     'URIParams.ipdlh',
 ]
 
@@ -163,8 +171,14 @@ LOCAL_INCLUDES += [
 ]
 
 if CONFIG['OS_ARCH'] == 'WINNT':
     LOCAL_INCLUDES += [
         '/security/sandbox/win/src/sandboxbroker',
     ]
 
 FAIL_ON_WARNINGS = True
+
+XPCSHELL_TESTS_MANIFESTS += ['unit/xpcshell.ini']
+
+SOURCES += [
+    'CrossProcessPipe.cpp',
+]
diff --git a/ipc/glue/nsICrossProcessPipe.idl b/ipc/glue/nsICrossProcessPipe.idl
new file mode 100644
--- /dev/null
+++ b/ipc/glue/nsICrossProcessPipe.idl
@@ -0,0 +1,38 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+interface nsIAsyncInputStream;
+interface nsIAsyncOutputStream;
+
+/**
+ * Like nsIPipe, except with the ends in different processes.
+ */
+[builtinclass, scriptable, uuid(e63d5c58-5086-4a1c-8b97-980a05deeb8e)]
+interface nsICrossProcessPipe : nsISupports
+{
+    /**
+     * initialize this pipe
+     *
+     * @param sending
+     *        true if the pipe is sending (that is, the output stream will be
+     *        used in the this process and the input stream will be serialized),
+     *        false if the pipe is receiving.
+     */
+    void init(in boolean sending);
+
+    /**
+     * The pipe's input end.  If the pipe is sending this is only useful for
+     * serializing via IPDL.
+     */
+    readonly attribute nsIAsyncInputStream inputStream;
+
+    /**
+     * The pipe's output end.  If the pipe is receiving this is only useful for
+     * serializing via IPDL.
+     */
+    readonly attribute nsIAsyncOutputStream outputStream;
+};
diff --git a/ipc/glue/unit/test_crossProcessPipe.js b/ipc/glue/unit/test_crossProcessPipe.js
new file mode 100644
--- /dev/null
+++ b/ipc/glue/unit/test_crossProcessPipe.js
@@ -0,0 +1,233 @@
+const { 'classes': Cc, 'interfaces': Ci, 'results': Cr, 'utils': Cu } = Components;
+
+Cu.import("resource://gre/modules/NetUtil.jsm");
+
+const gIsInChild = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime)
+                     .processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;
+
+let mm = gIsInChild ?
+              Cc["@mozilla.org/childprocessmessagemanager;1"].getService(Ci.nsIMessageSender) :
+              Cc["@mozilla.org/parentprocessmessagemanager;1"].getService(Ci.nsIMessageListenerManager);
+
+function newXPP() {
+  return Cc["@mozilla.org/crossprocesspipe;1"].createInstance(Ci.nsICrossProcessPipe);
+}
+
+function initializeChild(callback) {
+  let file = do_get_file("test_crossProcessPipe.js");
+  mm.addMessageListener("XPPINIT", function thunk(message) {
+    // Replace mm with the correct process message manager
+    mm.removeMessageListener("XPPINIT", thunk);
+    mm = message.target.QueryInterface(Ci.nsIMessageSender);
+    addListener();
+    do_execute_soon(callback);
+  });
+  do_load_child_test_harness();
+  sendCommand("load(\"" + file.path.replace(/\\/g, "/") + "\"); run_test();");
+}
+
+function addListener() {
+  Assert.ok(mm instanceof Ci.nsIMessageSender);
+  mm.addMessageListener("XPPTEST", function(message) {
+    let retval;
+
+    if (test) {
+      retval = test.next(message.data).value;
+    } else if (receiver) {
+      retval = receiver.next(message.data).value;
+    } else {
+      do_check_true(false);
+    }
+
+    if (retval) {
+      sendMessage(retval);
+    }
+  });
+
+  mm.addMessageListener("XPPCONTINUE", continueTest);
+}
+
+function sendMessage(message) {
+  mm.sendAsyncMessage("XPPTEST", message);
+}
+
+function continueTest() {
+  if (gIsInChild) {
+    mm.sendAsyncMessage("XPPCONTINUE", null);
+    return;
+  }
+
+  test_runner.next();
+}
+
+function getStreamAndContinue(thing) {
+  return function(object) { thing.next(object); };
+}
+
+function getDataAndContinue(thing) {
+  return function(stream, resultCode) {
+      let data = NetUtil.readInputStreamToString(stream, stream.available());
+      thing.next(data);
+    };
+}
+
+let test;
+let receiver;
+
+// Make sure the basics work.
+function* test0() {
+  let ipc = ipcTest();
+  Assert.ok(ipc instanceof Ci.nsITestShellTest);
+
+  let XPP = newXPP();
+  Assert.notEqual(XPP, null);
+  Assert.ok(XPP instanceof Ci.nsICrossProcessPipe);
+  Assert.throws(function() { XPP.inputStream; }, "NS_ERROR_NOT_INITIALIZED");
+  Assert.throws(function() { XPP.outputStream; }, "NS_ERROR_NOT_INITIALIZED");
+  Assert.notEqual(XPP.init, undefined);
+
+  XPP.init(true);
+  Assert.ok(XPP.inputStream instanceof Ci.nsIAsyncInputStream);
+  Assert.ok(XPP.outputStream instanceof Ci.nsIAsyncOutputStream);
+
+  sendMessage("ohai");
+  let response = yield;
+  Assert.equal(response, "obai");
+
+  continueTest();
+}
+
+function* recv0() {
+  let response = yield;
+  Assert.equal(response, "ohai");
+  yield "obai";
+}
+
+// Test sending data
+function* test1() {
+  const data = "ohai";
+
+  let XPP = newXPP();
+  XPP.init(true);
+
+  let inputStream = XPP.inputStream;
+  let outputStream = XPP.outputStream;
+
+  Assert.throws(function() { outputStream.write(data, data.length); }, "NS_ERROR_BASE_STREAM_WOULD_BLOCK");
+
+  outputStream.asyncWait(getStreamAndContinue(test), 0, 0, null);
+
+  let ipc = ipcTest();
+  ipc.sendInputStream(inputStream);
+
+  let readyStream = yield;
+  Assert.equal(readyStream, outputStream);
+
+  outputStream.write(data, data.length);
+  outputStream.close();
+
+  let dataReceived = yield;
+  Assert.equal(data, dataReceived);
+
+  continueTest();
+}
+
+function* recv1() {
+  let ipc = ipcTest();
+  ipc.onInputStreamReceived = getStreamAndContinue(receiver);
+
+  let inputStream = yield;
+  Assert.ok(inputStream instanceof Ci.nsIAsyncInputStream);
+
+  Assert.equal(inputStream.isNonBlocking(), true);
+
+  NetUtil.asyncFetch(inputStream, getDataAndContinue(receiver))
+
+  let data = yield;
+  sendMessage(data);
+}
+
+// Test the result code
+function* test2() {
+  let XPP = newXPP();
+  XPP.init(true);
+
+  let inputStream = XPP.inputStream;
+  let outputStream = XPP.outputStream;
+
+  outputStream.asyncWait(getStreamAndContinue(test), 0, 0, null);
+
+  let ipc = ipcTest();
+  ipc.sendInputStream(inputStream);
+
+  yield;
+
+  // Pick a strange result code so it won't show up naturally.
+  outputStream.closeWithStatus(Cr.NS_ERROR_FILE_TOO_BIG);
+
+  let statusReceived = yield;
+  Assert.equal(statusReceived, Cr.NS_ERROR_FILE_TOO_BIG);
+
+  continueTest();
+};
+
+function* recv2() {
+  let ipc = ipcTest();
+  ipc.onInputStreamReceived = getStreamAndContinue(receiver);
+
+  let inputStream = yield;
+
+  NetUtil.asyncFetch(inputStream, function (stream, resultCode) {
+    receiver.next(resultCode);
+  })
+
+  let exception = yield;
+  sendMessage(exception);
+}
+
+const tests = [
+  [test0, recv0],
+  [test1, recv1],
+  [test2, recv2],
+];
+
+function* run_all_tests() {
+  equal(gIsInChild, false);
+
+  // Synchronize tests.  testN and recvN will be run simultaneously in the
+  // parent and child, and then in the child and parent, respectively.
+  for (let i = 0; i < tests.length; i++) {
+    sendCommand("test = null; receiver = tests[" + i + "][1](); receiver.next();", function() { test.next(); });
+    test = tests[i][0]();
+    receiver = null;
+
+    yield;
+
+    sendCommand("receiver = null; test = tests[" + i + "][0](); test.next();");
+    receiver = tests[i][1]();
+    receiver.next(); // NB: We initialize the receiver immediately, only the test has to wait.
+    test = null;
+
+    yield;
+  }
+
+  do_test_finished();
+}
+
+let test_runner;
+
+function run_test() {
+  if (!gIsInChild) {
+    do_test_pending();
+    initializeChild(function() { test_runner = run_all_tests(); test_runner.next(); });
+  } else {
+    addListener();
+
+    // Set up the IPC testing protocol
+    ipcTest();
+
+    // Nothing else to do, parent drives.
+    mm.sendAsyncMessage("XPPINIT", "Hello");
+  }
+}
+
diff --git a/ipc/glue/unit/xpcshell.ini b/ipc/glue/unit/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/ipc/glue/unit/xpcshell.ini
@@ -0,0 +1,5 @@
+[DEFAULT]
+head = 
+tail = 
+
+[test_crossProcessPipe.js]
diff --git a/ipc/testshell/PTestShell.ipdl b/ipc/testshell/PTestShell.ipdl
--- a/ipc/testshell/PTestShell.ipdl
+++ b/ipc/testshell/PTestShell.ipdl
@@ -1,24 +1,29 @@
 /* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include protocol PContent;
 include protocol PTestShellCommand;
+include protocol PTestShellTest;
 
 namespace mozilla {
 namespace ipc {
 
 async protocol PTestShell
 {
   manager PContent;
 
   manages PTestShellCommand;
+  manages PTestShellTest;
+
+parent:
+  PTestShellTest();
 
 child:
   __delete__();
 
   ExecuteCommand(nsString aCommand);
 
   PTestShellCommand(nsString aCommand);
 };
diff --git a/ipc/testshell/PTestShell.ipdl b/ipc/testshell/PTestShellTest.ipdl
copy from ipc/testshell/PTestShell.ipdl
copy to ipc/testshell/PTestShellTest.ipdl
--- a/ipc/testshell/PTestShell.ipdl
+++ b/ipc/testshell/PTestShellTest.ipdl
@@ -1,27 +1,26 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-include protocol PContent;
-include protocol PTestShellCommand;
+include protocol PTestShell;
+include protocol PFileDescriptorSet;
+
+include InputStreamParams;
 
 namespace mozilla {
 namespace ipc {
 
-async protocol PTestShell
+// An object for random test methods.
+async protocol PTestShellTest
 {
-  manager PContent;
-
-  manages PTestShellCommand;
+  manager PTestShell;
 
 child:
   __delete__();
 
-  ExecuteCommand(nsString aCommand);
-
-  PTestShellCommand(nsString aCommand);
+both:
+  InputStream(InputStreamParams params, OptionalFileDescriptorSet fds);
 };
 
 } // namespace ipc
 } // namespace mozilla
diff --git a/ipc/testshell/TestShellChild.cpp b/ipc/testshell/TestShellChild.cpp
--- a/ipc/testshell/TestShellChild.cpp
+++ b/ipc/testshell/TestShellChild.cpp
@@ -3,19 +3,24 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "TestShellChild.h"
 
 using mozilla::ipc::TestShellChild;
 using mozilla::ipc::PTestShellCommandChild;
 using mozilla::ipc::XPCShellEnvironment;
 
+/* static */
+TestShellChild* TestShellChild::sSingleton;
+
 TestShellChild::TestShellChild()
 : mXPCShell(XPCShellEnvironment::CreateEnvironment())
 {
+  MOZ_ASSERT(!sSingleton);
+  sSingleton = this;
 }
 
 bool
 TestShellChild::RecvExecuteCommand(const nsString& aCommand)
 {
   if (mXPCShell->IsQuitting()) {
     NS_WARNING("Commands sent after quit command issued!");
     return false;
@@ -49,8 +54,13 @@ TestShellChild::RecvPTestShellCommandCon
   nsString response;
   if (!mXPCShell->EvaluateString(aCommand, &response)) {
     return false;
   }
 
   return PTestShellCommandChild::Send__delete__(aActor, response);
 }
 
+/* static */ TestShellChild*
+TestShellChild::Get()
+{
+  return sSingleton;
+}
diff --git a/ipc/testshell/TestShellChild.h b/ipc/testshell/TestShellChild.h
--- a/ipc/testshell/TestShellChild.h
+++ b/ipc/testshell/TestShellChild.h
@@ -2,43 +2,58 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef ipc_testshell_TestShellChild_h
 #define ipc_testshell_TestShellChild_h 1
 
 #include "mozilla/ipc/PTestShellChild.h"
 #include "mozilla/ipc/PTestShellCommandChild.h"
+#include "mozilla/ipc/PTestShellTestParent.h"
 #include "mozilla/ipc/XPCShellEnvironment.h"
 
 #include "nsAutoPtr.h"
 
+class nsITestShellTest;
+
 namespace mozilla {
 
 namespace ipc {
 
 class XPCShellEnvironment;
 
 class TestShellChild : public PTestShellChild
 {
+  static TestShellChild* sSingleton;
+
 public:
   TestShellChild();
 
-  bool
-  RecvExecuteCommand(const nsString& aCommand);
+  virtual bool
+  RecvExecuteCommand(const nsString& aCommand) MOZ_OVERRIDE;
 
-  PTestShellCommandChild*
-  AllocPTestShellCommandChild(const nsString& aCommand);
+  virtual PTestShellCommandChild*
+  AllocPTestShellCommandChild(const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
+  virtual bool
   RecvPTestShellCommandConstructor(PTestShellCommandChild* aActor,
-                                   const nsString& aCommand);
+                                   const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
-  DeallocPTestShellCommandChild(PTestShellCommandChild* aCommand);
+  virtual bool
+  DeallocPTestShellCommandChild(PTestShellCommandChild* aCommand) MOZ_OVERRIDE;
+
+  virtual PTestShellTestChild*
+  AllocPTestShellTestChild() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPTestShellTestChild(PTestShellTestChild* aTest) MOZ_OVERRIDE;
+
+  nsITestShellTest* GetOrCreateTestObject();
+
+  static TestShellChild* Get();
 
 private:
   nsAutoPtr<XPCShellEnvironment> mXPCShell;
 };
 
 } /* namespace ipc */
 } /* namespace mozilla */
 
diff --git a/ipc/testshell/TestShellParent.cpp b/ipc/testshell/TestShellParent.cpp
--- a/ipc/testshell/TestShellParent.cpp
+++ b/ipc/testshell/TestShellParent.cpp
@@ -15,16 +15,25 @@
 #include "xpcpublic.h"
 
 using namespace mozilla;
 using mozilla::ipc::TestShellParent;
 using mozilla::ipc::TestShellCommandParent;
 using mozilla::ipc::PTestShellCommandParent;
 using mozilla::dom::ContentParent;
 
+/* static */
+TestShellParent* TestShellParent::sSingleton;
+
+TestShellParent::TestShellParent()
+{
+  MOZ_ASSERT(!sSingleton);
+  sSingleton = this;
+}
+
 void
 TestShellParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   // Implement me! Bug 1005177
 }
 
 PTestShellCommandParent*
 TestShellParent::AllocPTestShellCommandParent(const nsString& aCommand)
@@ -45,16 +54,22 @@ TestShellParent::CommandDone(TestShellCo
 {
   // XXX what should happen if the callback fails?
   /*bool ok = */command->RunCallback(aResponse);
   command->ReleaseCallback();
 
   return true;
 }
 
+/* static */ TestShellParent*
+TestShellParent::Get()
+{
+  return sSingleton;
+}
+
 bool
 TestShellCommandParent::SetCallback(JSContext* aCx,
                                     JS::Value aCallback)
 {
   if (!mCallback.Hold(aCx)) {
     return false;
   }
 
diff --git a/ipc/testshell/TestShellParent.h b/ipc/testshell/TestShellParent.h
--- a/ipc/testshell/TestShellParent.h
+++ b/ipc/testshell/TestShellParent.h
@@ -5,40 +5,57 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef ipc_testshell_TestShellParent_h
 #define ipc_testshell_TestShellParent_h 1
 
 #include "mozilla/ipc/PTestShellParent.h"
 #include "mozilla/ipc/PTestShellCommandParent.h"
+#include "mozilla/ipc/PTestShellTest.h"
 
 #include "js/TypeDecls.h"
 #include "nsAutoJSValHolder.h"
 #include "nsString.h"
 
+class nsITestShellTest;
+
 namespace mozilla {
 
 namespace ipc {
 
 class TestShellCommandParent;
 
 class TestShellParent : public PTestShellParent
 {
+  static TestShellParent* sSingleton;
+
 public:
+  TestShellParent();
+
   virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE;
 
-  PTestShellCommandParent*
-  AllocPTestShellCommandParent(const nsString& aCommand);
+  virtual PTestShellCommandParent*
+  AllocPTestShellCommandParent(const nsString& aCommand) MOZ_OVERRIDE;
 
-  bool
-  DeallocPTestShellCommandParent(PTestShellCommandParent* aActor);
+  virtual bool
+  DeallocPTestShellCommandParent(PTestShellCommandParent* aActor) MOZ_OVERRIDE;
+
+  virtual PTestShellTestParent*
+  AllocPTestShellTestParent() MOZ_OVERRIDE;
+
+  virtual bool
+  DeallocPTestShellTestParent(PTestShellTestParent* aTest) MOZ_OVERRIDE;
 
   bool
   CommandDone(TestShellCommandParent* aActor, const nsString& aResponse);
+
+  nsITestShellTest* GetTestObject();
+
+  static TestShellParent* Get();
 };
 
 
 class TestShellCommandParent : public PTestShellCommandParent
 {
 public:
   TestShellCommandParent() {}
 
diff --git a/ipc/testshell/TestShellTest.cpp b/ipc/testshell/TestShellTest.cpp
new file mode 100644
--- /dev/null
+++ b/ipc/testshell/TestShellTest.cpp
@@ -0,0 +1,220 @@
+#include "nsITestShellTest.h"
+#include "mozilla/ipc/PTestShellTestParent.h"
+#include "mozilla/ipc/PTestShellTestChild.h"
+#include "TestShellParent.h"
+#include "TestShellChild.h"
+
+#include "nsIAsyncInputStream.h"
+#include "nsIAsyncOutputStream.h"
+#include "nsISupportsImpl.h"
+
+#include "nsCOMPtr.h"
+#include "mozilla/ipc/InputStreamUtils.h"
+
+namespace mozilla {
+namespace ipc {
+
+template <class Derived>
+class TestShellTest : public nsITestShellTest
+{
+  nsCOMPtr<nsIInputStreamCallback> mInputStreamCb;
+  nsCOMPtr<nsIOutputStreamCallback> mOutputStreamCb;
+
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSITESTSHELLTEST
+
+  Derived*
+  AsDerived() const
+  {
+    return static_cast<Derived*>(const_cast<TestShellTest*>(this));
+  }
+
+protected:
+  bool RecvInputStream(const InputStreamParams& aParams,
+		       const OptionalFileDescriptorSet& aFds);
+};
+
+template <class Derived>
+NS_IMPL_ADDREF(TestShellTest<Derived>)
+
+template <class Derived>
+NS_IMPL_RELEASE(TestShellTest<Derived>)
+
+template <class Derived>
+NS_INTERFACE_MAP_BEGIN(TestShellTest<Derived>)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsITestShellTest)
+NS_INTERFACE_MAP_END
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::GetOnInputStreamReceived(nsIInputStreamCallback** aCb)
+{
+  NS_IF_ADDREF(*aCb = mInputStreamCb);
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SetOnInputStreamReceived(nsIInputStreamCallback* aCb)
+{
+  mInputStreamCb = aCb;
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::GetOnOutputStreamReceived(nsIOutputStreamCallback** aCb)
+{
+  NS_IF_ADDREF(*aCb = mOutputStreamCb);
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SetOnOutputStreamReceived(nsIOutputStreamCallback* aCb)
+{
+  mOutputStreamCb = aCb;
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SendInputStream(nsIInputStream* aInputStream)
+{
+  InputStreamParams params;
+  nsTArray<FileDescriptor> fds;
+
+  SerializeInputStream(aInputStream, params, fds);
+
+  MOZ_RELEASE_ASSERT(fds.Length() == 0); // Not supported yet!
+
+  if (!AsDerived()->Derived::Protocol::SendInputStream(params, void_t())) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+template <class Derived>
+NS_IMETHODIMP
+TestShellTest<Derived>::SendOutputStream(nsIOutputStream* aOutputStream)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+template <class Derived>
+bool
+TestShellTest<Derived>::RecvInputStream(const InputStreamParams& aParams,
+					const OptionalFileDescriptorSet& aFds)
+{
+  nsTArray<FileDescriptor> fds;
+  nsCOMPtr<nsIInputStream> stream = DeserializeInputStream(aParams, fds);
+  nsCOMPtr<nsIAsyncInputStream> asyncStream = do_QueryInterface(stream);
+
+  if (mInputStreamCb) {
+    mInputStreamCb->OnInputStreamReady(asyncStream);
+  }
+
+  return true;
+}
+
+class TestShellTestParent : public TestShellTest<TestShellTestParent>,
+			    public PTestShellTestParent
+{
+public:
+  typedef TestShellTest<TestShellTestParent> Base;
+  typedef PTestShellTestParent Protocol;
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
+  { }
+
+  virtual bool RecvInputStream(const InputStreamParams& aParams,
+			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
+  {
+    return Base::RecvInputStream(aParams, aFds);
+  }
+};
+
+class TestShellTestChild : public TestShellTest<TestShellTestChild>,
+			   public PTestShellTestChild
+{
+public:
+  typedef TestShellTest<TestShellTestChild> Base;
+  typedef PTestShellTestChild Protocol;
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) MOZ_OVERRIDE
+  { }
+
+  virtual bool RecvInputStream(const InputStreamParams& aParams,
+			       const OptionalFileDescriptorSet& aFds) MOZ_OVERRIDE
+  {
+    return Base::RecvInputStream(aParams, aFds);
+  }
+};
+
+template class TestShellTest<TestShellTestParent>;
+template class TestShellTest<TestShellTestChild>;
+
+PTestShellTestParent*
+TestShellParent::AllocPTestShellTestParent()
+{
+  nsRefPtr<TestShellTestParent> test = new TestShellTestParent();
+  return test.forget().take(); // The reference is held by IPDL.
+}
+
+bool
+TestShellParent::DeallocPTestShellTestParent(PTestShellTestParent* aTest)
+{
+  nsRefPtr<TestShellTestParent> test =
+    dont_AddRef(static_cast<TestShellTestParent*>(aTest));
+  return true;
+}
+
+nsITestShellTest*
+TestShellParent::GetTestObject()
+{
+  auto& tests = ManagedPTestShellTestParent();
+  MOZ_ASSERT(tests.Length() <= 1);
+
+  if (tests.Length() == 0) {
+    return nullptr;
+  }
+
+  return static_cast<TestShellTestParent*>(tests[0]);
+}
+
+PTestShellTestChild*
+TestShellChild::AllocPTestShellTestChild()
+{
+  MOZ_ASSERT_UNREACHABLE("Should be allocated elsewhere!");
+  return nullptr;
+}
+
+bool
+TestShellChild::DeallocPTestShellTestChild(PTestShellTestChild* aTest)
+{
+  nsRefPtr<TestShellTestChild> test =
+    dont_AddRef(static_cast<TestShellTestChild*>(aTest));
+  return true;
+}
+
+nsITestShellTest*
+TestShellChild::GetOrCreateTestObject()
+{
+  auto& tests = ManagedPTestShellTestChild();
+  MOZ_ASSERT(tests.Length() <= 1);
+
+  if (tests.Length() == 0) {
+    nsRefPtr<TestShellTestChild> test = new TestShellTestChild();
+    SendPTestShellTestConstructor(test);
+    return test.forget().take(); // This reference belongs to IPDL,
+                                 // not the caller.
+  }
+
+  return static_cast<TestShellTestChild*>(tests[0]);
+}
+
+}
+}
diff --git a/ipc/testshell/XPCShellEnvironment.cpp b/ipc/testshell/XPCShellEnvironment.cpp
--- a/ipc/testshell/XPCShellEnvironment.cpp
+++ b/ipc/testshell/XPCShellEnvironment.cpp
@@ -35,21 +35,20 @@
 #include "nsJSUtils.h"
 #include "nsJSPrincipals.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 
 #include "BackstagePass.h"
 
 #include "TestShellChild.h"
-#include "TestShellParent.h"
+#include "nsITestShellTest.h"
 
 using mozilla::ipc::XPCShellEnvironment;
 using mozilla::ipc::TestShellChild;
-using mozilla::ipc::TestShellParent;
 using mozilla::AutoSafeJSContext;
 using namespace JS;
 
 namespace {
 
 static const char kDefaultRuntimeScriptFilename[] = "xpcshell.js";
 
 class XPCShellDirProvider : public nsIDirectoryServiceProvider
@@ -259,29 +258,57 @@ GCZeal(JSContext *cx, unsigned argc, JS:
   if (!ToUint32(cx, args.get(0), &zeal))
     return false;
 
   JS_SetGCZeal(cx, uint8_t(zeal), JS_DEFAULT_ZEAL_FREQ);
   return true;
 }
 #endif
 
+static bool
+IpcTest(JSContext *cx, unsigned argc, JS::Value *vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    nsCOMPtr<nsITestShellTest> test;
+    MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Content);
+
+    TestShellChild* tsc = TestShellChild::Get();
+    test = tsc->GetOrCreateTestObject();
+
+    if (test) {
+        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
+        nsCOMPtr<nsIXPConnectJSObjectHolder> wrappedNative;
+        xpc->WrapNative(cx, JS_THIS_OBJECT(cx, vp), test,
+                        NS_GET_IID(nsITestShellTest),
+                        getter_AddRefs(wrappedNative));
+        
+        args.rval().set(OBJECT_TO_JSVAL(wrappedNative->GetJSObject()));
+    }
+    else {
+        args.rval().setUndefined();
+    }
+
+    return true;
+}
+
 const JSFunctionSpec gGlobalFunctions[] =
 {
     JS_FS("print",           Print,          0,0),
     JS_FS("load",            Load,           1,0),
     JS_FS("quit",            Quit,           0,0),
     JS_FS("version",         Version,        1,0),
     JS_FS("build",           BuildDate,      0,0),
     JS_FS("dumpXPC",         DumpXPC,        1,0),
     JS_FS("dump",            Dump,           1,0),
     JS_FS("gc",              GC,             0,0),
  #ifdef JS_GC_ZEAL
     JS_FS("gczeal",          GCZeal,         1,0),
  #endif
+    JS_FS("ipcTest",         IpcTest,        0,0),
     JS_FS_END
 };
 
 typedef enum JSShellErrNum
 {
 #define MSG_DEF(name, number, count, exception, format) \
     name = number,
 #include "jsshell.msg"
diff --git a/ipc/testshell/moz.build b/ipc/testshell/moz.build
--- a/ipc/testshell/moz.build
+++ b/ipc/testshell/moz.build
@@ -1,33 +1,41 @@
 # -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+XPIDL_MODULE = 'testshell'
+
+XPIDL_SOURCES += [
+    'nsITestShellTest.idl',
+]
+
 EXPORTS.mozilla.ipc += [
     'TestShellChild.h',
     'TestShellParent.h',
     'XPCShellEnvironment.h',
 ]
 
 # FIXME/bug 575918: out-of-process xpcshell is broken on OS X
 if CONFIG['OS_ARCH'] != 'Darwin':
     XPCSHELL_TESTS_MANIFESTS += ['tests/xpcshell.ini']
 
 SOURCES += [
     'TestShellChild.cpp',
     'TestShellParent.cpp',
+    'TestShellTest.cpp',
     'XPCShellEnvironment.cpp',
 ]
 
 IPDL_SOURCES = [
     'PTestShell.ipdl',
     'PTestShellCommand.ipdl',
+    'PTestShellTest.ipdl',
 ]
 
 FAIL_ON_WARNINGS = True
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
 
diff --git a/ipc/testshell/nsITestShellTest.idl b/ipc/testshell/nsITestShellTest.idl
new file mode 100644
--- /dev/null
+++ b/ipc/testshell/nsITestShellTest.idl
@@ -0,0 +1,20 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+interface nsIInputStream;
+interface nsIInputStreamCallback;
+interface nsIOutputStream;
+interface nsIOutputStreamCallback;
+
+[scriptable, builtinclass, uuid(ef3342e4-7f63-4403-bed4-0b4a95bc0a2a)]
+interface nsITestShellTest : nsISupports
+{
+  attribute nsIInputStreamCallback onInputStreamReceived;
+  attribute nsIOutputStreamCallback onOutputStreamReceived;
+
+  void sendInputStream(in nsIInputStream aInputStream);
+  void sendOutputStream(in nsIOutputStream aOutputStream);
+};
diff --git a/ipc/testshell/tests/test_ipcshell.js b/ipc/testshell/tests/test_ipcshell.js
--- a/ipc/testshell/tests/test_ipcshell.js
+++ b/ipc/testshell/tests/test_ipcshell.js
@@ -18,11 +18,19 @@ function run_test() {
       var cmp = pair[0].localeCompare(pair[1]);
       sendCommand(
           "'"+ pair[0] +"'.localeCompare('"+ pair[1] +"');",
           function (result) {
               do_check_eq(cmp, result);
               do_test_finished(); 
           });
     })
+
+  do_test_pending();
+  sendCommand("ipcTest",
+    function(result) {
+      do_check_neq(result, undefined);
+      do_check_neq(ipcTest, undefined);
+      do_test_finished();
+    });
 }
 load('test_ipcshell_child.js');
 
diff --git a/ipc/testshell/tests/test_ipcshell_child.js b/ipc/testshell/tests/test_ipcshell_child.js
--- a/ipc/testshell/tests/test_ipcshell_child.js
+++ b/ipc/testshell/tests/test_ipcshell_child.js
@@ -1,9 +1,10 @@
-const Cc = Components.classes;
-const Ci = Components.interfaces;
+const Cc = Components.classes;
+const Ci = Components.interfaces;
 
 const runtime = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime);
 
-if (typeof(run_test) == "undefined") {
+if (typeof(run_test) == "undefined") {
   run_test = function() {
-    do_check_eq(runtime.processType, Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT);
-  }}
+    do_check_eq(runtime.processType, Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT);
+  }
+}
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -26,16 +26,19 @@
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
 #include "nsJSPrincipals.h"
 #include "xpcpublic.h"
 #include "BackstagePass.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIPrincipal.h"
 #include "nsJSUtils.h"
+#include "nsITestShellTest.h"
+#include "mozilla/ipc/TestShellParent.h"
+#include "mozilla/ipc/TestShellChild.h"
 
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #ifdef XP_WIN
 #include <windows.h>
 #endif
@@ -51,16 +54,17 @@
 #endif
 
 #ifdef MOZ_CRASHREPORTER
 #include "nsExceptionHandler.h"
 #include "nsICrashReporter.h"
 #endif
 
 using namespace mozilla;
+using namespace mozilla::ipc;
 using namespace JS;
 
 class XPCShellDirProvider : public nsIDirectoryServiceProvider2
 {
 public:
     NS_DECL_ISUPPORTS_INHERITED
     NS_DECL_NSIDIRECTORYSERVICEPROVIDER
     NS_DECL_NSIDIRECTORYSERVICEPROVIDER2
@@ -462,16 +466,47 @@ SendCommand(JSContext *cx, unsigned argc
         return false;
     }
 
     args.rval().setUndefined();
     return true;
 }
 
 static bool
+IpcTest(JSContext *cx, unsigned argc, JS::Value *vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    nsCOMPtr<nsITestShellTest> test;
+    if (XRE_GetProcessType() == GeckoProcessType_Default) {
+        TestShellParent* tsp = TestShellParent::Get();
+	test = tsp->GetTestObject();
+    }
+    else {
+        TestShellChild* tsc = TestShellChild::Get();
+	test = tsc->GetOrCreateTestObject();
+    }
+
+    if (test) {
+        nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID());
+        nsCOMPtr<nsIXPConnectJSObjectHolder> wrappedNative;
+        xpc->WrapNative(cx, JS_THIS_OBJECT(cx, vp), test,
+                        NS_GET_IID(nsITestShellTest),
+                        getter_AddRefs(wrappedNative));
+        
+        args.rval().set(OBJECT_TO_JSVAL(wrappedNative->GetJSObject()));
+    }
+    else {
+        args.rval().setUndefined();
+    }
+
+    return true;
+}
+
+static bool
 Options(JSContext *cx, unsigned argc, jsval *vp)
 {
     JS::CallArgs args = CallArgsFromVp(argc, vp);
     RuntimeOptions oldRuntimeOptions = RuntimeOptionsRef(cx);
 
     for (unsigned i = 0; i < args.length(); ++i) {
         JSString *str = ToString(cx, args[i]);
         if (!str)
@@ -644,16 +679,17 @@ static const JSFunctionSpec glob_functio
     JS_FS("dump",            Dump,           1,0),
     JS_FS("gc",              GC,             0,0),
 #ifdef JS_GC_ZEAL
     JS_FS("gczeal",          GCZeal,         1,0),
 #endif
     JS_FS("options",         Options,        0,0),
     JS_FN("parent",          Parent,         1,0),
     JS_FS("sendCommand",     SendCommand,    1,0),
+    JS_FS("ipcTest",         IpcTest,        0,0),
     JS_FS("atob",            Atob,           1,0),
     JS_FS("btoa",            Btoa,           1,0),
     JS_FS("setInterruptCallback", SetInterruptCallback, 1,0),
     JS_FS("simulateActivityCallback", SimulateActivityCallback, 1,0),
     JS_FS_END
 };
 
 static bool
diff --git a/xpcom/base/nsError.h b/xpcom/base/nsError.h
--- a/xpcom/base/nsError.h
+++ b/xpcom/base/nsError.h
@@ -170,38 +170,46 @@
   #include "ErrorListCDefines.h"
 #endif
 
 #undef SUCCESS_OR_FAILURE
 #undef SUCCESS
 #undef FAILURE
 
 /**
+ * mozilla/Assertions.h includes nsTraceRefcnt.h, which expects to be able to
+ * use nsresult, so we have to include it after defining nsresult.
+ */
+#include "mozilla/Assertions.h"
+
+/**
  * @name Standard Error Handling Macros
  * @return 0 or 1 (false/true with bool type for C++)
  */
 
 #ifdef __cplusplus
 inline uint32_t
 NS_FAILED_impl(nsresult aErr)
 {
   return static_cast<uint32_t>(aErr) & 0x80000000;
 }
 #define NS_FAILED(_nsresult)    ((bool)MOZ_UNLIKELY(NS_FAILED_impl(_nsresult)))
 #define NS_SUCCEEDED(_nsresult) ((bool)MOZ_LIKELY(!NS_FAILED_impl(_nsresult)))
+#define MOZ_ALWAYS_SUCCEEDS(_nsresult) MOZ_ALWAYS_TRUE(NS_SUCCEEDED(_nsresult))
 
 /* Check that our enum type is actually uint32_t as expected */
 static_assert(((nsresult)0) < ((nsresult)-1),
               "nsresult must be an unsigned type");
 static_assert(sizeof(nsresult) == sizeof(uint32_t),
               "nsresult must be 32 bits");
 #else
 #define NS_FAILED_impl(_nsresult) ((_nsresult) & 0x80000000)
 #define NS_FAILED(_nsresult)    (MOZ_UNLIKELY(NS_FAILED_impl(_nsresult)))
 #define NS_SUCCEEDED(_nsresult) (MOZ_LIKELY(!NS_FAILED_impl(_nsresult)))
+#define MOZ_ALWAYS_SUCCEEDS(_nsresult) MOZ_ALWAYS_TRUE(NS_SUCCEEDED(_nsresult))
 #endif
 
 /**
  * @name Standard Error Generating Macros
  */
 
 #define NS_ERROR_GENERATE(sev, module, code) \
   (nsresult)(((uint32_t)(sev) << 31) | \
diff --git a/xpcom/build/XPCOMInit.cpp b/xpcom/build/XPCOMInit.cpp
--- a/xpcom/build/XPCOMInit.cpp
+++ b/xpcom/build/XPCOMInit.cpp
@@ -25,16 +25,17 @@
 #include "nsObserverList.h"
 #include "nsObserverService.h"
 #include "nsProperties.h"
 #include "nsPersistentProperties.h"
 #include "nsScriptableInputStream.h"
 #include "nsBinaryStream.h"
 #include "nsStorageStream.h"
 #include "nsPipe.h"
+#include "mozilla/ipc/CrossProcessPipe.h"
 #include "nsScriptableBase64Encoder.h"
 
 #include "nsMemoryImpl.h"
 #include "nsDebugImpl.h"
 #include "nsTraceRefcnt.h"
 #include "nsErrorService.h"
 
 #include "nsSupportsArray.h"
diff --git a/xpcom/build/XPCOMModule.inc b/xpcom/build/XPCOMModule.inc
--- a/xpcom/build/XPCOMModule.inc
+++ b/xpcom/build/XPCOMModule.inc
@@ -6,16 +6,18 @@
 
     COMPONENT(SCRIPTABLEINPUTSTREAM, nsScriptableInputStream::Create)
     COMPONENT(BINARYINPUTSTREAM, nsBinaryInputStreamConstructor)
     COMPONENT(BINARYOUTPUTSTREAM, nsBinaryOutputStreamConstructor)
     COMPONENT(STORAGESTREAM, nsStorageStreamConstructor)
     COMPONENT(VERSIONCOMPARATOR, nsVersionComparatorImplConstructor)
     COMPONENT(SCRIPTABLEBASE64ENCODER, nsScriptableBase64EncoderConstructor)
     COMPONENT(PIPE, nsPipeConstructor)
+    COMPONENT(CROSSPROCESSPIPE,
+              mozilla::ipc::detail::XPCOMCreateCrossProcessPipe)
 
     COMPONENT(PROPERTIES, nsPropertiesConstructor)
 
     COMPONENT(PERSISTENTPROPERTIES, nsPersistentProperties::Create)
 
     COMPONENT(SUPPORTSARRAY, nsSupportsArray::Create)
     COMPONENT(ARRAY, nsArrayBase::XPCOMConstructor)
     COMPONENT(CONSOLESERVICE, nsConsoleServiceConstructor)
diff --git a/xpcom/io/nsIAsyncOutputStream.idl b/xpcom/io/nsIAsyncOutputStream.idl
--- a/xpcom/io/nsIAsyncOutputStream.idl
+++ b/xpcom/io/nsIAsyncOutputStream.idl
@@ -86,17 +86,17 @@ interface nsIAsyncOutputStream : nsIOutp
      * stream).
      */
     const unsigned long WAIT_CLOSURE_ONLY = (1<<0);
 };
 
 /**
  * This is a companion interface for nsIAsyncOutputStream::asyncWait.
  */
-[scriptable, uuid(40dbcdff-9053-42c5-a57c-3ec910d0f148)]
+[function, scriptable, uuid(40dbcdff-9053-42c5-a57c-3ec910d0f148)]
 interface nsIOutputStreamCallback : nsISupports
 {
     /**
      * Called to indicate that the stream is either writable or closed.
      *
      * @param aStream
      *        The stream whose asyncWait method was called.
      */
diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -1185,36 +1185,22 @@ nsPipeOutputStream::WriteSegments(nsRead
     if (segmentLen < originalLen) {
       mPipe->AdvanceWriteCursor(originalLen - segmentLen);
     }
   }
 
   return rv;
 }
 
-static NS_METHOD
-nsReadFromRawBuffer(nsIOutputStream* aOutStr,
-                    void* aClosure,
-                    char* aToRawSegment,
-                    uint32_t aOffset,
-                    uint32_t aCount,
-                    uint32_t* aReadCount)
-{
-  const char* fromBuf = (const char*)aClosure;
-  memcpy(aToRawSegment, &fromBuf[aOffset], aCount);
-  *aReadCount = aCount;
-  return NS_OK;
-}
-
 NS_IMETHODIMP
 nsPipeOutputStream::Write(const char* aFromBuf,
                           uint32_t aBufLen,
                           uint32_t* aWriteCount)
 {
-  return WriteSegments(nsReadFromRawBuffer, (void*)aFromBuf, aBufLen, aWriteCount);
+  return WriteSegments(NS_CopySegmentToBuffer, (void*)aFromBuf, aBufLen, aWriteCount);
 }
 
 NS_IMETHODIMP
 nsPipeOutputStream::Flush(void)
 {
   // nothing to do
   return NS_OK;
 }
