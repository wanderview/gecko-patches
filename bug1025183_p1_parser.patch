# HG changeset patch
# Parent 2fc48871c4593f7317f9a11c31c0ea9562130a14
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P1 Add ScalarValueString to webidl parser. r=bz

diff --git a/dom/bindings/parser/WebIDL.py b/dom/bindings/parser/WebIDL.py
--- a/dom/bindings/parser/WebIDL.py
+++ b/dom/bindings/parser/WebIDL.py
@@ -1374,16 +1374,17 @@ class IDLType(IDLObject):
         'float',
         'unrestricted_double',
         # "double" last primitive type to match IDLBuiltinType
         'double',
         # Other types
         'any',
         'domstring',
         'bytestring',
+        'scalarvaluestring',
         'object',
         'date',
         'void',
         # Funny stuff
         'interface',
         'dictionary',
         'enum',
         'callback',
@@ -1426,16 +1427,19 @@ class IDLType(IDLObject):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return self.name == "Void"
 
     def isSequence(self):
         return False
 
     def isMozMap(self):
         return False
@@ -1599,16 +1603,19 @@ class IDLNullableType(IDLType):
         return self.inner.isString()
 
     def isByteString(self):
         return self.inner.isByteString()
 
     def isDOMString(self):
         return self.inner.isDOMString()
 
+    def isScalarValueString(self):
+        return self.inner.isScalarValueString()
+
     def isFloat(self):
         return self.inner.isFloat()
 
     def isUnrestricted(self):
         return self.inner.isUnrestricted()
 
     def includesRestrictedFloat(self):
         return self.inner.includesRestrictedFloat()
@@ -1720,16 +1727,19 @@ class IDLSequenceType(IDLType):
         return False;
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         return True
 
     def isArray(self):
         return False
@@ -1974,16 +1984,19 @@ class IDLArrayType(IDLType):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         assert not self.inner.isSequence()
         return False
 
     def isArray(self):
@@ -2069,16 +2082,19 @@ class IDLTypedefType(IDLType, IDLObjectW
         return self.inner.isString()
 
     def isByteString(self):
         return self.inner.isByteString()
 
     def isDOMString(self):
         return self.inner.isDOMString()
 
+    def isScalarValueString(self):
+        return self.inner.isScalarValueString()
+
     def isVoid(self):
         return self.inner.isVoid()
 
     def isSequence(self):
         return self.inner.isSequence()
 
     def isMozMap(self):
         return self.inner.isMozMap()
@@ -2165,16 +2181,19 @@ class IDLWrapperType(IDLType):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         return False
 
     def isArray(self):
         return False
@@ -2301,16 +2320,17 @@ class IDLBuiltinType(IDLType):
         'float',
         'unrestricted_double',
         # IMPORTANT: "double" must be the last primitive type listed
         'double',
         # Other types
         'any',
         'domstring',
         'bytestring',
+        'scalarvaluestring',
         'object',
         'date',
         'void',
         # Funny stuff
         'ArrayBuffer',
         'ArrayBufferView',
         'Int8Array',
         'Uint8Array',
@@ -2335,16 +2355,17 @@ class IDLBuiltinType(IDLType):
             Types.boolean: IDLType.Tags.bool,
             Types.unrestricted_float: IDLType.Tags.unrestricted_float,
             Types.float: IDLType.Tags.float,
             Types.unrestricted_double: IDLType.Tags.unrestricted_double,
             Types.double: IDLType.Tags.double,
             Types.any: IDLType.Tags.any,
             Types.domstring: IDLType.Tags.domstring,
             Types.bytestring: IDLType.Tags.bytestring,
+            Types.scalarvaluestring: IDLType.Tags.scalarvaluestring,
             Types.object: IDLType.Tags.object,
             Types.date: IDLType.Tags.date,
             Types.void: IDLType.Tags.void,
             Types.ArrayBuffer: IDLType.Tags.interface,
             Types.ArrayBufferView: IDLType.Tags.interface,
             Types.Int8Array: IDLType.Tags.interface,
             Types.Uint8Array: IDLType.Tags.interface,
             Types.Uint8ClampedArray: IDLType.Tags.interface,
@@ -2367,24 +2388,28 @@ class IDLBuiltinType(IDLType):
     def isBoolean(self):
         return self._typeTag == IDLBuiltinType.Types.boolean
 
     def isNumeric(self):
         return self.isPrimitive() and not self.isBoolean()
 
     def isString(self):
         return self._typeTag == IDLBuiltinType.Types.domstring or \
-               self._typeTag == IDLBuiltinType.Types.bytestring
+               self._typeTag == IDLBuiltinType.Types.bytestring or \
+               self._typeTag == IDLBuiltinType.Types.scalarvaluestring
 
     def isByteString(self):
         return self._typeTag == IDLBuiltinType.Types.bytestring
 
     def isDOMString(self):
         return self._typeTag == IDLBuiltinType.Types.domstring
 
+    def isScalarValueString(self):
+        return self._typeTag == IDLBuiltinType.Types.scalarvaluestring
+
     def isInteger(self):
         return self._typeTag <= IDLBuiltinType.Types.unsigned_long_long
 
     def isArrayBuffer(self):
         return self._typeTag == IDLBuiltinType.Types.ArrayBuffer
 
     def isArrayBufferView(self):
         return self._typeTag == IDLBuiltinType.Types.ArrayBufferView
@@ -2527,16 +2552,19 @@ BuiltinTypes = {
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Any",
                          IDLBuiltinType.Types.any),
       IDLBuiltinType.Types.domstring:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "String",
                          IDLBuiltinType.Types.domstring),
       IDLBuiltinType.Types.bytestring:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "ByteString",
                          IDLBuiltinType.Types.bytestring),
+      IDLBuiltinType.Types.scalarvaluestring:
+          IDLBuiltinType(BuiltinLocation("<builtin type>"), "ScalarValueString",
+                         IDLBuiltinType.Types.scalarvaluestring),
       IDLBuiltinType.Types.object:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Object",
                          IDLBuiltinType.Types.object),
       IDLBuiltinType.Types.date:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Date",
                          IDLBuiltinType.Types.date),
       IDLBuiltinType.Types.void:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Void",
@@ -2661,16 +2689,23 @@ class IDLValue(IDLObject):
             return self
         elif self.type.isFloat() and type.isFloat():
             if (not type.isUnrestricted() and
                 (self.value == float("inf") or self.value == float("-inf") or
                  math.isnan(self.value))):
                 raise WebIDLError("Trying to convert unrestricted value %s to non-unrestricted"
                                   % self.value, [location]);
             return self
+        elif self.type.isString() and type.isScalarValueString():
+            # Allow ScalarValueStrings to use default value just like
+            # DOMString.  No coercion is required in this case as Codegen.py
+            # treats ScalarValueString just like DOMString, but with an
+            # extra normalization step.
+            assert self.type.isDOMString()
+            return self
         raise WebIDLError("Cannot coerce type %s to type %s." %
                           (self.type, type), [location])
 
     def _getDependentObjects(self):
         return set()
 
 class IDLNullValue(IDLObject):
     def __init__(self, location):
@@ -3823,16 +3858,17 @@ class Tokenizer(object):
         "deleter": "DELETER",
         "legacycaller": "LEGACYCALLER",
         "optional": "OPTIONAL",
         "...": "ELLIPSIS",
         "::": "SCOPE",
         "Date": "DATE",
         "DOMString": "DOMSTRING",
         "ByteString": "BYTESTRING",
+        "ScalarValueString": "SCALARVALUESTRING",
         "any": "ANY",
         "boolean": "BOOLEAN",
         "byte": "BYTE",
         "double": "DOUBLE",
         "float": "FLOAT",
         "long": "LONG",
         "object": "OBJECT",
         "octet": "OCTET",
@@ -4718,16 +4754,17 @@ class Parser(Tokenizer):
                   | SEMICOLON
                   | LT
                   | EQUALS
                   | GT
                   | QUESTIONMARK
                   | DATE
                   | DOMSTRING
                   | BYTESTRING
+                  | SCALARVALUESTRING
                   | ANY
                   | ATTRIBUTE
                   | BOOLEAN
                   | BYTE
                   | LEGACYCALLER
                   | CONST
                   | CREATOR
                   | DELETER
@@ -4971,16 +5008,22 @@ class Parser(Tokenizer):
         p[0] = IDLBuiltinType.Types.domstring
 
     def p_PrimitiveOrStringTypeBytestring(self, p):
         """
             PrimitiveOrStringType : BYTESTRING
         """
         p[0] = IDLBuiltinType.Types.bytestring
 
+    def p_PrimitiveOrStringTypeScalarValueString(self, p):
+        """
+            PrimitiveOrStringType : SCALARVALUESTRING
+        """
+        p[0] = IDLBuiltinType.Types.scalarvaluestring
+
     def p_UnsignedIntegerTypeUnsigned(self, p):
         """
             UnsignedIntegerType : UNSIGNED IntegerType
         """
         p[0] = p[2] + 1 # Adding one to a given signed integer type
                         # gets you the unsigned type.
 
     def p_UnsignedIntegerType(self, p):
diff --git a/dom/bindings/parser/tests/test_distinguishability.py b/dom/bindings/parser/tests/test_distinguishability.py
--- a/dom/bindings/parser/tests/test_distinguishability.py
+++ b/dom/bindings/parser/tests/test_distinguishability.py
@@ -154,28 +154,29 @@ def WebIDLTest(parser, harness):
                  "boolean?", "DOMString", "ByteString", "Enum", "Enum2",
                  "Interface", "Interface?",
                  "AncestorInterface", "UnrelatedInterface",
                  "ImplementedInterface", "CallbackInterface",
                  "CallbackInterface?", "CallbackInterface2",
                  "object", "Callback", "Callback2", "optional Dict",
                  "optional Dict2", "sequence<long>", "sequence<short>",
                  "MozMap<object>", "MozMap<Dict>", "MozMap<long>",
-                 "long[]", "short[]", "Date", "Date?", "any" ]
+                 "long[]", "short[]", "Date", "Date?", "any",
+                 "ScalarValueString" ]
     # When we can parse Date and RegExp, we need to add them here.
 
     # Try to categorize things a bit to keep list lengths down
     def allBut(list1, list2):
         return [a for a in list1 if a not in list2 and a != "any"]
     numerics = [ "long", "short", "long?", "short?" ]
     booleans = [ "boolean", "boolean?" ]
     primitives = numerics + booleans
     nonNumerics = allBut(argTypes, numerics)
     nonBooleans = allBut(argTypes, booleans)
-    strings = [ "DOMString", "ByteString", "Enum", "Enum2" ]
+    strings = [ "DOMString", "ByteString", "Enum", "Enum2", "ScalarValueString" ]
     nonStrings = allBut(argTypes, strings)
     nonObjects = primitives + strings
     objects = allBut(argTypes, nonObjects )
     interfaces = [ "Interface", "Interface?", "AncestorInterface",
                    "UnrelatedInterface", "ImplementedInterface" ]
     nullables = ["long?", "short?", "boolean?", "Interface?",
                  "CallbackInterface?", "optional Dict", "optional Dict2",
                  "Date?", "any"]
@@ -199,16 +200,17 @@ def WebIDLTest(parser, harness):
     setDistinguishable("long", nonNumerics)
     setDistinguishable("short", nonNumerics)
     setDistinguishable("long?", allBut(nonNumerics, nullables))
     setDistinguishable("short?", allBut(nonNumerics, nullables))
     setDistinguishable("boolean", nonBooleans)
     setDistinguishable("boolean?", allBut(nonBooleans, nullables))
     setDistinguishable("DOMString", nonStrings)
     setDistinguishable("ByteString", nonStrings)
+    setDistinguishable("ScalarValueString", nonStrings)
     setDistinguishable("Enum", nonStrings)
     setDistinguishable("Enum2", nonStrings)
     setDistinguishable("Interface", notRelatedInterfaces)
     setDistinguishable("Interface?", allBut(notRelatedInterfaces, nullables))
     setDistinguishable("AncestorInterface", notRelatedInterfaces)
     setDistinguishable("UnrelatedInterface",
                        allBut(argTypes, ["object", "UnrelatedInterface"]))
     setDistinguishable("ImplementedInterface", notRelatedInterfaces)
diff --git a/dom/bindings/parser/tests/test_scalarvaluestring.py b/dom/bindings/parser/tests/test_scalarvaluestring.py
new file mode 100644
--- /dev/null
+++ b/dom/bindings/parser/tests/test_scalarvaluestring.py
@@ -0,0 +1,36 @@
+# -*- coding: UTF-8 -*-
+
+import WebIDL
+
+def WebIDLTest(parser, harness):
+    parser.parse("""
+        interface TestScalarValueString {
+          attribute ScalarValueString svs;
+        };
+    """)
+
+    results = parser.finish();
+
+    harness.check(len(results), 1, "Should be one production")
+    harness.ok(isinstance(results[0], WebIDL.IDLInterface),
+               "Should be an IDLInterface")
+    iface = results[0]
+    harness.check(iface.identifier.QName(), "::TestScalarValueString",
+                  "Interface has the right QName")
+    harness.check(iface.identifier.name, "TestScalarValueString",
+                  "Interface has the right name")
+    harness.check(iface.parent, None, "Interface has no parent")
+
+    members = iface.members
+    harness.check(len(members), 1, "Should be one member")
+
+    attr = members[0]
+    harness.ok(isinstance(attr, WebIDL.IDLAttribute), "Should be an IDLAttribute")
+    harness.check(attr.identifier.QName(), "::TestScalarValueString::svs",
+                  "Attr has correct QName")
+    harness.check(attr.identifier.name, "svs", "Attr has correct name")
+    harness.check(str(attr.type), "ScalarValueString",
+                  "Attr type is the correct name")
+    harness.ok(attr.type.isScalarValueString(), "Should be ScalarValueString type")
+    harness.ok(attr.type.isString(), "Should be String collective type")
+    harness.ok(not attr.type.isDOMString(), "Should be not be DOMString type")
diff --git a/dom/bindings/parser/tests/test_union.py b/dom/bindings/parser/tests/test_union.py
--- a/dom/bindings/parser/tests/test_union.py
+++ b/dom/bindings/parser/tests/test_union.py
@@ -58,16 +58,17 @@ def WebIDLTest(parser, harness):
              "unsigned long",
              "long long",
              "unsigned long long",
              "boolean",
              "byte",
              "octet",
              "DOMString",
              "ByteString",
+             "ScalarValueString",
              #"sequence<float>",
              "object",
              "ArrayBuffer",
              #"Date",
              "TestInterface1",
              "TestInterface2"]
 
     testPre = """
