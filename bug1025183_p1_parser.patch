# HG changeset patch
# Parent 9da193279d12cdfd1b870ea69c696d7e95f7f19c
# User Ben Kelly <ben@wanderview.com>
Bug 1025183 P1 Add ScalarValueString to webidl parser


diff --git a/dom/bindings/parser/WebIDL.py b/dom/bindings/parser/WebIDL.py
--- a/dom/bindings/parser/WebIDL.py
+++ b/dom/bindings/parser/WebIDL.py
@@ -1307,16 +1307,17 @@ class IDLType(IDLObject):
         'float',
         'unrestricted_double',
         # "double" last primitive type to match IDLBuiltinType
         'double',
         # Other types
         'any',
         'domstring',
         'bytestring',
+        'scalarvaluestring',
         'object',
         'date',
         'void',
         # Funny stuff
         'interface',
         'dictionary',
         'enum',
         'callback',
@@ -1359,16 +1360,19 @@ class IDLType(IDLObject):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return self.name == "Void"
 
     def isSequence(self):
         return False
 
     def isMozMap(self):
         return False
@@ -1532,16 +1536,19 @@ class IDLNullableType(IDLType):
         return self.inner.isString()
 
     def isByteString(self):
         return self.inner.isByteString()
 
     def isDOMString(self):
         return self.inner.isDOMString()
 
+    def isScalarValueString(self):
+        return self.inner.isScalarValueString()
+
     def isFloat(self):
         return self.inner.isFloat()
 
     def isUnrestricted(self):
         return self.inner.isUnrestricted()
 
     def includesRestrictedFloat(self):
         return self.inner.includesRestrictedFloat()
@@ -1653,16 +1660,19 @@ class IDLSequenceType(IDLType):
         return False;
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         return True
 
     def isArray(self):
         return False
@@ -1907,16 +1917,19 @@ class IDLArrayType(IDLType):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         assert not self.inner.isSequence()
         return False
 
     def isArray(self):
@@ -2002,16 +2015,19 @@ class IDLTypedefType(IDLType, IDLObjectW
         return self.inner.isString()
 
     def isByteString(self):
         return self.inner.isByteString()
 
     def isDOMString(self):
         return self.inner.isDOMString()
 
+    def isScalarValueString(self):
+        return self.inner.isScalarValueString()
+
     def isVoid(self):
         return self.inner.isVoid()
 
     def isSequence(self):
         return self.inner.isSequence()
 
     def isMozMap(self):
         return self.inner.isMozMap()
@@ -2098,16 +2114,19 @@ class IDLWrapperType(IDLType):
         return False
 
     def isByteString(self):
         return False
 
     def isDOMString(self):
         return False
 
+    def isScalarValueString(self):
+        return False
+
     def isVoid(self):
         return False
 
     def isSequence(self):
         return False
 
     def isArray(self):
         return False
@@ -2234,16 +2253,17 @@ class IDLBuiltinType(IDLType):
         'float',
         'unrestricted_double',
         # IMPORTANT: "double" must be the last primitive type listed
         'double',
         # Other types
         'any',
         'domstring',
         'bytestring',
+        'scalarvaluestring',
         'object',
         'date',
         'void',
         # Funny stuff
         'ArrayBuffer',
         'ArrayBufferView',
         'Int8Array',
         'Uint8Array',
@@ -2268,16 +2288,17 @@ class IDLBuiltinType(IDLType):
             Types.boolean: IDLType.Tags.bool,
             Types.unrestricted_float: IDLType.Tags.unrestricted_float,
             Types.float: IDLType.Tags.float,
             Types.unrestricted_double: IDLType.Tags.unrestricted_double,
             Types.double: IDLType.Tags.double,
             Types.any: IDLType.Tags.any,
             Types.domstring: IDLType.Tags.domstring,
             Types.bytestring: IDLType.Tags.bytestring,
+            Types.scalarvaluestring: IDLType.Tags.scalarvaluestring,
             Types.object: IDLType.Tags.object,
             Types.date: IDLType.Tags.date,
             Types.void: IDLType.Tags.void,
             Types.ArrayBuffer: IDLType.Tags.interface,
             Types.ArrayBufferView: IDLType.Tags.interface,
             Types.Int8Array: IDLType.Tags.interface,
             Types.Uint8Array: IDLType.Tags.interface,
             Types.Uint8ClampedArray: IDLType.Tags.interface,
@@ -2300,24 +2321,28 @@ class IDLBuiltinType(IDLType):
     def isBoolean(self):
         return self._typeTag == IDLBuiltinType.Types.boolean
 
     def isNumeric(self):
         return self.isPrimitive() and not self.isBoolean()
 
     def isString(self):
         return self._typeTag == IDLBuiltinType.Types.domstring or \
-               self._typeTag == IDLBuiltinType.Types.bytestring
+               self._typeTag == IDLBuiltinType.Types.bytestring or \
+               self._typeTag == IDLBuiltinType.Types.scalarvaluestring
 
     def isByteString(self):
         return self._typeTag == IDLBuiltinType.Types.bytestring
 
     def isDOMString(self):
         return self._typeTag == IDLBuiltinType.Types.domstring
 
+    def isScalarValueString(self):
+        return self._typeTag == IDLBuiltinType.Types.scalarvaluestring
+
     def isInteger(self):
         return self._typeTag <= IDLBuiltinType.Types.unsigned_long_long
 
     def isArrayBuffer(self):
         return self._typeTag == IDLBuiltinType.Types.ArrayBuffer
 
     def isArrayBufferView(self):
         return self._typeTag == IDLBuiltinType.Types.ArrayBufferView
@@ -2460,16 +2485,19 @@ BuiltinTypes = {
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Any",
                          IDLBuiltinType.Types.any),
       IDLBuiltinType.Types.domstring:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "String",
                          IDLBuiltinType.Types.domstring),
       IDLBuiltinType.Types.bytestring:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "ByteString",
                          IDLBuiltinType.Types.bytestring),
+      IDLBuiltinType.Types.scalarvaluestring:
+          IDLBuiltinType(BuiltinLocation("<builtin type>"), "ScalarValueString",
+                         IDLBuiltinType.Types.scalarvaluestring),
       IDLBuiltinType.Types.object:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Object",
                          IDLBuiltinType.Types.object),
       IDLBuiltinType.Types.date:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Date",
                          IDLBuiltinType.Types.date),
       IDLBuiltinType.Types.void:
           IDLBuiltinType(BuiltinLocation("<builtin type>"), "Void",
@@ -3696,16 +3724,17 @@ class Tokenizer(object):
         "deleter": "DELETER",
         "legacycaller": "LEGACYCALLER",
         "optional": "OPTIONAL",
         "...": "ELLIPSIS",
         "::": "SCOPE",
         "Date": "DATE",
         "DOMString": "DOMSTRING",
         "ByteString": "BYTESTRING",
+        "ScalarValueString": "SCALARVALUESTRING",
         "any": "ANY",
         "boolean": "BOOLEAN",
         "byte": "BYTE",
         "double": "DOUBLE",
         "float": "FLOAT",
         "long": "LONG",
         "object": "OBJECT",
         "octet": "OCTET",
@@ -4580,16 +4609,17 @@ class Parser(Tokenizer):
                   | SEMICOLON
                   | LT
                   | EQUALS
                   | GT
                   | QUESTIONMARK
                   | DATE
                   | DOMSTRING
                   | BYTESTRING
+                  | SCALARVALUESTRING
                   | ANY
                   | ATTRIBUTE
                   | BOOLEAN
                   | BYTE
                   | LEGACYCALLER
                   | CONST
                   | CREATOR
                   | DELETER
@@ -4833,16 +4863,22 @@ class Parser(Tokenizer):
         p[0] = IDLBuiltinType.Types.domstring
 
     def p_PrimitiveOrStringTypeBytestring(self, p):
         """
             PrimitiveOrStringType : BYTESTRING
         """
         p[0] = IDLBuiltinType.Types.bytestring
 
+    def p_PrimitiveOrStringTypeScalarValueString(self, p):
+        """
+            PrimitiveOrStringType : SCALARVALUESTRING
+        """
+        p[0] = IDLBuiltinType.Types.scalarvaluestring
+
     def p_UnsignedIntegerTypeUnsigned(self, p):
         """
             UnsignedIntegerType : UNSIGNED IntegerType
         """
         p[0] = p[2] + 1 # Adding one to a given signed integer type
                         # gets you the unsigned type.
 
     def p_UnsignedIntegerType(self, p):
diff --git a/dom/bindings/parser/tests/test_scalarvaluestring.py b/dom/bindings/parser/tests/test_scalarvaluestring.py
new file mode 100644
--- /dev/null
+++ b/dom/bindings/parser/tests/test_scalarvaluestring.py
@@ -0,0 +1,38 @@
+# -*- coding: UTF-8 -*-
+
+import WebIDL
+
+def WebIDLTest(parser, harness):
+    parser.parse("""
+        interface TestScalarValueString {
+          attribute ScalarValueString svs;
+        };
+    """)
+
+    results = parser.finish();
+
+    harness.ok(True, "TestScalarValueString interface parsed without error.")
+
+    harness.check(len(results), 1, "Should be one production")
+    harness.ok(isinstance(results[0], WebIDL.IDLInterface),
+               "Should be an IDLInterface")
+    iface = results[0]
+    harness.check(iface.identifier.QName(), "::TestScalarValueString",
+                  "Interface has the right QName")
+    harness.check(iface.identifier.name, "TestScalarValueString",
+                  "Interface has the right name")
+    harness.check(iface.parent, None, "Interface has no parent")
+
+    members = iface.members
+    harness.check(len(members), 1, "Should be one production")
+
+    attr = members[0]
+    harness.ok(isinstance(attr, WebIDL.IDLAttribute), "Should be an IDLAttribute")
+    harness.check(attr.identifier.QName(), "::TestScalarValueString::svs",
+                  "Attr has correct QName")
+    harness.check(attr.identifier.name, "svs", "Attr has correct name")
+    harness.check(str(attr.type), "ScalarValueString",
+                  "Attr type is the correct name")
+    harness.ok(attr.type.isScalarValueString(), "Should be ScalarValueString type")
+    harness.ok(attr.type.isString(), "Should be String collective type")
+    harness.ok(not attr.type.isDOMString(), "Should be not be DOMString type")
diff --git a/dom/bindings/parser/tests/test_union.py b/dom/bindings/parser/tests/test_union.py
--- a/dom/bindings/parser/tests/test_union.py
+++ b/dom/bindings/parser/tests/test_union.py
@@ -58,16 +58,17 @@ def WebIDLTest(parser, harness):
              "unsigned long",
              "long long",
              "unsigned long long",
              "boolean",
              "byte",
              "octet",
              "DOMString",
              "ByteString",
+             "ScalarValueString",
              #"sequence<float>",
              "object",
              "ArrayBuffer",
              #"Date",
              "TestInterface1",
              "TestInterface2"]
 
     testPre = """
