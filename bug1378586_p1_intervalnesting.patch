# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  09a4282d1172ac255038e7ccacfd772140b219e2
Bug 1378586 P1 Track the nesting level on interval Timeout objects. r=farre

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -587,20 +587,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
     timeout->mIsTracking = (rand() % 2) == 0;
 
     MOZ_LOG(gLog, LogLevel::Debug,
             ("Classified timeout %p as %stracking (random mode)\n",
              timeout.get(), timeout->mIsTracking ? "" : "non-"));
     break;
   }
 
-  uint32_t nestingLevel = sNestingLevel + 1;
-  if (!aIsInterval) {
-    timeout->mNestingLevel = nestingLevel;
-  }
+  timeout->mNestingLevel = sNestingLevel + 1;
 
   // Now clamp the actual interval we will use for the timer based on
   TimeDuration realInterval = CalculateDelay(timeout);
   TimeStamp now = TimeStamp::Now();
   timeout->SetWhenOrTimeRemaining(now, realInterval);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
@@ -981,16 +978,20 @@ TimeoutManager::RescheduleTimeout(Timeou
                                   const TimeStamp& aCurrentNow)
 {
   MOZ_DIAGNOSTIC_ASSERT(aLastCallbackTime <= aCurrentNow);
 
   if (!aTimeout->mIsInterval) {
     return false;
   }
 
+  // Automatically increase the nesting level when a setInterval()
+  // is rescheduled just as if it was using a chained setTimeout().
+  aTimeout->mNestingLevel += 1;
+
   // Compute time to next timeout for interval timer.
   // Make sure nextInterval is at least CalculateDelay().
   TimeDuration nextInterval = CalculateDelay(aTimeout);
 
   TimeStamp firingTime = aLastCallbackTime + nextInterval;
   TimeDuration delay = firingTime - aCurrentNow;
 
   // And make sure delay is nonnegative; that might happen if the timer
