# HG changeset patch
# Parent 7d85ac833cffb46f4b59ebf4f5ba88114b2f5fe6
# User Ben Kelly <ben@wanderview.com>
Bug 1140051 Avoid Cache shutdown assert when Manager alive, but not active. r=ehsan


diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/Manager.h"
 
+#include "mozilla/AutoRestore.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/unused.h"
 #include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
@@ -192,19 +193,17 @@ public:
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(aManager);
     MOZ_ASSERT(sFactory);
 
     MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
 
     // clean up the factory singleton if there are no more managers
-    if (sFactory->mManagerList.IsEmpty()) {
-      DestroyInstance();
-    }
+    MaybeDestroyInstance();
   }
 
   static void
   StartShutdownAllOnMainThread()
   {
     MOZ_ASSERT(NS_IsMainThread());
 
     // Lock for sFactoryShutdown and sBackgroundThread.
@@ -231,24 +230,26 @@ public:
     StaticMutexAutoLock lock(sMutex);
     // Infer whether we have shutdown using the sBackgroundThread value.  We
     // guarantee this is nullptr when sFactory is destroyed.
     return sFactoryShutdown && !sBackgroundThread;
   }
 
 private:
   Factory()
+    : mInSyncShutdown(false)
   {
     MOZ_COUNT_CTOR(cache::Manager::Factory);
   }
 
   ~Factory()
   {
     MOZ_COUNT_DTOR(cache::Manager::Factory);
     MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
   }
 
   static nsresult
   MaybeCreateInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
 
     if (!sFactory) {
@@ -259,17 +260,17 @@ private:
         StaticMutexAutoLock lock(sMutex);
 
         if (sFactoryShutdown) {
           return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
         }
 
         // Cannot use ClearOnShutdown() because we're on the background thread.
         // This is automatically cleared when Factory::Remove() calls
-        // DestroyInstance().
+        // MaybeDestroyInstance().
         MOZ_ASSERT(!sBackgroundThread);
         sBackgroundThread = NS_GetCurrentThread();
       }
 
       // We cannot use ClearOnShutdown() here because we're not on the main
       // thread.  Instead, we delete sFactory in Factory::Remove() after the
       // last manager is removed.  ShutdownObserver ensures this happens
       // before shutdown.
@@ -280,21 +281,29 @@ private:
     // out from under ourselves just before we return from Remove().  This
     // would be (even more) dangerous if other code had a pointer to the
     // factory itself.
 
     return NS_OK;
   }
 
   static void
-  DestroyInstance()
+  MaybeDestroyInstance()
   {
     mozilla::ipc::AssertIsOnBackgroundThread();
     MOZ_ASSERT(sFactory);
 
+    // If the factory is is still in use then we cannot delete yet.  This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down.  We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
     // Be clear about what we are locking.  sFactory is bg thread only, so
     // we don't need to lock it here.  Just protect sBackgroundThread.
     {
       StaticMutexAutoLock lock(sMutex);
       MOZ_ASSERT(sBackgroundThread);
       sBackgroundThread = nullptr;
     }
 
@@ -315,21 +324,31 @@ private:
       StaticMutexAutoLock lock(sMutex);
       MOZ_ASSERT(!sBackgroundThread);
 #endif
       return;
     }
 
     MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
 
-    ManagerList::ForwardIterator iter(sFactory->mManagerList);
-    while (iter.HasMore()) {
-      nsRefPtr<Manager> manager = iter.GetNext();
-      manager->Shutdown();
+    {
+      // Note that we are synchronously calling shutdown code here.  If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        nsRefPtr<Manager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
     }
+
+    MaybeDestroyInstance();
   }
 
   class ShutdownAllRunnable MOZ_FINAL : public nsRunnable
   {
   public:
     NS_IMETHOD
     Run() MOZ_OVERRIDE
     {
@@ -358,16 +377,21 @@ private:
   // Must hold sMutex to access.
   static StaticRefPtr<nsIThread> sBackgroundThread;
 
   // Weak references as we don't want to keep Manager objects alive forever.
   // When a Manager is destroyed it calls Factory::Remove() to clear itself.
   // PBackground thread only.
   typedef nsTObserverArray<Manager*> ManagerList;
   ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
 };
 
 // static
 StaticAutoPtr<Manager::Factory> Manager::Factory::sFactory;
 
 // static
 StaticMutex Manager::Factory::sMutex;
 
