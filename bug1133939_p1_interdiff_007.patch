# HG changeset patch
# Parent f3bd173f676a2fc40b0febc9bf0f57fecf8d945c
# User Ben Kelly <ben@wanderview.com>
Bug 1133939 P1 interdiff 007 better document AutoReadSegment


diff --git a/xpcom/io/nsPipe3.cpp b/xpcom/io/nsPipe3.cpp
--- a/xpcom/io/nsPipe3.cpp
+++ b/xpcom/io/nsPipe3.cpp
@@ -121,17 +121,23 @@ struct nsPipeReadState
     , mActiveRead(false)
     , mNeedDrain(false)
   { }
 
   char*    mReadCursor;
   char*    mReadLimit;
   int32_t  mSegment;
   uint32_t mAvailable;
+
+  // This flag is managed using the AutoReadSegment RAII stack class.
   bool     mActiveRead;
+
+  // Set to indicate that the input stream has closed and should be drained,
+  // but that drain has been delayed due to an active read.  When the read
+  // completes, this flag indicate the drain should then be performed.
   bool     mNeedDrain;
 };
 
 //-----------------------------------------------------------------------------
 
 // an input end of a pipe (maintained as a list of refs within the pipe)
 class nsPipeInputStream
   : public nsIAsyncInputStream
@@ -275,64 +281,63 @@ private:
 
 //-----------------------------------------------------------------------------
 
 class nsPipe MOZ_FINAL : public nsIPipe
 {
 public:
   friend class nsPipeInputStream;
   friend class nsPipeOutputStream;
+  friend class AutoReadSegment;
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIPIPE
 
   // nsPipe methods:
   nsPipe();
 
 private:
   ~nsPipe();
 
-public:
   //
   // methods below may only be called while inside the pipe's monitor
   //
 
   void PeekSegment(const nsPipeReadState& aReadState, uint32_t aIndex,
                    char*& aCursor, char*& aLimit);
+  SegmentChangeResult AdvanceReadSegment(nsPipeReadState& aReadState);
+  bool ReadSegmentBeingWritten(nsPipeReadState& aReadState);
+  uint32_t CountSegmentReferences(int32_t aSegment);
+  void SetAllNullReadCursors();
+  bool AllReadCursorsMatchWriteCursor();
+  void RollBackAllReadCursors(char* aWriteCursor);
+  void UpdateAllReadCursors(char* aWriteCursor);
+  void ValidateAllReadCursors();
 
   //
   // methods below may be called while outside the pipe's monitor
   //
 
-  nsresult GetReadSegment(nsPipeReadState& aReadState, const char*& aSegment,
-                          uint32_t& aLength);
-  void     ReleaseReadSegment(nsPipeReadState& aReadState,
-                              nsPipeEvents& aEvents);
-  void     AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aCount);
-  SegmentChangeResult AdvanceReadSegment(nsPipeReadState& aReadState);
   void     DrainInputStream(nsPipeReadState& aReadState, nsPipeEvents& aEvents);
-  bool     ReadSegmentBeingWritten(nsPipeReadState& aReadState);
 
   nsresult GetWriteSegment(char*& aSegment, uint32_t& aSegmentLen);
   void     AdvanceWriteCursor(uint32_t aCount);
 
   void     OnInputStreamException(nsPipeInputStream* aStream, nsresult aReason);
   void     OnPipeException(nsresult aReason, bool aOutputOnly = false);
 
   nsresult CloneInputStream(nsPipeInputStream* aOriginal,
                             nsIInputStream** aCloneOut);
 
-protected:
-  // Only callable with mReetrantMonitor locked
-  uint32_t CountSegmentReferences(int32_t aSegment);
-  void SetAllNullReadCursors();
-  bool AllReadCursorsMatchWriteCursor();
-  void RollBackAllReadCursors(char* aWriteCursor);
-  void UpdateAllReadCursors(char* aWriteCursor);
-  void ValidateAllReadCursors();
+  // methods below should only be called by AutoReadSegment
+  nsresult GetReadSegment(nsPipeReadState& aReadState, const char*& aSegment,
+                          uint32_t& aLength);
+  void     ReleaseReadSegment(nsPipeReadState& aReadState,
+                              nsPipeEvents& aEvents);
+  void     AdvanceReadCursor(nsPipeReadState& aReadState, uint32_t aCount);
 
   // We can't inherit from both nsIInputStream and nsIOutputStream
   // because they collide on their Close method. Consequently we nest their
   // implementations to avoid the extra object allocation.
   nsPipeOutputStream  mOutput;
 
   // Since the input stream can be cloned, we may have more than one.  Use
   // a weak reference as the streams will clear their entry here in their
@@ -677,16 +682,18 @@ nsPipe::AdvanceReadCursor(nsPipeReadStat
 
     ReleaseReadSegment(aReadState, events);
   }
 }
 
 SegmentChangeResult
 nsPipe::AdvanceReadSegment(nsPipeReadState& aReadState)
 {
+  mReentrantMonitor.AssertCurrentThreadIn();
+
   int32_t currentSegment = aReadState.mSegment;
 
   // Move to the next segment to read
   aReadState.mSegment += 1;
 
   SegmentChangeResult result = SegmentNotChanged;
 
   // If this was the last reference to the first segment, then remove it.
@@ -777,16 +784,17 @@ nsPipe::DrainInputStream(nsPipeReadState
       mOutput.OnOutputWritable(aEvents) == NotifyMonitor) {
     mon.NotifyAll();
   }
 }
 
 bool
 nsPipe::ReadSegmentBeingWritten(nsPipeReadState& aReadState)
 {
+  mReentrantMonitor.AssertCurrentThreadIn();
   bool beingWritten = mWriteSegment == aReadState.mSegment &&
                       mWriteLimit > mWriteCursor;
   NS_ASSERTION(!beingWritten || aReadState.mReadLimit == mWriteCursor,
                "unexpected state");
   return beingWritten;
 }
 
 nsresult
