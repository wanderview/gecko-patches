# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  1338d9412b088a2ec07a81dd7347abeb00835b6f
Validate PrincipalInfo and creation URL.

diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientManager.h"
 
 #include "ClientHandle.h"
 #include "ClientManagerChild.h"
 #include "ClientManagerOpChild.h"
+#include "ClientPrefs.h"
 #include "ClientSource.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "prthread.h"
 
 namespace mozilla {
@@ -210,16 +211,18 @@ ClientManager::GetWorkerPrivate() const
 // static
 void
 ClientManager::Startup()
 {
   MOZ_ASSERT(NS_IsMainThread());
   PRStatus status =
     PR_NewThreadPrivateIndex(&sClientManagerThreadLocalIndex, nullptr);
   MOZ_DIAGNOSTIC_ASSERT(status == PR_SUCCESS);
+
+  ClientPrefsInit();
 }
 
 // static
 UniquePtr<ClientSource>
 ClientManager::CreateSource(ClientType aType, nsIPrincipal* aPrincipal)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aPrincipal);
diff --git a/dom/clients/manager/ClientManagerParent.cpp b/dom/clients/manager/ClientManagerParent.cpp
--- a/dom/clients/manager/ClientManagerParent.cpp
+++ b/dom/clients/manager/ClientManagerParent.cpp
@@ -96,16 +96,25 @@ ClientManagerParent::AllocPClientSourceP
 
 bool
 ClientManagerParent::DeallocPClientSourceParent(PClientSourceParent* aActor)
 {
   delete aActor;
   return true;
 }
 
+IPCResult
+ClientManagerParent::RecvPClientSourceConstructor(PClientSourceParent* aActor,
+                                                  const ClientSourceConstructorArgs& aArgs)
+{
+  ClientSourceParent* actor = static_cast<ClientSourceParent*>(aActor);
+  actor->Init();
+  return IPC_OK();
+}
+
 ClientManagerParent::ClientManagerParent()
   : mService(ClientManagerService::GetOrCreateInstance())
 {
 }
 
 ClientManagerParent::~ClientManagerParent()
 {
 }
diff --git a/dom/clients/manager/ClientManagerParent.h b/dom/clients/manager/ClientManagerParent.h
--- a/dom/clients/manager/ClientManagerParent.h
+++ b/dom/clients/manager/ClientManagerParent.h
@@ -51,16 +51,20 @@ class ClientManagerParent final : public
   DeallocPClientNavigateOpParent(PClientNavigateOpParent* aActor) override;
 
   PClientSourceParent*
   AllocPClientSourceParent(const ClientSourceConstructorArgs& aArgs) override;
 
   bool
   DeallocPClientSourceParent(PClientSourceParent* aActor) override;
 
+  mozilla::ipc::IPCResult
+  RecvPClientSourceConstructor(PClientSourceParent* aActor,
+                               const ClientSourceConstructorArgs& aArgs) override;
+
 public:
   ClientManagerParent();
   ~ClientManagerParent();
 };
 
 } // namespace dom
 } // namespace mozilla
 
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -86,34 +86,43 @@ ClientManagerService::GetOrCreateInstanc
   if (!sClientManagerServiceInstance) {
     sClientManagerServiceInstance = new ClientManagerService();
   }
 
   RefPtr<ClientManagerService> ref(sClientManagerServiceInstance);
   return ref.forget();
 }
 
-void
+bool
 ClientManagerService::AddSource(ClientSourceParent* aSource)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aSource);
   auto entry = mSourceTable.LookupForAdd(aSource->Info().Id());
-  MOZ_DIAGNOSTIC_ASSERT(!entry);
+  // Do not permit overwriting an existing ClientSource with the same
+  // UUID.  This would allow a spoofed ClientParentSource actor to
+  // intercept postMessage() intended for the real actor.
+  if (entry) {
+    return false;
+  }
   entry.OrInsert([&] { return aSource; });
+  return true;
 }
 
-void
+bool
 ClientManagerService::RemoveSource(ClientSourceParent* aSource)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aSource);
   auto entry = mSourceTable.Lookup(aSource->Info().Id());
-  MOZ_DIAGNOSTIC_ASSERT(entry);
+  if (!entry) {
+    return false;
+  }
   entry.Remove();
+  return true;
 }
 
 ClientSourceParent*
 ClientManagerService::FindSource(const nsID& aID, const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
 
   auto entry = mSourceTable.Lookup(aID);
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -30,20 +30,20 @@ class ClientManagerService final
 
   ClientManagerService();
   ~ClientManagerService();
 
 public:
   static already_AddRefed<ClientManagerService>
   GetOrCreateInstance();
 
-  void
+  bool
   AddSource(ClientSourceParent* aSource);
 
-  void
+  bool
   RemoveSource(ClientSourceParent* aSource);
 
   ClientSourceParent*
   FindSource(const nsID& aID,
              const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
   already_AddRefed<ClientOpPromise>
   Navigate(const ClientNavigateArgs& aArgs);
diff --git a/dom/clients/manager/ClientPrefs.cpp b/dom/clients/manager/ClientPrefs.cpp
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientPrefs.cpp
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientPrefs.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace {
+
+bool gDataURLUniqueOpaqueOrigin = false;
+bool gStrictFileOrigin = false;
+
+} // anonymous namespace
+
+void
+ClientPrefsInit()
+{
+  Preferences::AddBoolVarCache(&gDataURLUniqueOpaqueOrigin,
+                               "security.data_uri.unique_opaque_origin",
+                               false);
+
+  Preferences::AddBoolVarCache(&gStrictFileOrigin,
+                               "security.fileuri.strict_origin_policy",
+                               false);
+}
+
+bool
+ClientPrefsGetDataURLUniqueOpaqueOrigin()
+{
+  return gDataURLUniqueOpaqueOrigin;
+}
+
+bool
+ClientPrefsGetStrictFileOrigin()
+{
+  return gStrictFileOrigin;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/clients/manager/ClientPrefs.h b/dom/clients/manager/ClientPrefs.h
new file mode 100644
--- /dev/null
+++ b/dom/clients/manager/ClientPrefs.h
@@ -0,0 +1,24 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef _mozilla_dom_ClientPrefs_h
+#define _mozilla_dom_ClientPrefs_h
+
+namespace mozilla {
+namespace dom {
+
+void
+ClientPrefsInit();
+
+bool
+ClientPrefsGetAllowUniqueOpaqueOrigin();
+
+bool
+ClientPrefsGetStrictFileOrigin();
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // _mozilla_dom_ClientPrefs_h
diff --git a/dom/clients/manager/ClientSourceParent.cpp b/dom/clients/manager/ClientSourceParent.cpp
--- a/dom/clients/manager/ClientSourceParent.cpp
+++ b/dom/clients/manager/ClientSourceParent.cpp
@@ -3,25 +3,318 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientSourceParent.h"
 
 #include "ClientHandleParent.h"
 #include "ClientManagerService.h"
+#include "ClientPrefs.h"
 #include "ClientSourceOpParent.h"
 #include "mozilla/dom/ClientIPCTypes.h"
+#include "mozilla/net/MozURL.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
+using mozilla::ipc::ContentPrincipalInfo;
 using mozilla::ipc::IPCResult;
 using mozilla::ipc::PrincipalInfo;
+using mozilla::net::MozURL;
+
+namespace {
+
+bool
+IsNestedURLScheme(const nsACString& aScheme)
+{
+  return aScheme.LowerCaseEqualsLiteral("feed") ||
+         aScheme.LowerCaseEqualsLiteral("jar") ||
+         aScheme.LowerCaseEqualsLiteral("moz-icon") ||
+         aScheme.LowerCaseEqualsLiteral("view-source") ||
+
+         // wyciwyg: URLs are similar to nested URLs, but technically not
+         // handled by nsINestedURI.  They do custom nesting in their
+         // necko channel and protocol handler.
+         aScheme.LowerCaseEqualsLiteral("wyciwyg");
+}
+
+bool
+IsNonStrictFileOrigin(const nsACString& aScheme, const nsACString& aHostname)
+{
+  return aScheme.LowerCaseEqualsLiteral("file") &&
+         aHostname.LowerCaseEqualsLiteral("universal_file_uri_origin");
+}
+
+} // anonymous namespace
+
+bool
+ClientSourceParent::IsValidPrincipal()
+{
+  // Ideally we would verify that the source process has permission to
+  // create a window or worker with the given principal, but we don't
+  // currently have any such restriction in place.  Instead, at least
+  // verify the PrincipalInfo is an expected type and has a parsable
+  // origin/spec.
+  switch (mClientInfo.PrincipalInfo().type()) {
+    // Any system and null principal is acceptable.
+    case PrincipalInfo::TSystemPrincipalInfo:
+    case PrincipalInfo::TNullPrincipalInfo:
+    {
+      return true;
+    }
+
+    // Validate content principals to ensure that the origin and spec are sane.
+    case PrincipalInfo::TContentPrincipalInfo:
+    {
+      const ContentPrincipalInfo& content =
+        mClientInfo.PrincipalInfo().get_ContentPrincipalInfo();
+
+      // Verify the principal spec parses.
+      RefPtr<MozURL> specURL;
+      nsresult rv = MozURL::Init(getter_AddRefs(specURL), content.spec());
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // Verify the principal originNoSuffix parses.
+      RefPtr<MozURL> originURL;
+      rv = MozURL::Init(getter_AddRefs(originURL),
+                        content.originNoSuffix().get_nsCString());
+      NS_ENSURE_SUCCESS(rv, false);
+
+      nsAutoCString specScheme;
+      rv = specURL->GetScheme(specScheme);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      nsAutoCString originScheme;
+      rv = originURL->GetScheme(originScheme);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // MozURL does not have a good way of dealing with nested URLs right
+      // now.  Accept spec strings using one of these schemes.
+      if (IsNestedURLScheme(specScheme)) {
+        return true;
+      }
+
+      // The about: windows can run in a content window, but they use a special
+      // moz-safe-about origin spec that won't match below.  Check for this
+      // here and accept these windows.
+      if (specScheme.LowerCaseEqualsLiteral("about") &&
+          originScheme.LowerCaseEqualsLiteral("moz-safe-about")) {
+        return true;
+      }
+
+      nsAutoCString originHostname;
+      rv = originURL->GetHostname(originHostname);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // Some file: principals do not use strict origin checking and
+      // instead have univeral origin token.  Accept these.
+      if (!ClientPrefsGetStrictFileOrigin() &&
+          IsNonStrictFileOrigin(originScheme, originHostname) &&
+          originScheme == specScheme) {
+        return true;
+      }
+
+      nsAutoCString specHostname;
+      rv = specURL->GetHostname(specHostname);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // MozURL does not parse the origin correctly for all internal
+      // schemes, such as moz-extension.  Instead, lets just validate
+      // that the spec and originNoSuffix strings have the same scheme
+      // and hostname.
+      return specScheme == originScheme &&
+             specHostname == originHostname;
+    }
+    default:
+    {
+      break;
+    }
+  }
+
+  // Windows and workers should not have expanded URLs, etc.
+  return false;
+}
+
+bool
+ClientSourceParent::IsValidURL(const nsACString& aURL) const
+{
+  RefPtr<MozURL> url;
+  nsresult rv = MozURL::Init(getter_AddRefs(url), aURL);
+  NS_ENSURE_SUCCESS(rv, false);
+
+  switch (mClientInfo.PrincipalInfo().type()) {
+    case PrincipalInfo::TContentPrincipalInfo:
+    {
+      // Any origin can create an about:blank or about:srcdoc Client.
+      if (aURL.LowerCaseEqualsLiteral("about:blank") ||
+          aURL.LowerCaseEqualsLiteral("about:srcdoc")) {
+        return true;
+      }
+
+      const ContentPrincipalInfo& content =
+        mClientInfo.PrincipalInfo().get_ContentPrincipalInfo();
+
+      // Parse the principal origin URL as well.  This ensures any MozURL
+      // parser issues effect both URLs equally.
+      RefPtr<MozURL> principalURL;
+      rv = MozURL::Init(getter_AddRefs(principalURL),
+                        content.originNoSuffix().get_nsCString());
+      NS_ENSURE_SUCCESS(rv, false);
+
+      nsAutoCString origin;
+      rv = url->GetOrigin(origin);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      nsAutoCString principalOrigin;
+      rv = principalURL->GetOrigin(principalOrigin);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // The vast majority of sites should simply result in the same principal
+      // and URL origin.
+      if (principalOrigin == origin) {
+        return true;
+      }
+
+      nsAutoCString scheme;
+      rv = url->GetScheme(scheme);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // MozURL does not have a good way of dealing with nested URLs right
+      // now.  Accept spec strings using one of these schemes.
+      if (IsNestedURLScheme(scheme)) {
+        return true;
+      }
+
+      // Generally any origin can also open javascript: windows and workers.
+      if (scheme.LowerCaseEqualsLiteral("javascript")) {
+        return true;
+      }
+
+      // We have some tests that use data: URL windows without an opaque
+      // origin.  This should only happen when a pref is set.
+      if (!ClientPrefsGetDataURLUniqueOpaqueOrigin() &&
+          scheme.LowerCaseEqualsLiteral("data")) {
+        return true;
+      }
+
+      nsAutoCString principalScheme;
+      rv = principalURL->GetScheme(principalScheme);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // Other about: URLs, like about:home and about:newtab, can run
+      // in with a content principal but may have a slightly different origin
+      // scheme.  Some windows use moz-safe-about: instead of about:.  Check
+      // for these allowed principal schemes explicitly here.  Note, we
+      // already handled about:blank above.
+      if (scheme.LowerCaseEqualsLiteral("about")) {
+        if (principalScheme == scheme ||
+            principalScheme.LowerCaseEqualsLiteral("moz-safe-about")) {
+          return true;
+        }
+
+        // Also check for about:sync-log which runs with a file: origin
+        // for some reason.
+        if (aURL.LowerCaseEqualsLiteral("about:sync-log") &&
+            principalScheme.LowerCaseEqualsLiteral("file")) {
+          return true;
+        }
+      }
+
+      nsAutoCString hostname;
+      rv = url->GetHostname(hostname);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // If the origin string does not match, then we could just be
+      // hitting an internal URL type like moz-extension: or resource:.
+      // These should pass a simply scheme://hostname check.
+      if (content.originNoSuffix() ==
+          (scheme + NS_LITERAL_CSTRING("://") + hostname)) {
+        return true;
+      }
+
+      nsAutoCString principalHostname;
+      rv = principalURL->GetHostname(principalHostname);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // Some file: principals do not use strict origin checking and
+      // instead have univeral origin token.  Accept these.
+      if (!ClientPrefsGetStrictFileOrigin() &&
+          IsNonStrictFileOrigin(principalScheme, principalHostname)) {
+
+        // File URLs with a non-strict file origin pass.
+        if(scheme == principalScheme) {
+          return true;
+        }
+
+        // It seems crash tests also run an iframe between tests with
+        // a data URI, but without the pref set.  And jsreftests use
+        // a blob:null URL with a non-strict file URL.
+        if (scheme.LowerCaseEqualsLiteral("data") ||
+            scheme.LowerCaseEqualsLiteral("blob")) {
+          return true;
+        }
+      }
+
+      // Some URLs like strict file: and chrome: URLs require the full
+      // hostname and path to match.  Currentl MozURL does not offer
+      // a good way to extract the path without a leaf file name, though,
+      // so for now we only check the hostname.
+      if ((scheme.LowerCaseEqualsLiteral("file") ||
+           scheme.LowerCaseEqualsLiteral("chrome")) &&
+          hostname == principalHostname) {
+        return true;
+      }
+
+      // Otherwise this URL does not seem to match the principal.
+      return false;
+    }
+    case PrincipalInfo::TSystemPrincipalInfo:
+    {
+      nsAutoCString scheme;
+      rv = url->GetScheme(scheme);
+      NS_ENSURE_SUCCESS(rv, false);
+
+      // While many types of documents can be created with a system principal,
+      // there are only a few that can reasonably become windows.  We attempt
+      // to validate the list of known cases here with a simple scheme check.
+      return scheme.LowerCaseEqualsLiteral("about") ||
+             scheme.LowerCaseEqualsLiteral("chrome") ||
+             scheme.LowerCaseEqualsLiteral("resource") ||
+             scheme.LowerCaseEqualsLiteral("blob") ||
+             scheme.LowerCaseEqualsLiteral("javascript") ||
+             scheme.LowerCaseEqualsLiteral("view-source") ||
+
+             (!ClientPrefsGetDataURLUniqueOpaqueOrigin() &&
+              scheme.LowerCaseEqualsLiteral("data")) ||
+
+             // There is a test using an old addon-sdk protocol handler
+             // to implement khrome scheme.  Allow this for now, but this
+             // should go away relatively soon.
+             scheme.LowerCaseEqualsLiteral("khrome");
+    }
+    case PrincipalInfo::TNullPrincipalInfo:
+    {
+      // A wide variety of clients can have a null principal.  For example,
+      // sandboxed iframes can have a normal content URL.  For now allow
+      // any parsable URL for null principals.  This is relatively safe since
+      // null principals have unique origins and won't most ClientManagerService
+      // queries anyway.
+      return true;
+    }
+    default:
+    {
+      break;
+    }
+  }
+
+  // Clients (windows/workers) should never have an expanded principal type.
+  return false;
+}
 
 IPCResult
 ClientSourceParent::RecvWorkerSyncPing()
 {
   // Do nothing here.  This is purely a sync message allowing the child to
   // confirm that the actor has been created on the parent process.
   return IPC_OK();
 }
@@ -31,28 +324,68 @@ ClientSourceParent::RecvTeardown()
 {
   Unused << Send__delete__(this);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ClientSourceParent::RecvRedirect(const ClientSourceConstructorArgs& aArgs)
 {
-  mService->RemoveSource(this);
+  if (NS_WARN_IF(!mService->RemoveSource(this))) {
+    return IPC_FAIL(this, "failed to remove ClientSource during redirect");
+  }
   mClientInfo = ClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(),
                            mClientInfo.CreationTime());
-  mService->AddSource(this);
+  if (NS_WARN_IF(!mService->AddSource(this))) {
+    return IPC_FAIL(this, "failed to add ClientSource during redirect");
+  }
   return IPC_OK();
 }
 
 IPCResult
 ClientSourceParent::RecvExecutionReady(const ClientSourceExecutionReadyArgs& aArgs)
 {
-  // TODO: Validate this against nsIURI and nsIPrincipal
-  // TODO: mark execution ready
+  // Now that we have the creation URL for the Client we can do some validation
+  // to make sure the child actor is not giving us garbage.
+  if (!IsValidURL(aArgs.url())) {
+    nsAutoCString origin;
+    switch (mClientInfo.PrincipalInfo().type()) {
+      // Any system and null principal is acceptable.
+      case PrincipalInfo::TSystemPrincipalInfo:
+      {
+        origin = NS_LITERAL_CSTRING("system");
+        break;
+      }
+      case PrincipalInfo::TNullPrincipalInfo:
+      {
+        origin = NS_LITERAL_CSTRING("null");
+        break;
+      }
+
+      // Validate content principals to ensure that the origin and spec are sane.
+      case PrincipalInfo::TContentPrincipalInfo:
+      {
+        const ContentPrincipalInfo& content =
+          mClientInfo.PrincipalInfo().get_ContentPrincipalInfo();
+        origin = content.originNoSuffix().get_nsCString();
+        break;
+      }
+      default:
+      {
+        break;
+      }
+    }
+    printf_stderr("### ### ClientSourceParent::%s origin:%s url:%s\n",
+                  __func__, origin.get(), aArgs.url().get());
+    MOZ_DIAGNOSTIC_ASSERT(false,
+      "ClientSourceParent::RecvExecutionReady() got invalid URL");
+    Unused << Send__delete__(this);
+    return IPC_OK();
+  }
+
   mClientInfo.SetURL(aArgs.url());
   mClientInfo.SetFrameType(aArgs.frameType());
   mExecutionReady = true;
 
   for (ClientHandleParent* handle : mHandleList) {
     Unused << handle->SendExecutionReady(mClientInfo.ToIPC());
   }
 
@@ -80,17 +413,17 @@ ClientSourceParent::RecvThaw()
   MOZ_DIAGNOSTIC_ASSERT(mFrozen);
   mFrozen = false;
   return IPC_OK();
 }
 
 void
 ClientSourceParent::ActorDestroy(ActorDestroyReason aReason)
 {
-  mService->RemoveSource(this);
+  Unused << mService->RemoveSource(this);
 
   nsTArray<ClientHandleParent*> handleList;
   mHandleList.SwapElements(handleList);
   for (ClientHandleParent* handle : handleList) {
     Unused << ClientHandleParent::Send__delete__(handle);
   }
 }
 
@@ -109,24 +442,76 @@ ClientSourceParent::DeallocPClientSource
 }
 
 ClientSourceParent::ClientSourceParent(const ClientSourceConstructorArgs& aArgs)
   : mClientInfo(aArgs.id(), aArgs.type(), aArgs.principalInfo(), aArgs.creationTime())
   , mService(ClientManagerService::GetOrCreateInstance())
   , mExecutionReady(false)
   , mFrozen(false)
 {
-  mService->AddSource(this);
 }
 
 ClientSourceParent::~ClientSourceParent()
 {
   MOZ_DIAGNOSTIC_ASSERT(mHandleList.IsEmpty());
 }
 
+void
+ClientSourceParent::Init()
+{
+  // Ensure the principal is reasonable before adding ourself to the service.
+  if (NS_WARN_IF(!IsValidPrincipal())) {
+    nsAutoCString origin;
+    nsAutoCString spec;
+    switch (mClientInfo.PrincipalInfo().type()) {
+      // Any system and null principal is acceptable.
+      case PrincipalInfo::TSystemPrincipalInfo:
+      {
+        origin = NS_LITERAL_CSTRING("system");
+        break;
+      }
+      case PrincipalInfo::TNullPrincipalInfo:
+      {
+        origin = NS_LITERAL_CSTRING("null");
+        break;
+      }
+
+      // Validate content principals to ensure that the origin and spec are sane.
+      case PrincipalInfo::TContentPrincipalInfo:
+      {
+        const ContentPrincipalInfo& content =
+          mClientInfo.PrincipalInfo().get_ContentPrincipalInfo();
+        origin = content.originNoSuffix().get_nsCString();
+        spec = content.spec();
+        break;
+      }
+      default:
+      {
+        break;
+      }
+    }
+    printf_stderr("### ### ClientSourceParent::%s origin:%s spec:%s\n",
+                  __func__, origin.get(), spec.get());
+    MOZ_DIAGNOSTIC_ASSERT(false,
+      "ClientSourceParent::Init() got invalid principal");
+    Unused << Send__delete__(this);
+    return;
+  }
+
+  // Its possible for AddSource() to fail if there is already an entry for
+  // our UUID.  This should not normally happen, but could if someone is
+  // spoofing IPC messages.
+  if (NS_WARN_IF(!mService->AddSource(this))) {
+    MOZ_DIAGNOSTIC_ASSERT(false,
+      "ClientSourceParent::Init() failed to add to service");
+    Unused << Send__delete__(this);
+    return;
+  }
+}
+
 bool
 ClientSourceParent::IsFrozen() const
 {
   return mFrozen;
 }
 
 const ClientInfo&
 ClientSourceParent::Info() const
diff --git a/dom/clients/manager/ClientSourceParent.h b/dom/clients/manager/ClientSourceParent.h
--- a/dom/clients/manager/ClientSourceParent.h
+++ b/dom/clients/manager/ClientSourceParent.h
@@ -21,16 +21,22 @@ class ClientSourceParent final : public 
 {
   ClientInfo mClientInfo;
   Maybe<ServiceWorkerDescriptor> mController;
   RefPtr<ClientManagerService> mService;
   nsTArray<ClientHandleParent*> mHandleList;
   bool mExecutionReady;
   bool mFrozen;
 
+  bool
+  IsValidPrincipal();
+
+  bool
+  IsValidURL(const nsACString& aURL) const;
+
   // PClientSourceParent
   mozilla::ipc::IPCResult
   RecvWorkerSyncPing() override;
 
   mozilla::ipc::IPCResult
   RecvTeardown() override;
 
   mozilla::ipc::IPCResult
@@ -53,16 +59,19 @@ class ClientSourceParent final : public 
 
   bool
   DeallocPClientSourceOpParent(PClientSourceOpParent* aActor) override;
 
 public:
   explicit ClientSourceParent(const ClientSourceConstructorArgs& aArgs);
   ~ClientSourceParent();
 
+  void
+  Init();
+
   const ClientInfo&
   Info() const;
 
   bool
   IsFrozen() const;
 
   bool
   ExecutionReady() const;
diff --git a/dom/clients/manager/moz.build b/dom/clients/manager/moz.build
--- a/dom/clients/manager/moz.build
+++ b/dom/clients/manager/moz.build
@@ -34,16 +34,17 @@ UNIFIED_SOURCES += [
   'ClientManagerParent.cpp',
   'ClientManagerService.cpp',
   'ClientNavigateOpChild.cpp',
   'ClientNavigateOpParent.cpp',
   'ClientOpenWindowOpActors.cpp',
   'ClientOpenWindowOpChild.cpp',
   'ClientOpenWindowOpParent.cpp',
   'ClientOpenWindowUtils.cpp',
+  'ClientPrefs.cpp',
   'ClientSource.cpp',
   'ClientSourceChild.cpp',
   'ClientSourceOpChild.cpp',
   'ClientSourceOpParent.cpp',
   'ClientSourceParent.cpp',
   'ClientState.cpp',
 ]
 
@@ -59,16 +60,17 @@ IPDL_SOURCES += [
   'PClientSourceOp.ipdl',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 LOCAL_INCLUDES += [
   '/dom/base',
   '/dom/workers',
+  '/netwerk/base',
 ]
 
 FINAL_LIBRARY = 'xul'
 
 MOCHITEST_MANIFESTS += [
 ]
 
 BROWSER_CHROME_MANIFESTS += [
diff --git a/dom/workers/ScriptLoader.cpp b/dom/workers/ScriptLoader.cpp
--- a/dom/workers/ScriptLoader.cpp
+++ b/dom/workers/ScriptLoader.cpp
@@ -1951,24 +1951,16 @@ ScriptExecutorRunnable::WorkerRun(JSCont
     NS_ASSERTION(!loadInfo.mChannel, "Should no longer have a channel!");
     NS_ASSERTION(loadInfo.mExecutionScheduled, "Should be scheduled!");
 
     if (!loadInfo.mExecutionResult) {
       return true;
     }
   }
 
-  if (mIsWorkerScript) {
-    if (mScriptLoader.mController.isSome()) {
-      aWorkerPrivate->Control(mScriptLoader.mController.ref());
-    }
-
-    aWorkerPrivate->ExecutionReady();
-  }
-
   // If nothing else has failed, our ErrorResult better not be a failure either.
   MOZ_ASSERT(!mScriptLoader.mRv.Failed(), "Who failed it and why?");
 
   // Slightly icky action at a distance, but there's no better place to stash
   // this value, really.
   JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
   MOZ_ASSERT(global);
 
@@ -1986,16 +1978,26 @@ ScriptExecutorRunnable::WorkerRun(JSCont
                                     loadInfo.mLoadResult, loadInfo.mURL);
       // Top level scripts only!
       if (mIsWorkerScript) {
         aWorkerPrivate->MaybeDispatchLoadFailedRunnable();
       }
       return true;
     }
 
+    // If this is a top level script that succeeded, then mark the
+    // Client execution ready and possibly controlled by a service worker.
+    if (mIsWorkerScript) {
+      if (mScriptLoader.mController.isSome()) {
+        aWorkerPrivate->Control(mScriptLoader.mController.ref());
+      }
+
+      aWorkerPrivate->ExecutionReady();
+    }
+
     NS_ConvertUTF16toUTF8 filename(loadInfo.mURL);
 
     JS::CompileOptions options(aCx);
     options.setFileAndLine(filename.get(), 1)
            .setNoScriptRval(true);
 
     if (mScriptLoader.mWorkerScriptType == DebuggerScript) {
       options.setVersion(JSVERSION_DEFAULT);
