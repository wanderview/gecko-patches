# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  a6c4561c16d60e9f6f2032f00c09d0bb4a47d3d2
Bug 1363829 P5 Add an executor class to represent the single timer executing timers for a window. r=ehsan

diff --git a/dom/base/TimeoutExecutor.cpp b/dom/base/TimeoutExecutor.cpp
new file mode 100644
--- /dev/null
+++ b/dom/base/TimeoutExecutor.cpp
@@ -0,0 +1,192 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "TimeoutExecutor.h"
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_ISUPPORTS(TimeoutExecutor, nsIRunnable, nsITimerCallback)
+
+TimeoutExecutor::~TimeoutExecutor()
+{
+  // The TimeoutManager should keep the Executor alive until its destroyed,
+  // and then call Shutdown() explicitly.
+  MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Shutdown);
+  MOZ_DIAGNOSTIC_ASSERT(!mOwner);
+  MOZ_DIAGNOSTIC_ASSERT(!mTimer);
+}
+
+nsresult
+TimeoutExecutor::ScheduleImmediate(const TimeStamp& aDeadline,
+                                   const TimeStamp& aNow)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
+  MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
+  MOZ_DIAGNOSTIC_ASSERT(aDeadline <= aNow);
+
+  nsresult rv =
+    mOwner->EventTarget()->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mMode = Mode::Immediate;
+  mDeadline = aDeadline;
+
+  return NS_OK;
+}
+
+nsresult
+TimeoutExecutor::ScheduleDelayed(const TimeStamp& aDeadline,
+                                 const TimeStamp& aNow)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mDeadline.IsNull());
+  MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::None);
+  MOZ_DIAGNOSTIC_ASSERT(aDeadline > aNow);
+
+  nsresult rv = NS_OK;
+
+  if (!mTimer) {
+    mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  // Always call Cancel() in case we are re-using a timer.  Otherwise
+  // the subsequent SetTarget() may fail.
+  rv = mTimer->Cancel();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = mTimer->SetTarget(mOwner->EventTarget());
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  TimeDuration delay = aDeadline - aNow;
+  rv = mTimer->InitWithCallback(this, delay.ToMilliseconds(),
+                                nsITimer::TYPE_ONE_SHOT);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mMode = Mode::Delayed;
+  mDeadline = aDeadline;
+
+  return NS_OK;
+}
+
+nsresult
+TimeoutExecutor::Schedule(const TimeStamp& aDeadline)
+{
+  TimeStamp now(TimeStamp::Now());
+
+  if (aDeadline <= now) {
+    return ScheduleImmediate(aDeadline, now);
+  }
+
+  return ScheduleDelayed(aDeadline, now);
+}
+
+nsresult
+TimeoutExecutor::MaybeReschedule(const TimeStamp& aDeadline)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
+  MOZ_DIAGNOSTIC_ASSERT(mMode == Mode::Immediate ||
+                        mMode == Mode::Delayed);
+
+  if (aDeadline >= mDeadline) {
+    return NS_OK;
+  }
+
+  if (mMode == Mode::Immediate) {
+    if (aDeadline < mDeadline) {
+      mDeadline = aDeadline;
+    }
+    return NS_OK;
+  }
+
+  Cancel();
+  return Schedule(aDeadline);
+}
+
+void
+TimeoutExecutor::MaybeExecute()
+{
+  // Due to cancellation races its possible to get additional executions.
+  // TimeoutManager must handle these as long as we have a deadline set.
+  // Ignore any additional executions beyond our last know deadline.
+  if (mMode == Mode::Shutdown ||
+      mMode == Mode::None) {
+    return;
+  }
+
+  MOZ_DIAGNOSTIC_ASSERT(mOwner);
+  MOZ_DIAGNOSTIC_ASSERT(!mDeadline.IsNull());
+
+  TimeStamp deadline(mDeadline);
+
+  Cancel();
+
+  mOwner->RunTimeout(deadline);
+}
+
+TimeoutExecutor::TimeoutExecutor(TimeoutManager* aOwner)
+  : mOwner(aOwner)
+  , mMode(Mode::None)
+{
+  MOZ_DIAGNOSTIC_ASSERT(mOwner);
+}
+
+void
+TimeoutExecutor::Shutdown()
+{
+  mOwner = nullptr;
+
+  if (mTimer) {
+    mTimer->Cancel();
+    mTimer = nullptr;
+  }
+
+  mMode = Mode::Shutdown;
+  mDeadline = TimeStamp();
+}
+
+nsresult
+TimeoutExecutor::MaybeSchedule(const TimeStamp& aDeadline)
+{
+  MOZ_DIAGNOSTIC_ASSERT(!aDeadline.IsNull());
+
+  if (mMode == Mode::Shutdown) {
+    return NS_OK;
+  }
+
+  if (mMode == Mode::Immediate || mMode == Mode::Delayed) {
+    return MaybeReschedule(aDeadline);
+  }
+
+  return Schedule(aDeadline);
+}
+
+void
+TimeoutExecutor::Cancel()
+{
+  if (mTimer) {
+    mTimer->Cancel();
+  }
+  mMode = Mode::None;
+  mDeadline = TimeStamp();
+}
+
+NS_IMETHODIMP
+TimeoutExecutor::Run()
+{
+  MaybeExecute();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+TimeoutExecutor::Notify(nsITimer* aTimer)
+{
+  MaybeExecute();
+  return NS_OK;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/base/TimeoutExecutor.h b/dom/base/TimeoutExecutor.h
new file mode 100644
--- /dev/null
+++ b/dom/base/TimeoutExecutor.h
@@ -0,0 +1,70 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_timeoutexecutor_h
+#define mozilla_dom_timeoutexecutor_h
+
+#include "nsIRunnable.h"
+#include "nsITimer.h"
+
+namespace mozilla {
+namespace dom {
+
+class TimeoutExecutor final : public nsIRunnable
+                            , public nsITimerCallback
+{
+  TimeoutManager* mOwner;
+  nsCOMPtr<nsITimer> mTimer;
+  TimeStamp mDeadline;
+
+  enum class Mode
+  {
+    None,
+    Immediate,
+    Delayed,
+    Shutdown
+  };
+
+  Mode mMode;
+
+  ~TimeoutExecutor();
+
+  nsresult
+  ScheduleImmediate(const TimeStamp& aDeadline, const TimeStamp& aNow);
+
+  nsresult
+  ScheduleDelayed(const TimeStamp& aDeadline, const TimeStamp& aNow);
+
+  nsresult
+  Schedule(const TimeStamp& aDeadline);
+
+  nsresult
+  MaybeReschedule(const TimeStamp& aDeadline);
+
+  void
+  MaybeExecute();
+
+public:
+  explicit TimeoutExecutor(TimeoutManager* aOwner);
+
+  void
+  Shutdown();
+
+  nsresult
+  MaybeSchedule(const TimeStamp& aDeadline);
+
+  void
+  Cancel();
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+  NS_DECL_NSITIMERCALLBACK
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_timeoutexecutor_h
diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -1515,8 +1515,14 @@ TimeoutManager::BeginSyncOperation()
 void
 TimeoutManager::EndSyncOperation()
 {
   // If we're running a timeout, restart the measurement from here.
   if (!mWindow.IsChromeWindow() && mRunningTimeout) {
     TimeoutTelemetry::Get().StartRecording(TimeStamp::Now());
   }
 }
+
+nsIEventTarget*
+TimeoutManager::EventTarget()
+{
+  return mWindow.EventTargetFor(TaskCategory::Timer);
+}
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -113,16 +113,19 @@ public:
     if (!mNormalTimeouts.ForEachAbortable(c)) {
       mTrackingTimeouts.ForEachAbortable(c);
     }
   }
 
   void BeginSyncOperation();
   void EndSyncOperation();
 
+  nsIEventTarget*
+  EventTarget();
+
   static const uint32_t InvalidFiringId;
 
 private:
   nsresult ResetTimersForThrottleReduction(int32_t aPreviousThrottleDelayMS);
   void MaybeStartThrottleTrackingTimout();
 
   bool IsBackground() const;
 
diff --git a/dom/base/moz.build b/dom/base/moz.build
--- a/dom/base/moz.build
+++ b/dom/base/moz.build
@@ -341,16 +341,17 @@ UNIFIED_SOURCES += [
     'StructuredCloneHolder.cpp',
     'StyleSheetList.cpp',
     'SubtleCrypto.cpp',
     'TabGroup.cpp',
     'Text.cpp',
     'TextInputProcessor.cpp',
     'ThirdPartyUtil.cpp',
     'Timeout.cpp',
+    'TimeoutExecutor.cpp',
     'TimeoutHandler.cpp',
     'TimeoutManager.cpp',
     'TreeWalker.cpp',
     'WebKitCSSMatrix.cpp',
     'WebSocket.cpp',
     'WindowNamedPropertiesHandler.cpp',
     'WindowOrientationObserver.cpp',
 ]
