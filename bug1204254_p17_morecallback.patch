# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  cda61e298226e2388d149dad163e850df38b2a64
Bug 1204254 P17 Do a better job of always calling the nsIInterceptedBodyCallback. r=asuth

diff --git a/netwerk/protocol/http/HttpChannelChild.cpp b/netwerk/protocol/http/HttpChannelChild.cpp
--- a/netwerk/protocol/http/HttpChannelChild.cpp
+++ b/netwerk/protocol/http/HttpChannelChild.cpp
@@ -1112,20 +1112,17 @@ HttpChannelChild::OnStopRequest(const ns
 
 void
 HttpChannelChild::DoPreOnStopRequest(nsresult aStatus)
 {
   LOG(("HttpChannelChild::DoPreOnStopRequest [this=%p status=%" PRIx32 "]\n",
        this, static_cast<uint32_t>(aStatus)));
   mIsPending = false;
 
-  if (mSynthesizedCallback) {
-    mSynthesizedCallback->BodyComplete(mStatus);
-    mSynthesizedCallback = nullptr;
-  }
+  MaybeCallSynthesizedCallback();
 
   Performance* documentPerformance = GetPerformance();
   if (documentPerformance) {
       documentPerformance->AddEntry(this, this);
   }
 
   if (!mCanceled && NS_SUCCEEDED(mStatus)) {
     mStatus = aStatus;
@@ -1401,16 +1398,18 @@ void
 HttpChannelChild::DoNotifyListenerCleanup()
 {
   LOG(("HttpChannelChild::DoNotifyListenerCleanup [this=%p]\n", this));
 
   if (mInterceptListener) {
     mInterceptListener->Cleanup();
     mInterceptListener = nullptr;
   }
+
+  MaybeCallSynthesizedCallback();
 }
 
 class DeleteSelfEvent : public NeckoTargetChannelEvent<HttpChannelChild>
 {
  public:
   explicit DeleteSelfEvent(HttpChannelChild* child)
   : NeckoTargetChannelEvent<HttpChannelChild>(child) {}
   void Run() { mChild->DeleteSelf(); }
@@ -1451,17 +1450,22 @@ HttpChannelChild::OverrideRunnable::Over
 
 NS_IMETHODIMP
 HttpChannelChild::OverrideRunnable::Run()
 {
   // Check to see if the channel was canceled in the middle of the redirect.
   nsresult rv = NS_OK;
   Unused << mChannel->GetStatus(&rv);
   if (NS_FAILED(rv)) {
+    if (mCallback) {
+      mCallback->BodyComplete(rv);
+      mCallback = nullptr;
+    }
     mChannel->CleanupRedirectingChannel(rv);
+    mNewChannel->Cancel(rv);
     return NS_OK;
   }
 
   bool ret = mChannel->Redirect3Complete(this);
 
   // If the method returns false, it means the IPDL connection is being
   // asyncly torn down and reopened, and OverrideWithSynthesizedResponse
   // will be called later from FinishInterceptedRedirect. This object will
@@ -2196,20 +2200,17 @@ HttpChannelChild::OnRedirectVerifyCallba
     }
 
     nsCOMPtr<nsIRequest> request = do_QueryInterface(mRedirectChannelChild);
     if (request) {
       request->GetLoadFlags(&loadFlags);
     }
   }
 
-  if (mSynthesizedCallback) {
-    mSynthesizedCallback->BodyComplete(mStatus);
-    mSynthesizedCallback = nullptr;
-  }
+  MaybeCallSynthesizedCallback();
 
   bool chooseAppcache = false;
   nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
     do_QueryInterface(newHttpChannel);
   if (appCacheChannel) {
     appCacheChannel->GetChooseApplicationCache(&chooseAppcache);
   }
 
@@ -3537,85 +3538,95 @@ HttpChannelChild::CancelOnMainThread(nsr
 }
 
 void
 HttpChannelChild::OverrideWithSynthesizedResponse(nsAutoPtr<nsHttpResponseHead>& aResponseHead,
                                                   nsIInputStream* aSynthesizedInput,
                                                   nsIInterceptedBodyCallback* aSynthesizedCallback,
                                                   InterceptStreamListener* aStreamListener)
 {
+  nsresult rv = NS_OK;
+
+  auto autoFireCallback = MakeScopeExit([&] {
+    if (aSynthesizedCallback) {
+      aSynthesizedCallback->BodyComplete(mStatus);
+    }
+  });
+
+  // This will be destructed before the autoFireCallback scope setting mStatus
+  // before we possibly invoke the callback.
+  auto autoCancel = MakeScopeExit([&] {
+    if (NS_FAILED(rv)) {
+      Cancel(rv);
+    }
+  });
+
+  if (NS_FAILED(mStatus)) {
+    return;
+  }
+
   mInterceptListener = aStreamListener;
 
   // Intercepted responses should already be decoded.  If its a redirect,
   // however, we want to respect the encoding of the final result instead.
   if (!nsHttpChannel::WillRedirect(aResponseHead)) {
     SetApplyConversion(false);
   }
 
   mResponseHead = aResponseHead;
   mSynthesizedResponse = true;
 
   mSynthesizedInput = aSynthesizedInput;
-  mSynthesizedCallback = aSynthesizedCallback;
 
   if (!mSynthesizedInput) {
-    nsresult rv = NS_NewCStringInputStream(getter_AddRefs(mSynthesizedInput),
-                                           EmptyCString());
-    if (NS_FAILED(rv)) {
-      Unused << AsyncAbort(rv);
-      return;
-    }
+    rv = NS_NewCStringInputStream(getter_AddRefs(mSynthesizedInput),
+                                  EmptyCString());
+    NS_ENSURE_SUCCESS_VOID(rv);
   }
 
   if (nsHttpChannel::WillRedirect(mResponseHead)) {
     mShouldInterceptSubsequentRedirect = true;
     // Continue with the original cross-process request
-    nsresult rv = ContinueAsyncOpen();
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      rv = AsyncAbort(rv);
-      MOZ_ASSERT(NS_SUCCEEDED(rv));
-    }
+    rv = ContinueAsyncOpen();
     return;
   }
 
   // For progress we trust the content-length for the "maximum" size.
   // We can't determine the full size from the stream itself since we
   // only receive the data incrementally.  We can't trust Available()
   // here.
   // TODO: We could implement an nsIFixedLengthInputStream interface and
   //       QI to it here.  This would let us determine the total length
   //       for streams that support it.  See bug 1388774.
-  nsresult rv = GetContentLength(&mSynthesizedStreamLength);
+  rv = GetContentLength(&mSynthesizedStreamLength);
   if (NS_FAILED(rv)) {
     mSynthesizedStreamLength = -1;
   }
 
   nsCOMPtr<nsIEventTarget> neckoTarget = GetNeckoTarget();
   MOZ_ASSERT(neckoTarget);
 
   rv = nsInputStreamPump::Create(getter_AddRefs(mSynthesizedResponsePump),
                                  mSynthesizedInput, 0, 0, true, neckoTarget);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    mSynthesizedInput->Close();
-    return;
-  }
+  NS_ENSURE_SUCCESS_VOID(rv);
 
   rv = mSynthesizedResponsePump->AsyncRead(aStreamListener, nullptr);
   NS_ENSURE_SUCCESS_VOID(rv);
 
+  mSynthesizedCallback = aSynthesizedCallback;
+  autoFireCallback.release();
+
   // if this channel has been suspended previously, the pump needs to be
   // correspondingly suspended now that it exists.
   for (uint32_t i = 0; i < mSuspendCount; i++) {
     rv = mSynthesizedResponsePump->Suspend();
     NS_ENSURE_SUCCESS_VOID(rv);
   }
 
-  if (mCanceled) {
-    mSynthesizedResponsePump->Cancel(mStatus);
-  }
+  MOZ_DIAGNOSTIC_ASSERT(!mCanceled);
 }
 
 NS_IMETHODIMP
 HttpChannelChild::ForceIntercepted(bool aPostRedirectChannelShouldIntercept,
                                    bool aPostRedirectChannelShouldUpgrade)
 {
   mShouldParentIntercept = true;
   mPostRedirectChannelShouldIntercept = aPostRedirectChannelShouldIntercept;
@@ -3728,10 +3739,21 @@ HttpChannelChild::SynthesizeResponseStar
 }
 
 void
 HttpChannelChild::SynthesizeResponseEndTime(const TimeStamp& aTime)
 {
   mTransactionTimings.responseEnd = aTime;
 }
 
+void
+HttpChannelChild::MaybeCallSynthesizedCallback()
+{
+  if (!mSynthesizedCallback) {
+    return;
+  }
+
+  mSynthesizedCallback->BodyComplete(mStatus);
+  mSynthesizedCallback = nullptr;
+}
+
 } // namespace net
 } // namespace mozilla
diff --git a/netwerk/protocol/http/HttpChannelChild.h b/netwerk/protocol/http/HttpChannelChild.h
--- a/netwerk/protocol/http/HttpChannelChild.h
+++ b/netwerk/protocol/http/HttpChannelChild.h
@@ -282,16 +282,19 @@ private:
   void CancelOnMainThread(nsresult aRv);
 
   void
   SynthesizeResponseStartTime(const TimeStamp& aTime);
 
   void
   SynthesizeResponseEndTime(const TimeStamp& aTime);
 
+  void
+  MaybeCallSynthesizedCallback();
+
   RequestHeaderTuples mClientSetRequestHeaders;
   RefPtr<nsInputStreamPump> mSynthesizedResponsePump;
   nsCOMPtr<nsIInputStream> mSynthesizedInput;
   nsCOMPtr<nsIInterceptedBodyCallback> mSynthesizedCallback;
   int64_t mSynthesizedStreamLength;
 
   bool mIsFromCache;
   bool mCacheEntryAvailable;
diff --git a/netwerk/protocol/http/InterceptedChannel.cpp b/netwerk/protocol/http/InterceptedChannel.cpp
--- a/netwerk/protocol/http/InterceptedChannel.cpp
+++ b/netwerk/protocol/http/InterceptedChannel.cpp
@@ -329,19 +329,17 @@ InterceptedChannelContent::CancelInterce
   MOZ_ASSERT(NS_FAILED(aStatus));
 
   if (mClosed) {
     return NS_ERROR_FAILURE;
   }
 
   mReportCollector->FlushConsoleReports(mChannel);
 
-  // we need to use AsyncAbort instead of Cancel since there's no active pump
-  // to cancel which will provide OnStart/OnStopRequest to the channel.
-  nsresult rv = mChannel->AsyncAbort(aStatus);
+  nsresult rv = mChannel->Cancel(aStatus);
   NS_ENSURE_SUCCESS(rv, rv);
   mStreamListener = nullptr;
   mClosed = true;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
diff --git a/netwerk/protocol/http/InterceptedHttpChannel.cpp b/netwerk/protocol/http/InterceptedHttpChannel.cpp
--- a/netwerk/protocol/http/InterceptedHttpChannel.cpp
+++ b/netwerk/protocol/http/InterceptedHttpChannel.cpp
@@ -247,16 +247,18 @@ InterceptedHttpChannel::StartPump()
   rv = mPump->AsyncRead(this, mListenerContext);
   NS_ENSURE_SUCCESS(rv, rv);
 
   uint32_t suspendCount = mSuspendCount;
   while (suspendCount--) {
     mPump->Suspend();
   }
 
+  MOZ_DIAGNOSTIC_ASSERT(!mCanceled);
+
   return rv;
 }
 
 nsresult
 InterceptedHttpChannel::OpenRedirectChannel()
 {
   nsresult rv = NS_OK;
 
@@ -658,71 +660,91 @@ InterceptedHttpChannel::SynthesizeHeader
   return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::StartSynthesizedResponse(nsIInputStream* aBody,
                                                  nsIInterceptedBodyCallback* aBodyCallback,
                                                  const nsACString& aFinalURLSpec)
 {
-  if (mCanceled) {
+  nsresult rv = NS_OK;
+
+  auto fireCallback = MakeScopeExit([&] {
     if (aBodyCallback) {
       aBodyCallback->BodyComplete(mStatus);
     }
+  });
 
+  // This will be destructed before the autoFireCallback scope setting mStatus
+  // before we possibly invoke the callback.  Make sure to always assign rv
+  // and avoid returning another method result directly.
+  auto autoCancel = MakeScopeExit([&] {
+    if (NS_FAILED(rv)) {
+      Cancel(rv);
+    }
+  });
+
+  if (mCanceled) {
     // Return NS_OK.  The channel should fire callbacks with an error code
     // if it was cancelled before this point.
     return NS_OK;
   }
 
-  // Take ownership of the body callbacks  We expect that if a failure
-  // occurs here our caller will call Cancel().  This will then invoke
-  // OnStopRequest() which will invoke the correct callback.  We also
-  // invoke callbacks if we skip reading the body due to following a
-  // redirect, etc.  In the case of an opaque response redirect we pass
-  // ownership of the callbacks to the new channel.
+  // Take ownership of the body callbacks.  If a failure occurs we will
+  // automatically Cancel() the channel.  This will then invoke OnStopRequest()
+  // which will invoke the correct callback.  In the case of an opaque response
+  // redirect we pass ownership of the callbacks to the new channel.
   mBodyCallback = aBodyCallback;
+  fireCallback.release();
 
   if (!mSynthesizedResponseHead) {
     mSynthesizedResponseHead.reset(new nsHttpResponseHead());
   }
 
   mResponseHead = mSynthesizedResponseHead.release();
 
   if (ShouldRedirect()) {
-    return FollowSyntheticRedirect();
+    rv = FollowSyntheticRedirect();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
   }
 
   // Intercepted responses should already be decoded.
   SetApplyConversion(false);
 
   // Errors and redirects may not have a body.  Synthesize an empty string stream
   // here so later code can be simpler.
   mBodyReader = aBody;
   if (!mBodyReader) {
-    nsresult rv = NS_NewCStringInputStream(getter_AddRefs(mBodyReader),
-                                           EmptyCString());
+    rv = NS_NewCStringInputStream(getter_AddRefs(mBodyReader), EmptyCString());
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   nsCOMPtr<nsIURI> responseURI;
   if (!aFinalURLSpec.IsEmpty()) {
-    nsresult rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
+    rv = NS_NewURI(getter_AddRefs(responseURI), aFinalURLSpec);
     NS_ENSURE_SUCCESS(rv, rv);
   } else {
     responseURI = mURI;
   }
 
   bool equal = false;
   Unused << mURI->Equals(responseURI, &equal);
   if (!equal) {
-    return RedirectForOpaqueResponse(responseURI);
+    rv = RedirectForOpaqueResponse(responseURI);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
   }
 
-  return StartPump();
+  rv = StartPump();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 InterceptedHttpChannel::FinishSynthesizedResponse()
 {
   if (mCanceled) {
     // Return NS_OK.  The channel should fire callbacks with an error code
     // if it was cancelled before this point.
