# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  91c943f7373722ad4e122d98a2ddd6c79708b732
Bug 1379243 P1 Make WorkerControlEventTarget implement nsISerialEventTarget. r=baku

diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -1623,17 +1623,17 @@ public:
     return NS_OK;
   }
 };
 
 } // anonymous namespace
 
 BEGIN_WORKERS_NAMESPACE
 
-class WorkerControlEventTarget final : public nsIEventTarget
+class WorkerControlEventTarget final : public nsISerialEventTarget
 {
   mozilla::Mutex mMutex;
   WorkerPrivate* mWorkerPrivate;
 
   ~WorkerControlEventTarget() = default;
 
 public:
   explicit WorkerControlEventTarget(WorkerPrivate* aWorkerPrivate)
@@ -1699,17 +1699,18 @@ public:
     MOZ_ASSERT(aIsOnCurrentThread);
     *aIsOnCurrentThread = IsOnCurrentThreadInfallible();
     return NS_OK;
   }
 
   NS_DECL_THREADSAFE_ISUPPORTS
 };
 
-NS_IMPL_ISUPPORTS(WorkerControlEventTarget, nsIEventTarget)
+NS_IMPL_ISUPPORTS(WorkerControlEventTarget, nsIEventTarget,
+                                            nsISerialEventTarget)
 
 END_WORKERS_NAMESPACE
 
 WorkerLoadInfo::WorkerLoadInfo()
   : mLoadFlags(nsIRequest::LOAD_NORMAL)
   , mWindowID(UINT64_MAX)
   , mServiceWorkerID(0)
   , mReferrerPolicy(net::RP_Unset)
@@ -5184,17 +5185,17 @@ WorkerPrivate::DispatchToMainThread(alre
 {
   nsCOMPtr<nsIRunnable> runnable = aRunnable;
   if (nsCOMPtr<nsINamed> named = do_QueryInterface(runnable)) {
     named->SetName("WorkerRunnable");
   }
   return mMainThreadEventTarget->Dispatch(runnable.forget(), aFlags);
 }
 
-nsIEventTarget*
+nsISerialEventTarget*
 WorkerPrivate::ControlEventTarget()
 {
   return mWorkerControlEventTarget;
 }
 
 void
 WorkerPrivate::InitializeGCTimers()
 {
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1456,17 +1456,17 @@ public:
 
   nsresult
   DispatchToMainThread(already_AddRefed<nsIRunnable> aRunnable,
                        uint32_t aFlags = NS_DISPATCH_NORMAL);
 
   // Get an event target that will dispatch runnables as control runnables on
   // the worker thread.  Implement nsICancelableRunnable if you wish to take
   // action on cancelation.
-  nsIEventTarget*
+  nsISerialEventTarget*
   ControlEventTarget();
 
 private:
   WorkerPrivate(WorkerPrivate* aParent,
                 const nsAString& aScriptURL, bool aIsChromeWorker,
                 WorkerType aWorkerType, const nsAString& aWorkerName,
                 const nsACString& aServiceWorkerScope,
                 WorkerLoadInfo& aLoadInfo);
