# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  c794842b1ccf223698130dd9ac790b704c7410c6

diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1512,42 +1512,16 @@ ServiceWorkerManager::GetActiveWorkerInf
 
   if (!registration) {
     return nullptr;
   }
 
   return registration->GetActive();
 }
 
-ServiceWorkerInfo*
-ServiceWorkerManager::GetActiveWorkerInfoForDescriptor(const ServiceWorkerDescriptor& aDesc)
-{
-  AssertIsOnMainThread();
-
-  nsCOMPtr<nsIPrincipal> principal =
-    PrincipalInfoToPrincipal(aDesc.PrincipalInfo());
-
-  nsCOMPtr<nsIURI> scope;
-  nsresult rv = NS_NewURI(getter_AddRefs(scope), aDesc.Scope());
-  NS_ENSURE_SUCCESS(rv, nullptr);
-
-  RefPtr<ServiceWorkerRegistrationInfo> registration =
-    GetServiceWorkerRegistrationInfo(principal, scope);
-  if (!registration) {
-    return nullptr;
-  }
-
-  ServiceWorkerInfo* info = registration->GetActive();
-  if (info->ID() != aDesc.Id()) {
-    return nullptr;
-  }
-
-  return info;
-}
-
 namespace {
 
 class UnregisterJobCallback final : public ServiceWorkerJob::Callback
 {
   nsCOMPtr<nsIServiceWorkerUnregisterCallback> mCallback;
 
   ~UnregisterJobCallback()
   {
@@ -2014,16 +1988,35 @@ ServiceWorkerManager::PrincipalToScopeKe
   nsresult rv = aPrincipal->GetOrigin(aKey);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
   return NS_OK;
 }
 
+/* static */ nsresult
+ServiceWorkerManager::PrincipalInfoToScopeKey(const PrincipalInfo& aPrincipalInfo,
+                                              nsACString& aKey)
+{
+  if (!aPrincipalInfo.type() != PrincipalInfo::TContentPrincipalInfo) {
+    return NS_ERROR_FAILURE;
+  }
+
+  auto content = aPrincipalInfo.get_ContentPrincipalInfo();
+
+  nsAutoCString suffix;
+  content.attr().CreateSuffix(suffix);
+
+  aKey = content.originNoSuffix();
+  aKey.Append(suffix);
+
+  return NS_OK;
+}
+
 /* static */ void
 ServiceWorkerManager::AddScopeAndRegistration(const nsACString& aScope,
                                               ServiceWorkerRegistrationInfo* aInfo)
 {
   MOZ_ASSERT(aInfo);
   MOZ_ASSERT(aInfo->mPrincipal);
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
@@ -2492,18 +2485,31 @@ ServiceWorkerManager::DispatchFetchEvent
 
   if (!nsContentUtils::IsNonSubresourceRequest(internalChannel)) {
     const Maybe<ServiceWorkerDescriptor>& controller = loadInfo->GetController();
     if (NS_WARN_IF(controller.isNothing())) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
-    serviceWorker = GetActiveWorkerInfoForDescriptor(controller.ref());
-    if (NS_WARN_IF(!serviceWorker)) {
+    aRv = PrincipalToScopeKey(controller.ref().PrincipalInfo(), scopeKey);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return;
+    }
+
+    RefPtr<ServiceWorkerRegistrationInfo> registration =
+      GetRegistration(scopeKey, controller.ref().Scope());
+    if (NS_WARN_IF(!registration)) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return;
+    }
+
+    serviceWorker = registration->GetActive();
+    if (NS_WARN_IF(!serviceWorker) ||
+        NS_WARN_IF(serviceWorker->Descriptor().Id() != controller.ref().Id())) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
   } else {
     nsCOMPtr<nsIURI> uri;
     aRv = aChannel->GetSecureUpgradedChannelURI(getter_AddRefs(uri));
     if (NS_WARN_IF(aRv.Failed())) {
       return;
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -355,19 +355,16 @@ private:
 
   ServiceWorkerInfo*
   GetActiveWorkerInfoForScope(const OriginAttributes& aOriginAttributes,
                               const nsACString& aScope);
 
   ServiceWorkerInfo*
   GetActiveWorkerInfoForDocument(nsIDocument* aDocument);
 
-  ServiceWorkerInfo*
-  GetActiveWorkerInfoForDescriptor(const ServiceWorkerDescriptor& aDesc);
-
   void
   TransitionServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOne);
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
 
   void
@@ -390,16 +387,19 @@ private:
                                    nsIURI* aURI);
 
   // This method generates a key using appId and isInElementBrowser from the
   // principal. We don't use the origin because it can change during the
   // loading.
   static nsresult
   PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aKey);
 
+  static nsresult
+  PrincipalInfoToScopeKey(const PrincipalInfo& aPrincipalInfo, nsACString& aKey);
+
   static void
   AddScopeAndRegistration(const nsACString& aScope,
                           ServiceWorkerRegistrationInfo* aRegistation);
 
   static bool
   FindScopeForPath(const nsACString& aScopeKey,
                    const nsACString& aPath,
                    RegistrationDataPerPrincipal** aData, nsACString& aMatch);
