# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  f35ec25489cb8e7fe95b9a0aae20ba9a84076fe6

diff --git a/dom/serviceworkers/ServiceWorkerContainer.cpp b/dom/serviceworkers/ServiceWorkerContainer.cpp
--- a/dom/serviceworkers/ServiceWorkerContainer.cpp
+++ b/dom/serviceworkers/ServiceWorkerContainer.cpp
@@ -281,26 +281,56 @@ ServiceWorkerContainer::GetRegistration(
 
 Promise*
 ServiceWorkerContainer::GetReady(ErrorResult& aRv)
 {
   if (mReadyPromise) {
     return mReadyPromise;
   }
 
-  nsCOMPtr<nsIServiceWorkerManager> swm = mozilla::services::GetServiceWorkerManager();
+  nsCOMPtr<nsIGlobalObject> global = GetParentObject();
+  if (!global) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  Maybe<ClientInfo> clientInfo(global->GetClientInfo());
+  if (clientInfo.isNothing()) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return nullptr;
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   if (!swm) {
-    aRv.Throw(NS_ERROR_FAILURE);
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return nullptr;
   }
 
-  nsCOMPtr<nsISupports> promise;
-  aRv = swm->GetReadyPromise(GetOwner(), getter_AddRefs(promise));
+  mReadyPromise = Promise::Create(GetParentObject(), aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
 
-  mReadyPromise = static_cast<Promise*>(promise.get());
+  RefPtr<Promise> outer = mReadyPromise;
+  swm->OnReady(clientInfo.ref())->Then(
+    global->EventTargetFor(TaskCategory::Other), __func__,
+    [outer, global] (const ServiceWorkerRegistrationDescriptor& aDescriptor) {
+      // TODO: don't require window here
+      nsCOMPtr<nsPIDOMWindowInner> window(do_QueryInterface(global));
+      NS_ENSURE_TRUE_VOID(window);
+      RefPtr<ServiceWorkerRegistration> reg =
+        window->GetServiceWorkerRegistration(aDescriptor);
+      NS_ENSURE_TRUE_VOID(reg);
+      outer->MaybeResolve(reg);
+    }, [outer] (nsresult aRv) {
+      outer->MaybeReject(aRv);
+    });
+
+  // TODO: track the MozPromise and disconnect when destroyed
+
   return mReadyPromise;
 }
 
 // Testing only.
 void
 ServiceWorkerContainer::GetScopeForUrl(const nsAString& aUrl,
                                        nsString& aScope,
                                        ErrorResult& aRv)
diff --git a/dom/serviceworkers/ServiceWorkerManager.cpp b/dom/serviceworkers/ServiceWorkerManager.cpp
--- a/dom/serviceworkers/ServiceWorkerManager.cpp
+++ b/dom/serviceworkers/ServiceWorkerManager.cpp
@@ -1433,29 +1433,69 @@ ServiceWorkerManager::StorePendingReadyP
 
   // We should not have 2 pending promises for the same window.
   MOZ_ASSERT(!mPendingReadyPromises.Get(aWindow, &data));
 
   data = new PendingReadyPromise(aURI, aPromise);
   mPendingReadyPromises.Put(aWindow, data);
 }
 
+RefPtr<ServiceWorkerRegistrationPromise>
+ServiceWorkerManager::OnReady(const ClientInfo& aClientInfo)
+{
+  AssertIsOnMainThread();
+
+  for (auto &prd : mPendingReadyList) {
+    if (prd->mClientInfo.Id() == aClientInfo.Id() &&
+        prd->mClientInfo.PrincipalInfo() == aClientInfo.PrincipalInfo()) {
+      return prd->mPromise;
+    }
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> reg =
+    GetServiceWorkerRegistrationInfo(aClientInfo);
+  if (reg && reg->GetActive()) {
+    return ServiceWorkerRegistrationPromise::CreateAndResolve(reg->Descriptor(),
+                                                              __func__);
+  }
+
+  // TODO: Use ClientHandle::OnDetach() to clean this list up.
+
+  mPendingReadyList.AppendElement(MakeUnique<PendingReadyData>(aClientInfo));
+  return mPendingReadyList.LastElement()->mPromise;
+}
+
 void
 ServiceWorkerManager::CheckPendingReadyPromises()
 {
   for (auto iter = mPendingReadyPromises.Iter(); !iter.Done(); iter.Next()) {
     nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(iter.Key());
     MOZ_ASSERT(window);
 
     nsAutoPtr<PendingReadyPromise>& pendingReadyPromise = iter.Data();
     if (CheckReadyPromise(window, pendingReadyPromise->mURI,
                           pendingReadyPromise->mPromise)) {
       iter.Remove();
     }
   }
+
+  nsTArray<UniquePtr<PendingReadyData>> pendingReadyList;
+  mPendingReadyList.SwapElements(pendingReadyList);
+  for (uint32_t i = 0; i < pendingReadyList.Length(); ++i) {
+    UniquePtr<PendingReadyData> prd(Move(pendingReadyList[i]));
+
+    RefPtr<ServiceWorkerRegistrationInfo> reg =
+      GetServiceWorkerRegistrationInfo(prd->mClientInfo);
+
+    if (reg && reg->GetActive()) {
+      prd->mPromise->Resolve(reg->Descriptor(), __func__);
+    } else {
+      mPendingReadyList.AppendElement(Move(prd));
+    }
+  }
 }
 
 bool
 ServiceWorkerManager::CheckReadyPromise(nsPIDOMWindowInner* aWindow,
                                         nsIURI* aURI, Promise* aPromise)
 {
   MOZ_ASSERT(aWindow);
   MOZ_ASSERT(aURI);
@@ -1891,43 +1931,57 @@ ServiceWorkerManager::StoreRegistration(
                                                     &principalInfo)))) {
     return;
   }
 
   mActor->SendRegister(data);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
-ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow)
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow) const
 {
   MOZ_ASSERT(aWindow);
   nsCOMPtr<nsIDocument> document = aWindow->GetExtantDoc();
   return GetServiceWorkerRegistrationInfo(document);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
-ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIDocument* aDoc)
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIDocument* aDoc) const
 {
   MOZ_ASSERT(aDoc);
   nsCOMPtr<nsIURI> documentURI = aDoc->GetDocumentURI();
   nsCOMPtr<nsIPrincipal> principal = aDoc->NodePrincipal();
   RefPtr<ServiceWorkerRegistrationInfo> reg =
     GetServiceWorkerRegistrationInfo(principal, documentURI);
   if (reg) {
     auto storageAllowed = nsContentUtils::StorageAllowedForDocument(aDoc);
     if (storageAllowed != nsContentUtils::StorageAccess::eAllow) {
       reg = nullptr;
     }
   }
   return reg.forget();
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
+ServiceWorkerManager::GetServiceWorkerRegistrationInfo(const ClientInfo& aClientInfo) const
+{
+  nsCOMPtr<nsIPrincipal> principal = aClientInfo.GetPrincipal();
+  NS_ENSURE_TRUE(principal, nullptr);
+
+  nsCOMPtr<nsIURI> uri;
+  nsresult rv = NS_NewURI(getter_AddRefs(uri), aClientInfo.URL(),
+                          nullptr, nullptr);
+  NS_ENSURE_SUCCESS(rv, nullptr);
+
+  return GetServiceWorkerRegistrationInfo(principal, uri);
+}
+
+already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal,
-                                                       nsIURI* aURI)
+                                                       nsIURI* aURI) const
 {
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(aURI);
 
   //XXXnsm Temporary fix until Bug 1171432 is fixed.
   if (NS_WARN_IF(BasePrincipal::Cast(aPrincipal)->AppId() == nsIScriptSecurityManager::UNKNOWN_APP_ID)) {
     return nullptr;
   }
@@ -1938,17 +1992,17 @@ ServiceWorkerManager::GetServiceWorkerRe
     return nullptr;
   }
 
   return GetServiceWorkerRegistrationInfo(scopeKey, aURI);
 }
 
 already_AddRefed<ServiceWorkerRegistrationInfo>
 ServiceWorkerManager::GetServiceWorkerRegistrationInfo(const nsACString& aScopeKey,
-                                                       nsIURI* aURI)
+                                                       nsIURI* aURI) const
 {
   MOZ_ASSERT(aURI);
 
   nsAutoCString spec;
   nsresult rv = aURI->GetSpec(spec);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return nullptr;
   }
diff --git a/dom/serviceworkers/ServiceWorkerManager.h b/dom/serviceworkers/ServiceWorkerManager.h
--- a/dom/serviceworkers/ServiceWorkerManager.h
+++ b/dom/serviceworkers/ServiceWorkerManager.h
@@ -21,16 +21,17 @@
 #include "mozilla/UniquePtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "mozilla/dom/ClientHandle.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/dom/ServiceWorkerRegistrarTypes.h"
 #include "mozilla/dom/ServiceWorkerRegistrationInfo.h"
+#include "mozilla/dom/ServiceWorkerUtils.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "nsClassHashtable.h"
 #include "nsDataHashtable.h"
 #include "nsRefPtrHashtable.h"
 #include "nsTArrayForwardDeclare.h"
 #include "nsTObserverArray.h"
 
 class nsIConsoleReportCollector;
@@ -114,16 +115,29 @@ public:
       : mClientHandle(aClientHandle)
       , mRegistrationInfo(aRegistrationInfo)
     {
     }
   };
 
   nsClassHashtable<nsIDHashKey, ControlledClientData> mControlledClients;
 
+  struct PendingReadyData
+  {
+    const ClientInfo mClientInfo;
+    RefPtr<ServiceWorkerRegistrationPromise::Private> mPromise;
+
+    explicit PendingReadyData(const ClientInfo& aClientInfo)
+      : mClientInfo(aClientInfo)
+      , mPromise(new ServiceWorkerRegistrationPromise::Private(__func__))
+    { }
+  };
+
+  nsTArray<UniquePtr<PendingReadyData>> mPendingReadyList;
+
   bool
   IsAvailable(nsIPrincipal* aPrincipal, nsIURI* aURI);
 
   // Return true if the given content process could potentially be executing
   // service worker code with the given principal.  At the current time, this
   // just means that we have any registration for the origin, regardless of
   // scope.  This is a very weak guarantee but is the best we can do when push
   // notifications can currently spin up a service worker in content processes
@@ -305,16 +319,19 @@ public:
                 const Maybe<nsTArray<uint8_t>>& aData);
 
   nsresult
   NotifyUnregister(nsIPrincipal* aPrincipal, const nsAString& aScope);
 
   void
   WorkerIsIdle(ServiceWorkerInfo* aWorker);
 
+  RefPtr<ServiceWorkerRegistrationPromise>
+  OnReady(const ClientInfo& aClient);
+
   void
   CheckPendingReadyPromises();
 
 private:
   ServiceWorkerManager();
   ~ServiceWorkerManager();
 
   void
@@ -363,27 +380,30 @@ private:
 
   void
   NotifyServiceWorkerRegistrationRemoved(ServiceWorkerRegistrationInfo* aRegistration);
 
   void
   StopControllingRegistration(ServiceWorkerRegistrationInfo* aRegistration);
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow);
+  GetServiceWorkerRegistrationInfo(nsPIDOMWindowInner* aWindow) const;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetServiceWorkerRegistrationInfo(nsIDocument* aDoc);
+  GetServiceWorkerRegistrationInfo(nsIDocument* aDoc) const;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
-  GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal, nsIURI* aURI);
+  GetServiceWorkerRegistrationInfo(const ClientInfo& aClientInfo) const;
+
+  already_AddRefed<ServiceWorkerRegistrationInfo>
+  GetServiceWorkerRegistrationInfo(nsIPrincipal* aPrincipal, nsIURI* aURI) const;
 
   already_AddRefed<ServiceWorkerRegistrationInfo>
   GetServiceWorkerRegistrationInfo(const nsACString& aScopeKey,
-                                   nsIURI* aURI);
+                                   nsIURI* aURI) const;
 
   // This method generates a key using appId and isInElementBrowser from the
   // principal. We don't use the origin because it can change during the
   // loading.
   static nsresult
   PrincipalToScopeKey(nsIPrincipal* aPrincipal, nsACString& aKey);
 
   static nsresult
diff --git a/dom/serviceworkers/ServiceWorkerUtils.h b/dom/serviceworkers/ServiceWorkerUtils.h
--- a/dom/serviceworkers/ServiceWorkerUtils.h
+++ b/dom/serviceworkers/ServiceWorkerUtils.h
@@ -1,18 +1,25 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ServiceWorkerUtils_h
 #define _mozilla_dom_ServiceWorkerUtils_h
 
+#include "mozilla/MozPromise.h"
+
 namespace mozilla {
 namespace dom {
 
+class ServiceWorkerRegistrationDescriptor;
+
+typedef MozPromise<ServiceWorkerRegistrationDescriptor, nsresult, false>
+        ServiceWorkerRegistrationPromise;
+
 bool
 ServiceWorkerParentInterceptEnabled();
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ServiceWorkerUtils_h
