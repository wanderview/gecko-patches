# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  6a5f1b76c76e950ddddf0f07e615192848cffa23
Bug 1371787 P4 Pass Timeout to DOMMinTimeoutValue(). r=ehsan

diff --git a/dom/base/TimeoutManager.cpp b/dom/base/TimeoutManager.cpp
--- a/dom/base/TimeoutManager.cpp
+++ b/dom/base/TimeoutManager.cpp
@@ -224,18 +224,19 @@ TimeoutManager::IsInvalidFiringId(uint32
   // in the stack.  This could be slow for a large stack, but that
   // should be rare.  It can only happen with deeply nested event
   // loop spinning.  For example, a page that does a lot of timers
   // and a lot of sync XHRs within those timers could be slow here.
   return !mFiringIdStack.Contains(aFiringId);
 }
 
 int32_t
-TimeoutManager::DOMMinTimeoutValue(bool aIsTracking) const {
-  bool throttleTracking = aIsTracking && mThrottleTrackingTimeouts;
+TimeoutManager::DOMMinTimeoutValue(Timeout* aTimeout) const {
+  MOZ_DIAGNOSTIC_ASSERT(aTimeout);
+  bool throttleTracking = aTimeout->mIsTracking && mThrottleTrackingTimeouts;
   auto minValue = throttleTracking ? gMinTrackingTimeoutValue
                                    : gMinClampTimeoutValue;
   return minValue;
 }
 
 #define TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY 0 // Consider all timeouts coming from tracking scripts as tracking
 // These strategies are useful for testing.
 #define ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY        1 // Consider all timeouts as normal
@@ -422,17 +423,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
 
   // Now clamp the actual interval we will use for the timer based on
   uint32_t realInterval = interval;
   if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL ||
       timeout->mIsTracking) {
     // Don't allow timeouts less than DOMMinTimeoutValue() from
     // now...
     realInterval = std::max(realInterval,
-                            uint32_t(DOMMinTimeoutValue(timeout->mIsTracking)));
+                            uint32_t(DOMMinTimeoutValue(timeout)));
   }
 
   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
   timeout->SetWhenOrTimeRemaining(TimeStamp::Now(), delta);
 
   // If we're not suspended, then set the timer.
   if (!mWindow.IsSuspended()) {
     nsresult rv = mExecutor->MaybeSchedule(timeout->When(),
@@ -472,17 +473,17 @@ TimeoutManager::SetTimeout(nsITimeoutHan
   *aReturn = timeout->mTimeoutId;
 
   MOZ_LOG(gLog, LogLevel::Debug,
           ("Set%s(TimeoutManager=%p, timeout=%p, delay=%i, "
            "minimum=%i, throttling=%s, background=%d, realInterval=%i) "
            "returned %stracking timeout ID %u\n",
            aIsInterval ? "Interval" : "Timeout",
            this, timeout.get(), interval,
-           DOMMinTimeoutValue(timeout->mIsTracking),
+           DOMMinTimeoutValue(timeout),
            mThrottleTrackingTimeouts ? "yes"
                                      : (mThrottleTrackingTimeoutsTimer ?
                                           "pending" : "no"),
            int(IsBackground()), realInterval,
            timeout->mIsTracking ? "" : "non-",
            timeout->mTimeoutId));
 
   return NS_OK;
@@ -801,17 +802,17 @@ TimeoutManager::RescheduleTimeout(Timeou
     return false;
   }
 
   // Compute time to next timeout for interval timer.
   // Make sure nextInterval is at least DOMMinTimeoutValue().
   TimeDuration nextInterval =
     TimeDuration::FromMilliseconds(
         std::max(aTimeout->mInterval,
-                 uint32_t(DOMMinTimeoutValue(aTimeout->mIsTracking))));
+                 uint32_t(DOMMinTimeoutValue(aTimeout))));
 
   TimeStamp firingTime = now + nextInterval;
 
   TimeStamp currentNow = TimeStamp::Now();
   TimeDuration delay = firingTime - currentNow;
 
   // And make sure delay is nonnegative; that might happen if the timer
   // thread is firing our timers somewhat early or if they're taking a long
diff --git a/dom/base/TimeoutManager.h b/dom/base/TimeoutManager.h
--- a/dom/base/TimeoutManager.h
+++ b/dom/base/TimeoutManager.h
@@ -50,17 +50,17 @@ public:
   // The timeout implementation functions.
   void RunTimeout(const TimeStamp& aNow, const TimeStamp& aTargetDeadline);
   // Return true if |aTimeout| needs to be reinserted into the timeout list.
   bool RescheduleTimeout(mozilla::dom::Timeout* aTimeout, const TimeStamp& now);
 
   void ClearAllTimeouts();
   uint32_t GetTimeoutId(mozilla::dom::Timeout::Reason aReason);
 
-  int32_t DOMMinTimeoutValue(bool aIsTracking) const;
+  int32_t DOMMinTimeoutValue(Timeout* aTimeout) const;
 
   // aTimeout is the timeout that we're about to start running.  This function
   // returns the current timeout.
   mozilla::dom::Timeout* BeginRunningTimeout(mozilla::dom::Timeout* aTimeout);
   // aTimeout is the last running timeout.
   void EndRunningTimeout(mozilla::dom::Timeout* aTimeout);
 
   void UnmarkGrayTimers();
