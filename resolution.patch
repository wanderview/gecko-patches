# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  eb6a446ef5c391ed6ee48a62ed84f6be84a71556

diff --git a/xpcom/threads/TimerThread.cpp b/xpcom/threads/TimerThread.cpp
--- a/xpcom/threads/TimerThread.cpp
+++ b/xpcom/threads/TimerThread.cpp
@@ -361,58 +361,23 @@ TimerThread::Shutdown()
   mThread->Shutdown();    // wait for the thread to die
 
   nsTimerEvent::Shutdown();
 
   MOZ_LOG(GetTimerLog(), LogLevel::Debug, ("TimerThread::Shutdown end\n"));
   return NS_OK;
 }
 
-namespace {
-
-struct MicrosecondsToInterval
-{
-  PRIntervalTime operator[](size_t aMs) const {
-    return PR_MicrosecondsToInterval(aMs);
-  }
-};
-
-struct IntervalComparator
-{
-  int operator()(PRIntervalTime aInterval) const {
-    return (0 < aInterval) ? -1 : 1;
-  }
-};
-
-} // namespace
-
 NS_IMETHODIMP
 TimerThread::Run()
 {
   NS_SetCurrentThreadName("Timer");
 
   MonitorAutoLock lock(mMonitor);
 
-  // We need to know how many microseconds give a positive PRIntervalTime. This
-  // is platform-dependent and we calculate it at runtime, finding a value |v|
-  // such that |PR_MicrosecondsToInterval(v) > 0| and then binary-searching in
-  // the range [0, v) to find the ms-to-interval scale.
-  uint32_t usForPosInterval = 1;
-  while (PR_MicrosecondsToInterval(usForPosInterval) == 0) {
-    usForPosInterval <<= 1;
-  }
-
-  size_t usIntervalResolution;
-  BinarySearchIf(MicrosecondsToInterval(), 0, usForPosInterval, IntervalComparator(), &usIntervalResolution);
-  MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution - 1) == 0);
-  MOZ_ASSERT(PR_MicrosecondsToInterval(usIntervalResolution) == 1);
-
-  // Half of the amount of microseconds needed to get positive PRIntervalTime.
-  // We use this to decide how to round our wait times later
-  int32_t halfMicrosecondsIntervalResolution = usIntervalResolution / 2;
   bool forceRunNextTimer = false;
 
   while (!mShutdown) {
     // Have to use PRIntervalTime here, since PR_WaitCondVar takes it
     TimeDuration waitFor(TimeDuration::Forever());
     bool forceRunThisTimer = forceRunNextTimer;
     forceRunNextTimer = false;
 
@@ -481,44 +446,35 @@ TimerThread::Run()
         }
       }
 
       RemoveLeadingCanceledTimersInternal();
 
       if (!mTimers.IsEmpty()) {
         TimeStamp timeout = mTimers[0]->Value()->mTimeout;
 
-        // Don't wait at all (even for PR_INTERVAL_NO_WAIT) if the next timer
-        // is due now or overdue.
-        //
-        // Note that we can only sleep for integer values of a certain
-        // resolution. We use halfMicrosecondsIntervalResolution, calculated
-        // before, to do the optimal rounding (i.e., of how to decide what
-        // interval is so small we should not wait at all).
-        double microseconds = (timeout - now).ToMilliseconds() * 1000;
+        TimeDuration delay = (timeout - now);
 
         if (ChaosMode::isActive(ChaosFeature::TimerScheduling)) {
           // The mean value of sFractions must be 1 to ensure that
           // the average of a long sequence of timeouts converges to the
           // actual sum of their times.
           static const float sFractions[] = {
             0.0f, 0.25f, 0.5f, 0.75f, 1.0f, 1.75f, 2.75f
           };
-          microseconds *=
-            sFractions[ChaosMode::randomUint32LessThan(ArrayLength(sFractions))];
+          delay += TimeDuration::FromMicroseconds(
+            sFractions[ChaosMode::randomUint32LessThan(ArrayLength(sFractions))]);
           forceRunNextTimer = true;
         }
 
-        if (microseconds < halfMicrosecondsIntervalResolution) {
+        if (delay < TimeDuration::Resolution()) {
           forceRunNextTimer = false;
           goto next; // round down; execute event now
         }
-        waitFor =
-          TimeDuration::Max(TimeDuration::FromMicroseconds(microseconds),
-                            TimeDuration::Resolution());
+        waitFor = delay;
       }
 
       if (MOZ_LOG_TEST(GetTimerLog(), LogLevel::Debug)) {
         if (waitFor == TimeDuration::Forever())
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
                  ("waiting for forever\n"));
         else
           MOZ_LOG(GetTimerLog(), LogLevel::Debug,
