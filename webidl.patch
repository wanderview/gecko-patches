# HG changeset patch
# Parent a5a720259d7965a6f1d7420fa2fefa66b233985a
# User Andrea Marchesini <amarchesini@mozilla.com>
* * *
try: -b do -p linux -u all -t none

diff --git a/browser/base/content/test/general/browser_blob-channelname.js b/browser/base/content/test/general/browser_blob-channelname.js
--- a/browser/base/content/test/general/browser_blob-channelname.js
+++ b/browser/base/content/test/general/browser_blob-channelname.js
@@ -1,11 +1,11 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 Cu.import("resource://gre/modules/NetUtil.jsm");
 
 function test() {
-    var file = new File(new Blob(['test'], {type: 'text/plain'}), {name: 'test-name'});
+    var file = new File([new Blob(['test'], {type: 'text/plain'})], "test-name");
     var url = URL.createObjectURL(file);
     var channel = NetUtil.newChannel(url);
 
     is(channel.contentDispositionFilename, 'test-name', "filename matches");
 }
diff --git a/content/base/public/nsDOMFile.h b/content/base/public/nsDOMFile.h
--- a/content/base/public/nsDOMFile.h
+++ b/content/base/public/nsDOMFile.h
@@ -1,43 +1,41 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#ifndef nsDOMFile_h__
-#define nsDOMFile_h__
+#ifndef mozilla_dom_DOMFile_h
+#define mozilla_dom_DOMFile_h
 
 #include "mozilla/Attributes.h"
-#include "nsICharsetDetectionObserver.h"
-#include "nsIFile.h"
+
 #include "nsIDOMFile.h"
 #include "nsIDOMFileList.h"
-#include "nsIInputStream.h"
-#include "nsIJSNativeInitializer.h"
 #include "nsIMutable.h"
-#include "nsCOMArray.h"
-#include "nsCOMPtr.h"
-#include "nsString.h"
 #include "nsIXMLHttpRequest.h"
-#include "nsAutoPtr.h"
-#include "nsFileStreams.h"
-#include "nsTemporaryFileInputStream.h"
 
 #include "mozilla/GuardObjects.h"
 #include "mozilla/LinkedList.h"
-#include <stdint.h>
 #include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
+#include "mozilla/dom/BlobBinding.h"
+#include "mozilla/dom/Date.h"
 #include "mozilla/dom/DOMError.h"
+#include "mozilla/dom/FileBinding.h"
 #include "mozilla/dom/indexedDB/FileInfo.h"
 #include "mozilla/dom/indexedDB/FileManager.h"
 #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
+#include "mozilla/dom/UnionTypes.h"
+#include "nsAutoPtr.h"
+#include "nsCycleCollectionParticipant.h"
+#include "nsCOMPtr.h"
+#include "nsString.h"
+#include "nsTemporaryFileInputStream.h"
 #include "nsWrapperCache.h"
-#include "nsCycleCollectionParticipant.h"
 
 class nsDOMMultipartFile;
 class nsIFile;
 class nsIInputStream;
 class nsIClassInfo;
 
 #define PIDOMFILEIMPL_IID \
   { 0x218ee173, 0xf44f, 0x4d30, \
@@ -55,30 +53,37 @@ namespace mozilla {
 namespace dom {
 
 namespace indexedDB {
 class FileInfo;
 };
 
 class DOMFileImpl;
 
+/* FOLLOWUP TODO:
+1. remove nsDOMBlobBuilder.h
+2. rename nsDOMFile.h/cpp to DOMFile.h/cpp
+3. rename nsDOMFileList to DOMFileList
+*/
 class DOMFile MOZ_FINAL : public nsIDOMFile
                         , public nsIXHRSendable
                         , public nsIMutable
-                        , public nsIJSNativeInitializer
+                        , public nsWrapperCache
 {
 public:
   NS_DECL_NSIDOMBLOB
   NS_DECL_NSIDOMFILE
   NS_DECL_NSIXHRSENDABLE
   NS_DECL_NSIMUTABLE
 
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(DOMFile, nsIDOMFile)
 
+  static already_AddRefed<DOMFile> CreateDOMBlob();
+
   static already_AddRefed<DOMFile>
   Create(const nsAString& aName, const nsAString& aContentType,
          uint64_t aLength, uint64_t aLastModifiedDate);
 
   static already_AddRefed<DOMFile>
   Create(const nsAString& aName, const nsAString& aContentType,
          uint64_t aLength);
 
@@ -117,21 +122,17 @@ public:
 
   static already_AddRefed<DOMFile>
   CreateFromFile(nsIFile* aFile, indexedDB::FileInfo* aFileInfo);
 
   static already_AddRefed<DOMFile>
   CreateFromFile(nsIFile* aFile, const nsAString& aName,
                  const nsAString& aContentType);
 
-  explicit DOMFile(DOMFileImpl* aImpl)
-    : mImpl(aImpl)
-  {
-    MOZ_ASSERT(mImpl);
-  }
+  explicit DOMFile(DOMFileImpl* aImpl);
 
   DOMFileImpl* Impl() const
   {
     return mImpl;
   }
 
   const nsTArray<nsRefPtr<DOMFileImpl>>* GetSubBlobImpls() const;
 
@@ -139,23 +140,82 @@ public:
 
   bool IsDateUnknown() const;
 
   bool IsFile() const;
 
   void SetLazyData(const nsAString& aName, const nsAString& aContentType,
                    uint64_t aLength, uint64_t aLastModifiedDate);
 
-  already_AddRefed<nsIDOMBlob>
-  CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType);
+  already_AddRefed<DOMFile>
+  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType,
+              ErrorResult& aRv);
 
-  // nsIJSNativeInitializer
-  NS_IMETHOD Initialize(nsISupports* aOwner, JSContext* aCx, JSObject* aObj,
-                        const JS::CallArgs& aArgs) MOZ_OVERRIDE;
+  // WebIDL methods
+  nsISupports* GetParentObject() const
+  {
+    return nullptr;
+  }
+
+  // Blob constructor
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal, ErrorResult& aRv);
+
+  // Blob constructor
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal,
+              const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+              const BlobPropertyBag& aBag,
+              ErrorResult& aRv);
+
+  // File constructor
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal,
+              const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+              const nsAString& aName,
+              const FilePropertyBag& aBag,
+              ErrorResult& aRv);
+
+  // File constructor - ChromeOnly
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal,
+              DOMFile& aData,
+              const FilePropertyBag& aBag,
+              ErrorResult& aRv);
+
+  // File constructor - ChromeOnly
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal,
+              const nsAString& aData,
+              const FilePropertyBag& aBag,
+              ErrorResult& aRv);
+
+  // File constructor - ChromeOnly
+  static already_AddRefed<DOMFile>
+  Constructor(const GlobalObject& aGlobal,
+              nsIFile* aData,
+              const FilePropertyBag& aBag,
+              ErrorResult& aRv);
+
+  virtual JSObject* WrapObject(JSContext* aCx) MOZ_OVERRIDE;
+
+  uint64_t GetSize(ErrorResult& aRv);
+
+  void GetType(nsAString& aType, ErrorResult& aRv);
+
+  int64_t GetLastModified(ErrorResult& aRv);
+
+  Date GetLastModifiedDate(ErrorResult& aRv);
+
+  void GetMozFullPath(nsAString& aFilename, ErrorResult& aRv);
+
+  already_AddRefed<DOMFile> Slice(const Optional<int64_t>& aStart,
+                                  const Optional<int64_t>& aEnd,
+                                  const Optional<nsAString>& aContentType,
+                                  ErrorResult& aRv);
 
 private:
   ~DOMFile() {};
 
   // The member is the real backend implementation of this DOMFile/DOMBlob.
   // It's thread-safe and not CC-able and it's the only element that is moved
   // between threads.
   // Note: we should not store any other state in this class!
@@ -166,40 +226,37 @@ private:
 // because this class must be ref-counted and it has to work with IPC.
 class DOMFileImpl : public PIDOMFileImpl
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
   DOMFileImpl() {}
 
-  virtual nsresult GetName(nsAString& aName) = 0;
+  virtual void GetName(nsAString& aName) = 0;
 
   virtual nsresult GetPath(nsAString& aName) = 0;
 
-  virtual nsresult
-  GetLastModifiedDate(JSContext* aCx,
-                      JS::MutableHandle<JS::Value> aDate) = 0;
+  virtual int64_t GetLastModified(ErrorResult& aRv) = 0;
 
-  virtual nsresult GetMozFullPath(nsAString& aName) = 0;
+  virtual void GetMozFullPath(nsAString& aName, ErrorResult& aRv) = 0;
 
-  virtual nsresult GetMozFullPathInternal(nsAString &aFileName) = 0;
+  virtual void GetMozFullPathInternal(nsAString& aFileName, ErrorResult& aRv) = 0;
 
-  virtual nsresult GetSize(uint64_t* aSize) = 0;
+  virtual uint64_t GetSize(ErrorResult& aRv) = 0;
 
-  virtual nsresult GetType(nsAString& aType) = 0;
+  virtual void GetType(nsAString& aType, ErrorResult& aRv) = 0;
 
-  virtual nsresult GetMozLastModifiedDate(uint64_t* aDate) = 0;
+  already_AddRefed<DOMFileImpl>
+  Slice(const Optional<int64_t>& aStart, const Optional<int64_t>& aEnd,
+        const Optional<nsAString>& aContentType, ErrorResult& aRv);
 
-  nsresult Slice(int64_t aStart, int64_t aEnd, const nsAString& aContentType,
-                 uint8_t aArgc, nsIDOMBlob **aBlob);
-
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) = 0;
+              const nsAString& aContentType, ErrorResult& aRv) = 0;
 
   virtual const nsTArray<nsRefPtr<DOMFileImpl>>*
   GetSubBlobImpls() const = 0;
 
   virtual nsresult GetInternalStream(nsIInputStream** aStream) = 0;
 
   virtual nsresult
   GetInternalUrl(nsIPrincipal* aPrincipal, nsAString& aURL) = 0;
@@ -228,19 +285,16 @@ public:
   virtual bool IsMemoryFile() const = 0;
 
   virtual bool IsSizeUnknown() const = 0;
 
   virtual bool IsDateUnknown() const = 0;
 
   virtual bool IsFile() const = 0;
 
-  virtual nsresult Initialize(nsISupports* aOwner, JSContext* aCx,
-                              JSObject* aObj, const JS::CallArgs& aArgs) = 0;
-
   // These 2 methods are used when the implementation has to CC something.
   virtual void Unlink() = 0;
   virtual void Traverse(nsCycleCollectionTraversalCallback &aCb) = 0;
 
   virtual bool IsCCed() const
   {
     return false;
   }
@@ -302,44 +356,51 @@ public:
     , mLastModificationDate(UINT64_MAX)
   {
     NS_ASSERTION(aLength != UINT64_MAX,
                  "Must know length when creating slice");
     // Ensure non-null mContentType by default
     mContentType.SetIsVoid(false);
   }
 
-  virtual nsresult GetName(nsAString& aName) MOZ_OVERRIDE;
+  virtual void GetName(nsAString& aName) MOZ_OVERRIDE;
 
   virtual nsresult GetPath(nsAString& aName) MOZ_OVERRIDE;
 
-  virtual nsresult GetLastModifiedDate(JSContext* aCx,
-                               JS::MutableHandle<JS::Value> aDate) MOZ_OVERRIDE;
+  virtual int64_t GetLastModified(ErrorResult& aRv) MOZ_OVERRIDE;
 
-  virtual nsresult GetMozFullPath(nsAString& aName) MOZ_OVERRIDE;
+  virtual void GetMozFullPath(nsAString& aName, ErrorResult& aRv) MOZ_OVERRIDE;
 
-  virtual nsresult GetMozFullPathInternal(nsAString& aFileName) MOZ_OVERRIDE;
+  virtual void GetMozFullPathInternal(nsAString& aFileName,
+                                      ErrorResult& aRv) MOZ_OVERRIDE;
 
-  virtual nsresult GetSize(uint64_t* aSize) MOZ_OVERRIDE;
+  virtual uint64_t GetSize(ErrorResult& aRv) MOZ_OVERRIDE
+  {
+    return mLength;
+  }
 
-  virtual nsresult GetType(nsAString& aType) MOZ_OVERRIDE;
+  virtual void GetType(nsAString& aType, ErrorResult& aRv) MOZ_OVERRIDE;
 
-  virtual nsresult GetMozLastModifiedDate(uint64_t* aDate) MOZ_OVERRIDE;
-
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType, ErrorResult& aRv) MOZ_OVERRIDE
+  {
+    return nullptr;
+  }
 
   virtual const nsTArray<nsRefPtr<DOMFileImpl>>*
   GetSubBlobImpls() const MOZ_OVERRIDE
   {
     return nullptr;
   }
 
-  virtual nsresult GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
+  virtual nsresult GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE
+  {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
 
   virtual nsresult GetInternalUrl(nsIPrincipal* aPrincipal, nsAString& aURL) MOZ_OVERRIDE;
 
   virtual int64_t GetFileId() MOZ_OVERRIDE;
 
   virtual void AddFileInfo(indexedDB::FileInfo* aFileInfo) MOZ_OVERRIDE;
 
   virtual indexedDB::FileInfo*
@@ -398,22 +459,16 @@ public:
     return false;
   }
 
   virtual bool IsSizeUnknown() const
   {
     return mLength == UINT64_MAX;
   }
 
-  virtual nsresult Initialize(nsISupports* aOwner, JSContext* aCx,
-                              JSObject* aObj, const JS::CallArgs& aArgs)
-  {
-    return NS_OK;
-  }
-
   virtual void Unlink() {}
   virtual void Traverse(nsCycleCollectionTraversalCallback &aCb) {}
 
 protected:
   virtual ~DOMFileImplBase() {}
 
   indexedDB::FileInfo* GetFileInfo() const
   {
@@ -464,19 +519,19 @@ public:
     : DOMFileImplBase(aContentType, aLength)
     , mDataOwner(new DataOwner(aMemoryBuffer, aLength))
   {
     NS_ASSERTION(mDataOwner && mDataOwner->mData, "must have data");
   }
 
   virtual nsresult GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType, ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual bool IsMemoryFile() const MOZ_OVERRIDE
   {
     return true;
   }
 
   class DataOwner MOZ_FINAL : public mozilla::LinkedListElement<DataOwner> {
   public:
@@ -551,19 +606,19 @@ public:
     , mStartPos(aStartPos)
     , mContentType(aContentType)
   {
     mFileDescOwner = new nsTemporaryFileInputStream::FileDescOwner(aFD);
   }
 
   virtual nsresult GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType, ErrorResult& aRv) MOZ_OVERRIDE;
 
 private:
   DOMFileImplTemporaryFileBlob(const DOMFileImplTemporaryFileBlob* aOther,
                                uint64_t aStart, uint64_t aLength,
                                const nsAString& aContentType)
     : DOMFileImplBase(aContentType, aLength)
     , mLength(aLength)
     , mStartPos(aStart)
@@ -680,22 +735,21 @@ public:
     , mStoredFile(false)
   {
     // Lazily get the content type and size
     mContentType.SetIsVoid(true);
     mName.SetIsVoid(true);
   }
 
   // Overrides
-  virtual nsresult GetSize(uint64_t* aSize) MOZ_OVERRIDE;
-  virtual nsresult GetType(nsAString& aType) MOZ_OVERRIDE;
-  virtual nsresult GetLastModifiedDate(JSContext* aCx,
-                               JS::MutableHandle<JS::Value> aLastModifiedDate) MOZ_OVERRIDE;
-  virtual nsresult GetMozLastModifiedDate(uint64_t* aLastModifiedDate) MOZ_OVERRIDE;
-  virtual nsresult GetMozFullPathInternal(nsAString& aFullPath) MOZ_OVERRIDE;
+  virtual uint64_t GetSize(ErrorResult& aRv) MOZ_OVERRIDE;
+  virtual void GetType(nsAString& aType, ErrorResult& aRv) MOZ_OVERRIDE;
+  virtual int64_t GetLastModified(ErrorResult& aRv) MOZ_OVERRIDE;
+  virtual void GetMozFullPathInternal(nsAString& aFullPath,
+                                      ErrorResult& aRv) MOZ_OVERRIDE;
   virtual nsresult GetInternalStream(nsIInputStream**) MOZ_OVERRIDE;
 
   void SetPath(const nsAString& aFullPath);
 
 private:
   // Create slice
   DOMFileImplFile(const DOMFileImplFile* aOther, uint64_t aStart,
                   uint64_t aLength, const nsAString& aContentType)
@@ -721,38 +775,35 @@ private:
       }
 
       mFileInfos.AppendElement(fileInfo);
     }
   }
 
   ~DOMFileImplFile() {}
 
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType, ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual bool IsStoredFile() const MOZ_OVERRIDE
   {
     return mStoredFile;
   }
 
   virtual bool IsWholeFile() const MOZ_OVERRIDE
   {
     return mWholeFile;
   }
 
   nsCOMPtr<nsIFile> mFile;
   bool mWholeFile;
   bool mStoredFile;
 };
 
-} // dom namespace
-} // file namespace
-
 class nsDOMFileList MOZ_FINAL : public nsIDOMFileList,
                                 public nsWrapperCache
 {
   ~nsDOMFileList() {}
 
 public:
   nsDOMFileList(nsISupports *aParent) : mParent(aParent)
   {
@@ -771,19 +822,27 @@ public:
     return mParent;
   }
 
   void Disconnect()
   {
     mParent = nullptr;
   }
 
-  bool Append(nsIDOMFile *aFile) { return mFiles.AppendObject(aFile); }
+  bool Append(DOMFile *aFile) { return mFiles.AppendElement(aFile); }
 
-  bool Remove(uint32_t aIndex) { return mFiles.RemoveObjectAt(aIndex); }
+  bool Remove(uint32_t aIndex) {
+    if (aIndex < mFiles.Length()) {
+      mFiles.RemoveElementAt(aIndex);
+      return true;
+    }
+
+    return false;
+  }
+
   void Clear() { return mFiles.Clear(); }
 
   static nsDOMFileList* FromSupports(nsISupports* aSupports)
   {
 #ifdef DEBUG
     {
       nsCOMPtr<nsIDOMFileList> list_qi = do_QueryInterface(aSupports);
 
@@ -793,28 +852,31 @@ public:
       NS_ASSERTION(list_qi == static_cast<nsIDOMFileList*>(aSupports),
                    "Uh, fix QI!");
     }
 #endif
 
     return static_cast<nsDOMFileList*>(aSupports);
   }
 
-  nsIDOMFile* Item(uint32_t aIndex)
+  DOMFile* Item(uint32_t aIndex)
   {
-    return mFiles.SafeObjectAt(aIndex);
+    return mFiles.SafeElementAt(aIndex);
   }
-  nsIDOMFile* IndexedGetter(uint32_t aIndex, bool& aFound)
+  DOMFile* IndexedGetter(uint32_t aIndex, bool& aFound)
   {
-    aFound = aIndex < static_cast<uint32_t>(mFiles.Count());
-    return aFound ? mFiles.ObjectAt(aIndex) : nullptr;
+    aFound = aIndex < mFiles.Length();
+    return aFound ? mFiles.ElementAt(aIndex) : nullptr;
   }
   uint32_t Length()
   {
-    return mFiles.Count();
+    return mFiles.Length();
   }
 
 private:
-  nsCOMArray<nsIDOMFile> mFiles;
+  nsTArray<nsRefPtr<DOMFile>> mFiles;
   nsISupports *mParent;
 };
 
-#endif
+} // dom namespace
+} // file namespace
+
+#endif // mozilla_dom_DOMFile_h
diff --git a/content/base/src/WebSocket.cpp b/content/base/src/WebSocket.cpp
--- a/content/base/src/WebSocket.cpp
+++ b/content/base/src/WebSocket.cpp
@@ -1177,30 +1177,30 @@ WebSocket::Send(const nsAString& aData,
 {
   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
 
   NS_ConvertUTF16toUTF8 msgString(aData);
   Send(nullptr, msgString, msgString.Length(), false, aRv);
 }
 
 void
-WebSocket::Send(nsIDOMBlob* aData,
+WebSocket::Send(DOMFile& aData,
                 ErrorResult& aRv)
 {
   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
 
   nsCOMPtr<nsIInputStream> msgStream;
-  nsresult rv = aData->GetInternalStream(getter_AddRefs(msgStream));
+  nsresult rv = aData.GetInternalStream(getter_AddRefs(msgStream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   uint64_t msgLength;
-  rv = aData->GetSize(&msgLength);
+  rv = aData.GetSize(&msgLength);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   if (msgLength > UINT32_MAX) {
     aRv.Throw(NS_ERROR_FILE_TOO_BIG);
     return;
diff --git a/content/base/src/WebSocket.h b/content/base/src/WebSocket.h
--- a/content/base/src/WebSocket.h
+++ b/content/base/src/WebSocket.h
@@ -27,16 +27,18 @@
 #include "nsWrapperCache.h"
 
 #define DEFAULT_WS_SCHEME_PORT  80
 #define DEFAULT_WSS_SCHEME_PORT 443
 
 namespace mozilla {
 namespace dom {
 
+class DOMFile;
+
 class WebSocket : public DOMEventTargetHelper,
                   public nsIInterfaceRequestor,
                   public nsIWebSocketListener,
                   public nsIObserver,
                   public nsSupportsWeakReference,
                   public nsIRequest
 {
 friend class CallDispatchConnectionCloseEvents;
@@ -126,17 +128,17 @@ public: // WebIDL interface:
 
   // webIDL: attribute DOMString binaryType;
   dom::BinaryType BinaryType() const { return mBinaryType; }
   void SetBinaryType(dom::BinaryType aData) { mBinaryType = aData; }
 
   // webIDL: void send(DOMString|Blob|ArrayBufferView data);
   void Send(const nsAString& aData,
             ErrorResult& aRv);
-  void Send(nsIDOMBlob* aData,
+  void Send(DOMFile& aData,
             ErrorResult& aRv);
   void Send(const ArrayBuffer& aData,
             ErrorResult& aRv);
   void Send(const ArrayBufferView& aData,
             ErrorResult& aRv);
 
 private: // constructor && distructor
   WebSocket(nsPIDOMWindow* aOwnerWindow);
diff --git a/content/base/src/nsContentUtils.cpp b/content/base/src/nsContentUtils.cpp
--- a/content/base/src/nsContentUtils.cpp
+++ b/content/base/src/nsContentUtils.cpp
@@ -85,16 +85,17 @@
 #include "nsGkAtoms.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsHtml5Module.h"
 #include "nsHtml5StringParser.h"
 #include "nsIAsyncVerifyRedirectCallback.h"
 #include "nsICategoryManager.h"
 #include "nsIChannelEventSink.h"
 #include "nsIChannelPolicy.h"
+#include "nsICharsetDetectionObserver.h"
 #include "nsIChromeRegistry.h"
 #include "nsIConsoleService.h"
 #include "nsIContent.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsIContentSink.h"
 #include "nsIContentViewer.h"
 #include "nsIDocShell.h"
 #include "nsIDocument.h"
diff --git a/content/base/src/nsDOMBlobBuilder.cpp b/content/base/src/nsDOMBlobBuilder.cpp
--- a/content/base/src/nsDOMBlobBuilder.cpp
+++ b/content/base/src/nsDOMBlobBuilder.cpp
@@ -19,23 +19,16 @@
 #include <algorithm>
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS_INHERITED0(DOMMultipartFileImpl, DOMFileImpl)
 
 nsresult
-DOMMultipartFileImpl::GetSize(uint64_t* aLength)
-{
-  *aLength = mLength;
-  return NS_OK;
-}
-
-nsresult
 DOMMultipartFileImpl::GetInternalStream(nsIInputStream** aStream)
 {
   nsresult rv;
   *aStream = nullptr;
 
   nsCOMPtr<nsIMultiplexInputStream> stream =
     do_CreateInstance("@mozilla.org/io/multiplex-input-stream;1");
   NS_ENSURE_TRUE(stream, NS_ERROR_FAILURE);
@@ -50,228 +43,148 @@ DOMMultipartFileImpl::GetInternalStream(
 
     rv = stream->AppendStream(scratchStream);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return CallQueryInterface(stream, aStream);
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 DOMMultipartFileImpl::CreateSlice(uint64_t aStart, uint64_t aLength,
-                                  const nsAString& aContentType)
+                                  const nsAString& aContentType,
+                                  ErrorResult& aRv)
 {
   // If we clamped to nothing we create an empty blob
   nsTArray<nsRefPtr<DOMFileImpl>> blobImpls;
 
   uint64_t length = aLength;
   uint64_t skipStart = aStart;
 
   // Prune the list of blobs if we can
   uint32_t i;
   for (i = 0; length && skipStart && i < mBlobImpls.Length(); i++) {
     DOMFileImpl* blobImpl = mBlobImpls[i].get();
 
-    uint64_t l;
-    nsresult rv = blobImpl->GetSize(&l);
-    NS_ENSURE_SUCCESS(rv, nullptr);
+    uint64_t l = blobImpl->GetSize(aRv);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
 
     if (skipStart < l) {
       uint64_t upperBound = std::min<uint64_t>(l - skipStart, length);
 
-      nsCOMPtr<nsIDOMBlob> firstBlob;
-      rv = blobImpl->Slice(skipStart, skipStart + upperBound,
-                           aContentType, 3,
-                           getter_AddRefs(firstBlob));
-      NS_ENSURE_SUCCESS(rv, nullptr);
+      nsRefPtr<DOMFileImpl> firstBlobImpl =
+        blobImpl->CreateSlice(skipStart, upperBound,
+                              aContentType, aRv);
+      if (NS_WARN_IF(aRv.Failed())) {
+        return nullptr;
+      }
 
       // Avoid wrapping a single blob inside an DOMMultipartFileImpl
       if (length == upperBound) {
-        return firstBlob.forget();
+        return firstBlobImpl.forget();
       }
 
-      blobImpls.AppendElement(static_cast<DOMFile*>(firstBlob.get())->Impl());
+      blobImpls.AppendElement(firstBlobImpl);
       length -= upperBound;
       i++;
       break;
     }
     skipStart -= l;
   }
 
   // Now append enough blobs until we're done
   for (; length && i < mBlobImpls.Length(); i++) {
     DOMFileImpl* blobImpl = mBlobImpls[i].get();
 
-    uint64_t l;
-    nsresult rv = blobImpl->GetSize(&l);
-    NS_ENSURE_SUCCESS(rv, nullptr);
+    uint64_t l = blobImpl->GetSize(aRv);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
 
     if (length < l) {
-      nsCOMPtr<nsIDOMBlob> lastBlob;
-      rv = blobImpl->Slice(0, length, aContentType, 3,
-                           getter_AddRefs(lastBlob));
-      NS_ENSURE_SUCCESS(rv, nullptr);
+      nsRefPtr<DOMFileImpl> lastBlobImpl =
+        blobImpl->CreateSlice(0, length, aContentType, aRv);
+      if (NS_WARN_IF(aRv.Failed())) {
+        return nullptr;
+      }
 
-      blobImpls.AppendElement(static_cast<DOMFile*>(lastBlob.get())->Impl());
+      blobImpls.AppendElement(lastBlobImpl);
     } else {
       blobImpls.AppendElement(blobImpl);
     }
     length -= std::min<uint64_t>(l, length);
   }
 
   // we can create our blob now
-  nsCOMPtr<nsIDOMBlob> blob =
-    new DOMFile(new DOMMultipartFileImpl(blobImpls, aContentType));
-  return blob.forget();
+  nsRefPtr<DOMFileImpl> impl =
+    new DOMMultipartFileImpl(blobImpls, aContentType);
+  return impl.forget();
 }
 
-/* static */ nsresult
-DOMMultipartFileImpl::NewFile(const nsAString& aName, nsISupports** aNewObject)
+void
+DOMMultipartFileImpl::InitializeBlob()
 {
-  nsCOMPtr<nsISupports> file =
-    do_QueryObject(new DOMFile(new DOMMultipartFileImpl(aName)));
-  file.forget(aNewObject);
-  return NS_OK;
+  SetLengthAndModifiedDate();
 }
 
-/* static */ nsresult
-DOMMultipartFileImpl::NewBlob(nsISupports** aNewObject)
+void
+DOMMultipartFileImpl::InitializeBlob(
+       JSContext* aCx,
+       const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+       const BlobPropertyBag& aBag,
+       ErrorResult& aRv)
 {
-  nsCOMPtr<nsISupports> file =
-    do_QueryObject(new DOMFile(new DOMMultipartFileImpl()));
-  file.forget(aNewObject);
-  return NS_OK;
-}
+  bool nativeEOL = false;
+  mContentType = aBag.mType;
+  nativeEOL = aBag.mEndings == EndingTypes::Native;
 
-static nsIDOMBlob*
-GetXPConnectNative(JSContext* aCx, JSObject* aObj) {
-  nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(
-    nsContentUtils::XPConnect()->GetNativeOfWrapper(aCx, aObj));
-  return blob;
-}
+  BlobSet blobSet;
 
-nsresult
-DOMMultipartFileImpl::Initialize(nsISupports* aOwner,
-                                 JSContext* aCx,
-                                 JSObject* aObj,
-                                 const JS::CallArgs& aArgs)
-{
-  if (!mIsFile) {
-    return InitBlob(aCx, aArgs.length(), aArgs.array(), GetXPConnectNative);
-  }
+  for (uint32_t i = 0, len = aData.Length(); i < len; ++i) {
+    const OwningArrayBufferOrArrayBufferViewOrBlobOrString& data = aData[i];
 
-  if (!nsContentUtils::IsCallerChrome()) {
-    return InitFile(aCx, aArgs.length(), aArgs.array());
-  }
+    if (data.IsBlob()) {
+      nsRefPtr<DOMFile> file = data.GetAsBlob().get();
+      blobSet.AppendBlobImpl(file->Impl());
+    }
 
-  if (aArgs.length() > 0) {
-    JS::Value* argv = aArgs.array();
-    if (argv[0].isObject()) {
-      JS::Rooted<JSObject*> obj(aCx, &argv[0].toObject());
-      if (JS_IsArrayObject(aCx, obj)) {
-        return InitFile(aCx, aArgs.length(), aArgs.array());
+    else if (data.IsString()) {
+      aRv = blobSet.AppendString(data.GetAsString(), nativeEOL, aCx);
+      if (aRv.Failed()) {
+        return;
       }
     }
+
+    else if (data.IsArrayBuffer()) {
+      const ArrayBuffer& buffer = data.GetAsArrayBuffer();
+      buffer.ComputeLengthAndData();
+      aRv = blobSet.AppendVoidPtr(buffer.Data(), buffer.Length());
+      if (aRv.Failed()) {
+        return;
+      }
+    }
+
+    else if (data.IsArrayBufferView()) {
+      const ArrayBufferView& buffer = data.GetAsArrayBufferView();
+      buffer.ComputeLengthAndData();
+      aRv = blobSet.AppendVoidPtr(buffer.Data(), buffer.Length());
+      if (aRv.Failed()) {
+        return;
+      }
+    }
+
+    else {
+      MOZ_ASSUME_UNREACHABLE("This should not happen.");
+    }
   }
 
-  return InitChromeFile(aCx, aArgs.length(), aArgs.array());
-}
-
-nsresult
-DOMMultipartFileImpl::InitBlob(JSContext* aCx,
-                               uint32_t aArgc,
-                               JS::Value* aArgv,
-                               UnwrapFuncPtr aUnwrapFunc)
-{
-  bool nativeEOL = false;
-  if (aArgc > 1) {
-    BlobPropertyBag d;
-    if (!d.Init(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aArgv[1]))) {
-      return NS_ERROR_TYPE_ERR;
-    }
-    mContentType = d.mType;
-    nativeEOL = d.mEndings == EndingTypes::Native;
-  }
-
-  if (aArgc > 0) {
-    return ParseBlobArrayArgument(aCx, aArgv[0], nativeEOL, aUnwrapFunc);
-  }
-
+  mBlobImpls = blobSet.GetBlobImpls();
   SetLengthAndModifiedDate();
-
-  return NS_OK;
-}
-
-nsresult
-DOMMultipartFileImpl::ParseBlobArrayArgument(JSContext* aCx, JS::Value& aValue,
-                                             bool aNativeEOL,
-                                             UnwrapFuncPtr aUnwrapFunc)
-{
-  if (!aValue.isObject()) {
-    return NS_ERROR_TYPE_ERR; // We're not interested
-  }
-
-  JS::Rooted<JSObject*> obj(aCx, &aValue.toObject());
-  if (!JS_IsArrayObject(aCx, obj)) {
-    return NS_ERROR_TYPE_ERR; // We're not interested
-  }
-
-  BlobSet blobSet;
-
-  uint32_t length;
-  MOZ_ALWAYS_TRUE(JS_GetArrayLength(aCx, obj, &length));
-  for (uint32_t i = 0; i < length; ++i) {
-    JS::Rooted<JS::Value> element(aCx);
-    if (!JS_GetElement(aCx, obj, i, &element))
-      return NS_ERROR_TYPE_ERR;
-
-    if (element.isObject()) {
-      JS::Rooted<JSObject*> obj(aCx, &element.toObject());
-      nsCOMPtr<nsIDOMBlob> blob = aUnwrapFunc(aCx, obj);
-      if (blob) {
-        nsRefPtr<DOMFileImpl> blobImpl =
-          static_cast<DOMFile*>(blob.get())->Impl();
-
-        // Flatten so that multipart blobs will never nest
-        const nsTArray<nsRefPtr<DOMFileImpl>>* subBlobImpls =
-          blobImpl->GetSubBlobImpls();
-        if (subBlobImpls) {
-          blobSet.AppendBlobImpls(*subBlobImpls);
-        } else {
-          blobSet.AppendBlobImpl(blobImpl);
-        }
-        continue;
-      }
-      if (JS_IsArrayBufferViewObject(obj)) {
-        nsresult rv = blobSet.AppendVoidPtr(
-                                          JS_GetArrayBufferViewData(obj),
-                                          JS_GetArrayBufferViewByteLength(obj));
-        NS_ENSURE_SUCCESS(rv, rv);
-        continue;
-      }
-      if (JS_IsArrayBufferObject(obj)) {
-        nsresult rv = blobSet.AppendArrayBuffer(obj);
-        NS_ENSURE_SUCCESS(rv, rv);
-        continue;
-      }
-    }
-
-    // coerce it to a string
-    JSString* str = JS::ToString(aCx, element);
-    NS_ENSURE_TRUE(str, NS_ERROR_TYPE_ERR);
-
-    nsresult rv = blobSet.AppendString(str, aNativeEOL, aCx);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  mBlobImpls = blobSet.GetBlobImpls();
-
-  SetLengthAndModifiedDate();
-
-  return NS_OK;
 }
 
 void
 DOMMultipartFileImpl::SetLengthAndModifiedDate()
 {
   MOZ_ASSERT(mLength == UINT64_MAX);
   MOZ_ASSERT(mLastModificationDate == UINT64_MAX);
 
@@ -280,184 +193,162 @@ DOMMultipartFileImpl::SetLengthAndModifi
   for (uint32_t index = 0, count = mBlobImpls.Length(); index < count; index++) {
     nsRefPtr<DOMFileImpl>& blob = mBlobImpls[index];
 
 #ifdef DEBUG
     MOZ_ASSERT(!blob->IsSizeUnknown());
     MOZ_ASSERT(!blob->IsDateUnknown());
 #endif
 
-    uint64_t subBlobLength;
-    MOZ_ALWAYS_TRUE(NS_SUCCEEDED(blob->GetSize(&subBlobLength)));
+    ErrorResult error;
+    uint64_t subBlobLength = blob->GetSize(error);
+    MOZ_ALWAYS_TRUE(!error.Failed());
 
     MOZ_ASSERT(UINT64_MAX - subBlobLength >= totalLength);
     totalLength += subBlobLength;
   }
 
   mLength = totalLength;
 
   if (mIsFile) {
     mLastModificationDate = PR_Now();
   }
 }
 
-nsresult
-DOMMultipartFileImpl::GetMozFullPathInternal(nsAString& aFilename)
+void
+DOMMultipartFileImpl::GetMozFullPathInternal(nsAString& aFilename,
+                                             ErrorResult& aRv)
 {
   if (!mIsFromNsiFile || mBlobImpls.Length() == 0) {
-    return DOMFileImplBase::GetMozFullPathInternal(aFilename);
+    DOMFileImplBase::GetMozFullPathInternal(aFilename, aRv);
+    return;
   }
 
   DOMFileImpl* blobImpl = mBlobImpls.ElementAt(0).get();
   if (!blobImpl) {
-    return DOMFileImplBase::GetMozFullPathInternal(aFilename);
+    DOMFileImplBase::GetMozFullPathInternal(aFilename, aRv);
+    return;
   }
 
-  return blobImpl->GetMozFullPathInternal(aFilename);
+  blobImpl->GetMozFullPathInternal(aFilename, aRv);
 }
 
-nsresult
-DOMMultipartFileImpl::InitChromeFile(JSContext* aCx,
-                                     uint32_t aArgc,
-                                     JS::Value* aArgv)
+void
+DOMMultipartFileImpl::InitializeChromeFile(DOMFile& aBlob,
+                                           const FilePropertyBag& aBag,
+                                           ErrorResult& aRv)
 {
-  nsresult rv;
+  NS_ASSERTION(!mImmutable, "Something went wrong ...");
 
-  NS_ASSERTION(!mImmutable, "Something went wrong ...");
-  NS_ENSURE_TRUE(!mImmutable, NS_ERROR_UNEXPECTED);
-  MOZ_ASSERT(nsContentUtils::IsCallerChrome());
-  NS_ENSURE_TRUE(aArgc > 0, NS_ERROR_UNEXPECTED);
-
-  if (aArgc > 1) {
-    FilePropertyBag d;
-    if (!d.Init(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aArgv[1]))) {
-      return NS_ERROR_TYPE_ERR;
-    }
-    mName = d.mName;
-    mContentType = d.mType;
+  if (mImmutable) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return;
   }
 
+  MOZ_ASSERT(nsContentUtils::IsCallerChrome());
 
-  // We expect to get a path to represent as a File object or
-  // Blob object, an nsIFile, or an nsIDOMFile.
-  nsCOMPtr<nsIFile> file;
-  nsCOMPtr<nsIDOMBlob> blob;
-  if (!aArgv[0].isString()) {
-    // Lets see if it's an nsIFile
-    if (!aArgv[0].isObject()) {
-      return NS_ERROR_UNEXPECTED; // We're not interested
-    }
+  mName = aBag.mName;
+  mContentType = aBag.mType;
+  mIsFromNsiFile = true;
 
-    JSObject* obj = &aArgv[0].toObject();
-
-    nsISupports* supports =
-      nsContentUtils::XPConnect()->GetNativeOfWrapper(aCx, obj);
-    if (!supports) {
-      return NS_ERROR_UNEXPECTED;
-    }
-
-    blob = do_QueryInterface(supports);
-    file = do_QueryInterface(supports);
-    if (!blob && !file) {
-      return NS_ERROR_UNEXPECTED;
-    }
-
-    mIsFromNsiFile = true;
-  } else {
-    // It's a string
-    JSString* str = JS::ToString(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aArgv[0]));
-    NS_ENSURE_TRUE(str, NS_ERROR_XPC_BAD_CONVERT_JS);
-
-    nsAutoJSString xpcomStr;
-    if (!xpcomStr.init(aCx, str)) {
-      return NS_ERROR_XPC_BAD_CONVERT_JS;
-    }
-
-    rv = NS_NewLocalFile(xpcomStr, false, getter_AddRefs(file));
-    NS_ENSURE_SUCCESS(rv, rv);
+  // XXXkhuey this is terrible
+  if (mContentType.IsEmpty()) {
+    aBlob.GetType(mContentType);
   }
 
-  if (file) {
-    bool exists;
-    rv = file->Exists(&exists);
-    NS_ENSURE_SUCCESS(rv, rv);
-    NS_ENSURE_TRUE(exists, NS_ERROR_FILE_NOT_FOUND);
 
-    bool isDir;
-    rv = file->IsDirectory(&isDir);
-    NS_ENSURE_SUCCESS(rv, rv);
-    NS_ENSURE_FALSE(isDir, NS_ERROR_FILE_IS_DIRECTORY);
+  BlobSet blobSet;
+  blobSet.AppendBlobImpl(aBlob.Impl());
+  mBlobImpls = blobSet.GetBlobImpls();
 
-    if (mName.IsEmpty()) {
-      file->GetLeafName(mName);
-    }
+  SetLengthAndModifiedDate();
+}
 
-    nsRefPtr<DOMFile> domFile = DOMFile::CreateFromFile(file);
+void
+DOMMultipartFileImpl::InitializeChromeFile(nsIFile* aFile,
+                                           const FilePropertyBag& aBag,
+                                           ErrorResult& aRv)
+{
+  NS_ASSERTION(!mImmutable, "Something went wrong ...");
+  if (mImmutable) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return;
+  }
 
-    // Pre-cache size.
-    uint64_t unused;
-    rv = domFile->GetSize(&unused);
-    NS_ENSURE_SUCCESS(rv, rv);
+  MOZ_ASSERT(nsContentUtils::IsCallerChrome());
 
-    // Pre-cache modified date.
-    rv = domFile->GetMozLastModifiedDate(&unused);
-    NS_ENSURE_SUCCESS(rv, rv);
+  mName = aBag.mName;
+  mContentType = aBag.mType;
+  mIsFromNsiFile = true;
 
-    blob = domFile.forget();
+  bool exists;
+  aRv = aFile->Exists(&exists);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+
+  if (!exists) {
+    aRv.Throw(NS_ERROR_FILE_NOT_FOUND);
+    return;
+  }
+
+  bool isDir;
+  aRv = aFile->IsDirectory(&isDir);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+
+  if (isDir) {
+    aRv.Throw(NS_ERROR_FILE_IS_DIRECTORY);
+    return;
+  }
+
+  if (mName.IsEmpty()) {
+    aFile->GetLeafName(mName);
+  }
+
+  nsRefPtr<DOMFile> blob = DOMFile::CreateFromFile(aFile);
+
+  // Pre-cache size.
+  uint64_t unused;
+  aRv = blob->GetSize(&unused);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
+  }
+
+  // Pre-cache modified date.
+  aRv = blob->GetMozLastModifiedDate(&unused);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
   }
 
   // XXXkhuey this is terrible
   if (mContentType.IsEmpty()) {
     blob->GetType(mContentType);
   }
 
   BlobSet blobSet;
   blobSet.AppendBlobImpl(static_cast<DOMFile*>(blob.get())->Impl());
   mBlobImpls = blobSet.GetBlobImpls();
 
   SetLengthAndModifiedDate();
-
-  return NS_OK;
 }
 
-nsresult
-DOMMultipartFileImpl::InitFile(JSContext* aCx,
-                               uint32_t aArgc,
-                               JS::Value* aArgv)
+void
+DOMMultipartFileImpl::InitializeChromeFile(const nsAString& aData,
+                                           const FilePropertyBag& aBag,
+                                           ErrorResult& aRv)
 {
-  NS_ASSERTION(!mImmutable, "Something went wrong ...");
-  NS_ENSURE_TRUE(!mImmutable, NS_ERROR_UNEXPECTED);
-
-  if (aArgc < 2) {
-    return NS_ERROR_TYPE_ERR;
+  nsCOMPtr<nsIFile> file;
+  aRv = NS_NewLocalFile(aData, false, getter_AddRefs(file));
+  if (NS_WARN_IF(aRv.Failed())) {
+    return;
   }
 
-  // File name
-  JSString* str = JS::ToString(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aArgv[1]));
-  NS_ENSURE_TRUE(str, NS_ERROR_XPC_BAD_CONVERT_JS);
-
-  nsAutoJSString xpcomStr;
-  if (!xpcomStr.init(aCx, str)) {
-    return NS_ERROR_XPC_BAD_CONVERT_JS;
-  }
-
-  mName = xpcomStr;
-
-  // Optional params
-  bool nativeEOL = false;
-  if (aArgc > 2) {
-    BlobPropertyBag d;
-    if (!d.Init(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aArgv[2]))) {
-      return NS_ERROR_TYPE_ERR;
-    }
-    mContentType = d.mType;
-    nativeEOL = d.mEndings == EndingTypes::Native;
-  }
-
-  return ParseBlobArrayArgument(aCx, aArgv[0], nativeEOL, GetXPConnectNative);
+  InitializeChromeFile(file, aBag, aRv);
 }
 
 nsresult
 BlobSet::AppendVoidPtr(const void* aData, uint32_t aLength)
 {
   NS_ENSURE_ARG_POINTER(aData);
 
   uint64_t offset = mDataLen;
@@ -465,24 +356,19 @@ BlobSet::AppendVoidPtr(const void* aData
   if (!ExpandBufferSize(aLength))
     return NS_ERROR_OUT_OF_MEMORY;
 
   memcpy((char*)mData + offset, aData, aLength);
   return NS_OK;
 }
 
 nsresult
-BlobSet::AppendString(JSString* aString, bool nativeEOL, JSContext* aCx)
+BlobSet::AppendString(const nsAString& aString, bool nativeEOL, JSContext* aCx)
 {
-  nsAutoJSString xpcomStr;
-  if (!xpcomStr.init(aCx, aString)) {
-    return NS_ERROR_XPC_BAD_CONVERT_JS;
-  }
-
-  nsCString utf8Str = NS_ConvertUTF16toUTF8(xpcomStr);
+  nsCString utf8Str = NS_ConvertUTF16toUTF8(aString);
 
   if (nativeEOL) {
     if (utf8Str.FindChar('\r') != kNotFound) {
       utf8Str.ReplaceSubstring("\r\n", "\n");
       utf8Str.ReplaceSubstring("\r", "\n");
     }
 #ifdef XP_WIN
     utf8Str.ReplaceSubstring("\n", "\r\n");
@@ -507,15 +393,8 @@ BlobSet::AppendBlobImpl(DOMFileImpl* aBl
 nsresult
 BlobSet::AppendBlobImpls(const nsTArray<nsRefPtr<DOMFileImpl>>& aBlobImpls)
 {
   Flush();
   mBlobImpls.AppendElements(aBlobImpls);
 
   return NS_OK;
 }
-
-nsresult
-BlobSet::AppendArrayBuffer(JSObject* aBuffer)
-{
-  return AppendVoidPtr(JS_GetArrayBufferData(aBuffer),
-                       JS_GetArrayBufferByteLength(aBuffer));
-}
diff --git a/content/base/src/nsDOMBlobBuilder.h b/content/base/src/nsDOMBlobBuilder.h
--- a/content/base/src/nsDOMBlobBuilder.h
+++ b/content/base/src/nsDOMBlobBuilder.h
@@ -3,28 +3,32 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsDOMBlobBuilder_h
 #define nsDOMBlobBuilder_h
 
 #include "nsDOMFile.h"
 
+#include "mozilla/Attributes.h"
 #include "mozilla/CheckedInt.h"
-#include "mozilla/Attributes.h"
+#include "mozilla/ErrorResult.h"
+#include "mozilla/dom/BlobBinding.h"
+#include "mozilla/dom/FileBinding.h"
 #include <algorithm>
 
 #define NS_DOMMULTIPARTBLOB_CID { 0x47bf0b43, 0xf37e, 0x49ef, \
   { 0x81, 0xa0, 0x18, 0xba, 0xc0, 0x57, 0xb5, 0xcc } }
 #define NS_DOMMULTIPARTBLOB_CONTRACTID "@mozilla.org/dom/multipart-blob;1"
 
 #define NS_DOMMULTIPARTFILE_CID { 0xc3361f77, 0x60d1, 0x4ea9, \
   { 0x94, 0x96, 0xdf, 0x5d, 0x6f, 0xcd, 0xd7, 0x8f } }
 #define NS_DOMMULTIPARTFILE_CONTRACTID "@mozilla.org/dom/multipart-file;1"
 
+using namespace mozilla;
 using namespace mozilla::dom;
 
 class DOMMultipartFileImpl MOZ_FINAL : public DOMFileImplBase
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // Create as a file
@@ -57,67 +61,69 @@ public:
 
   // Create as a blob to be later initialized
   DOMMultipartFileImpl()
     : DOMFileImplBase(EmptyString(), UINT64_MAX),
       mIsFromNsiFile(false)
   {
   }
 
-  virtual nsresult
-  Initialize(nsISupports* aOwner, JSContext* aCx, JSObject* aObj,
-             const JS::CallArgs& aArgs) MOZ_OVERRIDE;
+  void InitializeBlob();
 
-  typedef nsIDOMBlob* (*UnwrapFuncPtr)(JSContext*, JSObject*);
-  nsresult InitBlob(JSContext* aCx,
-                    uint32_t aArgc,
-                    JS::Value* aArgv,
-                    UnwrapFuncPtr aUnwrapFunc);
-  nsresult InitFile(JSContext* aCx,
-                    uint32_t aArgc,
-                    JS::Value* aArgv);
-  nsresult InitChromeFile(JSContext* aCx,
-                          uint32_t aArgc,
-                          JS::Value* aArgv);
+  void InitializeBlob(
+       JSContext* aCx,
+       const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+       const BlobPropertyBag& aBag,
+       ErrorResult& aRv);
 
-  virtual already_AddRefed<nsIDOMBlob>
+  void InitializeChromeFile(DOMFile& aData,
+                            const FilePropertyBag& aBag,
+                            ErrorResult& aRv);
+
+  void InitializeChromeFile(const nsAString& aData,
+                            const FilePropertyBag& aBag,
+                            ErrorResult& aRv);
+
+  void InitializeChromeFile(nsIFile* aData,
+                            const FilePropertyBag& aBag,
+                            ErrorResult& aRv);
+
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType,
+              ErrorResult& aRv) MOZ_OVERRIDE;
 
-  virtual nsresult GetSize(uint64_t* aSize) MOZ_OVERRIDE;
+  virtual uint64_t GetSize(ErrorResult& aRv) MOZ_OVERRIDE
+  {
+    return mLength;
+  }
 
   virtual nsresult GetInternalStream(nsIInputStream** aInputStream) MOZ_OVERRIDE;
 
-  static nsresult NewFile(const nsAString& aName, nsISupports** aNewObject);
-
-  // DOMClassInfo constructor (for Blob([b1, "foo"], { type: "image/png" }))
-  static nsresult NewBlob(nsISupports* *aNewObject);
-
-  // DOMClassInfo constructor (for File([b1, "foo"], { type: "image/png",
-  //                                                   name: "foo.png" }))
-  inline static nsresult NewFile(nsISupports** aNewObject)
-  {
-    // Initialization will set the filename, so we can pass in an empty string
-    // for now.
-    return NewFile(EmptyString(), aNewObject);
-  }
-
   virtual const nsTArray<nsRefPtr<DOMFileImpl>>* GetSubBlobImpls() const MOZ_OVERRIDE
   {
     return &mBlobImpls;
   }
 
-  virtual nsresult GetMozFullPathInternal(nsAString& aFullPath) MOZ_OVERRIDE;
+  virtual void GetMozFullPathInternal(nsAString& aFullPath,
+                                      ErrorResult& aRv) MOZ_OVERRIDE;
+
+  void SetName(const nsAString& aName)
+  {
+    mName = aName;
+  }
+
+  void SetFromNsIFile(bool aValue)
+  {
+    mIsFromNsiFile = aValue;
+  }
 
 protected:
   virtual ~DOMMultipartFileImpl() {}
 
-  nsresult ParseBlobArrayArgument(JSContext* aCx, JS::Value& aValue,
-                                  bool aNativeEOL, UnwrapFuncPtr aUnwrapFunc);
-
   void SetLengthAndModifiedDate();
 
   nsTArray<nsRefPtr<DOMFileImpl>> mBlobImpls;
   bool mIsFromNsiFile;
 };
 
 class BlobSet {
 public:
@@ -126,19 +132,18 @@ public:
   {}
 
   ~BlobSet()
   {
     moz_free(mData);
   }
 
   nsresult AppendVoidPtr(const void* aData, uint32_t aLength);
-  nsresult AppendString(JSString* aString, bool nativeEOL, JSContext* aCx);
+  nsresult AppendString(const nsAString& aString, bool nativeEOL, JSContext* aCx);
   nsresult AppendBlobImpl(DOMFileImpl* aBlobImpl);
-  nsresult AppendArrayBuffer(JSObject* aBuffer);
   nsresult AppendBlobImpls(const nsTArray<nsRefPtr<DOMFileImpl>>& aBlobImpls);
 
   nsTArray<nsRefPtr<DOMFileImpl>>& GetBlobImpls() { Flush(); return mBlobImpls; }
 
   already_AddRefed<nsIDOMBlob>
   GetBlobInternal(const nsACString& aContentType)
   {
     nsCOMPtr<nsIDOMBlob> blob = new DOMFile(
diff --git a/content/base/src/nsDOMDataChannel.cpp b/content/base/src/nsDOMDataChannel.cpp
--- a/content/base/src/nsDOMDataChannel.cpp
+++ b/content/base/src/nsDOMDataChannel.cpp
@@ -17,17 +17,17 @@
 extern PRLogModuleInfo* GetDataChannelLog();
 #endif
 #undef LOG
 #define LOG(args) PR_LOG(GetDataChannelLog(), PR_LOG_DEBUG, args)
 
 
 #include "nsDOMDataChannelDeclarations.h"
 #include "nsDOMDataChannel.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "nsIDOMDataChannel.h"
 #include "nsIDOMMessageEvent.h"
 #include "mozilla/DOMEventTargetHelper.h"
 #include "mozilla/dom/ScriptSettings.h"
 
 #include "nsError.h"
 #include "nsAutoPtr.h"
 #include "nsContentUtils.h"
@@ -267,29 +267,29 @@ nsDOMDataChannel::Close()
 void
 nsDOMDataChannel::Send(const nsAString& aData, ErrorResult& aRv)
 {
   NS_ConvertUTF16toUTF8 msgString(aData);
   Send(nullptr, msgString, msgString.Length(), false, aRv);
 }
 
 void
-nsDOMDataChannel::Send(nsIDOMBlob* aData, ErrorResult& aRv)
+nsDOMDataChannel::Send(DOMFile& aData, ErrorResult& aRv)
 {
   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
 
   nsCOMPtr<nsIInputStream> msgStream;
-  nsresult rv = aData->GetInternalStream(getter_AddRefs(msgStream));
+  nsresult rv = aData.GetInternalStream(getter_AddRefs(msgStream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   uint64_t msgLength;
-  rv = aData->GetSize(&msgLength);
+  rv = aData.GetSize(&msgLength);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   if (msgLength > UINT32_MAX) {
     aRv.Throw(NS_ERROR_FILE_TOO_BIG);
     return;
diff --git a/content/base/src/nsDOMDataChannel.h b/content/base/src/nsDOMDataChannel.h
--- a/content/base/src/nsDOMDataChannel.h
+++ b/content/base/src/nsDOMDataChannel.h
@@ -12,16 +12,20 @@
 #include "mozilla/dom/DataChannelBinding.h"
 #include "mozilla/dom/TypedArray.h"
 #include "mozilla/net/DataChannelListener.h"
 #include "nsIDOMDataChannel.h"
 #include "nsIInputStream.h"
 
 
 namespace mozilla {
+namespace dom {
+class DOMFile;
+}
+
 class DataChannel;
 };
 
 class nsDOMDataChannel : public mozilla::DOMEventTargetHelper,
                          public nsIDOMDataChannel,
                          public mozilla::DataChannelListener
 {
 public:
@@ -61,17 +65,17 @@ public:
       static_cast<int>(mBinaryType));
   }
   void SetBinaryType(mozilla::dom::RTCDataChannelType aType)
   {
     mBinaryType = static_cast<DataChannelBinaryType>(
       static_cast<int>(aType));
   }
   void Send(const nsAString& aData, mozilla::ErrorResult& aRv);
-  void Send(nsIDOMBlob* aData, mozilla::ErrorResult& aRv);
+  void Send(mozilla::dom::DOMFile& aData, mozilla::ErrorResult& aRv);
   void Send(const mozilla::dom::ArrayBuffer& aData, mozilla::ErrorResult& aRv);
   void Send(const mozilla::dom::ArrayBufferView& aData,
             mozilla::ErrorResult& aRv);
 
   // Uses XPIDL GetProtocol.
   bool Ordered() const;
   uint16_t Id() const;
   uint16_t Stream() const; // deprecated
diff --git a/content/base/src/nsDOMFile.cpp b/content/base/src/nsDOMFile.cpp
--- a/content/base/src/nsDOMFile.cpp
+++ b/content/base/src/nsDOMFile.cpp
@@ -4,20 +4,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsDOMFile.h"
 
 #include "nsCExternalHandlerService.h"
 #include "nsContentCID.h"
 #include "nsContentUtils.h"
-#include "nsDOMClassInfoID.h"
+#include "nsDOMBlobBuilder.h"
 #include "nsError.h"
 #include "nsICharsetDetector.h"
-#include "nsIClassInfo.h"
 #include "nsIConverterInputStream.h"
 #include "nsIDocument.h"
 #include "nsIFileStreams.h"
 #include "nsIInputStream.h"
 #include "nsIIPCSerializableInputStream.h"
 #include "nsIMemoryReporter.h"
 #include "nsIMIMEService.h"
 #include "nsISeekableStream.h"
@@ -34,19 +33,16 @@
 #include "mozilla/SHA1.h"
 #include "mozilla/CheckedInt.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Attributes.h"
 #include "nsThreadUtils.h"
 
 #include "mozilla/dom/FileListBinding.h"
 
-DOMCI_DATA(File, mozilla::dom::DOMFile)
-DOMCI_DATA(Blob, mozilla::dom::DOMFile)
-
 namespace mozilla {
 namespace dom {
 
 // XXXkhuey the input stream that we pass out of a DOMFile
 // can outlive the actual DOMFile object.  Thus, we must
 // ensure that the buffer underlying the stream we get
 // from NS_NewByteInputStream is held alive as long as the
 // stream is.  We do that by passing back this class instead.
@@ -125,41 +121,48 @@ nsresult DataOwnerAdapter::Create(DataOw
 ////////////////////////////////////////////////////////////////////////////
 // mozilla::dom::DOMFile implementation
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(DOMFile)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(DOMFile)
   MOZ_ASSERT(tmp->mImpl);
   tmp->mImpl->Unlink();
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(DOMFile)
   MOZ_ASSERT(tmp->mImpl);
   tmp->mImpl->Traverse(cb);
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(DOMFile)
   // This class should not receive any nsIRemoteBlob QI!
   MOZ_ASSERT(!aIID.Equals(NS_GET_IID(nsIRemoteBlob)));
 
+  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMFile)
   NS_INTERFACE_MAP_ENTRY(nsIDOMBlob)
   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIDOMFile, IsFile())
   NS_INTERFACE_MAP_ENTRY(nsIXHRSendable)
   NS_INTERFACE_MAP_ENTRY(nsIMutable)
-  NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
-  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO_CONDITIONAL(File, IsFile())
-  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO_CONDITIONAL(Blob, !(IsFile()))
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(DOMFile)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(DOMFile)
 
 /* static */ already_AddRefed<DOMFile>
+DOMFile::CreateDOMBlob()
+{
+  nsRefPtr<DOMFile> file = new DOMFile(new DOMMultipartFileImpl());
+  return file.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
 DOMFile::Create(const nsAString& aName, const nsAString& aContentType,
                 uint64_t aLength, uint64_t aLastModifiedDate)
 {
   nsRefPtr<DOMFile> file = new DOMFile(
     new DOMFileImplBase(aName, aContentType, aLength, aLastModifiedDate));
   return file.forget();
 }
 
@@ -245,29 +248,37 @@ DOMFile::CreateFromFile(const nsAString&
   nsRefPtr<DOMFile> file = new DOMFile(
     new DOMFileImplFile(aName, aContentType, aLength, aFile, aFileInfo));
   return file.forget();
 }
 
 /* static */ already_AddRefed<DOMFile>
 DOMFile::CreateFromFile(nsIFile* aFile, indexedDB::FileInfo* aFileInfo)
 {
-  nsRefPtr<DOMFile> file = new DOMFile(new DOMFileImplFile(aFile, aFileInfo));
+  nsRefPtr<DOMFile> file = new DOMFile(
+    new DOMFileImplFile(aFile, aFileInfo));
   return file.forget();
 }
 
 /* static */ already_AddRefed<DOMFile>
 DOMFile::CreateFromFile(nsIFile* aFile, const nsAString& aName,
                         const nsAString& aContentType)
 {
   nsRefPtr<DOMFile> file = new DOMFile(
     new DOMFileImplFile(aFile, aName, aContentType));
   return file.forget();
 }
 
+DOMFile::DOMFile(DOMFileImpl* aImpl)
+  : mImpl(aImpl)
+{
+  MOZ_ASSERT(mImpl);
+  SetIsDOMBinding();
+}
+
 const nsTArray<nsRefPtr<DOMFileImpl>>*
 DOMFile::GetSubBlobImpls() const
 {
   return mImpl->GetSubBlobImpls();
 }
 
 bool
 DOMFile::IsSizeUnknown() const
@@ -289,77 +300,136 @@ DOMFile::IsFile() const
 
 void
 DOMFile::SetLazyData(const nsAString& aName, const nsAString& aContentType,
                      uint64_t aLength, uint64_t aLastModifiedDate)
 {
   return mImpl->SetLazyData(aName, aContentType, aLength, aLastModifiedDate);
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFile>
 DOMFile::CreateSlice(uint64_t aStart, uint64_t aLength,
-                     const nsAString& aContentType)
+                     const nsAString& aContentType,
+                     ErrorResult& aRv)
 {
-  return mImpl->CreateSlice(aStart, aLength, aContentType);
-}
+  nsRefPtr<DOMFileImpl> impl = mImpl->CreateSlice(aStart, aLength,
+                                                  aContentType, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
 
-NS_IMETHODIMP
-DOMFile::Initialize(nsISupports* aOwner, JSContext* aCx, JSObject* aObj,
-                    const JS::CallArgs& aArgs)
-{
-  return mImpl->Initialize(aOwner, aCx, aObj, aArgs);
+  nsRefPtr<DOMFile> file = new DOMFile(impl);
+  return file.forget();
 }
 
 NS_IMETHODIMP
 DOMFile::GetName(nsAString& aFileName)
 {
-  return mImpl->GetName(aFileName);
+  mImpl->GetName(aFileName);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 DOMFile::GetPath(nsAString& aPath)
 {
   return mImpl->GetPath(aPath);
 }
 
 NS_IMETHODIMP
 DOMFile::GetLastModifiedDate(JSContext* aCx,
                              JS::MutableHandle<JS::Value> aDate)
 {
-  return mImpl->GetLastModifiedDate(aCx, aDate);
+  ErrorResult rv;
+  int64_t value = GetLastModified(rv);
+  if (rv.Failed()) {
+    return rv.ErrorCode();
+  }
+
+  JS::Rooted<JSObject*> date(aCx, JS_NewDateObjectMsec(aCx, value));
+  if (!date) {
+    return NS_ERROR_OUT_OF_MEMORY;
+  }
+
+  aDate.setObject(*date);
+  return NS_OK;
+}
+
+Date
+DOMFile::GetLastModifiedDate(ErrorResult& aRv)
+{
+  int64_t value = GetLastModified(aRv);
+  if (aRv.Failed()) {
+    return Date();
+  }
+
+  return Date(value);
+}
+
+int64_t
+DOMFile::GetLastModified(ErrorResult& aRv)
+{
+  return mImpl->GetLastModified(aRv);
 }
 
 NS_IMETHODIMP
-DOMFile::GetMozFullPath(nsAString &aFileName)
+DOMFile::GetMozFullPath(nsAString& aFileName)
 {
-  return mImpl->GetMozFullPath(aFileName);
+  ErrorResult rv;
+  GetMozFullPath(aFileName, rv);
+  return rv.ErrorCode();
+}
+
+void
+DOMFile::GetMozFullPath(nsAString& aFilename, ErrorResult& aRv)
+{
+  mImpl->GetMozFullPath(aFilename, aRv);
 }
 
 NS_IMETHODIMP
-DOMFile::GetMozFullPathInternal(nsAString &aFileName)
+DOMFile::GetMozFullPathInternal(nsAString& aFileName)
 {
-  return mImpl->GetMozFullPathInternal(aFileName);
+  ErrorResult rv;
+  mImpl->GetMozFullPathInternal(aFileName, rv);
+  return rv.ErrorCode();
 }
 
 NS_IMETHODIMP
 DOMFile::GetSize(uint64_t* aSize)
 {
-  return mImpl->GetSize(aSize);
+  ErrorResult rv;
+  *aSize = GetSize(rv);
+  return rv.ErrorCode();
+}
+
+uint64_t
+DOMFile::GetSize(ErrorResult& aRv)
+{
+  return mImpl->GetSize(aRv);
 }
 
 NS_IMETHODIMP
 DOMFile::GetType(nsAString &aType)
 {
-  return mImpl->GetType(aType);
+  ErrorResult rv;
+  GetType(aType, rv);
+  return rv.ErrorCode();
+}
+
+void
+DOMFile::GetType(nsAString& aType, ErrorResult& aRv)
+{
+  return mImpl->GetType(aType, aRv);
 }
 
 NS_IMETHODIMP
 DOMFile::GetMozLastModifiedDate(uint64_t* aDate)
 {
-  return mImpl->GetMozLastModifiedDate(aDate);
+  ErrorResult rv;
+  *aDate = GetLastModified(rv);
+  return rv.ErrorCode();
 }
 
 // Makes sure that aStart and aEnd is less then or equal to aSize and greater
 // than 0
 static void
 ParseSize(int64_t aSize, int64_t& aStart, int64_t& aEnd)
 {
   CheckedInt64 newStartOffset = aStart;
@@ -394,18 +464,55 @@ ParseSize(int64_t aSize, int64_t& aStart
   }
 }
 
 NS_IMETHODIMP
 DOMFile::Slice(int64_t aStart, int64_t aEnd,
                const nsAString& aContentType, uint8_t aArgc,
                nsIDOMBlob **aBlob)
 {
-  MOZ_ASSERT(mImpl);
-  return mImpl->Slice(aStart, aEnd, aContentType, aArgc, aBlob);
+  Optional<int64_t> start;
+  if (aArgc > 0) {
+    start.Construct(aStart);
+  }
+
+  Optional<int64_t> end;
+  if (aArgc > 1) {
+    end.Construct(aEnd);
+  }
+
+  Optional<nsAString> contentType;
+  if (aArgc > 1) {
+    contentType = &aContentType;
+  }
+
+  ErrorResult rv;
+  nsRefPtr<DOMFile> file = Slice(start, end, contentType, rv);
+  if (rv.Failed()) {
+    return rv.ErrorCode();
+  }
+
+  file.forget(aBlob);
+  return NS_OK;
+}
+
+already_AddRefed<DOMFile>
+DOMFile::Slice(const Optional<int64_t>& aStart,
+               const Optional<int64_t>& aEnd,
+               const Optional<nsAString>& aContentType,
+               ErrorResult& aRv)
+{
+  nsRefPtr<DOMFileImpl> impl =
+    mImpl->Slice(aStart, aEnd, aContentType, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+
+  nsRefPtr<DOMFile> file = new DOMFile(impl);
+  return file.forget();
 }
 
 NS_IMETHODIMP
 DOMFile::GetInternalStream(nsIInputStream** aStream)
 {
  return mImpl->GetInternalStream(aStream);
 }
 
@@ -455,148 +562,246 @@ DOMFile::SetMutable(bool aMutable)
 }
 
 NS_IMETHODIMP_(bool)
 DOMFile::IsMemoryFile()
 {
   return mImpl->IsMemoryFile();
 }
 
+JSObject*
+DOMFile::WrapObject(JSContext* aCx)
+{
+  return IsFile() ? FileBinding::Wrap(aCx, this)
+                  : BlobBinding::Wrap(aCx, this);
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(const GlobalObject& aGlobal, ErrorResult& aRv)
+{
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl();
+  MOZ_ASSERT(!impl->IsFile());
+
+  impl->InitializeBlob();
+
+  nsRefPtr<DOMFile> file = new DOMFile(impl);
+
+  return file.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(
+        const GlobalObject& aGlobal,
+        const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+        const BlobPropertyBag& aBag,
+        ErrorResult& aRv)
+{
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl();
+
+  impl->InitializeBlob(aGlobal.Context(), aData, aBag, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+  MOZ_ASSERT(!impl->IsFile());
+
+  nsRefPtr<DOMFile> file = new DOMFile(impl);
+
+  return file.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(
+        const GlobalObject& aGlobal,
+        const Sequence<OwningArrayBufferOrArrayBufferViewOrBlobOrString>& aData,
+        const nsAString& aName,
+        const FilePropertyBag& aBag,
+        ErrorResult& aRv)
+{
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl(aName);
+
+// TODO: read the spec about the FilePropertyBag
+  impl->InitializeBlob(aGlobal.Context(), aData, aBag, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+  MOZ_ASSERT(impl->IsFile());
+
+  nsRefPtr<DOMFile> file = new DOMFile(impl);
+
+  return file.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(const GlobalObject& aGlobal,
+                     DOMFile& aData,
+                     const FilePropertyBag& aBag,
+                     ErrorResult& aRv)
+{
+  if (!nsContentUtils::IsCallerChrome()) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl(EmptyString());
+  impl->InitializeChromeFile(aData, aBag, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+  MOZ_ASSERT(impl->IsFile());
+
+  nsRefPtr<DOMFile> domFile = new DOMFile(impl);
+
+  return domFile.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(const GlobalObject& aGlobal,
+                     nsIFile* aData,
+                     const FilePropertyBag& aBag,
+                     ErrorResult& aRv)
+{
+  if (!nsContentUtils::IsCallerChrome()) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl(EmptyString());
+  impl->InitializeChromeFile(aData, aBag, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+  MOZ_ASSERT(impl->IsFile());
+
+  nsRefPtr<DOMFile> domFile = new DOMFile(impl);
+
+  return domFile.forget();
+}
+
+/* static */ already_AddRefed<DOMFile>
+DOMFile::Constructor(const GlobalObject& aGlobal,
+                     const nsAString& aData,
+                     const FilePropertyBag& aBag,
+                     ErrorResult& aRv)
+{
+  if (!nsContentUtils::IsCallerChrome()) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return nullptr;
+  }
+
+  nsRefPtr<DOMMultipartFileImpl> impl = new DOMMultipartFileImpl(EmptyString());
+  impl->InitializeChromeFile(aData, aBag, aRv);
+  if (aRv.Failed()) {
+    return nullptr;
+  }
+  MOZ_ASSERT(impl->IsFile());
+
+  nsRefPtr<DOMFile> domFile = new DOMFile(impl);
+
+  return domFile.forget();
+}
+
 ////////////////////////////////////////////////////////////////////////////
 // mozilla::dom::DOMFileImpl implementation
 
-nsresult
-DOMFileImpl::Slice(int64_t aStart, int64_t aEnd,
-                   const nsAString& aContentType, uint8_t aArgc,
-                   nsIDOMBlob **aBlob)
+already_AddRefed<DOMFileImpl>
+DOMFileImpl::Slice(const Optional<int64_t>& aStart,
+                   const Optional<int64_t>& aEnd,
+                   const Optional<nsAString>& aContentType,
+                   ErrorResult& aRv)
 {
-  *aBlob = nullptr;
-
   // Truncate aStart and aEnd so that we stay within this file.
-  uint64_t thisLength;
-  nsresult rv = GetSize(&thisLength);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (aArgc < 2) {
-    aEnd = (int64_t)thisLength;
+  uint64_t thisLength = GetSize(aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
   }
 
-  ParseSize((int64_t)thisLength, aStart, aEnd);
+  int64_t start = aStart.WasPassed() ? aStart.Value() : 0;
+  int64_t end = aEnd.WasPassed() ? aEnd.Value() : (int64_t)thisLength;
+
+  nsString contentType;
+  if (aContentType.WasPassed()) {
+    contentType = aContentType.Value();
+  }
+
+  ParseSize((int64_t)thisLength, start, end);
 
   // Create the new file
-  nsCOMPtr<nsIDOMBlob> blob =
-    CreateSlice((uint64_t)aStart, (uint64_t)(aEnd - aStart), aContentType);
-
-  blob.forget(aBlob);
-  return *aBlob ? NS_OK : NS_ERROR_UNEXPECTED;
+  return CreateSlice((uint64_t)start, (uint64_t)(end - start),
+                     contentType, aRv);
 }
 
 ////////////////////////////////////////////////////////////////////////////
 // DOMFileImpl implementation
 
 NS_IMPL_ISUPPORTS(DOMFileImpl, PIDOMFileImpl)
 
 ////////////////////////////////////////////////////////////////////////////
 // DOMFileImplFile implementation
 
 NS_IMPL_ISUPPORTS_INHERITED0(DOMFileImplFile, DOMFileImpl)
 
-nsresult
+void
 DOMFileImplBase::GetName(nsAString& aName)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
   aName = mName;
-  return NS_OK;
 }
 
 nsresult
 DOMFileImplBase::GetPath(nsAString& aPath)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
   aPath = mPath;
   return NS_OK;
 }
 
-nsresult
-DOMFileImplBase::GetLastModifiedDate(JSContext* aCx,
-                                     JS::MutableHandle<JS::Value> aDate)
-{
-  JS::Rooted<JSObject*> date(aCx, JS_NewDateObjectMsec(aCx, JS_Now() / PR_USEC_PER_MSEC));
-  if (!date) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  aDate.setObject(*date);
-  return NS_OK;
-}
-
-nsresult
-DOMFileImplBase::GetMozFullPath(nsAString &aFileName)
+void
+DOMFileImplBase::GetMozFullPath(nsAString& aFileName, ErrorResult& aRv)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
 
   // It is unsafe to call IsCallerChrome on a non-main thread. If
   // you hit the following assertion you need to figure out some other way to
   // determine privileges and call GetMozFullPathInternal.
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
   if (nsContentUtils::IsCallerChrome()) {
-    return GetMozFullPathInternal(aFileName);
-  }
-  aFileName.Truncate();
-  return NS_OK;
-}
-
-nsresult
-DOMFileImplBase::GetMozFullPathInternal(nsAString& aFileName)
-{
-  if (!mIsFile) {
-    return NS_ERROR_FAILURE;
+    GetMozFullPathInternal(aFileName, aRv);
+    return;
   }
 
   aFileName.Truncate();
-  return NS_OK;
 }
 
-nsresult
-DOMFileImplBase::GetSize(uint64_t* aSize)
+void
+DOMFileImplBase::GetMozFullPathInternal(nsAString& aFileName, ErrorResult& aRv)
 {
-  *aSize = mLength;
-  return NS_OK;
+  if (!mIsFile) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return;
+  }
+
+  aFileName.Truncate();
 }
 
-nsresult
-DOMFileImplBase::GetType(nsAString& aType)
+void
+DOMFileImplBase::GetType(nsAString& aType, ErrorResult& aRv)
 {
   aType = mContentType;
-  return NS_OK;
 }
 
-nsresult
-DOMFileImplBase::GetMozLastModifiedDate(uint64_t* aLastModifiedDate)
+int64_t
+DOMFileImplBase::GetLastModified(ErrorResult& aRv)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
   if (IsDateUnknown()) {
     mLastModificationDate = PR_Now();
   }
-  *aLastModifiedDate = mLastModificationDate;
-  return NS_OK;
-}
 
-already_AddRefed<nsIDOMBlob>
-DOMFileImplBase::CreateSlice(uint64_t aStart, uint64_t aLength,
-                             const nsAString& aContentType)
-{
-  return nullptr;
-}
-
-nsresult
-DOMFileImplBase::GetInternalStream(nsIInputStream** aStream)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return mLastModificationDate / PR_USEC_PER_MSEC;
 }
 
 nsresult
 DOMFileImplBase::GetInternalUrl(nsIPrincipal* aPrincipal, nsAString& aURL)
 {
   NS_ENSURE_STATE(aPrincipal);
 
   nsCString url;
@@ -694,22 +899,27 @@ DOMFileImplBase::GetSendInfo(nsIInputStr
                              nsACString& aCharset)
 {
   nsresult rv;
 
   nsCOMPtr<nsIInputStream> stream;
   rv = this->GetInternalStream(getter_AddRefs(stream));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  rv = this->GetSize(aContentLength);
-  NS_ENSURE_SUCCESS(rv, rv);
+  ErrorResult error;
+  *aContentLength = GetSize(error);
+  if (NS_WARN_IF(error.Failed())) {
+    return error.ErrorCode();
+  }
 
   nsString contentType;
-  rv = this->GetType(contentType);
-  NS_ENSURE_SUCCESS(rv, rv);
+  this->GetType(contentType, error);
+  if (error.Failed()) {
+    return error.ErrorCode();
+  }
 
   CopyUTF16toUTF8(contentType, aContentType);
 
   aCharset.Truncate();
 
   stream.forget(aBody);
   return NS_OK;
 }
@@ -725,135 +935,118 @@ nsresult
 DOMFileImplBase::SetMutable(bool aMutable)
 {
   nsresult rv = NS_OK;
 
   NS_ENSURE_ARG(!mImmutable || !aMutable);
 
   if (!mImmutable && !aMutable) {
     // Force the content type and size to be cached
+    ErrorResult error;
     nsString dummyString;
-    rv = this->GetType(dummyString);
-    NS_ENSURE_SUCCESS(rv, rv);
+    GetType(dummyString, error);
+    if (error.Failed()) {
+      return error.ErrorCode();
+    }
 
-    uint64_t dummyInt;
-    rv = this->GetSize(&dummyInt);
-    NS_ENSURE_SUCCESS(rv, rv);
+    GetSize(error);
+    if (NS_WARN_IF(error.Failed())) {
+      return error.ErrorCode();
+    }
   }
 
   mImmutable = !aMutable;
   return rv;
 }
 
 ////////////////////////////////////////////////////////////////////////////
 // DOMFileImplFile implementation
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 DOMFileImplFile::CreateSlice(uint64_t aStart, uint64_t aLength,
-                             const nsAString& aContentType)
+                             const nsAString& aContentType,
+                             ErrorResult& aRv)
 {
-  nsCOMPtr<nsIDOMBlob> blob =
-    new DOMFile(new DOMFileImplFile(this, aStart, aLength, aContentType));
-  return blob.forget();
+  nsRefPtr<DOMFileImpl> impl =
+    new DOMFileImplFile(this, aStart, aLength, aContentType);
+  return impl.forget();
 }
 
-nsresult
-DOMFileImplFile::GetMozFullPathInternal(nsAString& aFilename)
+void
+DOMFileImplFile::GetMozFullPathInternal(nsAString& aFilename, ErrorResult& aRv)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
-  return mFile->GetPath(aFilename);
+  aRv = mFile->GetPath(aFilename);
 }
 
-nsresult
-DOMFileImplFile::GetLastModifiedDate(JSContext* aCx,
-                                     JS::MutableHandle<JS::Value> aLastModifiedDate)
-{
-  NS_ASSERTION(mIsFile, "Should only be called on files");
-
-  PRTime msecs;
-  if (IsDateUnknown()) {
-    nsresult rv = mFile->GetLastModifiedTime(&msecs);
-    NS_ENSURE_SUCCESS(rv, rv);
-    mLastModificationDate = msecs;
-  } else {
-    msecs = mLastModificationDate;
-  }
-
-  JSObject* date = JS_NewDateObjectMsec(aCx, msecs);
-  if (date) {
-    aLastModifiedDate.setObject(*date);
-  }
-  else {
-    date = JS_NewDateObjectMsec(aCx, JS_Now() / PR_USEC_PER_MSEC);
-    aLastModifiedDate.setObject(*date);
-  }
-
-  return NS_OK;
-}
-
-nsresult
-DOMFileImplFile::GetSize(uint64_t* aFileSize)
+uint64_t
+DOMFileImplFile::GetSize(ErrorResult& aRv)
 {
   if (IsSizeUnknown()) {
     NS_ASSERTION(mWholeFile,
                  "Should only use lazy size when using the whole file");
     int64_t fileSize;
-    nsresult rv = mFile->GetFileSize(&fileSize);
-    NS_ENSURE_SUCCESS(rv, rv);
+    aRv = mFile->GetFileSize(&fileSize);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return 0;
+    }
 
     if (fileSize < 0) {
-      return NS_ERROR_FAILURE;
+      aRv.Throw(NS_ERROR_FAILURE);
+      return 0;
     }
 
     mLength = fileSize;
   }
 
-  *aFileSize = mLength;
-
-  return NS_OK;
+  return mLength;
 }
 
-nsresult
-DOMFileImplFile::GetType(nsAString& aType)
+void
+DOMFileImplFile::GetType(nsAString& aType, ErrorResult& aRv)
 {
   if (mContentType.IsVoid()) {
     NS_ASSERTION(mWholeFile,
                  "Should only use lazy ContentType when using the whole file");
     nsresult rv;
     nsCOMPtr<nsIMIMEService> mimeService =
       do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aRv.Throw(rv);
+      return;
+    }
 
     nsAutoCString mimeType;
     rv = mimeService->GetTypeFromFile(mFile, mimeType);
     if (NS_FAILED(rv)) {
       mimeType.Truncate();
     }
 
     AppendUTF8toUTF16(mimeType, mContentType);
     mContentType.SetIsVoid(false);
   }
 
   aType = mContentType;
-
-  return NS_OK;
 }
 
-nsresult
-DOMFileImplFile::GetMozLastModifiedDate(uint64_t* aLastModifiedDate)
+int64_t
+DOMFileImplFile::GetLastModified(ErrorResult& aRv)
 {
   NS_ASSERTION(mIsFile, "Should only be called on files");
   if (IsDateUnknown()) {
     PRTime msecs;
-    nsresult rv = mFile->GetLastModifiedTime(&msecs);
-    NS_ENSURE_SUCCESS(rv, rv);
+    aRv = mFile->GetLastModifiedTime(&msecs);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return 0;
+    }
+
     mLastModificationDate = msecs;
   }
-  *aLastModifiedDate = mLastModificationDate;
-  return NS_OK;
+
+  return mLastModificationDate;
 }
 
 const uint32_t sFileStreamFlags =
   nsIFileInputStream::CLOSE_ON_EOF |
   nsIFileInputStream::REOPEN_ON_REWIND |
   nsIFileInputStream::DEFER_OPEN;
 
 nsresult
@@ -874,23 +1067,24 @@ DOMFileImplFile::SetPath(const nsAString
   mPath = aPath;
 }
 
 ////////////////////////////////////////////////////////////////////////////
 // DOMFileImplMemory implementation
 
 NS_IMPL_ISUPPORTS_INHERITED0(DOMFileImplMemory, DOMFileImpl)
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 DOMFileImplMemory::CreateSlice(uint64_t aStart, uint64_t aLength,
-                               const nsAString& aContentType)
+                               const nsAString& aContentType,
+                               ErrorResult& aRv)
 {
-  nsCOMPtr<nsIDOMBlob> blob =
-    new DOMFile(new DOMFileImplMemory(this, aStart, aLength, aContentType));
-  return blob.forget();
+  nsRefPtr<DOMFileImpl> impl =
+    new DOMFileImplMemory(this, aStart, aLength, aContentType);
+  return impl.forget();
 }
 
 nsresult
 DOMFileImplMemory::GetInternalStream(nsIInputStream** aStream)
 {
   if (mLength > INT32_MAX)
     return NS_ERROR_FAILURE;
 
@@ -999,41 +1193,41 @@ DOMFileImplMemory::DataOwner::EnsureMemo
   sMemoryReporterRegistered = true;
 }
 
 ////////////////////////////////////////////////////////////////////////////
 // DOMFileImplTemporaryFileBlob implementation
 
 NS_IMPL_ISUPPORTS_INHERITED0(DOMFileImplTemporaryFileBlob, DOMFileImpl)
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 DOMFileImplTemporaryFileBlob::CreateSlice(uint64_t aStart, uint64_t aLength,
-                                          const nsAString& aContentType)
+                                          const nsAString& aContentType,
+                                          ErrorResult& aRv)
 {
-  if (aStart + aLength > mLength)
+  if (aStart + aLength > mLength) {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
+  }
 
-  nsCOMPtr<nsIDOMBlob> blob =
-    new DOMFile(new DOMFileImplTemporaryFileBlob(this, aStart + mStartPos,
-                                                 aLength, aContentType));
-  return blob.forget();
+  nsRefPtr<DOMFileImpl> impl =
+    new DOMFileImplTemporaryFileBlob(this, aStart + mStartPos,
+                                     aLength, aContentType);
+  return impl.forget();
 }
 
 nsresult
 DOMFileImplTemporaryFileBlob::GetInternalStream(nsIInputStream** aStream)
 {
   nsCOMPtr<nsIInputStream> stream =
     new nsTemporaryFileInputStream(mFileDescOwner, mStartPos, mStartPos + mLength);
   stream.forget(aStream);
   return NS_OK;
 }
 
-} // dom namespace
-} // mozilla namespace
-
 ////////////////////////////////////////////////////////////////////////////
 // nsDOMFileList implementation
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(nsDOMFileList)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMFileList)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMFileList)
@@ -1055,12 +1249,15 @@ nsDOMFileList::GetLength(uint32_t* aLeng
   *aLength = Length();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMFileList::Item(uint32_t aIndex, nsIDOMFile **aFile)
 {
-  NS_IF_ADDREF(*aFile = Item(aIndex));
-
+  nsRefPtr<DOMFile> file = Item(aIndex);
+  file.forget(aFile);
   return NS_OK;
 }
+
+} // dom namespace
+} // mozilla namespace
diff --git a/content/base/src/nsDOMFileReader.cpp b/content/base/src/nsDOMFileReader.cpp
--- a/content/base/src/nsDOMFileReader.cpp
+++ b/content/base/src/nsDOMFileReader.cpp
@@ -184,45 +184,49 @@ nsDOMFileReader::GetError(nsISupports** 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDOMFileReader::ReadAsArrayBuffer(nsIDOMBlob* aFile, JSContext* aCx)
 {
   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
   ErrorResult rv;
-  ReadAsArrayBuffer(aCx, aFile, rv);
+  nsRefPtr<DOMFile> file = static_cast<DOMFile*>(aFile);
+  ReadAsArrayBuffer(aCx, *file, rv);
   return rv.ErrorCode();
 }
 
 NS_IMETHODIMP
 nsDOMFileReader::ReadAsBinaryString(nsIDOMBlob* aFile)
 {
   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
   ErrorResult rv;
-  ReadAsBinaryString(aFile, rv);
+  nsRefPtr<DOMFile> file = static_cast<DOMFile*>(aFile);
+  ReadAsBinaryString(*file, rv);
   return rv.ErrorCode();
 }
 
 NS_IMETHODIMP
 nsDOMFileReader::ReadAsText(nsIDOMBlob* aFile,
                             const nsAString &aCharset)
 {
   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
   ErrorResult rv;
-  ReadAsText(aFile, aCharset, rv);
+  nsRefPtr<DOMFile> file = static_cast<DOMFile*>(aFile);
+  ReadAsText(*file, aCharset, rv);
   return rv.ErrorCode();
 }
 
 NS_IMETHODIMP
 nsDOMFileReader::ReadAsDataURL(nsIDOMBlob* aFile)
 {
   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
   ErrorResult rv;
-  ReadAsDataURL(aFile, rv);
+  nsRefPtr<DOMFile> file = static_cast<DOMFile*>(aFile);
+  ReadAsDataURL(*file, rv);
   return rv.ErrorCode();
 }
 
 NS_IMETHODIMP
 nsDOMFileReader::Abort()
 {
   ErrorResult rv;
   FileIOObject::Abort(rv);
@@ -364,33 +368,31 @@ nsDOMFileReader::DoReadData(nsIAsyncInpu
   mDataLen += aCount;
   return NS_OK;
 }
 
 // Helper methods
 
 void
 nsDOMFileReader::ReadFileContent(JSContext* aCx,
-                                 nsIDOMBlob* aFile,
+                                 DOMFile& aFile,
                                  const nsAString &aCharset,
                                  eDataFormat aDataFormat,
                                  ErrorResult& aRv)
 {
-  MOZ_ASSERT(aFile);
-
   //Implicit abort to clear any other activity going on
   Abort();
   mError = nullptr;
   SetDOMStringToNull(mResult);
   mTransferred = 0;
   mTotal = 0;
   mReadyState = nsIDOMFileReader::EMPTY;
   FreeFileData();
 
-  mFile = aFile;
+  mFile = &aFile;
   mDataFormat = aDataFormat;
   CopyUTF16toUTF8(aCharset, mCharset);
 
   nsresult rv;
 
   nsCOMPtr<nsIStreamTransportService> sts =
     do_GetService(kStreamTransportServiceCID, &rv);
   if (NS_WARN_IF(NS_FAILED(rv))) {
diff --git a/content/base/src/nsDOMFileReader.h b/content/base/src/nsDOMFileReader.h
--- a/content/base/src/nsDOMFileReader.h
+++ b/content/base/src/nsDOMFileReader.h
@@ -14,30 +14,31 @@
 #include "nsIInterfaceRequestor.h"
 #include "nsJSUtils.h"
 #include "nsTArray.h"
 #include "nsIJSNativeInitializer.h"
 #include "prtime.h"
 #include "nsITimer.h"
 #include "nsIAsyncInputStream.h"
 
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "nsIDOMFileReader.h"
 #include "nsIDOMFileList.h"
 #include "nsCOMPtr.h"
 
 #include "FileIOObject.h"
 
 class nsDOMFileReader : public mozilla::dom::FileIOObject,
                         public nsIDOMFileReader,
                         public nsIInterfaceRequestor,
                         public nsSupportsWeakReference
 {
   typedef mozilla::ErrorResult ErrorResult;
   typedef mozilla::dom::GlobalObject GlobalObject;
+  typedef mozilla::dom::DOMFile DOMFile;
 public:
   nsDOMFileReader();
 
   NS_DECL_ISUPPORTS_INHERITED
 
   NS_DECL_NSIDOMFILEREADER
 
   NS_REALLY_FORWARD_NSIDOMEVENTTARGET(mozilla::DOMEventTargetHelper)
@@ -57,31 +58,28 @@ public:
   {
     return GetOwner();
   }
   virtual JSObject* WrapObject(JSContext* aCx) MOZ_OVERRIDE;
 
   // WebIDL
   static already_AddRefed<nsDOMFileReader>
   Constructor(const GlobalObject& aGlobal, ErrorResult& aRv);
-  void ReadAsArrayBuffer(JSContext* aCx, nsIDOMBlob* aBlob, ErrorResult& aRv)
+  void ReadAsArrayBuffer(JSContext* aCx, DOMFile& aBlob, ErrorResult& aRv)
   {
-    MOZ_ASSERT(aBlob);
     ReadFileContent(aCx, aBlob, EmptyString(), FILE_AS_ARRAYBUFFER, aRv);
   }
 
-  void ReadAsText(nsIDOMBlob* aBlob, const nsAString& aLabel, ErrorResult& aRv)
+  void ReadAsText(DOMFile& aBlob, const nsAString& aLabel, ErrorResult& aRv)
   {
-    MOZ_ASSERT(aBlob);
     ReadFileContent(nullptr, aBlob, aLabel, FILE_AS_TEXT, aRv);
   }
 
-  void ReadAsDataURL(nsIDOMBlob* aBlob, ErrorResult& aRv)
+  void ReadAsDataURL(DOMFile& aBlob, ErrorResult& aRv)
   {
-    MOZ_ASSERT(aBlob);
     ReadFileContent(nullptr, aBlob, EmptyString(), FILE_AS_DATAURL, aRv);
   }
 
   using FileIOObject::Abort;
 
   // Inherited ReadyState().
 
   void GetResult(JSContext* aCx, JS::MutableHandle<JS::Value> aResult,
@@ -94,19 +92,18 @@ public:
   using FileIOObject::SetOnprogress;
   IMPL_EVENT_HANDLER(load)
   using FileIOObject::GetOnabort;
   using FileIOObject::SetOnabort;
   using FileIOObject::GetOnerror;
   using FileIOObject::SetOnerror;
   IMPL_EVENT_HANDLER(loadend)
 
-  void ReadAsBinaryString(nsIDOMBlob* aBlob, ErrorResult& aRv)
+  void ReadAsBinaryString(DOMFile& aBlob, ErrorResult& aRv)
   {
-    MOZ_ASSERT(aBlob);
     ReadFileContent(nullptr, aBlob, EmptyString(), FILE_AS_BINARY, aRv);
   }
 
 
   nsresult Init();
 
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED(nsDOMFileReader,
                                                          FileIOObject)
@@ -117,17 +114,17 @@ protected:
 
   enum eDataFormat {
     FILE_AS_ARRAYBUFFER,
     FILE_AS_BINARY,
     FILE_AS_TEXT,
     FILE_AS_DATAURL
   };
 
-  void ReadFileContent(JSContext* aCx, nsIDOMBlob* aBlob,
+  void ReadFileContent(JSContext* aCx, DOMFile& aBlob,
                        const nsAString &aCharset, eDataFormat aDataFormat,
                        ErrorResult& aRv);
   nsresult GetAsText(nsIDOMBlob *aFile, const nsACString &aCharset,
                      const char *aFileData, uint32_t aDataLen, nsAString &aResult);
   nsresult GetAsDataURL(nsIDOMBlob *aFile, const char *aFileData, uint32_t aDataLen, nsAString &aResult);
 
   void FreeFileData() {
     moz_free(mFileData);
diff --git a/content/base/src/nsFormData.cpp b/content/base/src/nsFormData.cpp
--- a/content/base/src/nsFormData.cpp
+++ b/content/base/src/nsFormData.cpp
@@ -1,16 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsFormData.h"
 #include "nsIVariant.h"
 #include "nsIInputStream.h"
-#include "nsIDOMFile.h"
 #include "mozilla/dom/HTMLFormElement.h"
 #include "mozilla/dom/FormDataBinding.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 
 nsFormData::nsFormData(nsISupports* aOwner)
   : nsFormSubmission(NS_LITERAL_CSTRING("UTF-8"), nullptr)
@@ -44,26 +43,26 @@ nsFormData::GetEncodedSubmission(nsIURI*
 
 void
 nsFormData::Append(const nsAString& aName, const nsAString& aValue)
 {
   AddNameValuePair(aName, aValue);
 }
 
 void
-nsFormData::Append(const nsAString& aName, nsIDOMBlob* aBlob,
+nsFormData::Append(const nsAString& aName, DOMFile& aBlob,
                    const Optional<nsAString>& aFilename)
 {
   nsString filename;
   if (aFilename.WasPassed()) {
     filename = aFilename.Value();
   } else {
     filename.SetIsVoid(true);
   }
-  AddNameFilePair(aName, aBlob, filename);
+  AddNameFilePair(aName, &aBlob, filename);
 }
 
 // -------------------------------------------------------------------------
 // nsIDOMFormData
 
 NS_IMETHODIMP
 nsFormData::Append(const nsAString& aName, nsIVariant* aValue)
 {
@@ -76,19 +75,20 @@ nsFormData::Append(const nsAString& aNam
     nsCOMPtr<nsISupports> supports;
     nsID *iid;
     rv = aValue->GetAsInterface(&iid, getter_AddRefs(supports));
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsMemory::Free(iid);
 
     nsCOMPtr<nsIDOMBlob> domBlob = do_QueryInterface(supports);
+    nsRefPtr<DOMFile> blob = static_cast<DOMFile*>(domBlob.get());
     if (domBlob) {
       Optional<nsAString> temp;
-      Append(aName, domBlob, temp);
+      Append(aName, *blob, temp);
       return NS_OK;
     }
   }
 
   char16_t* stringData = nullptr;
   uint32_t stringLen = 0;
   rv = aValue->GetAsWStringWithSize(&stringLen, &stringData);
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/content/base/src/nsFormData.h b/content/base/src/nsFormData.h
--- a/content/base/src/nsFormData.h
+++ b/content/base/src/nsFormData.h
@@ -1,27 +1,25 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef nsFormData_h__
 #define nsFormData_h__
 
 #include "mozilla/Attributes.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "nsIDOMFormData.h"
 #include "nsIXMLHttpRequest.h"
 #include "nsFormSubmission.h"
 #include "nsWrapperCache.h"
 #include "nsTArray.h"
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/BindingDeclarations.h"
 
-class nsIDOMFile;
-
 namespace mozilla {
 class ErrorResult;
 
 namespace dom {
 class HTMLFormElement;
 class GlobalObject;
 } // namespace dom
 } // namespace mozilla
@@ -52,17 +50,17 @@ public:
   {
     return mOwner;
   }
   static already_AddRefed<nsFormData>
   Constructor(const mozilla::dom::GlobalObject& aGlobal,
               const mozilla::dom::Optional<mozilla::dom::NonNull<mozilla::dom::HTMLFormElement> >& aFormElement,
               mozilla::ErrorResult& aRv);
   void Append(const nsAString& aName, const nsAString& aValue);
-  void Append(const nsAString& aName, nsIDOMBlob* aBlob,
+  void Append(const nsAString& aName, mozilla::dom::DOMFile& aBlob,
               const mozilla::dom::Optional<nsAString>& aFilename);
 
   // nsFormSubmission
   virtual nsresult GetEncodedSubmission(nsIURI* aURI,
                                         nsIInputStream** aPostDataStream) MOZ_OVERRIDE;
   virtual nsresult AddNameValuePair(const nsAString& aName,
                                     const nsAString& aValue) MOZ_OVERRIDE
   {
diff --git a/content/base/src/nsFrameMessageManager.cpp b/content/base/src/nsFrameMessageManager.cpp
--- a/content/base/src/nsFrameMessageManager.cpp
+++ b/content/base/src/nsFrameMessageManager.cpp
@@ -23,17 +23,17 @@
 #include "nsIXULRuntime.h"
 #include "nsIScriptError.h"
 #include "nsIConsoleService.h"
 #include "nsIMemoryReporter.h"
 #include "nsIProtocolHandler.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsIJSRuntimeService.h"
 #include "nsIDOMClassInfo.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "xpcpublic.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/nsIContentParent.h"
 #include "mozilla/dom/PermissionMessageUtils.h"
 #include "mozilla/dom/StructuredCloneUtils.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "JavaScriptChild.h"
@@ -198,25 +198,25 @@ template<ActorFlavorEnum Flavor>
 static bool
 BuildClonedMessageData(typename BlobTraits<Flavor>::ConcreteContentManagerType* aManager,
                        const StructuredCloneData& aData,
                        ClonedMessageData& aClonedData)
 {
   SerializedStructuredCloneBuffer& buffer = aClonedData.data();
   buffer.data = aData.mData;
   buffer.dataLength = aData.mDataLength;
-  const nsTArray<nsCOMPtr<nsIDOMBlob> >& blobs = aData.mClosure.mBlobs;
+  const nsTArray<nsRefPtr<DOMFile>>& blobs = aData.mClosure.mBlobs;
   if (!blobs.IsEmpty()) {
     typedef typename BlobTraits<Flavor>::ProtocolType ProtocolType;
     InfallibleTArray<ProtocolType*>& blobList = DataBlobs<Flavor>::Blobs(aClonedData);
     uint32_t length = blobs.Length();
     blobList.SetCapacity(length);
     for (uint32_t i = 0; i < length; ++i) {
       typename BlobTraits<Flavor>::BlobType* protocolActor =
-        aManager->GetOrCreateActorForBlob(blobs[i]);
+        aManager->GetOrCreateActorForBlob(static_cast<DOMFile*>(blobs[i].get()));
       if (!protocolActor) {
         return false;
       }
       blobList.AppendElement(protocolActor);
     }
   }
   return true;
 }
@@ -249,17 +249,17 @@ UnpackClonedMessageData(const ClonedMess
   cloneData.mDataLength = buffer.dataLength;
   if (!blobs.IsEmpty()) {
     uint32_t length = blobs.Length();
     cloneData.mClosure.mBlobs.SetCapacity(length);
     for (uint32_t i = 0; i < length; ++i) {
       auto* blob =
         static_cast<typename BlobTraits<Flavor>::BlobType*>(blobs[i]);
       MOZ_ASSERT(blob);
-      nsCOMPtr<nsIDOMBlob> domBlob = blob->GetBlob();
+      nsRefPtr<DOMFile> domBlob = blob->GetBlob();
       MOZ_ASSERT(domBlob);
       cloneData.mClosure.mBlobs.AppendElement(domBlob);
     }
   }
   return cloneData;
 }
 
 StructuredCloneData
diff --git a/content/base/src/nsHostObjectProtocolHandler.cpp b/content/base/src/nsHostObjectProtocolHandler.cpp
--- a/content/base/src/nsHostObjectProtocolHandler.cpp
+++ b/content/base/src/nsHostObjectProtocolHandler.cpp
@@ -12,16 +12,17 @@
 #include "nsIPrincipal.h"
 #include "nsDOMFile.h"
 #include "nsIDOMMediaStream.h"
 #include "mozilla/dom/MediaSource.h"
 #include "nsIMemoryReporter.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/LoadInfo.h"
 
+using mozilla;
 using mozilla::dom::DOMFileImpl;
 using mozilla::LoadInfo;
 
 // -----------------------------------------------------------------------
 // Hash table
 struct DataInfo
 {
   // mObject is expected to be an nsIDOMBlob, nsIDOMMediaStream, or MediaSource
@@ -503,30 +504,33 @@ nsHostObjectProtocolHandler::NewChannel(
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIChannel> channel;
   rv = NS_NewInputStreamChannel(getter_AddRefs(channel),
                                 uri,
                                 stream);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  ErrorResult error;
   nsString type;
-  rv = blob->GetType(type);
-  NS_ENSURE_SUCCESS(rv, rv);
+   blob->GetType(type, error);
+  if (NS_WARN_IF(error.Failed())) {
+    return error.ErrorCode();
+  }
 
   if (blob->IsFile()) {
     nsString filename;
-    rv = blob->GetName(filename);
-    NS_ENSURE_SUCCESS(rv, rv);
+    blob->GetName(filename);
     channel->SetContentDispositionFilename(filename);
   }
 
-  uint64_t size;
-  rv = blob->GetSize(&size);
-  NS_ENSURE_SUCCESS(rv, rv);
+  uint64_t size = blob->GetSize(error);
+  if (NS_WARN_IF(error.Failed())) {
+    return error.ErrorCode();
+  }
 
   nsCOMPtr<nsILoadInfo> loadInfo =
     new mozilla::LoadInfo(info->mPrincipal, LoadInfo::eInheritPrincipal,
                           LoadInfo::eNotSandboxed);
   channel->SetLoadInfo(loadInfo);
   channel->SetOriginalURI(uri);
   channel->SetContentType(NS_ConvertUTF16toUTF8(type));
   channel->SetContentLength(size);
diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -779,18 +779,19 @@ nsXMLHttpRequest::CreateResponseParsedJS
 
 void
 nsXMLHttpRequest::CreatePartialBlob()
 {
   if (mDOMFile) {
     if (mLoadTotal == mLoadTransferred) {
       mResponseBlob = mDOMFile;
     } else {
-      mResponseBlob =
-        mDOMFile->CreateSlice(0, mLoadTransferred, EmptyString());
+      ErrorResult rv;
+      mResponseBlob = mDOMFile->CreateSlice(0, mLoadTransferred,
+                                            EmptyString(), rv);
     }
     return;
   }
 
   // mBlobSet can be null if the request has been canceled
   if (!mBlobSet) {
     return;
   }
@@ -2604,17 +2605,18 @@ nsXMLHttpRequest::GetRequestBody(nsIVari
       const ArrayBufferView* view = value.mArrayBufferView;
       view->ComputeLengthAndData();
       return ::GetRequestBody(view->Data(), view->Length(), aResult,
                               aContentLength, aContentType, aCharset);
     }
     case nsXMLHttpRequest::RequestBody::Blob:
     {
       nsresult rv;
-      nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mBlob, &rv);
+      nsCOMPtr<nsIDOMBlob> blob = value.mBlob;
+      nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(blob, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
 
       return ::GetRequestBody(sendable, aResult, aContentLength, aContentType, aCharset);
     }
     case nsXMLHttpRequest::RequestBody::Document:
     {
       nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(value.mDocument);
       return ::GetRequestBody(document, aResult, aContentLength, aContentType, aCharset);
diff --git a/content/base/src/nsXMLHttpRequest.h b/content/base/src/nsXMLHttpRequest.h
--- a/content/base/src/nsXMLHttpRequest.h
+++ b/content/base/src/nsXMLHttpRequest.h
@@ -346,17 +346,17 @@ private:
     RequestBody(const mozilla::dom::ArrayBuffer* aArrayBuffer) : mType(ArrayBuffer)
     {
       mValue.mArrayBuffer = aArrayBuffer;
     }
     RequestBody(const mozilla::dom::ArrayBufferView* aArrayBufferView) : mType(ArrayBufferView)
     {
       mValue.mArrayBufferView = aArrayBufferView;
     }
-    RequestBody(nsIDOMBlob* aBlob) : mType(Blob)
+    RequestBody(mozilla::dom::DOMFile* aBlob) : mType(Blob)
     {
       mValue.mBlob = aBlob;
     }
     RequestBody(nsIDocument* aDocument) : mType(Document)
     {
       mValue.mDocument = aDocument;
     }
     RequestBody(const nsAString& aString) : mType(DOMString)
@@ -380,17 +380,17 @@ private:
       Document,
       DOMString,
       FormData,
       InputStream
     };
     union Value {
       const mozilla::dom::ArrayBuffer* mArrayBuffer;
       const mozilla::dom::ArrayBufferView* mArrayBufferView;
-      nsIDOMBlob* mBlob;
+      mozilla::dom::DOMFile* mBlob;
       nsIDocument* mDocument;
       const nsAString* mString;
       nsFormData* mFormData;
       nsIInputStream* mStream;
     };
 
     Type GetType() const
     {
@@ -436,20 +436,19 @@ public:
   {
     aRv = Send(RequestBody(&aArrayBuffer));
   }
   void Send(const mozilla::dom::ArrayBufferView& aArrayBufferView,
             ErrorResult& aRv)
   {
     aRv = Send(RequestBody(&aArrayBufferView));
   }
-  void Send(nsIDOMBlob* aBlob, ErrorResult& aRv)
+  void Send(mozilla::dom::DOMFile& aBlob, ErrorResult& aRv)
   {
-    NS_ASSERTION(aBlob, "Null should go to string version");
-    aRv = Send(RequestBody(aBlob));
+    aRv = Send(RequestBody(&aBlob));
   }
   void Send(nsIDocument& aDoc, ErrorResult& aRv)
   {
     aRv = Send(RequestBody(&aDoc));
   }
   void Send(const nsAString& aString, ErrorResult& aRv)
   {
     if (DOMStringIsNull(aString)) {
diff --git a/content/base/test/chrome/test_bug914381.html b/content/base/test/chrome/test_bug914381.html
--- a/content/base/test/chrome/test_bug914381.html
+++ b/content/base/test/chrome/test_bug914381.html
@@ -30,17 +30,17 @@ function createFileWithData(fileData) {
   outStream.write(fileData, fileData.length);
   outStream.close();
 
   return testFile;
 }
 
 /** Test for Bug 914381. DOMFile's created in JS using an nsIFile should allow mozGetFullPathInternal calls to succeed **/
 var file = createFileWithData("Test bug 914381");
-var f = File(file);
+var f = new File(file);
 is(f.mozFullPathInternal, undefined, "mozFullPathInternal is undefined from js");
 is(f.mozFullPath, file.path, "mozFullPath returns path if created with nsIFile");
 
 f = File(file.path);
 is(f.mozFullPathInternal, undefined, "mozFullPathInternal is undefined from js");
 is(f.mozFullPath, "", "mozFullPath returns blank if created with a string");
 </script>
 </pre>
diff --git a/content/base/test/test_blobconstructor.html b/content/base/test/test_blobconstructor.html
--- a/content/base/test/test_blobconstructor.html
+++ b/content/base/test/test_blobconstructor.html
@@ -15,75 +15,75 @@ https://bugzilla.mozilla.org/show_bug.cg
 <p id="display"></p>
 <div id="content" style="display: none">
   
 </div>
 <pre id="test">
 <script class="testbody" type="text/javascript;version=1.7">
 "use strict";
 /** Test for Bug 721569 **/
-var blob = Blob();
+var blob = new Blob();
 ok(blob, "Blob should exist");
 
 ok(blob.size !== undefined, "Blob should have a size property");
 ok(blob.type !== undefined, "Blob should have a type property");
 ok(blob.slice, "Blob should have a slice method");
 
-blob = Blob([], {type: null});
+blob = new Blob([], {type: null});
 ok(blob, "Blob should exist");
 is(blob.type, "null", "Blob type should be stringified");
 
-blob = Blob([], {type: undefined});
+blob = new Blob([], {type: undefined});
 ok(blob, "Blob should exist");
 is(blob.type, "", "Blob type should be treated as missing");
 
 try {
-blob = Blob([]);
+blob = new Blob([]);
 ok(true, "an empty blobParts argument should not throw");
 } catch(e) {
 ok(false, "NOT REACHED");
 }
 
 try {
-blob = Blob(null);
+blob = new Blob(null);
 ok(false, "NOT REACHED");
 } catch(e) {
 ok(true, "a null blobParts member should throw");
 }
 
 try {
-blob = Blob([], null);
+blob = new Blob([], null);
 ok(true, "a null options member should not throw");
 } catch(e) {
 ok(false, "NOT REACHED");
 }
 
 try {
-blob = Blob([], undefined);
+blob = new Blob([], undefined);
 ok(true, "an undefined options member should not throw");
 } catch(e) {
 ok(false, "NOT REACHED");
 }
 
 try {
-blob = Blob([], false);
+blob = new Blob([], false);
 ok(false, "NOT REACHED");
 } catch(e) {
 ok(true, "a boolean options member should throw");
 }
 
 try {
-blob = Blob([], 0);
+blob = new Blob([], 0);
 ok(false, "NOT REACHED");
 } catch(e) {
 ok(true, "a numeric options member should throw");
 }
 
 try {
-blob = Blob([], "");
+blob = new Blob([], "");
 ok(false, "NOT REACHED");
 } catch(e) {
 ok(true, "a string options member should throw");
 }
 
 /** Test for dictionary initialization order **/
 (function() {
   var o = {};
@@ -95,23 +95,23 @@ ok(true, "a string options member should
   }
   ["type", "endings"].forEach(function(n) {
     Object.defineProperty(o, n, { get: add_to_called.bind(null, n) });
   });
   var b = new Blob([], o);
   is(JSON.stringify(called), JSON.stringify(["endings", "type"]), "dictionary members should be get in lexicographical order");
 })();
 
-let blob1 = Blob(["squiggle"]);
+let blob1 = new Blob(["squiggle"]);
 ok(blob1 instanceof Blob, "Blob constructor should produce Blobs");
 ok(!(blob1 instanceof File), "Blob constructor should not produce Files");
 is(blob1.type, "", "Blob constructor with no options should return Blob with empty type");
 is(blob1.size, 8, "Blob constructor should return Blob with correct size");
 
-let blob2 = Blob(["steak"], {type: "content/type"});
+let blob2 = new Blob(["steak"], {type: "content/type"});
 ok(blob2 instanceof Blob, "Blob constructor should produce Blobs");
 ok(!(blob2 instanceof File), "Blob constructor should not produce Files");
 is(blob2.type, "content/type", "Blob constructor with a type option should return Blob with the type");
 is(blob2.size, 5, "Blob constructor should return Blob with correct size");
 
 
 let aB = new ArrayBuffer(16);
 var int8View = new Int8Array(aB);
diff --git a/content/html/content/public/HTMLCanvasElement.h b/content/html/content/public/HTMLCanvasElement.h
--- a/content/html/content/public/HTMLCanvasElement.h
+++ b/content/html/content/public/HTMLCanvasElement.h
@@ -11,31 +11,31 @@
 #include "nsGenericHTMLElement.h"
 #include "nsGkAtoms.h"
 #include "nsSize.h"
 #include "nsError.h"
 
 #include "mozilla/gfx/Rect.h"
 
 class nsICanvasRenderingContextInternal;
-class nsIDOMFile;
 class nsITimerCallback;
 
 namespace mozilla {
 
 namespace layers {
 class CanvasLayer;
 class LayerManager;
 }
 namespace gfx {
 class SourceSurface;
 }
 
 namespace dom {
 
+class DOMFile;
 class FileCallback;
 class HTMLCanvasPrintState;
 class PrintCallback;
 
 class HTMLCanvasElement MOZ_FINAL : public nsGenericHTMLElement,
                                     public nsIDOMHTMLCanvasElement
 {
   enum {
@@ -97,19 +97,19 @@ public:
   bool MozOpaque() const
   {
     return GetBoolAttr(nsGkAtoms::moz_opaque);
   }
   void SetMozOpaque(bool aValue, ErrorResult& aRv)
   {
     SetHTMLBoolAttr(nsGkAtoms::moz_opaque, aValue, aRv);
   }
-  already_AddRefed<nsIDOMFile> MozGetAsFile(const nsAString& aName,
-                                            const nsAString& aType,
-                                            ErrorResult& aRv);
+  already_AddRefed<DOMFile> MozGetAsFile(const nsAString& aName,
+                                         const nsAString& aType,
+                                         ErrorResult& aRv);
   already_AddRefed<nsISupports> MozGetIPCContext(const nsAString& aContextId,
                                                  ErrorResult& aRv)
   {
     nsCOMPtr<nsISupports> context;
     aRv = MozGetIPCContext(aContextId, getter_AddRefs(context));
     return context.forget();
   }
   void MozFetchAsStream(nsIInputStreamCallback* aCallback,
@@ -221,19 +221,16 @@ protected:
                        bool* usingCustomParseOptions);
   nsresult ExtractData(nsAString& aType,
                        const nsAString& aOptions,
                        nsIInputStream** aStream);
   nsresult ToDataURLImpl(JSContext* aCx,
                          const nsAString& aMimeType,
                          const JS::Value& aEncoderOptions,
                          nsAString& aDataURL);
-  nsresult MozGetAsFileImpl(const nsAString& aName,
-                            const nsAString& aType,
-                            nsIDOMFile** aResult);
   nsresult GetContextHelper(const nsAString& aContextId,
                             nsICanvasRenderingContextInternal **aContext);
   void CallPrintCallback();
 
   nsString mCurrentContextId;
   nsRefPtr<HTMLCanvasElement> mOriginalCanvas;
   nsRefPtr<PrintCallback> mPrintCallback;
   nsCOMPtr<nsICanvasRenderingContextInternal> mCurrentContext;
diff --git a/content/html/content/src/HTMLCanvasElement.cpp b/content/html/content/src/HTMLCanvasElement.cpp
--- a/content/html/content/src/HTMLCanvasElement.cpp
+++ b/content/html/content/src/HTMLCanvasElement.cpp
@@ -557,73 +557,76 @@ HTMLCanvasElement::ToBlob(JSContext* aCx
                                        imageBuffer,
                                        format,
                                        GetSize(),
                                        mCurrentContext,
                                        global,
                                        aCallback);
 }
 
-already_AddRefed<nsIDOMFile>
-HTMLCanvasElement::MozGetAsFile(const nsAString& aName,
-                                const nsAString& aType,
-                                ErrorResult& aRv)
-{
-  nsCOMPtr<nsIDOMFile> file;
-  aRv = MozGetAsFile(aName, aType, getter_AddRefs(file));
-  return file.forget();
-}
-
 NS_IMETHODIMP
 HTMLCanvasElement::MozGetAsFile(const nsAString& aName,
                                 const nsAString& aType,
                                 nsIDOMFile** aResult)
 {
   OwnerDoc()->WarnOnceAbout(nsIDocument::eMozGetAsFile);
 
   // do a trust check if this is a write-only canvas
   if ((mWriteOnly) &&
       !nsContentUtils::IsCallerChrome()) {
     return NS_ERROR_DOM_SECURITY_ERR;
   }
 
-  return MozGetAsFileImpl(aName, aType, aResult);
+  ErrorResult rv;
+  nsRefPtr<DOMFile> file = MozGetAsFile(aName, aType, rv);
+  if (NS_WARN_IF(rv.Failed())) {
+    return rv.ErrorCode();
+  }
+
+  file.forget(aResult);
+  return NS_OK;
 }
 
-nsresult
-HTMLCanvasElement::MozGetAsFileImpl(const nsAString& aName,
-                                    const nsAString& aType,
-                                    nsIDOMFile** aResult)
+already_AddRefed<DOMFile>
+HTMLCanvasElement::MozGetAsFile(const nsAString& aName,
+                                const nsAString& aType,
+                                ErrorResult& aRv)
 {
   nsCOMPtr<nsIInputStream> stream;
   nsAutoString type(aType);
-  nsresult rv = ExtractData(type, EmptyString(), getter_AddRefs(stream));
-  NS_ENSURE_SUCCESS(rv, rv);
+  aRv = ExtractData(type, EmptyString(), getter_AddRefs(stream));
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
 
   uint64_t imgSize;
-  rv = stream->Available(&imgSize);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(imgSize <= UINT32_MAX, NS_ERROR_FILE_TOO_BIG);
+  aRv = stream->Available(&imgSize);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
+
+  if (NS_WARN_IF(imgSize > UINT32_MAX)) {
+    aRv.Throw(NS_ERROR_FILE_TOO_BIG);
+    return nullptr;
+  }
 
   void* imgData = nullptr;
-  rv = NS_ReadInputStreamToBuffer(stream, &imgData, (uint32_t)imgSize);
-  NS_ENSURE_SUCCESS(rv, rv);
+  aRv = NS_ReadInputStreamToBuffer(stream, &imgData, (uint32_t)imgSize);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
 
   JSContext* cx = nsContentUtils::GetCurrentJSContext();
   if (cx) {
     JS_updateMallocCounter(cx, imgSize);
   }
 
   // The DOMFile takes ownership of the buffer
-  nsRefPtr<DOMFile> file =
-    DOMFile::CreateMemoryFile(imgData, (uint32_t)imgSize, aName, type,
-                              PR_Now());
-
-  file.forget(aResult);
-  return NS_OK;
+  return DOMFile::CreateMemoryFile(imgData, (uint32_t)imgSize, aName, type,
+                                   PR_Now());
 }
 
 nsresult
 HTMLCanvasElement::GetContextHelper(const nsAString& aContextId,
                                     nsICanvasRenderingContextInternal **aContext)
 {
   NS_ENSURE_ARG(aContext);
 
diff --git a/content/html/content/src/HTMLInputElement.cpp b/content/html/content/src/HTMLInputElement.cpp
--- a/content/html/content/src/HTMLInputElement.cpp
+++ b/content/html/content/src/HTMLInputElement.cpp
@@ -231,36 +231,36 @@ class HTMLInputElementState MOZ_FINAL : 
     const nsString& GetValue() {
       return mValue;
     }
 
     void SetValue(const nsAString& aValue) {
       mValue = aValue;
     }
 
-    const nsTArray<nsCOMPtr<nsIDOMFile> >& GetFiles() {
+    const nsTArray<nsRefPtr<DOMFile>>& GetFiles() {
       return mFiles;
     }
 
-    void SetFiles(const nsTArray<nsCOMPtr<nsIDOMFile> >& aFiles) {
+    void SetFiles(const nsTArray<nsRefPtr<DOMFile>>& aFiles) {
       mFiles.Clear();
       mFiles.AppendElements(aFiles);
     }
 
     HTMLInputElementState()
       : mValue()
       , mChecked(false)
       , mCheckedSet(false)
     {};
 
   protected:
     ~HTMLInputElementState() {}
 
     nsString mValue;
-    nsTArray<nsCOMPtr<nsIDOMFile> > mFiles;
+    nsTArray<nsRefPtr<DOMFile>> mFiles;
     bool mChecked;
     bool mCheckedSet;
 };
 
 NS_DEFINE_STATIC_IID_ACCESSOR(HTMLInputElementState, NS_INPUT_ELEMENT_STATE_IID)
 
 NS_IMPL_ISUPPORTS(HTMLInputElementState, HTMLInputElementState)
 
@@ -516,17 +516,17 @@ public:
       nsCOMPtr<nsISimpleEnumerator> iter =
         new DirPickerRecursiveFileEnumerator(mTopDir);
       bool hasMore = true;
       nsCOMPtr<nsISupports> tmp;
       while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
         iter->GetNext(getter_AddRefs(tmp));
         nsCOMPtr<nsIDOMFile> domFile = do_QueryInterface(tmp);
         MOZ_ASSERT(domFile);
-        mFileList.AppendElement(domFile);
+        mFileList.AppendElement(static_cast<DOMFile*>(domFile.get()));
         mFileListLength = mFileList.Length();
         if (mCanceled) {
           MOZ_ASSERT(!mInput, "This is bad - how did this happen?");
           // There's no point dispatching to the main thread (that doesn't
           // guarantee that we'll be destroyed there).
           return NS_OK;
         }
       }
@@ -589,17 +589,17 @@ public:
    * we don't increase the size of HTMLInputElement for something that's rarely
    * used.
    */
   uint32_t mPreviousFileListLength;
 
 private:
   nsRefPtr<HTMLInputElement> mInput;
   nsCOMPtr<nsIFile> mTopDir;
-  nsTArray<nsCOMPtr<nsIDOMFile> > mFileList;
+  nsTArray<nsRefPtr<DOMFile>> mFileList;
 
   // We access the list length on both threads, so we need the indirection of
   // this atomic member to make the access thread safe:
   mozilla::Atomic<uint32_t> mFileListLength;
 
   mozilla::Atomic<bool> mCanceled;
 };
 
@@ -650,42 +650,42 @@ HTMLInputElement::nsFilePickerShownCallb
     // dispatching the "change" event.
     mInput->mDirPickerFileListBuilderTask =
       new DirPickerFileListBuilderTask(mInput.get(), pickedDir.get());
     return target->Dispatch(mInput->mDirPickerFileListBuilderTask,
                             NS_DISPATCH_NORMAL);
   }
 
   // Collect new selected filenames
-  nsTArray<nsCOMPtr<nsIDOMFile> > newFiles;
+  nsTArray<nsRefPtr<DOMFile>> newFiles;
   if (mode == static_cast<int16_t>(nsIFilePicker::modeOpenMultiple)) {
     nsCOMPtr<nsISimpleEnumerator> iter;
     nsresult rv = mFilePicker->GetDomfiles(getter_AddRefs(iter));
     NS_ENSURE_SUCCESS(rv, rv);
 
     if (!iter) {
       return NS_OK;
     }
 
     nsCOMPtr<nsISupports> tmp;
     bool hasMore = true;
 
     while (NS_SUCCEEDED(iter->HasMoreElements(&hasMore)) && hasMore) {
       iter->GetNext(getter_AddRefs(tmp));
       nsCOMPtr<nsIDOMFile> domFile = do_QueryInterface(tmp);
       MOZ_ASSERT(domFile);
-      newFiles.AppendElement(domFile);
+      newFiles.AppendElement(static_cast<DOMFile*>(domFile.get()));
     }
   } else {
     MOZ_ASSERT(mode == static_cast<int16_t>(nsIFilePicker::modeOpen));
     nsCOMPtr<nsIDOMFile> domFile;
     nsresult rv = mFilePicker->GetDomfile(getter_AddRefs(domFile));
     NS_ENSURE_SUCCESS(rv, rv);
     if (domFile) {
-      newFiles.AppendElement(domFile);
+      newFiles.AppendElement(static_cast<DOMFile*>(domFile.get()));
     }
   }
 
   if (newFiles.IsEmpty()) {
     return NS_OK;
   }
 
   // Store the last used directory using the content pref service:
@@ -931,17 +931,17 @@ HTMLInputElement::InitFilePicker(FilePic
     SetFilePickerFiltersFromAccept(filePicker);
   } else {
     filePicker->AppendFilters(nsIFilePicker::filterAll);
   }
 
   // Set default directry and filename
   nsAutoString defaultName;
 
-  const nsTArray<nsCOMPtr<nsIDOMFile> >& oldFiles = GetFilesInternal();
+  const nsTArray<nsRefPtr<DOMFile>>& oldFiles = GetFilesInternal();
 
   nsCOMPtr<nsIFilePickerShownCallback> callback =
     new HTMLInputElement::nsFilePickerShownCallback(this, filePicker);
 
   if (!oldFiles.IsEmpty() &&
       aType != FILE_PICKER_DIRECTORY) {
     nsString path;
 
@@ -1702,17 +1702,17 @@ HTMLInputElement::IsValueEmpty() const
   GetValueInternal(value);
 
   return value.IsEmpty();
 }
 
 void
 HTMLInputElement::ClearFiles(bool aSetValueChanged)
 {
-  nsTArray<nsCOMPtr<nsIDOMFile> > files;
+  nsTArray<nsRefPtr<DOMFile>> files;
   SetFiles(files, aSetValueChanged);
 }
 
 /* static */ Decimal
 HTMLInputElement::StringToDecimal(const nsAString& aValue)
 {
   if (!IsASCII(aValue)) {
     return Decimal::nan();
@@ -2295,17 +2295,17 @@ HTMLInputElement::MozGetFileNameArray(ui
   *aFileNames = ret;
 
   return NS_OK;
 }
 
 void
 HTMLInputElement::MozSetFileNameArray(const Sequence< nsString >& aFileNames)
 {
-  nsTArray<nsCOMPtr<nsIDOMFile> > files;
+  nsTArray<nsRefPtr<DOMFile>> files;
   for (uint32_t i = 0; i < aFileNames.Length(); ++i) {
     nsCOMPtr<nsIFile> file;
 
     if (StringBeginsWith(aFileNames[i], NS_LITERAL_STRING("file:"),
                          nsASCIICaseInsensitiveStringComparator())) {
       // Converts the URL string into the corresponding nsIFile if possible
       // A local file will be created if the URL string begins with file://
       NS_GetFileFromURLSpec(NS_ConvertUTF16toUTF8(aFileNames[i]),
@@ -2313,17 +2313,17 @@ HTMLInputElement::MozSetFileNameArray(co
     }
 
     if (!file) {
       // this is no "file://", try as local file
       NS_NewLocalFile(aFileNames[i], false, getter_AddRefs(file));
     }
 
     if (file) {
-      nsCOMPtr<nsIDOMFile> domFile = DOMFile::CreateFromFile(file);
+      nsRefPtr<DOMFile> domFile = DOMFile::CreateFromFile(file);
       files.AppendElement(domFile);
     } else {
       continue; // Not much we can do if the file doesn't exist
     }
 
   }
 
   SetFiles(files, true);
@@ -2549,37 +2549,37 @@ HTMLInputElement::GetDisplayFileName(nsA
     nsContentUtils::FormatLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
                                           "XFilesSelected", params, value);
   }
 
   aValue = value;
 }
 
 void
-HTMLInputElement::SetFiles(const nsTArray<nsCOMPtr<nsIDOMFile> >& aFiles,
+HTMLInputElement::SetFiles(const nsTArray<nsRefPtr<DOMFile>>& aFiles,
                            bool aSetValueChanged)
 {
   mFiles.Clear();
   mFiles.AppendElements(aFiles);
 
   AfterSetFiles(aSetValueChanged);
 }
 
 void
 HTMLInputElement::SetFiles(nsIDOMFileList* aFiles,
                            bool aSetValueChanged)
 {
+  nsRefPtr<nsDOMFileList> files = static_cast<nsDOMFileList*>(aFiles);
   mFiles.Clear();
 
   if (aFiles) {
     uint32_t listLength;
     aFiles->GetLength(&listLength);
     for (uint32_t i = 0; i < listLength; i++) {
-      nsCOMPtr<nsIDOMFile> file;
-      aFiles->Item(i, getter_AddRefs(file));
+      nsRefPtr<DOMFile> file = files->Item(i);
       mFiles.AppendElement(file);
     }
   }
 
   AfterSetFiles(aSetValueChanged);
 }
 
 void
@@ -2769,17 +2769,17 @@ HTMLInputElement::DispatchProgressEvent(
 }
 
 nsresult
 HTMLInputElement::UpdateFileList()
 {
   if (mFileList) {
     mFileList->Clear();
 
-    const nsTArray<nsCOMPtr<nsIDOMFile> >& files = GetFilesInternal();
+    const nsTArray<nsRefPtr<DOMFile>>& files = GetFilesInternal();
     for (uint32_t i = 0; i < files.Length(); ++i) {
       if (!mFileList->Append(files[i])) {
         return NS_ERROR_FAILURE;
       }
     }
   }
 
   return NS_OK;
@@ -5617,17 +5617,17 @@ HTMLInputElement::SubmitNamesValues(nsFo
   }
 
   //
   // Submit file if its input type=file and this encoding method accepts files
   //
   if (mType == NS_FORM_INPUT_FILE) {
     // Submit files
 
-    const nsTArray<nsCOMPtr<nsIDOMFile> >& files = GetFilesInternal();
+    const nsTArray<nsRefPtr<DOMFile>>& files = GetFilesInternal();
 
     for (uint32_t i = 0; i < files.Length(); ++i) {
       aFormSubmission->AddNameFilePair(name, files[i], NullString());
     }
 
     if (files.IsEmpty()) {
       // If no file was selected, pretend we had an empty file with an
       // empty filename.
@@ -5865,17 +5865,17 @@ HTMLInputElement::RestoreState(nsPresSta
       case VALUE_MODE_DEFAULT_ON:
         if (inputState->IsCheckedSet()) {
           restoredCheckedState = true;
           DoSetChecked(inputState->GetChecked(), true, true);
         }
         break;
       case VALUE_MODE_FILENAME:
         {
-          const nsTArray<nsCOMPtr<nsIDOMFile> >& files = inputState->GetFiles();
+          const nsTArray<nsRefPtr<DOMFile>>& files = inputState->GetFiles();
           SetFiles(files, true);
         }
         break;
       case VALUE_MODE_VALUE:
       case VALUE_MODE_DEFAULT:
         if (GetValueMode() == VALUE_MODE_DEFAULT &&
             mType != NS_FORM_INPUT_HIDDEN) {
           break;
@@ -6338,17 +6338,17 @@ HTMLInputElement::IsValueMissing() const
     return false;
   }
 
   switch (GetValueMode()) {
     case VALUE_MODE_VALUE:
       return IsValueEmpty();
     case VALUE_MODE_FILENAME:
     {
-      const nsTArray<nsCOMPtr<nsIDOMFile> >& files = GetFilesInternal();
+      const nsTArray<nsRefPtr<DOMFile>>& files = GetFilesInternal();
       return files.IsEmpty();
     }
     case VALUE_MODE_DEFAULT_ON:
       // This should not be used for type radio.
       // See the MOZ_ASSERT at the beginning of the method.
       return !mChecked;
     case VALUE_MODE_DEFAULT:
     default:
diff --git a/content/html/content/src/HTMLInputElement.h b/content/html/content/src/HTMLInputElement.h
--- a/content/html/content/src/HTMLInputElement.h
+++ b/content/html/content/src/HTMLInputElement.h
@@ -19,30 +19,31 @@
 #include "mozilla/dom/HTMLFormElement.h" // for HasEverTriedInvalidSubmit()
 #include "mozilla/dom/HTMLInputElementBinding.h"
 #include "nsIFilePicker.h"
 #include "nsIContentPrefService2.h"
 #include "mozilla/Decimal.h"
 #include "nsContentUtils.h"
 #include "nsTextEditorState.h"
 
-class nsDOMFileList;
 class nsIRadioGroupContainer;
 class nsIRadioGroupVisitor;
 class nsIRadioVisitor;
 
 namespace mozilla {
 
 class EventChainPostVisitor;
 class EventChainPreVisitor;
 
 namespace dom {
 
 class Date;
 class DirPickerFileListBuilderTask;
+class DOMFile;
+class nsDOMFileList;
 
 class UploadLastDir MOZ_FINAL : public nsIObserver, public nsSupportsWeakReference {
 
   ~UploadLastDir() {}
 
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIOBSERVER
@@ -205,22 +206,22 @@ public:
   NS_IMETHOD_(void) UpdatePlaceholderVisibility(bool aNotify) MOZ_OVERRIDE;
   NS_IMETHOD_(bool) GetPlaceholderVisibility() MOZ_OVERRIDE;
   NS_IMETHOD_(void) InitializeKeyboardEventListeners() MOZ_OVERRIDE;
   NS_IMETHOD_(void) OnValueChanged(bool aNotify) MOZ_OVERRIDE;
   NS_IMETHOD_(bool) HasCachedSelection() MOZ_OVERRIDE;
 
   void GetDisplayFileName(nsAString& aFileName) const;
 
-  const nsTArray<nsCOMPtr<nsIDOMFile> >& GetFilesInternal() const
+  const nsTArray<nsRefPtr<DOMFile>>& GetFilesInternal() const
   {
     return mFiles;
   }
 
-  void SetFiles(const nsTArray<nsCOMPtr<nsIDOMFile> >& aFiles, bool aSetValueChanged);
+  void SetFiles(const nsTArray<nsRefPtr<DOMFile>>& aFiles, bool aSetValueChanged);
   void SetFiles(nsIDOMFileList* aFiles, bool aSetValueChanged);
 
   // Called when a nsIFilePicker or a nsIColorPicker terminate.
   void PickerClosed();
 
   void SetCheckedChangedInternal(bool aCheckedChanged);
   bool GetCheckedChanged() const {
     return mCheckedChanged;
@@ -1241,17 +1242,17 @@ protected:
    * used when uploading a file. It is vital that this is kept separate from
    * mValue so that it won't be possible to 'leak' the value from a text-input
    * to a file-input. Additionally, the logic for this value is kept as simple
    * as possible to avoid accidental errors where the wrong filename is used.
    * Therefor the list of filenames is always owned by this member, never by
    * the frame. Whenever the frame wants to change the filename it has to call
    * SetFileNames to update this member.
    */
-  nsTArray<nsCOMPtr<nsIDOMFile> >   mFiles;
+  nsTArray<nsRefPtr<DOMFile>> mFiles;
 
   nsRefPtr<nsDOMFileList>  mFileList;
 
   nsRefPtr<DirPickerFileListBuilderTask> mDirPickerFileListBuilderTask;
 
   nsString mStaticDocFileList;
   
   /** 
diff --git a/content/html/content/test/test_formData.html b/content/html/content/test/test_formData.html
--- a/content/html/content/test/test_formData.html
+++ b/content/html/content/test/test_formData.html
@@ -47,22 +47,22 @@ function runTest() {
     }
 
     var file, blob = new Blob(['hey'], {type: 'text/plain'});
 
     var fd = new FormData();
     fd.append("empty", blob);
     fd.append("explicit", blob, "explicit-file-name");
     fd.append("explicit-empty", blob, "");
-    file = SpecialPowers.unwrap(SpecialPowers.wrap(window).File(blob, {name: 'testname'}));
+    file = new File([blob], 'testname',  {type: 'text/plain'});
     fd.append("file-name", file);
-    file = SpecialPowers.unwrap(SpecialPowers.wrap(window).File(blob, {name: ''}));
+    file = new File([blob], '',  {type: 'text/plain'});
     fd.append("empty-file-name", file);
-    file = SpecialPowers.unwrap(SpecialPowers.wrap(window).File(blob, {name: 'testname'}));
+    file = new File([blob], 'testname',  {type: 'text/plain'});
     fd.append("file-name-overwrite", file, "overwrite");
     xhr.responseType = 'json';
     xhr.send(fd);
 }
 
 runTest()
 </script>
 </body>
-</html>
\ No newline at end of file
+</html>
diff --git a/content/media/MediaRecorder.cpp b/content/media/MediaRecorder.cpp
--- a/content/media/MediaRecorder.cpp
+++ b/content/media/MediaRecorder.cpp
@@ -772,17 +772,20 @@ MediaRecorder::CreateAndDispatchBlobEven
   if (!CheckPrincipal()) {
     // Media is not same-origin, don't allow the data out.
     nsRefPtr<nsIDOMBlob> blob = aBlob;
     return NS_ERROR_DOM_SECURITY_ERR;
   }
   BlobEventInit init;
   init.mBubbles = false;
   init.mCancelable = false;
-  init.mData = aBlob;
+
+  nsCOMPtr<nsIDOMBlob> blob = aBlob;
+  init.mData = static_cast<DOMFile*>(blob.get());
+
   nsRefPtr<BlobEvent> event =
     BlobEvent::Constructor(this,
                            NS_LITERAL_STRING("dataavailable"),
                            init);
   event->SetTrusted(true);
   return DispatchDOMEvent(nullptr, event, nullptr, nullptr);
 }
 
diff --git a/dom/archivereader/ArchiveReader.cpp b/dom/archivereader/ArchiveReader.cpp
--- a/dom/archivereader/ArchiveReader.cpp
+++ b/dom/archivereader/ArchiveReader.cpp
@@ -4,36 +4,35 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ArchiveReader.h"
 #include "ArchiveRequest.h"
 #include "ArchiveEvent.h"
 #include "ArchiveZipEvent.h"
 
+#include "nsDOMFile.h"
 #include "nsIURI.h"
 #include "nsNetUtil.h"
 
 #include "mozilla/dom/ArchiveReaderBinding.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/dom/EncodingUtils.h"
 
 using namespace mozilla;
 using namespace mozilla::dom;
 USING_ARCHIVEREADER_NAMESPACE
 
 /* static */ already_AddRefed<ArchiveReader>
 ArchiveReader::Constructor(const GlobalObject& aGlobal,
-                           nsIDOMBlob* aBlob,
+                           DOMFile& aBlob,
                            const ArchiveReaderOptions& aOptions,
                            ErrorResult& aError)
 {
-  MOZ_ASSERT(aBlob);
-
   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aGlobal.GetAsSupports());
   if (!window) {
     aError.Throw(NS_ERROR_UNEXPECTED);
     return nullptr;
   }
 
   nsAutoCString encoding;
   if (!EncodingUtils::FindEncodingForLabelNoReplacement(aOptions.mEncoding,
@@ -42,24 +41,23 @@ ArchiveReader::Constructor(const GlobalO
     return nullptr;
   }
 
   nsRefPtr<ArchiveReader> reader =
     new ArchiveReader(aBlob, window, encoding);
   return reader.forget();
 }
 
-ArchiveReader::ArchiveReader(nsIDOMBlob* aBlob, nsPIDOMWindow* aWindow,
+ArchiveReader::ArchiveReader(DOMFile& aBlob, nsPIDOMWindow* aWindow,
                              const nsACString& aEncoding)
-  : mBlob(aBlob)
+  : mBlob(&aBlob)
   , mWindow(aWindow)
   , mStatus(NOT_STARTED)
   , mEncoding(aEncoding)
 {
-  MOZ_ASSERT(aBlob);
   MOZ_ASSERT(aWindow);
 
   SetIsDOMBinding();
 }
 
 ArchiveReader::~ArchiveReader()
 {
 }
diff --git a/dom/archivereader/ArchiveReader.h b/dom/archivereader/ArchiveReader.h
--- a/dom/archivereader/ArchiveReader.h
+++ b/dom/archivereader/ArchiveReader.h
@@ -14,16 +14,17 @@
 #include "nsCOMArray.h"
 #include "nsIChannel.h"
 #include "nsIDOMFile.h"
 #include "mozilla/Attributes.h"
 
 namespace mozilla {
 namespace dom {
 struct ArchiveReaderOptions;
+class DOMFile;
 class GlobalObject;
 } // namespace dom
 } // namespace mozilla
 
 BEGIN_ARCHIVEREADER_NAMESPACE
 
 class ArchiveRequest;
 
@@ -33,20 +34,20 @@ class ArchiveRequest;
 class ArchiveReader MOZ_FINAL : public nsISupports,
                                 public nsWrapperCache
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(ArchiveReader)
 
   static already_AddRefed<ArchiveReader>
-  Constructor(const GlobalObject& aGlobal, nsIDOMBlob* aBlob,
+  Constructor(const GlobalObject& aGlobal, DOMFile& aBlob,
               const ArchiveReaderOptions& aOptions, ErrorResult& aError);
 
-  ArchiveReader(nsIDOMBlob* aBlob, nsPIDOMWindow* aWindow,
+  ArchiveReader(DOMFile& aBlob, nsPIDOMWindow* aWindow,
                 const nsACString& aEncoding);
 
   nsIDOMWindow* GetParentObject() const
   {
     return mWindow;
   }
   virtual JSObject* WrapObject(JSContext* aCx) MOZ_OVERRIDE;
 
diff --git a/dom/archivereader/ArchiveZipEvent.cpp b/dom/archivereader/ArchiveZipEvent.cpp
--- a/dom/archivereader/ArchiveZipEvent.cpp
+++ b/dom/archivereader/ArchiveZipEvent.cpp
@@ -79,16 +79,19 @@ nsIDOMFile*
 ArchiveZipItem::File(ArchiveReader* aArchiveReader)
 {
   nsString filename;
 
   if (NS_FAILED(GetFilename(filename))) {
     return nullptr;
   }
 
+  nsCOMPtr<nsPIDOMWindow> window =
+    do_QueryInterface(aArchiveReader->GetParentObject());
+
   return new DOMFile(
     new ArchiveZipFileImpl(filename,
                            NS_ConvertUTF8toUTF16(GetType()),
                            StrToInt32(mCentralStruct.orglen),
                            mCentralStruct, aArchiveReader));
 }
 
 uint32_t
diff --git a/dom/archivereader/ArchiveZipFile.cpp b/dom/archivereader/ArchiveZipFile.cpp
--- a/dom/archivereader/ArchiveZipFile.cpp
+++ b/dom/archivereader/ArchiveZipFile.cpp
@@ -2,20 +2,22 @@
 /* vim: set ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ArchiveZipFile.h"
 #include "ArchiveZipEvent.h"
 
+#include "nsDOMFile.h"
 #include "nsIInputStream.h"
 #include "zlib.h"
 #include "mozilla/Attributes.h"
 
+using namespace mozilla::dom;
 USING_ARCHIVEREADER_NAMESPACE
 
 #define ZIP_CHUNK 16384
 
 /**
  * Input stream object for zip files
  */
 class ArchiveInputStream MOZ_FINAL : public nsIInputStream,
@@ -391,21 +393,21 @@ ArchiveZipFileImpl::Unlink()
 
 void
 ArchiveZipFileImpl::Traverse(nsCycleCollectionTraversalCallback &cb)
 {
   ArchiveZipFileImpl* tmp = this;
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mArchiveReader);
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 ArchiveZipFileImpl::CreateSlice(uint64_t aStart,
                                 uint64_t aLength,
-                                const nsAString& aContentType)
+                                const nsAString& aContentType,
+                                ErrorResult& aRv)
 {
-  nsCOMPtr<nsIDOMBlob> t =
-    new DOMFile(new ArchiveZipFileImpl(mFilename, mContentType,
-                                       aStart, mLength, mCentral,
-                                       mArchiveReader));
-  return t.forget();
+  nsRefPtr<DOMFileImpl> impl =
+    new ArchiveZipFileImpl(mFilename, mContentType, aStart, mLength, mCentral,
+                           mArchiveReader);
+  return impl.forget();
 }
 
 NS_IMPL_ISUPPORTS_INHERITED0(ArchiveZipFileImpl, DOMFileImpl)
diff --git a/dom/archivereader/ArchiveZipFile.h b/dom/archivereader/ArchiveZipFile.h
--- a/dom/archivereader/ArchiveZipFile.h
+++ b/dom/archivereader/ArchiveZipFile.h
@@ -66,19 +66,19 @@ public:
   }
 
 protected:
   virtual ~ArchiveZipFileImpl()
   {
     MOZ_COUNT_DTOR(ArchiveZipFileImpl);
   }
 
-  virtual already_AddRefed<nsIDOMBlob> CreateSlice(uint64_t aStart,
-                                                   uint64_t aLength,
-                                                   const nsAString& aContentType) MOZ_OVERRIDE;
+  virtual already_AddRefed<DOMFileImpl>
+  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType,
+              ErrorResult& aRv) MOZ_OVERRIDE;
 
 private: // Data
   ZipCentral mCentral;
   nsRefPtr<ArchiveReader> mArchiveReader;
 
   nsString mFilename;
 };
 
diff --git a/dom/base/MessagePort.cpp b/dom/base/MessagePort.cpp
--- a/dom/base/MessagePort.cpp
+++ b/dom/base/MessagePort.cpp
@@ -6,22 +6,22 @@
 #include "MessagePort.h"
 #include "MessageEvent.h"
 #include "mozilla/dom/Event.h"
 #include "mozilla/dom/MessageChannel.h"
 #include "mozilla/dom/MessagePortBinding.h"
 #include "mozilla/dom/MessagePortList.h"
 #include "mozilla/dom/StructuredCloneTags.h"
 #include "nsContentUtils.h"
+#include "nsDOMFile.h"
 #include "nsGlobalWindow.h"
 #include "nsPresContext.h"
 #include "ScriptSettings.h"
 
 #include "nsIDocument.h"
-#include "nsIDOMFile.h"
 #include "nsIDOMFileList.h"
 #include "nsIPresShell.h"
 
 namespace mozilla {
 namespace dom {
 
 class DispatchEventRunnable : public nsRunnable
 {
@@ -98,17 +98,30 @@ struct StructuredCloneInfo
 
 static JSObject*
 PostMessageReadStructuredClone(JSContext* cx,
                                JSStructuredCloneReader* reader,
                                uint32_t tag,
                                uint32_t data,
                                void* closure)
 {
-  if (tag == SCTAG_DOM_BLOB || tag == SCTAG_DOM_FILELIST) {
+  if (tag == SCTAG_DOM_BLOB) {
+    NS_ASSERTION(!data, "Data should be empty");
+
+    // What we get back from the reader is a DOMFileImpl.
+    // From that we create a new DOMFile.
+    DOMFileImpl* blobImpl;
+    if (JS_ReadBytes(reader, &blobImpl, sizeof(blobImpl))) {
+      MOZ_ASSERT(blobImpl);
+      nsRefPtr<DOMFile> blob = new DOMFile(blobImpl);
+      return blob->WrapObject(cx);
+    }
+  }
+
+  if (tag == SCTAG_DOM_FILELIST) {
     NS_ASSERTION(!data, "Data should be empty");
 
     nsISupports* supports;
     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
       JS::Rooted<JS::Value> val(cx);
       if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, supports, &val))) {
         return val.toObjectOrNull();
       }
@@ -129,28 +142,36 @@ static bool
 PostMessageWriteStructuredClone(JSContext* cx,
                                 JSStructuredCloneWriter* writer,
                                 JS::Handle<JSObject*> obj,
                                 void *closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
   NS_ASSERTION(scInfo, "Must have scInfo!");
 
+  // See if this is a File/Blob object.
+  {
+    DOMFile* blob = nullptr;
+    if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, obj, blob))) {
+      DOMFileImpl* blobImpl = blob->Impl();
+      if (JS_WriteUint32Pair(writer, SCTAG_DOM_BLOB, 0) &&
+          JS_WriteBytes(writer, &blobImpl, sizeof(blobImpl))) {
+        scInfo->mEvent->StoreISupports(blobImpl);
+        return true;
+      }
+    }
+  }
+
   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
   nsContentUtils::XPConnect()->
     GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrappedNative));
   if (wrappedNative) {
     uint32_t scTag = 0;
     nsISupports* supports = wrappedNative->Native();
 
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
-    if (blob) {
-      scTag = SCTAG_DOM_BLOB;
-    }
-
     nsCOMPtr<nsIDOMFileList> list = do_QueryInterface(supports);
     if (list) {
       scTag = SCTAG_DOM_FILELIST;
     }
 
     if (scTag) {
       return JS_WriteUint32Pair(writer, scTag, 0) &&
              JS_WriteBytes(writer, &supports, sizeof(supports)) &&
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -8,16 +8,17 @@
 #include "base/basictypes.h"
 
 #include "Navigator.h"
 #include "nsIXULAppInfo.h"
 #include "nsPluginArray.h"
 #include "nsMimeTypeArray.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/dom/DesktopNotification.h"
+#include "nsDOMFile.h"
 #include "nsGeolocation.h"
 #include "nsIHttpProtocolHandler.h"
 #include "nsIContentPolicy.h"
 #include "nsIContentSecurityPolicy.h"
 #include "nsContentPolicyUtils.h"
 #include "nsCrossSiteListenerProxy.h"
 #include "nsISupportsPriority.h"
 #include "nsICachingChannel.h"
@@ -1262,24 +1263,24 @@ Navigator::SendBeacon(const nsAString& a
       if (NS_FAILED(rv)) {
         aRv.Throw(NS_ERROR_FAILURE);
         return false;
       }
       mimeType.AssignLiteral("application/octet-stream");
       in = strStream;
 
     } else if (aData.Value().IsBlob()) {
-      nsCOMPtr<nsIDOMBlob> blob = aData.Value().GetAsBlob();
-      rv = blob->GetInternalStream(getter_AddRefs(in));
+      DOMFile& blob = aData.Value().GetAsBlob();
+      rv = blob.GetInternalStream(getter_AddRefs(in));
       if (NS_FAILED(rv)) {
         aRv.Throw(NS_ERROR_FAILURE);
         return false;
       }
       nsAutoString type;
-      rv = blob->GetType(type);
+      rv = blob.GetType(type);
       if (NS_FAILED(rv)) {
         aRv.Throw(NS_ERROR_FAILURE);
         return false;
       }
       mimeType = NS_ConvertUTF16toUTF8(type);
 
     } else if (aData.Value().IsFormData()) {
       nsFormData& form = aData.Value().GetAsFormData();
diff --git a/dom/base/Navigator.h b/dom/base/Navigator.h
--- a/dom/base/Navigator.h
+++ b/dom/base/Navigator.h
@@ -20,17 +20,16 @@
 #include "nsTArray.h"
 
 class nsPluginArray;
 class nsMimeTypeArray;
 class nsPIDOMWindow;
 class nsIDOMNavigatorSystemMessages;
 class nsDOMCameraManager;
 class nsDOMDeviceStorage;
-class nsIDOMBlob;
 class nsIPrincipal;
 
 namespace mozilla {
 namespace dom {
 class Geolocation;
 class systemMessageCallback;
 struct MediaStreamConstraints;
 class WakeLock;
diff --git a/dom/base/URL.cpp b/dom/base/URL.cpp
--- a/dom/base/URL.cpp
+++ b/dom/base/URL.cpp
@@ -106,25 +106,22 @@ URL::Constructor(const GlobalObject& aGl
   }
 
   nsRefPtr<URL> url = new URL(uri);
   return url.forget();
 }
 
 void
 URL::CreateObjectURL(const GlobalObject& aGlobal,
-                     nsIDOMBlob* aBlob,
+                     DOMFile& aBlob,
                      const objectURLOptions& aOptions,
                      nsString& aResult,
                      ErrorResult& aError)
 {
-  DOMFile* blob = static_cast<DOMFile*>(aBlob);
-  MOZ_ASSERT(blob);
-
-  CreateObjectURLInternal(aGlobal, blob->Impl(),
+  CreateObjectURLInternal(aGlobal, aBlob.Impl(),
                           NS_LITERAL_CSTRING(BLOBURI_SCHEME), aOptions, aResult,
                           aError);
 }
 
 void
 URL::CreateObjectURL(const GlobalObject& aGlobal, DOMMediaStream& aStream,
                      const mozilla::dom::objectURLOptions& aOptions,
                      nsString& aResult,
diff --git a/dom/base/URL.h b/dom/base/URL.h
--- a/dom/base/URL.h
+++ b/dom/base/URL.h
@@ -6,27 +6,27 @@
 #define URL_h___
 
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/URLSearchParams.h"
 #include "nsCycleCollectionParticipant.h"
 #include "nsAutoPtr.h"
 #include "nsString.h"
 
-class nsIDOMBlob;
 class nsISupports;
 class nsIURI;
 
 namespace mozilla {
 
 class ErrorResult;
 class DOMMediaStream;
 
 namespace dom {
 
+class DOMFile;
 class MediaSource;
 class GlobalObject;
 struct objectURLOptions;
 
 namespace workers {
 class URLProxy;
 }
 
@@ -47,17 +47,17 @@ public:
   static already_AddRefed<URL>
   Constructor(const GlobalObject& aGlobal, const nsAString& aUrl,
               URL& aBase, ErrorResult& aRv);
   static already_AddRefed<URL>
   Constructor(const GlobalObject& aGlobal, const nsAString& aUrl,
               const nsAString& aBase, ErrorResult& aRv);
 
   static void CreateObjectURL(const GlobalObject& aGlobal,
-                              nsIDOMBlob* aBlob,
+                              DOMFile& aBlob,
                               const objectURLOptions& aOptions,
                               nsString& aResult,
                               ErrorResult& aError);
   static void CreateObjectURL(const GlobalObject& aGlobal,
                               DOMMediaStream& aStream,
                               const objectURLOptions& aOptions,
                               nsString& aResult,
                               ErrorResult& aError);
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -33,17 +33,16 @@
 #include "nsICategoryManager.h"
 #include "nsIComponentRegistrar.h"
 #include "nsXPCOM.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIXPConnect.h"
 #include "xptcall.h"
 #include "nsTArray.h"
 #include "nsDocument.h" // nsDOMStyleSheetList
-#include "nsDOMBlobBuilder.h"
 
 // General helper includes
 #include "nsGlobalWindow.h"
 #include "nsIContent.h"
 #include "nsIDocument.h"
 #include "nsIDOMDocument.h"
 #include "nsIDOMEvent.h"
 #include "nsIDOMEventListener.h"
@@ -107,20 +106,16 @@
 #include "nsITreeSelection.h"
 #include "nsITreeContentView.h"
 #include "nsITreeView.h"
 #include "nsIXULTemplateBuilder.h"
 #include "nsITreeColumns.h"
 #endif
 #include "nsIDOMXPathNSResolver.h"
 
-// Drag and drop
-#include "nsIDOMFile.h"
-#include "nsDOMBlobBuilder.h" // nsDOMMultipartFile
-
 #include "nsIEventListenerService.h"
 #include "nsIMessageManager.h"
 
 #include "mozilla/dom/TouchEvent.h"
 
 #include "nsWrapperCacheInlines.h"
 #include "mozilla/dom/HTMLCollectionBinding.h"
 
@@ -330,21 +325,16 @@ static nsDOMClassInfoData sClassInfoData
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(XSLTProcessor, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(XPathNSResolver, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
-  NS_DEFINE_CLASSINFO_DATA(Blob, nsDOMGenericSH,
-                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
-  NS_DEFINE_CLASSINFO_DATA(File, nsDOMGenericSH,
-                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
-
   NS_DEFINE_CLASSINFO_DATA(ModalContentWindow, nsWindowSH,
                            DEFAULT_SCRIPTABLE_FLAGS |
                            WINDOW_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(MozSmsMessage, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(MozMmsMessage, nsDOMGenericSH,
@@ -420,18 +410,16 @@ struct nsConstructorFuncMapData
   nsDOMConstructorFunc mConstructorFunc;
 };
 
 #define NS_DEFINE_CONSTRUCTOR_FUNC_DATA(_class, _func)                        \
   { eDOMClassInfo_##_class##_id, _func },
 
 static const nsConstructorFuncMapData kConstructorFuncMap[] =
 {
-  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(Blob, DOMMultipartFileImpl::NewBlob)
-  NS_DEFINE_CONSTRUCTOR_FUNC_DATA(File, DOMMultipartFileImpl::NewFile)
   NS_DEFINE_CONSTRUCTOR_FUNC_DATA(MozSmsFilter, SmsFilter::NewSmsFilter)
   NS_DEFINE_CONSTRUCTOR_FUNC_DATA(XSLTProcessor, XSLTProcessorCtor)
 };
 #undef NS_DEFINE_CONSTRUCTOR_FUNC_DATA
 
 nsIXPConnect *nsDOMClassInfo::sXPConnect = nullptr;
 nsIScriptSecurityManager *nsDOMClassInfo::sSecMan = nullptr;
 bool nsDOMClassInfo::sIsInitialized = false;
@@ -908,25 +896,16 @@ nsDOMClassInfo::Init()
     DOM_CLASSINFO_MAP_ENTRY(nsIXSLTProcessor)
     DOM_CLASSINFO_MAP_ENTRY(nsIXSLTProcessorPrivate)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(XPathNSResolver, nsIDOMXPathNSResolver)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMXPathNSResolver)
   DOM_CLASSINFO_MAP_END
 
-  DOM_CLASSINFO_MAP_BEGIN(Blob, nsIDOMBlob)
-    DOM_CLASSINFO_MAP_ENTRY(nsIDOMBlob)
-  DOM_CLASSINFO_MAP_END
-
-  DOM_CLASSINFO_MAP_BEGIN(File, nsIDOMFile)
-    DOM_CLASSINFO_MAP_ENTRY(nsIDOMBlob)
-    DOM_CLASSINFO_MAP_ENTRY(nsIDOMFile)
-  DOM_CLASSINFO_MAP_END
-
   DOM_CLASSINFO_MAP_BEGIN_NO_CLASS_IF(ModalContentWindow, nsIDOMWindow)
     DOM_CLASSINFO_WINDOW_MAP_ENTRIES
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMModalContentWindow)
 #ifdef MOZ_WEBSPEECH
     DOM_CLASSINFO_MAP_ENTRY(nsISpeechSynthesisGetter)
 #endif
   DOM_CLASSINFO_MAP_END
 
diff --git a/dom/base/nsDOMClassInfoClasses.h b/dom/base/nsDOMClassInfoClasses.h
--- a/dom/base/nsDOMClassInfoClasses.h
+++ b/dom/base/nsDOMClassInfoClasses.h
@@ -42,19 +42,16 @@ DOMCI_CLASS(CSSMozDocumentRule)
 DOMCI_CLASS(CSSSupportsRule)
 
 // XSLTProcessor
 DOMCI_CLASS(XSLTProcessor)
 
 // DOM Level 3 XPath objects
 DOMCI_CLASS(XPathNSResolver)
 
-DOMCI_CLASS(Blob)
-DOMCI_CLASS(File)
-
 // DOM modal content window class, almost identical to Window
 DOMCI_CLASS(ModalContentWindow)
 
 DOMCI_CLASS(MozSmsMessage)
 DOMCI_CLASS(MozMmsMessage)
 DOMCI_CLASS(MozSmsFilter)
 DOMCI_CLASS(MozSmsSegmentInfo)
 DOMCI_CLASS(MozMobileMessageThread)
diff --git a/dom/base/nsGlobalWindow.cpp b/dom/base/nsGlobalWindow.cpp
--- a/dom/base/nsGlobalWindow.cpp
+++ b/dom/base/nsGlobalWindow.cpp
@@ -7905,23 +7905,21 @@ PostMessageReadStructuredClone(JSContext
                                uint32_t data,
                                void* closure)
 {
   if (tag == SCTAG_DOM_BLOB) {
     NS_ASSERTION(!data, "Data should be empty");
 
     // What we get back from the reader is a DOMFileImpl.
     // From that we create a new DOMFile.
-    nsISupports* supports;
-    if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
-      nsCOMPtr<nsIDOMBlob> file = new DOMFile(static_cast<DOMFileImpl*>(supports));
-      JS::Rooted<JS::Value> val(cx);
-      if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, file, &val))) {
-        return val.toObjectOrNull();
-      }
+    DOMFileImpl* blobImpl;
+    if (JS_ReadBytes(reader, &blobImpl, sizeof(blobImpl))) {
+      MOZ_ASSERT(blobImpl);
+      nsRefPtr<DOMFile> blob = new DOMFile(blobImpl);
+      return blob->WrapObject(cx);
     }
   }
 
   if (tag == SCTAG_DOM_FILELIST) {
     NS_ASSERTION(!data, "Data should be empty");
 
     nsISupports* supports;
     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
@@ -7946,30 +7944,36 @@ static bool
 PostMessageWriteStructuredClone(JSContext* cx,
                                 JSStructuredCloneWriter* writer,
                                 JS::Handle<JSObject*> obj,
                                 void *closure)
 {
   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
   NS_ASSERTION(scInfo, "Must have scInfo!");
 
+  // See if this is a File/Blob object.
+  {
+    DOMFile* blob = nullptr;
+    if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, obj, blob)) && scInfo->subsumes) {
+      DOMFileImpl* blobImpl = blob->Impl();
+      if (JS_WriteUint32Pair(writer, SCTAG_DOM_BLOB, 0) &&
+          JS_WriteBytes(writer, &blobImpl, sizeof(blobImpl))) {
+        scInfo->event->StoreISupports(blobImpl);
+        return true;
+      }
+    }
+  }
+
   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
   nsContentUtils::XPConnect()->
     GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrappedNative));
   if (wrappedNative) {
     uint32_t scTag = 0;
     nsISupports* supports = wrappedNative->Native();
 
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
-    if (blob && scInfo->subsumes) {
-      scTag = SCTAG_DOM_BLOB;
-      DOMFile* file = static_cast<DOMFile*>(blob.get());
-      supports = file->Impl();
-    }
-
     nsCOMPtr<nsIDOMFileList> list = do_QueryInterface(supports);
     if (list && scInfo->subsumes)
       scTag = SCTAG_DOM_FILELIST;
 
     if (scTag)
       return JS_WriteUint32Pair(writer, scTag, 0) &&
              JS_WriteBytes(writer, &supports, sizeof(supports)) &&
              scInfo->event->StoreISupports(supports);
diff --git a/dom/base/test/file_url.jsm b/dom/base/test/file_url.jsm
--- a/dom/base/test/file_url.jsm
+++ b/dom/base/test/file_url.jsm
@@ -1,12 +1,12 @@
 this.EXPORTED_SYMBOLS = ['checkFromJSM'];
 
 this.checkFromJSM = function checkFromJSM(ok, is) {
-  Components.utils.importGlobalProperties(['URL']);
+  Components.utils.importGlobalProperties(['URL', 'Blob']);
 
   var url = new URL('http://www.example.com');
   is(url.href, "http://www.example.com/", "JSM should have URL");
 
   var url2 = new URL('/foobar', url);
   is(url2.href, "http://www.example.com/foobar", "JSM should have URL - based on another URL");
 
   var blob = new Blob(['a']);
diff --git a/dom/base/test/test_messageChannel_post.html b/dom/base/test/test_messageChannel_post.html
--- a/dom/base/test/test_messageChannel_post.html
+++ b/dom/base/test/test_messageChannel_post.html
@@ -45,17 +45,21 @@ https://bugzilla.mozilla.org/show_bug.cg
                   null,
                   undefined,
                   "hello world",
                   new Blob([]),
                   true ];
 
     a.port1.onmessage = function(evt) {
       ok(tests.length, "We are waiting for a message");
-      is(tests[0], evt.data, "Value ok: " + tests[0]);
+      if (typeof(tests[0]) == 'object') {
+        is(typeof(tests[0]), typeof(evt.data), "Value ok: " + tests[0]);
+      } else {
+        is(tests[0], evt.data, "Value ok: " + tests[0]);
+      }
       tests.shift();
       runTest();
     }
 
     function runTest() {
       if (!tests.length) {
         SimpleTest.finish();
         return;
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -144,23 +144,20 @@ DOMInterfaces = {
 'BarProp': {
     'headerFile': 'mozilla/dom/BarProps.h',
 },
 
 'BiquadFilterNode': {
     'resultNotAddRefed': [ 'frequency', 'detune', 'q', 'gain' ],
 },
 
-'Blob': [
-{
-    'headerFile': 'nsIDOMFile.h',
+'Blob': {
+    'nativeType': 'mozilla::dom::DOMFile',
+    'headerFile': 'nsDOMFile.h',
 },
-{
-    'workers': True,
-}],
 
 'BatteryManager': {
     'nativeType': 'mozilla::dom::battery::BatteryManager',
     'headerFile': 'BatteryManager.h'
 },
 
 'BluetoothAdapter': {
     'nativeType': 'mozilla::dom::bluetooth::BluetoothAdapter',
@@ -445,18 +442,23 @@ DOMInterfaces = {
 
 'Exception': {
     'headerFile': 'mozilla/dom/DOMException.h',
     'binaryNames': {
         'message': 'messageMoz',
     },
 },
 
+'File': {
+    'nativeType': 'mozilla::dom::DOMFile',
+    'headerFile': 'nsDOMFile.h',
+},
+
 'FileList': {
-    'nativeType': 'nsDOMFileList',
+    'nativeType': 'mozilla::dom::nsDOMFileList',
     'headerFile': 'nsDOMFile.h',
     'resultNotAddRefed': [ 'item' ]
 },
 
 'FileReader': {
     'nativeType': 'nsDOMFileReader',
     'implicitJSContext': [ 'readAsArrayBuffer' ],
 },
@@ -1984,17 +1986,16 @@ def addExternalIface(iface, nativeType=N
     domInterface['notflattened'] = notflattened
     DOMInterfaces[iface] = domInterface
 
 addExternalIface('ApplicationCache', nativeType='nsIDOMOfflineResourceList')
 addExternalIface('Counter')
 addExternalIface('CSSRule')
 addExternalIface('mozIDOMApplication', nativeType='mozIDOMApplication', headerFile='nsIDOMApplicationRegistry.h')
 addExternalIface('RTCDataChannel', nativeType='nsIDOMDataChannel')
-addExternalIface('File')
 addExternalIface('HitRegionOptions', nativeType='nsISupports')
 addExternalIface('imgINotificationObserver', nativeType='imgINotificationObserver')
 addExternalIface('imgIRequest', nativeType='imgIRequest', notflattened=True)
 addExternalIface('MenuBuilder', nativeType='nsIMenuBuilder', notflattened=True)
 addExternalIface('MozBoxObject', nativeType='nsIBoxObject')
 addExternalIface('MozControllers', nativeType='nsIControllers')
 addExternalIface('MozFrameLoader', nativeType='nsIFrameLoader', notflattened=True)
 addExternalIface('MozFrameRequestCallback', nativeType='nsIFrameRequestCallback',
@@ -2015,16 +2016,17 @@ addExternalIface('MozWakeLockListener', 
 addExternalIface('MozXULTemplateBuilder', nativeType='nsIXULTemplateBuilder')
 addExternalIface('nsIBrowserDOMWindow', nativeType='nsIBrowserDOMWindow',
                  notflattened=True)
 addExternalIface('nsIControllers', nativeType='nsIControllers')
 addExternalIface('nsIDOMCrypto', nativeType='nsIDOMCrypto',
                  headerFile='Crypto.h')
 addExternalIface('nsIInputStreamCallback', nativeType='nsIInputStreamCallback',
                  headerFile='nsIAsyncInputStream.h')
+addExternalIface('nsIFile', nativeType='nsIFile', notflattened=True)
 addExternalIface('nsIMessageBroadcaster', nativeType='nsIMessageBroadcaster',
                  headerFile='nsIMessageManager.h', notflattened=True)
 addExternalIface('nsISelectionListener', nativeType='nsISelectionListener')
 addExternalIface('nsIStreamListener', nativeType='nsIStreamListener', notflattened=True)
 addExternalIface('nsISupports', nativeType='nsISupports')
 addExternalIface('nsIDocShell', nativeType='nsIDocShell', notflattened=True)
 addExternalIface('nsIEditor', nativeType='nsIEditor', notflattened=True)
 addExternalIface('nsIVariant', nativeType='nsIVariant', notflattened=True)
diff --git a/dom/browser-element/BrowserElementParent.jsm b/dom/browser-element/BrowserElementParent.jsm
--- a/dom/browser-element/BrowserElementParent.jsm
+++ b/dom/browser-element/BrowserElementParent.jsm
@@ -532,21 +532,23 @@ BrowserElementParent.prototype = {
    *
    */
   _gotDOMRequestResult: function(data) {
     let req = this._pendingDOMRequests[data.json.id];
     delete this._pendingDOMRequests[data.json.id];
 
     if ('successRv' in data.json) {
       debug("Successful gotDOMRequestResult.");
-      Services.DOMRequest.fireSuccess(req, data.json.successRv);
+      Services.DOMRequest.fireSuccess(req,
+        Cu.cloneInto(data.json.successRv, this._window));
     }
     else {
       debug("Got error in gotDOMRequestResult.");
-      Services.DOMRequest.fireErrorAsync(req, data.json.errorMsg);
+      Services.DOMRequest.fireErrorAsync(req,
+        Cu.cloneInto(data.json.errorMsg, this._window));
     }
   },
 
   _setVisible: function(visible) {
     this._sendAsyncMsg('set-visible', {visible: visible});
     this._frameLoader.visible = visible;
   },
 
diff --git a/dom/camera/DOMCameraControl.cpp b/dom/camera/DOMCameraControl.cpp
--- a/dom/camera/DOMCameraControl.cpp
+++ b/dom/camera/DOMCameraControl.cpp
@@ -10,16 +10,17 @@
 #include "nsThread.h"
 #include "DeviceStorage.h"
 #include "DeviceStorageFileDescriptor.h"
 #include "mozilla/dom/TabChild.h"
 #include "mozilla/ipc/FileDescriptorUtils.h"
 #include "mozilla/MediaManager.h"
 #include "mozilla/Services.h"
 #include "mozilla/unused.h"
+#include "nsDOMFile.h"
 #include "nsIAppsService.h"
 #include "nsIObserverService.h"
 #include "nsIDOMDeviceStorage.h"
 #include "nsIDOMEventListener.h"
 #include "nsIScriptSecurityManager.h"
 #include "Navigator.h"
 #include "nsXULAppAPI.h"
 #include "DOMCameraManager.h"
@@ -1172,18 +1173,19 @@ nsDOMCameraControl::OnTakePictureComplet
   if (!cb) {
     // Warn because it shouldn't be possible to get here without
     // having passed a success callback into takePicture(), even
     // though we guard against a nullptr dereference.
     NS_WARNING("DOM Null success callback in OnTakePictureComplete()");
     return;
   }
 
+  nsRefPtr<DOMFile> blob = static_cast<DOMFile*>(aPicture);
   ErrorResult ignored;
-  cb->Call(aPicture, ignored);
+  cb->Call(*blob, ignored);
 }
 
 void
 nsDOMCameraControl::OnUserError(CameraControlListener::UserContext aContext, nsresult aError)
 {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsRefPtr<CameraErrorCallback> errorCb;
diff --git a/dom/canvas/ImageEncoder.cpp b/dom/canvas/ImageEncoder.cpp
--- a/dom/canvas/ImageEncoder.cpp
+++ b/dom/canvas/ImageEncoder.cpp
@@ -44,17 +44,17 @@ public:
         DOMFile::CreateMemoryFile(mImgData, mImgSize, mType);
 
       {
         AutoJSAPI jsapi;
         jsapi.Init(mGlobal);
         JS_updateMallocCounter(jsapi.cx(), mImgSize);
       }
 
-      mCallback->Call(blob, rv);
+      mCallback->Call(*blob, rv);
     }
 
     // These members aren't thread-safe. We're making sure that they're being
     // released on the main thread here. Otherwise, they could be getting
     // released by EncodingRunnable's destructor on the encoding thread
     // (bug 916128).
     mGlobal = nullptr;
     mCallback = nullptr;
diff --git a/dom/contacts/ContactManager.js b/dom/contacts/ContactManager.js
--- a/dom/contacts/ContactManager.js
+++ b/dom/contacts/ContactManager.js
@@ -85,18 +85,19 @@ ContactManager.prototype = {
     this.__DOM_IMPL__.setEventHandler("oncontactchange", aHandler);
   },
 
   get oncontactchange() {
     return this.__DOM_IMPL__.getEventHandler("oncontactchange");
   },
 
   _convertContact: function(aContact) {
-    let newContact = new this._window.mozContact(aContact.properties);
-    newContact.setMetadata(aContact.id, aContact.published, aContact.updated);
+    var contact = Cu.cloneInto(aContact, this._window);
+    let newContact = new this._window.mozContact(contact.properties);
+    newContact.setMetadata(contact.id, contact.published, contact.updated);
     return newContact;
   },
 
   _convertContacts: function(aContacts) {
     let contacts = new this._window.Array();
     for (let i in aContacts) {
       contacts.push(this._convertContact(aContacts[i]));
     }
diff --git a/dom/contacts/tests/test_contacts_blobs.html b/dom/contacts/tests/test_contacts_blobs.html
--- a/dom/contacts/tests/test_contacts_blobs.html
+++ b/dom/contacts/tests/test_contacts_blobs.html
@@ -83,24 +83,24 @@ var properties2 = {
 };
 
 var sample_id1;
 var createResult1;
 var findResult1;
 
 function verifyBlob(blob1, blob2, isLast)
 {
-  is(blob1 instanceof SpecialPowers.Ci.nsIDOMBlob, true,
-     "blob1 is an instance of nsIDOMBlob");
-  is(blob2 instanceof SpecialPowers.Ci.nsIDOMBlob, true,
-     "blob2 is an instance of nsIDOMBlob");
-  isnot(blob1 instanceof SpecialPowers.Ci.nsIDOMFile, true,
-     "blob1 is an instance of nsIDOMFile");
-  isnot(blob2 instanceof SpecialPowers.Ci.nsIDOMFile, true,
-     "blob2 is an instance of nsIDOMFile");
+  is(blob1 instanceof Blob, true,
+     "blob1 is an instance of DOMBlob");
+  is(blob2 instanceof Blob, true,
+     "blob2 is an instance of DOMBlob");
+  isnot(blob1 instanceof File, true,
+     "blob1 is an instance of DOMFile");
+  isnot(blob2 instanceof File, true,
+     "blob2 is an instance of DOMFile");
   ise(blob1.size, blob2.size, "Same size");
   ise(blob1.type, blob2.type, "Same type");
 
   var buffer1;
   var buffer2;
 
   var reader1 = new FileReader();
   reader1.readAsArrayBuffer(blob2);
diff --git a/dom/devicestorage/DeviceStorageRequestParent.cpp b/dom/devicestorage/DeviceStorageRequestParent.cpp
--- a/dom/devicestorage/DeviceStorageRequestParent.cpp
+++ b/dom/devicestorage/DeviceStorageRequestParent.cpp
@@ -517,17 +517,17 @@ nsresult
 DeviceStorageRequestParent::PostBlobSuccessEvent::CancelableRun() {
   MOZ_ASSERT(NS_IsMainThread());
 
   nsString mime;
   CopyASCIItoUTF16(mMimeType, mime);
 
   nsString fullPath;
   mFile->GetFullPath(fullPath);
-  nsCOMPtr<nsIDOMBlob> blob = new DOMFile(
+  nsRefPtr<DOMFile> blob = new DOMFile(
     new DOMFileImplFile(fullPath, mime, mLength, mFile->mFile,
                         mLastModificationDate));
 
   ContentParent* cp = static_cast<ContentParent*>(mParent->Manager());
   BlobParent* actor = cp->GetOrCreateActorForBlob(blob);
   if (!actor) {
     ErrorResponse response(NS_LITERAL_STRING(POST_ERROR_EVENT_UNKNOWN));
     unused << mParent->Send__delete__(mParent, response);
diff --git a/dom/devicestorage/nsDeviceStorage.cpp b/dom/devicestorage/nsDeviceStorage.cpp
--- a/dom/devicestorage/nsDeviceStorage.cpp
+++ b/dom/devicestorage/nsDeviceStorage.cpp
@@ -2939,17 +2939,18 @@ public:
             !typeChecker->Check(mFile->mStorageType, mBlob)) {
           r = new PostErrorEvent(mRequest.forget(),
                                  POST_ERROR_EVENT_ILLEGAL_TYPE);
           return NS_DispatchToCurrentThread(r);
         }
 
         if (XRE_GetProcessType() != GeckoProcessType_Default) {
           BlobChild* actor
-            = ContentChild::GetSingleton()->GetOrCreateActorForBlob(mBlob);
+            = ContentChild::GetSingleton()->GetOrCreateActorForBlob(
+              static_cast<DOMFile*>(mBlob.get()));
           if (!actor) {
             return NS_ERROR_FAILURE;
           }
 
           DeviceStorageAddParams params;
           params.blobChild() = actor;
           params.type() = mFile->mStorageType;
           params.storageName() = mFile->mStorageName;
@@ -2984,17 +2985,18 @@ public:
             !typeChecker->Check(mFile->mStorageType, mBlob)) {
           r = new PostErrorEvent(mRequest.forget(),
                                  POST_ERROR_EVENT_ILLEGAL_TYPE);
           return NS_DispatchToCurrentThread(r);
         }
 
         if (XRE_GetProcessType() != GeckoProcessType_Default) {
           BlobChild* actor
-            = ContentChild::GetSingleton()->GetOrCreateActorForBlob(mBlob);
+            = ContentChild::GetSingleton()->GetOrCreateActorForBlob(
+              static_cast<DOMFile*>(mBlob.get()));
           if (!actor) {
             return NS_ERROR_FAILURE;
           }
 
           DeviceStorageAppendParams params;
           params.blobChild() = actor;
           params.type() = mFile->mStorageType;
           params.storageName() = mFile->mStorageName;
diff --git a/dom/events/test/test_eventctors.html b/dom/events/test/test_eventctors.html
--- a/dom/events/test/test_eventctors.html
+++ b/dom/events/test/test_eventctors.html
@@ -198,17 +198,17 @@ ok(ex, "Shouldn't be able to re-define t
 ex = false;
 ok(!e.isTrusted, "BlobEvent shouldn't be trusted!");
 
 ok(!e.bubbles, "Event shouldn't bubble!");
 ok(!e.cancelable, "Event shouldn't be cancelable!");
 document.dispatchEvent(e);
 is(receivedEvent, e, "Wrong event!");
 
-var blob = Blob();
+var blob = new Blob();
 e = new BlobEvent("hello", { bubbles: true, cancelable: true, data: blob });
 is(e.type, "hello", "Wrong event type!");
 ok(!e.isTrusted, "Event shouldn't be trusted!");
 ok(e.bubbles, "Event should bubble!");
 ok(e.cancelable, "Event should be cancelable!");
 is(e.data, blob , "Wrong event.data!");
 document.dispatchEvent(e);
 is(receivedEvent, e, "Wrong event!");
diff --git a/dom/filehandle/FileHandle.cpp b/dom/filehandle/FileHandle.cpp
--- a/dom/filehandle/FileHandle.cpp
+++ b/dom/filehandle/FileHandle.cpp
@@ -12,17 +12,17 @@
 #include "FileService.h"
 #include "FileStreamWrappers.h"
 #include "MemoryStreams.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "MutableFile.h"
 #include "nsContentUtils.h"
 #include "nsDebug.h"
 #include "nsError.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "nsIEventTarget.h"
 #include "nsISeekableStream.h"
 #include "nsNetUtil.h"
 #include "nsString.h"
 #include "nsStringStream.h"
 #include "nsThreadUtils.h"
 #include "xpcpublic.h"
 
@@ -617,27 +617,27 @@ FileHandleBase::GetInputStream(const Arr
   }
 
   *aInputLength = length;
   return stream.forget();
 }
 
 // static
 already_AddRefed<nsIInputStream>
-FileHandleBase::GetInputStream(nsIDOMBlob* aValue, uint64_t* aInputLength,
+FileHandleBase::GetInputStream(const DOMFile& aValue, uint64_t* aInputLength,
                                ErrorResult& aRv)
 {
-  uint64_t length;
-  aRv = aValue->GetSize(&length);
+  DOMFile& file = const_cast<DOMFile&>(aValue);
+  uint64_t length = file.GetSize(aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
 
   nsCOMPtr<nsIInputStream> stream;
-  aRv = aValue->GetInternalStream(getter_AddRefs(stream));
+  aRv = file.GetInternalStream(getter_AddRefs(stream));
   if (aRv.Failed()) {
     return nullptr;
   }
 
   *aInputLength = length;
   return stream.forget();
 }
 
diff --git a/dom/filehandle/FileHandle.h b/dom/filehandle/FileHandle.h
--- a/dom/filehandle/FileHandle.h
+++ b/dom/filehandle/FileHandle.h
@@ -16,21 +16,21 @@
 #include "mozilla/ErrorResult.h"
 #include "nsAutoPtr.h"
 #include "nsCOMPtr.h"
 #include "nsIInputStream.h"
 #include "nsIRunnable.h"
 #include "nsTArray.h"
 
 class nsAString;
-class nsIDOMBlob;
 
 namespace mozilla {
 namespace dom {
 
+class DOMFile;
 class FileHelper;
 class FileRequestBase;
 class FileService;
 class FinishHelper;
 class MetadataHelper;
 class MutableFileBase;
 
 /**
@@ -235,17 +235,18 @@ protected:
   nsresult
   Finish();
 
   static already_AddRefed<nsIInputStream>
   GetInputStream(const ArrayBuffer& aValue, uint64_t* aInputLength,
                  ErrorResult& aRv);
 
   static already_AddRefed<nsIInputStream>
-  GetInputStream(nsIDOMBlob* aValue, uint64_t* aInputLength, ErrorResult& aRv);
+  GetInputStream(const DOMFile& aValue, uint64_t* aInputLength,
+                 ErrorResult& aRv);
 
   static already_AddRefed<nsIInputStream>
   GetInputStream(const nsAString& aValue, uint64_t* aInputLength,
                  ErrorResult& aRv);
 };
 
 class FinishHelper MOZ_FINAL : public nsIRunnable
 {
diff --git a/dom/filesystem/CreateFileTask.cpp b/dom/filesystem/CreateFileTask.cpp
--- a/dom/filesystem/CreateFileTask.cpp
+++ b/dom/filesystem/CreateFileTask.cpp
@@ -20,17 +20,17 @@
 
 namespace mozilla {
 namespace dom {
 
 uint32_t CreateFileTask::sOutputBufferSize = 0;
 
 CreateFileTask::CreateFileTask(FileSystemBase* aFileSystem,
                                const nsAString& aPath,
-                               nsIDOMBlob* aBlobData,
+                               DOMFile* aBlobData,
                                InfallibleTArray<uint8_t>& aArrayData,
                                bool replace,
                                ErrorResult& aRv)
   : FileSystemTaskBase(aFileSystem)
   , mTargetRealPath(aPath)
   , mBlobData(aBlobData)
   , mReplace(replace)
 {
diff --git a/dom/filesystem/CreateFileTask.h b/dom/filesystem/CreateFileTask.h
--- a/dom/filesystem/CreateFileTask.h
+++ b/dom/filesystem/CreateFileTask.h
@@ -6,32 +6,32 @@
 
 #ifndef mozilla_dom_CreateFileTask_h
 #define mozilla_dom_CreateFileTask_h
 
 #include "mozilla/dom/FileSystemTaskBase.h"
 #include "nsAutoPtr.h"
 #include "mozilla/ErrorResult.h"
 
-class nsIDOMBlob;
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 
+class DOMFile;
 class DOMFileImpl;
 class Promise;
 
 class CreateFileTask MOZ_FINAL
   : public FileSystemTaskBase
 {
 public:
   CreateFileTask(FileSystemBase* aFileSystem,
                  const nsAString& aPath,
-                 nsIDOMBlob* aBlobData,
+                 DOMFile* aBlobData,
                  InfallibleTArray<uint8_t>& aArrayData,
                  bool replace,
                  ErrorResult& aRv);
   CreateFileTask(FileSystemBase* aFileSystem,
                  const FileSystemCreateFileParams& aParam,
                  FileSystemRequestParent* aParent);
 
   virtual
@@ -61,17 +61,17 @@ protected:
 
 private:
   void
   GetOutputBufferSize() const;
 
   static uint32_t sOutputBufferSize;
   nsRefPtr<Promise> mPromise;
   nsString mTargetRealPath;
-  nsCOMPtr<nsIDOMBlob> mBlobData;
+  nsRefPtr<DOMFile> mBlobData;
   nsCOMPtr<nsIInputStream> mBlobStream;
   InfallibleTArray<uint8_t> mArrayData;
   bool mReplace;
 
   // This cannot be a DOMFile because this object is created on a different
   // thread and DOMFile is not thread-safe. Let's use the DOMFileImpl instead.
   nsRefPtr<DOMFileImpl> mTargetFileImpl;
 };
diff --git a/dom/filesystem/DeviceStorageFileSystem.cpp b/dom/filesystem/DeviceStorageFileSystem.cpp
--- a/dom/filesystem/DeviceStorageFileSystem.cpp
+++ b/dom/filesystem/DeviceStorageFileSystem.cpp
@@ -118,17 +118,19 @@ DeviceStorageFileSystem::GetRealPath(DOM
 {
   MOZ_ASSERT(FileSystemUtils::IsParentProcess(),
              "Should be on parent process!");
   MOZ_ASSERT(aFile, "aFile Should not be null.");
 
   aRealPath.Truncate();
 
   nsAutoString filePath;
-  if (NS_FAILED(aFile->GetMozFullPathInternal(filePath))) {
+  ErrorResult rv;
+  aFile->GetMozFullPathInternal(filePath, rv);
+  if (NS_WARN_IF(rv.Failed())) {
     return false;
   }
 
   return LocalPathToRealPath(filePath, aRealPath);
 }
 
 const nsAString&
 DeviceStorageFileSystem::GetRootName() const
diff --git a/dom/filesystem/Directory.cpp b/dom/filesystem/Directory.cpp
--- a/dom/filesystem/Directory.cpp
+++ b/dom/filesystem/Directory.cpp
@@ -98,17 +98,17 @@ Directory::GetName(nsString& aRetval) co
 }
 
 already_AddRefed<Promise>
 Directory::CreateFile(const nsAString& aPath, const CreateFileOptions& aOptions,
                       ErrorResult& aRv)
 {
   nsresult error = NS_OK;
   nsString realPath;
-  nsRefPtr<nsIDOMBlob> blobData;
+  nsRefPtr<DOMFile> blobData;
   InfallibleTArray<uint8_t> arrayData;
   bool replace = (aOptions.mIfExists == CreateIfExistsMode::Replace);
 
   // Get the file content.
   if (aOptions.mData.WasPassed()) {
     auto& data = aOptions.mData.Value();
     if (data.IsString()) {
       NS_ConvertUTF16toUTF8 str(data.GetAsString());
@@ -126,18 +126,18 @@ Directory::CreateFile(const nsAString& a
       blobData = data.GetAsBlob();
     }
   }
 
   if (!DOMPathToRealPath(aPath, realPath)) {
     error = NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR;
   }
 
-  nsRefPtr<CreateFileTask> task = new CreateFileTask(mFileSystem, realPath,
-    blobData, arrayData, replace, aRv);
+  nsRefPtr<CreateFileTask> task =
+    new CreateFileTask(mFileSystem, realPath, blobData, arrayData, replace, aRv);
   if (aRv.Failed()) {
     return nullptr;
   }
   task->SetError(error);
   FileSystemPermissionRequest::RequestForTask(task);
   return task->GetPromise();
 }
 
@@ -195,17 +195,17 @@ Directory::RemoveInternal(const StringOr
 {
   nsresult error = NS_OK;
   nsString realPath;
   nsRefPtr<DOMFileImpl> file;
 
   // Check and get the target path.
 
   if (aPath.IsFile()) {
-    file = static_cast<DOMFile*>(aPath.GetAsFile())->Impl();
+    file = aPath.GetAsFile().Impl();
     goto parameters_check_done;
   }
 
   if (aPath.IsString()) {
     if (!DOMPathToRealPath(aPath.GetAsString(), realPath)) {
       error = NS_ERROR_DOM_FILESYSTEM_INVALID_PATH_ERR;
     }
     goto parameters_check_done;
diff --git a/dom/filesystem/FileSystemTaskBase.cpp b/dom/filesystem/FileSystemTaskBase.cpp
--- a/dom/filesystem/FileSystemTaskBase.cpp
+++ b/dom/filesystem/FileSystemTaskBase.cpp
@@ -164,17 +164,17 @@ FileSystemTaskBase::GetBlobParent(nsIDOM
   nsString mimeType;
   aFile->GetType(mimeType);
   uint64_t fileSize;
   aFile->GetSize(&fileSize);
   uint64_t lastModifiedDate;
   aFile->GetMozLastModifiedDate(&lastModifiedDate);
 
   ContentParent* cp = static_cast<ContentParent*>(mRequestParent->Manager());
-  return cp->GetOrCreateActorForBlob(aFile);
+  return cp->GetOrCreateActorForBlob(static_cast<DOMFile*>(aFile));
 }
 
 void
 FileSystemTaskBase::SetError(const nsresult& aErrorValue)
 {
   uint16_t module = NS_ERROR_GET_MODULE(aErrorValue);
   if (module == NS_ERROR_MODULE_DOM_FILESYSTEM ||
       module == NS_ERROR_MODULE_DOM_FILE ||
diff --git a/dom/indexedDB/FileSnapshot.cpp b/dom/indexedDB/FileSnapshot.cpp
--- a/dom/indexedDB/FileSnapshot.cpp
+++ b/dom/indexedDB/FileSnapshot.cpp
@@ -78,32 +78,34 @@ FileImplSnapshot::GetInternalStream(nsII
 
   nsresult rv = mFileHandle->OpenInputStream(mWholeFile, mStart, mLength,
                                              aStream);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 FileImplSnapshot::CreateSlice(uint64_t aStart, uint64_t aLength,
-                              const nsAString& aContentType)
+                              const nsAString& aContentType,
+                              ErrorResult& aRv)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
 
-  nsCOMPtr<nsIDOMBlob> t =
-    new DOMFile(new FileImplSnapshot(this, aStart, aLength, aContentType));
+  nsRefPtr<DOMFileImpl> impl =
+    new FileImplSnapshot(this, aStart, aLength, aContentType);
 
-  return t.forget();
+  return impl.forget();
 }
 
-nsresult
-FileImplSnapshot::GetMozFullPathInternal(nsAString& aFilename)
+void
+FileImplSnapshot::GetMozFullPathInternal(nsAString& aFilename,
+                                         ErrorResult& aRv)
 {
   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
   NS_ASSERTION(mIsFile, "Should only be called on files");
 
-  return mFile->GetPath(aFilename);
+  aRv = mFile->GetPath(aFilename);
 }
 
 } // namespace indexedDB
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/indexedDB/FileSnapshot.h b/dom/indexedDB/FileSnapshot.h
--- a/dom/indexedDB/FileSnapshot.h
+++ b/dom/indexedDB/FileSnapshot.h
@@ -25,18 +25,18 @@ public:
   NS_DECL_ISUPPORTS_INHERITED
 
   // Create as a stored file
   FileImplSnapshot(const nsAString& aName, const nsAString& aContentType,
                    uint64_t aLength, nsIFile* aFile, IDBFileHandle* aFileHandle,
                    FileInfo* aFileInfo);
 
   // Overrides
-  virtual nsresult
-  GetMozFullPathInternal(nsAString& aFullPath) MOZ_OVERRIDE;
+  virtual void
+  GetMozFullPathInternal(nsAString& aFullPath, ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual nsresult
   GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
   virtual void
   Unlink() MOZ_OVERRIDE;
 
   virtual void
@@ -50,19 +50,20 @@ public:
 
 protected:
   // Create slice
   FileImplSnapshot(const FileImplSnapshot* aOther, uint64_t aStart,
                    uint64_t aLength, const nsAString& aContentType);
 
   virtual ~FileImplSnapshot();
 
-  virtual already_AddRefed<nsIDOMBlob>
+  virtual already_AddRefed<DOMFileImpl>
   CreateSlice(uint64_t aStart, uint64_t aLength,
-              const nsAString& aContentType) MOZ_OVERRIDE;
+              const nsAString& aContentType,
+              ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual bool
   IsStoredFile() const MOZ_OVERRIDE
   {
     return true;
   }
 
   virtual bool
diff --git a/dom/indexedDB/IDBObjectStore.cpp b/dom/indexedDB/IDBObjectStore.cpp
--- a/dom/indexedDB/IDBObjectStore.cpp
+++ b/dom/indexedDB/IDBObjectStore.cpp
@@ -808,18 +808,16 @@ public:
                                            const BlobOrFileData& aData)
   {
     MOZ_ASSERT(NS_IsMainThread());
 
     MOZ_ASSERT(aData.tag == SCTAG_DOM_FILE ||
                aData.tag == SCTAG_DOM_FILE_WITHOUT_LASTMODIFIEDDATE ||
                aData.tag == SCTAG_DOM_BLOB);
 
-    nsresult rv = NS_OK;
-
     nsRefPtr<FileInfo>& fileInfo = aFile.mFileInfo;
 
     nsCOMPtr<nsIFile> nativeFile;
     if (!aFile.mFile) {
       FileManager* fileManager = aDatabase->Manager();
         NS_ASSERTION(fileManager, "This should never be null!");
 
       nsCOMPtr<nsIFile> directory = fileManager->GetDirectory();
@@ -843,50 +841,46 @@ public:
         }
         domBlob = aFile.mFile;
       }
       else {
         domBlob = DOMFile::CreateFromFile(aData.type, aData.size, nativeFile,
                                           fileInfo);
       }
 
-      JS::Rooted<JS::Value> wrappedBlob(aCx);
-      rv = nsContentUtils::WrapNative(aCx, domBlob, &NS_GET_IID(nsIDOMBlob),
-                                      &wrappedBlob);
-      if (NS_FAILED(rv)) {
-        NS_WARNING("Failed to wrap native!");
+      DOMFile* blob = static_cast<DOMFile*>(domBlob.get());
+      JS::Rooted<JSObject*> obj(aCx, blob->WrapObject(aCx));
+      if (!obj || !JS_WrapObject(aCx, &obj)) {
         return nullptr;
       }
 
-      return wrappedBlob.toObjectOrNull();
+      return obj;
     }
 
     nsCOMPtr<nsIDOMFile> domFile;
     if (aFile.mFile) {
       if (!ResolveMysteryFile(aFile.mFile, aData.name, aData.type, aData.size,
                               aData.lastModifiedDate)) {
         return nullptr;
       }
       domFile = do_QueryInterface(aFile.mFile);
       NS_ASSERTION(domFile, "This should never fail!");
     }
     else {
       domFile = DOMFile::CreateFromFile(aData.name, aData.type, aData.size,
                                         nativeFile, fileInfo);
     }
 
-    JS::Rooted<JS::Value> wrappedFile(aCx);
-    rv = nsContentUtils::WrapNative(aCx, domFile, &NS_GET_IID(nsIDOMFile),
-                                    &wrappedFile);
-    if (NS_FAILED(rv)) {
-      NS_WARNING("Failed to wrap native!");
+    DOMFile* file = static_cast<DOMFile*>(domFile.get());
+    JS::Rooted<JSObject*> obj(aCx, file->WrapObject(aCx));
+    if (!obj || !JS_WrapObject(aCx, &obj)) {
       return nullptr;
     }
 
-    return wrappedFile.toObjectOrNull();
+    return obj;
   }
 };
 
 
 class CreateIndexDeserializationTraits
 {
 public:
   static bool CreateAndWrapMutableFile(JSContext* aCx,
@@ -1624,107 +1618,101 @@ IDBObjectStore::StructuredCloneWriteCall
     }
 
     StructuredCloneFile* file = cloneWriteInfo->mFiles.AppendElement();
     file->mFileInfo = fileInfo.forget();
 
     return true;
   }
 
-  nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
-  nsContentUtils::XPConnect()->
-    GetWrappedNativeOfJSObject(aCx, aObj, getter_AddRefs(wrappedNative));
-
-  if (wrappedNative) {
-    nsISupports* supports = wrappedNative->Native();
-
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
-    if (blob) {
-      nsCOMPtr<nsIInputStream> inputStream;
-
-      // Check if it is a blob created from this db or the blob was already
-      // stored in this db
-      nsRefPtr<FileInfo> fileInfo = transaction->GetFileInfo(blob);
-      if (!fileInfo && fileManager) {
-        fileInfo = blob->GetFileInfo(fileManager);
-
+  DOMFile* domBlob = nullptr;
+  if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, aObj, domBlob))) {
+    nsCOMPtr<nsIInputStream> inputStream;
+
+    // Check if it is a blob created from this db or the blob was already
+    // stored in this db
+    nsRefPtr<FileInfo> fileInfo = transaction->GetFileInfo(domBlob);
+    if (!fileInfo && fileManager) {
+      fileInfo = domBlob->GetFileInfo(fileManager);
+
+      if (!fileInfo) {
+        fileInfo = fileManager->GetNewFileInfo();
         if (!fileInfo) {
-          fileInfo = fileManager->GetNewFileInfo();
-          if (!fileInfo) {
-            NS_WARNING("Failed to get new file info!");
-            return false;
-          }
-
-          if (NS_FAILED(blob->GetInternalStream(getter_AddRefs(inputStream)))) {
-            NS_WARNING("Failed to get internal steam!");
-            return false;
-          }
-
-          transaction->AddFileInfo(blob, fileInfo);
+          NS_WARNING("Failed to get new file info!");
+          return false;
         }
+
+        if (NS_FAILED(domBlob->GetInternalStream(getter_AddRefs(inputStream)))) {
+          NS_WARNING("Failed to get internal steam!");
+          return false;
+        }
+
+        transaction->AddFileInfo(domBlob, fileInfo);
       }
-
-      uint64_t size;
-      if (NS_FAILED(blob->GetSize(&size))) {
-        NS_WARNING("Failed to get size!");
+    }
+
+    ErrorResult rv;
+    uint64_t size = domBlob->GetSize(rv);
+    if (rv.Failed()) {
+      NS_WARNING("Failed to get size!");
+      return false;
+    }
+
+    size = NativeEndian::swapToLittleEndian(size);
+
+    nsString type;
+    domBlob->GetType(type, rv);
+    if (rv.Failed()) {
+      NS_WARNING("Failed to get type!");
+      return false;
+    }
+
+    NS_ConvertUTF16toUTF8 convType(type);
+    uint32_t convTypeLength =
+      NativeEndian::swapToLittleEndian(convType.Length());
+
+    if (!JS_WriteUint32Pair(aWriter, domBlob->IsFile() ? SCTAG_DOM_FILE : SCTAG_DOM_BLOB,
+                            cloneWriteInfo->mFiles.Length()) ||
+        !JS_WriteBytes(aWriter, &size, sizeof(size)) ||
+        !JS_WriteBytes(aWriter, &convTypeLength, sizeof(convTypeLength)) ||
+        !JS_WriteBytes(aWriter, convType.get(), convType.Length())) {
+      return false;
+    }
+
+    if (domBlob->IsFile()) {
+      uint64_t lastModifiedDate = 0;
+      if (NS_FAILED(domBlob->GetMozLastModifiedDate(&lastModifiedDate))) {
+        NS_WARNING("Failed to get last modified date!");
         return false;
       }
-      size = NativeEndian::swapToLittleEndian(size);
-
-      nsString type;
-      if (NS_FAILED(blob->GetType(type))) {
-        NS_WARNING("Failed to get type!");
+
+      lastModifiedDate = NativeEndian::swapToLittleEndian(lastModifiedDate);
+
+      nsString name;
+      if (NS_FAILED(domBlob->GetName(name))) {
+        NS_WARNING("Failed to get name!");
         return false;
       }
-      NS_ConvertUTF16toUTF8 convType(type);
-      uint32_t convTypeLength =
-        NativeEndian::swapToLittleEndian(convType.Length());
-
-      nsCOMPtr<nsIDOMFile> file = do_QueryInterface(blob);
-
-      if (!JS_WriteUint32Pair(aWriter, file ? SCTAG_DOM_FILE : SCTAG_DOM_BLOB,
-                              cloneWriteInfo->mFiles.Length()) ||
-          !JS_WriteBytes(aWriter, &size, sizeof(size)) ||
-          !JS_WriteBytes(aWriter, &convTypeLength, sizeof(convTypeLength)) ||
-          !JS_WriteBytes(aWriter, convType.get(), convType.Length())) {
+      NS_ConvertUTF16toUTF8 convName(name);
+      uint32_t convNameLength =
+        NativeEndian::swapToLittleEndian(convName.Length());
+
+      if (!JS_WriteBytes(aWriter, &lastModifiedDate, sizeof(lastModifiedDate)) ||
+          !JS_WriteBytes(aWriter, &convNameLength, sizeof(convNameLength)) ||
+          !JS_WriteBytes(aWriter, convName.get(), convName.Length())) {
         return false;
       }
-
-      if (file) {
-        uint64_t lastModifiedDate = 0;
-        if (NS_FAILED(file->GetMozLastModifiedDate(&lastModifiedDate))) {
-          NS_WARNING("Failed to get last modified date!");
-          return false;
-        }
-
-        lastModifiedDate = NativeEndian::swapToLittleEndian(lastModifiedDate);
-
-        nsString name;
-        if (NS_FAILED(file->GetName(name))) {
-          NS_WARNING("Failed to get name!");
-          return false;
-        }
-        NS_ConvertUTF16toUTF8 convName(name);
-        uint32_t convNameLength =
-          NativeEndian::swapToLittleEndian(convName.Length());
-
-        if (!JS_WriteBytes(aWriter, &lastModifiedDate, sizeof(lastModifiedDate)) || 
-            !JS_WriteBytes(aWriter, &convNameLength, sizeof(convNameLength)) ||
-            !JS_WriteBytes(aWriter, convName.get(), convName.Length())) {
-          return false;
-        }
-      }
-
-      StructuredCloneFile* cloneFile = cloneWriteInfo->mFiles.AppendElement();
-      cloneFile->mFile = blob.forget();
-      cloneFile->mFileInfo = fileInfo.forget();
-      cloneFile->mInputStream = inputStream.forget();
-
-      return true;
     }
+
+    StructuredCloneFile* cloneFile = cloneWriteInfo->mFiles.AppendElement();
+    cloneFile->mFile = domBlob;
+    cloneFile->mFileInfo = fileInfo.forget();
+    cloneFile->mInputStream = inputStream.forget();
+
+    return true;
   }
 
   // try using the runtime callbacks
   const JSStructuredCloneCallbacks* runtimeCallbacks =
     js::GetContextStructuredCloneCallbacks(aCx);
   if (runtimeCallbacks) {
     return runtimeCallbacks->write(aCx, aWriter, aObj, nullptr);
   }
@@ -1809,18 +1797,18 @@ IDBObjectStore::ConvertBlobsToActors(
 
       nsCOMPtr<nsIFile> nativeFile =
         aFileManager->GetFileForId(directory, file.mFileInfo->Id());
       if (!nativeFile) {
         IDB_WARNING("Failed to get file!");
         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
       }
 
-      nsCOMPtr<nsIDOMBlob> blob = DOMFile::CreateFromFile(nativeFile,
-                                                          file.mFileInfo);
+      nsRefPtr<DOMFile> blob = DOMFile::CreateFromFile(nativeFile,
+                                                       file.mFileInfo);
 
       BlobParent* actor =
         aContentParent->GetOrCreateActorForBlob(blob);
       if (!actor) {
         // This can only fail if the child has crashed.
         IDB_REPORT_INTERNAL_ERR();
         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
       }
@@ -3403,18 +3391,18 @@ AddHelper::PackArgumentsForParentProcess
     NS_ASSERTION(aBlobCreator, "This should never be null!");
 
     for (uint32_t index = 0; index < fileCount; index++) {
       const StructuredCloneFile& file = files[index];
 
       NS_ASSERTION(file.mFile, "This should never be null!");
       NS_ASSERTION(!file.mFileInfo, "This is not yet supported!");
 
-      BlobChild* actor =
-        aBlobCreator->GetOrCreateActorForBlob(file.mFile);
+      nsRefPtr<DOMFile> domFile = static_cast<DOMFile*>(file.mFile.get());
+      BlobChild* actor = aBlobCreator->GetOrCreateActorForBlob(domFile);
       if (!actor) {
         IDB_REPORT_INTERNAL_ERR();
         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
       }
       blobsChild.AppendElement(actor);
     }
   }
 
diff --git a/dom/indexedDB/ipc/IndexedDBParent.cpp b/dom/indexedDB/ipc/IndexedDBParent.cpp
--- a/dom/indexedDB/ipc/IndexedDBParent.cpp
+++ b/dom/indexedDB/ipc/IndexedDBParent.cpp
@@ -1,28 +1,28 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 
 #include "IndexedDBParent.h"
 
 #include "nsIDOMEvent.h"
-#include "nsIDOMFile.h"
 #include "nsIXPConnect.h"
 
 #include "mozilla/AppProcessChecker.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/IDBDatabaseBinding.h"
 #include "mozilla/dom/ipc/Blob.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/unused.h"
 #include "nsCxPusher.h"
+#include "nsDOMFile.h"
 
 #include "AsyncConnectionHelper.h"
 #include "DatabaseInfo.h"
 #include "IDBDatabase.h"
 #include "IDBEvents.h"
 #include "IDBFactory.h"
 #include "IDBIndex.h"
 #include "IDBKeyRange.h"
@@ -1496,17 +1496,17 @@ IndexedDBObjectStoreRequestParent::Conve
     // Walk the chain to get to ContentParent.
     MOZ_ASSERT(mObjectStore->Transaction()->Database()->GetContentParent());
 
     uint32_t length = aActors.Length();
     aBlobs.SetCapacity(length);
 
     for (uint32_t index = 0; index < length; index++) {
       BlobParent* actor = static_cast<BlobParent*>(aActors[index]);
-      nsCOMPtr<nsIDOMBlob> blob = actor->GetBlob();
+      nsRefPtr<DOMFile> blob = actor->GetBlob();
       aBlobs.AppendElement(blob);
     }
   }
 }
 
 bool
 IndexedDBObjectStoreRequestParent::IsDisconnected()
 {
diff --git a/dom/indexedDB/test/unit/test_temporary_storage.js b/dom/indexedDB/test/unit/test_temporary_storage.js
--- a/dom/indexedDB/test/unit/test_temporary_storage.js
+++ b/dom/indexedDB/test/unit/test_temporary_storage.js
@@ -1,13 +1,15 @@
 /**
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
+Components.utils.importGlobalProperties(['Blob']);
+
 var testGenerator = testSteps();
 
 function testSteps()
 {
   const name = this.window ? window.location.pathname : "Splendid Test";
 
   const urls = [
     { url: "http://www.alpha.com",        flags: [true, true, false, false] },
@@ -197,17 +199,17 @@ function testSteps()
   let db = event.target.result;
 
   checkUsage(3);
   yield undefined;
 
   // Stage 4
   let trans = db.transaction(["foo"], "readwrite");
 
-  let blob = Blob(["bar"]);
+  let blob = new Blob(["bar"]);
   request = trans.objectStore("foo").add(blob, 42);
   request.onerror = errorHandler;
   request.onsuccess = grabEventAndContinueHandler;
   event = yield undefined;
 
   trans.oncomplete = grabEventAndContinueHandler;
   event = yield undefined;
 
diff --git a/dom/ipc/Blob.cpp b/dom/ipc/Blob.cpp
--- a/dom/ipc/Blob.cpp
+++ b/dom/ipc/Blob.cpp
@@ -739,27 +739,25 @@ public:
   SetActor(BlobChild* aActor)
   {
     MOZ_ASSERT(!aActor || !mActor);
     mActor = aActor;
   }
 
   NS_DECL_ISUPPORTS_INHERITED
 
-  virtual already_AddRefed<nsIDOMBlob>
-  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType)
-              MOZ_OVERRIDE;
+  virtual already_AddRefed<DOMFileImpl>
+  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType,
+              ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual nsresult
   GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
-  virtual nsresult
-  GetLastModifiedDate(JSContext* cx,
-                      JS::MutableHandle<JS::Value> aLastModifiedDate)
-                      MOZ_OVERRIDE;
+  virtual int64_t
+  GetLastModified(ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual void*
   GetPBlob() MOZ_OVERRIDE;
 
 private:
   ~RemoteBlob()
   {
     if (mActor) {
@@ -995,94 +993,87 @@ private:
 };
 
 /*******************************************************************************
  * BlobChild::RemoteBlob Implementation
  ******************************************************************************/
 
 NS_IMPL_ISUPPORTS_INHERITED(BlobChild::RemoteBlob, DOMFileImpl, nsIRemoteBlob)
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 BlobChild::
 RemoteBlob::CreateSlice(uint64_t aStart,
                         uint64_t aLength,
-                        const nsAString& aContentType)
+                        const nsAString& aContentType,
+                        ErrorResult& aRv)
 {
   if (!mActor) {
+    aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   nsRefPtr<SliceHelper> helper = new SliceHelper(mActor);
 
-  ErrorResult rv;
   nsRefPtr<DOMFileImpl> slice = helper->GetSlice(aStart, aLength,
-                                                 aContentType, rv);
-  if (rv.Failed()) {
+                                                 aContentType, aRv);
+  if (aRv.Failed()) {
     return nullptr;
   }
 
-  nsRefPtr<DOMFile> file = new DOMFile(slice);
-  return file.forget();
+  return slice.forget();
 }
 
 nsresult
 BlobChild::
 RemoteBlob::GetInternalStream(nsIInputStream** aStream)
 {
   if (!mActor) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsRefPtr<StreamHelper> helper = new StreamHelper(mActor, this);
   return helper->GetStream(aStream);
 }
 
-nsresult
+int64_t
 BlobChild::
-RemoteBlob::GetLastModifiedDate(JSContext* cx,
-                                JS::MutableHandle<JS::Value> aLastModifiedDate)
+RemoteBlob::GetLastModified(ErrorResult& aRv)
 {
   if (IsDateUnknown()) {
-    aLastModifiedDate.setNull();
-  } else {
-    JSObject* date = JS_NewDateObjectMsec(cx, mLastModificationDate);
-    if (!date) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    aLastModifiedDate.setObject(*date);
+    return 0;
   }
-  return NS_OK;
+
+  return mLastModificationDate;
 }
 
 void*
 BlobChild::
 RemoteBlob::GetPBlob()
 {
   return static_cast<PBlobChild*>(mActor);
 }
 
 /*******************************************************************************
  * BlobChild
  ******************************************************************************/
 
-BlobChild::BlobChild(nsIContentChild* aManager, nsIDOMBlob* aBlob)
+BlobChild::BlobChild(nsIContentChild* aManager, DOMFile* aBlob)
   : mBlob(aBlob)
   , mRemoteBlob(nullptr)
   , mStrongManager(aManager)
   , mOwnsBlob(true)
   , mBlobIsFile(false)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(aBlob);
 
   aBlob->AddRef();
 
-  nsCOMPtr<nsIDOMFile> file = do_QueryInterface(aBlob);
-  mBlobIsFile = !!file;
+  mBlobIsFile = aBlob->IsFile();
 }
 
 BlobChild::BlobChild(nsIContentChild* aManager,
                      const ChildBlobConstructorParams& aParams)
   : mBlob(nullptr)
   , mRemoteBlob(nullptr)
   , mStrongManager(aManager)
   , mOwnsBlob(false)
@@ -1139,33 +1130,34 @@ BlobChild::Create(nsIContentChild* aMana
       MOZ_ASSERT(source);
 
       nsCOMPtr<nsIDOMBlob> slice;
       nsresult rv =
         source->Slice(params.begin(), params.end(), params.contentType(), 3,
                       getter_AddRefs(slice));
       NS_ENSURE_SUCCESS(rv, nullptr);
 
-      return new BlobChild(aManager, slice);
+      nsRefPtr<DOMFile> file = static_cast<DOMFile*>(slice.get());
+      return new BlobChild(aManager, file);
     }
 
     default:
       MOZ_CRASH("Unknown params!");
   }
 
   return nullptr;
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFile>
 BlobChild::GetBlob()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mBlob);
 
-  nsCOMPtr<nsIDOMBlob> blob;
+  nsRefPtr<DOMFile> blob;
 
   // Remote blobs are held alive until the first call to GetBlob. Thereafter we
   // only hold a weak reference. Normal blobs are held alive until the actor is
   // destroyed.
   if (mRemoteBlob && mOwnsBlob) {
     blob = dont_AddRef(mBlob);
     mOwnsBlob = false;
   }
@@ -1445,27 +1437,25 @@ public:
         OptionalInputStreamParams::TInputStreamParams) {
       mInputStreamParams =
         aParams.optionalInputStreamParams().get_InputStreamParams();
     }
   }
 
   NS_DECL_ISUPPORTS_INHERITED
 
-  virtual already_AddRefed<nsIDOMBlob>
-  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType)
-              MOZ_OVERRIDE;
+  virtual already_AddRefed<DOMFileImpl>
+  CreateSlice(uint64_t aStart, uint64_t aLength, const nsAString& aContentType,
+              ErrorResult& aRv) MOZ_OVERRIDE;
 
   virtual nsresult
   GetInternalStream(nsIInputStream** aStream) MOZ_OVERRIDE;
 
-  virtual nsresult
-  GetLastModifiedDate(JSContext* cx,
-                      JS::MutableHandle<JS::Value> aLastModifiedDate)
-                      MOZ_OVERRIDE;
+  virtual int64_t
+  GetLastModified(ErrorResult& aRv) MOZ_OVERRIDE;
 
   void*
   GetPBlob() MOZ_OVERRIDE;
 
 private:
   ~RemoteBlob()
   {
     if (mActor) {
@@ -1703,37 +1693,37 @@ private:
 };
 
 /*******************************************************************************
  * BlobChild::RemoteBlob Implementation
  ******************************************************************************/
 
 NS_IMPL_ISUPPORTS_INHERITED(BlobParent::RemoteBlob, DOMFileImpl, nsIRemoteBlob)
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFileImpl>
 BlobParent::
 RemoteBlob::CreateSlice(uint64_t aStart,
                         uint64_t aLength,
-                        const nsAString& aContentType)
+                        const nsAString& aContentType,
+                        ErrorResult& aRv)
 {
   if (!mActor) {
+    aRv.Throw(NS_ERROR_FAILURE);
     return nullptr;
   }
 
   nsRefPtr<SliceHelper> helper = new SliceHelper(mActor);
 
-  ErrorResult rv;
   nsRefPtr<DOMFileImpl> slice = helper->GetSlice(aStart, aLength,
-                                                 aContentType, rv);
-  if (rv.Failed()) {
+                                                 aContentType, aRv);
+  if (aRv.Failed()) {
     return nullptr;
   }
 
-  nsRefPtr<DOMFile> file = new DOMFile(slice);
-  return file.forget();
+  return slice.forget();
 }
 
 nsresult
 BlobParent::
 RemoteBlob::GetInternalStream(nsIInputStream** aStream)
 {
   if (mInputStreamParams.type() != InputStreamParams::T__None) {
     nsTArray<FileDescriptor> fds;
@@ -1753,59 +1743,52 @@ RemoteBlob::GetInternalStream(nsIInputSt
   if (!mActor) {
     return NS_ERROR_UNEXPECTED;
   }
 
   nsRefPtr<StreamHelper> helper = new StreamHelper(mActor, this);
   return helper->GetStream(aStream);
 }
 
-nsresult
+int64_t
 BlobParent::
-RemoteBlob::GetLastModifiedDate(JSContext* cx,
-                                JS::MutableHandle<JS::Value> aLastModifiedDate)
+RemoteBlob::GetLastModified(ErrorResult& aRv)
 {
   if (IsDateUnknown()) {
-    aLastModifiedDate.setNull();
-  } else {
-    JSObject* date = JS_NewDateObjectMsec(cx, mLastModificationDate);
-    if (!date) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    aLastModifiedDate.setObject(*date);
+    return 0;
   }
-  return NS_OK;
+
+  return mLastModificationDate;
 }
 
 void*
 BlobParent::
 RemoteBlob::GetPBlob()
 {
   return static_cast<PBlobParent*>(mActor);
 }
 
 /*******************************************************************************
  * BlobParent
  ******************************************************************************/
 
-BlobParent::BlobParent(nsIContentParent* aManager, nsIDOMBlob* aBlob)
+BlobParent::BlobParent(nsIContentParent* aManager, DOMFile* aBlob)
   : mBlob(aBlob)
   , mRemoteBlob(nullptr)
   , mStrongManager(aManager)
   , mOwnsBlob(true)
   , mBlobIsFile(false)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aManager);
   MOZ_ASSERT(aBlob);
 
   aBlob->AddRef();
 
-  nsCOMPtr<nsIDOMFile> file = do_QueryInterface(aBlob);
-  mBlobIsFile = !!file;
+  mBlobIsFile = aBlob->IsFile();
 }
 
 BlobParent::BlobParent(nsIContentParent* aManager,
                        const ParentBlobConstructorParams& aParams)
   : mBlob(nullptr)
   , mRemoteBlob(nullptr)
   , mStrongManager(aManager)
   , mOwnsBlob(false)
@@ -1870,33 +1853,34 @@ BlobParent::Create(nsIContentParent* aMa
       MOZ_ASSERT(source);
 
       nsCOMPtr<nsIDOMBlob> slice;
       nsresult rv =
         source->Slice(params.begin(), params.end(), params.contentType(), 3,
                       getter_AddRefs(slice));
       NS_ENSURE_SUCCESS(rv, nullptr);
 
-      return new BlobParent(aManager, slice);
+      nsRefPtr<DOMFile> file = static_cast<DOMFile*>(slice.get());
+      return new BlobParent(aManager, file);
     }
 
     default:
       MOZ_CRASH("Unknown params!");
   }
 
   return nullptr;
 }
 
-already_AddRefed<nsIDOMBlob>
+already_AddRefed<DOMFile>
 BlobParent::GetBlob()
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(mBlob);
 
-  nsCOMPtr<nsIDOMBlob> blob;
+  nsRefPtr<DOMFile> blob;
 
   // Remote blobs are held alive until the first call to GetBlob. Thereafter we
   // only hold a weak reference. Normal blobs are held alive until the actor is
   // destroyed.
   if (mRemoteBlob && mOwnsBlob) {
     blob = dont_AddRef(mBlob);
     mOwnsBlob = false;
   }
diff --git a/dom/ipc/Blob.h b/dom/ipc/Blob.h
--- a/dom/ipc/Blob.h
+++ b/dom/ipc/Blob.h
@@ -6,55 +6,55 @@
 #define mozilla_dom_ipc_Blob_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PBlobParent.h"
 #include "nsAutoPtr.h"
 #include "nsTArray.h"
 
-class nsIDOMBlob;
 class nsString;
 template <class> class nsRevocableEventPtr;
 
 namespace mozilla {
 namespace dom {
 
+class DOMFile;
 class nsIContentChild;
 class nsIContentParent;
 class PBlobStreamChild;
 class PBlobStreamParent;
 
 class BlobChild MOZ_FINAL
   : public PBlobChild
 {
   friend class nsIContentChild;
 
   class RemoteBlob;
   friend class RemoteBlob;
 
-  nsIDOMBlob* mBlob;
+  DOMFile* mBlob;
   RemoteBlob* mRemoteBlob;
   nsRefPtr<nsIContentChild> mStrongManager;
 
   bool mOwnsBlob;
   bool mBlobIsFile;
 
 public:
   // This create function is called on the sending side.
   static BlobChild*
-  Create(nsIContentChild* aManager, nsIDOMBlob* aBlob)
+  Create(nsIContentChild* aManager, DOMFile* aBlob)
   {
     return new BlobChild(aManager, aBlob);
   }
 
   // Get the blob associated with this actor. This may always be called on the
   // sending side. It may also be called on the receiving side unless this is a
   // "mystery" blob that has not yet received a SetMysteryBlobInfo() call.
-  already_AddRefed<nsIDOMBlob>
+  already_AddRefed<DOMFile>
   GetBlob();
 
   // Use this for files.
   bool
   SetMysteryBlobInfo(const nsString& aName,
                      const nsString& aContentType,
                      uint64_t aLength,
                      uint64_t aLastModifiedDate);
@@ -62,17 +62,17 @@ public:
   // Use this for non-file blobs.
   bool
   SetMysteryBlobInfo(const nsString& aContentType, uint64_t aLength);
 
   nsIContentChild* Manager();
 
 private:
   // This constructor is called on the sending side.
-  BlobChild(nsIContentChild* aManager, nsIDOMBlob* aBlob);
+  BlobChild(nsIContentChild* aManager, DOMFile* aBlob);
 
   // This constructor is called on the receiving side.
   BlobChild(nsIContentChild* aManager, const ChildBlobConstructorParams& aParams);
 
   // Only destroyed by ContentChild.
   ~BlobChild();
 
   // This create function is called on the receiving side by ContentChild.
@@ -108,17 +108,17 @@ class BlobParent MOZ_FINAL
   friend class nsIContentParent;
 
   class OpenStreamRunnable;
   friend class OpenStreamRunnable;
 
   class RemoteBlob;
   friend class RemoteBlob;
 
-  nsIDOMBlob* mBlob;
+  DOMFile* mBlob;
   RemoteBlob* mRemoteBlob;
   nsRefPtr<nsIContentParent> mStrongManager;
 
   // nsIInputStreams backed by files must ensure that the files are actually
   // opened and closed on a background thread before we can send their file
   // handles across to the child. The child process could crash during this
   // process so we need to make sure we cancel the intended response in such a
   // case. We do that by holding an array of nsRevocableEventPtr. If the child
@@ -127,41 +127,41 @@ class BlobParent MOZ_FINAL
   nsTArray<nsRevocableEventPtr<OpenStreamRunnable>> mOpenStreamRunnables;
 
   bool mOwnsBlob;
   bool mBlobIsFile;
 
 public:
   // This create function is called on the sending side.
   static BlobParent*
-  Create(nsIContentParent* aManager, nsIDOMBlob* aBlob)
+  Create(nsIContentParent* aManager, DOMFile* aBlob)
   {
     return new BlobParent(aManager, aBlob);
   }
 
   // Get the blob associated with this actor. This may always be called on the
   // sending side. It may also be called on the receiving side unless this is a
   // "mystery" blob that has not yet received a SetMysteryBlobInfo() call.
-  already_AddRefed<nsIDOMBlob>
+  already_AddRefed<DOMFile>
   GetBlob();
 
   // Use this for files.
   bool
   SetMysteryBlobInfo(const nsString& aName, const nsString& aContentType,
                      uint64_t aLength, uint64_t aLastModifiedDate);
 
   // Use this for non-file blobs.
   bool
   SetMysteryBlobInfo(const nsString& aContentType, uint64_t aLength);
 
   nsIContentParent* Manager();
 
 private:
   // This constructor is called on the sending side.
-  BlobParent(nsIContentParent* aManager, nsIDOMBlob* aBlob);
+  BlobParent(nsIContentParent* aManager, DOMFile* aBlob);
 
   // This constructor is called on the receiving side.
   BlobParent(nsIContentParent* aManager,
              const ParentBlobConstructorParams& aParams);
 
   ~BlobParent();
 
   // This create function is called on the receiving side by ContentParent.
diff --git a/dom/ipc/FilePickerParent.cpp b/dom/ipc/FilePickerParent.cpp
--- a/dom/ipc/FilePickerParent.cpp
+++ b/dom/ipc/FilePickerParent.cpp
@@ -112,17 +112,18 @@ FilePickerParent::FileSizeAndDateRunnabl
 
 void
 FilePickerParent::SendFiles(const nsCOMArray<nsIDOMFile>& aDomfiles)
 {
   nsIContentParent* parent = static_cast<TabParent*>(Manager())->Manager();
   InfallibleTArray<PBlobParent*> files;
 
   for (unsigned i = 0; i < aDomfiles.Length(); i++) {
-    BlobParent* blob = parent->GetOrCreateActorForBlob(aDomfiles[i]);
+    BlobParent* blob = parent->GetOrCreateActorForBlob(
+      static_cast<DOMFile*>(aDomfiles[i]));
     if (blob) {
       files.AppendElement(blob);
     }
   }
 
   InputFiles infiles;
   infiles.filesParent().SwapElements(files);
   unused << Send__delete__(this, infiles, mResult);
diff --git a/dom/ipc/StructuredCloneUtils.cpp b/dom/ipc/StructuredCloneUtils.cpp
--- a/dom/ipc/StructuredCloneUtils.cpp
+++ b/dom/ipc/StructuredCloneUtils.cpp
@@ -1,21 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* vim: set sw=4 ts=8 et tw=80 : */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "StructuredCloneUtils.h"
 
-#include "nsIDOMFile.h"
 #include "nsIDOMDOMException.h"
 #include "nsIMutable.h"
 #include "nsIXPConnect.h"
 
+#include "nsDOMFile.h"
 #include "nsContentUtils.h"
 #include "nsJSEnvironment.h"
 #include "MainThreadUtils.h"
 #include "StructuredCloneTags.h"
 #include "jsapi.h"
 
 using namespace mozilla::dom;
 
@@ -33,117 +33,60 @@ Read(JSContext* aCx, JSStructuredCloneRe
      uint32_t aData, void* aClosure)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aClosure);
 
   StructuredCloneClosure* closure =
     static_cast<StructuredCloneClosure*>(aClosure);
 
-  if (aTag == SCTAG_DOM_FILE) {
+  if (aTag == SCTAG_DOM_BLOB) {
     MOZ_ASSERT(aData < closure->mBlobs.Length());
-
-    nsCOMPtr<nsIDOMFile> file = do_QueryInterface(closure->mBlobs[aData]);
-    MOZ_ASSERT(file);
+    nsRefPtr<DOMFile> blob = closure->mBlobs[aData];
 
 #ifdef DEBUG
     {
       // File should not be mutable.
-      nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
       bool isMutable;
-      MOZ_ASSERT(NS_SUCCEEDED(mutableFile->GetMutable(&isMutable)));
+      MOZ_ASSERT(NS_SUCCEEDED(blob->GetMutable(&isMutable)));
       MOZ_ASSERT(!isMutable);
     }
 #endif
 
-    JS::Rooted<JS::Value> wrappedFile(aCx);
-    nsresult rv = nsContentUtils::WrapNative(aCx, file, &NS_GET_IID(nsIDOMFile),
-                                             &wrappedFile);
-    if (NS_FAILED(rv)) {
+    JS::Rooted<JSObject*> wrappedBlob(aCx, blob->WrapObject(aCx));
+    if (!wrappedBlob || !JS_WrapObject(aCx, &wrappedBlob)) {
       Error(aCx, nsIDOMDOMException::DATA_CLONE_ERR);
       return nullptr;
     }
 
-    return &wrappedFile.toObject();
-  }
-
-  if (aTag == SCTAG_DOM_BLOB) {
-    MOZ_ASSERT(aData < closure->mBlobs.Length());
-
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(closure->mBlobs[aData]);
-    MOZ_ASSERT(blob);
-
-#ifdef DEBUG
-    {
-      // Blob should not be mutable.
-      nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
-      bool isMutable;
-      MOZ_ASSERT(NS_SUCCEEDED(mutableBlob->GetMutable(&isMutable)));
-      MOZ_ASSERT(!isMutable);
-    }
-#endif
-
-    JS::Rooted<JS::Value> wrappedBlob(aCx);
-    nsresult rv = nsContentUtils::WrapNative(aCx, blob, &NS_GET_IID(nsIDOMBlob),
-                                             &wrappedBlob);
-    if (NS_FAILED(rv)) {
-      Error(aCx, nsIDOMDOMException::DATA_CLONE_ERR);
-      return nullptr;
-    }
-
-    return &wrappedBlob.toObject();
+    return wrappedBlob;
   }
 
   return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nullptr);
 }
 
 bool
 Write(JSContext* aCx, JSStructuredCloneWriter* aWriter,
       JS::Handle<JSObject*> aObj, void* aClosure)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aClosure);
 
   StructuredCloneClosure* closure =
     static_cast<StructuredCloneClosure*>(aClosure);
 
-  // See if this is a wrapped native.
-  nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
-  nsContentUtils::XPConnect()->
-    GetWrappedNativeOfJSObject(aCx, aObj, getter_AddRefs(wrappedNative));
-
-  if (wrappedNative) {
-    // Get the raw nsISupports out of it.
-    nsISupports* wrappedObject = wrappedNative->Native();
-    MOZ_ASSERT(wrappedObject);
-
-    // See if the wrapped native is a nsIDOMFile.
-    nsCOMPtr<nsIDOMFile> file = do_QueryInterface(wrappedObject);
-    if (file) {
-      nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
-      if (mutableFile &&
-          NS_SUCCEEDED(mutableFile->SetMutable(false)) &&
-          JS_WriteUint32Pair(aWriter, SCTAG_DOM_FILE,
-                             closure->mBlobs.Length())) {
-        closure->mBlobs.AppendElement(file);
-        return true;
-      }
-    }
-
-    // See if the wrapped native is a nsIDOMBlob.
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(wrappedObject);
-    if (blob) {
-      nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
-      if (mutableBlob &&
-          NS_SUCCEEDED(mutableBlob->SetMutable(false)) &&
-          JS_WriteUint32Pair(aWriter, SCTAG_DOM_BLOB,
-                             closure->mBlobs.Length())) {
-        closure->mBlobs.AppendElement(blob);
-        return true;
-      }
+  // See if the wrapped native is a DOMFile/Blob.
+  {
+    DOMFile* blob = nullptr;
+    if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, aObj, blob)) &&
+        NS_SUCCEEDED(blob->SetMutable(false)) &&
+        JS_WriteUint32Pair(aWriter, SCTAG_DOM_BLOB,
+                           closure->mBlobs.Length())) {
+      closure->mBlobs.AppendElement(blob);
+      return true;
     }
   }
 
   return NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nullptr);
 }
 
 JSStructuredCloneCallbacks gCallbacks = {
   Read,
diff --git a/dom/ipc/StructuredCloneUtils.h b/dom/ipc/StructuredCloneUtils.h
--- a/dom/ipc/StructuredCloneUtils.h
+++ b/dom/ipc/StructuredCloneUtils.h
@@ -4,30 +4,30 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_StructuredCloneUtils_h
 #define mozilla_dom_StructuredCloneUtils_h
 
 #include "nsCOMPtr.h"
 #include "nsTArray.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 
 #include "js/StructuredClone.h"
 
 namespace mozilla {
 
 struct SerializedStructuredCloneBuffer;
 
 namespace dom {
 
 struct
 StructuredCloneClosure
 {
-  nsTArray<nsCOMPtr<nsIDOMBlob> > mBlobs;
+  nsTArray<nsRefPtr<DOMFile>> mBlobs;
 };
 
 struct
 StructuredCloneData
 {
   StructuredCloneData() : mData(nullptr), mDataLength(0) {}
   uint64_t* mData;
   size_t mDataLength;
diff --git a/dom/ipc/nsIContentChild.cpp b/dom/ipc/nsIContentChild.cpp
--- a/dom/ipc/nsIContentChild.cpp
+++ b/dom/ipc/nsIContentChild.cpp
@@ -90,48 +90,46 @@ nsIContentChild::AllocPBlobChild(const B
 bool
 nsIContentChild::DeallocPBlobChild(PBlobChild* aActor)
 {
   delete aActor;
   return true;
 }
 
 BlobChild*
-nsIContentChild::GetOrCreateActorForBlob(nsIDOMBlob* aBlob)
+nsIContentChild::GetOrCreateActorForBlob(DOMFile* aBlob)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aBlob);
 
   // If the blob represents a remote blob then we can simply pass its actor back
   // here.
-  const auto* domFile = static_cast<DOMFile*>(aBlob);
-  nsCOMPtr<nsIRemoteBlob> remoteBlob = do_QueryInterface(domFile->Impl());
+  nsCOMPtr<nsIRemoteBlob> remoteBlob = do_QueryInterface(aBlob->Impl());
   if (remoteBlob) {
     BlobChild* actor =
       static_cast<BlobChild*>(
         static_cast<PBlobChild*>(remoteBlob->GetPBlob()));
     MOZ_ASSERT(actor);
     if (actor->Manager() == this) {
       return actor;
     }
   }
 
   // All blobs shared between processes must be immutable.
-  nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(aBlob);
-  if (!mutableBlob || NS_FAILED(mutableBlob->SetMutable(false))) {
+  if (NS_FAILED(aBlob->SetMutable(false))) {
     NS_WARNING("Failed to make blob immutable!");
     return nullptr;
   }
 
 #ifdef DEBUG
   {
     // XXX This is only safe so long as all blob implementations in our tree
     //     inherit DOMFileImplBase. If that ever changes then this will need to
     //     grow a real interface or something.
-    const auto* blob = static_cast<DOMFileImplBase*>(domFile->Impl());
+    const auto* blob = static_cast<DOMFileImplBase*>(aBlob->Impl());
 
     MOZ_ASSERT(!blob->IsSizeUnknown());
     MOZ_ASSERT(!blob->IsDateUnknown());
   }
 #endif
 
   ParentBlobConstructorParams params;
 
@@ -150,24 +148,23 @@ nsIContentChild::GetOrCreateActorForBlob
   InputStreamParams inputStreamParams;
   nsTArray<mozilla::ipc::FileDescriptor> fds;
   SerializeInputStream(stream, inputStreamParams, fds);
 
   MOZ_ASSERT(fds.IsEmpty());
 
   params.optionalInputStreamParams() = inputStreamParams;
 
-  nsCOMPtr<nsIDOMFile> file = do_QueryInterface(aBlob);
-  if (file) {
+  if (aBlob->IsFile()) {
     FileBlobConstructorParams fileParams;
 
-    rv = file->GetName(fileParams.name());
+    rv = aBlob->GetName(fileParams.name());
     NS_ENSURE_SUCCESS(rv, nullptr);
 
-    rv = file->GetMozLastModifiedDate(&fileParams.modDate());
+    rv = aBlob->GetMozLastModifiedDate(&fileParams.modDate());
     NS_ENSURE_SUCCESS(rv, nullptr);
 
     fileParams.contentType() = contentType;
     fileParams.length() = length;
 
     params.blobParams() = fileParams;
   } else {
     NormalBlobConstructorParams blobParams;
diff --git a/dom/ipc/nsIContentChild.h b/dom/ipc/nsIContentChild.h
--- a/dom/ipc/nsIContentChild.h
+++ b/dom/ipc/nsIContentChild.h
@@ -25,24 +25,25 @@ namespace mozilla {
 
 namespace jsipc {
 class PJavaScriptChild;
 class JavaScriptChild;
 class CpowEntry;
 } // jsipc
 
 namespace dom {
+class DOMFile;
 class IPCTabContext;
 
 class nsIContentChild : public nsISupports
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENTCHILD_IID)
 
-  BlobChild* GetOrCreateActorForBlob(nsIDOMBlob* aBlob);
+  BlobChild* GetOrCreateActorForBlob(DOMFile* aBlob);
 
   virtual PBlobChild*
   SendPBlobConstructor(PBlobChild* aActor,
                        const BlobConstructorParams& params) = 0;
   virtual bool
   SendPBrowserConstructor(PBrowserChild* aActor,
                           const IPCTabContext& aContext,
                           const uint32_t& aChromeFlags,
diff --git a/dom/ipc/nsIContentParent.cpp b/dom/ipc/nsIContentParent.cpp
--- a/dom/ipc/nsIContentParent.cpp
+++ b/dom/ipc/nsIContentParent.cpp
@@ -146,47 +146,45 @@ nsIContentParent::AllocPBlobParent(const
 bool
 nsIContentParent::DeallocPBlobParent(PBlobParent* aActor)
 {
   delete aActor;
   return true;
 }
 
 BlobParent*
-nsIContentParent::GetOrCreateActorForBlob(nsIDOMBlob* aBlob)
+nsIContentParent::GetOrCreateActorForBlob(DOMFile* aBlob)
 {
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aBlob);
 
   // If the blob represents a remote blob for this ContentParent then we can
   // simply pass its actor back here.
-  const auto* domFile = static_cast<DOMFile*>(aBlob);
-  nsCOMPtr<nsIRemoteBlob> remoteBlob = do_QueryInterface(domFile->Impl());
+  nsCOMPtr<nsIRemoteBlob> remoteBlob = do_QueryInterface(aBlob->Impl());
   if (remoteBlob) {
     if (BlobParent* actor = static_cast<BlobParent*>(
           static_cast<PBlobParent*>(remoteBlob->GetPBlob()))) {
       MOZ_ASSERT(actor);
 
       if (actor->Manager() == this) {
         return actor;
       }
     }
   }
 
   // All blobs shared between processes must be immutable.
-  nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(aBlob);
-  if (!mutableBlob || NS_FAILED(mutableBlob->SetMutable(false))) {
+  if (NS_FAILED(aBlob->SetMutable(false))) {
     NS_WARNING("Failed to make blob immutable!");
     return nullptr;
   }
 
   // XXX This is only safe so long as all blob implementations in our tree
   //     inherit DOMFileImplBase. If that ever changes then this will need to grow
   //     a real interface or something.
-  const auto* blob = static_cast<DOMFileImplBase*>(domFile->Impl());
+  const auto* blob = static_cast<DOMFileImplBase*>(aBlob->Impl());
 
   ChildBlobConstructorParams params;
 
   if (blob->IsSizeUnknown() || blob->IsDateUnknown()) {
     // We don't want to call GetSize or GetLastModifiedDate
     // yet since that may stat a file on the main thread
     // here. Instead we'll learn the size lazily from the
     // other process.
@@ -196,24 +194,23 @@ nsIContentParent::GetOrCreateActorForBlo
     nsString contentType;
     nsresult rv = aBlob->GetType(contentType);
     NS_ENSURE_SUCCESS(rv, nullptr);
 
     uint64_t length;
     rv = aBlob->GetSize(&length);
     NS_ENSURE_SUCCESS(rv, nullptr);
 
-    nsCOMPtr<nsIDOMFile> file = do_QueryInterface(aBlob);
-    if (file) {
+    if (aBlob->IsFile()) {
       FileBlobConstructorParams fileParams;
 
-      rv = file->GetMozLastModifiedDate(&fileParams.modDate());
+      rv = aBlob->GetMozLastModifiedDate(&fileParams.modDate());
       NS_ENSURE_SUCCESS(rv, nullptr);
 
-      rv = file->GetName(fileParams.name());
+      rv = aBlob->GetName(fileParams.name());
       NS_ENSURE_SUCCESS(rv, nullptr);
 
       fileParams.contentType() = contentType;
       fileParams.length() = length;
 
       params = fileParams;
     } else {
       NormalBlobConstructorParams blobParams;
diff --git a/dom/ipc/nsIContentParent.h b/dom/ipc/nsIContentParent.h
--- a/dom/ipc/nsIContentParent.h
+++ b/dom/ipc/nsIContentParent.h
@@ -28,25 +28,26 @@ namespace jsipc {
 class PJavaScriptParent;
 class JavaScriptParent;
 class CpowEntry;
 } // namespace jsipc
 
 namespace dom {
 class IPCTabContext;
 class ContentParent;
+class DOMFile;
 
 class nsIContentParent : public nsISupports
                        , public mozilla::dom::ipc::MessageManagerCallback
 {
 public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICONTENTPARENT_IID)
 
   nsIContentParent();
-  BlobParent* GetOrCreateActorForBlob(nsIDOMBlob* aBlob);
+  BlobParent* GetOrCreateActorForBlob(DOMFile* aBlob);
 
   virtual uint64_t ChildID() = 0;
   virtual bool IsForApp() = 0;
   virtual bool IsForBrowser() = 0;
 
   virtual PBlobParent* SendPBlobConstructor(
     PBlobParent* actor,
     const BlobConstructorParams& params) NS_WARN_UNUSED_RESULT = 0;
diff --git a/dom/mobilemessage/src/MmsMessage.cpp b/dom/mobilemessage/src/MmsMessage.cpp
--- a/dom/mobilemessage/src/MmsMessage.cpp
+++ b/dom/mobilemessage/src/MmsMessage.cpp
@@ -388,17 +388,17 @@ MmsMessage::GetData(ContentParent* aPare
     DOMFile* file = static_cast<DOMFile*>(element.content.get());
     if (file->IsDateUnknown()) {
       uint64_t date;
       if (NS_FAILED(file->GetMozLastModifiedDate(&date))) {
         NS_WARNING("Failed to get last modified date!");
       }
     }
 
-    mma.contentParent() = aParent->GetOrCreateActorForBlob(element.content);
+    mma.contentParent() = aParent->GetOrCreateActorForBlob(file);
     if (!mma.contentParent()) {
       return false;
     }
     aData.attachments().AppendElement(mma);
   }
 
   return true;
 }
diff --git a/dom/mobilemessage/src/gonk/WspPduHelper.jsm b/dom/mobilemessage/src/gonk/WspPduHelper.jsm
--- a/dom/mobilemessage/src/gonk/WspPduHelper.jsm
+++ b/dom/mobilemessage/src/gonk/WspPduHelper.jsm
@@ -1,16 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {classes: Cc, interfaces: Ci, utils: Cu, results: Cr} = Components;
 
+Cu.importGlobalProperties(['Blob']);
 Cu.import("resource://gre/modules/wap_consts.js", this);
 
 let DEBUG; // set to true to see debug messages
 
 // Special ASCII characters
 const NUL = 0;
 const CR = 13;
 const LF = 10;
diff --git a/dom/settings/SettingsDB.jsm b/dom/settings/SettingsDB.jsm
--- a/dom/settings/SettingsDB.jsm
+++ b/dom/settings/SettingsDB.jsm
@@ -3,16 +3,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 let Cc = Components.classes;
 let Ci = Components.interfaces;
 let Cu = Components.utils;
 
+Cu.importGlobalProperties(['Blob']);
 Cu.import("resource://gre/modules/Services.jsm");
 
 this.EXPORTED_SYMBOLS = ["SettingsDB", "SETTINGSDB_NAME", "SETTINGSSTORE_NAME"];
 
 const DEBUG = false;
 function debug(s) {
   if (DEBUG) dump("-*- SettingsDB: " + s + "\n");
 }
diff --git a/dom/webidl/Blob.webidl b/dom/webidl/Blob.webidl
--- a/dom/webidl/Blob.webidl
+++ b/dom/webidl/Blob.webidl
@@ -5,32 +5,37 @@
  *
  * The origin of this IDL file is
  * http://dev.w3.org/2006/webapi/FileAPI/#blob
  *
  * Copyright  2012 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C
  * liability, trademark and document use rules apply.
  */
 
-/*
-[Constructor, Constructor((ArrayBuffer or ArrayBufferView or Blob or DOMString)[] blobParts, optional BlobPropertyBag options)] 
+[Constructor,
+ Constructor(sequence<(ArrayBuffer or ArrayBufferView or Blob or DOMString)> blobParts, optional BlobPropertyBag options)]
 interface Blob {
 
+  [GetterThrows]
   readonly attribute unsigned long long size;
+
+  [GetterThrows]
   readonly attribute DOMString type;
 
+  // TODO readonly attribute boolean isClosed;
+
   //slice Blob into byte-ranged chunks
 
-  Blob slice(optional long long start,
-             optional long long end,
+  [Throws]
+  Blob slice([Clamp] optional long long start,
+             [Clamp] optional long long end,
              optional DOMString contentType);
-  void close(); 
 
+  // TODO void close();
 };
-*/
 
 enum EndingTypes{"transparent", "native"};
 
 dictionary BlobPropertyBag {
 
   DOMString type = "";
   EndingTypes endings = "transparent";
 
diff --git a/dom/webidl/BlobEvent.webidl b/dom/webidl/BlobEvent.webidl
--- a/dom/webidl/BlobEvent.webidl
+++ b/dom/webidl/BlobEvent.webidl
@@ -1,14 +1,13 @@
 /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  */
-interface Blob;
 
 [Constructor(DOMString type, optional BlobEventInit eventInitDict)]
 interface BlobEvent : Event
 {
   readonly attribute Blob? data;
 };
 
 dictionary BlobEventInit : EventInit
diff --git a/dom/webidl/Directory.webidl b/dom/webidl/Directory.webidl
--- a/dom/webidl/Directory.webidl
+++ b/dom/webidl/Directory.webidl
@@ -1,16 +1,14 @@
 /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  */
 
-interface File;
-
 /*
  * All functions on Directory that accept DOMString arguments for file or
  * directory names only allow relative path to current directory itself. The
  * path should be a descendent path like "path/to/file.txt" and not contain a
  * segment of ".." or ".". So the paths aren't allowed to walk up the directory
  * tree. For example, paths like "../foo", "..", "/foo/bar" or "foo/../bar" are
  * not allowed.
  */
diff --git a/dom/webidl/File.webidl b/dom/webidl/File.webidl
--- a/dom/webidl/File.webidl
+++ b/dom/webidl/File.webidl
@@ -1,9 +1,41 @@
 /* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/.
  */
 
+interface nsIFile;
+
+[Constructor(sequence<(ArrayBuffer or ArrayBufferView or Blob or DOMString)> fileBits,
+             DOMString fileName, optional FilePropertyBag options),
+
+ // These constructors is just for chrome callee:
+ Constructor(Blob fileBits, optional FilePropertyBag options),
+ Constructor(nsIFile fileBits, optional FilePropertyBag options),
+ Constructor(DOMString fileBits, optional FilePropertyBag options)]
+interface File : Blob {
+
+  readonly attribute DOMString name;
+
+  [GetterThrows]
+  readonly attribute long long lastModified;
+
+};
+
 dictionary FilePropertyBag : BlobPropertyBag {
-  DOMString name = "";
+
+      DOMString name = "";
+      long long lastModified;
+
 };
+
+// Mozilla extensions
+partial interface File {
+
+  [GetterThrows]
+  readonly attribute Date lastModifiedDate;
+
+  [GetterThrows]
+  readonly attribute DOMString mozFullPath;
+
+};
diff --git a/dom/webidl/FileList.webidl b/dom/webidl/FileList.webidl
--- a/dom/webidl/FileList.webidl
+++ b/dom/webidl/FileList.webidl
@@ -5,14 +5,12 @@
  *
  * The origin of this IDL file is
  * http://dev.w3.org/2006/webapi/FileAPI/
  *
  * Copyright  2012 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C
  * liability, trademark and document use rules apply.
  */
 
-interface File;
-
 interface FileList {
   getter File? item(unsigned long index);
   readonly attribute unsigned long length;
 };
diff --git a/dom/webidl/FileReaderSync.webidl b/dom/webidl/FileReaderSync.webidl
--- a/dom/webidl/FileReaderSync.webidl
+++ b/dom/webidl/FileReaderSync.webidl
@@ -5,18 +5,16 @@
  *
  * The origin of this IDL file is
  * http://dev.w3.org/2006/webapi/FileAPI/
  *
  * Copyright  2012 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C
  * liability, trademark and document use rules apply.
  */
 
-interface Blob;
-
 [Constructor]
 interface FileReaderSync {
 
   // Synchronously return strings
 
   [Throws]
   ArrayBuffer readAsArrayBuffer(Blob blob);
   [Throws]
diff --git a/dom/webidl/HTMLCanvasElement.webidl b/dom/webidl/HTMLCanvasElement.webidl
--- a/dom/webidl/HTMLCanvasElement.webidl
+++ b/dom/webidl/HTMLCanvasElement.webidl
@@ -5,17 +5,16 @@
  *
  * The origin of this IDL file is
  * http://www.whatwg.org/specs/web-apps/current-work/#the-canvas-element
  *  Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and
  * Opera Software ASA. You are granted a license to use, reproduce
  * and create derivative works of this document.
  */
 
-interface Blob;
 interface nsIInputStreamCallback;
 interface nsISupports;
 interface Variant;
 
 interface HTMLCanvasElement : HTMLElement {
   [Pure, SetterThrows]
            attribute unsigned long width;
   [Pure, SetterThrows]
diff --git a/dom/webidl/XMLHttpRequest.webidl b/dom/webidl/XMLHttpRequest.webidl
--- a/dom/webidl/XMLHttpRequest.webidl
+++ b/dom/webidl/XMLHttpRequest.webidl
@@ -5,17 +5,16 @@
  *
  * The origin of this IDL file is
  * www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/
  *
  * Copyright  2012 W3C (MIT, ERCIM, Keio), All Rights Reserved. W3C
  * liability, trademark and document use rules apply.
  */
 
-interface Blob;
 interface InputStream;
 interface MozChannel;
 interface IID;
 
 enum XMLHttpRequestResponseType {
   "",
   "arraybuffer",
   "blob",
diff --git a/dom/workers/File.cpp b/dom/workers/File.cpp
deleted file mode 100644
--- a/dom/workers/File.cpp
+++ /dev/null
@@ -1,503 +0,0 @@
-/* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "File.h"
-
-#include "nsDOMFile.h"
-#include "nsDOMBlobBuilder.h"
-#include "nsError.h"
-
-#include "jsapi.h"
-#include "jsfriendapi.h"
-#include "nsCOMPtr.h"
-#include "nsJSUtils.h"
-#include "nsString.h"
-
-#include "mozilla/dom/Exceptions.h"
-#include "WorkerInlines.h"
-#include "WorkerPrivate.h"
-
-USING_WORKERS_NAMESPACE
-using mozilla::dom::Throw;
-
-namespace {
-
-class Blob
-{
-  // Blob should never be instantiated.
-  Blob();
-  ~Blob();
-
-  static const JSClass sClass;
-  static const JSPropertySpec sProperties[];
-  static const JSFunctionSpec sFunctions[];
-
-public:
-  static JSObject*
-  InitClass(JSContext* aCx, JS::Handle<JSObject*> aObj)
-  {
-    return JS_InitClass(aCx, aObj, JS::NullPtr(), &sClass, Construct, 0,
-                        sProperties, sFunctions, nullptr, nullptr);
-  }
-
-  static JSObject*
-  Create(JSContext* aCx, nsIDOMBlob* aBlob)
-  {
-    MOZ_ASSERT(SameCOMIdentity(static_cast<nsISupports*>(aBlob), aBlob));
-
-    JSObject* obj = JS_NewObject(aCx, &sClass, JS::NullPtr(), JS::NullPtr());
-    if (obj) {
-      JS_SetPrivate(obj, aBlob);
-      NS_ADDREF(aBlob);
-    }
-    return obj;
-  }
-
-  static nsIDOMBlob*
-  GetPrivate(JSObject* aObj);
-
-private:
-  static nsIDOMBlob*
-  GetInstancePrivate(JSContext* aCx, JS::Handle<JSObject*> aObj, const char* aFunctionName)
-  {
-    nsIDOMBlob* blob = GetPrivate(aObj);
-    if (blob) {
-      return blob;
-    }
-
-    JS_ReportErrorNumber(aCx, js_GetErrorMessage, nullptr,
-                         JSMSG_INCOMPATIBLE_PROTO, sClass.name, aFunctionName,
-                         JS_GetClass(aObj)->name);
-    return nullptr;
-  }
-
-  static nsIDOMBlob*
-  Unwrap(JSContext* aCx, JSObject* aObj)
-  {
-    return GetPrivate(aObj);
-  }
-
-  static bool
-  Construct(JSContext* aCx, unsigned aArgc, jsval* aVp)
-  {
-    JS::CallArgs args = CallArgsFromVp(aArgc, aVp);
-
-    nsRefPtr<DOMMultipartFileImpl> fileImpl = new DOMMultipartFileImpl();
-    nsRefPtr<mozilla::dom::DOMFile> file = new mozilla::dom::DOMFile(fileImpl);
-
-    nsresult rv = fileImpl->InitBlob(aCx, args.length(), args.array(), Unwrap);
-    if (NS_FAILED(rv)) {
-      return Throw(aCx, rv);
-    }
-
-    JSObject* obj = file::CreateBlob(aCx, file);
-    if (!obj) {
-      return false;
-    }
-
-    args.rval().setObject(*obj);
-    return true;
-  }
-
-  static void
-  Finalize(JSFreeOp* aFop, JSObject* aObj)
-  {
-    MOZ_ASSERT(JS_GetClass(aObj) == &sClass);
-
-    nsIDOMBlob* blob = GetPrivate(aObj);
-    NS_IF_RELEASE(blob);
-  }
-
-  static bool
-  IsBlob(JS::Handle<JS::Value> v)
-  {
-    return v.isObject() && GetPrivate(&v.toObject()) != nullptr;
-  }
-
-  static bool
-  GetSizeImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMBlob* blob = GetInstancePrivate(aCx, obj, "size");
-    MOZ_ASSERT(blob);
-
-    uint64_t size;
-    if (NS_FAILED(blob->GetSize(&size))) {
-      return Throw(aCx, NS_ERROR_DOM_FILE_NOT_READABLE_ERR);
-    }
-
-    aArgs.rval().setNumber(double(size));
-    return true;
-  }
-
-  static bool
-  GetSize(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsBlob, GetSizeImpl>(aCx, args);
-  }
-
-  static bool
-  GetTypeImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMBlob* blob = GetInstancePrivate(aCx, obj, "type");
-    MOZ_ASSERT(blob);
-
-    nsString type;
-    if (NS_FAILED(blob->GetType(type))) {
-      return Throw(aCx, NS_ERROR_DOM_FILE_NOT_READABLE_ERR);
-    }
-
-    JSString* jsType = JS_NewUCStringCopyN(aCx, type.get(), type.Length());
-    if (!jsType) {
-      return false;
-    }
-
-    aArgs.rval().setString(jsType);
-    return true;
-  }
-
-  static bool
-  GetType(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsBlob, GetTypeImpl>(aCx, args);
-  }
-
-  static bool
-  Slice(JSContext* aCx, unsigned aArgc, jsval* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-
-    JS::Rooted<JSObject*> obj(aCx, args.thisv().toObjectOrNull());
-    if (!obj) {
-      return false;
-    }
-
-    nsIDOMBlob* blob = GetInstancePrivate(aCx, obj, "slice");
-    if (!blob) {
-      return false;
-    }
-
-    double start = 0, end = 0;
-    JS::Rooted<JSString*> jsContentType(aCx, JS_GetEmptyString(JS_GetRuntime(aCx)));
-    if (!JS_ConvertArguments(aCx, args, "/IIS", &start,
-                             &end, jsContentType.address())) {
-      return false;
-    }
-
-    nsAutoJSString contentType;
-    if (!contentType.init(aCx, jsContentType)) {
-      return false;
-    }
-
-    uint8_t optionalArgc = aArgc;
-    nsCOMPtr<nsIDOMBlob> rtnBlob;
-    if (NS_FAILED(blob->Slice(static_cast<uint64_t>(start),
-                              static_cast<uint64_t>(end),
-                              contentType, optionalArgc,
-                              getter_AddRefs(rtnBlob)))) {
-      return Throw(aCx, NS_ERROR_DOM_FILE_NOT_READABLE_ERR);
-    }
-
-    JSObject* rtnObj = file::CreateBlob(aCx, rtnBlob);
-    if (!rtnObj) {
-      return false;
-    }
-
-    args.rval().setObject(*rtnObj);
-    return true;
-  }
-};
-
-const JSClass Blob::sClass = {
-  "Blob",
-  JSCLASS_HAS_PRIVATE,
-  JS_PropertyStub, JS_DeletePropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
-  JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, Finalize
-};
-
-const JSPropertySpec Blob::sProperties[] = {
-  JS_PSGS("size", GetSize, GetterOnlyJSNative, JSPROP_ENUMERATE),
-  JS_PSGS("type", GetType, GetterOnlyJSNative, JSPROP_ENUMERATE),
-  JS_PS_END
-};
-
-const JSFunctionSpec Blob::sFunctions[] = {
-  JS_FN("slice", Slice, 1, JSPROP_ENUMERATE),
-  JS_FS_END
-};
-
-class File : public Blob
-{
-  // File should never be instantiated.
-  File();
-  ~File();
-
-  static const JSClass sClass;
-  static const JSPropertySpec sProperties[];
-
-public:
-  static JSObject*
-  InitClass(JSContext* aCx, JS::Handle<JSObject*> aObj, JS::Handle<JSObject*> aParentProto)
-  {
-    return JS_InitClass(aCx, aObj, aParentProto, &sClass, Construct, 0,
-                        sProperties, nullptr, nullptr, nullptr);
-  }
-
-  static JSObject*
-  Create(JSContext* aCx, nsIDOMFile* aFile)
-  {
-    MOZ_ASSERT(SameCOMIdentity(static_cast<nsISupports*>(aFile), aFile));
-
-    JSObject* obj = JS_NewObject(aCx, &sClass, JS::NullPtr(), JS::NullPtr());
-    if (obj) {
-      JS_SetPrivate(obj, aFile);
-      NS_ADDREF(aFile);
-    }
-    return obj;
-  }
-
-  static nsIDOMFile*
-  GetPrivate(JSObject* aObj)
-  {
-    if (aObj) {
-      const JSClass* classPtr = JS_GetClass(aObj);
-      if (classPtr == &sClass) {
-        nsISupports* priv = static_cast<nsISupports*>(JS_GetPrivate(aObj));
-        nsCOMPtr<nsIDOMFile> file = do_QueryInterface(priv);
-        MOZ_ASSERT_IF(priv, file);
-        return file;
-      }
-    }
-    return nullptr;
-  }
-
-  static const JSClass*
-  Class()
-  {
-    return &sClass;
-  }
-
-private:
-  static nsIDOMFile*
-  GetInstancePrivate(JSContext* aCx, JS::Handle<JSObject*> aObj, const char* aFunctionName)
-  {
-    nsIDOMFile* file = GetPrivate(aObj);
-    if (file) {
-      return file;
-    }
-
-    JS_ReportErrorNumber(aCx, js_GetErrorMessage, nullptr,
-                         JSMSG_INCOMPATIBLE_PROTO, sClass.name, aFunctionName,
-                         JS_GetClass(aObj)->name);
-    return nullptr;
-  }
-
-  static bool
-  Construct(JSContext* aCx, unsigned aArgc, jsval* aVp)
-  {
-    JS_ReportErrorNumber(aCx, js_GetErrorMessage, nullptr,
-                         JSMSG_WRONG_CONSTRUCTOR,
-                         sClass.name);
-    return false;
-  }
-
-  static void
-  Finalize(JSFreeOp* aFop, JSObject* aObj)
-  {
-    MOZ_ASSERT(JS_GetClass(aObj) == &sClass);
-
-    nsIDOMFile* file = GetPrivate(aObj);
-    NS_IF_RELEASE(file);
-  }
-
-  static bool
-  IsFile(JS::Handle<JS::Value> v)
-  {
-    return v.isObject() && GetPrivate(&v.toObject()) != nullptr;
-  }
-
-  static bool
-  GetMozFullPathImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMFile* file = GetInstancePrivate(aCx, obj, "mozFullPath");
-    MOZ_ASSERT(file);
-
-    nsString fullPath;
-
-    if (GetWorkerPrivateFromContext(aCx)->UsesSystemPrincipal() &&
-        NS_FAILED(file->GetMozFullPathInternal(fullPath))) {
-      return Throw(aCx, NS_ERROR_DOM_FILE_NOT_READABLE_ERR);
-    }
-
-    JSString* jsFullPath = JS_NewUCStringCopyN(aCx, fullPath.get(),
-                                               fullPath.Length());
-    if (!jsFullPath) {
-      return false;
-    }
-
-    aArgs.rval().setString(jsFullPath);
-    return true;
-  }
-
-  static bool
-  GetMozFullPath(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsFile, GetMozFullPathImpl>(aCx, args);
-  }
-
-  static bool
-  GetNameImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMFile* file = GetInstancePrivate(aCx, obj, "name");
-    MOZ_ASSERT(file);
-
-    nsString name;
-    if (NS_FAILED(file->GetName(name))) {
-      name.Truncate();
-    }
-
-    JSString* jsName = JS_NewUCStringCopyN(aCx, name.get(), name.Length());
-    if (!jsName) {
-      return false;
-    }
-
-    aArgs.rval().setString(jsName);
-    return true;
-  }
-
-  static bool
-  GetName(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsFile, GetNameImpl>(aCx, args);
-  }
-
-  static bool
-  GetPathImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMFile* file = GetInstancePrivate(aCx, obj, "path");
-    MOZ_ASSERT(file);
-
-    nsString path;
-    if (NS_FAILED(file->GetPath(path))) {
-      path.Truncate();
-    }
-
-    JSString* jsPath = JS_NewUCStringCopyN(aCx, path.get(), path.Length());
-    if (!jsPath) {
-      return false;
-    }
-
-    aArgs.rval().setString(jsPath);
-    return true;
-  }
-
-  static bool
-  GetPath(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsFile, GetPathImpl>(aCx, args);
-  }
-
-  static bool
-  GetLastModifiedDateImpl(JSContext* aCx, JS::CallArgs aArgs)
-  {
-    JS::Rooted<JSObject*> obj(aCx, &aArgs.thisv().toObject());
-    nsIDOMFile* file = GetInstancePrivate(aCx, obj, "lastModifiedDate");
-    MOZ_ASSERT(file);
-
-    if (NS_FAILED(file->GetLastModifiedDate(aCx, aArgs.rval()))) {
-      return false;
-    }
-    return true;
-  }
-
-  static bool
-  GetLastModifiedDate(JSContext* aCx, unsigned aArgc, JS::Value* aVp)
-  {
-    JS::CallArgs args = JS::CallArgsFromVp(aArgc, aVp);
-    return JS::CallNonGenericMethod<IsFile, GetLastModifiedDateImpl>(aCx, args);
-  }
-};
-
-const JSClass File::sClass = {
-  "File",
-  JSCLASS_HAS_PRIVATE,
-  JS_PropertyStub, JS_DeletePropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
-  JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, Finalize
-};
-
-const JSPropertySpec File::sProperties[] = {
-  JS_PSGS("name", GetName, GetterOnlyJSNative, JSPROP_ENUMERATE),
-  JS_PSGS("path", GetPath, GetterOnlyJSNative, JSPROP_ENUMERATE),
-  JS_PSGS("lastModifiedDate", GetLastModifiedDate, GetterOnlyJSNative,
-          JSPROP_ENUMERATE),
-  JS_PSGS("mozFullPath", GetMozFullPath, GetterOnlyJSNative, JSPROP_ENUMERATE),
-  JS_PS_END
-};
-
-nsIDOMBlob*
-Blob::GetPrivate(JSObject* aObj)
-{
-  if (aObj) {
-    const JSClass* classPtr = JS_GetClass(aObj);
-    if (classPtr == &sClass || classPtr == File::Class()) {
-      nsISupports* priv = static_cast<nsISupports*>(JS_GetPrivate(aObj));
-      nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(priv);
-      MOZ_ASSERT_IF(priv, blob);
-      return blob;
-    }
-  }
-  return nullptr;
-}
-
-} // anonymous namespace
-
-BEGIN_WORKERS_NAMESPACE
-
-namespace file {
-
-JSObject*
-CreateBlob(JSContext* aCx, nsIDOMBlob* aBlob)
-{
-  return Blob::Create(aCx, aBlob);
-}
-
-bool
-InitClasses(JSContext* aCx, JS::Handle<JSObject*> aGlobal)
-{
-  JS::Rooted<JSObject*> blobProto(aCx, Blob::InitClass(aCx, aGlobal));
-  return blobProto && File::InitClass(aCx, aGlobal, blobProto);
-}
-
-nsIDOMBlob*
-GetDOMBlobFromJSObject(JSObject* aObj)
-{
-  return Blob::GetPrivate(aObj);
-}
-
-JSObject*
-CreateFile(JSContext* aCx, nsIDOMFile* aFile)
-{
-  return File::Create(aCx, aFile);
-}
-
-nsIDOMFile*
-GetDOMFileFromJSObject(JSObject* aObj)
-{
-  return File::GetPrivate(aObj);
-}
-
-} // namespace file
-
-END_WORKERS_NAMESPACE
diff --git a/dom/workers/File.h b/dom/workers/File.h
deleted file mode 100644
--- a/dom/workers/File.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_workers_file_h__
-#define mozilla_dom_workers_file_h__
-
-#include "Workers.h"
-
-class nsIDOMFile;
-class nsIDOMBlob;
-
-BEGIN_WORKERS_NAMESPACE
-
-namespace file {
-
-bool
-InitClasses(JSContext* aCx, JS::Handle<JSObject*> aGlobal);
-
-JSObject*
-CreateBlob(JSContext* aCx, nsIDOMBlob* aBlob);
-
-nsIDOMBlob*
-GetDOMBlobFromJSObject(JSObject* aObj);
-
-JSObject*
-CreateFile(JSContext* aCx, nsIDOMFile* aFile);
-
-nsIDOMFile*
-GetDOMFileFromJSObject(JSObject* aObj);
-
-} // namespace file
-
-END_WORKERS_NAMESPACE
-
-#endif /* mozilla_dom_workers_file_h__ */
diff --git a/dom/workers/FileReaderSync.cpp b/dom/workers/FileReaderSync.cpp
--- a/dom/workers/FileReaderSync.cpp
+++ b/dom/workers/FileReaderSync.cpp
@@ -10,30 +10,30 @@
 #include "mozilla/Base64.h"
 #include "mozilla/dom/EncodingUtils.h"
 #include "nsContentUtils.h"
 #include "mozilla/dom/FileReaderSyncBinding.h"
 #include "nsCExternalHandlerService.h"
 #include "nsComponentManagerUtils.h"
 #include "nsCOMPtr.h"
 #include "nsDOMClassInfoID.h"
+#include "nsDOMFile.h"
 #include "nsError.h"
-#include "nsIDOMFile.h"
 #include "nsIConverterInputStream.h"
 #include "nsIInputStream.h"
 #include "nsISeekableStream.h"
 #include "nsISupportsImpl.h"
 #include "nsNetUtil.h"
 #include "nsServiceManagerUtils.h"
 
-#include "File.h"
 #include "RuntimeService.h"
 
 USING_WORKERS_NAMESPACE
 using namespace mozilla;
+using namespace mozilla::dom;
 using mozilla::dom::Optional;
 using mozilla::dom::GlobalObject;
 
 // static
 already_AddRefed<FileReaderSync>
 FileReaderSync::Constructor(const GlobalObject& aGlobal, ErrorResult& aRv)
 {
   nsRefPtr<FileReaderSync> frs = new FileReaderSync();
@@ -45,28 +45,22 @@ JSObject*
 FileReaderSync::WrapObject(JSContext* aCx)
 {
   return FileReaderSyncBinding_workers::Wrap(aCx, this);
 }
 
 void
 FileReaderSync::ReadAsArrayBuffer(JSContext* aCx,
                                   JS::Handle<JSObject*> aScopeObj,
-                                  JS::Handle<JSObject*> aBlob,
+                                  DOMFile& aBlob,
                                   JS::MutableHandle<JSObject*> aRetval,
                                   ErrorResult& aRv)
 {
-  nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aBlob);
-  if (!blob) {
-    aRv.Throw(NS_ERROR_INVALID_ARG);
-    return;
-  }
-
   uint64_t blobSize;
-  nsresult rv = blob->GetSize(&blobSize);
+  nsresult rv = aBlob.GetSize(&blobSize);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   JS::Rooted<JSObject*> jsArrayBuffer(aCx, JS_NewArrayBuffer(aCx, blobSize));
   if (!jsArrayBuffer) {
     // XXXkhuey we need a way to indicate to the bindings that the call failed
@@ -78,17 +72,17 @@ FileReaderSync::ReadAsArrayBuffer(JSCont
   uint32_t bufferLength = JS_GetArrayBufferByteLength(jsArrayBuffer);
   uint8_t* arrayBuffer = JS_GetStableArrayBufferData(aCx, jsArrayBuffer);
   if (!arrayBuffer) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return;
   }
 
   nsCOMPtr<nsIInputStream> stream;
-  rv = blob->GetInternalStream(getter_AddRefs(stream));
+  rv = aBlob.GetInternalStream(getter_AddRefs(stream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   uint32_t numRead;
   rv = stream->Read((char*)arrayBuffer, bufferLength, &numRead);
   if (NS_FAILED(rv)) {
@@ -96,28 +90,22 @@ FileReaderSync::ReadAsArrayBuffer(JSCont
     return;
   }
   NS_ASSERTION(numRead == bufferLength, "failed to read data");
 
   aRetval.set(jsArrayBuffer);
 }
 
 void
-FileReaderSync::ReadAsBinaryString(JS::Handle<JSObject*> aBlob,
+FileReaderSync::ReadAsBinaryString(DOMFile& aBlob,
                                    nsAString& aResult,
                                    ErrorResult& aRv)
 {
-  nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aBlob);
-  if (!blob) {
-    aRv.Throw(NS_ERROR_INVALID_ARG);
-    return;
-  }
-
   nsCOMPtr<nsIInputStream> stream;
-  nsresult rv = blob->GetInternalStream(getter_AddRefs(stream));
+  nsresult rv = aBlob.GetInternalStream(getter_AddRefs(stream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   uint32_t numRead;
   do {
     char readBuf[4096];
@@ -132,29 +120,23 @@ FileReaderSync::ReadAsBinaryString(JS::H
     if (aResult.Length() - oldLength != numRead) {
       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
       return;
     }
   } while (numRead > 0);
 }
 
 void
-FileReaderSync::ReadAsText(JS::Handle<JSObject*> aBlob,
+FileReaderSync::ReadAsText(DOMFile& aBlob,
                            const Optional<nsAString>& aEncoding,
                            nsAString& aResult,
                            ErrorResult& aRv)
 {
-  nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aBlob);
-  if (!blob) {
-    aRv.Throw(NS_ERROR_INVALID_ARG);
-    return;
-  }
-
   nsCOMPtr<nsIInputStream> stream;
-  nsresult rv = blob->GetInternalStream(getter_AddRefs(stream));
+  nsresult rv = aBlob.GetInternalStream(getter_AddRefs(stream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   nsAutoCString encoding;
   unsigned char sniffBuf[3] = { 0, 0, 0 };
   uint32_t numRead;
@@ -169,17 +151,17 @@ FileReaderSync::ReadAsText(JS::Handle<JS
   // Standard, which the File API references.
   if (!nsContentUtils::CheckForBOM(sniffBuf, numRead, encoding)) {
     // BOM sniffing failed. Try the API argument.
     if (!aEncoding.WasPassed() ||
         !EncodingUtils::FindEncodingForLabel(aEncoding.Value(),
                                              encoding)) {
       // API argument failed. Try the type property of the blob.
       nsAutoString type16;
-      blob->GetType(type16);
+      aBlob.GetType(type16);
       NS_ConvertUTF16toUTF8 type(type16);
       nsAutoCString specifiedCharset;
       bool haveCharset;
       int32_t charsetStart, charsetEnd;
       NS_ExtractCharsetFromContentType(type,
                                        specifiedCharset,
                                        &haveCharset,
                                        &charsetStart,
@@ -208,47 +190,41 @@ FileReaderSync::ReadAsText(JS::Handle<JS
   rv = ConvertStream(stream, encoding.get(), aResult);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 }
 
 void
-FileReaderSync::ReadAsDataURL(JS::Handle<JSObject*> aBlob, nsAString& aResult,
+FileReaderSync::ReadAsDataURL(DOMFile& aBlob, nsAString& aResult,
                               ErrorResult& aRv)
 {
-  nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aBlob);
-  if (!blob) {
-    aRv.Throw(NS_ERROR_INVALID_ARG);
-    return;
-  }
-
   nsAutoString scratchResult;
   scratchResult.AssignLiteral("data:");
 
   nsString contentType;
-  blob->GetType(contentType);
+  aBlob.GetType(contentType);
 
   if (contentType.IsEmpty()) {
     scratchResult.AppendLiteral("application/octet-stream");
   } else {
     scratchResult.Append(contentType);
   }
   scratchResult.AppendLiteral(";base64,");
 
   nsCOMPtr<nsIInputStream> stream;
-  nsresult rv = blob->GetInternalStream(getter_AddRefs(stream));
+  nsresult rv = aBlob.GetInternalStream(getter_AddRefs(stream));
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   uint64_t size;
-  rv = blob->GetSize(&size);
+  rv = aBlob.GetSize(&size);
   if (NS_FAILED(rv)) {
     aRv.Throw(rv);
     return;
   }
 
   nsCOMPtr<nsIInputStream> bufferedStream;
   rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream), stream, size);
   if (NS_FAILED(rv)) {
diff --git a/dom/workers/FileReaderSync.h b/dom/workers/FileReaderSync.h
--- a/dom/workers/FileReaderSync.h
+++ b/dom/workers/FileReaderSync.h
@@ -11,16 +11,17 @@
 
 class nsIInputStream;
 class nsIDOMBlob;
 
 namespace mozilla {
 class ErrorResult;
 
 namespace dom {
+class DOMFile;
 class GlobalObject;
 template<typename> class Optional;
 }
 }
 
 BEGIN_WORKERS_NAMESPACE
 
 class FileReaderSync MOZ_FINAL
@@ -38,23 +39,19 @@ private:
 
 public:
   static already_AddRefed<FileReaderSync>
   Constructor(const GlobalObject& aGlobal, ErrorResult& aRv);
 
   JSObject* WrapObject(JSContext* aCx);
 
   void ReadAsArrayBuffer(JSContext* aCx, JS::Handle<JSObject*> aScopeObj,
-                         JS::Handle<JSObject*> aBlob,
-                         JS::MutableHandle<JSObject*> aRetval,
+                         DOMFile& aBlob, JS::MutableHandle<JSObject*> aRetval,
                          ErrorResult& aRv);
-  void ReadAsBinaryString(JS::Handle<JSObject*> aBlob, nsAString& aResult,
-                          ErrorResult& aRv);
-  void ReadAsText(JS::Handle<JSObject*> aBlob,
-                  const Optional<nsAString>& aEncoding,
+  void ReadAsBinaryString(DOMFile& aBlob, nsAString& aResult, ErrorResult& aRv);
+  void ReadAsText(DOMFile& aBlob, const Optional<nsAString>& aEncoding,
                   nsAString& aResult, ErrorResult& aRv);
-  void ReadAsDataURL(JS::Handle<JSObject*> aBlob, nsAString& aResult,
-                     ErrorResult& aRv);
+  void ReadAsDataURL(DOMFile& aBlob, nsAString& aResult, ErrorResult& aRv);
 };
 
 END_WORKERS_NAMESPACE
 
 #endif // mozilla_dom_workers_filereadersync_h__
diff --git a/dom/workers/RegisterBindings.cpp b/dom/workers/RegisterBindings.cpp
--- a/dom/workers/RegisterBindings.cpp
+++ b/dom/workers/RegisterBindings.cpp
@@ -1,26 +1,27 @@
 /* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "WorkerPrivate.h"
 #include "ChromeWorkerScope.h"
-#include "File.h"
 #include "RuntimeService.h"
 
 #include "jsapi.h"
 #include "js/OldDebugAPI.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/BlobBinding.h"
 #include "mozilla/dom/ConsoleBinding.h"
 #include "mozilla/dom/DOMExceptionBinding.h"
 #include "mozilla/dom/EventBinding.h"
 #include "mozilla/dom/EventHandlerBinding.h"
 #include "mozilla/dom/EventTargetBinding.h"
+#include "mozilla/dom/FileBinding.h"
 #include "mozilla/dom/FileReaderSyncBinding.h"
 #include "mozilla/dom/HeadersBinding.h"
 #include "mozilla/dom/ImageData.h"
 #include "mozilla/dom/ImageDataBinding.h"
 #include "mozilla/dom/MessageEventBinding.h"
 #include "mozilla/dom/MessagePortBinding.h"
 #include "mozilla/dom/PromiseBinding.h"
 #include "mozilla/dom/TextDecoderBinding.h"
@@ -49,25 +50,22 @@ WorkerPrivate::RegisterBindings(JSContex
   if (IsChromeWorker()) {
     if (!ChromeWorkerBinding::GetConstructorObject(aCx, aGlobal) ||
         !DefineChromeWorkerFunctions(aCx, aGlobal) ||
         !DefineOSFileConstants(aCx, aGlobal)) {
       return false;
     }
   }
 
-  // Init other classes we care about.
-  if (!file::InitClasses(aCx, aGlobal)) {
-    return false;
-  }
-
   // Init other paris-bindings.
-  if (!ConsoleBinding::GetConstructorObject(aCx, aGlobal) ||
+  if (!BlobBinding::GetConstructorObject(aCx, aGlobal) ||
+      !ConsoleBinding::GetConstructorObject(aCx, aGlobal) ||
       !DOMExceptionBinding::GetConstructorObject(aCx, aGlobal) ||
       !EventBinding::GetConstructorObject(aCx, aGlobal) ||
+      !FileBinding::GetConstructorObject(aCx, aGlobal) ||
       !FileReaderSyncBinding_workers::GetConstructorObject(aCx, aGlobal) ||
       (HeadersBinding::ConstructorEnabled(aCx, aGlobal) &&
        !HeadersBinding::GetConstructorObject(aCx, aGlobal)) ||
       !ImageDataBinding::GetConstructorObject(aCx, aGlobal) ||
       !MessageEventBinding::GetConstructorObject(aCx, aGlobal) ||
       !MessagePortBinding::GetConstructorObject(aCx, aGlobal) ||
       !PromiseBinding::GetConstructorObject(aCx, aGlobal) ||
       !TextDecoderBinding::GetConstructorObject(aCx, aGlobal) ||
diff --git a/dom/workers/URL.cpp b/dom/workers/URL.cpp
--- a/dom/workers/URL.cpp
+++ b/dom/workers/URL.cpp
@@ -14,17 +14,16 @@
 #include "mozilla/dom/URLBinding.h"
 #include "mozilla/dom/URLSearchParams.h"
 #include "nsGlobalWindow.h"
 #include "nsHostObjectProtocolHandler.h"
 #include "nsNetCID.h"
 #include "nsServiceManagerUtils.h"
 #include "nsThreadUtils.h"
 
-#include "File.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 
 BEGIN_WORKERS_NAMESPACE
 using mozilla::dom::GlobalObject;
 
 class URLProxy MOZ_FINAL
 {
@@ -841,50 +840,42 @@ URL::SetHash(const nsAString& aHash, Err
 }
 
 // static
 void
 URL::CreateObjectURL(const GlobalObject& aGlobal, JSObject* aBlob,
                      const mozilla::dom::objectURLOptions& aOptions,
                      nsString& aResult, mozilla::ErrorResult& aRv)
 {
+  SetDOMStringToNull(aResult);
+
+  NS_NAMED_LITERAL_STRING(argStr, "Argument 1 of URL.createObjectURL");
+  NS_NAMED_LITERAL_STRING(blobStr, "Blob");
+  aRv.ThrowTypeError(MSG_DOES_NOT_IMPLEMENT_INTERFACE, &argStr, &blobStr);
+}
+
+// static
+void
+URL::CreateObjectURL(const GlobalObject& aGlobal, DOMFile& aBlob,
+                     const mozilla::dom::objectURLOptions& aOptions,
+                     nsString& aResult, mozilla::ErrorResult& aRv)
+{
   JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
-  nsCOMPtr<nsIDOMBlob> blob = file::GetDOMBlobFromJSObject(aBlob);
-  if (!blob) {
-    SetDOMStringToNull(aResult);
-
-    NS_NAMED_LITERAL_STRING(argStr, "Argument 1 of URL.createObjectURL");
-    NS_NAMED_LITERAL_STRING(blobStr, "Blob");
-    aRv.ThrowTypeError(MSG_DOES_NOT_IMPLEMENT_INTERFACE, &argStr, &blobStr);
-    return;
-  }
-
-  DOMFile* domBlob = static_cast<DOMFile*>(blob.get());
-
   nsRefPtr<CreateURLRunnable> runnable =
-    new CreateURLRunnable(workerPrivate, domBlob->Impl(), aOptions, aResult);
+    new CreateURLRunnable(workerPrivate, aBlob.Impl(), aOptions, aResult);
 
   if (!runnable->Dispatch(cx)) {
     JS_ReportPendingException(cx);
   }
 }
 
 // static
 void
-URL::CreateObjectURL(const GlobalObject& aGlobal, JSObject& aBlob,
-                     const mozilla::dom::objectURLOptions& aOptions,
-                     nsString& aResult, mozilla::ErrorResult& aRv)
-{
-  return CreateObjectURL(aGlobal, &aBlob, aOptions, aResult, aRv);
-}
-
-// static
-void
 URL::RevokeObjectURL(const GlobalObject& aGlobal, const nsAString& aUrl)
 {
   JSContext* cx = aGlobal.Context();
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(cx);
 
   nsRefPtr<RevokeURLRunnable> runnable =
     new RevokeURLRunnable(workerPrivate, aUrl);
 
diff --git a/dom/workers/URL.h b/dom/workers/URL.h
--- a/dom/workers/URL.h
+++ b/dom/workers/URL.h
@@ -10,16 +10,17 @@
 #include "Workers.h"
 
 #include "mozilla/ErrorResult.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/dom/URLSearchParams.h"
 
 namespace mozilla {
 namespace dom {
+class DOMFile;
 struct objectURLOptions;
 }
 }
 
 BEGIN_WORKERS_NAMESPACE
 
 class URLProxy;
 
@@ -56,17 +57,17 @@ public:
 
   static void
   CreateObjectURL(const GlobalObject& aGlobal,
                   JSObject* aArg, const objectURLOptions& aOptions,
                   nsString& aResult, ErrorResult& aRv);
 
   static void
   CreateObjectURL(const GlobalObject& aGlobal,
-                  JSObject& aArg, const objectURLOptions& aOptions,
+                  DOMFile& aArg, const objectURLOptions& aOptions,
                   nsString& aResult, ErrorResult& aRv);
 
   static void
   RevokeObjectURL(const GlobalObject& aGlobal, const nsAString& aUrl);
 
   void GetHref(nsString& aHref, ErrorResult& aRv) const;
 
   void SetHref(const nsAString& aHref, ErrorResult& aRv);
diff --git a/dom/workers/WorkerPrivate.cpp b/dom/workers/WorkerPrivate.cpp
--- a/dom/workers/WorkerPrivate.cpp
+++ b/dom/workers/WorkerPrivate.cpp
@@ -67,17 +67,16 @@
 #ifdef ANDROID
 #include <android/log.h>
 #endif
 
 #ifdef DEBUG
 #include "nsThreadManager.h"
 #endif
 
-#include "File.h"
 #include "MessagePort.h"
 #include "Navigator.h"
 #include "Principal.h"
 #include "RuntimeService.h"
 #include "ScriptLoader.h"
 #include "ServiceWorkerManager.h"
 #include "SharedWorker.h"
 #include "WorkerFeature.h"
@@ -292,44 +291,18 @@ LogErrorToConsole(const nsAString& aMess
 struct WorkerStructuredCloneCallbacks
 {
   static JSObject*
   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
        uint32_t aData, void* aClosure)
   {
     JS::Rooted<JSObject*> result(aCx);
 
-    // See if object is a nsIDOMFile pointer.
-    if (aTag == DOMWORKER_SCTAG_FILE) {
-      MOZ_ASSERT(!aData);
-
-      DOMFileImpl* fileImpl;
-      if (JS_ReadBytes(aReader, &fileImpl, sizeof(fileImpl))) {
-        MOZ_ASSERT(fileImpl);
-
-#ifdef DEBUG
-        {
-          // File should not be mutable.
-          bool isMutable;
-          NS_ASSERTION(NS_SUCCEEDED(fileImpl->GetMutable(&isMutable)) &&
-                       !isMutable,
-                       "Only immutable file should be passed to worker");
-        }
-#endif
-
-        {
-          // New scope to protect |result| from a moving GC during ~nsRefPtr.
-          nsRefPtr<DOMFile> file = new DOMFile(fileImpl);
-          result = file::CreateFile(aCx, file);
-        }
-        return result;
-      }
-    }
     // See if object is a nsIDOMBlob pointer.
-    else if (aTag == DOMWORKER_SCTAG_BLOB) {
+    if (aTag == DOMWORKER_SCTAG_BLOB) {
       MOZ_ASSERT(!aData);
 
       DOMFileImpl* blobImpl;
       if (JS_ReadBytes(aReader, &blobImpl, sizeof(blobImpl))) {
         MOZ_ASSERT(blobImpl);
 
 #ifdef DEBUG
         {
@@ -339,17 +312,17 @@ struct WorkerStructuredCloneCallbacks
                        !isMutable,
                        "Only immutable blob should be passed to worker");
         }
 #endif
 
         {
           // New scope to protect |result| from a moving GC during ~nsRefPtr.
           nsRefPtr<DOMFile> blob = new DOMFile(blobImpl);
-          result = file::CreateBlob(aCx, blob);
+          result = blob->WrapObject(aCx);
         }
         return result;
       }
     }
     // See if the object is an ImageData.
     else if (aTag == SCTAG_DOM_IMAGEDATA) {
       MOZ_ASSERT(!aData);
 
@@ -382,34 +355,21 @@ struct WorkerStructuredCloneCallbacks
         JS::Handle<JSObject*> aObj, void* aClosure)
   {
     NS_ASSERTION(aClosure, "Null pointer!");
 
     // We'll stash any nsISupports pointers that need to be AddRef'd here.
     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
 
-    // See if this is a File object.
+    // See if this is a Blob/File object.
     {
-      nsIDOMFile* file = file::GetDOMFileFromJSObject(aObj);
-      if (file) {
-        DOMFileImpl* fileImpl = static_cast<DOMFile*>(file)->Impl();
-        if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
-            JS_WriteBytes(aWriter, &fileImpl, sizeof(fileImpl))) {
-          clonedObjects->AppendElement(fileImpl);
-          return true;
-        }
-      }
-    }
-
-    // See if this is a Blob object.
-    {
-      nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aObj);
-      if (blob) {
-        DOMFileImpl* blobImpl = static_cast<DOMFile*>(blob)->Impl();
+      DOMFile* blob = nullptr;
+      if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, aObj, blob))) {
+        DOMFileImpl* blobImpl = blob->Impl();
         if (blobImpl && NS_SUCCEEDED(blobImpl->SetMutable(false)) &&
             JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
             JS_WriteBytes(aWriter, &blobImpl, sizeof(blobImpl))) {
           clonedObjects->AppendElement(blobImpl);
           return true;
         }
       }
     }
@@ -455,82 +415,39 @@ JSStructuredCloneCallbacks gWorkerStruct
 struct MainThreadWorkerStructuredCloneCallbacks
 {
   static JSObject*
   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32_t aTag,
        uint32_t aData, void* aClosure)
   {
     AssertIsOnMainThread();
 
-    // See if object is a nsIDOMFile pointer.
-    if (aTag == DOMWORKER_SCTAG_FILE) {
-      MOZ_ASSERT(!aData);
-
-      DOMFileImpl* fileImpl;
-      if (JS_ReadBytes(aReader, &fileImpl, sizeof(fileImpl))) {
-        MOZ_ASSERT(fileImpl);
-
-#ifdef DEBUG
-        {
-          // File should not be mutable.
-          bool isMutable;
-          NS_ASSERTION(NS_SUCCEEDED(fileImpl->GetMutable(&isMutable)) &&
-                       !isMutable,
-                       "Only immutable file should be passed to worker");
-        }
-#endif
-
-        nsCOMPtr<nsIDOMFile> file = new DOMFile(fileImpl);
-
-        // nsIDOMFiles should be threadsafe, thus we will use the same instance
-        // on the main thread.
-        JS::Rooted<JS::Value> wrappedFile(aCx);
-        nsresult rv = nsContentUtils::WrapNative(aCx, file,
-                                                 &NS_GET_IID(nsIDOMFile),
-                                                 &wrappedFile);
-        if (NS_FAILED(rv)) {
-          Error(aCx, nsIDOMDOMException::DATA_CLONE_ERR);
-          return nullptr;
-        }
-
-        return &wrappedFile.toObject();
-      }
-    }
-    // See if object is a nsIDOMBlob pointer.
-    else if (aTag == DOMWORKER_SCTAG_BLOB) {
+    // See if object is a Blob/File pointer.
+    if (aTag == DOMWORKER_SCTAG_BLOB) {
       MOZ_ASSERT(!aData);
 
       DOMFileImpl* blobImpl;
       if (JS_ReadBytes(aReader, &blobImpl, sizeof(blobImpl))) {
         MOZ_ASSERT(blobImpl);
 
 #ifdef DEBUG
         {
           // Blob should not be mutable.
           bool isMutable;
           NS_ASSERTION(NS_SUCCEEDED(blobImpl->GetMutable(&isMutable)) &&
                        !isMutable,
                        "Only immutable blob should be passed to worker");
         }
 #endif
 
-        nsCOMPtr<nsIDOMBlob> blob = new DOMFile(blobImpl);
-
-        // nsIDOMBlobs should be threadsafe, thus we will use the same instance
-        // on the main thread.
-        JS::Rooted<JS::Value> wrappedBlob(aCx);
-        nsresult rv = nsContentUtils::WrapNative(aCx, blob,
-                                                 &NS_GET_IID(nsIDOMBlob),
-                                                 &wrappedBlob);
-        if (NS_FAILED(rv)) {
-          Error(aCx, nsIDOMDOMException::DATA_CLONE_ERR);
-          return nullptr;
-        }
-
-        return &wrappedBlob.toObject();
+        nsRefPtr<DOMFile> blob = new DOMFile(blobImpl);
+
+        JS::Rooted<JSObject*> wrappedBlob(aCx);
+        wrappedBlob = blob->WrapObject(aCx);
+        return wrappedBlob;
       }
     }
 
     JS_ClearPendingException(aCx);
     return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nullptr);
   }
 
   static bool
@@ -540,63 +457,28 @@ struct MainThreadWorkerStructuredCloneCa
     AssertIsOnMainThread();
 
     NS_ASSERTION(aClosure, "Null pointer!");
 
     // We'll stash any nsISupports pointers that need to be AddRef'd here.
     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
 
-    // See if this is a wrapped native.
-    nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
-    nsContentUtils::XPConnect()->
-      GetWrappedNativeOfJSObject(aCx, aObj, getter_AddRefs(wrappedNative));
-
-    if (wrappedNative) {
-      // Get the raw nsISupports out of it.
-      nsISupports* wrappedObject = wrappedNative->Native();
-      NS_ASSERTION(wrappedObject, "Null pointer?!");
-
-      // See if the wrapped native is a nsIDOMFile.
-      nsCOMPtr<nsIDOMFile> file = do_QueryInterface(wrappedObject);
-      if (file) {
-        nsRefPtr<DOMFileImpl> fileImpl =
-          static_cast<DOMFile*>(file.get())->Impl();
-
-        if (fileImpl->IsCCed()) {
-          NS_WARNING("Cycle collected file objects are not supported!");
-        } else {
-          if (NS_SUCCEEDED(fileImpl->SetMutable(false))) {
-            DOMFileImpl* fileImplPtr = fileImpl;
-            if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
-                JS_WriteBytes(aWriter, &fileImplPtr, sizeof(fileImplPtr))) {
-              clonedObjects->AppendElement(fileImpl);
-              return true;
-            }
-          }
-        }
-      }
-
-      // See if the wrapped native is a nsIDOMBlob.
-      nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(wrappedObject);
-      if (blob) {
-        nsRefPtr<DOMFileImpl> blobImpl =
-          static_cast<DOMFile*>(blob.get())->Impl();
-
+    // See if this is a Blob/File object.
+    {
+      DOMFile* blob = nullptr;
+      if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, aObj, blob))) {
+        DOMFileImpl* blobImpl = blob->Impl();
         if (blobImpl->IsCCed()) {
           NS_WARNING("Cycle collected blob objects are not supported!");
-        } else {
-          if (NS_SUCCEEDED(blobImpl->SetMutable(false))) {
-            DOMFileImpl* blobImplPtr = blobImpl;
-            if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
-                JS_WriteBytes(aWriter, &blobImplPtr, sizeof(blobImplPtr))) {
-              clonedObjects->AppendElement(blobImpl);
-              return true;
-            }
-          }
+        } else if (NS_SUCCEEDED(blobImpl->SetMutable(false)) &&
+                   JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
+                   JS_WriteBytes(aWriter, &blobImpl, sizeof(blobImpl))) {
+          clonedObjects->AppendElement(blobImpl);
+          return true;
         }
       }
     }
 
     JS_ClearPendingException(aCx);
     return NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nullptr);
   }
 
diff --git a/dom/workers/WorkerPrivate.h b/dom/workers/WorkerPrivate.h
--- a/dom/workers/WorkerPrivate.h
+++ b/dom/workers/WorkerPrivate.h
@@ -1208,18 +1208,17 @@ GetCurrentThreadWorkerPrivate();
 bool
 IsCurrentThreadRunningChromeWorker();
 
 JSContext*
 GetCurrentThreadJSContext();
 
 enum WorkerStructuredDataType
 {
-  DOMWORKER_SCTAG_FILE = SCTAG_DOM_MAX,
-  DOMWORKER_SCTAG_BLOB,
+  DOMWORKER_SCTAG_BLOB = SCTAG_DOM_MAX,
 
   DOMWORKER_SCTAG_END
 };
 
 JSStructuredCloneCallbacks*
 WorkerStructuredCloneCallbacks(bool aMainRuntime);
 
 JSStructuredCloneCallbacks*
diff --git a/dom/workers/XMLHttpRequest.cpp b/dom/workers/XMLHttpRequest.cpp
--- a/dom/workers/XMLHttpRequest.cpp
+++ b/dom/workers/XMLHttpRequest.cpp
@@ -14,20 +14,20 @@
 
 #include "jsfriendapi.h"
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/dom/Exceptions.h"
 #include "mozilla/dom/ProgressEvent.h"
 #include "nsComponentManagerUtils.h"
 #include "nsContentUtils.h"
 #include "nsCxPusher.h"
+#include "nsDOMFile.h"
 #include "nsJSUtils.h"
 #include "nsThreadUtils.h"
 
-#include "File.h"
 #include "RuntimeService.h"
 #include "WorkerPrivate.h"
 #include "WorkerRunnable.h"
 #include "XMLHttpRequestUpload.h"
 
 using namespace mozilla;
 
 using namespace mozilla::dom;
@@ -2113,18 +2113,17 @@ XMLHttpRequest::Send(JS::Handle<JSObject
   }
 
   if (!mProxy) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return;
   }
 
   JS::Rooted<JS::Value> valToClone(cx);
-  if (JS_IsArrayBufferObject(aBody) || JS_IsArrayBufferViewObject(aBody) ||
-      file::GetDOMBlobFromJSObject(aBody)) {
+  if (JS_IsArrayBufferObject(aBody) || JS_IsArrayBufferViewObject(aBody)) {
     valToClone.setObject(*aBody);
   }
   else {
     JS::Rooted<JS::Value> obj(cx, JS::ObjectValue(*aBody));
     JSString* bodyStr = JS::ToString(cx, obj);
     if (!bodyStr) {
       aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
       return;
@@ -2144,16 +2143,55 @@ XMLHttpRequest::Send(JS::Handle<JSObject
     aRv.Throw(NS_ERROR_DOM_DATA_CLONE_ERR);
     return;
   }
 
   SendInternal(EmptyString(), Move(buffer), clonedObjects, aRv);
 }
 
 void
+XMLHttpRequest::Send(DOMFile& aBody, ErrorResult& aRv)
+{
+  JSContext* cx = mWorkerPrivate->GetJSContext();
+  mWorkerPrivate->AssertIsOnWorkerThread();
+
+  if (mCanceled) {
+    aRv.Throw(UNCATCHABLE_EXCEPTION);
+    return;
+  }
+
+  if (!mProxy) {
+    aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
+    return;
+  }
+
+  JS::Rooted<JSObject*> obj(cx, aBody.WrapObject(cx));
+  if (!obj) {
+    aRv.Throw(NS_ERROR_FAILURE);
+    return;
+  }
+
+  JSStructuredCloneCallbacks* callbacks =
+    mWorkerPrivate->IsChromeWorker() ?
+    ChromeWorkerStructuredCloneCallbacks(false) :
+    WorkerStructuredCloneCallbacks(false);
+
+  nsTArray<nsCOMPtr<nsISupports> > clonedObjects;
+  JS::Rooted<JS::Value> value(cx, JS::ObjectValue(*obj));
+
+  JSAutoStructuredCloneBuffer buffer;
+  if (!buffer.write(cx, value, callbacks, &clonedObjects)) {
+    aRv.Throw(NS_ERROR_DOM_DATA_CLONE_ERR);
+    return;
+  }
+
+  SendInternal(EmptyString(), Move(buffer), clonedObjects, aRv);
+}
+
+void
 XMLHttpRequest::Send(const ArrayBuffer& aBody, ErrorResult& aRv)
 {
   JS::Rooted<JSObject*> obj(mWorkerPrivate->GetJSContext(), aBody.Obj());
   return Send(obj, aRv);
 }
 
 void
 XMLHttpRequest::Send(const ArrayBufferView& aBody, ErrorResult& aRv)
diff --git a/dom/workers/XMLHttpRequest.h b/dom/workers/XMLHttpRequest.h
--- a/dom/workers/XMLHttpRequest.h
+++ b/dom/workers/XMLHttpRequest.h
@@ -11,16 +11,22 @@
 // Need this for XMLHttpRequestResponseType.
 #include "mozilla/dom/XMLHttpRequestBinding.h"
 
 #include "mozilla/dom/TypedArray.h"
 
 #include "js/StructuredClone.h"
 #include "nsXMLHttpRequest.h"
 
+namespace mozilla {
+namespace dom {
+class DOMFile;
+}
+}
+
 BEGIN_WORKERS_NAMESPACE
 
 class Proxy;
 class XMLHttpRequestUpload;
 class WorkerPrivate;
 
 class XMLHttpRequest MOZ_FINAL: public nsXHREventTarget,
                                 public WorkerFeature
@@ -159,16 +165,19 @@ public:
 
   void
   Send(const nsAString& aBody, ErrorResult& aRv);
 
   void
   Send(JS::Handle<JSObject*> aBody, ErrorResult& aRv);
 
   void
+  Send(DOMFile& aBody, ErrorResult& aRv);
+
+  void
   Send(const ArrayBuffer& aBody, ErrorResult& aRv);
 
   void
   Send(const ArrayBufferView& aBody, ErrorResult& aRv);
 
   void
   SendAsBinary(const nsAString& aBody, ErrorResult& aRv);
 
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -32,17 +32,16 @@ EXPORTS.mozilla.dom.workers.bindings += 
     'XMLHttpRequest.h',
     'XMLHttpRequestUpload.h',
 ]
 
 SOURCES += [
     'ChromeWorkerScope.cpp',
     'DataStore.cpp',
     'DataStoreCursor.cpp',
-    'File.cpp',
     'FileReaderSync.cpp',
     'Location.cpp',
     'MessagePort.cpp',
     'Navigator.cpp',
     'Principal.cpp',
     'RegisterBindings.cpp',
     'RuntimeService.cpp',
     'ScriptLoader.cpp',
diff --git a/ipc/glue/InputStreamUtils.cpp b/ipc/glue/InputStreamUtils.cpp
--- a/ipc/glue/InputStreamUtils.cpp
+++ b/ipc/glue/InputStreamUtils.cpp
@@ -5,28 +5,29 @@
 #include "InputStreamUtils.h"
 
 #include "nsIIPCSerializableInputStream.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/ipc/Blob.h"
 #include "nsComponentManagerUtils.h"
 #include "nsDebug.h"
+#include "nsDOMFile.h"
 #include "nsID.h"
-#include "nsIDOMFile.h"
 #include "nsIXULRuntime.h"
 #include "nsMIMEInputStream.h"
 #include "nsMultiplexInputStream.h"
 #include "nsNetCID.h"
 #include "nsStringStream.h"
 #include "nsThreadUtils.h"
 #include "nsXULAppAPI.h"
 
 using mozilla::dom::BlobChild;
 using mozilla::dom::BlobParent;
+using mozilla::dom::DOMFile;
 
 namespace {
 
 NS_DEFINE_CID(kStringInputStreamCID, NS_STRINGINPUTSTREAM_CID);
 NS_DEFINE_CID(kFileInputStreamCID, NS_LOCALFILEINPUTSTREAM_CID);
 NS_DEFINE_CID(kPartialFileInputStreamCID, NS_PARTIALLOCALFILEINPUTSTREAM_CID);
 NS_DEFINE_CID(kBufferedInputStreamCID, NS_BUFFEREDINPUTSTREAM_CID);
 NS_DEFINE_CID(kMIMEInputStreamCID, NS_MIMEINPUTSTREAM_CID);
@@ -106,17 +107,17 @@ DeserializeInputStream(const InputStream
 
     case InputStreamParams::TMultiplexInputStreamParams:
       serializable = do_CreateInstance(kMultiplexInputStreamCID);
       break;
 
     // When the input stream already exists in this process, all we need to do
     // is retrieve the original instead of sending any data over the wire.
     case InputStreamParams::TRemoteInputStreamParams: {
-      nsCOMPtr<nsIDOMBlob> domBlob;
+      nsRefPtr<DOMFile> domBlob;
       const RemoteInputStreamParams& params =
           aParams.get_RemoteInputStreamParams();
 
       domBlob = params.remoteBlobParent() ?
           static_cast<BlobParent*>(params.remoteBlobParent())->GetBlob() :
           static_cast<BlobChild*>(params.remoteBlobChild())->GetBlob();
 
       MOZ_ASSERT(domBlob, "Invalid blob contents");
diff --git a/js/xpconnect/loader/mozJSComponentLoader.cpp b/js/xpconnect/loader/mozJSComponentLoader.cpp
--- a/js/xpconnect/loader/mozJSComponentLoader.cpp
+++ b/js/xpconnect/loader/mozJSComponentLoader.cpp
@@ -141,98 +141,21 @@ Debug(JSContext *cx, unsigned argc, jsva
 {
 #ifdef DEBUG
     return Dump(cx, argc, vp);
 #else
     return true;
 #endif
 }
 
-static bool
-File(JSContext *cx, unsigned argc, Value *vp)
-{
-    CallArgs args = CallArgsFromVp(argc, vp);
-
-    if (args.length() == 0) {
-        XPCThrower::Throw(NS_ERROR_UNEXPECTED, cx);
-        return false;
-    }
-
-    nsCOMPtr<nsISupports> native;
-    nsresult rv = DOMMultipartFileImpl::NewFile(getter_AddRefs(native));
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-
-    nsCOMPtr<nsIJSNativeInitializer> initializer = do_QueryInterface(native);
-    MOZ_ASSERT(initializer);
-
-    rv = initializer->Initialize(nullptr, cx, nullptr, args);
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-
-    nsXPConnect *xpc = nsXPConnect::XPConnect();
-    JSObject *glob = CurrentGlobalOrNull(cx);
-
-    nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
-    rv = xpc->WrapNativeToJSVal(cx, glob, native, nullptr,
-                                &NS_GET_IID(nsISupports),
-                                true, args.rval());
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-    return true;
-}
-
-static bool
-Blob(JSContext *cx, unsigned argc, Value *vp)
-{
-    CallArgs args = CallArgsFromVp(argc, vp);
-
-    nsCOMPtr<nsISupports> native;
-    nsresult rv = DOMMultipartFileImpl::NewBlob(getter_AddRefs(native));
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-
-    nsCOMPtr<nsIJSNativeInitializer> initializer = do_QueryInterface(native);
-    MOZ_ASSERT(initializer);
-
-    rv = initializer->Initialize(nullptr, cx, nullptr, args);
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-
-    nsXPConnect *xpc = nsXPConnect::XPConnect();
-    JSObject *glob = CurrentGlobalOrNull(cx);
-
-    nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
-    rv = xpc->WrapNativeToJSVal(cx, glob, native, nullptr,
-                                &NS_GET_IID(nsISupports),
-                                true, args.rval());
-    if (NS_FAILED(rv)) {
-        XPCThrower::Throw(rv, cx);
-        return false;
-    }
-    return true;
-}
-
 static const JSFunctionSpec gGlobalFun[] = {
     JS_FS("dump",    Dump,   1,0),
     JS_FS("debug",   Debug,  1,0),
     JS_FS("atob",    Atob,   1,0),
     JS_FS("btoa",    Btoa,   1,0),
-    JS_FS("File",    File,   1,JSFUN_CONSTRUCTOR),
-    JS_FS("Blob",    Blob,   2,JSFUN_CONSTRUCTOR),
     JS_FS_END
 };
 
 class MOZ_STACK_CLASS JSCLContextHelper
 {
 public:
     JSCLContextHelper(JSContext* aCx);
     ~JSCLContextHelper();
diff --git a/js/xpconnect/src/ExportHelpers.cpp b/js/xpconnect/src/ExportHelpers.cpp
--- a/js/xpconnect/src/ExportHelpers.cpp
+++ b/js/xpconnect/src/ExportHelpers.cpp
@@ -9,48 +9,51 @@
 #include "AccessCheck.h"
 #include "jsfriendapi.h"
 #include "jsproxy.h"
 #include "jswrapper.h"
 #include "js/StructuredClone.h"
 #include "mozilla/dom/BindingUtils.h"
 #include "nsGlobalWindow.h"
 #include "nsJSUtils.h"
-#include "nsIDOMFile.h"
+#include "nsDOMFile.h"
 #include "nsIDOMFileList.h"
 
 using namespace mozilla;
+using namespace mozilla::dom;
 using namespace JS;
 using namespace js;
 
 namespace xpc {
 
 bool
 IsReflector(JSObject *obj)
 {
     return IS_WN_REFLECTOR(obj) || dom::IsDOMObject(obj);
 }
 
 enum StackScopedCloneTags {
     SCTAG_BASE = JS_SCTAG_USER_MIN,
     SCTAG_REFLECTOR,
+    SCTAG_BLOB,
     SCTAG_FUNCTION
 };
 
 class MOZ_STACK_CLASS StackScopedCloneData {
 public:
     StackScopedCloneData(JSContext *aCx, StackScopedCloneOptions *aOptions)
         : mOptions(aOptions)
         , mReflectors(aCx)
         , mFunctions(aCx)
     {}
 
     StackScopedCloneOptions *mOptions;
     AutoObjectVector mReflectors;
     AutoObjectVector mFunctions;
+    nsTArray<nsRefPtr<DOMFileImpl>> mBlobImpls;
 };
 
 static JSObject *
 StackScopedCloneRead(JSContext *cx, JSStructuredCloneReader *reader, uint32_t tag,
                      uint32_t data, void *closure)
 {
     MOZ_ASSERT(closure, "Null pointer!");
     StackScopedCloneData *cloneData = static_cast<StackScopedCloneData *>(closure);
@@ -81,58 +84,84 @@ StackScopedCloneRead(JSContext *cx, JSSt
           return nullptr;
 
       if (!xpc::NewFunctionForwarder(cx, JSID_VOIDHANDLE, obj, &functionValue))
           return nullptr;
 
       return &functionValue.toObject();
     }
 
+    if (tag == SCTAG_BLOB) {
+        MOZ_ASSERT(!data);
+
+        size_t idx;
+        if (!JS_ReadBytes(reader, &idx, sizeof(size_t)))
+            return nullptr;
+
+        nsRefPtr<DOMFile> blob = new DOMFile(cloneData->mBlobImpls[idx]);
+        RootedObject wrappedObj(cx, blob->WrapObject(cx));
+        if (!wrappedObj || !JS_WrapObject(cx, &wrappedObj))
+            return nullptr;
+
+        return wrappedObj;
+    }
+
     MOZ_ASSERT_UNREACHABLE("Encountered garbage in the clone stream!");
     return nullptr;
 }
 
 // The HTML5 structured cloning algorithm includes a few DOM objects, notably
-// Blob and FileList. That wouldn't in itself be a reason to support them here,
+// FileList. That wouldn't in itself be a reason to support them here,
 // but we've historically supported them for Cu.cloneInto (where we didn't support
 // other reflectors), so we need to continue to do so in the wrapReflectors == false
 // case to maintain compatibility.
 //
-// Blob and FileList clones are supposed to give brand new objects, rather than
+// FileList clones are supposed to give brand new objects, rather than
 // cross-compartment wrappers. For this, our current implementation relies on the
 // fact that these objects are implemented with XPConnect and have one reflector
-// per scope. This will need to be fixed when Blob and File move to WebIDL. See
-// bug 827823 comment 6.
-bool IsBlobOrFileList(JSObject *obj)
+// per scope.
+bool IsFileList(JSObject *obj)
 {
     nsISupports *supports = UnwrapReflectorToISupports(obj);
     if (!supports)
         return false;
-    nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
-    if (blob)
-        return true;
     nsCOMPtr<nsIDOMFileList> fileList = do_QueryInterface(supports);
     if (fileList)
         return true;
     return false;
 }
 
 static bool
 StackScopedCloneWrite(JSContext *cx, JSStructuredCloneWriter *writer,
                       Handle<JSObject *> objArg, void *closure)
 {
     MOZ_ASSERT(closure, "Null pointer!");
     StackScopedCloneData *cloneData = static_cast<StackScopedCloneData *>(closure);
 
+    {
+        DOMFile* blob = nullptr;
+        if (NS_SUCCEEDED(UNWRAP_OBJECT(Blob, objArg, blob))) {
+            DOMFileImpl* blobImpl = blob->Impl();
+            MOZ_ASSERT(blobImpl);
+
+            if (!cloneData->mBlobImpls.AppendElement(blobImpl))
+                return false;
+
+            size_t idx = cloneData->mBlobImpls.Length() - 1;
+            return JS_WriteUint32Pair(writer, SCTAG_BLOB, 0) &&
+                   JS_WriteBytes(writer, &idx, sizeof(size_t));
+        }
+    }
+
     // The SpiderMonkey structured clone machinery does a CheckedUnwrap, but
     // doesn't strip off outer windows. Do that to avoid confusing the reflector
     // detection.
     RootedObject obj(cx, JS_ObjectToInnerObject(cx, objArg));
     if ((cloneData->mOptions->wrapReflectors && IsReflector(obj)) ||
-        IsBlobOrFileList(obj))
+        IsFileList(obj))
     {
         if (!cloneData->mReflectors.append(obj))
             return false;
 
         size_t idx = cloneData->mReflectors.length() - 1;
         if (!JS_WriteUint32Pair(writer, SCTAG_REFLECTOR, 0))
             return false;
         if (!JS_WriteBytes(writer, &idx, sizeof(size_t)))
diff --git a/js/xpconnect/src/Sandbox.cpp b/js/xpconnect/src/Sandbox.cpp
--- a/js/xpconnect/src/Sandbox.cpp
+++ b/js/xpconnect/src/Sandbox.cpp
@@ -25,18 +25,20 @@
 #include "nsPrincipal.h"
 #include "nsXMLHttpRequest.h"
 #include "WrapperFactory.h"
 #include "xpcprivate.h"
 #include "XPCQuickStubs.h"
 #include "XPCWrapper.h"
 #include "XrayWrapper.h"
 #include "mozilla/dom/BindingUtils.h"
+#include "mozilla/dom/BlobBinding.h"
 #include "mozilla/dom/CSSBinding.h"
 #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
+#include "mozilla/dom/FileBinding.h"
 #include "mozilla/dom/PromiseBinding.h"
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/dom/TextDecoderBinding.h"
 #include "mozilla/dom/TextEncoderBinding.h"
 #include "mozilla/dom/URLBinding.h"
 
 using namespace mozilla;
 using namespace JS;
@@ -742,16 +744,20 @@ xpc::GlobalProperties::Parse(JSContext *
         } else if (!strcmp(name.ptr(), "TextDecoder")) {
             TextDecoder = true;
         } else if (!strcmp(name.ptr(), "URL")) {
             URL = true;
         } else if (!strcmp(name.ptr(), "atob")) {
             atob = true;
         } else if (!strcmp(name.ptr(), "btoa")) {
             btoa = true;
+        } else if (!strcmp(name.ptr(), "Blob")) {
+            Blob = true;
+        } else if (!strcmp(name.ptr(), "File")) {
+            File = true;
         } else {
             JS_ReportError(cx, "Unknown property name: %s", name.ptr());
             return false;
         }
     }
     return true;
 }
 
@@ -787,16 +793,24 @@ xpc::GlobalProperties::Define(JSContext 
     if (atob &&
         !JS_DefineFunction(cx, obj, "atob", Atob, 1, 0))
         return false;
 
     if (btoa &&
         !JS_DefineFunction(cx, obj, "btoa", Btoa, 1, 0))
         return false;
 
+    if (Blob &&
+        !dom::BlobBinding::GetConstructorObject(cx, obj))
+        return false;
+
+    if (File &&
+        !dom::FileBinding::GetConstructorObject(cx, obj))
+        return false;
+
     return true;
 }
 
 nsresult
 xpc::CreateSandboxObject(JSContext *cx, MutableHandleValue vp, nsISupports *prinOrSop,
                          SandboxOptions& options)
 {
     // Create the sandbox global object
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -560,94 +560,16 @@ Btoa(JSContext *cx, unsigned argc, Value
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (!args.length())
         return true;
 
   return xpc::Base64Encode(cx, args[0], args.rval());
 }
 
-static bool
-Blob(JSContext *cx, unsigned argc, Value *vp)
-{
-  JS::CallArgs args = CallArgsFromVp(argc, vp);
-
-  nsCOMPtr<nsISupports> native =
-    do_CreateInstance("@mozilla.org/dom/multipart-blob;1");
-  if (!native) {
-    JS_ReportError(cx, "Could not create native object!");
-    return false;
-  }
-
-  nsCOMPtr<nsIJSNativeInitializer> initializer = do_QueryInterface(native);
-  MOZ_ASSERT(initializer);
-
-  nsresult rv = initializer->Initialize(nullptr, cx, nullptr, args);
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not initialize native object!");
-    return false;
-  }
-
-  nsCOMPtr<nsIXPConnect> xpc = do_GetService(kXPConnectServiceContractID, &rv);
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not get XPConnent service!");
-    return false;
-  }
-
-  JSObject *global = JS::CurrentGlobalOrNull(cx);
-  rv = xpc->WrapNativeToJSVal(cx, global, native, nullptr,
-                              &NS_GET_IID(nsISupports), true,
-                              args.rval());
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not wrap native object!");
-    return false;
-  }
-
-  return true;
-}
-
-static bool
-File(JSContext *cx, unsigned argc, Value *vp)
-{
-  JS::CallArgs args = CallArgsFromVp(argc, vp);
-
-  nsCOMPtr<nsISupports> native =
-    do_CreateInstance("@mozilla.org/dom/multipart-file;1");
-  if (!native) {
-    JS_ReportError(cx, "Could not create native object!");
-    return false;
-  }
-
-  nsCOMPtr<nsIJSNativeInitializer> initializer = do_QueryInterface(native);
-  MOZ_ASSERT(initializer);
-
-  nsresult rv = initializer->Initialize(nullptr, cx, nullptr, args);
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not initialize native object!");
-    return false;
-  }
-
-  nsCOMPtr<nsIXPConnect> xpc = do_GetService(kXPConnectServiceContractID, &rv);
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not get XPConnent service!");
-    return false;
-  }
-
-  JSObject *global = JS::CurrentGlobalOrNull(cx);
-  rv = xpc->WrapNativeToJSVal(cx, global, native, nullptr,
-                              &NS_GET_IID(nsISupports), true,
-                              args.rval());
-  if (NS_FAILED(rv)) {
-    JS_ReportError(cx, "Could not wrap native object!");
-    return false;
-  }
-
-  return true;
-}
-
 static Maybe<PersistentRootedValue> sScriptedInterruptCallback;
 
 static bool
 XPCShellInterruptCallback(JSContext *cx)
 {
     MOZ_ASSERT(!sScriptedInterruptCallback.empty());
     RootedValue callback(cx, sScriptedInterruptCallback.ref());
 
@@ -724,18 +646,16 @@ static const JSFunctionSpec glob_functio
 #ifdef JS_GC_ZEAL
     JS_FS("gczeal",          GCZeal,         1,0),
 #endif
     JS_FS("options",         Options,        0,0),
     JS_FN("parent",          Parent,         1,0),
     JS_FS("sendCommand",     SendCommand,    1,0),
     JS_FS("atob",            Atob,           1,0),
     JS_FS("btoa",            Btoa,           1,0),
-    JS_FS("Blob",            Blob,           2,JSFUN_CONSTRUCTOR),
-    JS_FS("File",            File,           2,JSFUN_CONSTRUCTOR),
     JS_FS("setInterruptCallback", SetInterruptCallback, 1,0),
     JS_FS("simulateActivityCallback", SimulateActivityCallback, 1,0),
     JS_FS_END
 };
 
 static bool
 env_setProperty(JSContext *cx, HandleObject obj, HandleId id, bool strict, MutableHandleValue vp)
 {
diff --git a/js/xpconnect/src/xpcprivate.h b/js/xpconnect/src/xpcprivate.h
--- a/js/xpconnect/src/xpcprivate.h
+++ b/js/xpconnect/src/xpcprivate.h
@@ -3374,16 +3374,18 @@ struct GlobalProperties {
     bool Promise : 1;
     bool indexedDB : 1;
     bool XMLHttpRequest : 1;
     bool TextDecoder : 1;
     bool TextEncoder : 1;
     bool URL : 1;
     bool atob : 1;
     bool btoa : 1;
+    bool Blob : 1;
+    bool File : 1;
 };
 
 // Infallible.
 already_AddRefed<nsIXPCComponents_utils_Sandbox>
 NewSandboxConstructor();
 
 // Returns true if class of 'obj' is SandboxClass.
 bool
diff --git a/js/xpconnect/tests/unit/component-blob.js b/js/xpconnect/tests/unit/component-blob.js
--- a/js/xpconnect/tests/unit/component-blob.js
+++ b/js/xpconnect/tests/unit/component-blob.js
@@ -1,13 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.importGlobalProperties(['Blob']);
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
 function do_check_true(cond, text) {
   // we don't have the test harness' utilities in this scope, so we need this
   // little helper. In the failure case, the exception is propagated to the
@@ -20,41 +21,35 @@ function BlobComponent() {
   this.wrappedJSObject = this;
 }
 BlobComponent.prototype =
 {
   doTest: function() {
     // throw if anything goes wrong
     let testContent = "<a id=\"a\"><b id=\"b\">hey!<\/b><\/a>";
     // should be able to construct a file
-    var f1 = Blob([testContent], {"type" : "text/xml"});
-    // with either constructor syntax
-    var f2 = new Blob([testContent], {"type" : "text/xml"});
+    var f1 = new Blob([testContent], {"type" : "text/xml"});
 
     // do some tests
     do_check_true(f1 instanceof Ci.nsIDOMBlob, "Should be a DOM Blob");
-    do_check_true(f2 instanceof Ci.nsIDOMBlob, "Should be a DOM Blob");
 
     do_check_true(!(f1 instanceof Ci.nsIDOMFile), "Should not be a DOM File");
-    do_check_true(!(f2 instanceof Ci.nsIDOMFile), "Should not be a DOM File");
 
     do_check_true(f1.type == "text/xml", "Wrong type");
-    do_check_true(f2.type == "text/xml", "Wrong type");
 
     do_check_true(f1.size == testContent.length, "Wrong content size");
-    do_check_true(f2.size == testContent.length, "Wrong content size");
 
-    var f3 = new Blob();
-    do_check_true(f3.size == 0, "Wrong size");
-    do_check_true(f3.type == "", "Wrong type");
+    var f2 = new Blob();
+    do_check_true(f2.size == 0, "Wrong size");
+    do_check_true(f2.type == "", "Wrong type");
 
     var threw = false;
     try {
       // Needs a valid ctor argument
-      var f3 = Blob(Date(132131532));
+      var f2 = new Blob(Date(132131532));
     } catch (e) {
       threw = true;
     }
     do_check_true(threw, "Passing a random object should fail");
 
     return true;
   },
 
diff --git a/js/xpconnect/tests/unit/component-file.js b/js/xpconnect/tests/unit/component-file.js
--- a/js/xpconnect/tests/unit/component-file.js
+++ b/js/xpconnect/tests/unit/component-file.js
@@ -1,13 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
+Components.utils.importGlobalProperties(['File']);
+
 
 const Ci = Components.interfaces;
 
 function do_check_true(cond, text) {
   // we don't have the test harness' utilities in this scope, so we need this
   // little helper. In the failure case, the exception is propagated to the
   // caller in the main run_test() function, and the test fails.
   if (!cond)
@@ -24,64 +26,55 @@ FileComponent.prototype =
 
     // find the current directory path
     var file = Components.classes["@mozilla.org/file/directory_service;1"]
                .getService(Ci.nsIProperties)
                .get("CurWorkD", Ci.nsIFile);
     file.append("xpcshell.ini");
 
     // should be able to construct a file
-    var f1 = File(file.path);
-    // with either constructor syntax
-    var f2 = new File(file.path);
+    var f1 = new File(file.path);
     // and with nsIFiles
-    var f3 = File(file);
-    var f4 = new File(file);
+    var f2 = new File(file);
 
     // do some tests
     do_check_true(f1 instanceof Ci.nsIDOMFile, "Should be a DOM File");
     do_check_true(f2 instanceof Ci.nsIDOMFile, "Should be a DOM File");
-    do_check_true(f3 instanceof Ci.nsIDOMFile, "Should be a DOM File");
-    do_check_true(f4 instanceof Ci.nsIDOMFile, "Should be a DOM File");
 
     do_check_true(f1.name == "xpcshell.ini", "Should be the right file");
     do_check_true(f2.name == "xpcshell.ini", "Should be the right file");
-    do_check_true(f3.name == "xpcshell.ini", "Should be the right file");
-    do_check_true(f4.name == "xpcshell.ini", "Should be the right file");
 
     do_check_true(f1.type == "", "Should be the right type");
     do_check_true(f2.type == "", "Should be the right type");
-    do_check_true(f3.type == "", "Should be the right type");
-    do_check_true(f4.type == "", "Should be the right type");
 
     var threw = false;
     try {
       // Needs a ctor argument
-      var f7 = File();
+      var f7 = new File();
     } catch (e) {
       threw = true;
     }
     do_check_true(threw, "No ctor arguments should throw");
 
     var threw = false;
     try {
       // Needs a valid ctor argument
-      var f7 = File(Date(132131532));
+      var f7 = new File(Date(132131532));
     } catch (e) {
       threw = true;
     }
     do_check_true(threw, "Passing a random object should fail");
 
     var threw = false
     try {
       // Directories fail
       var dir = Components.classes["@mozilla.org/file/directory_service;1"]
                           .getService(Ci.nsIProperties)
                           .get("CurWorkD", Ci.nsIFile);
-      var f7 = File(dir)
+      var f7 = new File(dir)
     } catch (e) {
       threw = true;
     }
     do_check_true(threw, "Can't create a File object for a directory");
 
     return true;
   },
 
diff --git a/js/xpconnect/tests/unit/test_blob2.js b/js/xpconnect/tests/unit/test_blob2.js
--- a/js/xpconnect/tests/unit/test_blob2.js
+++ b/js/xpconnect/tests/unit/test_blob2.js
@@ -1,40 +1,36 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+Components.utils.importGlobalProperties(['Blob']);
+
 const Ci = Components.interfaces;
 
 function run_test() {
   // throw if anything goes wrong
   let testContent = "<a id=\"a\"><b id=\"b\">hey!<\/b><\/a>";
   // should be able to construct a file
-  var f1 = Blob([testContent], {"type" : "text/xml"});
-  // with either constructor syntax
-  var f2 = new Blob([testContent], {"type" : "text/xml"});
+  var f1 = new Blob([testContent], {"type" : "text/xml"});
 
   // do some tests
   do_check_true(f1 instanceof Ci.nsIDOMBlob, "Should be a DOM Blob");
-  do_check_true(f2 instanceof Ci.nsIDOMBlob, "Should be a DOM Blob");
 
   do_check_true(!(f1 instanceof Ci.nsIDOMFile), "Should not be a DOM File");
-  do_check_true(!(f2 instanceof Ci.nsIDOMFile), "Should not be a DOM File");
 
   do_check_true(f1.type == "text/xml", "Wrong type");
-  do_check_true(f2.type == "text/xml", "Wrong type");
 
   do_check_true(f1.size == testContent.length, "Wrong content size");
-  do_check_true(f2.size == testContent.length, "Wrong content size");
 
-  var f3 = new Blob();
-  do_check_true(f3.size == 0, "Wrong size");
-  do_check_true(f3.type == "", "Wrong type");
+  var f2 = new Blob();
+  do_check_true(f2.size == 0, "Wrong size");
+  do_check_true(f2.type == "", "Wrong type");
 
   var threw = false;
   try {
     // Needs a valid ctor argument
-    var f3 = Blob(Date(132131532));
+    var f2 = new Blob(Date(132131532));
   } catch (e) {
     threw = true;
   }
   do_check_true(threw, "Passing a random object should fail");
 }
diff --git a/js/xpconnect/tests/unit/test_file2.js b/js/xpconnect/tests/unit/test_file2.js
--- a/js/xpconnect/tests/unit/test_file2.js
+++ b/js/xpconnect/tests/unit/test_file2.js
@@ -1,46 +1,39 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+Components.utils.importGlobalProperties(['File']);
+
 const Ci = Components.interfaces;
 
 function run_test() {
   // throw if anything goes wrong
 
   // find the current directory path
   var file = Components.classes["@mozilla.org/file/directory_service;1"]
              .getService(Ci.nsIProperties)
              .get("CurWorkD", Ci.nsIFile);
   file.append("xpcshell.ini");
 
   // should be able to construct a file
-  var f1 = File(file.path);
-  // with either constructor syntax
-  var f2 = new File(file.path);
+  var f1 = new File(file.path);
   // and with nsIFiles
-  var f3 = File(file);
-  var f4 = new File(file);
+  var f2 = new File(file);
 
   // do some tests
   do_check_true(f1 instanceof Ci.nsIDOMFile, "Should be a DOM File");
   do_check_true(f2 instanceof Ci.nsIDOMFile, "Should be a DOM File");
-  do_check_true(f3 instanceof Ci.nsIDOMFile, "Should be a DOM File");
-  do_check_true(f4 instanceof Ci.nsIDOMFile, "Should be a DOM File");
 
   do_check_true(f1.name == "xpcshell.ini", "Should be the right file");
   do_check_true(f2.name == "xpcshell.ini", "Should be the right file");
-  do_check_true(f3.name == "xpcshell.ini", "Should be the right file");
-  do_check_true(f4.name == "xpcshell.ini", "Should be the right file");
 
   do_check_true(f1.type == "", "Should be the right type");
   do_check_true(f2.type == "", "Should be the right type");
-  do_check_true(f3.type == "", "Should be the right type");
-  do_check_true(f4.type == "", "Should be the right type");
 
   var threw = false;
   try {
     // Needs a ctor argument
     var f7 = File();
   } catch (e) {
     threw = true;
   }
diff --git a/layout/build/nsLayoutModule.cpp b/layout/build/nsLayoutModule.cpp
--- a/layout/build/nsLayoutModule.cpp
+++ b/layout/build/nsLayoutModule.cpp
@@ -505,18 +505,16 @@ NS_GENERIC_FACTORY_CONSTRUCTOR(inFlasher
 NS_GENERIC_FACTORY_CONSTRUCTOR(inCSSValueSearch)
 NS_GENERIC_FACTORY_CONSTRUCTOR(inDOMUtils)
 
 MAKE_CTOR2(CreateContentViewer,           nsIContentViewer,            NS_NewContentViewer)
 MAKE_CTOR(CreateHTMLDocument,             nsIDocument,                 NS_NewHTMLDocument)
 MAKE_CTOR(CreateXMLDocument,              nsIDocument,                 NS_NewXMLDocument)
 MAKE_CTOR(CreateSVGDocument,              nsIDocument,                 NS_NewSVGDocument)
 MAKE_CTOR(CreateImageDocument,            nsIDocument,                 NS_NewImageDocument)
-MAKE_CTOR(CreateDOMBlob,                  nsISupports,                 DOMMultipartFileImpl::NewBlob)
-MAKE_CTOR(CreateDOMFile,                  nsISupports,                 DOMMultipartFileImpl::NewFile)
 MAKE_CTOR(CreateDOMSelection,             nsISelection,                NS_NewDomSelection)
 MAKE_CTOR2(CreateContentIterator,         nsIContentIterator,          NS_NewContentIterator)
 MAKE_CTOR2(CreatePreContentIterator,      nsIContentIterator,          NS_NewPreContentIterator)
 MAKE_CTOR2(CreateSubtreeIterator,         nsIContentIterator,          NS_NewContentSubtreeIterator)
 MAKE_CTOR(CreateTextEncoder,              nsIDocumentEncoder,          NS_NewTextEncoder)
 MAKE_CTOR(CreateHTMLCopyTextEncoder,      nsIDocumentEncoder,          NS_NewHTMLCopyTextEncoder)
 MAKE_CTOR(CreateXMLContentSerializer,     nsIContentSerializer,        NS_NewXMLContentSerializer)
 MAKE_CTOR(CreateHTMLContentSerializer,    nsIContentSerializer,        NS_NewHTMLContentSerializer)
@@ -660,18 +658,16 @@ NS_DEFINE_NAMED_CID(IN_DEEPTREEWALKER_CI
 NS_DEFINE_NAMED_CID(IN_FLASHER_CID);
 NS_DEFINE_NAMED_CID(IN_CSSVALUESEARCH_CID);
 NS_DEFINE_NAMED_CID(IN_DOMUTILS_CID);
 NS_DEFINE_NAMED_CID(NS_CONTENT_VIEWER_CID);
 NS_DEFINE_NAMED_CID(NS_HTMLDOCUMENT_CID);
 NS_DEFINE_NAMED_CID(NS_XMLDOCUMENT_CID);
 NS_DEFINE_NAMED_CID(NS_SVGDOCUMENT_CID);
 NS_DEFINE_NAMED_CID(NS_IMAGEDOCUMENT_CID);
-NS_DEFINE_NAMED_CID(NS_DOMMULTIPARTBLOB_CID);
-NS_DEFINE_NAMED_CID(NS_DOMMULTIPARTFILE_CID);
 NS_DEFINE_NAMED_CID(NS_DOMSELECTION_CID);
 NS_DEFINE_NAMED_CID(NS_CONTENTITERATOR_CID);
 NS_DEFINE_NAMED_CID(NS_PRECONTENTITERATOR_CID);
 NS_DEFINE_NAMED_CID(NS_SUBTREEITERATOR_CID);
 NS_DEFINE_NAMED_CID(NS_CANVASRENDERINGCONTEXTWEBGL_CID);
 NS_DEFINE_NAMED_CID(NS_TEXT_ENCODER_CID);
 NS_DEFINE_NAMED_CID(NS_HTMLCOPY_TEXT_ENCODER_CID);
 NS_DEFINE_NAMED_CID(NS_XMLCONTENTSERIALIZER_CID);
@@ -949,18 +945,16 @@ static const mozilla::Module::CIDEntry k
   { &kIN_FLASHER_CID, false, nullptr, inFlasherConstructor },
   { &kIN_CSSVALUESEARCH_CID, false, nullptr, inCSSValueSearchConstructor },
   { &kIN_DOMUTILS_CID, false, nullptr, inDOMUtilsConstructor },
   { &kNS_CONTENT_VIEWER_CID, false, nullptr, CreateContentViewer },
   { &kNS_HTMLDOCUMENT_CID, false, nullptr, CreateHTMLDocument },
   { &kNS_XMLDOCUMENT_CID, false, nullptr, CreateXMLDocument },
   { &kNS_SVGDOCUMENT_CID, false, nullptr, CreateSVGDocument },
   { &kNS_IMAGEDOCUMENT_CID, false, nullptr, CreateImageDocument },
-  { &kNS_DOMMULTIPARTBLOB_CID, false, nullptr, CreateDOMBlob },
-  { &kNS_DOMMULTIPARTFILE_CID, false, nullptr, CreateDOMFile },
   { &kNS_DOMSELECTION_CID, false, nullptr, CreateDOMSelection },
   { &kNS_CONTENTITERATOR_CID, false, nullptr, CreateContentIterator },
   { &kNS_PRECONTENTITERATOR_CID, false, nullptr, CreatePreContentIterator },
   { &kNS_SUBTREEITERATOR_CID, false, nullptr, CreateSubtreeIterator },
   { &kNS_CANVASRENDERINGCONTEXTWEBGL_CID, false, nullptr, CreateCanvasRenderingContextWebGL },
   { &kNS_TEXT_ENCODER_CID, false, nullptr, CreateTextEncoder },
   { &kNS_HTMLCOPY_TEXT_ENCODER_CID, false, nullptr, CreateHTMLCopyTextEncoder },
   { &kNS_XMLCONTENTSERIALIZER_CID, false, nullptr, CreateXMLContentSerializer },
@@ -1099,18 +1093,16 @@ static const mozilla::Module::ContractID
   { "@mozilla.org/inspector/dom-view;1", &kIN_DOMVIEW_CID },
 #endif
   { "@mozilla.org/inspector/deep-tree-walker;1", &kIN_DEEPTREEWALKER_CID },
   { "@mozilla.org/inspector/flasher;1", &kIN_FLASHER_CID },
   { "@mozilla.org/inspector/search;1?type=cssvalue", &kIN_CSSVALUESEARCH_CID },
   { IN_DOMUTILS_CONTRACTID, &kIN_DOMUTILS_CID },
   { "@mozilla.org/xml/xml-document;1", &kNS_XMLDOCUMENT_CID },
   { "@mozilla.org/svg/svg-document;1", &kNS_SVGDOCUMENT_CID },
-  { NS_DOMMULTIPARTBLOB_CONTRACTID, &kNS_DOMMULTIPARTBLOB_CID },
-  { NS_DOMMULTIPARTFILE_CONTRACTID, &kNS_DOMMULTIPARTFILE_CID },
   { "@mozilla.org/content/dom-selection;1", &kNS_DOMSELECTION_CID },
   { "@mozilla.org/content/post-content-iterator;1", &kNS_CONTENTITERATOR_CID },
   { "@mozilla.org/content/pre-content-iterator;1", &kNS_PRECONTENTITERATOR_CID },
   { "@mozilla.org/content/subtree-content-iterator;1", &kNS_SUBTREEITERATOR_CID },
   { "@mozilla.org/content/canvas-rendering-context;1?id=experimental-webgl", &kNS_CANVASRENDERINGCONTEXTWEBGL_CID },
 #ifdef MOZ_WEBGL_CONFORMANT
   { "@mozilla.org/content/canvas-rendering-context;1?id=webgl", &kNS_CANVASRENDERINGCONTEXTWEBGL_CID },
 #endif
diff --git a/testing/specialpowers/content/MockFilePicker.jsm b/testing/specialpowers/content/MockFilePicker.jsm
--- a/testing/specialpowers/content/MockFilePicker.jsm
+++ b/testing/specialpowers/content/MockFilePicker.jsm
@@ -90,17 +90,17 @@ this.MockFilePicker = {
     var file = FileUtils.getDir("TmpD", [], false);
     file.append("testfile");
     file.createUnique(Ci.nsIFile.NORMAL_FILE_TYPE, 0644);
     this.returnFiles = [file];
   },
 
   useBlobFile: function() {
     var blob = new this.window.Blob([]);
-    var file = new this.window.File(blob, { name: 'helloworld.txt', type: 'plain/text' });
+    var file = new this.window.File([blob], 'helloworld.txt', { type: 'plain/text' });
     this.returnFiles = [file];
   },
 
   isNsIFile: function(aFile) {
     let ret = false;
     try {
       if (aFile.QueryInterface(Ci.nsIFile))
         ret = true;
diff --git a/toolkit/crashreporter/CrashSubmit.jsm b/toolkit/crashreporter/CrashSubmit.jsm
--- a/toolkit/crashreporter/CrashSubmit.jsm
+++ b/toolkit/crashreporter/CrashSubmit.jsm
@@ -1,14 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 Components.utils.import("resource://gre/modules/Services.jsm");
 Components.utils.import("resource://gre/modules/KeyValueParser.jsm");
+Components.utils.importGlobalProperties(['File']);
 
 this.EXPORTED_SYMBOLS = [
   "CrashSubmit"
 ];
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const STATE_START = Ci.nsIWebProgressListener.STATE_START;
@@ -265,23 +266,23 @@ Submitter.prototype = {
         formData.append(name, value);
       }
     }
     if (this.noThrottle) {
       // tell the server not to throttle this, since it was manually submitted
       formData.append("Throttleable", "0");
     }
     // add the minidumps
-    formData.append("upload_file_minidump", File(this.dump.path));
+    formData.append("upload_file_minidump", new File(this.dump.path));
     if (this.additionalDumps.length > 0) {
       let names = [];
       for (let i of this.additionalDumps) {
         names.push(i.name);
         formData.append("upload_file_minidump_"+i.name,
-                        File(i.dump.path));
+                        new File(i.dump.path));
       }
     }
 
     let self = this;
     xhr.addEventListener("readystatechange", function (aEvt) {
       if (xhr.readyState == 4) {
         let ret =
           xhr.status == 200 ? parseKeyValuePairs(xhr.responseText) : {};
diff --git a/toolkit/modules/PropertyListUtils.jsm b/toolkit/modules/PropertyListUtils.jsm
--- a/toolkit/modules/PropertyListUtils.jsm
+++ b/toolkit/modules/PropertyListUtils.jsm
@@ -56,16 +56,17 @@
 "use strict";
 
 this.EXPORTED_SYMBOLS = ["PropertyListUtils"];
 
 const Cc = Components.classes;
 const Ci = Components.interfaces;
 const Cu = Components.utils;
 
+Cu.importGlobalProperties(['File']);
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Dict",
                                   "resource://gre/modules/Dict.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "ctypes",
                                   "resource://gre/modules/ctypes.jsm");
 XPCOMUtils.defineLazyModuleGetter(this, "Services",
                                   "resource://gre/modules/Services.jsm");
