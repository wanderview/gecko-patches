# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  99ee247e1270c86d02edc63855f8f03dcca274f7
Bug 1469046 Disable service worker propagation when e10s pref is enabled. r=asuth

diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -54,16 +54,17 @@
 #include "mozilla/dom/PositionError.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/dom/power/PowerManagerService.h"
 #include "mozilla/dom/Permissions.h"
 #include "mozilla/dom/PresentationParent.h"
 #include "mozilla/dom/PPresentationParent.h"
 #include "mozilla/dom/PushNotifier.h"
 #include "mozilla/dom/quota/QuotaManagerService.h"
+#include "mozilla/dom/ServiceWorkerUtils.h"
 #include "mozilla/dom/URLClassifierParent.h"
 #include "mozilla/embedding/printingui/PrintingParent.h"
 #include "mozilla/extensions/StreamFilterParent.h"
 #include "mozilla/gfx/gfxVars.h"
 #include "mozilla/gfx/GPUProcessManager.h"
 #include "mozilla/hal_sandbox/PHalParent.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundParent.h"
@@ -2444,17 +2445,17 @@ ContentParent::InitInternal(ProcessPrior
     }
   }
 #endif
   if (shouldSandbox && !SendSetProcessSandbox(brokerFd)) {
     KillHard("SandboxInitFailed");
   }
 #endif
 
-  {
+  if (!ServiceWorkerParentInterceptEnabled()) {
     RefPtr<ServiceWorkerRegistrar> swr = ServiceWorkerRegistrar::Get();
     MOZ_ASSERT(swr);
 
     nsTArray<ServiceWorkerRegistrationData> registrations;
     swr->GetRegistrations(registrations);
 
     // Send down to the content process the permissions for each of the
     // registered service worker scopes.
diff --git a/dom/serviceworkers/ServiceWorkerInfo.cpp b/dom/serviceworkers/ServiceWorkerInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerInfo.cpp
@@ -195,16 +195,18 @@ ServiceWorkerInfo::ServiceWorkerInfo(nsI
   , mCreationTimeStamp(TimeStamp::Now())
   , mInstalledTime(0)
   , mActivatedTime(0)
   , mRedundantTime(0)
   , mServiceWorkerPrivate(new ServiceWorkerPrivate(this))
   , mSkipWaitingFlag(false)
   , mHandlesFetch(Unknown)
 {
+  MOZ_ASSERT_IF(ServiceWorkerParentInterceptEnabled(),
+                XRE_GetProcessType() == GeckoProcessType_Default);
   MOZ_ASSERT(mPrincipal);
   // cache origin attributes so we can use them off main thread
   mOriginAttributes = mPrincipal->OriginAttributesRef();
   MOZ_ASSERT(!mDescriptor.ScriptURL().IsEmpty());
   MOZ_ASSERT(!mCacheName.IsEmpty());
 
   // Scripts of a service worker should always be loaded bypass service workers.
   // Otherwise, we might not be able to update a service worker correctly, if
diff --git a/dom/serviceworkers/ServiceWorkerManagerService.cpp b/dom/serviceworkers/ServiceWorkerManagerService.cpp
--- a/dom/serviceworkers/ServiceWorkerManagerService.cpp
+++ b/dom/serviceworkers/ServiceWorkerManagerService.cpp
@@ -86,16 +86,20 @@ ServiceWorkerManagerService::UnregisterA
 
 void
 ServiceWorkerManagerService::PropagateRegistration(
                                            uint64_t aParentID,
                                            ServiceWorkerRegistrationData& aData)
 {
   AssertIsOnBackgroundThread();
 
+  if (ServiceWorkerParentInterceptEnabled()) {
+    return;
+  }
+
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<ServiceWorkerManagerParent> parent = iter.Get()->GetKey();
     MOZ_ASSERT(parent);
 
     if (parent->ID() != aParentID) {
       Unused << parent->SendNotifyRegister(aData);
 #ifdef DEBUG
@@ -128,16 +132,20 @@ ServiceWorkerManagerService::PropagateRe
 void
 ServiceWorkerManagerService::PropagateSoftUpdate(
                                       uint64_t aParentID,
                                       const OriginAttributes& aOriginAttributes,
                                       const nsAString& aScope)
 {
   AssertIsOnBackgroundThread();
 
+  if (ServiceWorkerParentInterceptEnabled()) {
+    return;
+  }
+
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<ServiceWorkerManagerParent> parent = iter.Get()->GetKey();
     MOZ_ASSERT(parent);
 
     nsString scope(aScope);
     Unused << parent->SendNotifySoftUpdate(aOriginAttributes,
                                            scope);
@@ -157,16 +165,20 @@ ServiceWorkerManagerService::PropagateSo
 void
 ServiceWorkerManagerService::PropagateUnregister(
                                             uint64_t aParentID,
                                             const PrincipalInfo& aPrincipalInfo,
                                             const nsAString& aScope)
 {
   AssertIsOnBackgroundThread();
 
+  if (ServiceWorkerParentInterceptEnabled()) {
+    return;
+  }
+
   RefPtr<dom::ServiceWorkerRegistrar> service =
     dom::ServiceWorkerRegistrar::Get();
   MOZ_ASSERT(service);
 
   // It's possible that we don't have any ServiceWorkerManager managing this
   // scope but we still need to unregister it from the ServiceWorkerRegistrar.
   service->UnregisterServiceWorker(aPrincipalInfo,
                                    NS_ConvertUTF16toUTF8(aScope));
@@ -192,16 +204,20 @@ ServiceWorkerManagerService::PropagateUn
 }
 
 void
 ServiceWorkerManagerService::PropagateRemove(uint64_t aParentID,
                                              const nsACString& aHost)
 {
   AssertIsOnBackgroundThread();
 
+  if (ServiceWorkerParentInterceptEnabled()) {
+    return;
+  }
+
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
     RefPtr<ServiceWorkerManagerParent> parent = iter.Get()->GetKey();
     MOZ_ASSERT(parent);
 
     if (parent->ID() != aParentID) {
       nsCString host(aHost);
       Unused << parent->SendNotifyRemove(host);
@@ -217,16 +233,20 @@ ServiceWorkerManagerService::PropagateRe
 #endif
 }
 
 void
 ServiceWorkerManagerService::PropagateRemoveAll(uint64_t aParentID)
 {
   AssertIsOnBackgroundThread();
 
+  if (ServiceWorkerParentInterceptEnabled()) {
+    return;
+  }
+
   RefPtr<dom::ServiceWorkerRegistrar> service =
     dom::ServiceWorkerRegistrar::Get();
   MOZ_ASSERT(service);
 
   service->RemoveAll();
 
   DebugOnly<bool> parentFound = false;
   for (auto iter = mAgents.Iter(); !iter.Done(); iter.Next()) {
diff --git a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
--- a/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
+++ b/dom/serviceworkers/ServiceWorkerRegistrationInfo.cpp
@@ -103,17 +103,20 @@ ServiceWorkerRegistrationInfo::ServiceWo
   , mControlledClientsCounter(0)
   , mDelayMultiplier(0)
   , mUpdateState(NoUpdate)
   , mCreationTime(PR_Now())
   , mCreationTimeStamp(TimeStamp::Now())
   , mLastUpdateTime(0)
   , mPendingUninstall(false)
   , mCorrupt(false)
-{}
+{
+  MOZ_ASSERT_IF(ServiceWorkerParentInterceptEnabled(),
+                XRE_GetProcessType() == GeckoProcessType_Default);
+}
 
 ServiceWorkerRegistrationInfo::~ServiceWorkerRegistrationInfo()
 {
   MOZ_DIAGNOSTIC_ASSERT(!IsControllingClients());
 }
 
 void
 ServiceWorkerRegistrationInfo::AddInstance(ServiceWorkerRegistrationListener* aInstance,
