# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  3cedab21a7e65e6a1c4c2294ecfb5502575a46e3
Bug 1332706 Add release assertions to LinkedListElement. r=froydnj

diff --git a/mfbt/LinkedList.h b/mfbt/LinkedList.h
--- a/mfbt/LinkedList.h
+++ b/mfbt/LinkedList.h
@@ -214,38 +214,38 @@ public:
   ConstRawType getPrevious() const { return mPrev->asT(); }
 
   /*
    * Insert aElem after this element in the list.  |this| must be part of a
    * linked list when you call setNext(); otherwise, this method will assert.
    */
   void setNext(RawType aElem)
   {
-    MOZ_ASSERT(isInList());
+    MOZ_RELEASE_ASSERT(isInList());
     setNextUnsafe(aElem);
   }
 
   /*
    * Insert aElem before this element in the list.  |this| must be part of a
    * linked list when you call setPrevious(); otherwise, this method will
    * assert.
    */
   void setPrevious(RawType aElem)
   {
-    MOZ_ASSERT(isInList());
+    MOZ_RELEASE_ASSERT(isInList());
     setPreviousUnsafe(aElem);
   }
 
   /*
    * Remove this element from the list which contains it.  If this element is
    * not currently part of a linked list, this method asserts.
    */
   void remove()
   {
-    MOZ_ASSERT(isInList());
+    MOZ_RELEASE_ASSERT(isInList());
 
     mPrev->mNext = mNext;
     mNext->mPrev = mPrev;
     mNext = this;
     mPrev = this;
 
     Traits::exitList(this);
   }
@@ -284,17 +284,17 @@ public:
     remove();
   }
 
   /*
    * Return true if |this| part is of a linked list, and false otherwise.
    */
   bool isInList() const
   {
-    MOZ_ASSERT((mNext == this) == (mPrev == this));
+    MOZ_RELEASE_ASSERT(IsValid());
     return mNext != this;
   }
 
 private:
   friend class LinkedList<T>;
   friend struct detail::LinkedListElementTraits<T>;
 
   enum class NodeKind {
@@ -309,48 +309,49 @@ private:
   { }
 
   /*
    * Return |this| cast to T* if we're a normal node, or return nullptr if
    * we're a sentinel node.
    */
   RawType asT()
   {
+    MOZ_RELEASE_ASSERT(IsValid());
     return mIsSentinel ? nullptr : static_cast<RawType>(this);
   }
   ConstRawType asT() const
   {
     return mIsSentinel ? nullptr : static_cast<ConstRawType>(this);
   }
 
   /*
    * Insert aElem after this element, but don't check that this element is in
    * the list.  This is called by LinkedList::insertFront().
    */
   void setNextUnsafe(RawType aElem)
   {
     LinkedListElement *listElem = static_cast<LinkedListElement*>(aElem);
-    MOZ_ASSERT(!listElem->isInList());
+    MOZ_RELEASE_ASSERT(!listElem->isInList());
 
     listElem->mNext = this->mNext;
     listElem->mPrev = this;
     this->mNext->mPrev = listElem;
     this->mNext = listElem;
 
     Traits::enterList(aElem);
   }
 
   /*
    * Insert aElem before this element, but don't check that this element is in
    * the list.  This is called by LinkedList::insertBack().
    */
   void setPreviousUnsafe(RawType aElem)
   {
     LinkedListElement<T>* listElem = static_cast<LinkedListElement<T>*>(aElem);
-    MOZ_ASSERT(!listElem->isInList());
+    MOZ_RELEASE_ASSERT(!listElem->isInList());
 
     listElem->mNext = this;
     listElem->mPrev = this->mPrev;
     this->mPrev->mNext = listElem;
     this->mPrev = listElem;
 
     Traits::enterList(aElem);
   }
@@ -391,16 +392,24 @@ private:
     aOther.mNext = &aOther;
     aOther.mPrev = &aOther;
 
     if (!mIsSentinel) {
       Traits::exitList(&aOther);
     }
   }
 
+  bool
+  IsValid() const
+  {
+    return ((mNext == this) == (mPrev == this)) &&
+           mNext && mNext->mPrev == this &&
+           mPrev && mPrev->mNext == this;
+  }
+
   LinkedListElement& operator=(const LinkedListElement<T>& aOther) = delete;
   LinkedListElement(const LinkedListElement<T>& aOther) = delete;
 };
 
 template<typename T>
 class LinkedList
 {
 private:
