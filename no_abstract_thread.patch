# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  92ea32de0b095565374c937f347458c85e1746da

diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -3380,17 +3380,18 @@ nsDocShell::MaybeCreateInitialClientSour
   Maybe<ServiceWorkerDescriptor> controller(parentInner->GetController());
   if (controller.isNothing()) {
     return;
   }
 
   // If the parent is controlled then propagate that controller to the
   // initial about:blank client as well.
   RefPtr<ClientHandle> handle =
-    ClientManager::CreateHandle(mInitialClientSource->Info());
+    ClientManager::CreateHandle(mInitialClientSource->Info(),
+                                parentInner->EventTargetFor(TaskCategory::Other));
   RefPtr<GenericPromise> ref = handle->Control(controller.ref());
 }
 
 Maybe<ClientInfo>
 nsDocShell::GetInitialClientInfo() const
 {
   if (mInitialClientSource) {
     Maybe<ClientInfo> result;
diff --git a/dom/clients/api/Client.cpp b/dom/clients/api/Client.cpp
--- a/dom/clients/api/Client.cpp
+++ b/dom/clients/api/Client.cpp
@@ -36,17 +36,18 @@ Client::~Client()
 {
 }
 
 void
 Client::EnsureHandle()
 {
   NS_ASSERT_OWNINGTHREAD(Client);
   if (!mHandle) {
-    mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()));
+    mHandle = ClientManager::CreateHandle(ClientInfo(mData->info()),
+                                          mGlobal->EventTargetFor(TaskCategory::Other));
   }
 }
 
 Client::Client(nsIGlobalObject* aGlobal, const ClientInfoAndState& aData)
   : mGlobal(aGlobal)
   , mData(MakeUnique<ClientInfoAndState>(aData))
 {
   MOZ_DIAGNOSTIC_ASSERT(mGlobal);
@@ -181,17 +182,17 @@ Client::Focus(ErrorResult& aRv)
     return outerPromise.forget();
   }
 
   EnsureHandle();
 
   RefPtr<Client> self = this;
 
   RefPtr<ClientStatePromise> innerPromise = mHandle->Focus();
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  innerPromise->Then(mGlobal->EventTargetFor(TaskCategory::Other), __func__,
     [self, outerPromise] (const ClientState& aResult) {
       RefPtr<Client> newClient =
         new Client(self->mGlobal, ClientInfoAndState(self->mData->info(), aResult.ToIPC()));
       outerPromise->MaybeResolve(newClient);
     }, [self, outerPromise] (nsresult aResult) {
       outerPromise->MaybeReject(aResult);
     });
 
@@ -221,16 +222,17 @@ Client::Navigate(const nsAString& aURL, 
     }
   }
 
   RefPtr<Client> self = this;
 
   ClientNavigateArgs args(mData->info(), NS_ConvertUTF16toUTF8(aURL), baseURL);
 
   StartClientManagerOp(&ClientManager::Navigate, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
     [self, outerPromise] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> newClient =
         new Client(self->mGlobal, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(newClient);
diff --git a/dom/clients/api/ClientDOMUtil.h b/dom/clients/api/ClientDOMUtil.h
--- a/dom/clients/api/ClientDOMUtil.h
+++ b/dom/clients/api/ClientDOMUtil.h
@@ -1,17 +1,16 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientDOMUtil_h
 #define _mozilla_dom_ClientDOMUtil_h
 
-#include "mozilla/AbstractThread.h"
 #include "mozilla/dom/ClientIPCTypes.h"
 #include "mozilla/dom/ClientOpPromise.h"
 #include "mozilla/dom/WorkerPrivate.h"
 #include "mozilla/dom/workers/bindings/WorkerHolderToken.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
@@ -20,29 +19,30 @@ namespace dom {
 class ClientEndPoint;
 
 nsresult
 ClientGetEndPoint(nsIGlobalObject* aGlobal, ClientEndPoint* aEndPointOut);
 
 // TODO: Add a ClientHandle version of this wrapper for Client methods.
 template<typename Func, typename Arg, typename Resolve, typename Reject>
 void
-StartClientManagerOp(Func aFunc, const Arg& aArg, Resolve aResolve, Reject aReject)
+StartClientManagerOp(Func aFunc, const Arg& aArg, nsISerialEventTarget* aTarget,
+                     Resolve aResolve, Reject aReject)
 {
   using mozilla::dom::workers::Closing;
   using mozilla::dom::workers::GetCurrentThreadWorkerPrivate;
   using mozilla::dom::workers::WorkerHolderToken;
 
   RefPtr<WorkerHolderToken> token;
   if (!NS_IsMainThread()) {
     token = WorkerHolderToken::Create(GetCurrentThreadWorkerPrivate(), Closing);
   }
 
-  RefPtr<ClientOpPromise> promise = aFunc(aArg);
-  promise->Then(AbstractThread::GetCurrent(), __func__,
+  RefPtr<ClientOpPromise> promise = aFunc(aArg, aTarget);
+  promise->Then(aTarget, __func__,
     [aResolve, token](const ClientOpResult& aResult) {
       if (token && token->IsShuttingDown()) {
         return;
       }
       aResolve(aResult);
     }, [aReject, token](nsresult aResult) {
       if (token && token->IsShuttingDown()) {
         return;
diff --git a/dom/clients/api/Clients.cpp b/dom/clients/api/Clients.cpp
--- a/dom/clients/api/Clients.cpp
+++ b/dom/clients/api/Clients.cpp
@@ -81,20 +81,23 @@ Clients::Get(const nsAString& aClientID,
   }
 
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TIPCServiceWorkerDescriptor
       ? endpoint.get_IPCServiceWorkerDescriptor().principalInfo()
       : endpoint.get_IPCClientInfo().principalInfo();
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
+  nsCOMPtr<nsISerialEventTarget> target =
+    mGlobal->EventTargetFor(TaskCategory::Other);
 
   RefPtr<ClientOpPromise> innerPromise =
-    ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo));
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+    ClientManager::GetInfoAndState(ClientGetInfoAndStateArgs(id, principalInfo),
+                                   target);
+  innerPromise->Then(target, __func__,
     [outerPromise, global] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolve(
         new Client(global, aResult.get_ClientInfoAndState()));
     }, [outerPromise] (nsresult aResult) {
       outerPromise->MaybeResolveWithUndefined();
     });
 
   return outerPromise.forget();
@@ -155,16 +158,17 @@ Clients::MatchAll(const ClientQueryOptio
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   // We don't expose this reserved clients yet
   const bool includeReserved = false;
   ClientMatchAllArgs args(endpoint, aOptions.mType,
                           aOptions.mIncludeUncontrolled,
                           includeReserved);
   StartClientManagerOp(&ClientManager::MatchAll, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise, global] (const ClientOpResult& aResult) {
       nsTArray<RefPtr<Client>> clientList;
       for (const ClientInfoAndState& value : aResult.get_ClientList().values()) {
         clientList.AppendElement(new Client(global, value));
       }
       clientList.Sort(MatchAllComparator());
       outerPromise->MaybeResolve(clientList);
     }, [outerPromise] (nsresult aResult) {
@@ -224,16 +228,17 @@ Clients::OpenWindow(const nsAString& aUR
     outerPromise->MaybeReject(NS_ERROR_DOM_INVALID_ACCESS_ERR);
     return outerPromise.forget();
   }
 
   nsCOMPtr<nsIGlobalObject> global = mGlobal;
 
   ClientOpenWindowArgs args(principalInfo, NS_ConvertUTF16toUTF8(aURL), baseURL);
   StartClientManagerOp(&ClientManager::OpenWindow, args,
+    mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise, global] (const ClientOpResult& aResult) {
       if (aResult.type() != ClientOpResult::TClientInfoAndState) {
         outerPromise->MaybeResolve(JS::NullHandleValue);
         return;
       }
       RefPtr<Client> client =
         new Client(global, aResult.get_ClientInfoAndState());
       outerPromise->MaybeResolve(client);
@@ -270,16 +275,17 @@ Clients::Claim(ErrorResult& aRv)
 
   if (serviceWorker.state() != ServiceWorkerState::Activating &&
       serviceWorker.state() != ServiceWorkerState::Activated) {
     aRv.Throw(NS_ERROR_DOM_INVALID_STATE_ERR);
     return outerPromise.forget();
   }
 
   StartClientManagerOp(&ClientManager::Claim, ClientClaimArgs(serviceWorker),
+    mGlobal->EventTargetFor(TaskCategory::Other),
     [outerPromise] (const ClientOpResult& aResult) {
       outerPromise->MaybeResolveWithUndefined();
     }, [outerPromise] (nsresult aResult) {
       outerPromise->MaybeReject(aResult);
     });
 
   return outerPromise.forget();
 }
diff --git a/dom/clients/manager/ClientHandle.cpp b/dom/clients/manager/ClientHandle.cpp
--- a/dom/clients/manager/ClientHandle.cpp
+++ b/dom/clients/manager/ClientHandle.cpp
@@ -5,17 +5,16 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientHandle.h"
 
 #include "ClientHandleChild.h"
 #include "ClientHandleOpChild.h"
 #include "ClientManager.h"
 #include "ClientState.h"
-#include "mozilla/AbstractThread.h"
 #include "mozilla/dom/PClientManagerChild.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Unused.h"
 
 namespace mozilla {
 namespace dom {
 
@@ -45,38 +44,42 @@ ClientHandle::StartOp(const ClientOpCons
 {
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientHandle> kungFuGrip = this;
-  promise->Then(AbstractThread::GetCurrent(), __func__,
+  promise->Then(mSerialEventTarget, __func__,
                 [kungFuGrip] (const ClientOpResult &) { },
                 [kungFuGrip] (nsresult) { });
 
   MaybeExecute([aArgs, promise] (ClientHandleChild* aActor) {
     ClientHandleOpChild* actor = new ClientHandleOpChild(aArgs, promise);
     if (!aActor->SendPClientHandleOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
     }
   });
 
   RefPtr<ClientOpPromise> ref = promise.get();
   return ref.forget();
 }
 
 ClientHandle::ClientHandle(ClientManager* aManager,
+                           nsISerialEventTarget* aSerialEventTarget,
                            const ClientInfo& aClientInfo)
   : mManager(aManager)
+  , mSerialEventTarget(aSerialEventTarget)
   , mClientInfo(aClientInfo)
 {
   MOZ_DIAGNOSTIC_ASSERT(mManager);
+  MOZ_DIAGNOSTIC_ASSERT(mSerialEventTarget);
+  MOZ_ASSERT(mSerialEventTarget->IsOnCurrentThread());
 }
 
 void
 ClientHandle::Activate(PClientManagerChild* aActor)
 {
   NS_ASSERT_OWNINGTHREAD(ClientHandle);
 
   if (IsShutdown()) {
@@ -111,17 +114,17 @@ already_AddRefed<GenericPromise>
 ClientHandle::Control(const ServiceWorkerDescriptor& aServiceWorker)
 {
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise =
     StartOp(ClientControlledArgs(aServiceWorker.ToIPC()));
 
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
   RefPtr<GenericPromise> ref = outerPromise.get();
   return ref.forget();
@@ -130,17 +133,17 @@ ClientHandle::Control(const ServiceWorke
 already_AddRefed<ClientStatePromise>
 ClientHandle::Focus()
 {
   RefPtr<ClientStatePromise::Private> outerPromise =
     new ClientStatePromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(ClientFocusArgs());
 
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(ClientState::FromIPC(aResult.get_IPCClientState()), __func__);
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
   RefPtr<ClientStatePromise> ref = outerPromise.get();
   return ref.forget();
@@ -165,17 +168,17 @@ ClientHandle::PostMessage(StructuredClon
     ref = GenericPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR, __func__);
     return ref.forget();
   }
 
   RefPtr<GenericPromise::Private> outerPromise =
     new GenericPromise::Private(__func__);
 
   RefPtr<ClientOpPromise> innerPromise = StartOp(args);
-  innerPromise->Then(AbstractThread::GetCurrent(), __func__,
+  innerPromise->Then(mSerialEventTarget, __func__,
     [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Resolve(true, __func__);
     }, [outerPromise](const ClientOpResult& aResult) {
       outerPromise->Reject(aResult.get_nsresult(), __func__);
     });
 
   ref = outerPromise.get();
   return ref.forget();
diff --git a/dom/clients/manager/ClientHandle.h b/dom/clients/manager/ClientHandle.h
--- a/dom/clients/manager/ClientHandle.h
+++ b/dom/clients/manager/ClientHandle.h
@@ -32,28 +32,30 @@ class StructuredCloneData;
 }
 
 class ClientHandle final : public ClientThing<ClientHandleChild>
 {
   friend class ClientManager;
   friend class ClientHandleChild;
 
   RefPtr<ClientManager> mManager;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
   ClientInfo mClientInfo;
 
   ~ClientHandle();
 
   void
   Shutdown();
 
   already_AddRefed<ClientOpPromise>
   StartOp(const ClientOpConstructorArgs& aArgs);
 
   // Private methods called by ClientManager
   ClientHandle(ClientManager* aManager,
+               nsISerialEventTarget* aSerialEventTarget,
                const ClientInfo& aClientInfo);
 
   void
   Activate(PClientManagerChild* aActor);
 
   // Private methods called by ClientHandleChild
   void
   ExecutionReady(const ClientInfo& aClientInfo);
diff --git a/dom/clients/manager/ClientHandleOpParent.cpp b/dom/clients/manager/ClientHandleOpParent.cpp
--- a/dom/clients/manager/ClientHandleOpParent.cpp
+++ b/dom/clients/manager/ClientHandleOpParent.cpp
@@ -15,23 +15,16 @@ namespace dom {
 
 ClientSourceParent*
 ClientHandleOpParent::GetSource() const
 {
   auto handle = static_cast<ClientHandleParent*>(Manager());
   return handle->GetSource();
 }
 
-AbstractThread*
-ClientHandleOpParent::BackgroundThread() const
-{
-  auto handle = static_cast<ClientHandleParent*>(Manager());
-  return handle->BackgroundThread();
-}
-
 void
 ClientHandleOpParent::ActorDestroy(ActorDestroyReason aReason)
 {
   mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientHandleOpParent::Init(const ClientOpConstructorArgs& aArgs)
@@ -68,17 +61,17 @@ ClientHandleOpParent::Init(const ClientO
   // Other argument types can just be forwarded straight through.
   else {
     p = source->StartOp(aArgs);
   }
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
-  p->Then(BackgroundThread(), __func__,
+  p->Then(GetCurrentThreadSerialEventTarget(), __func__,
       [this] (const ClientOpResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
       }, [this] (const ClientOpResult& aResult) {
         mPromiseRequestHolder.Complete();
         Unused << PClientHandleOpParent::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
diff --git a/dom/clients/manager/ClientHandleOpParent.h b/dom/clients/manager/ClientHandleOpParent.h
--- a/dom/clients/manager/ClientHandleOpParent.h
+++ b/dom/clients/manager/ClientHandleOpParent.h
@@ -17,19 +17,16 @@ class ClientSourceParent;
 
 class ClientHandleOpParent final : public PClientHandleOpParent
 {
   MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
 
   ClientSourceParent*
   GetSource() const;
 
-  AbstractThread*
-  BackgroundThread() const;
-
   // PClientHandleOpParent interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
 public:
   ClientHandleOpParent() = default;
   ~ClientHandleOpParent() = default;
 
diff --git a/dom/clients/manager/ClientHandleParent.cpp b/dom/clients/manager/ClientHandleParent.cpp
--- a/dom/clients/manager/ClientHandleParent.cpp
+++ b/dom/clients/manager/ClientHandleParent.cpp
@@ -79,16 +79,10 @@ ClientHandleParent::Init(const IPCClient
 }
 
 ClientSourceParent*
 ClientHandleParent::GetSource() const
 {
   return mSource;
 }
 
-AbstractThread*
-ClientHandleParent::BackgroundThread() const
-{
-  return mService->BackgroundThread();
-}
-
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientHandleParent.h b/dom/clients/manager/ClientHandleParent.h
--- a/dom/clients/manager/ClientHandleParent.h
+++ b/dom/clients/manager/ClientHandleParent.h
@@ -42,17 +42,14 @@ public:
   ClientHandleParent();
   ~ClientHandleParent();
 
   void
   Init(const IPCClientInfo& aClientInfo);
 
   ClientSourceParent*
   GetSource() const;
-
-  AbstractThread*
-  BackgroundThread() const;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientHandleParent_h
diff --git a/dom/clients/manager/ClientManager.cpp b/dom/clients/manager/ClientManager.cpp
--- a/dom/clients/manager/ClientManager.cpp
+++ b/dom/clients/manager/ClientManager.cpp
@@ -158,47 +158,51 @@ ClientManager::CreateSourceInternal(Clie
   } else {
     mPendingSourceList.AppendElement(source.get());
   }
 
   return Move(source);
 }
 
 already_AddRefed<ClientHandle>
-ClientManager::CreateHandleInternal(const ClientInfo& aClientInfo)
+ClientManager::CreateHandleInternal(const ClientInfo& aClientInfo,
+                                    nsISerialEventTarget* aSerialEventTarget)
 {
   NS_ASSERT_OWNINGTHREAD(ClientManager);
+  MOZ_DIAGNOSTIC_ASSERT(aSerialEventTarget);
 
   if (IsShutdown()) {
     return nullptr;
   }
 
-  RefPtr<ClientHandle> handle = new ClientHandle(this, aClientInfo);
+  RefPtr<ClientHandle> handle = new ClientHandle(this, aSerialEventTarget,
+                                                 aClientInfo);
 
   // TODO: Replace with MaybeExecute()?  How to handle error shutdown?
   if (GetActor()) {
     handle->Activate(GetActor());
   } else {
     mPendingHandleList.AppendElement(handle);
   }
 
   return handle.forget();
 }
 
 already_AddRefed<ClientOpPromise>
-ClientManager::StartOp(const ClientOpConstructorArgs& aArgs)
+ClientManager::StartOp(const ClientOpConstructorArgs& aArgs,
+                       nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // Hold a ref to the client until the remote operation completes.  Otherwise
   // the ClientHandle might get de-refed and teardown the actor before we
   // get an answer.
   RefPtr<ClientManager> kungFuGrip = this;
-  promise->Then(AbstractThread::GetCurrent(), __func__,
+  promise->Then(aSerialEventTarget, __func__,
                 [kungFuGrip] (const ClientOpResult&) { },
                 [kungFuGrip] (nsresult) { });
 
   MaybeExecute([aArgs, promise] (ClientManagerChild* aActor) {
     ClientManagerOpChild* actor = new ClientManagerOpChild(aArgs, promise);
     if (!aActor->SendPClientManagerOpConstructor(actor, aArgs)) {
       // Constructor failure will reject promise via ActorDestroy()
       return;
@@ -330,56 +334,62 @@ UniquePtr<ClientSource>
 ClientManager::CreateSource(ClientType aType, const PrincipalInfo& aPrincipal)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
   return mgr->CreateSourceInternal(aType, aPrincipal);
 }
 
 // static
 already_AddRefed<ClientHandle>
-ClientManager::CreateHandle(const ClientInfo& aClientInfo)
+ClientManager::CreateHandle(const ClientInfo& aClientInfo,
+                            nsISerialEventTarget* aSerialEventTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->CreateHandleInternal(aClientInfo);
-}
-
-// static
-already_AddRefed<ClientOpPromise>
-ClientManager::MatchAll(const ClientMatchAllArgs& aArgs)
-{
-  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->StartOp(aArgs);
-}
-
-// static
-already_AddRefed<ClientOpPromise>
-ClientManager::Claim(const ClientClaimArgs& aArgs)
-{
-  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->StartOp(aArgs);
+  return mgr->CreateHandleInternal(aClientInfo, aSerialEventTarget);
 }
 
 // static
 already_AddRefed<ClientOpPromise>
-ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs)
+ClientManager::MatchAll(const ClientMatchAllArgs& aArgs,
+                        nsISerialEventTarget* aTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->StartOp(aArgs);
+  return mgr->StartOp(aArgs, aTarget);
 }
 
 // static
 already_AddRefed<ClientOpPromise>
-ClientManager::Navigate(const ClientNavigateArgs& aArgs)
+ClientManager::Claim(const ClientClaimArgs& aArgs,
+                     nsISerialEventTarget* aTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->StartOp(aArgs);
+  return mgr->StartOp(aArgs, aTarget);
 }
 
 // static
 already_AddRefed<ClientOpPromise>
-ClientManager::OpenWindow(const ClientOpenWindowArgs& aArgs)
+ClientManager::GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
+                               nsISerialEventTarget* aTarget)
 {
   RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
-  return mgr->StartOp(aArgs);
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::Navigate(const ClientNavigateArgs& aArgs,
+                        nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
+}
+
+// static
+already_AddRefed<ClientOpPromise>
+ClientManager::OpenWindow(const ClientOpenWindowArgs& aArgs,
+                          nsISerialEventTarget* aTarget)
+{
+  RefPtr<ClientManager> mgr = GetOrCreateForCurrentThread();
+  return mgr->StartOp(aArgs, aTarget);
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManager.h b/dom/clients/manager/ClientManager.h
--- a/dom/clients/manager/ClientManager.h
+++ b/dom/clients/manager/ClientManager.h
@@ -52,20 +52,22 @@ class ClientManager final : public Clien
   void
   Shutdown();
 
   UniquePtr<ClientSource>
   CreateSourceInternal(ClientType aType,
                        const mozilla::ipc::PrincipalInfo& aPrincipal);
 
   already_AddRefed<ClientHandle>
-  CreateHandleInternal(const ClientInfo& aClientInfo);
+  CreateHandleInternal(const ClientInfo& aClientInfo,
+                       nsISerialEventTarget* aSerialEventTarget);
 
   already_AddRefed<ClientOpPromise>
-  StartOp(const ClientOpConstructorArgs& aArgs);
+  StartOp(const ClientOpConstructorArgs& aArgs,
+          nsISerialEventTarget* aSerialEventTarget);
 
   void
   PBackgroundActorCreated(mozilla::ipc::PBackgroundChild* aActor);
 
   // Private methods called by ClientSource
   void
   ForgetSource(ClientSource* aSource);
 
@@ -85,32 +87,34 @@ public:
 
   static UniquePtr<ClientSource>
   CreateSource(ClientType aType, nsIPrincipal* aPrincipal);
 
   static UniquePtr<ClientSource>
   CreateSource(ClientType aType, const mozilla::ipc::PrincipalInfo& aPrincipal);
 
   static already_AddRefed<ClientHandle>
-  CreateHandle(const ClientInfo& aClientInfo);
-
-  static already_AddRefed<ClientOpPromise>
-  MatchAll(const ClientMatchAllArgs& aArgs);
+  CreateHandle(const ClientInfo& aClientInfo,
+               nsISerialEventTarget* aSerialEventTarget);
 
   static already_AddRefed<ClientOpPromise>
-  Claim(const ClientClaimArgs& aArgs);
+  MatchAll(const ClientMatchAllArgs& aArgs, nsISerialEventTarget* aTarget);
 
   static already_AddRefed<ClientOpPromise>
-  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
+  Claim(const ClientClaimArgs& aArgs, nsISerialEventTarget* aTarget);
 
   static already_AddRefed<ClientOpPromise>
-  Navigate(const ClientNavigateArgs& aArgs);
+  GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs,
+                  nsISerialEventTarget* aTarget);
 
   static already_AddRefed<ClientOpPromise>
-  OpenWindow(const ClientOpenWindowArgs& aArgs);
+  Navigate(const ClientNavigateArgs& aArgs, nsISerialEventTarget* aTarget);
+
+  static already_AddRefed<ClientOpPromise>
+  OpenWindow(const ClientOpenWindowArgs& aArgs, nsISerialEventTarget* aTarget);
 
   NS_INLINE_DECL_REFCOUNTING(mozilla::dom::ClientManager)
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientManager_h
diff --git a/dom/clients/manager/ClientManagerOpParent.cpp b/dom/clients/manager/ClientManagerOpParent.cpp
--- a/dom/clients/manager/ClientManagerOpParent.cpp
+++ b/dom/clients/manager/ClientManagerOpParent.cpp
@@ -20,17 +20,17 @@ ClientManagerOpParent::DoServiceOp(Metho
 {
   // Note, we need perfect forarding of the template type in order
   // to allow already_AddRefed<> to be passed as an arg.
   RefPtr<ClientOpPromise> p = (mService->*aMethod)(Forward<Args>(aArgs)...);
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
-  p->Then(mService->BackgroundThread(), __func__,
+  p->Then(GetCurrentThreadSerialEventTarget(), __func__,
     [this] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aResult);
     }, [this] (nsresult aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientManagerOpParent::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
diff --git a/dom/clients/manager/ClientManagerService.cpp b/dom/clients/manager/ClientManagerService.cpp
--- a/dom/clients/manager/ClientManagerService.cpp
+++ b/dom/clients/manager/ClientManagerService.cpp
@@ -95,17 +95,16 @@ MatchPrincipalInfo(const PrincipalInfo& 
 
   // TODO: figure out how expanded principal should work
   MOZ_CRASH("unexpected principal type!");
 }
 
 } // anonymous namespace
 
 ClientManagerService::ClientManagerService()
- : mBackgroundThread(AbstractThread::CreateXPCOMThreadWrapper(NS_GetCurrentThread(), false))
 {
   AssertIsOnBackgroundThread();
 }
 
 ClientManagerService::~ClientManagerService()
 {
   AssertIsOnBackgroundThread();
   MOZ_DIAGNOSTIC_ASSERT(mSourceTable.Count() == 0);
@@ -123,22 +122,16 @@ ClientManagerService::GetOrCreateInstanc
   if (!sClientManagerServiceInstance) {
     sClientManagerServiceInstance = new ClientManagerService();
   }
 
   RefPtr<ClientManagerService> ref(sClientManagerServiceInstance);
   return ref.forget();
 }
 
-AbstractThread*
-ClientManagerService::BackgroundThread() const
-{
-  return mBackgroundThread;
-}
-
 void
 ClientManagerService::AddSource(ClientSourceParent* aSource)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aSource);
   auto entry = mSourceTable.LookupForAdd(aSource->Info().Id());
   MOZ_DIAGNOSTIC_ASSERT(!entry);
   entry.OrInsert([&] { return aSource; });
@@ -214,17 +207,16 @@ ClientManagerService::Navigate(const Cli
   return ref.forget();
 }
 
 namespace
 {
 
 class PromiseListHolder final
 {
-  RefPtr<AbstractThread> mTarget;
   RefPtr<ClientOpPromise::Private> mResultPromise;
   nsTArray<RefPtr<ClientOpPromise>> mPromiseList;
   nsTArray<ClientInfoAndState> mResultList;
   uint32_t mOutstandingPromiseCount;
 
   void
   ProcessSuccess(const ClientInfoAndState& aResult)
   {
@@ -237,44 +229,45 @@ class PromiseListHolder final
   {
     MOZ_DIAGNOSTIC_ASSERT(mOutstandingPromiseCount > 0);
     mOutstandingPromiseCount -= 1;
     MaybeFinish();
   }
 
   ~PromiseListHolder() = default;
 public:
-  explicit PromiseListHolder(AbstractThread* aTarget)
-    : mTarget(aTarget)
-    , mResultPromise(new ClientOpPromise::Private(__func__))
+  PromiseListHolder()
+    : mResultPromise(new ClientOpPromise::Private(__func__))
     , mOutstandingPromiseCount(0)
   {
   }
 
   already_AddRefed<ClientOpPromise>
   GetResultPromise()
   {
     RefPtr<PromiseListHolder> kungFuDeathGrip = this;
-    mResultPromise->Then(AbstractThread::GetCurrent(), __func__,
+    mResultPromise->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
       [kungFuDeathGrip] (const ClientOpResult& aResult) { },
       [kungFuDeathGrip] (nsresult aResult) { });
 
     RefPtr<ClientOpPromise> ref = mResultPromise;
     return ref.forget();
   }
 
   void
   AddPromise(already_AddRefed<ClientOpPromise> aPromise)
   {
     mPromiseList.AppendElement(aPromise);
     MOZ_DIAGNOSTIC_ASSERT(mPromiseList.LastElement());
     mOutstandingPromiseCount += 1;
 
     RefPtr<PromiseListHolder> self(this);
-    mPromiseList.LastElement()->Then(mTarget, __func__,
+    mPromiseList.LastElement()->Then(
+      GetCurrentThreadSerialEventTarget(), __func__,
       [self] (const ClientOpResult& aResult) {
         // TODO: This is pretty clunky.  Try to figure out a better
         //       wait for MatchAll() and Claim() to share this code
         //       even though they expect different return values.
         if (aResult.type() == ClientOpResult::TClientInfoAndState) {
           self->ProcessSuccess(aResult.get_ClientInfoAndState());
         } else {
           self->ProcessCompletion();
@@ -304,18 +297,17 @@ ClientManagerService::MatchAll(const Cli
 
   const ClientEndPoint& endpoint = aArgs.endpoint();
 
   const PrincipalInfo& principalInfo =
     endpoint.type() == ClientEndPoint::TIPCClientInfo
       ? endpoint.get_IPCClientInfo().principalInfo()
       : endpoint.get_IPCServiceWorkerDescriptor().principalInfo();
 
-  RefPtr<PromiseListHolder> promiseList =
-    new PromiseListHolder(mBackgroundThread);
+  RefPtr<PromiseListHolder> promiseList = new PromiseListHolder();
 
   for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
     ClientSourceParent* source = iter.UserData();
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
       continue;
     }
@@ -368,18 +360,17 @@ ClientManagerService::MatchAll(const Cli
 already_AddRefed<ClientOpPromise>
 ClientManagerService::Claim(const ClientClaimArgs& aArgs)
 {
   AssertIsOnBackgroundThread();
 
   const IPCServiceWorkerDescriptor& serviceWorker = aArgs.serviceWorker();
   const PrincipalInfo& principalInfo = serviceWorker.principalInfo();
 
-  RefPtr<PromiseListHolder> promiseList =
-    new PromiseListHolder(mBackgroundThread);
+  RefPtr<PromiseListHolder> promiseList = new PromiseListHolder();
 
   for (auto iter = mSourceTable.Iter(); !iter.Done(); iter.Next()) {
     ClientSourceParent* source = iter.UserData();
     MOZ_DIAGNOSTIC_ASSERT(source);
 
     if (source->IsFrozen()) {
       continue;
     }
@@ -429,28 +420,26 @@ ClientManagerService::GetInfoAndState(co
   return source->StartOp(aArgs);
 }
 
 namespace {
 
 class OpenWindowRunnable : public Runnable
 {
   RefPtr<ClientOpPromise::Private> mPromise;
-  RefPtr<AbstractThread> mTarget;
   const ClientOpenWindowArgs mArgs;
   RefPtr<ContentParent> mSourceProcess;
 
   ~OpenWindowRunnable()
   {
     NS_ReleaseOnMainThreadSystemGroup(mSourceProcess.forget());
   }
 
 public:
   OpenWindowRunnable(ClientOpPromise::Private* aPromise,
-                     AbstractThread* aTarget,
                      const ClientOpenWindowArgs& aArgs,
                      already_AddRefed<ContentParent> aSourceProcess)
     : mPromise(aPromise)
     , mArgs(aArgs)
     , mSourceProcess(aSourceProcess)
   {
     MOZ_DIAGNOSTIC_ASSERT(mPromise);
   }
@@ -503,18 +492,20 @@ already_AddRefed<ClientOpPromise>
 ClientManagerService::OpenWindow(const ClientOpenWindowArgs& aArgs,
                                  already_AddRefed<ContentParent> aSourceProcess)
 {
   RefPtr<ClientOpPromise::Private> promise =
     new ClientOpPromise::Private(__func__);
 
   // TODO: How do we clean this up if bg thread and main thread shutdown?
 
-  nsCOMPtr<nsIRunnable> r = new OpenWindowRunnable(promise, mBackgroundThread,
-                                                   aArgs, Move(aSourceProcess));
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(r.forget()));
+  nsCOMPtr<nsIRunnable> r = new OpenWindowRunnable(promise, aArgs,
+                                                   Move(aSourceProcess));
+  MOZ_ALWAYS_SUCCEEDS(SystemGroup::Dispatch("ClientManagerService::OpenWindow",
+                                            TaskCategory::Other,
+                                            r.forget()));
 
   RefPtr<ClientOpPromise> ref = promise;
   return ref.forget();
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientManagerService.h b/dom/clients/manager/ClientManagerService.h
--- a/dom/clients/manager/ClientManagerService.h
+++ b/dom/clients/manager/ClientManagerService.h
@@ -17,32 +17,27 @@ class PrincipalInfo;
 }
 
 namespace dom {
 
 class ClientSourceParent;
 
 class ClientManagerService final
 {
-  RefPtr<AbstractThread> mBackgroundThread;
-
   // Store the ClientSourceParent objects in a hash table.  We want to
   // optimize for insertion, removal, and lookup by UUID.
   nsDataHashtable<nsIDHashKey, ClientSourceParent*> mSourceTable;
 
   ClientManagerService();
   ~ClientManagerService();
 
 public:
   static already_AddRefed<ClientManagerService>
   GetOrCreateInstance();
 
-  AbstractThread*
-  BackgroundThread() const;
-
   void
   AddSource(ClientSourceParent* aSource);
 
   void
   RemoveSource(ClientSourceParent* aSource);
 
   ClientSourceParent*
   FindSource(const nsID& aID,
diff --git a/dom/clients/manager/ClientNavigateOpChild.cpp b/dom/clients/manager/ClientNavigateOpChild.cpp
--- a/dom/clients/manager/ClientNavigateOpChild.cpp
+++ b/dom/clients/manager/ClientNavigateOpChild.cpp
@@ -155,16 +155,18 @@ ClientNavigateOpChild::DoNavigate(const 
   if (!window) {
     ref = ClientOpPromise::CreateAndReject(NS_ERROR_DOM_INVALID_STATE_ERR,
                                            __func__);
     return ref.forget();
   }
 
   MOZ_ASSERT(NS_IsMainThread());
 
+  mSerialEventTarget = window->EventTargetFor(TaskCategory::Other);
+
   // In theory we could do the URL work before paying the IPC overhead
   // cost, but in practice its easier to do it here.  The ClientHandle
   // may be off-main-thread while this method is guaranteed to always
   // be main thread.
   nsCOMPtr<nsIURI> baseURL;
   nsresult rv = NS_NewURI(getter_AddRefs(baseURL), aArgs.baseURL());
   if (NS_FAILED(rv)) {
     ref = ClientOpPromise::CreateAndReject(rv, __func__);
@@ -230,34 +232,42 @@ ClientNavigateOpChild::DoNavigate(const 
   if (NS_FAILED(rv)) {
     promise->Reject(rv, __func__);
     ref = promise;
     return ref.forget();
   }
 
   ref = promise.get();
 
-  ref->Then(AbstractThread::GetCurrent(), __func__,
+  ref->Then(mSerialEventTarget, __func__,
     [listener] (const ClientOpResult& aResult) { },
     [listener] (nsresult aResult) { });
 
   return ref.forget();
 }
 
 void
 ClientNavigateOpChild::ActorDestroy(ActorDestroyReason aReason)
 {
   mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientNavigateOpChild::Init(const ClientNavigateOpConstructorArgs& aArgs)
 {
   RefPtr<ClientOpPromise> promise = DoNavigate(aArgs);
-  promise->Then(AbstractThread::GetCurrent(), __func__,
+
+  // Normally we get the event target from the window in DoNavigate().  If a
+  // failure occurred, though, we may need to fall back to the current thread
+  // target.
+  if (!mSerialEventTarget) {
+    mSerialEventTarget = GetCurrentThreadSerialEventTarget();
+  }
+
+  promise->Then(mSerialEventTarget, __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
     }, [this] (nsresult aResult) {
       mPromiseRequestHolder.Complete();
       PClientNavigateOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
diff --git a/dom/clients/manager/ClientNavigateOpChild.h b/dom/clients/manager/ClientNavigateOpChild.h
--- a/dom/clients/manager/ClientNavigateOpChild.h
+++ b/dom/clients/manager/ClientNavigateOpChild.h
@@ -12,16 +12,17 @@
 namespace mozilla {
 namespace dom {
 
 class ClientSource;
 
 class ClientNavigateOpChild final : public PClientNavigateOpChild
 {
   MozPromiseRequestHolder<ClientOpPromise> mPromiseRequestHolder;
+  nsCOMPtr<nsISerialEventTarget> mSerialEventTarget;
 
   already_AddRefed<ClientOpPromise>
   DoNavigate(const ClientNavigateOpConstructorArgs& aArgs);
 
   // PClientNavigateOpChild interface
   void
   ActorDestroy(ActorDestroyReason aReason) override;
 
diff --git a/dom/clients/manager/ClientOpenWindowOpChild.cpp b/dom/clients/manager/ClientOpenWindowOpChild.cpp
--- a/dom/clients/manager/ClientOpenWindowOpChild.cpp
+++ b/dom/clients/manager/ClientOpenWindowOpChild.cpp
@@ -1,17 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ClientOpenWindowOpChild.h"
 #include "ClientOpenWindowUtils.h"
-#include "mozilla/AbstractThread.h"
+#include "mozilla/SystemGroup.h"
 
 namespace mozilla {
 namespace dom {
 
 already_AddRefed<ClientOpPromise>
 ClientOpenWindowOpChild::DoOpenWindow(const ClientOpenWindowArgs& aArgs)
 {
   RefPtr<ClientOpPromise> ref =
@@ -24,17 +24,17 @@ ClientOpenWindowOpChild::ActorDestroy(Ac
 {
   mPromiseRequestHolder.DisconnectIfExists();
 }
 
 void
 ClientOpenWindowOpChild::Init(const ClientOpenWindowArgs& aArgs)
 {
   RefPtr<ClientOpPromise> promise = DoOpenWindow(aArgs);
-  promise->Then(AbstractThread::GetCurrent(), __func__,
+  promise->Then(SystemGroup::EventTargetFor(TaskCategory::Other), __func__,
     [this] (const ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
     }, [this] (nsresult aResult) {
       mPromiseRequestHolder.Complete();
       PClientOpenWindowOpChild::Send__delete__(this, aResult);
     })->Track(mPromiseRequestHolder);
 }
diff --git a/dom/clients/manager/ClientOpenWindowUtils.cpp b/dom/clients/manager/ClientOpenWindowUtils.cpp
--- a/dom/clients/manager/ClientOpenWindowUtils.cpp
+++ b/dom/clients/manager/ClientOpenWindowUtils.cpp
@@ -300,17 +300,17 @@ WaitForLoad(const ClientOpenWindowArgs& 
   rv = webProgress->AddProgressListener(listener,
                                         nsIWebProgress::NOTIFY_STATE_DOCUMENT);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     promise->Reject(rv, __func__);
     return;
   }
 
   // Hold the listener alive until the promise settles
-  ref->Then(AbstractThread::GetCurrent(), __func__,
+  ref->Then(aOuterWindow->EventTargetFor(TaskCategory::Other), __func__,
     [listener] (const ClientOpResult& aResult) { },
     [listener] (nsresult aResult) { });
 }
 
 #ifdef MOZ_WIDGET_ANDROID
 
 class LaunchObserver final : public nsIObserver
 {
@@ -397,17 +397,17 @@ ClientOpenWindowInCurrentProcess(const C
   nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
 
 #ifdef MOZ_WIDGET_ANDROID
   // If we get the NOT_AVAILABLE error that means the browser is still
   // launching on android.  Use the observer we created above to wait
   // until the launch completes and then try to open the window again.
   if (rv == NS_ERROR_NOT_AVAILABLE && launchObserver) {
     RefPtr<GenericPromise> p = launchObserver->Promise();
-    p->Then(AbstractThread::GetCurrent(), __func__,
+    p->Then(outerWindow->EventTargetFor(TaskCategory::Other), __func__,
       [aArgs, promise] (bool aResult) {
         nsCOMPtr<nsPIDOMWindowOuter> outerWindow;
         nsresult rv = OpenWindow(aArgs, getter_AddRefs(outerWindow));
         if (NS_WARN_IF(NS_FAILED(rv))) {
           promise->Reject(rv, __func__);
         }
 
         WaitForLoad(aArgs, outerWindow, promise);
diff --git a/dom/clients/manager/ClientSource.cpp b/dom/clients/manager/ClientSource.cpp
--- a/dom/clients/manager/ClientSource.cpp
+++ b/dom/clients/manager/ClientSource.cpp
@@ -589,17 +589,17 @@ ClientSource::Claim(const ClientClaimArg
     ref = ClientOpPromise::CreateAndResolve(NS_OK, __func__);
     return ref.forget();
   }
 
   RefPtr<ClientOpPromise::Private> outerPromise =
     new ClientOpPromise::Private(__func__);
 
   RefPtr<GenericPromise> p = swm->MaybeClaimClient(doc, swd);
-  p->Then(AbstractThread::GetCurrent(), __func__,
+  p->Then(innerWindow->EventTargetFor(TaskCategory::Other), __func__,
     [outerPromise] (bool aResult) {
       outerPromise->Resolve(NS_OK, __func__);
     }, [outerPromise] (nsresult aResult) {
       outerPromise->Reject(aResult, __func__);
     });
 
   ref = outerPromise;
   return ref.forget();
@@ -638,10 +638,33 @@ ClientSource::SnapshotState(ClientState*
     }
     return NS_OK;
   }
 
   *aStateOut = ClientState(ClientWorkerState());
   return NS_OK;
 }
 
+nsISerialEventTarget*
+ClientSource::EventTargetFor(TaskCategory aCat) const
+{
+  nsPIDOMWindowInner* innerWindow = GetInnerWindow();
+  if (innerWindow) {
+    return innerWindow->EventTargetFor(aCat);
+  }
+
+  WorkerPrivate* workerPrivate = GetWorkerPrivate();
+  if (workerPrivate) {
+    nsCOMPtr<nsISerialEventTarget> target = workerPrivate->GetEventTarget();
+    return target;
+  }
+
+  nsIDocShell* docshell = GetDocShell();
+  nsPIDOMWindowOuter* outerWindow = docshell ? docshell->GetWindow() : nullptr;
+  if (outerWindow) {
+    return outerWindow->EventTargetFor(aCat);
+  }
+
+  return SystemGroup::EventTargetFor(aCat);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/clients/manager/ClientSource.h b/dom/clients/manager/ClientSource.h
--- a/dom/clients/manager/ClientSource.h
+++ b/dom/clients/manager/ClientSource.h
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 #ifndef _mozilla_dom_ClientSource_h
 #define _mozilla_dom_ClientSource_h
 
 #include "mozilla/dom/ClientInfo.h"
 #include "mozilla/dom/ClientThing.h"
 #include "mozilla/dom/ServiceWorkerDescriptor.h"
+#include "mozilla/TaskCategory.h"
 #include "mozilla/Variant.h"
 #include "ClientOpPromise.h"
 
 #ifdef XP_WIN
 #undef PostMessage
 #endif
 
 class nsIDocShell;
@@ -130,14 +131,17 @@ public:
   already_AddRefed<ClientOpPromise>
   Claim(const ClientClaimArgs& aArgs);
 
   already_AddRefed<ClientOpPromise>
   GetInfoAndState(const ClientGetInfoAndStateArgs& aArgs);
 
   nsresult
   SnapshotState(ClientState* aStateOut);
+
+  nsISerialEventTarget*
+  EventTargetFor(TaskCategory aCat) const;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // _mozilla_dom_ClientSource_h
diff --git a/dom/clients/manager/ClientSourceOpChild.cpp b/dom/clients/manager/ClientSourceOpChild.cpp
--- a/dom/clients/manager/ClientSourceOpChild.cpp
+++ b/dom/clients/manager/ClientSourceOpChild.cpp
@@ -30,17 +30,17 @@ ClientSourceOpChild::DoSourceOp(Method a
     return;
   }
 
   RefPtr<ClientOpPromise> p = (source->*aMethod)(aArgs);
 
   // Capturing `this` is safe here because we disconnect the promise in
   // ActorDestroy() which ensures neither lambda is called if the actor
   // is destroyed before the source operation completes.
-  p->Then(AbstractThread::GetCurrent(), __func__,
+  p->Then(source->EventTargetFor(TaskCategory::Other), __func__,
     [this, aArgs] (const mozilla::dom::ClientOpResult& aResult) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aResult);
     }, [this] (nsresult aRv) {
       mPromiseRequestHolder.Complete();
       Unused << PClientSourceOpChild::Send__delete__(this, aRv);
     })->Track(mPromiseRequestHolder);
 }
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -2446,17 +2446,18 @@ ServiceWorkerManager::StartControllingAD
     aDoc->SetId(aDocumentId);
   }
   ServiceWorkerInfo* activeWorker = aRegistration->GetActive();
   nsPIDOMWindowInner* innerWindow = aDoc->GetInnerWindow();
   if (activeWorker && innerWindow) {
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     if (clientInfo.isSome()) {
       RefPtr<ClientHandle> clientHandle =
-        ClientManager::CreateHandle(clientInfo.ref());
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    SystemGroup::EventTargetFor(TaskCategory::Other));
       if (clientHandle) {
         ref = clientHandle->Control(activeWorker->Descriptor());
       }
     }
   }
   Telemetry::Accumulate(Telemetry::SERVICE_WORKER_CONTROLLED_DOCUMENTS, 1);
   return ref.forget();
 }
@@ -2773,17 +2774,18 @@ ServiceWorkerManager::DispatchFetchEvent
       if (clientInfo.isNothing()) {
         clientInfo = loadInfo->GetInitialClientInfo();
       }
       if (clientInfo.isSome()) {
         // First, attempt to mark the reserved client controlled directly.  This
         // will update the controlled status in the ClientManagerService in the
         // parent.  It will also eventually propagate back to the ClientSource.
         RefPtr<ClientHandle> clientHandle =
-          ClientManager::CreateHandle(clientInfo.ref());
+          ClientManager::CreateHandle(clientInfo.ref(),
+                                      SystemGroup::EventTargetFor(TaskCategory::Other));
         if (clientHandle) {
           RefPtr<GenericPromise> p =
             clientHandle->Control(serviceWorker->Descriptor());
         }
 
         // But we also note the reserved state on the LoadInfo.  This allows the
         // ClientSource to be updated immediately after the nsIChannel starts.
         // This is necessary to have the correct controller in place for immediate
@@ -3549,17 +3551,18 @@ ServiceWorkerManager::UpdateClientContro
     nsPIDOMWindowInner* innerWindow = doc->GetInnerWindow();
     if (NS_WARN_IF(!innerWindow)) {
       continue;
     }
 
     Maybe<ClientInfo> clientInfo = innerWindow->GetClientInfo();
     if (clientInfo.isSome()) {
       RefPtr<ClientHandle> clientHandle =
-        ClientManager::CreateHandle(clientInfo.ref());
+        ClientManager::CreateHandle(clientInfo.ref(),
+                                    innerWindow->EventTargetFor(TaskCategory::Other));
       if (clientHandle) {
         RefPtr<GenericPromise> p =
           clientHandle->Control(activeWorker->Descriptor());
       }
     }
   }
 }
 
