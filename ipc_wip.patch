# HG changeset patch
# Parent  c446fa70b699077f0b2affcdee7eb8cbe86d46ea

diff --git a/dom/plugins/ipc/PluginMessageUtils.h b/dom/plugins/ipc/PluginMessageUtils.h
--- a/dom/plugins/ipc/PluginMessageUtils.h
+++ b/dom/plugins/ipc/PluginMessageUtils.h
@@ -31,16 +31,18 @@
 #else
 namespace mac_plugin_interposing { class NSCursorInfo { }; }
 #endif
 using mac_plugin_interposing::NSCursorInfo;
 #ifdef XP_WIN
 #include "commdlg.h"
 #endif
 
+#include "base/shared_memory.h"
+
 namespace mozilla {
 namespace plugins {
 
 using layers::SurfaceDescriptorX11;
 
 enum ScriptableObjectType
 {
   LocalObject,
diff --git a/ipc/chromium/src/base/time.h b/ipc/chromium/src/base/time.h
--- a/ipc/chromium/src/base/time.h
+++ b/ipc/chromium/src/base/time.h
@@ -23,17 +23,17 @@
 
 #ifndef BASE_TIME_H_
 #define BASE_TIME_H_
 
 #include <time.h>
 
 #include "base/basictypes.h"
 
-#if defined(OS_WIN)
+#if 0 && defined(OS_WIN)
 // For FILETIME in FromFileTime, until it moves to a new converter class.
 // See TODO(iyengar) below.
 #include <windows.h>
 #endif
 
 namespace base {
 
 class Time;
@@ -222,17 +222,17 @@ class Time {
   time_t ToTimeT() const;
 
   // Converts time to/from a double which is the number of seconds since epoch
   // (Jan 1, 1970).  Webkit uses this format to represent time.
   static Time FromDoubleT(double dt);
   double ToDoubleT() const;
 
 
-#if defined(OS_WIN)
+#if 0 && defined(OS_WIN)
   static Time FromFileTime(FILETIME ft);
   FILETIME ToFileTime() const;
 #endif
 
   // Converts an exploded structure representing either the local time or UTC
   // into a Time class.
   static Time FromUTCExploded(const Exploded& exploded) {
     return FromExploded(false, exploded);
@@ -466,17 +466,17 @@ class TimeTicks {
   // Please use Now() to create a new object. This is for internal use
   // and testing. Ticks is in microseconds.
   explicit TimeTicks(int64_t ticks) : ticks_(ticks) {
   }
 
   // Tick count in microseconds.
   int64_t ticks_;
 
-#if defined(OS_WIN)
+#if 0 && defined(OS_WIN)
   typedef DWORD (*TickFunctionType)(void);
   static TickFunctionType SetMockTickFunction(TickFunctionType ticker);
 #endif
 };
 
 inline TimeTicks TimeDelta::operator+(TimeTicks t) const {
   return TimeTicks(t.ticks_ + delta_);
 }
diff --git a/ipc/chromium/src/chrome/common/ipc_message_utils.h b/ipc/chromium/src/chrome/common/ipc_message_utils.h
--- a/ipc/chromium/src/chrome/common/ipc_message_utils.h
+++ b/ipc/chromium/src/chrome/common/ipc_message_utils.h
@@ -15,17 +15,17 @@
 #include "base/string_util.h"
 #include "base/string16.h"
 #include "base/time.h"
 
 #if defined(OS_POSIX)
 #include "chrome/common/file_descriptor_set_posix.h"
 #endif
 #include "chrome/common/ipc_message.h"
-#include "chrome/common/transport_dib.h"
+//#include "chrome/common/transport_dib.h"
 
 namespace IPC {
 
 //-----------------------------------------------------------------------------
 // An iterator class for reading the fields contained within a Message.
 
 class MessageIterator {
  public:
@@ -382,17 +382,17 @@ struct ParamTraitsStd<std::map<K, V> > {
   }
 };
 
 // Windows-specific types.
 
 template <class P>
 struct ParamTraitsWindows : ParamTraitsStd<P> {};
 
-#if defined(OS_WIN)
+#if 0 && defined(OS_WIN)
 template <>
 struct ParamTraitsWindows<HANDLE> {
   typedef HANDLE param_type;
   static void Write(Message* m, const param_type& p) {
     m->WriteIntPtr(reinterpret_cast<intptr_t>(p));
   }
   static bool Read(const Message* m, PickleIterator* iter, param_type* r) {
     DCHECK_EQ(sizeof(param_type), sizeof(intptr_t));
@@ -471,17 +471,17 @@ struct ParamTraitsIPC<base::FileDescript
       l->append(StringPrintf(L"FD(%d auto-close)", p.fd));
     } else {
       l->append(StringPrintf(L"FD(%d)", p.fd));
     }
   }
 };
 #endif // defined(OS_POSIX)
 
-#if defined(OS_WIN)
+#if 0 && defined(OS_WIN)
 template<>
 struct ParamTraitsIPC<TransportDIB::Id> {
   typedef TransportDIB::Id param_type;
   static void Write(Message* m, const param_type& p) {
     WriteParam(m, p.handle);
     WriteParam(m, p.sequence_num);
   }
   static bool Read(const Message* m, PickleIterator* iter, param_type* r) {
diff --git a/ipc/glue/Transport_win.cpp b/ipc/glue/Transport_win.cpp
--- a/ipc/glue/Transport_win.cpp
+++ b/ipc/glue/Transport_win.cpp
@@ -8,16 +8,35 @@
 
 #include "mozilla/ipc/Transport.h"
 #include "mozilla/ipc/ProtocolUtils.h"
 
 using namespace std;
 
 using base::ProcessHandle;
 
+// Mozilla-specific types.
+
+template <class P>
+struct ParamTraitsMozilla : ParamTraitsIPC<P> {};
+
+template <>
+struct ParamTraitsMozilla<nsresult> {
+  typedef nsresult param_type;
+  static void Write(Message* m, const param_type& p) {
+    m->WriteUInt32(static_cast<uint32_t>(p));
+  }
+  static bool Read(const Message* m, PickleIterator* iter, param_type* r) {
+    return m->ReadUInt32(iter, reinterpret_cast<uint32_t*>(r));
+  }
+  static void Log(const param_type& p, std::wstring* l) {
+    l->append(StringPrintf(L"%u", static_cast<uint32_t>(p)));
+  }
+};
+
 namespace mozilla {
 namespace ipc {
 
 nsresult
 CreateTransport(base::ProcessId aProcIdOne,
                 TransportDescriptor* aOne,
                 TransportDescriptor* aTwo)
 {
diff --git a/ipc/glue/Transport_win.h b/ipc/glue/Transport_win.h
--- a/ipc/glue/Transport_win.h
+++ b/ipc/glue/Transport_win.h
@@ -31,16 +31,26 @@ TransferHandleToProcess(HANDLE source, b
 
 
 namespace IPC {
 
 template<>
 struct ParamTraits<mozilla::ipc::TransportDescriptor>
 {
   typedef mozilla::ipc::TransportDescriptor paramType;
+  static void _Write(Message* m, const HANDLE& p) {
+    m->WriteIntPtr(reinterpret_cast<intptr_t>(p));
+  }
+  static bool _Read(const Message* m, PickleIterator* iter, HANDLE* r) {
+    DCHECK_EQ(sizeof(HANDLE), sizeof(intptr_t));
+    return m->ReadIntPtr(iter, reinterpret_cast<intptr_t*>(r));
+  }
+  static void _Log(const HANDLE& p, std::wstring* l) {
+    l->append(StringPrintf(L"0x%X", p));
+  }
   static void Write(Message* aMsg, const paramType& aParam)
   {
     HANDLE pipe = mozilla::ipc::TransferHandleToProcess(aParam.mServerPipeHandle,
                                                         aParam.mDestinationProcessId);
     DWORD duplicateFromProcessId = 0;
     if (!pipe) {
       if (XRE_IsParentProcess()) {
         // If we are the parent and failed to transfer then there is no hope,
@@ -49,25 +59,25 @@ struct ParamTraits<mozilla::ipc::Transpo
       } else {
         // We are probably sending to parent so it should be able to duplicate.
         pipe = aParam.mServerPipeHandle;
         duplicateFromProcessId = ::GetCurrentProcessId();
       }
     }
 
     WriteParam(aMsg, aParam.mPipeName);
-    WriteParam(aMsg, pipe);
+    _Write(aMsg, pipe);
     WriteParam(aMsg, duplicateFromProcessId);
     WriteParam(aMsg, aParam.mDestinationProcessId);
   }
   static bool Read(const Message* aMsg, PickleIterator* aIter, paramType* aResult)
   {
     DWORD duplicateFromProcessId;
     bool r = (ReadParam(aMsg, aIter, &aResult->mPipeName) &&
-              ReadParam(aMsg, aIter, &aResult->mServerPipeHandle) &&
+              _Read(aMsg, aIter, &aResult->mServerPipeHandle) &&
               ReadParam(aMsg, aIter, &duplicateFromProcessId) &&
               ReadParam(aMsg, aIter, &aResult->mDestinationProcessId));
     if (!r) {
       return r;
     }
 
     MOZ_RELEASE_ASSERT(aResult->mServerPipeHandle,
                        "Main process failed to duplicate pipe handle to child.");
