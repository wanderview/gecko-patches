# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  b940c45b9e07992c5e92f872d22c8b0ed3ac7437

diff --git a/netwerk/protocol/http/HttpChannelParent.cpp b/netwerk/protocol/http/HttpChannelParent.cpp
--- a/netwerk/protocol/http/HttpChannelParent.cpp
+++ b/netwerk/protocol/http/HttpChannelParent.cpp
@@ -14,16 +14,17 @@
 #include "mozilla/dom/Element.h"
 #include "mozilla/dom/TabParent.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/UniquePtr.h"
 #include "mozilla/Unused.h"
 #include "HttpBackgroundChannelParent.h"
 #include "HttpChannelParentListener.h"
+#include "InterceptedHttpChannel.h"
 #include "nsHttpHandler.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
 #include "nsISupportsPriority.h"
 #include "nsIAuthPromptProvider.h"
 #include "nsIBackgroundChannelRegistrar.h"
 #include "nsSerializationHelper.h"
 #include "nsISerializable.h"
@@ -47,16 +48,17 @@
 #include "nsIWindowWatcher.h"
 #include "nsIDocument.h"
 #include "nsStreamUtils.h"
 #include "nsStringStream.h"
 #include "nsIStorageStream.h"
 #include "nsThreadUtils.h"
 #include "nsQueryObject.h"
 #include "nsIURIClassifier.h"
+#include "mozilla/ErrorNames.h"
 
 using mozilla::BasePrincipal;
 using namespace mozilla::dom;
 using namespace mozilla::ipc;
 
 namespace mozilla {
 namespace net {
 
@@ -71,16 +73,17 @@ HttpChannelParent::HttpChannelParent(con
   , mLoadContext(aLoadContext)
   , mStatus(NS_OK)
   , mPendingDiversion(false)
   , mDivertingFromChild(false)
   , mDivertedOnStartRequest(false)
   , mSuspendedForDiversion(false)
   , mSuspendAfterSynthesizeResponse(false)
   , mWillSynthesizeResponse(false)
+  , mSynthesizedRedirectWillSuspend(false)
   , mNestedFrameId(0)
 {
   LOG(("Creating HttpChannelParent [this=%p]\n", this));
 
   // Ensure gHttpHandler is initialized: we need the atom table up and running.
   nsCOMPtr<nsIHttpProtocolHandler> dummyInitializer =
     do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http");
 
@@ -122,16 +125,17 @@ HttpChannelParent::ActorDestroy(ActorDes
 bool
 HttpChannelParent::Init(const HttpChannelCreationArgs& aArgs)
 {
   LOG(("HttpChannelParent::Init [this=%p]\n", this));
   switch (aArgs.type()) {
   case HttpChannelCreationArgs::THttpChannelOpenArgs:
   {
     const HttpChannelOpenArgs& a = aArgs.get_HttpChannelOpenArgs();
+    nsCOMPtr<nsIURI> uri = DeserializeURI(a.uri());
     return DoAsyncOpen(a.uri(), a.original(), a.doc(), a.referrer(),
                        a.referrerPolicy(), a.apiRedirectTo(), a.topWindowURI(),
                        a.loadFlags(), a.requestHeaders(),
                        a.requestMethod(), a.uploadStream(),
                        a.uploadStreamHasHeaders(), a.priority(), a.classOfService(),
                        a.redirectionLimit(), a.allowSTS(),
                        a.thirdPartyFlags(), a.resumeAt(), a.startPos(),
                        a.entityID(), a.chooseApplicationCache(),
@@ -387,16 +391,22 @@ HttpChannelParent::InvokeAsyncOpen(nsres
     rv = mChannel->AsyncOpen2(mParentListener);
   }
   else {
     rv = mChannel->AsyncOpen(mParentListener, nullptr);
   }
   if (NS_FAILED(rv)) {
     AsyncOpenFailed(rv);
   }
+
+  if (mWillSynthesizeResponse && mSuspendAfterSynthesizeResponse) {
+    mChannel->Suspend();
+    mWillSynthesizeResponse = false;
+    MaybeFlushPendingDiversion();
+  }
 }
 
 namespace {
 class InvokeAsyncOpen : public Runnable
 {
   nsMainThreadPtrHandle<nsIInterfaceRequestor> mChannel;
   nsresult mStatus;
 public:
@@ -512,27 +522,68 @@ HttpChannelParent::DoAsyncOpen(  const U
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   if (!loadInfo) {
     return SendFailedAsyncOpen(NS_ERROR_UNEXPECTED);
   }
 
-  nsCOMPtr<nsIChannel> channel;
-  rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
-                             nullptr, nullptr, aLoadFlags, ios);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
+  RefPtr<HttpBaseChannel> httpChannel;
+
+  if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
+    const nsHttpResponseHead& head =
+      aSynthesizedResponseHead.get_nsHttpResponseHead();
+
+    nsCOMPtr<nsIInputStream> body;
+    rv = NS_NewCStringInputStream(getter_AddRefs(body), EmptyCString());
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    RefPtr<InterceptedHttpChannel> intercepted =
+      InterceptedHttpChannel::CreateForSynthesis(&head, body);
+    if (NS_WARN_IF(!intercepted)) {
+      return SendFailedAsyncOpen(NS_ERROR_FAILURE);
+    }
+
+    if (nsHttpChannel::WillRedirect(const_cast<nsHttpResponseHead*>(&head))) {
+      intercepted->AutoSuspendRedirectChannel();
+      mSynthesizedRedirectWillSuspend = true;
+    }
+
+    httpChannel = intercepted.forget();
+
+    rv = httpChannel->Init(uri, 0, nullptr, 0, nullptr, aChannelId);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    rv = httpChannel->SetLoadInfo(loadInfo);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    mWillSynthesizeResponse = true;
+
+  } else {
+    nsCOMPtr<nsIChannel> channel;
+    rv = NS_NewChannelInternal(getter_AddRefs(channel), uri, loadInfo,
+                               nullptr, nullptr, aLoadFlags, ios);
+    if (NS_FAILED(rv)) {
+      return SendFailedAsyncOpen(rv);
+    }
+
+    httpChannel = do_QueryObject(channel);
+    if (!httpChannel) {
+      return SendFailedAsyncOpen(NS_ERROR_FAILURE);
+    }
   }
 
-  RefPtr<HttpBaseChannel> httpChannel = do_QueryObject(channel, &rv);
-  if (NS_FAILED(rv)) {
-    return SendFailedAsyncOpen(rv);
-  }
+  MOZ_DIAGNOSTIC_ASSERT(httpChannel);
 
   // Set the channelId allocated in child to the parent instance
   rv = httpChannel->SetChannelId(aChannelId);
   MOZ_ALWAYS_SUCCEEDS(rv);
   rv = httpChannel->SetTopLevelContentWindowId(aContentWindowId);
   MOZ_ALWAYS_SUCCEEDS(rv);
   rv = httpChannel->SetTopLevelOuterContentWindowId(aTopLevelOuterContentWindowId);
   MOZ_ALWAYS_SUCCEEDS(rv);
@@ -655,16 +706,17 @@ HttpChannelParent::DoAsyncOpen(  const U
 
       httpChannelImpl->InternalSetUploadStream(newUploadStream);
     } else {
       httpChannelImpl->InternalSetUploadStream(stream);
     }
     httpChannelImpl->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
   }
 
+  /*
   if (aSynthesizedResponseHead.type() == OptionalHttpResponseHead::TnsHttpResponseHead) {
     parentListener->SetupInterception(aSynthesizedResponseHead.get_nsHttpResponseHead());
     mWillSynthesizeResponse = true;
     httpChannelImpl->SetCouldBeSynthesized();
 
     if (!aSecurityInfoSerialization.IsEmpty()) {
       nsCOMPtr<nsISupports> secInfo;
       NS_DeserializeObject(aSecurityInfoSerialization, getter_AddRefs(secInfo));
@@ -672,16 +724,17 @@ HttpChannelParent::DoAsyncOpen(  const U
       MOZ_ASSERT(NS_SUCCEEDED(rv));
     }
   } else {
     nsLoadFlags newLoadFlags;
     httpChannel->GetLoadFlags(&newLoadFlags);
     newLoadFlags |= nsIChannel::LOAD_BYPASS_SERVICE_WORKER;
     httpChannel->SetLoadFlags(newLoadFlags);
   }
+  */
 
   nsCOMPtr<nsISupportsPRUint32> cacheKey =
     do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
   if (NS_FAILED(rv)) {
     return SendFailedAsyncOpen(rv);
   }
 
   rv = cacheKey->SetData(aCacheKey);
@@ -857,19 +910,19 @@ HttpChannelParent::ConnectChannel(const 
 
   RefPtr<nsHttpChannel> httpChannelImpl = do_QueryObject(mChannel);
   if (httpChannelImpl) {
     httpChannelImpl->SetWarningReporter(this);
   }
 
   nsCOMPtr<nsINetworkInterceptController> controller;
   NS_QueryNotificationCallbacks(channel, controller);
-  RefPtr<HttpChannelParentListener> parentListener = do_QueryObject(controller);
-  MOZ_ASSERT(parentListener);
-  parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
+  //RefPtr<HttpChannelParentListener> parentListener = do_QueryObject(controller);
+  //MOZ_ASSERT(parentListener);
+  //parentListener->SetupInterceptionAfterRedirect(shouldIntercept);
 
   if (mPBOverride != kPBOverride_Unset) {
     // redirected-to channel may not support PB
     nsCOMPtr<nsIPrivateBrowsingChannel> pbChannel = do_QueryObject(mChannel);
     if (pbChannel) {
       pbChannel->SetPrivate(mPBOverride == kPBOverride_Private ? true : false);
     }
   }
@@ -1497,19 +1550,17 @@ HttpChannelParent::OnStartRequest(nsIReq
       if (mIPCClosed ||
           !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
       {
         return NS_ERROR_UNEXPECTED;
       }
     }
   }
 
-  nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(aRequest);
-  if (encodedChannel)
-    encodedChannel->SetApplyConversion(false);
+  chan->SetApplyConversion(false);
 
   // Keep the cache entry for future use in RecvSetCacheTokenCachedCharset().
   // It could be already released by nsHttpChannel at that time.
   nsCOMPtr<nsISupports> cacheEntry;
   nsresult channelStatus = NS_OK;
   uint32_t cacheKeyValue = 0;
   nsAutoCString altDataType;
 
@@ -1585,16 +1636,17 @@ HttpChannelParent::OnStopRequest(nsIRequ
                                  nsresult aStatusCode)
 {
   LOG(("HttpChannelParent::OnStopRequest: [this=%p aRequest=%p status=%" PRIx32 "]\n",
        this, aRequest, static_cast<uint32_t>(aStatusCode)));
   MOZ_ASSERT(NS_IsMainThread());
 
   MOZ_RELEASE_ASSERT(!mDivertingFromChild,
     "Cannot call OnStopRequest if diverting is set!");
+
   ResourceTimingStruct timing;
   mChannel->GetDomainLookupStart(&timing.domainLookupStart);
   mChannel->GetDomainLookupEnd(&timing.domainLookupEnd);
   mChannel->GetConnectStart(&timing.connectStart);
   mChannel->GetSecureConnectionStart(&timing.secureConnectionStart);
   mChannel->GetConnectEnd(&timing.connectEnd);
   mChannel->GetRequestStart(&timing.requestStart);
   mChannel->GetResponseStart(&timing.responseStart);
@@ -2249,22 +2301,28 @@ HttpChannelParent::RecvDeletingChannel()
     return IPC_FAIL_NO_REASON(this);
   }
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 HttpChannelParent::RecvFinishInterceptedRedirect()
 {
+
   // We make sure not to send any more messages until the IPC channel is torn
   // down by the child.
   mIPCClosed = true;
   if (!SendFinishInterceptedRedirect()) {
     return IPC_FAIL_NO_REASON(this);
   }
+
+  // Resume the channel since we called
+  // InterceptedHttpChannel::AutoSuspendRedirectChannel earlier.
+  mChannel->Resume();
+
   return IPC_OK();
 }
 
 //-----------------------------------------------------------------------------
 // HttpChannelSecurityWarningReporter
 //-----------------------------------------------------------------------------
 
 nsresult
diff --git a/netwerk/protocol/http/HttpChannelParent.h b/netwerk/protocol/http/HttpChannelParent.h
--- a/netwerk/protocol/http/HttpChannelParent.h
+++ b/netwerk/protocol/http/HttpChannelParent.h
@@ -301,16 +301,17 @@ private:
   bool mDivertedOnStartRequest;
 
   bool mSuspendedForDiversion;
 
   // Set if this channel should be suspended after synthesizing a response.
   bool mSuspendAfterSynthesizeResponse;
   // Set if this channel will synthesize its response.
   bool mWillSynthesizeResponse;
+  bool mSynthesizedRedirectWillSuspend;
 
   dom::TabId mNestedFrameId;
 
   RefPtr<ChannelEventQueue> mEventQ;
 
   RefPtr<HttpBackgroundChannelParent> mBgParent;
 
   // Number of events to wait before actually invoking AsyncOpen on the main
