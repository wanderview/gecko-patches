# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  076a7a66096f9e8d102548397254be32eb26bc3d

diff --git a/dom/base/Element.cpp b/dom/base/Element.cpp
--- a/dom/base/Element.cpp
+++ b/dom/base/Element.cpp
@@ -643,18 +643,18 @@ Element::GetScrollFrame(nsIFrame **aStyl
     *aStyledFrame = frame;
   }
   if (!frame) {
     return nullptr;
   }
 
   // menu frames implement GetScrollTargetFrame but we don't want
   // to use it here.  Similar for comboboxes.
-  FrameType type = frame->Type();
-  if (type != FrameType::Menu && type != FrameType::ComboboxControl) {
+  mozilla::FrameType type = frame->Type();
+  if (type != mozilla::FrameType::Menu && type != mozilla::FrameType::ComboboxControl) {
     nsIScrollableFrame *scrollFrame = frame->GetScrollTargetFrame();
     if (scrollFrame)
       return scrollFrame;
   }
 
   nsIDocument* doc = OwnerDoc();
   bool quirksMode = doc->GetCompatibilityMode() == eCompatibility_NavQuirks;
   Element* elementWithRootScrollInfo =
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -2712,17 +2712,17 @@ nsFocusManager::DetermineElementToMoveFo
         ignoreTabIndex = true;
     }
 
     // check if the focus is currently inside a popup. Elements such as the
     // autocomplete widget use the noautofocus attribute to allow the focus to
     // remain outside the popup when it is opened.
     if (frame) {
       popupFrame =
-        nsLayoutUtils::GetClosestFrameOfType(frame, FrameType::MenuPopup);
+        nsLayoutUtils::GetClosestFrameOfType(frame, mozilla::FrameType::MenuPopup);
     }
 
     if (popupFrame && !forDocumentNavigation) {
       // Don't navigate outside of a popup, so pretend that the
       // root content is the popup itself
       rootContent = popupFrame->GetContent();
       NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
     }
@@ -2939,17 +2939,17 @@ nsFocusManager::DetermineElementToMoveFo
 
       // if the frame is inside a popup, make sure to scan only within the
       // popup. This handles the situation of tabbing amongst elements
       // inside an iframe which is itself inside a popup. Otherwise,
       // navigation would move outside the popup when tabbing outside the
       // iframe.
       if (!forDocumentNavigation) {
         popupFrame =
-          nsLayoutUtils::GetClosestFrameOfType(frame, FrameType::MenuPopup);
+          nsLayoutUtils::GetClosestFrameOfType(frame, mozilla::FrameType::MenuPopup);
         if (popupFrame) {
           rootContent = popupFrame->GetContent();
           NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
         }
       }
     }
     else {
       // There is no parent, so call the tree owner. This will tell the
diff --git a/dom/events/EventStateManager.cpp b/dom/events/EventStateManager.cpp
--- a/dom/events/EventStateManager.cpp
+++ b/dom/events/EventStateManager.cpp
@@ -2734,20 +2734,20 @@ EventStateManager::DecideGestureEvent(Wi
     // assist is solving this.
     if (current && IsRemoteTarget(current->GetContent())) {
       panDirection = WidgetGestureNotifyEvent::ePanBoth;
       // We don't know when we reach bounds, so just disable feedback for now.
       displayPanFeedback = false;
       break;
     }
 
-    FrameType currentFrameType = current->Type();
+    mozilla::FrameType currentFrameType = current->Type();
 
     // Scrollbars should always be draggable
-    if (currentFrameType == FrameType::Scrollbar) {
+    if (currentFrameType == mozilla::FrameType::Scrollbar) {
       panDirection = WidgetGestureNotifyEvent::ePanNone;
       break;
     }
 
 #ifdef MOZ_XUL
     // Special check for trees
     nsTreeBodyFrame* treeFrame = do_QueryFrame(current);
     if (treeFrame) {
diff --git a/layout/base/AccessibleCaretManager.cpp b/layout/base/AccessibleCaretManager.cpp
--- a/layout/base/AccessibleCaretManager.cpp
+++ b/layout/base/AccessibleCaretManager.cpp
@@ -1260,17 +1260,17 @@ AccessibleCaretManager::DragCaretInterna
   }
 
   ClearMaintainedSelection();
 
   nsIFrame* anchorFrame = nullptr;
   selection->GetPrimaryFrameForAnchorNode(&anchorFrame);
 
   nsIFrame* scrollable =
-    nsLayoutUtils::GetClosestFrameOfType(anchorFrame, FrameType::Scroll);
+    nsLayoutUtils::GetClosestFrameOfType(anchorFrame, mozilla::FrameType::Scroll);
   AutoWeakFrame weakScrollable = scrollable;
   fs->HandleClick(offsets.content, offsets.StartOffset(), offsets.EndOffset(),
                   GetCaretMode() == CaretMode::Selection, false,
                   offsets.associate);
   if (!weakScrollable.IsAlive()) {
     return NS_OK;
   }
 
diff --git a/layout/base/GeckoRestyleManager.cpp b/layout/base/GeckoRestyleManager.cpp
--- a/layout/base/GeckoRestyleManager.cpp
+++ b/layout/base/GeckoRestyleManager.cpp
@@ -856,26 +856,26 @@ GetPrevContinuationWithSameStyle(nsIFram
     prevContinuation = nullptr;
   }
   return prevContinuation;
 }
 
 nsresult
 GeckoRestyleManager::ReparentStyleContext(nsIFrame* aFrame)
 {
-  FrameType frameType = aFrame->Type();
-  if (frameType == FrameType::Placeholder) {
+  mozilla::FrameType frameType = aFrame->Type();
+  if (frameType == mozilla::FrameType::Placeholder) {
     // Also reparent the out-of-flow and all its continuations.
     nsIFrame* outOfFlow =
       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     NS_ASSERTION(outOfFlow, "no out-of-flow frame");
     do {
       ReparentStyleContext(outOfFlow);
     } while ((outOfFlow = outOfFlow->GetNextContinuation()));
-  } else if (frameType == FrameType::Backdrop) {
+  } else if (frameType == mozilla::FrameType::Backdrop) {
     // Style context of backdrop frame has no parent style context, and
     // thus we do not need to reparent it.
     return NS_OK;
   }
 
   // DO NOT verify the style tree before reparenting.  The frame
   // tree has already been changed, so this check would just fail.
   nsStyleContext* oldContext = aFrame->StyleContext();
@@ -1655,18 +1655,18 @@ ElementRestyler::MoveStyleContextsForCon
       // FIXME: It is probably safe to just continue here instead of bailing out.
       if (child->IsPlaceholderFrame()) {
         return false;
       }
       nsStyleContext* sc = child->StyleContext();
       if (sc->GetParent() != aOldContext) {
         return false;
       }
-      FrameType type = child->Type();
-      if (type == FrameType::Letter || type == FrameType::Line) {
+      mozilla::FrameType type = child->Type();
+      if (type == mozilla::FrameType::Letter || type == mozilla::FrameType::Line) {
         return false;
       }
       if (sc->HasChildThatUsesGrandancestorStyle()) {
         // XXX Not sure if we need this?
         return false;
       }
       nsIAtom* pseudoTag = sc->GetPseudo();
       if (pseudoTag && !nsCSSAnonBoxes::IsNonElement(pseudoTag)) {
@@ -2063,26 +2063,26 @@ ElementRestyler::ComputeRestyleResultFro
     return;
   }
 
   // Style changes might have moved children between the two nsLetterFrames
   // (the one matching ::first-letter and the one containing the rest of the
   // content).  Continue restyling to the children of the nsLetterFrame so
   // that they get the correct style context parent.  Similarly for
   // nsLineFrames.
-  FrameType type = aSelf->Type();
-
-  if (type == FrameType::Letter) {
+  mozilla::FrameType type = aSelf->Type();
+
+  if (type == mozilla::FrameType::Letter) {
     LOG_RESTYLE_CONTINUE("frame is a letter frame");
     aRestyleResult = RestyleResult::eContinue;
     aCanStopWithStyleChange = false;
     return;
   }
 
-  if (type == FrameType::Line) {
+  if (type == mozilla::FrameType::Line) {
     LOG_RESTYLE_CONTINUE("frame is a line frame");
     aRestyleResult = RestyleResult::eContinue;
     aCanStopWithStyleChange = false;
     return;
   }
 
   // Some style computations depend not on the parent's style, but a grandparent
   // or one the grandparent's ancestors.  An example is an explicit 'inherit'
diff --git a/layout/base/PresShell.cpp b/layout/base/PresShell.cpp
--- a/layout/base/PresShell.cpp
+++ b/layout/base/PresShell.cpp
@@ -3528,17 +3528,17 @@ PresShell::DoScrollContentIntoView()
     // coords and size are all zero, and it has no content showing anyway.
     // Don't bother scrolling to it.  We'll try again when we finish up layout.
     return;
   }
 
   // Make sure we skip 'frame' ... if it's scrollable, we should use its
   // scrollable ancestor as the container.
   nsIFrame* container =
-    nsLayoutUtils::GetClosestFrameOfType(frame->GetParent(), FrameType::Scroll);
+    nsLayoutUtils::GetClosestFrameOfType(frame->GetParent(), mozilla::FrameType::Scroll);
   if (!container) {
     // nothing can be scrolled
     return;
   }
 
   ScrollIntoViewData* data = static_cast<ScrollIntoViewData*>(
     mContentToScrollTo->GetProperty(nsGkAtoms::scrolling));
   if (MOZ_UNLIKELY(!data)) {
diff --git a/layout/base/RestyleManager.cpp b/layout/base/RestyleManager.cpp
--- a/layout/base/RestyleManager.cpp
+++ b/layout/base/RestyleManager.cpp
@@ -1074,17 +1074,17 @@ DoApplyRenderingChangeToTree(nsIFrame* a
       }
     }
     if (aChange & nsChangeHint_UpdateTextPath) {
       if (nsSVGUtils::IsInSVGTextSubtree(aFrame)) {
         // Invalidate and reflow the entire SVGTextFrame:
         NS_ASSERTION(aFrame->GetContent()->IsSVGElement(nsGkAtoms::textPath),
                      "expected frame for a <textPath> element");
         nsIFrame* text =
-          nsLayoutUtils::GetClosestFrameOfType(aFrame, FrameType::SVGText);
+          nsLayoutUtils::GetClosestFrameOfType(aFrame, mozilla::FrameType::SVGText);
         NS_ASSERTION(text, "expected to find an ancestor SVGTextFrame");
         static_cast<SVGTextFrame*>(text)->NotifyGlyphMetricsChange();
       } else {
         MOZ_ASSERT(false, "unexpected frame got nsChangeHint_UpdateTextPath");
       }
     }
     if (aChange & nsChangeHint_UpdateOpacityLayer) {
       // FIXME/bug 796697: we can get away with empty transactions for
diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp
--- a/layout/base/nsLayoutUtils.cpp
+++ b/layout/base/nsLayoutUtils.cpp
@@ -1527,35 +1527,35 @@ nsLayoutUtils::GetChildListNameFor(nsIFr
       id = nsIFrame::kPopupList;
 #endif // MOZ_XUL
     } else {
       NS_ASSERTION(aChildFrame->IsFloating(), "not a floated frame");
       id = nsIFrame::kFloatList;
     }
 
   } else {
-    FrameType childType = aChildFrame->Type();
-    if (FrameType::MenuPopup == childType) {
+    mozilla::FrameType childType = aChildFrame->Type();
+    if (mozilla::FrameType::MenuPopup == childType) {
       nsIFrame* parent = aChildFrame->GetParent();
       MOZ_ASSERT(parent, "nsMenuPopupFrame can't be the root frame");
       if (parent) {
         if (parent->IsPopupSetFrame()) {
           id = nsIFrame::kPopupList;
         } else {
           nsIFrame* firstPopup = parent->GetChildList(nsIFrame::kPopupList).FirstChild();
           MOZ_ASSERT(!firstPopup || !firstPopup->GetNextSibling(),
                      "We assume popupList only has one child, but it has more.");
           id = firstPopup == aChildFrame
                  ? nsIFrame::kPopupList
                  : nsIFrame::kPrincipalList;
         }
       } else {
         id = nsIFrame::kPrincipalList;
       }
-    } else if (FrameType::TableColGroup == childType) {
+    } else if (mozilla::FrameType::TableColGroup == childType) {
       id = nsIFrame::kColGroupList;
     } else if (aChildFrame->IsTableCaption()) {
       id = nsIFrame::kCaptionList;
     } else {
       id = nsIFrame::kPrincipalList;
     }
   }
 
@@ -1617,34 +1617,34 @@ nsLayoutUtils::GetAfterFrame(const nsICo
 {
   Element* pseudo = GetAfterPseudo(aContent);
   return pseudo ? pseudo->GetPrimaryFrame() : nullptr;
 }
 
 // static
 nsIFrame*
 nsLayoutUtils::GetClosestFrameOfType(nsIFrame* aFrame,
-                                     FrameType aFrameType,
+                                     mozilla::FrameType aFrameType,
                                      nsIFrame* aStopAt)
 {
   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
     if (frame->Type() == aFrameType) {
       return frame;
     }
     if (frame == aStopAt) {
       break;
     }
   }
   return nullptr;
 }
 
 /* static */ nsIFrame*
 nsLayoutUtils::GetPageFrame(nsIFrame* aFrame)
 {
-  return GetClosestFrameOfType(aFrame, FrameType::Page);
+  return GetClosestFrameOfType(aFrame, mozilla::FrameType::Page);
 }
 
 // static
 nsIFrame*
 nsLayoutUtils::GetStyleFrame(nsIFrame* aFrame)
 {
   if (aFrame->IsTableWrapperFrame()) {
     nsIFrame* inner = aFrame->PrincipalChildList().FirstChild();
@@ -2892,17 +2892,17 @@ nsLayoutUtils::ContainsPoint(const nsRec
   rect.Inflate(aInflateSize);
   return rect.Contains(aPoint);
 }
 
 nsRect
 nsLayoutUtils::ClampRectToScrollFrames(nsIFrame* aFrame, const nsRect& aRect)
 {
   nsIFrame* closestScrollFrame =
-    nsLayoutUtils::GetClosestFrameOfType(aFrame, FrameType::Scroll);
+    nsLayoutUtils::GetClosestFrameOfType(aFrame, mozilla::FrameType::Scroll);
 
   nsRect resultRect = aRect;
 
   while (closestScrollFrame) {
     nsIScrollableFrame* sf = do_QueryFrame(closestScrollFrame);
 
     nsRect scrollPortRect = sf->GetScrollPortRect();
     nsLayoutUtils::TransformRect(closestScrollFrame, aFrame, scrollPortRect);
@@ -2912,17 +2912,17 @@ nsLayoutUtils::ClampRectToScrollFrames(n
     // Check whether aRect is visible in the scroll frame or not.
     if (resultRect.IsEmpty()) {
       break;
     }
 
     // Get next ancestor scroll frame.
     closestScrollFrame =
       nsLayoutUtils::GetClosestFrameOfType(closestScrollFrame->GetParent(),
-                                           FrameType::Scroll);
+                                           mozilla::FrameType::Scroll);
   }
 
   return resultRect;
 }
 
 bool
 nsLayoutUtils::GetLayerTransformForFrame(nsIFrame* aFrame,
                                          Matrix4x4* aTransform)
@@ -3010,17 +3010,17 @@ static SVGTextFrame*
 GetContainingSVGTextFrame(nsIFrame* aFrame)
 {
   if (!nsSVGUtils::IsInSVGTextSubtree(aFrame)) {
     return nullptr;
   }
 
   return static_cast<SVGTextFrame*>
     (nsLayoutUtils::GetClosestFrameOfType(aFrame->GetParent(),
-                                          FrameType::SVGText));
+                                          mozilla::FrameType::SVGText));
 }
 
 nsPoint
 nsLayoutUtils::TransformAncestorPointToFrame(nsIFrame* aFrame,
                                              const nsPoint& aPoint,
                                              nsIFrame* aAncestor)
 {
     SVGTextFrame* text = GetContainingSVGTextFrame(aFrame);
@@ -3591,28 +3591,28 @@ nsLayoutUtils::PaintFrame(nsRenderingCon
         }
       }
 
       nsDisplayListBuilder::AutoCurrentScrollParentIdSetter idSetter(&builder, id);
 
       aFrame->BuildDisplayListForStackingContext(&builder, dirtyRect, &list);
     }
 
-    FrameType frameType = aFrame->Type();
+    mozilla::FrameType frameType = aFrame->Type();
 
     // For the viewport frame in print preview/page layout we want to paint
     // the grey background behind the page, not the canvas color.
-    if (frameType == FrameType::Viewport &&
+    if (frameType == mozilla::FrameType::Viewport &&
         nsLayoutUtils::NeedsPrintPreviewBackground(presContext)) {
       nsRect bounds = nsRect(builder.ToReferenceFrame(aFrame),
                              aFrame->GetSize());
       nsDisplayListBuilder::AutoBuildingDisplayList
         buildingDisplayList(&builder, aFrame, bounds, false);
       presShell->AddPrintPreviewBackgroundItem(builder, list, aFrame, bounds);
-    } else if (frameType != FrameType::Page) {
+    } else if (frameType != mozilla::FrameType::Page) {
       // For printing, this function is first called on an nsPageFrame, which
       // creates a display list with a PageContent item. The PageContent item's
       // paint function calls this function on the nsPageFrame's child which is
       // an nsPageContentFrame. We only want to add the canvas background color
       // item once, for the nsPageContentFrame.
 
       // Add the canvas background color to the bottom of the list. This
       // happens after we've built the list so that AddCanvasBackgroundColorItem
@@ -4652,19 +4652,19 @@ GetPercentBSize(const nsStyleCoord& aSty
   const nsStylePosition *pos = f->StylePosition();
   const nsStyleCoord& bSizeCoord = pos->BSize(wm);
   nscoord h;
   if (!GetAbsoluteCoord(bSizeCoord, h) &&
       !GetPercentBSize(bSizeCoord, f, aHorizontalAxis, h)) {
     NS_ASSERTION(bSizeCoord.GetUnit() == eStyleUnit_Auto ||
                  bSizeCoord.HasPercent(),
                  "unknown block-size unit");
-    FrameType fType = f->Type();
-    if (fType != FrameType::Viewport && fType != FrameType::Canvas &&
-        fType != FrameType::PageContent) {
+    mozilla::FrameType fType = f->Type();
+    if (fType != mozilla::FrameType::Viewport && fType != mozilla::FrameType::Canvas &&
+        fType != mozilla::FrameType::PageContent) {
       // There's no basis for the percentage height, so it acts like auto.
       // Should we consider a max-height < min-height pair a basis for
       // percentage heights?  The spec is somewhat unclear, and not doing
       // so is simpler and avoids troubling discontinuities in behavior,
       // so I'll choose not to. -LDB
       return false;
     }
 
@@ -4830,31 +4830,31 @@ static int32_t gNoiseIndent = 0;
 inline static bool
 FormControlShrinksForPercentISize(nsIFrame* aFrame)
 {
   if (!aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
     // Quick test to reject most frames.
     return false;
   }
 
-  FrameType fType = aFrame->Type();
-  if (fType == FrameType::Meter || fType == FrameType::Progress) {
+  mozilla::FrameType fType = aFrame->Type();
+  if (fType == mozilla::FrameType::Meter || fType == mozilla::FrameType::Progress) {
     // progress and meter do have this shrinking behavior
     // FIXME: Maybe these should be nsIFormControlFrame?
     return true;
   }
 
   if (!static_cast<nsIFormControlFrame*>(do_QueryFrame(aFrame))) {
     // Not a form control.  This includes fieldsets, which do not
     // shrink.
     return false;
   }
 
-  if (fType == FrameType::GfxButtonControl ||
-      fType == FrameType::HTMLButtonControl) {
+  if (fType == mozilla::FrameType::GfxButtonControl ||
+      fType == mozilla::FrameType::HTMLButtonControl) {
     // Buttons don't have this shrinking behavior.  (Note that color
     // inputs do, even though they inherit from button, so we can't use
     // do_QueryFrame here.)
     return false;
   }
 
   return true;
 }
@@ -5962,25 +5962,25 @@ nsLayoutUtils::GetFirstLineBaseline(Writ
 nsLayoutUtils::GetFirstLinePosition(WritingMode aWM,
                                     const nsIFrame* aFrame,
                                     LinePosition* aResult)
 {
   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
   if (!block) {
     // For the first-line baseline we also have to check for a table, and if
     // so, use the baseline of its first row.
-    FrameType fType = aFrame->Type();
-    if (fType == FrameType::TableWrapper  ||
-        fType == FrameType::FlexContainer ||
-        fType == FrameType::GridContainer) {
-      if ((fType == FrameType::GridContainer &&
+    mozilla::FrameType fType = aFrame->Type();
+    if (fType == mozilla::FrameType::TableWrapper  ||
+        fType == mozilla::FrameType::FlexContainer ||
+        fType == mozilla::FrameType::GridContainer) {
+      if ((fType == mozilla::FrameType::GridContainer &&
            aFrame->HasAnyStateBits(NS_STATE_GRID_SYNTHESIZE_BASELINE)) ||
-          (fType == FrameType::FlexContainer &&
+          (fType == mozilla::FrameType::FlexContainer &&
            aFrame->HasAnyStateBits(NS_STATE_FLEX_SYNTHESIZE_BASELINE)) ||
-          (fType == FrameType::TableWrapper &&
+          (fType == mozilla::FrameType::TableWrapper &&
            static_cast<const nsTableWrapperFrame*>(aFrame)->GetRowCount() == 0)) {
         // empty grid/flex/table container
         aResult->mBStart = 0;
         aResult->mBaseline = aFrame->SynthesizeBaselineBOffsetFromBorderBox(aWM,
                                        BaselineSharingGroup::eFirst);
         aResult->mBEnd = aFrame->BSize(aWM);
         return true;
       }
@@ -5988,17 +5988,17 @@ nsLayoutUtils::GetFirstLinePosition(Writ
       aResult->mBaseline = aFrame->GetLogicalBaseline(aWM);
       // This is what we want for the list bullet caller; not sure if
       // other future callers will want the same.
       aResult->mBEnd = aFrame->BSize(aWM);
       return true;
     }
 
     // For first-line baselines, we have to consider scroll frames.
-    if (fType == FrameType::Scroll) {
+    if (fType == mozilla::FrameType::Scroll) {
       nsIScrollableFrame *sFrame = do_QueryFrame(const_cast<nsIFrame*>(aFrame));
       if (!sFrame) {
         NS_NOTREACHED("not scroll frame");
       }
       LinePosition kidPosition;
       if (GetFirstLinePosition(aWM,
                                sFrame->GetScrolledFrame(), &kidPosition)) {
         // Consider only the border and padding that contributes to the
@@ -6006,17 +6006,17 @@ nsLayoutUtils::GetFirstLinePosition(Writ
         // position.
         *aResult = kidPosition +
           aFrame->GetLogicalUsedBorderAndPadding(aWM).BStart(aWM);
         return true;
       }
       return false;
     }
 
-    if (fType == FrameType::FieldSet) {
+    if (fType == mozilla::FrameType::FieldSet) {
       LinePosition kidPosition;
       nsIFrame* kid = aFrame->PrincipalChildList().FirstChild();
       // kid might be a legend frame here, but that's ok.
       if (GetFirstLinePosition(aWM, kid, &kidPosition)) {
         *aResult = kidPosition +
           kid->GetLogicalNormalPosition(aWM, aFrame->GetSize()).B(aWM);
         return true;
       }
@@ -6937,24 +6937,24 @@ nsLayoutUtils::GetFrameTransparency(nsIF
       bg->BottomLayer().mClip != StyleGeometryBox::BorderBox)
     return eTransparencyTransparent;
   return eTransparencyOpaque;
 }
 
 static bool IsPopupFrame(nsIFrame* aFrame)
 {
   // aFrame is a popup it's the list control frame dropdown for a combobox.
-  FrameType frameType = aFrame->Type();
-  if (frameType == FrameType::ListControl) {
+  mozilla::FrameType frameType = aFrame->Type();
+  if (frameType == mozilla::FrameType::ListControl) {
     nsListControlFrame* lcf = static_cast<nsListControlFrame*>(aFrame);
     return lcf->IsInDropDownMode();
   }
 
   // ... or if it's a XUL menupopup frame.
-  return frameType == FrameType::MenuPopup;
+  return frameType == mozilla::FrameType::MenuPopup;
 }
 
 /* static */ bool
 nsLayoutUtils::IsPopup(nsIFrame* aFrame)
 {
   // Optimization: the frame can't possibly be a popup if it has no view.
   if (!aFrame->HasView()) {
     NS_ASSERTION(!IsPopupFrame(aFrame), "popup frame must have a view");
@@ -7121,19 +7121,19 @@ nsLayoutUtils::GetDeviceContextForScreen
 nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
 {
   NS_PRECONDITION(aFrame->GetParent(),
                   "IsReallyFixedPos called on frame not in tree");
   NS_PRECONDITION(aFrame->StyleDisplay()->mPosition ==
                     NS_STYLE_POSITION_FIXED,
                   "IsReallyFixedPos called on non-'position:fixed' frame");
 
-  FrameType parentType = aFrame->GetParent()->Type();
-  return parentType == FrameType::Viewport ||
-         parentType == FrameType::PageContent;
+  mozilla::FrameType parentType = aFrame->GetParent()->Type();
+  return parentType == mozilla::FrameType::Viewport ||
+         parentType == mozilla::FrameType::PageContent;
 }
 
 nsLayoutUtils::SurfaceFromElementResult
 nsLayoutUtils::SurfaceFromOffscreenCanvas(OffscreenCanvas* aOffscreenCanvas,
                                           uint32_t aSurfaceFlags,
                                           RefPtr<DrawTarget>& aTarget)
 {
   SurfaceFromElementResult result;
@@ -7932,29 +7932,29 @@ nsLayoutUtils::FontSizeInflationInner(co
 
   // If between this current frame and its font inflation container there is a
   // non-inline element with fixed width or height, then we should not inflate
   // fonts for this frame.
   for (const nsIFrame* f = aFrame;
        f && !f->IsContainerForFontSizeInflation();
        f = f->GetParent()) {
     nsIContent* content = f->GetContent();
-    FrameType fType = f->Type();
+    mozilla::FrameType fType = f->Type();
     nsIFrame* parent = f->GetParent();
     // Also, if there is more than one frame corresponding to a single
     // content node, we want the outermost one.
     if (!(parent && parent->GetContent() == content) &&
         // ignore width/height on inlines since they don't apply
-        fType != FrameType::Inline &&
+        fType != mozilla::FrameType::Inline &&
         // ignore width on radios and checkboxes since we enlarge them and
         // they have width/height in ua.css
-        fType != FrameType::FormControl) {
+        fType != mozilla::FrameType::FormControl) {
       // ruby annotations should have the same inflation as its
       // grandparent, which is the ruby frame contains the annotation.
-      if (fType == FrameType::RubyText) {
+      if (fType == mozilla::FrameType::RubyText) {
         MOZ_ASSERT(parent && parent->IsRubyTextContainerFrame());
         nsIFrame* grandparent = parent->GetParent();
         MOZ_ASSERT(grandparent && grandparent->IsRubyFrame());
         return FontSizeInflationFor(grandparent);
       }
       nsStyleCoord stylePosWidth = f->StylePosition()->mWidth;
       nsStyleCoord stylePosHeight = f->StylePosition()->mHeight;
       if (stylePosWidth.GetUnit() != eStyleUnit_Auto ||
diff --git a/layout/generic/ReflowInput.h b/layout/generic/ReflowInput.h
--- a/layout/generic/ReflowInput.h
+++ b/layout/generic/ReflowInput.h
@@ -960,17 +960,17 @@ public:
   static void* DisplayInitFrameTypeEnter(nsIFrame* aFrame,
                                          ReflowInput* aState);
   static void DisplayInitFrameTypeExit(nsIFrame* aFrame,
                                        ReflowInput* aState,
                                        void* aValue);
 #endif
 
 protected:
-  void InitFrameType(FrameType aFrameType);
+  void InitFrameType(mozilla::FrameType aFrameType);
   void InitCBReflowInput();
   void InitResizeFlags(nsPresContext* aPresContext,
                        mozilla::FrameType aFrameType);
 
   void InitConstraints(nsPresContext* aPresContext,
                        const mozilla::LogicalSize& aContainingBlockSize,
                        const nsMargin* aBorder,
                        const nsMargin* aPadding,
@@ -1009,14 +1009,14 @@ protected:
   // aInsideBoxSizing returns the part of the padding, border, and margin
   // in the aAxis dimension that goes inside the edge given by box-sizing;
   // aOutsideBoxSizing returns the rest.
   void CalculateBorderPaddingMargin(mozilla::LogicalAxis aAxis,
                                     nscoord aContainingBlockSize,
                                     nscoord* aInsideBoxSizing,
                                     nscoord* aOutsideBoxSizing) const;
 
-  void CalculateBlockSideMargins(FrameType aFrameType);
+  void CalculateBlockSideMargins(mozilla::FrameType aFrameType);
 };
 
 } // namespace mozilla
 
 #endif // mozilla_ReflowInput_h
diff --git a/layout/generic/RubyUtils.h b/layout/generic/RubyUtils.h
--- a/layout/generic/RubyUtils.h
+++ b/layout/generic/RubyUtils.h
@@ -50,29 +50,29 @@ namespace mozilla {
  *    one of its ruby text containers does.
  * 3. If a ruby text container has a larger final isize, its children
  *    must not have.
  */
 
 class RubyUtils
 {
 public:
-  static inline bool IsRubyContentBox(FrameType aFrameType)
+  static inline bool IsRubyContentBox(mozilla::FrameType aFrameType)
   {
     return aFrameType == mozilla::FrameType::RubyBase ||
            aFrameType == mozilla::FrameType::RubyText;
   }
 
-  static inline bool IsRubyContainerBox(FrameType aFrameType)
+  static inline bool IsRubyContainerBox(mozilla::FrameType aFrameType)
   {
     return aFrameType == mozilla::FrameType::RubyBaseContainer ||
            aFrameType == mozilla::FrameType::RubyTextContainer;
   }
 
-  static inline bool IsRubyBox(FrameType aFrameType)
+  static inline bool IsRubyBox(mozilla::FrameType aFrameType)
   {
     return aFrameType == mozilla::FrameType::Ruby ||
            IsRubyContentBox(aFrameType) || IsRubyContainerBox(aFrameType);
   }
 
   static inline bool IsExpandableRubyBox(nsIFrame* aFrame)
   {
     mozilla::FrameType type = aFrame->Type();
