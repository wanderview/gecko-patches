# HG changeset patch
# User Ben Kelly <ben@wanderview.com>
# Parent  de67fccc4c64a49f261aea29141357b94c7b3b9c
Bug 1331038 P2 Add a gtest to verify nsPipe handles OOM gracefully. r=froydnj

diff --git a/xpcom/tests/gtest/TestPipes.cpp b/xpcom/tests/gtest/TestPipes.cpp
--- a/xpcom/tests/gtest/TestPipes.cpp
+++ b/xpcom/tests/gtest/TestPipes.cpp
@@ -1066,16 +1066,74 @@ TEST(Pipes, Close_During_Read_Partial_Se
   TestCloseDuringRead(1024, 512);
 }
 
 TEST(Pipes, Close_During_Read_Full_Segment)
 {
   TestCloseDuringRead(1024, 1024);
 }
 
+nsresult
+MakeLargePipe(const nsTArray<char>& aData, nsIAsyncOutputStream** aWriterOut)
+{
+  nsCOMPtr<nsIAsyncInputStream> reader;
+  nsCOMPtr<nsIAsyncOutputStream> writer;
+
+  // Use the max segment size (4GB).  We can't have a bigger pipe even
+  // with multiple segments because nsPipe::Init() truncates to avoid
+  // overflow.
+  const uint32_t segmentSize = UINT32_MAX;
+  const uint32_t numSegments = 1;
+
+  nsresult rv = NS_NewPipe2(getter_AddRefs(reader), getter_AddRefs(writer),
+                            true, true,  // non-blocking - reader, writer
+                            segmentSize, numSegments);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  // Write some data to allocate a segment.
+  uint32_t numWritten = 0;
+  rv = writer->Write(aData.Elements(), aData.Length(), &numWritten);
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  writer.forget(aWriterOut);
+  return NS_OK;
+}
+
+TEST(Pipes, OOM)
+{
+  const uint32_t dataSize = 4;
+  nsTArray<char> inputData;
+  testing::CreateData(dataSize, inputData);
+
+  nsTArray<nsCOMPtr<nsIAsyncOutputStream>> writerList;
+
+  // We can't just allocate a single large pipe and force it to OOM.  Thanks
+  // to nsPipe::Init() anti-overflow checking we are effectively limited to
+  // 4GB per pipe.  There are many systems in the world where this will not
+  // OOM.  Therefore, force an OOM by creating many 4GB pipes.  We hold them
+  // alive as we create them and expect to OOM before we get too far.
+  while (true) {
+    nsCOMPtr<nsIAsyncOutputStream> writer;
+    nsresult rv = MakeLargePipe(inputData, getter_AddRefs(writer));
+    if (NS_FAILED(rv)) {
+      // This should have failed due to a memory limitations.
+      ASSERT_EQ(NS_ERROR_OUT_OF_MEMORY, rv);
+      return;
+    }
+    writerList.AppendElement(writer.forget());
+  }
+
+  // We should never get here.
+  ASSERT_TRUE(false);
+}
+
 TEST(Pipes, Interfaces)
 {
   nsCOMPtr<nsIInputStream> reader;
   nsCOMPtr<nsIOutputStream> writer;
 
   nsresult rv = NS_NewPipe(getter_AddRefs(reader), getter_AddRefs(writer));
   ASSERT_TRUE(NS_SUCCEEDED(rv));
 
